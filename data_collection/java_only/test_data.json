[
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(boolean condition) {\n        assertFalse(null, condition);\n    }",
    "comment": "Asserts that a condition is false. If it isn't it throws\nan AssertionFailedError."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "assertEventsMatchLoosely",
    "code": "public final void assertEventsMatchLoosely(Condition<? super Event>... conditions) {\n\t\tPreconditions.notNull(conditions, \"conditions must not be null\");\n\t\tPreconditions.containsNoNullElements(conditions, \"conditions must not contain null elements\");\n\t\tassertEventsMatchLoosely(this.events, conditions);\n\t}",
    "comment": "Assert that all provided conditions are matched by an {@linkplain Event event}\ncontained in this {@code Events} object, regardless of order.\n\n<p>Note that this method performs a partial match. Thus, some events may\nnot match any of the provided conditions.\n\n<p>Conditions can be imported statically from {@link EventConditions}\nand {@link TestExecutionResultConditions}.\n\n<h4>Example</h4>\n\n<pre class=\"code\">\nexecutionResults.testEvents().assertEventsMatchLoosely(\nevent(test(\"exampleTestMethod\"), started()),\nevent(test(\"exampleTestMethod\"), finishedSuccessfully())\n);\n</pre>\n\n@param conditions the conditions to match against; never {@code null}\n@since 1.7\n@see #assertEventsMatchExactly(Condition...)\n@see #assertEventsMatchLooselyInOrder(Condition...)\n@see EventConditions\n@see TestExecutionResultConditions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng6057CheckReactorOrderTest.java",
    "type": "method",
    "name": "extractReactorBuildOrder",
    "code": "private List<String> extractReactorBuildOrder(List<String> loadedLines) {\n        List<String> resultingLines = new LinkedList<>();\n        boolean start = false;\n        for (String line : loadedLines) {\n            if (start) {\n                if (line.startsWith(\"[INFO] -------------\")) {\n                    start = false;\n                } else if (!line.endsWith(\"[INFO] \")) {\n                    resultingLines.add(line);\n                }\n            } else {\n                if (line.startsWith(\"[INFO] Reactor Build Order:\")) {\n                    start = true;\n                }\n            }\n        }\n        return resultingLines;\n    }",
    "comment": "Extract the lines at the beginning of the Maven output:\n\n<pre>\n[INFO] Reactor Build Order:\n[INFO]\n[INFO] module-1\n[INFO] module-2\n[INFO] base-project\n[INFO]\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "addSparkArg",
    "code": "public T addSparkArg(String name, String value) {\n    SparkSubmitOptionParser validator = new ArgumentValidator(true);\n    if (validator.MASTER.equals(name)) {\n      setMaster(value);\n    } else if (validator.REMOTE.equals(name)) {\n      setRemote(value);\n    } else if (validator.PROPERTIES_FILE.equals(name)) {\n      setPropertiesFile(value);\n    } else if (validator.CONF.equals(name)) {\n      String[] vals = value.split(\"=\", 2);\n      setConf(vals[0], vals[1]);\n    } else if (validator.CLASS.equals(name)) {\n      setMainClass(value);\n    } else if (validator.JARS.equals(name)) {\n      builder.jars.clear();\n      for (String jar : value.split(\",\")) {\n        addJar(jar);\n      }\n    } else if (validator.FILES.equals(name)) {\n      builder.files.clear();\n      for (String file : value.split(\",\")) {\n        addFile(file);\n      }\n    } else if (validator.PY_FILES.equals(name)) {\n      builder.pyFiles.clear();\n      for (String file : value.split(\",\")) {\n        addPyFile(file);\n      }\n    } else {\n      validator.parse(Arrays.asList(name, value));\n      builder.userArgs.add(name);\n      builder.userArgs.add(value);\n    }\n    return self();\n  }",
    "comment": "Adds an argument with a value to the Spark invocation. If the argument name corresponds to\na known argument, the code validates that the argument actually expects a value, and throws\nan exception otherwise.\n<p>\nIt is safe to add arguments modified by other methods in this class (such as\n{@link #setMaster(String)} - the last invocation will be the one to take effect.\n<p>\nUse this method with caution. It is possible to create an invalid Spark command by passing\nunknown arguments to this method, since those are allowed for forward compatibility.\n\n@since 1.5.0\n@param name Name of argument to add.\n@param value Value of the argument.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/test/org/apache/spark/Java8RDDAPISuite.java",
    "type": "method",
    "name": "zip",
    "code": "public void zip() {\n    JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1, 2, 3, 4, 5));\n    JavaDoubleRDD doubles = rdd.mapToDouble(x -> 1.0 * x);\n    JavaPairRDD<Integer, Double> zipped = rdd.zip(doubles);\n    zipped.count();\n  }",
    "comment": "Try reading the output back as an object file"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/intercepting-filter/src/main/java/com/iluwatar/intercepting/filter/NameFilter.java",
    "type": "method",
    "name": "execute",
    "code": "public String execute(Order order) {\n    var result = super.execute(order);\n    var name = order.getName();\n    if (name == null || name.isEmpty() || name.matches(\".*[^\\\\w|\\\\s]+.*\")) {\n      return result + \"Invalid name! \";\n    } else {\n      return result;\n    }\n  }",
    "comment": "Concrete implementation of filter. This filter checks if the input in the Name field is valid.\n(alphanumeric)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/api/plugin/DriverPlugin.java",
    "type": "method",
    "name": "init",
    "code": "default Map<String, String> init(SparkContext sc, PluginContext pluginContext) {\n    return Collections.emptyMap();\n  }",
    "comment": "Initialize the plugin.\n<p>\nThis method is called early in the initialization of the Spark driver. Explicitly, it is\ncalled before the Spark driver's task scheduler is initialized. This means that a lot\nof other Spark subsystems may yet not have been initialized. This call also blocks driver\ninitialization.\n<p>\nIt's recommended that plugins be careful about what operations are performed in this call,\npreferably performing expensive operations in a separate thread, or postponing them until\nthe application has fully started.\n\n@param sc The SparkContext loading the plugin.\n@param pluginContext Additional plugin-specific about the Spark application where the plugin\nis running.\n@return A map that will be provided to the {@link ExecutorPlugin#init(PluginContext,Map)}\nmethod."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicTest.java",
    "type": "method",
    "name": "dynamicTest",
    "code": "public static DynamicTest dynamicTest(String displayName, Executable executable) {\n\t\treturn new DynamicTest(displayName, null, executable);\n\t}",
    "comment": "Factory for creating a new {@code DynamicTest} for the supplied display\n@param executable the executable code block for the dynamic test;\nnever {@code null}\n@see #stream(Iterator, Function, ThrowingConsumer)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/MavenSession.java",
    "type": "method",
    "name": "setProjects",
    "code": "public void setProjects(List<MavenProject> projects) {\n        if (!projects.isEmpty()) {\n            MavenProject first = projects.get(0);\n            this.currentProject = ThreadLocal.withInitial(() -> first);\n            this.topLevelProject = projects.stream()\n                    .filter(project -> project.isExecutionRoot())\n                    .findFirst()\n                    .orElse(first);\n        } else {\n            this.currentProject = new ThreadLocal<>();\n            this.topLevelProject = null;\n        }\n        this.projects = projects;\n    }",
    "comment": "Plugin context keyed by project ({@link MavenProject#getId()}) and by plugin lookup key\n({@link PluginDescriptor#getPluginLookupKey()}). Plugin contexts itself are mappings of {@link String} keys to\n{@link Object} values."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-builder-support/src/test/java/org/apache/maven/building/DefaultProblemTest.java",
    "type": "method",
    "name": "testGetColumnNumber",
    "code": "void testGetColumnNumber() {\n        DefaultProblem problem = new DefaultProblem(null, null, null, -1, -1, null);\n        assertEquals(-1, problem.getColumnNumber());\n\n        problem = new DefaultProblem(null, null, null, -1, 42, null);\n        assertEquals(42, problem.getColumnNumber());\n\n        problem = new DefaultProblem(null, null, null, -1, Integer.MAX_VALUE, null);\n        assertEquals(Integer.MAX_VALUE, problem.getColumnNumber());\n\n        problem = new DefaultProblem(null, null, null, -1, Integer.MIN_VALUE, null);\n        assertEquals(Integer.MIN_VALUE, problem.getColumnNumber());\n    }",
    "comment": "this case is not specified, might also return -1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/AssumptionViolatedException.java",
    "type": "method",
    "name": "AssumptionViolatedException",
    "code": "public AssumptionViolatedException(Object value, Matcher<?> matcher) {\n        this(null, true, value, matcher);\n    }",
    "comment": "An assumption exception with the given <i>value</i> (String or\nThrowable) and an additional failing {@link Matcher}.\n\n@deprecated Please use {@link org.junit.AssumptionViolatedException} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/validator/AnnotationValidator.java",
    "type": "method",
    "name": "validateAnnotatedClass",
    "code": "public List<Exception> validateAnnotatedClass(TestClass testClass) {\n        return NO_VALIDATION_ERRORS;\n    }",
    "comment": "Validates annotation on the given class.\n\n@param testClass that is being validated\n@return A list of exceptions. Default behavior is to return an empty list.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/queue-based-load-leveling/src/main/java/com/iluwatar/queue/load/leveling/TaskGenerator.java",
    "type": "method",
    "name": "run",
    "code": "public void run() {\n    var count = this.msgCount;\n\n    try {\n      while (count > 0) {\n        var statusMsg = \"Message-\" + count + \" submitted by \" + Thread.currentThread().getName();\n        this.submit(new Message(statusMsg));\n\n        LOGGER.info(statusMsg);\n\n        // reduce the message count.\n        count--;\n\n        // Make the current thread to sleep after every Message submission.\n        Thread.sleep(1000);\n      }\n    } catch (Exception e) {\n      LOGGER.error(e.getMessage());\n    }\n  }",
    "comment": "Each TaskGenerator thread will submit all the messages to the Queue. After every message\nsubmission TaskGenerator thread will sleep for 1 second."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/game-loop/src/main/java/com/iluwatar/gameloop/VariableStepGameLoop.java",
    "type": "method",
    "name": "processGameLoop",
    "code": "protected void processGameLoop() {\n    var lastFrameTime = System.currentTimeMillis();\n    while (isGameRunning()) {\n      processInput();\n      var currentFrameTime = System.currentTimeMillis();\n      var elapsedTime = currentFrameTime - lastFrameTime;\n      update(elapsedTime);\n      lastFrameTime = currentFrameTime;\n      render();\n    }\n  }",
    "comment": "The variable-step game loop chooses a time step to advance based on how much real time passed\nsince the last frame. The longer the frame takes, the bigger steps the game takes. It always\nkeeps up with real time because it will take bigger and bigger steps to get there."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "isValidContinuationByte",
    "code": "private static boolean isValidContinuationByte(byte b) {\n     return b >= (byte) 0x80 && b <= (byte) 0xBF;\n  }",
    "comment": "Utility methods and constants for UTF-8 string validation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/gateway/src/test/java/com/iluwatar/gateway/ServiceFactoryTest.java",
    "type": "method",
    "name": "testGatewayFactoryRegistrationAndRetrieval",
    "code": "void testGatewayFactoryRegistrationAndRetrieval() {\n    Gateway serviceA = gatewayFactory.getGateway(\"ServiceA\");\n    Gateway serviceB = gatewayFactory.getGateway(\"ServiceB\");\n    Gateway serviceC = gatewayFactory.getGateway(\"ServiceC\");\n\n    assertTrue(\n        serviceA instanceof ExternalServiceA, \"ServiceA should be an instance of ExternalServiceA\");\n    assertTrue(\n        serviceB instanceof ExternalServiceB, \"ServiceB should be an instance of ExternalServiceB\");\n    assertTrue(\n        serviceC instanceof ExternalServiceC, \"ServiceC should be an instance of ExternalServiceC\");\n  }",
    "comment": "Check if the retrieved instances match their expected types"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "privateKeyPassword",
    "code": "public Builder privateKeyPassword(String privateKeyPassword) {\n      this.privateKeyPassword = privateKeyPassword;\n      return this;\n    }",
    "comment": "Sets the private key password\n\n@param privateKeyPassword The password for the private key\n@return The builder object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-executor/src/test/java/org/apache/maven/cling/executor/impl/ToolboxToolTest.java",
    "type": "method",
    "name": "metadataPath4",
    "code": "void metadataPath4(ExecutorHelper.Mode mode) {\n        ExecutorHelper helper = new HelperImpl(\n                mode,\n                mvn4ExecutorRequestBuilder().build().installationDirectory(),\n                userHome,\n                MavenExecutorTestSupport.EMBEDDED_MAVEN_EXECUTOR,\n                MavenExecutorTestSupport.FORKED_MAVEN_EXECUTOR);\n        String path = new ToolboxTool(helper).metadataPath(helper.executorRequest(), \"aopalliance\", \"someremote\");\n        assertTrue(path.endsWith(\"aopalliance\" + File.separator + \"maven-metadata-someremote.xml\"), \"path=\" + path);\n    }",
    "comment": "split repository: assert \"ends with\" as split may introduce prefixes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/CleanArgument.java",
    "type": "method",
    "name": "doCleanArgs",
    "code": "private static String[] doCleanArgs(String[] args) {\n        List<String> cleaned = new ArrayList<>();\n\n        StringBuilder currentArg = null;\n\n        for (String arg : args) {\n            boolean addedToBuffer = false;\n\n            if (arg.startsWith(\"\\\"\")) {\n                if (currentArg != null) {\n                    cleaned.add(currentArg.toString());\n                }\n\n                currentArg = new StringBuilder(arg.substring(1));\n                addedToBuffer = true;\n            }\n\n            if (addedToBuffer && arg.endsWith(\"\\\"\")) {\n                if (!currentArg.isEmpty()) {\n                    currentArg.setLength(currentArg.length() - 1);\n                }\n\n                cleaned.add(currentArg.toString());\n\n                currentArg = null;\n                continue;\n            }\n\n            if (!addedToBuffer) {\n                if (currentArg != null) {\n                    currentArg.append(' ').append(arg);\n                } else {\n                    cleaned.add(arg);\n                }\n            }\n        }\n\n        if (currentArg != null) {\n            cleaned.add(currentArg.toString());\n        }\n\n        int cleanedSz = cleaned.size();\n\n        String[] cleanArgs;\n\n        if (cleanedSz == 0) {\n            cleanArgs = args;\n        } else {\n            cleanArgs = cleaned.toArray(new String[0]);\n        }\n\n        return cleanArgs;\n    }",
    "comment": "if we're in the process of building up another arg, push it and start over.\nthis is for the case: \"-Dfoo=bar \"-Dfoo2=bar two\" (note the first unterminated quote)\nstart building an argument here.\nthis has to be a separate \"if\" statement, to capture the case of: \"-Dfoo=bar\"\nif we're building an argument, keep doing so.\nif this is the case of \"-Dfoo=bar\", then we need to adjust the buffer.\nif we haven't added this arg to the buffer, and we ARE building an argument\nbuffer, then append it with a preceding space...again, not sure what else to\ndo other than collapse whitespace.\nNOTE: The case of a trailing quote is handled by nullifying the arg buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Graph.java",
    "type": "method",
    "name": "operation",
    "code": "public GraphOperation operation(String name) {\n    synchronized (nativeHandleLock) {\n      long oph = operation(nativeHandle, name);\n      if (oph == 0) {\n        return null;\n      }\n      return new GraphOperation(this, oph);\n    }\n  }",
    "comment": "Returns the operation (node in the Graph) with the provided name.\n\n<p>Or {@code null} if no such operation exists in the Graph."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/Phase.java",
    "type": "method",
    "name": "getConfiguration",
    "code": "public Object getConfiguration() {\n        return this.configuration;\n    } // -- Object getConfiguration()",
    "comment": "Get configuration to pass to all goals run in this phase.\n\n@return Object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeArrayData.java",
    "type": "method",
    "name": "hashCode",
    "code": "public int hashCode() {\n    return Murmur3_x86_32.hashUnsafeBytes(baseObject, baseOffset, sizeInBytes, 42);\n  }",
    "comment": "This `hashCode` computation could consume much processor time for large data.\nIf the computation becomes a bottleneck, we can use a light-weight logic; the first fixed bytes\nare used to compute `hashCode` (See `Vector.hashCode`).\nThe same issue exists in `UnsafeRow.hashCode`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/ClockSource.java",
    "type": "method",
    "name": "plusMillis",
    "code": "static long plusMillis(long time, long millis) {\n      return CLOCK.plusMillis0(time, millis);\n   }",
    "comment": "Return the specified opaque time-stamp plus the specified number of milliseconds.\n\n@param time an opaque time-stamp\n@param millis milliseconds to add\n@return a new opaque time-stamp"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "escapeSlashes",
    "code": "private String escapeSlashes(String name) {\n        return SLASHES.matcher(name).replaceAll(\"_\");\n    }",
    "comment": "ganglia metric names can't contain slashes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/KVStoreView.java",
    "type": "method",
    "name": "index",
    "code": "public KVStoreView<T> index(String name) {\n    this.index = Preconditions.checkNotNull(name);\n    return this;\n  }",
    "comment": "Iterates according to the given index."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "chooseOptimalSize",
    "code": "protected static Size chooseOptimalSize(final Size[] choices, final int width, final int height) {\n    final int minSize = Math.max(Math.min(width, height), MINIMUM_PREVIEW_SIZE);\n    final Size desiredSize = new Size(width, height);\n\n    // Collect the supported resolutions that are at least as big as the preview Surface\n    boolean exactSizeFound = false;\n    final List<Size> bigEnough = new ArrayList<Size>();\n    final List<Size> tooSmall = new ArrayList<Size>();\n    for (final Size option : choices) {\n      if (option.equals(desiredSize)) {\n        // Set the size but don't return yet so that remaining sizes will still be logged.\n        exactSizeFound = true;\n      }\n\n      if (option.getHeight() >= minSize && option.getWidth() >= minSize) {\n        bigEnough.add(option);\n      } else {\n        tooSmall.add(option);\n      }\n    }\n\n    LOGGER.i(\"Desired size: \" + desiredSize + \", min size: \" + minSize + \"x\" + minSize);\n    LOGGER.i(\"Valid preview sizes: [\" + TextUtils.join(\", \", bigEnough) + \"]\");\n    LOGGER.i(\"Rejected preview sizes: [\" + TextUtils.join(\", \", tooSmall) + \"]\");\n\n    if (exactSizeFound) {\n      LOGGER.i(\"Exact size match found.\");\n      return desiredSize;\n    }\n\n    // Pick the smallest of those, assuming we found any\n    if (bigEnough.size() > 0) {\n      final Size chosenSize = Collections.min(bigEnough, new CompareSizesByArea());\n      LOGGER.i(\"Chosen size: \" + chosenSize.getWidth() + \"x\" + chosenSize.getHeight());\n      return chosenSize;\n    } else {\n      LOGGER.e(\"Couldn't find any suitable preview size\");\n      return choices[0];\n    }\n  }",
    "comment": "Given {@code choices} of {@code Size}s supported by a camera, chooses the smallest one whose\nwidth and height are at least as large as the minimum of both, or an exact match if possible.\n\n@param choices The list of sizes that the camera supports for the intended output class\n@param width The minimum desired width\n@param height The minimum desired height\n@return The optimal {@code Size}, or an arbitrary one if none were big enough"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/CommandBuilderUtils.java",
    "type": "method",
    "name": "quoteForCommandString",
    "code": "static String quoteForCommandString(String s) {\n    StringBuilder quoted = new StringBuilder().append('\"');\n    for (int i = 0; i < s.length(); i++) {\n      int cp = s.codePointAt(i);\n      if (cp == '\"' || cp == '\\\\') {\n        quoted.appendCodePoint('\\\\');\n      }\n      quoted.appendCodePoint(cp);\n    }\n    return quoted.append('\"').toString();\n  }",
    "comment": "Quotes a string so that it can be used in a command string.\nBasically, just add simple escapes. E.g.:\noriginal single argument : ab \"cd\" ef\nafter: \"ab \\\"cd\\\" ef\"\n\nThis can be parsed back into a single argument by python's \"shlex.split()\" function."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/saga/src/main/java/com/iluwatar/saga/orchestration/Saga.java",
    "type": "method",
    "name": "Saga",
    "code": "private Saga() {\n    this.chapters = new ArrayList<>();\n  }",
    "comment": "Saga representation. Saga consists of chapters. Every ChoreographyChapter is executed by a\ncertain service."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "succeeded",
    "code": "public Events succeeded() {\n\t\treturn new Events(finishedEventsByStatus(Status.SUCCESSFUL), this.category + \" Successful\");\n\t}",
    "comment": "Get the succeeded {@link Events} contained in this {@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-distributed-tracing/order-microservice/src/main/java/com/iluwatar/order/microservice/OrderService.java",
    "type": "method",
    "name": "validateProduct",
    "code": "Boolean validateProduct() {\n    try {\n      ResponseEntity<Boolean> productValidationResult =\n          restTemplateBuilder\n              .build()\n              .postForEntity(\n                  \"http://localhost:30302/product/validate\", \"validating product\", Boolean.class);\n      LOGGER.info(\"Product validation result: {}\", productValidationResult.getBody());\n      return productValidationResult.getBody();\n    } catch (ResourceAccessException | HttpClientErrorException e) {\n      LOGGER.error(\"Error communicating with product service: {}\", e.getMessage());\n      return false;\n    }\n  }",
    "comment": "Validates the product by calling the respective microservice.\n\n@return true if the product is valid, false otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/androidTest/java/com/example/android/observability/persistence/UserDaoTest.java",
    "type": "method",
    "name": "initDb",
    "code": "public void initDb() {\n        // using an in-memory database because the information stored here disappears when the\n        // process is killed\n        mDatabase = Room.inMemoryDatabaseBuilder(ApplicationProvider.getApplicationContext(),\n                UsersDatabase.class)\n                // allowing main thread queries, just for testing\n                .allowMainThreadQueries()\n                .build();\n    }",
    "comment": "Test the implementation of {@link UserDao}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dependency-injection/src/test/java/com/iluwatar/dependency/injection/GuiceWizardTest.java",
    "type": "method",
    "name": "testSmokeEveryThingThroughInjectionFramework",
    "code": "void testSmokeEveryThingThroughInjectionFramework() {\n\n    List<Class<? extends Tobacco>> tobaccos =\n        List.of(OldTobyTobacco.class, RivendellTobacco.class, SecondBreakfastTobacco.class);\n\n    // Configure the tobacco in the injection framework ...\n    // ... and create a new wizard with it\n    // Verify if the wizard is smoking the correct tobacco ...\n    tobaccos.forEach(\n        tobaccoClass -> {\n          final var injector =\n              Guice.createInjector(\n                  new AbstractModule() {\n                  });\n          final var guiceWizard = injector.getInstance(GuiceWizard.class);\n          guiceWizard.smoke();\n          String lastMessage = appender.getLastMessage();\n          assertEquals(\"GuiceWizard smoking \" + tobaccoClass.getSimpleName(), lastMessage);\n        });\n\n    // ... and nothing else is happening.\n    assertEquals(tobaccos.size(), appender.getLogSize());\n  }",
    "comment": "Test if the {@link GuiceWizard} smokes whatever instance of {@link Tobacco} is passed to him\nthrough the Guice google inject framework"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/AetherDependencyWrapper.java",
    "type": "method",
    "name": "getType",
    "code": "public Type getType() {\n        String type = dependency.getArtifact().getProperty(ArtifactProperties.TYPE, getExtension());\n        return session.requireType(type);\n    }",
    "comment": "{@return the type of the wrapped dependency}\nThe default implementation infers the type from the properties associated to the Eclipse Aether artifact."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaLogisticRegressionSummaryExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaLogisticRegressionSummaryExample\")\n      .getOrCreate();\n\n    Dataset<Row> training = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_libsvm_data.txt\");\n\n    LogisticRegression lr = new LogisticRegression()\n      .setMaxIter(10)\n      .setRegParam(0.3)\n      .setElasticNetParam(0.8);\n\n    LogisticRegressionModel lrModel = lr.fit(training);\n\n    BinaryLogisticRegressionTrainingSummary trainingSummary = lrModel.binarySummary();\n\n    double[] objectiveHistory = trainingSummary.objectiveHistory();\n    for (double lossPerIteration : objectiveHistory) {\n      System.out.println(lossPerIteration);\n    }\n\n    Dataset<Row> roc = trainingSummary.roc();\n    roc.show();\n    roc.select(\"FPR\").show();\n    System.out.println(trainingSummary.areaUnderROC());\n\n    Dataset<Row> fMeasure = trainingSummary.fMeasureByThreshold();\n    double maxFMeasure = fMeasure.select(functions.max(\"F-Measure\")).head().getDouble(0);\n    double bestThreshold = fMeasure.where(fMeasure.col(\"F-Measure\").equalTo(maxFMeasure))\n      .select(\"threshold\").head().getDouble(0);\n    lrModel.setThreshold(bestThreshold);\n\n    spark.stop();\n  }",
    "comment": "$example on$\n$example off$\nLoad training data\nFit the model\n$example on$\nExtract the summary from the returned LogisticRegressionModel instance trained in the earlier\nexample\nObtain the loss per iteration.\nObtain the receiver-operating characteristic as a dataframe and areaUnderROC.\nGet the threshold corresponding to the maximum F-Measure and rerun LogisticRegression with\nthis selected threshold.\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "setArtifactFilter",
    "code": "public void setArtifactFilter(ArtifactFilter artifactFilter) {\n        this.artifactFilter = artifactFilter;\n        this.artifacts = null;\n        this.artifactMap = null;\n    }",
    "comment": "Sets the scope filter to select the artifacts being exposed to the currently executed mojo.\n<strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not\npart of the public API. In particular, this method can be changed or deleted without prior notice and must not be\nused by plugins.\n\n@param artifactFilter The artifact filter, may be {@code null} to exclude all artifacts."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelBuilder.java",
    "type": "method",
    "name": "putSource",
    "code": "public void putSource(String groupId, String artifactId, ModelSource source) {\n            mappedSources\n                    .computeIfAbsent(new GAKey(groupId, artifactId), k -> new HashSet<>())\n                    .add(source);\n            if (groupId != null) {\n                putSource(null, artifactId, source);\n            }\n        }",
    "comment": "Also  register the source under the null groupId"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterFactory.java",
    "type": "method",
    "name": "create",
    "code": "public InterpreterApi create(@NonNull ByteBuffer byteBuffer, InterpreterApi.Options options) {\n    return InterpreterApi.create(byteBuffer, options);\n  }",
    "comment": "Constructs an {@link InterpreterApi} instance, using the specified model and options. The model\nwill be read from a {@code ByteBuffer}.\n\n@param byteBuffer A pre-trained TF Lite model, in binary serialized form. The ByteBuffer should\nnot be modified after the construction of an {@link InterpreterApi} instance. The {@code\nByteBuffer} can be either a {@code MappedByteBuffer} that memory-maps a model file, or a\ndirect {@code ByteBuffer} of nativeOrder() that contains the bytes content of a model.\n@param options A set of options for customizing interpreter behavior.\n@throws IllegalArgumentException if {@code byteBuffer} is not a {@code MappedByteBuffer} nor a\ndirect {@code ByteBuffer} of nativeOrder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/aggregate/Avg.java",
    "type": "method",
    "name": "Avg",
    "code": "public Avg(Expression column, boolean isDistinct) {\n    this.input = column;\n    this.isDistinct = isDistinct;\n  }",
    "comment": "An aggregate function that returns the mean of all the values in a group.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/CartController.java",
    "type": "method",
    "name": "CartController",
    "code": "public CartController(final ShoppingCartService shoppingCart) {\n    this.shoppingCartUseCase = shoppingCart;\n  }",
    "comment": "Constructs a CartController with the specified shopping cart service.\n\n@param shoppingCart The shopping cart service to handle cart operations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/KVStoreView.java",
    "type": "method",
    "name": "last",
    "code": "public KVStoreView<T> last(Object value) {\n    this.last = value;\n    return this;\n  }",
    "comment": "Stops iteration at the given value of the chosen index (inclusive)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/XXH64.java",
    "type": "method",
    "name": "XXH64",
    "code": "public XXH64(long seed) {\n    super();\n    this.seed = seed;\n  }",
    "comment": "xxHash64. A high quality and fast 64 bit hash code by Yann Colet and Mathias Westerdahl. The\nclass below is modelled like its Murmur3_x86_32 cousin.\n<p/>\nThis was largely based on the following (original) C and Java implementations:\nhttps://github.com/Cyan4973/xxHash/blob/master/xxhash.c\nhttps://github.com/OpenHFT/Zero-Allocation-Hashing/blob/master/src/main/java/net/openhft/hashing/XxHash_r39.java\nhttps://github.com/airlift/slice/blob/master/src/main/java/io/airlift/slice/XxHash64.java"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/ReactorBuildStatus.java",
    "type": "method",
    "name": "ReactorBuildStatus",
    "code": "public ReactorBuildStatus(ProjectDependencyGraph projectDependencyGraph) {\n        this.projectDependencyGraph = projectDependencyGraph;\n    }",
    "comment": "Contains status information that is global to an entire reactor build.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Integer expected, Integer actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManager.java",
    "type": "method",
    "name": "isUpdateRequired",
    "code": "public boolean isUpdateRequired(RepositoryMetadata metadata, ArtifactRepository repository, File file) {\n        ArtifactRepositoryPolicy policy = metadata.getPolicy(repository);\n\n        if (!policy.isEnabled()) {\n            if (getLogger().isDebugEnabled()) {\n                getLogger()\n                        .debug(\"Skipping update check for \" + metadata.getKey() + \" (\" + file + \") from \"\n                                + repository.getId() + \" (\" + repository.getUrl() + \")\");\n            }\n\n            return false;\n        }\n\n        if (getLogger().isDebugEnabled()) {\n            getLogger()\n                    .debug(\"Determining update check for \" + metadata.getKey() + \" (\" + file + \") from \"\n                            + repository.getId() + \" (\" + repository.getUrl() + \")\");\n        }\n\n        if (file == null) {\n            return true;\n        }\n\n        Date lastCheckDate = readLastUpdated(metadata, repository, file);\n\n        return (lastCheckDate == null) || policy.checkOutOfDate(lastCheckDate);\n    }",
    "comment": "Here, we need to determine which policy to use. Release updateInterval will be used when\nthe metadata refers to a release artifact or meta-version, and snapshot updateInterval will be used when\nit refers to a snapshot artifact or meta-version.\nNOTE: Release metadata includes version information about artifacts that have been released, to allow\nmeta-versions like RELEASE and LATEST to resolve, and also to allow retrieval of the range of valid, released\nartifacts available.\nTODO throw something instead?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/RuleChain.java",
    "type": "method",
    "name": "outerRule",
    "code": "public static RuleChain outerRule(TestRule outerRule) {\n        return emptyRuleChain().around(outerRule);\n    }",
    "comment": "Returns a {@code RuleChain} with a single {@link TestRule}. This method\nis the usual starting point of a {@code RuleChain}.\n\n@param outerRule the outer rule of the {@code RuleChain}.\n@return a {@code RuleChain} with a single {@link TestRule}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(char expected, Character actual, String message) {\n\t\tAssertEquals.assertEquals((Character) expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "certChain",
    "code": "public Builder certChain(File certChain) {\n      this.certChain = certChain;\n      return this;\n    }",
    "comment": "Sets a X.509 certificate chain file in PEM format\n\n@param certChain The certificate chain file to use\n@return The builder object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlan.java",
    "type": "method",
    "name": "then",
    "code": "public void then(BuildPlan step) {\n        step.plan.forEach((k, v) -> plan.merge(k, v, this::merge));\n        aliases.putAll(step.aliases);\n    }",
    "comment": "add a follow-up plan to this one"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/saga/src/main/java/com/iluwatar/saga/orchestration/SagaOrchestrator.java",
    "type": "method",
    "name": "SagaOrchestrator",
    "code": "public SagaOrchestrator(Saga saga, ServiceDiscoveryService sd) {\n    this.saga = saga;\n    this.sd = sd;\n    this.state = new CurrentState();\n  }",
    "comment": "Create a new service to orchetrate sagas.\n\n@param saga saga to process\n@param sd service discovery @see {@link ServiceDiscoveryService}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfig.java",
    "type": "method",
    "name": "enableTestEngineAutoRegistration",
    "code": "public Builder enableTestEngineAutoRegistration(boolean enabled) {\n\t\t\tthis.engineAutoRegistrationEnabled = enabled;\n\t\t\treturn this;\n\t\t}",
    "comment": "Configure the auto-registration flag for test engines.\n\n<p>Defaults to {@code true}.\n\n@param enabled {@code true} if test engines should be automatically\nregistered\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/migrationsupport/rules/ExpectedExceptionSupportTests.java",
    "type": "method",
    "name": "expectedExceptionIsProcessedCorrectly",
    "code": "void expectedExceptionIsProcessedCorrectly() {\n\t\tEvents tests = executeTestsForClass(ExpectedExceptionTestCase.class);\n\n\t\ttests.assertStatistics(stats -> stats.started(4).succeeded(1).aborted(0).failed(3));\n\n\t\ttests.succeeded().assertThatEvents().have(\n\t\t\tevent(test(\"correctExceptionExpectedThrown\"), finishedSuccessfully()));\n\n\t\ttests.failed().assertThatEvents()//\n\t\t\t\t.haveExactly(1, //\n\t\t\t\t\tevent(test(\"noExceptionExpectedButThrown\"), //\n\t\t\t\t\t\tfinishedWithFailure(message(\"no exception expected\")))) //\n\t\t\t\t.haveExactly(1, //\n\t\t\t\t\tevent(test(\"exceptionExpectedButNotThrown\"), //\n\t\t\t\t\t\tfinishedWithFailure(instanceOf(AssertionError.class), //\n\t\t\t\t\t\t\tmessage(\"Expected test to throw an instance of java.lang.RuntimeException\")))) //\n\t\t\t\t.haveExactly(1, //\n\t\t\t\t\tevent(test(\"wrongExceptionExpected\"), //\n\t\t\t\t\t\tfinishedWithFailure(instanceOf(AssertionError.class), //\n\t\t\t\t\t\t\tmessage(value -> value.contains(\"Expected: an instance of java.io.IOException\")))));\n\t}",
    "comment": "Integration tests for {@link ExpectedExceptionSupport}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "bytesToString",
    "code": "public static String bytesToString(ByteBuffer b) {\n    return StandardCharsets.UTF_8.decode(b.slice()).toString();\n  }",
    "comment": "Convert the given byte buffer to a string. The resulting string can be\nconverted back to the same byte buffer through {@link #stringToBytes(String)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getArtifacts",
    "code": "public Set<Artifact> getArtifacts() {\n        if (artifacts == null) {\n            if (artifactFilter == null || resolvedArtifacts == null) {\n                artifacts = new LinkedHashSet<>();\n            } else {\n                artifacts = new LinkedHashSet<>(resolvedArtifacts.size() * 2);\n                for (Artifact artifact : resolvedArtifacts) {\n                    if (artifactFilter.include(artifact)) {\n                        artifacts.add(artifact);\n                    }\n                }\n            }\n        }\n        return artifacts;\n    }",
    "comment": "All dependencies that this project has, including transitive ones. Contents are lazily populated, so depending on\nwhat phases have run dependencies in some scopes won't be included. e.g. if only compile phase has run,\ndependencies with scope test won't be included.\n\n@return {@link Set} &lt; {@link Artifact} &gt;\n@see #getDependencyArtifacts() to get only direct dependencies"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/DefaultLifecycleExecutor.java",
    "type": "method",
    "name": "getPhaseToLifecycleMap",
    "code": "public Map<String, Lifecycle> getPhaseToLifecycleMap() {\n        return defaultLifeCycles.getPhaseToLifecycleMap();\n    }",
    "comment": "USED BY MAVEN HELP PLUGIN"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetReadState.java",
    "type": "method",
    "name": "resetForNewPage",
    "code": "void resetForNewPage(int totalValuesInPage, long pageFirstRowIndex) {\n    this.valuesToReadInPage = totalValuesInPage;\n    this.rowId = pageFirstRowIndex;\n  }",
    "comment": "Must be called at the beginning of reading a new page."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProjectBuilderRequest.java",
    "type": "method",
    "name": "processPlugins",
    "code": "public ProjectBuilderRequestBuilder processPlugins(boolean processPlugins) {\n            this.processPlugins = processPlugins;\n            return this;\n        }",
    "comment": "Sets whether plugins should be processed during project building.\nWhen true, the builder will process plugin information which may include\nresolving plugin dependencies and executing plugin goals that participate in project building.\n\n@param processPlugins true if plugins should be processed, false otherwise\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/AutoCloseExtension.java",
    "type": "method",
    "name": "preDestroyTestInstance",
    "code": "public void preDestroyTestInstance(ExtensionContext context) {\n\t\tThrowableCollector throwableCollector = new ThrowableCollector(__ -> false);\n\t\tTestInstancePreDestroyCallback.preDestroyTestInstances(context,\n\t\t\ttestInstance -> closeFields(testInstance.getClass(), testInstance, throwableCollector));\n\t\tthrowableCollector.assertEmpty();\n\t}",
    "comment": "{@code AutoCloseExtension} is a JUnit Jupiter extension that closes resources\nif a field in a test class is annotated with {@link AutoClose @AutoClose}.\n\n<p>Consult the Javadoc for {@code @AutoClose} for details on the contract.\n\n@since 5.11\n@see AutoClose"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/interpreter/src/main/java/com/iluwatar/interpreter/App.java",
    "type": "method",
    "name": "getOperatorInstance",
    "code": "public static Expression getOperatorInstance(String s, Expression left, Expression right) {\n    return switch (s) {\n      case \"+\" -> new PlusExpression(left, right);\n      case \"-\" -> new MinusExpression(left, right);\n      default -> new MultiplyExpression(left, right);\n    };\n  }",
    "comment": "Returns correct expression based on the parameters.\n\n@param s input string\n@param left expression\n@param right expression\n@return expression"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "safeLookup",
    "code": "public void safeLookup(Object keyBase, long keyOffset, int keyLength, Location loc, int hash) {\n    assert(longArray != null);\n\n    numKeyLookups++;\n\n    int pos = hash & mask;\n    int step = 1;\n    while (true) {\n      numProbes++;\n      if (longArray.get(pos * 2) == 0) {\n        // This is a new key.\n        loc.with(pos, hash, false);\n        return;\n      } else {\n        long stored = longArray.get(pos * 2 + 1);\n        if ((int) (stored) == hash) {\n          // Full hash code matches.  Let's compare the keys for equality.\n          loc.with(pos, hash, true);\n          if (loc.getKeyLength() == keyLength) {\n            final boolean areEqual = ByteArrayMethods.arrayEquals(\n              keyBase,\n              keyOffset,\n              loc.getKeyBase(),\n              loc.getKeyOffset(),\n              keyLength\n            );\n            if (areEqual) {\n              return;\n            }\n          }\n        }\n      }\n      pos = (pos + step) & mask;\n      step++;\n    }\n  }",
    "comment": "Looks up a key, and saves the result in provided `loc`.\n\nThis is a thread-safe version of `lookup`, could be used by multiple threads."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/KVStoreView.java",
    "type": "method",
    "name": "max",
    "code": "public KVStoreView<T> max(long max) {\n    Preconditions.checkArgument(max > 0L, \"max must be positive.\");\n    this.max = max;\n    return this;\n  }",
    "comment": "Stops iteration after a number of elements has been retrieved."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/LegacyReportingUtils.java",
    "type": "method",
    "name": "getClassName",
    "code": "public static String getClassName(TestPlan testPlan, TestIdentifier testIdentifier) {\n\t\treturn org.junit.platform.launcher.listeners.LegacyReportingUtils.getClassName(testPlan, testIdentifier);\n\t}",
    "comment": "Get the class name for the supplied {@link TestIdentifier} using the\nsupplied {@link TestPlan}.\n\n<p>This implementation attempts to find the closest test identifier with\na {@link ClassSource} by traversing the hierarchy upwards towards the\nroot starting with the supplied test identifier. In case no such source\nis found, it falls back to using the parent's\n{@linkplain TestIdentifier#getLegacyReportingName legacy reporting name}.\n\n@param testPlan the test plan that contains the {@code TestIdentifier};\nnever {@code null}\n@param testIdentifier the identifier to determine the class name for;\nnever {@code null}\n@see TestIdentifier#getLegacyReportingName"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicSample/app/src/main/java/com/example/android/persistence/ui/MainActivity.java",
    "type": "method",
    "name": "onCreate",
    "code": "protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main_activity);\n\n        if (savedInstanceState == null) {\n            ProductListFragment fragment = new ProductListFragment();\n\n            getSupportFragmentManager().beginTransaction()\n                    .add(R.id.fragment_container, fragment, ProductListFragment.TAG).commit();\n        }\n    }",
    "comment": "Add product list fragment if this is first creation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/ProjectDependencyGraphStubTest.java",
    "type": "method",
    "name": "testADependencies",
    "code": "void testADependencies() {\n        final List<MavenProject> mavenProjects = stub.getUpstreamProjects(ProjectDependencyGraphStub.A, false);\n        assertEquals(0, mavenProjects.size());\n    }",
    "comment": "Tests the stub. Yeah, I know."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/ExternalResource.java",
    "type": "method",
    "name": "after",
    "code": "protected void after() {\n        // do nothing\n    }",
    "comment": "Override to tear down your specific external resource."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/options/TestDiscoveryOptionsMixin.java",
    "type": "method",
    "name": "setConfigurationParameters2",
    "code": "public void setConfigurationParameters2(Map<String, String> keyValuePairs) {\n\t\t\tsetConfigurationParameters(keyValuePairs);\n\t\t}",
    "comment": "Implementation note: the @Option annotation is on a setter method to allow validation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantSchema.java",
    "type": "method",
    "name": "ObjectField",
    "code": "public ObjectField(String fieldName, VariantSchema schema) {\n      this.fieldName = fieldName;\n      this.schema = schema;\n    }",
    "comment": "Defines a valid shredding schema, as described in\nhttps://github.com/apache/parquet-format/blob/master/VariantShredding.md.\nA shredding schema contains a value and optional typed_value field.\nIf a typed_value is an array or struct, it recursively contain its own shredding schema for\nelements and fields, respectively.\nThe schema also contains a metadata field at the top level, but not in recursively shredded\nfields."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/factory-kit/src/test/java/com/iluwatar/factorykit/factorykit/FactoryKitTest.java",
    "type": "method",
    "name": "testWeapon",
    "code": "void testWeapon() {\n    var weapon = factory.create(WeaponType.SWORD);\n    verifyWeapon(weapon, Sword.class);\n  }",
    "comment": "Testing {@link WeaponFactory} to produce a SWORD asserting that the Weapon is an instance of\n{@link Sword}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/ProjectBuildFailureException.java",
    "type": "method",
    "name": "ProjectBuildFailureException",
    "code": "public ProjectBuildFailureException(String projectId, MojoFailureException cause) {\n        super(\"Build for project: \" + projectId + \" failed during execution of mojo.\", cause);\n\n        this.projectId = projectId;\n    }",
    "comment": "Exception which occurs when a normal (i.e. non-aggregator) mojo fails to\nexecute. In this case, the mojo failed while executing against a particular\nproject instance, so we can wrap the {@link MojoFailureException} with context\ninformation including projectId that caused the failure."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/commander/src/test/java/com/iluwatar/commander/RetryTest.java",
    "type": "method",
    "name": "performTest",
    "code": "void performTest() {\n    Retry.Operation op =\n        (l) -> {\n          if (!l.isEmpty()) {\n            throw l.remove(0);\n          }\n        };\n    Retry.HandleErrorIssue<Order> handleError = (o, e) -> {};\n    var r1 =\n        new Retry<>(\n            op,\n            handleError,\n            3,\n            30000,\n            e -> DatabaseUnavailableException.class.isAssignableFrom(e.getClass()));\n    var r2 =\n        new Retry<>(\n            op,\n            handleError,\n            3,\n            30000,\n            e -> DatabaseUnavailableException.class.isAssignableFrom(e.getClass()));\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    var arr1 =\n        new ArrayList<>(\n            List.of(new ItemUnavailableException(), new DatabaseUnavailableException()));\n    try {\n      r1.perform(arr1, order);\n    } catch (Exception e1) {\n      LOG.error(\"An exception occurred\", e1);\n    }\n    var arr2 =\n        new ArrayList<>(\n            List.of(new DatabaseUnavailableException(), new ItemUnavailableException()));\n    try {\n      r2.perform(arr2, order);\n    } catch (Exception e1) {\n      LOG.error(\"An exception occurred\", e1);\n    }\n    assertTrue(arr1.size() == 1 && arr2.isEmpty());\n  }",
    "comment": "r1 stops at ItemUnavailableException, r2 retries because it encounters\nDatabaseUnavailableException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/MyDoubleSum.java",
    "type": "method",
    "name": "MyDoubleSum",
    "code": "public MyDoubleSum() {\n    List<StructField> inputFields = new ArrayList<>();\n    inputFields.add(DataTypes.createStructField(\"inputDouble\", DataTypes.DoubleType, true));\n    _inputDataType = DataTypes.createStructType(inputFields);\n\n    List<StructField> bufferFields = new ArrayList<>();\n    bufferFields.add(DataTypes.createStructField(\"bufferDouble\", DataTypes.DoubleType, true));\n    _bufferSchema = DataTypes.createStructType(bufferFields);\n\n    _returnDataType = DataTypes.DoubleType;\n  }",
    "comment": "An example {@link UserDefinedAggregateFunction} to calculate the sum of a\n{@link org.apache.spark.sql.types.DoubleType} column."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<String> create(Scope scope, String data, Charset charset) {\n    try (Tensor<String> value = Tensor.create(data.getBytes(charset), String.class)) {\n      return createWithTensor(scope, value);\n    }\n  }",
    "comment": "Creates a {@code String} constant using a specified encoding.\n\n@param scope is a scope used to add the underlying operation.\n@param charset The encoding from String to bytes.\n@param data The string to put into the new constant.\n@return a string constant"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/InMemoryStore.java",
    "type": "method",
    "name": "deleteParentIndex",
    "code": "private void deleteParentIndex(Object key) {\n      if (hasNaturalParentIndex) {\n        for (NaturalKeys v : parentToChildrenMap.values()) {\n          if (v.remove(asKey(key)) != null) {\n            break;\n          }\n        }\n      }\n    }",
    "comment": "`v` can be empty after removing the natural key and we can remove it from\n`parentToChildrenMap`. However, `parentToChildrenMap` is a ConcurrentMap and such\nchecking and deleting can be slow.\nThis method is to delete one object with certain key, let's make it simple here."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(double[] expected, double[] actual, double delta) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, delta);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} double arrays are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room2/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "getUser",
    "code": "void getUser(final LoadUserCallback callback) {\n        final WeakReference<LoadUserCallback> loadUserCallback = new WeakReference<>(callback);\n\n        // request the user on the I/O thread\n        mAppExecutors.diskIO().execute(() -> {\n            final User user = mUserDataSource.getUser();\n            // notify on the main thread\n            mAppExecutors.mainThread().execute(() -> {\n                final LoadUserCallback userCallback = loadUserCallback.get();\n                if (userCallback == null) {\n                    return;\n                }\n                if (user == null) {\n                    userCallback.onDataNotAvailable();\n                } else {\n                    mCachedUser = user;\n                    userCallback.onUserLoaded(mCachedUser);\n                }\n            });\n        });\n    }",
    "comment": "Get the user from the data source, cache it and notify via the callback that the user has\nbeen retrieved.\n\n@param callback callback that gets called when the user was retrieved from the data source."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java",
    "type": "method",
    "name": "determineReactorFailureBehaviour",
    "code": "private String determineReactorFailureBehaviour(final CommandLine commandLine) {\n        if (commandLine.hasOption(CLIManager.FAIL_FAST)) {\n            return MavenExecutionRequest.REACTOR_FAIL_FAST;\n        } else if (commandLine.hasOption(CLIManager.FAIL_AT_END)) {\n            return MavenExecutionRequest.REACTOR_FAIL_AT_END;\n        } else if (commandLine.hasOption(CLIManager.FAIL_NEVER)) {\n            return MavenExecutionRequest.REACTOR_FAIL_NEVER;\n        } else {\n            return MavenExecutionRequest.REACTOR_FAIL_FAST;\n        }\n    }",
    "comment": "this is the default behavior."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/ClassMap.java",
    "type": "method",
    "name": "getPublicMethod",
    "code": "private static Method getPublicMethod(Class<?> clazz, String name, Class<?>... paramTypes) {\n        // if this class is public, then try to get it\n        if ((clazz.getModifiers() & Modifier.PUBLIC) != 0) {\n            try {\n                return clazz.getMethod(name, paramTypes);\n            } catch (NoSuchMethodException e) {\n                // If the class does not have the method, then neither its superclass\n                // nor any of its interfaces has it so quickly return null.\n                return null;\n            }\n        }\n\n        //  try the superclass\n        Class<?> superclazz = clazz.getSuperclass();\n\n        if (superclazz != null) {\n            Method superclazzMethod = getPublicMethod(superclazz, name, paramTypes);\n\n            if (superclazzMethod != null) {\n                return superclazzMethod;\n            }\n        }\n\n        // and interfaces\n        Class<?>[] interfaces = clazz.getInterfaces();\n\n        for (Class<?> anInterface : interfaces) {\n            Method interfaceMethod = getPublicMethod(anInterface, name, paramTypes);\n\n            if (interfaceMethod != null) {\n                return interfaceMethod;\n            }\n        }\n\n        return null;\n    }",
    "comment": "Looks up the method with specified name and signature in the first public\nsuperclass or implemented interface of the class.\n\n@param clazz      the class whose method is sought\n@param name       the name of the method\n@param paramTypes the classes of method parameters"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "fail",
    "code": "public static <V> V fail(String message, Throwable cause) {\n\t\tAssertionUtils.fail(message, cause);\n\t\treturn null; // appeasing the compiler: this line will never be executed.\n\t}",
    "comment": "<em>Fail</em> the test with the given failure {@code message} as well\nas the underlying {@code cause}.\n\n<p>See Javadoc for {@link #fail(String)} for an explanation of this method's\ngeneric return type {@code V}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Double unexpected, double actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Double) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarMap.java",
    "type": "method",
    "name": "ColumnarMap",
    "code": "public ColumnarMap(ColumnVector keys, ColumnVector values, int offset, int length) {\n    this.length = length;\n    this.keys = new ColumnarArray(keys, offset, length);\n    this.values = new ColumnarArray(values, offset, length);\n  }",
    "comment": "Map abstraction in {@link ColumnVector}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/map-reduce/src/main/java/com/iluwatar/Mapper.java",
    "type": "method",
    "name": "map",
    "code": "public static Map<String, Integer> map(String input) {\n    Map<String, Integer> wordCount = new HashMap<>();\n    String[] words = input.split(\"\\\\s+\");\n    for (String word : words) {\n      word = word.toLowerCase().replaceAll(\"[^a-z]\", \"\");\n      if (!word.isEmpty()) {\n        wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n      }\n    }\n    return wordCount;\n  }",
    "comment": "Splits a given input string into words and counts their occurrences.\n\n@param input The input string to be mapped.\n@return A map where keys are words and values are their respective counts."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Short expected, Short actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Long> create(Scope scope, long[] data) {\n    return create(scope, data, Long.class);\n  }",
    "comment": "Creates a rank-1 constant of {@code long} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/manipulation/Filter.java",
    "type": "method",
    "name": "intersect",
    "code": "public Filter intersect(final Filter second) {\n        if (second == this || second == ALL) {\n            return this;\n        }\n        final Filter first = this;\n        return new Filter() {\n\n            @Override\n            public String describe() {\n                return first.describe() + \" and \" + second.describe();\n            }\n        };\n    }",
    "comment": "Returns a new Filter that accepts the intersection of the tests accepted\nby this Filter and {@code second}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegateImpl.java",
    "type": "method",
    "name": "getNnapiErrno",
    "code": "public int getNnapiErrno() {\n    checkNotClosed();\n    return getNnapiErrno(delegateHandle);\n  }",
    "comment": "Returns the latest error code returned by an NNAPI call or zero if NO calls to NNAPI failed.\nThe error code is reset when the delegate is associated with an <a\nhref=https://www.tensorflow.org/lite/api_docs/java/org/tensorflow/lite/Interpreter>interpreter</a>.\n\n<p>For details on NNAPI error codes see <a\nhref=\"https://developer.android.com/ndk/reference/group/neural-networks#resultcode\">the NNAPI\ndocumentation</a>.\n\n@throws IllegalStateException if the method is called after {@link #close() close}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/FailedAssumptionsTests.java",
    "type": "method",
    "name": "testAbortedExceptionInBeforeAll",
    "code": "void testAbortedExceptionInBeforeAll() {\n\t\tEngineExecutionResults results = executeTestsForClass(TestAbortedExceptionInBeforeAllTestCase.class);\n\n\t\tresults.containerEvents().assertStatistics(stats -> stats.aborted(1));\n\t\tresults.testEvents().assertStatistics(stats -> stats.started(0));\n\t}",
    "comment": "Integration tests that verify support for failed assumptions in the\n{@link JupiterTestEngine}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Float> create(float[][] data) {\n    return Tensor.create(data, Float.class);\n  }",
    "comment": "Creates a rank-2 tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java",
    "type": "method",
    "name": "registerExtensionsFromExecutableParameters",
    "code": "static void registerExtensionsFromExecutableParameters(ExtensionRegistrar registrar, Executable executable) {\n\t\tPreconditions.notNull(registrar, \"ExtensionRegistrar must not be null\");\n\t\tPreconditions.notNull(executable, \"Executable must not be null\");\n\n\t\tAtomicInteger index = new AtomicInteger();\n\n\t\t// @formatter:off\n\t\tArrays.stream(executable.getParameters())\n\t\t\t\t.map(parameter -> findRepeatableAnnotations(parameter, index.getAndIncrement(), ExtendWith.class))\n\t\t\t\t.flatMap(ExtensionUtils::streamDeclarativeExtensionTypes)\n\t\t\t\t.forEach(registrar::registerExtension);\n\t\t// @formatter:on\n\t}",
    "comment": "Register extensions using the supplied registrar from parameters in the\nsupplied {@link Executable} (i.e., a {@link java.lang.reflect.Constructor}\nor {@link java.lang.reflect.Method}) that are annotated with\n{@link ExtendWith @ExtendWith}.\n\n@param registrar the registrar with which to register the extensions; never {@code null}\n@param executable the constructor or method whose parameters should be searched; never {@code null}\n@since 5.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/CommandBuilderUtils.java",
    "type": "method",
    "name": "mergeEnvPathList",
    "code": "static void mergeEnvPathList(Map<String, String> userEnv, String envKey, String pathList) {\n    if (!isEmpty(pathList)) {\n      String current = firstNonEmpty(userEnv.get(envKey), System.getenv(envKey));\n      userEnv.put(envKey, join(File.pathSeparator, current, pathList));\n    }\n  }",
    "comment": "Updates the user environment, appending the given pathList to the existing value of the given\nenvironment variable (or setting it if it hasn't yet been set)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "getDecimal",
    "code": "public Decimal getDecimal(int rowId, int precision, int scale) {\n    if (precision <= Decimal.MAX_INT_DIGITS()) {\n      return Decimal.createUnsafe(getInt(rowId), precision, scale);\n    } else if (precision <= Decimal.MAX_LONG_DIGITS()) {\n      return Decimal.createUnsafe(getLong(rowId), precision, scale);\n    } else {\n      byte[] bytes = getBinary(rowId);\n      BigInteger bigInteger = new BigInteger(bytes);\n      BigDecimal javaDecimal = new BigDecimal(bigInteger, scale);\n      return Decimal.apply(javaDecimal, precision, scale);\n    }\n  }",
    "comment": "copy and modify from WritableColumnVector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/bully/BullyInstance.java",
    "type": "method",
    "name": "handleElectionInvokeMessage",
    "code": "protected void handleElectionInvokeMessage() {\n    if (!isLeader()) {\n      LOGGER.info(INSTANCE + localId + \"- Start election.\");\n      boolean electionResult = messageManager.sendElectionMessage(localId, String.valueOf(localId));\n      if (electionResult) {\n        LOGGER.info(INSTANCE + localId + \"- Succeed in election. Start leader notification.\");\n        leaderId = localId;\n        messageManager.sendLeaderMessage(localId, localId);\n        messageManager.sendHeartbeatInvokeMessage(localId);\n      }\n    }\n  }",
    "comment": "Process election invoke message. Send election message to all the instances with smaller ID. If\nany one of them is alive, do nothing. If no instance alive, send leader message to all the\nalive instance and restart heartbeat."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/Validatable.java",
    "type": "method",
    "name": "reportAndClear",
    "code": "static void reportAndClear(List<DiscoveryIssue> issues, DiscoveryIssueReporter reporter) {\n\t\tissues.forEach(reporter::reportIssue);\n\t\tissues.clear();\n\t}",
    "comment": "Report and clear the given list of {@link DiscoveryIssue}s using the\nsupplied {@link DiscoveryIssueReporter}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "debug",
    "code": "public Executions debug() {\n\t\tdebug(System.out);\n\t\treturn this;\n\t}",
    "comment": "Print all executions to {@link System#out}.\n\n@return this {@code Executions} object for method chaining; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/MethodFilter.java",
    "type": "method",
    "name": "excludeMethodNamePatterns",
    "code": "static MethodFilter excludeMethodNamePatterns(List<String> patterns) {\n\t\treturn excludeMethodNamePatterns(patterns.toArray(new String[0]));\n\t}",
    "comment": "Create a new <em>exclude</em> {@link MethodFilter} based on the\n@see Class#getName()\n@see Method#getName()\n@see #excludeMethodNamePatterns(String...)\n@see #includeMethodNamePatterns(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expressions.java",
    "type": "method",
    "name": "bucket",
    "code": "public static Transform bucket(int numBuckets, String... columns) {\n    NamedReference[] references = Arrays.stream(columns)\n      .map(Expressions::column)\n      .toArray(NamedReference[]::new);\n    return LogicalExpressions.bucket(numBuckets, references);\n  }",
    "comment": "Create a bucket transform for one or more columns.\n<p>\nThis transform represents a logical mapping from a value to a bucket id in [0, numBuckets)\nbased on a hash of the value.\n<p>\nThe name reported by transforms created with this method is \"bucket\".\n\n@param numBuckets the number of output buckets\n@param columns input columns for the bucket transform\n@return a logical bucket transform with name \"bucket\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/saga/src/main/java/com/iluwatar/saga/choreography/Saga.java",
    "type": "method",
    "name": "isSuccess",
    "code": "public boolean isSuccess() {\n      return result == ChapterResult.SUCCESS;\n    }",
    "comment": "the result for chapter is good.\n\n@return true if is good otherwise bad"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Integer> create(Scope scope, int[] data) {\n    return create(scope, data, Integer.class);\n  }",
    "comment": "Creates a rank-1 constant of {@code int} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/tracking/MultiBoxTracker.java",
    "type": "method",
    "name": "MultiBoxTracker",
    "code": "public MultiBoxTracker(final Context context) {\n    this.context = context;\n    for (final int color : COLORS) {\n      availableColors.add(color);\n    }\n\n    boxPaint.setColor(Color.RED);\n    boxPaint.setStyle(Style.STROKE);\n    boxPaint.setStrokeWidth(12.0f);\n    boxPaint.setStrokeCap(Cap.ROUND);\n    boxPaint.setStrokeJoin(Join.ROUND);\n    boxPaint.setStrokeMiter(100);\n\n    textSizePx =\n        TypedValue.applyDimension(\n            TypedValue.COMPLEX_UNIT_DIP, TEXT_SIZE_DIP, context.getResources().getDisplayMetrics());\n    borderedText = new BorderedText(textSizePx);\n  }",
    "comment": "A tracker wrapping ObjectTracker that also handles non-max suppression and matching existing\nobjects to new detections."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/MavenSession.java",
    "type": "method",
    "name": "adaptSettings",
    "code": "private static Settings adaptSettings(MavenExecutionRequest request) {\n        File localRepo = request.getLocalRepositoryPath();\n        return new Settings(org.apache.maven.api.settings.Settings.newBuilder()\n                .localRepository(localRepo != null ? localRepo.getAbsolutePath() : null)\n                .interactiveMode(request.isInteractiveMode())\n                .offline(request.isOffline())\n                .proxies(request.getProxies().stream().map(Proxy::getDelegate).collect(Collectors.toList()))\n                .servers(request.getServers().stream().map(Server::getDelegate).collect(Collectors.toList()))\n                .mirrors(request.getMirrors().stream().map(Mirror::getDelegate).collect(Collectors.toList()))\n                .profiles(request.getProfiles().stream()\n                        .map(Profile::getDelegate)\n                        .map(SettingsUtilsV4::convertToSettingsProfile)\n                        .collect(Collectors.toList()))\n                .activeProfiles(request.getActiveProfiles())\n                .pluginGroups(request.getPluginGroups())\n                .build());\n    }",
    "comment": "Adapt a {@link MavenExecutionRequest} to a {@link Settings} object for use in the Maven core.\nWe want to make sure that what is ask for in the execution request overrides what is in the settings.\nThe CLI feeds into an execution request so if a particular value is present in the execution request\nthen we will take that over the value coming from the user settings."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-driven-architecture/src/main/java/com/iluwatar/eda/framework/EventDispatcher.java",
    "type": "method",
    "name": "EventDispatcher",
    "code": "public EventDispatcher() {\n    handlers = new HashMap<>();\n  }",
    "comment": "Handles the routing of {@link Event} messages to associated handlers. A {@link HashMap} is used\nto store the association between events and their respective handlers."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/FarthestConflictResolverTest.java",
    "type": "method",
    "name": "testEqualReversed",
    "code": "void testEqualReversed() {\n        ResolutionNode a2n = createResolutionNode(a2);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a2n, a2n, a1n);\n    }",
    "comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\na:2.0\na:1.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-settings-builder/src/main/java/org/apache/maven/settings/crypto/DefaultSettingsDecrypter.java",
    "type": "method",
    "name": "DefaultSettingsDecrypter",
    "code": "public DefaultSettingsDecrypter(MavenSecDispatcher securityDispatcher) {\n        this.securityDispatcher = securityDispatcher;\n    }",
    "comment": "Decrypts passwords in the settings.\n\n@deprecated since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3807PluginConfigExpressionEvaluationTest.java",
    "type": "method",
    "name": "assertEvaluated",
    "code": "private void assertEvaluated(String value) {\n        assertNotNull(value);\n        assertTrue(value.length() > 0);\n        assertFalse(value.contains(\"${\"), value);\n    }\n}",
    "comment": "Verify that plugin configurations are subject to the parameter expression evaluator, in particular composite\nparameter types.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/saga/src/main/java/com/iluwatar/saga/choreography/Service.java",
    "type": "method",
    "name": "Service",
    "code": "public Service(ServiceDiscoveryService service) {\n    this.sd = service;\n  }",
    "comment": "Common abstraction class representing services. implementing a general contract @see {@link\nChoreographyChapter}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/condition/EnabledIfEnvironmentVariableCondition.java",
    "type": "method",
    "name": "getEnvironmentVariable",
    "code": "protected String getEnvironmentVariable(String name) {\n\t\treturn System.getenv(name);\n\t}",
    "comment": "Get the value of the named environment variable.\n\n<p>The default implementation delegates to\n{@link System#getenv(String)}. Can be overridden in a subclass for\ntesting purposes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/sqlite/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "getUser",
    "code": "void getUser(final LoadUserCallback callback) {\n        final WeakReference<LoadUserCallback> loadUserCallback = new WeakReference<>(callback);\n\n        // request the user on the I/O thread\n        mAppExecutors.diskIO().execute(new Runnable() {\n                mAppExecutors.mainThread().execute(new Runnable() {\n                        if (user == null) {\n                            userCallback.onDataNotAvailable();\n                        } else {\n                            mCachedUser = user;\n                            userCallback.onUserLoaded(mCachedUser);\n                        }\n                    }\n                });\n            }",
    "comment": "Get the user from the data source, cache it and notify via the callback that the user has\nbeen retrieved.\n\n@param callback callback that gets called when the user was retrieved from the data source."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/MyDoubleSum.java",
    "type": "method",
    "name": "update",
    "code": "@Override public void update(MutableAggregationBuffer buffer, Row input) {\n    if (!input.isNullAt(0)) {\n      if (buffer.isNullAt(0)) {\n        buffer.update(0, input.getDouble(0));\n      } else {\n        Double newValue = input.getDouble(0) + buffer.getDouble(0);\n        buffer.update(0, newValue);\n      }\n    }\n  }",
    "comment": "This input Row only has a single column storing the input value in Double.\nWe only update the buffer when the input value is not null.\nIf the buffer value (the intermediate result of the sum) is still null,\nwe set the input value to the buffer.\nOtherwise, we add the input value to the buffer value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "getArtifactMetadataPath",
    "code": "public String getArtifactMetadataPath(String gid, String aid, String version, String filename) {\n        return getArtifactMetadataPath(gid, aid, version, filename, null);\n    }",
    "comment": "Gets the path to a file in the local artifact directory. Note that the method does not check whether the returned\npath actually points to an existing file.\n\n@param gid      The group id, must not be <code>null</code>.\n@param aid      The artifact id, may be <code>null</code>.\n@param version  The artifact version, may be <code>null</code>.\n@param filename The filename to use, must not be <code>null</code>.\n@return The (absolute) path to the local artifact metadata, never <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(char unexpected, Character actual, String message) {\n\t\tAssertNotEquals.assertNotEquals((Character) unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(Object[] expected, Object[] actual) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} object arrays are deeply equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Nested float arrays are checked as in {@link #assertEquals(float, float)}.\n<p>Nested double arrays are checked as in {@link #assertEquals(double, double)}.\n\n@see Objects#equals(Object, Object)\n@see Arrays#deepEquals(Object[], Object[])"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/src/mdo/java/InputLocation.java",
    "type": "method",
    "name": "merge",
    "code": "public static InputLocation merge(InputLocation target, InputLocation source, Collection<Integer> indices) {\n        if (source == null) {\n            return target;\n        } else if (target == null) {\n            return source;\n        }\n\n        Map<Object, InputLocation> locations;\n        Map<Object, InputLocation> sourceLocations = source.locations;\n        Map<Object, InputLocation> targetLocations = target.locations;\n        if (sourceLocations == null) {\n            locations = targetLocations;\n        } else if (targetLocations == null) {\n            locations = sourceLocations;\n        } else {\n            locations = new LinkedHashMap<>();\n            for (int index : indices) {\n                InputLocation location;\n                if (index < 0) {\n                    location = sourceLocations.get(~index);\n                } else {\n                    location = targetLocations.get(index);\n                }\n                locations.put(locations.size(), location);\n            }\n        }\n\n        return new InputLocation(target.getLineNumber(), target.getColumnNumber(), target.getSource(), locations);\n    } // -- InputLocation merge( InputLocation, InputLocation, java.util.Collection )",
    "comment": "Merges the {@code source} location into the {@code target} location.\nThis method is used when the locations refer to lists and also merges the indices.\n\n@param target the target location\n@param source the source location\n@param indices the list of integers for the indices\n@return the merged location"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/EnabledIfSystemPropertyConditionTests.java",
    "type": "method",
    "name": "getExecutionCondition",
    "code": "protected ExecutionCondition getExecutionCondition() {\n\t\treturn new EnabledIfSystemPropertyCondition();\n\t}",
    "comment": "Unit tests for {@link EnabledIfSystemPropertyCondition}.\n\n<p>Note that test method names MUST match the test method names in\n{@link EnabledIfSystemPropertyIntegrationTests}.\n\n@since 5.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "fromBytes",
    "code": "public static UTF8String fromBytes(byte[] bytes, int offset, int numBytes) {\n    if (bytes != null) {\n      return new UTF8String(bytes, BYTE_ARRAY_OFFSET + offset, numBytes);\n    } else {\n      return null;\n    }\n  }",
    "comment": "Creates an UTF8String from byte array, which should be encoded in UTF-8.\n\nNote: `bytes` will be hold by returned UTF8String."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "selectors",
    "code": "public static Resolution selectors(Set<? extends DiscoverySelector> selectors) {\n\t\t\tPreconditions.containsNoNullElements(selectors, \"selectors must not contain null elements\");\n\t\t\tPreconditions.notEmpty(selectors, \"selectors must not be empty\");\n\t\t\treturn new Resolution(emptySet(), selectors);\n\t\t}",
    "comment": "Factory for creating a resolution that contains the supplied\n{@link DiscoverySelector DiscoverySelectors}.\n\n@param selectors the resolved {@code DiscoverySelectors}; never\n{@code null} or empty\n@return an resolution that contains the supplied\n{@code DiscoverySelectors}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-driven-architecture/src/test/java/com/iluwatar/eda/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/MethodMap.java",
    "type": "method",
    "name": "getApplicables",
    "code": "private static LinkedList<Method> getApplicables(List<Method> methods, Class<?>... classes) {\n        LinkedList<Method> list = new LinkedList<>();\n\n        for (Method method : methods) {\n            if (isApplicable(method, classes)) {\n                list.add(method);\n            }\n        }\n        return list;\n    }",
    "comment": "Returns all methods that are applicable to actual argument types.\n\n@param methods list of all candidate methods\n@param classes the actual types of the arguments\n@return a list that contains only applicable methods (number of\nformal and actual arguments matches, and argument types are assignable\nto formal types through a method invocation conversion)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java",
    "type": "method",
    "name": "removeWithTypeSafetyAndPrimitiveValueType",
    "code": "void removeWithTypeSafetyAndPrimitiveValueType() {\n\t\t\tString key = \"enigma\";\n\t\t\tint value = 42;\n\t\t\tstore.put(namespace, key, value);\n\n\t\t\tint requiredInt = store.remove(namespace, key, int.class);\n\t\t\tassertEquals(value, requiredInt);\n\n\t\t\tstore.put(namespace, key, value);\n\t\t\tInteger requiredInteger = store.get(namespace, key, Integer.class);\n\t\t\tassertEquals(value, requiredInteger.intValue());\n\t\t}",
    "comment": "The fact that we can declare this as an int suffices for testing the required type.\nThe fact that we can declare this as an Integer suffices for testing the required type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java",
    "type": "method",
    "name": "equals",
    "code": "public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n\n        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;\n\n        return patterns.equals(other.patterns);\n    }",
    "comment": "make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(char expected, Character actual) {\n\t\tAssertEquals.assertEquals((Character) expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java",
    "type": "method",
    "name": "methodInvoker",
    "code": "protected Statement methodInvoker(FrameworkMethod method, Object test) {\n        return new InvokeMethod(method, test);\n    }",
    "comment": "Returns a {@link Statement} that invokes {@code method} on {@code test}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "getMap",
    "code": "public final ColumnarMap getMap(int rowId) {\n    if (isNullAt(rowId)) return null;\n    return new ColumnarMap(getChild(0), getChild(1), getArrayOffset(rowId), getArrayLength(rowId));\n  }",
    "comment": "`WritableColumnVector` puts the key array in the first child column vector, value array in the\nsecond child column vector, and puts the offsets and lengths in the current column vector."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/BufferHolder.java",
    "type": "method",
    "name": "grow",
    "code": "void grow(int neededSize) {\n    if (neededSize < 0) {\n      throw new SparkIllegalArgumentException(\n        \"_LEGACY_ERROR_TEMP_3198\",\n        Map.of(\"neededSize\", String.valueOf(neededSize)));\n    }\n    if (neededSize > ARRAY_MAX - totalSize()) {\n      throw new SparkIllegalArgumentException(\n        \"_LEGACY_ERROR_TEMP_3199\",\n        Map.of(\"neededSize\", String.valueOf(neededSize), \"arrayMax\", String.valueOf(ARRAY_MAX)));\n    }\n    final int length = totalSize() + neededSize;\n    if (buffer.length < length) {\n      // This will not happen frequently, because the buffer is re-used.\n      int newLength = length < ARRAY_MAX / 2 ? length * 2 : ARRAY_MAX;\n      int roundedSize = ByteArrayMethods.roundNumberOfBytesToNearestWord(newLength);\n      final byte[] tmp = new byte[roundedSize];\n      Platform.copyMemory(\n        buffer,\n        Platform.BYTE_ARRAY_OFFSET,\n        tmp,\n        Platform.BYTE_ARRAY_OFFSET,\n        totalSize());\n      buffer = tmp;\n      row.pointTo(buffer, buffer.length);\n    }\n  }",
    "comment": "Grows the buffer by at least neededSize and points the row to the buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactResolver.java",
    "type": "method",
    "name": "newThread",
    "code": "public Thread newThread(Runnable r) {\n            Thread newThread = new Thread(GROUP, r, \"resolver-\" + THREAD_NUMBER.getAndIncrement());\n            newThread.setDaemon(true);\n            newThread.setContextClassLoader(null);\n            return newThread;\n        }",
    "comment": "ThreadCreator for creating daemon threads with fixed ThreadGroup-name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/SettingsUtilsV4.java",
    "type": "method",
    "name": "SettingsUtilsV4",
    "code": "private SettingsUtilsV4() {\n        // don't allow construction.\n    }",
    "comment": "Several convenience methods to handle settings"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "wasSuccessful",
    "code": "public synchronized boolean wasSuccessful() {\n        return failureCount() == 0 && errorCount() == 0;\n    }",
    "comment": "Returns whether the entire test was successful or not."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "setAcceleratorName",
    "code": "public Options setAcceleratorName(String name) {\n      this.acceleratorName = name;\n      return this;\n    }",
    "comment": "Specifies the name of the target accelerator to be used by NNAPI. If this parameter is\nspecified the {@link #setUseNnapiCpu(boolean)} method won't have any effect.\n\n<p>Only effective on Android 10 (API level 29) and above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Double expected, double actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Double) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "convertDurationsTo",
    "code": "public Builder convertDurationsTo(TimeUnit durationUnit) {\n            this.durationUnit = durationUnit;\n            return this;\n        }",
    "comment": "Convert durations to the given time unit.\n\n@param durationUnit a unit of time\n@return {@code this}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkSubmitCommandBuilder.java",
    "type": "method",
    "name": "buildSparkSubmitArgs",
    "code": "List<String> buildSparkSubmitArgs(boolean includeRemote) {\n    List<String> args = new ArrayList<>();\n    OptionParser parser = new OptionParser(false);\n    final boolean isSpecialCommand;\n\n    if (!userArgs.isEmpty()) {\n      parser.parse(userArgs);\n      isSpecialCommand = parser.isSpecialCommand;\n    } else {\n      isSpecialCommand = this.isSpecialCommand;\n    }\n\n    if (!allowsMixedArguments && !isSpecialCommand) {\n      checkArgument(appResource != null, \"Missing application resource.\");\n    }\n\n    if (verbose) {\n      args.add(parser.VERBOSE);\n    }\n\n    if (master != null) {\n      args.add(parser.MASTER);\n      args.add(master);\n    }\n\n    if (includeRemote && remote != null) {\n      args.add(parser.REMOTE);\n      args.add(remote);\n    }\n\n    if (deployMode != null) {\n      args.add(parser.DEPLOY_MODE);\n      args.add(deployMode);\n    }\n\n    if (appName != null) {\n      args.add(parser.NAME);\n      args.add(appName);\n    }\n\n    for (Map.Entry<String, String> e : conf.entrySet()) {\n      if (includeRemote ||\n           (!e.getKey().equalsIgnoreCase(\"spark.api.mode\") &&\n             !e.getKey().equalsIgnoreCase(\"spark.remote\"))) {\n        args.add(parser.CONF);\n        args.add(String.format(\"%s=%s\", e.getKey(), e.getValue()));\n      }\n    }\n\n    if (propertiesFile != null) {\n      args.add(parser.PROPERTIES_FILE);\n      args.add(propertiesFile);\n    }\n\n    if (isExample) {\n      jars.addAll(findExamplesJars());\n    }\n\n    if (!jars.isEmpty()) {\n      args.add(parser.JARS);\n      args.add(join(\",\", jars));\n    }\n\n    if (!files.isEmpty()) {\n      args.add(parser.FILES);\n      args.add(join(\",\", files));\n    }\n\n    if (!pyFiles.isEmpty()) {\n      args.add(parser.PY_FILES);\n      args.add(join(\",\", pyFiles));\n    }\n\n    if (isExample && !isSpecialCommand) {\n      checkArgument(mainClass != null, \"Missing example class name.\");\n    }\n\n    if (mainClass != null) {\n      args.add(parser.CLASS);\n      if (isRemote && \"1\".equals(getenv(\"SPARK_SCALA_SHELL\"))) {\n        args.add(\"org.apache.spark.sql.application.ConnectRepl\");\n      } else {\n        args.add(mainClass);\n      }\n    }\n\n    args.addAll(parsedArgs);\n\n    if (appResource != null) {\n      if (isRemote && \"1\".equals(getenv(\"SPARK_SCALA_SHELL\"))) {\n        args.add(\"connect-shell\");\n      } else {\n        args.add(appResource);\n      }\n    }\n\n    args.addAll(appArgs);\n\n    return args;\n  }",
    "comment": "If the user args array is not empty, we need to parse it to detect exactly what\nthe user is trying to run, so that checks below are correct."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/auth/HttpAuthUtils.java",
    "type": "method",
    "name": "splitCookieToken",
    "code": "private static Map<String, String> splitCookieToken(String tokenStr) {\n    Map<String, String> map = new HashMap<String, String>();\n    StringTokenizer st = new StringTokenizer(tokenStr, COOKIE_ATTR_SEPARATOR);\n\n    while (st.hasMoreTokens()) {\n      String part = st.nextToken();\n      int separator = part.indexOf(COOKIE_KEY_VALUE_SEPARATOR);\n      if (separator == -1) {\n        LOG.error(\"Invalid token string {}\", MDC.of(LogKeys.TOKEN$.MODULE$, tokenStr));\n        return null;\n      }\n      String key = part.substring(0, separator);\n      String value = part.substring(separator + 1);\n      map.put(key, value);\n    }\n    return map;\n  }",
    "comment": "Splits the cookie token into attributes pairs.\n@param str input token.\n@return a map with the attribute pairs of the token if the input is valid.\nElse, returns null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "setModelToken",
    "code": "public Options setModelToken(String modelToken) {\n      this.modelToken = modelToken;\n      return this;\n    }",
    "comment": "Sets the token to be used to identify this model in the model compilation cache. If either\n{@code cacheDir} or {@code modelToken} parameters are unset NNAPI caching will be disabled.\n\n<p>Only effective on Android 10 (API level 29) and above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/MethodMap.java",
    "type": "method",
    "name": "getApplicables",
    "code": "private static LinkedList<Method> getApplicables(List<Method> methods, Class<?>... classes) {\n        LinkedList<Method> list = new LinkedList<>();\n\n        for (Method method : methods) {\n            if (isApplicable(method, classes)) {\n                list.add(method);\n            }\n        }\n        return list;\n    }",
    "comment": "Returns all methods that are applicable to actual argument types.\n\n@param methods list of all candidate methods\n@param classes the actual types of the arguments\n@return a list that contains only applicable methods (number of\nformal and actual arguments matches, and argument types are assignable\nto formal types through a method invocation conversion)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutorTests.java",
    "type": "method",
    "name": "outOfMemoryErrorInLeafExecution",
    "code": "void outOfMemoryErrorInLeafExecution() {\n\t\tvar child = spy(new MyLeaf(UniqueId.root(\"leaf\", \"leaf\")));\n\t\tvar outOfMemoryError = new OutOfMemoryError(\"in test\");\n\t\twhen(child.execute(eq(rootContext), any())).thenThrow(outOfMemoryError);\n\t\troot.addChild(child);\n\n\t\tThrowable actualException = assertThrows(OutOfMemoryError.class, () -> executor.execute());\n\t\tassertSame(outOfMemoryError, actualException);\n\t}",
    "comment": "Verifies support for unrecoverable exceptions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "byteStringAsMb",
    "code": "public static long byteStringAsMb(String str) {\n    return byteStringAs(str, ByteUnit.MiB);\n  }",
    "comment": "Convert a passed byte string (e.g. 50b, 100k, or 250m) to mebibytes for\ninternal use.\n\nIf no suffix is provided, the passed number is assumed to be in mebibytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/WagonB.java",
    "type": "method",
    "name": "getSupportedProtocols",
    "code": "public String[] getSupportedProtocols() {\n        return new String[] {\"b1\", \"b2\"};\n}",
    "comment": "Wagon for testing, for protocols <code>b1</code> and <code>b2</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelNormalizer.java",
    "type": "method",
    "name": "injectList",
    "code": "private <T> List<T> injectList(List<T> list, UnaryOperator<T> modifer) {\n        List<T> newList = null;\n        for (int i = 0; i < list.size(); i++) {\n            T oldT = list.get(i);\n            T newT = modifer.apply(oldT);\n            if (newT != oldT) {\n                if (newList == null) {\n                    newList = new ArrayList<>(list);\n                }\n                newList.set(i, newT);\n            }\n        }\n        return newList;\n    }",
    "comment": "Returns a list suited for the builders, i.e. null if not modified"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/CartController.java",
    "type": "method",
    "name": "calculateTotal",
    "code": "public double calculateTotal(final String userId) {\n    return shoppingCartUseCase.calculateTotal(userId);\n  }",
    "comment": "Calculates the total cost of items in the user's cart.\n\n@param userId The ID of the user.\n@return The total price of all items in the cart."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/test/java/org/apache/spark/launcher/InProcessLauncherSuite.java",
    "type": "method",
    "name": "testSetup",
    "code": "public void testSetup() {\n    lastError = null;\n  }",
    "comment": "Arguments passed to the test class to identify the test being run."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelData.java",
    "type": "method",
    "name": "getGroupId",
    "code": "public String getGroupId() {\n        return (groupId != null) ? groupId : \"\";\n    }",
    "comment": "Gets the effective group identifier of the model.\n\n@return The effective group identifier of the model or an empty string if unknown, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setUtf8String",
    "code": "public void setUtf8String(UTF8String value) {\n    stringData = value;\n  }",
    "comment": "Sets the `UTF8String` `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/Result.java",
    "type": "method",
    "name": "newResult",
    "code": "public static <T> Result<T> newResult(T model, Iterable<? extends ModelProblem> problems) {\n        return new Result<>(hasErrors(problems), model, problems);\n    }",
    "comment": "New result - determine whether error or success by checking problems for errors\n\n@param model\n@param problems"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuildingRequest.java",
    "type": "method",
    "name": "setResolveVersionRanges",
    "code": "public ProjectBuildingRequest setResolveVersionRanges(boolean value) {\n        this.resolveVersionRanges = value;\n        return this;\n    }",
    "comment": "@since 3.2.2\n@deprecated This got added when implementing MNG-2199 and is no longer used.\nCommit 6cf9320942c34bc68205425ab696b1712ace9ba4 updated the way 'MavenProject' objects are initialized."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/main/java/com/example/android/observability/persistence/UsersDatabase.java",
    "type": "method",
    "name": "getInstance",
    "code": "public static UsersDatabase getInstance(Context context) {\n        if (INSTANCE == null) {\n            synchronized (UsersDatabase.class) {\n                if (INSTANCE == null) {\n                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                            UsersDatabase.class, \"Sample.db\")\n                            .build();\n                }\n            }\n        }\n        return INSTANCE;\n    }",
    "comment": "The Room database that contains the Users table"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenBaseLogger.java",
    "type": "method",
    "name": "MavenBaseLogger",
    "code": "protected MavenBaseLogger(String name) {\n        this.name = name;\n\n        String levelString = recursivelyComputeLevelString();\n        if (levelString != null) {\n            this.currentLogLevel = SimpleLoggerConfiguration.stringToLevel(levelString);\n        } else {\n            this.currentLogLevel = CONFIG_PARAMS.defaultLogLevel;\n        }\n    }",
    "comment": "Protected access allows only {@link MavenLoggerFactory} and also derived classes to instantiate\nMavenLoggerFactory instances."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/matchers/TypeSafeMatcher.java",
    "type": "method",
    "name": "matches",
    "code": "public final boolean matches(Object item) {\n        return item != null\n                && expectedType.isInstance(item)\n                && matchesSafely((T) item);\n    }",
    "comment": "Method made final to prevent accidental override.\nIf you need to override this, there's no point on extending TypeSafeMatcher.\nInstead, extend the {@link BaseMatcher}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/max/MaxHistory.java",
    "type": "method",
    "name": "testComparator",
    "code": "public Comparator<Description> testComparator() {\n        return new TestComparator();\n    }",
    "comment": "@return a comparator that ranks tests based on the JUnit Max sorting\nrules, as described in the {@link MaxCore} class comment."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultMojoExecutionConfigurator.java",
    "type": "method",
    "name": "DefaultMojoExecutionConfigurator",
    "code": "public DefaultMojoExecutionConfigurator() {\n        this.messageBuilderFactory = new DefaultMessageBuilderFactory();\n    }",
    "comment": "Default ctor is used in IT and most probably some 3rd party code. For those cases, we do provide sane defaults\nbut given this is a component, injection should be used, replacing direct instantiation.\n\n@deprecated Do not use this ctor directly, inject this component instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/ProtoSession.java",
    "type": "method",
    "name": "toBuilder",
    "code": "default Builder toBuilder() {\n        try {\n            return new Builder(\n                    getUserProperties(), getSystemProperties(), getStartTime(), getTopDirectory(), getRootDirectory());\n        } catch (IllegalStateException e) {\n            return new Builder(getUserProperties(), getSystemProperties(), getStartTime(), getTopDirectory(), null);\n        }\n    }",
    "comment": "Returns a proto session builder of this instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, float actual, float delta, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, delta, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Character unexpected, Character actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java",
    "type": "method",
    "name": "intersection",
    "code": "private List<Restriction> intersection(List<Restriction> r1, List<Restriction> r2) {\n        List<Restriction> restrictions = new ArrayList<>(r1.size() + r2.size());\n        Iterator<Restriction> i1 = r1.iterator();\n        Iterator<Restriction> i2 = r2.iterator();\n        Restriction res1 = i1.next();\n        Restriction res2 = i2.next();\n\n        boolean done = false;\n        while (!done) {\n            if (res1.getLowerBound() == null\n                    || res2.getUpperBound() == null\n                    || res1.getLowerBound().compareTo(res2.getUpperBound()) <= 0) {\n                if (res1.getUpperBound() == null\n                        || res2.getLowerBound() == null\n                        || res1.getUpperBound().compareTo(res2.getLowerBound()) >= 0) {\n                    ArtifactVersion lower;\n                    ArtifactVersion upper;\n                    boolean lowerInclusive;\n                    boolean upperInclusive;\n\n                    if (res1.getLowerBound() == null) {\n                        lower = res2.getLowerBound();\n                        lowerInclusive = res2.isLowerBoundInclusive();\n                    } else if (res2.getLowerBound() == null) {\n                        lower = res1.getLowerBound();\n                        lowerInclusive = res1.isLowerBoundInclusive();\n                    } else {\n                        int comparison = res1.getLowerBound().compareTo(res2.getLowerBound());\n                        if (comparison < 0) {\n                            lower = res2.getLowerBound();\n                            lowerInclusive = res2.isLowerBoundInclusive();\n                        } else if (comparison == 0) {\n                            lower = res1.getLowerBound();\n                            lowerInclusive = res1.isLowerBoundInclusive() && res2.isLowerBoundInclusive();\n                        } else {\n                            lower = res1.getLowerBound();\n                            lowerInclusive = res1.isLowerBoundInclusive();\n                        }\n                    }\n\n                    if (res1.getUpperBound() == null) {\n                        upper = res2.getUpperBound();\n                        upperInclusive = res2.isUpperBoundInclusive();\n                    } else if (res2.getUpperBound() == null) {\n                        upper = res1.getUpperBound();\n                        upperInclusive = res1.isUpperBoundInclusive();\n                    } else {\n                        int comparison = res1.getUpperBound().compareTo(res2.getUpperBound());\n                        if (comparison < 0) {\n                            upper = res1.getUpperBound();\n                            upperInclusive = res1.isUpperBoundInclusive();\n                        } else if (comparison == 0) {\n                            upper = res1.getUpperBound();\n                            upperInclusive = res1.isUpperBoundInclusive() && res2.isUpperBoundInclusive();\n                        } else {\n                            upper = res2.getUpperBound();\n                            upperInclusive = res2.isUpperBoundInclusive();\n                        }\n                    }\n\n                    if (lower == null || upper == null || lower.compareTo(upper) != 0) {\n                        restrictions.add(new Restriction(lower, lowerInclusive, upper, upperInclusive));\n                    } else if (lowerInclusive && upperInclusive) {\n                        restrictions.add(new Restriction(lower, lowerInclusive, upper, upperInclusive));\n                    }\n\n                    if (upper == res2.getUpperBound()) {\n                        if (i2.hasNext()) {\n                            res2 = i2.next();\n                        } else {\n                            done = true;\n                        }\n                    } else {\n                        if (i1.hasNext()) {\n                            res1 = i1.next();\n                        } else {\n                            done = true;\n                        }\n                    }\n                } else {\n                    if (i1.hasNext()) {\n                        res1 = i1.next();\n                    } else {\n                        done = true;\n                    }\n                }\n            } else {\n                if (i2.hasNext()) {\n                    res2 = i2.next();\n                } else {\n                    done = true;\n                }\n            }\n        }\n\n        return restrictions;\n    }",
    "comment": "overlaps\ndon't add if they are equal and one is not inclusive\nnoinspection ObjectEquality\nadvance res2\nadvance res1\nmove on to next in r1\nmove on to next in r2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultLegacySupport.java",
    "type": "method",
    "name": "setSession",
    "code": "public void setSession(MavenSession session) {\n        AtomicReference<MavenSession> reference = DefaultLegacySupport.SESSION.get();\n        if (reference != null) {\n            reference.set(null);\n        }\n\n        if (session == null && reference != null) {\n            DefaultLegacySupport.SESSION.remove();\n        } else {\n            DefaultLegacySupport.SESSION.set(new AtomicReference<>(session));\n        }\n    }",
    "comment": "Helps to provide backward-compatibility with plugins that use legacy components. <strong>Warning:</strong> This is an\ninternal utility component that is only public for technical reasons, it is not part of the public API. In\nparticular, this component can be changed or deleted without prior notice.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/server/TransportRequestHandler.java",
    "type": "method",
    "name": "respond",
    "code": "private ChannelFuture respond(Encodable result) {\n    SocketAddress remoteAddress = channel.remoteAddress();\n    return channel.writeAndFlush(result).addListener(future -> {\n      if (future.isSuccess()) {\n        logger.trace(\"Sent result {} to client {}\", result, remoteAddress);\n      } else {\n        logger.error(\"Error sending result {} to {}; closing connection\", future.cause(),\n          MDC.of(LogKeys.RESULT$.MODULE$, result),\n          MDC.of(LogKeys.HOST_PORT$.MODULE$, remoteAddress));\n        channel.close();\n      }\n    });\n  }",
    "comment": "Responds to a single message with some Encodable object. If a failure occurs while sending,\nit will be logged and the channel closed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "getFilePath",
    "code": "String getFilePath(String filename) {\n      String targetFile =\n        ExecutorDiskUtils.getFilePath(\n          appPathsInfo.activeLocalDirs,\n          appPathsInfo.subDirsPerLocalDir,\n          filename);\n      logger.debug(\"Get merged file {}\", targetFile);\n      return targetFile;\n    }",
    "comment": "The logic here is consistent with\n@see [[org.apache.spark.storage.DiskBlockManager#getMergedShuffleFile(\norg.apache.spark.storage.BlockId, scala.Option)]]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/SupportsOverwriteV2.java",
    "type": "method",
    "name": "canOverwrite",
    "code": "default boolean canOverwrite(Predicate[] predicates) {\n    return true;\n  }",
    "comment": "Checks whether it is possible to overwrite data from a data source table that matches filter\nexpressions.\n<p>\nRows should be overwritten from the data source iff all of the filter expressions match.\nThat is, the expressions must be interpreted as a set of filters that are ANDed together.\n\n@param predicates V2 filter expressions, used to match data to overwrite\n@return true if the delete operation can be performed\n\n@since 3.4.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantSchema.java",
    "type": "method",
    "name": "isUnshredded",
    "code": "public boolean isUnshredded() {\n    return topLevelMetadataIdx >= 0 && variantIdx >= 0 && typedIdx < 0;\n  }",
    "comment": "Return whether the variant column is unshrededed. The user is not required to do anything\nspecial, but can have certain optimizations for unshrededed variant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Float> create(float[][][][][][] data) {\n    return Tensor.create(data, Float.class);\n  }",
    "comment": "Creates a rank-6 tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/ssl/SslSampleConfigs.java",
    "type": "method",
    "name": "createDefaultConfigMap",
    "code": "public static Map<String, String> createDefaultConfigMap() {\n    Map<String, String> confMap = new HashMap<String, String>();\n    confMap.put(\"spark.ssl.rpc.enabled\", \"true\");\n    confMap.put(\"spark.ssl.rpc.openSslEnabled\", \"true\");\n    confMap.put(\"spark.ssl.rpc.privateKey\", SslSampleConfigs.unencryptedPrivateKeyPath);\n    // intentionally not set\n    // confMap.put(\"spark.ssl.rpc.privateKeyPassword\", \"password\");\n    confMap.put(\"spark.ssl.rpc.certChain\", SslSampleConfigs.unencryptedCertChainPath);\n    confMap.put(\"spark.ssl.enabled\", \"true\");\n    confMap.put(\"spark.ssl.keyPassword\", \"password\");\n    confMap.put(\"spark.ssl.trustStoreReloadingEnabled\", \"false\");\n    confMap.put(\"spark.ssl.trustStoreReloadIntervalMs\", \"10000\");\n    confMap.put(\"spark.ssl.keyStore\", SslSampleConfigs.keyStorePath);\n    confMap.put(\"spark.ssl.keyStorePassword\", \"password\");\n    confMap.put(\"spark.ssl.trustStore\", SslSampleConfigs.trustStorePath);\n    confMap.put(\"spark.ssl.trustStorePassword\", \"password\");\n    confMap.put(\"spark.ssl.protocol\", \"TLSv1.3\");\n    confMap.put(\"spark.ssl.standalone.enabled\", \"true\");\n    confMap.put(\"spark.ssl.ui.enabled\", \"true\");\n    return confMap;\n  }",
    "comment": "Creates a config map containing the settings needed to enable the RPC SSL feature\nAll the settings (except the enabled one) are intentionally set on the parent namespace\nso that we can verify settings inheritance works. We intentionally set conflicting\noptions for the key password to verify that is handled correctly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(char unexpected, char actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/NearestConflictResolverTest.java",
    "type": "method",
    "name": "testDepth",
    "code": "void testDepth() {\n        ResolutionNode a1n = createResolutionNode(a1);\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n\n        assertResolveConflict(a1n, a1n, a2n);\n    }",
    "comment": "Tests that <code>a:1.0</code> wins in the scenario:\n<pre>\na:1.0\nb:1.0 -&gt; a:2.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getSystemArtifacts",
    "code": "public List<Artifact> getSystemArtifacts() {\n        List<Artifact> list = new ArrayList<>(getArtifacts().size());\n\n        for (Artifact a : getArtifacts()) {\n            if (a.getArtifactHandler().isAddedToClasspath()) {\n                if (Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\n                    list.add(a);\n                }\n            }\n        }\n        return list;\n    }",
    "comment": "TODO classpath check doesn't belong here - that's the other method\nTODO let the scope handler deal with this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/main/java/org/apache/hadoop/hive/ql/io/DelegateSymlinkTextInputFormat.java",
    "type": "method",
    "name": "DelegateSymlinkTextInputSplit",
    "code": "public DelegateSymlinkTextInputSplit() {\n      super((Path) null, 0, 0, (String[]) null);\n      targetPath = null;\n    }",
    "comment": "Delegate for SymlinkTextInputFormat, created to address SPARK-40815.\nFixes an issue where SymlinkTextInputFormat returns empty splits which could result in\nthe correctness issue when \"spark.hadoopRDD.ignoreEmptySplits\" is enabled.\n<p>\nIn this class, we update the split start and length to match the target file input thus fixing\nthe issue."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ThrowableCollector.java",
    "type": "method",
    "name": "assertEmpty",
    "code": "public void assertEmpty() {\n\t\tif (!isEmpty()) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(this.throwable);\n\t\t}\n\t}",
    "comment": "Assert that this {@code ThrowableCollector} is <em>empty</em> (i.e.,\nhas not collected any {@code Throwables}).\n\n<p>If this collector is not empty, the first collected {@code Throwable}\nwill be thrown with any additional {@code Throwables}\n{@linkplain Throwable#addSuppressed(Throwable) suppressed} in the\nfirst {@code Throwable}. Note, however, that the {@code Throwable}\nwill not be wrapped. Rather, it will be\n{@linkplain ExceptionUtils#throwAsUncheckedException masked}\nas an unchecked exception.\n\n@see #getThrowable()\n@see ExceptionUtils#throwAsUncheckedException(Throwable)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Module.java",
    "type": "method",
    "name": "runMethod",
    "code": "public IValue runMethod(String methodName, IValue... inputs) {\n    return mNativePeer.runMethod(methodName, inputs);\n  }",
    "comment": "Runs the specified method of this module with the specified arguments.\n\n@param methodName name of the TorchScript method to run.\n@param inputs arguments that will be passed to TorchScript method.\n@return return value from the method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "Executions",
    "code": "private Executions(Stream<Execution> executions, String category) {\n\t\tPreconditions.notNull(executions, \"Execution stream must not be null\");\n\n\t\tthis.executions = Collections.unmodifiableList(executions.collect(toList()));\n\t\tthis.category = category;\n\t}",
    "comment": "{@code Executions} is a facade that provides a fluent API for working with\n{@linkplain Execution executions}.\n\n@since 1.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertLinesMatch.java",
    "type": "method",
    "name": "assertLinesMatch",
    "code": "void assertLinesMatch() {\n\t\t\tint expectedSize = expectedLines.size();\n\t\t\tint actualSize = actualLines.size();\n\n\t\t\tif (expectedSize > actualSize) {\n\t\t\t\tfail(\"expected %d lines, but only got %d\", expectedSize, actualSize);\n\t\t\t}\n\n\t\t\tif (expectedSize == actualSize) {\n\t\t\t\tif (IntStream.range(0, expectedSize).allMatch(i -> matches(expectedLines.get(i), actualLines.get(i)))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassertLinesMatchWithFastForward();\n\t\t}",
    "comment": "trivial case: when expecting more than actual lines available, something is wrong\nsimple case: both list are equally sized, compare them line-by-line\nelse fall-through to \"with fast-forward\" matching"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "parseProperty",
    "code": "private static String[] parseProperty(String line) {\n            // sorry for this spaghetti code, please replace it as soon as\n            // possible with a regexp when the Java 1.3 requirement is dropped\n\n            String[] result = new String[2];\n            StringBuilder key = new StringBuilder();\n            StringBuilder value = new StringBuilder();\n\n            // state of the automaton:\n            // 0: key parsing\n            // 1: antislash found while parsing the key\n            // 2: separator crossing\n            // 3: white spaces\n            // 4: value parsing\n            int state = 0;\n\n            for (int pos = 0; pos < line.length(); pos++) {\n                char c = line.charAt(pos);\n\n                switch (state) {\n                    case 0:\n                        if (c == '\\\\') {\n                            state = 1;\n                        } else if (contains(WHITE_SPACE, c)) {\n                            // switch to the separator crossing state\n                            state = 2;\n                        } else if (contains(SEPARATORS, c)) {\n                            // switch to the value parsing state\n                            state = 3;\n                        } else {\n                            key.append(c);\n                        }\n\n                        break;\n\n                    case 1:\n                        if (contains(SEPARATORS, c) || contains(WHITE_SPACE, c)) {\n                            // this is an escaped separator or white space\n                            key.append(c);\n                        } else {\n                            // another escaped character, the '\\' is preserved\n                            key.append('\\\\');\n                            key.append(c);\n                        }\n\n                        // return to the key parsing state\n                        state = 0;\n\n                        break;\n\n                    case 2:\n                        if (contains(WHITE_SPACE, c)) {\n                            // do nothing, eat all white spaces\n                            state = 2;\n                        } else if (contains(SEPARATORS, c)) {\n                            // switch to the value parsing state\n                            state = 3;\n                        } else {\n                            // any other character indicates we encoutered the beginning of the value\n                            value.append(c);\n\n                            // switch to the value parsing state\n                            state = 4;\n                        }\n\n                        break;\n\n                    case 3:\n                        if (contains(WHITE_SPACE, c)) {\n                            // do nothing, eat all white spaces\n                            state = 3;\n                        } else {\n                            // any other character indicates we encoutered the beginning of the value\n                            value.append(c);\n\n                            // switch to the value parsing state\n                            state = 4;\n                        }\n\n                        break;\n\n                    case 4:\n                        value.append(c);\n                        break;\n\n                    default:\n                        throw new IllegalStateException();\n                }\n            }\n\n            result[0] = key.toString();\n            result[1] = value.toString();\n\n            return result;\n        }",
    "comment": "Parse a property line and return the key and the value in an array.\n\n@param line the line to parse\n@return an array with the property's key and value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java",
    "type": "method",
    "name": "withTimeout",
    "code": "public Builder withTimeout(long timeout, TimeUnit unit) {\n            if (timeout < 0) {\n                throw new IllegalArgumentException(\"timeout must be non-negative\");\n            }\n            if (unit == null) {\n                throw new NullPointerException(\"TimeUnit cannot be null\");\n            }\n            this.timeout = timeout;\n            this.unit = unit;\n            return this;\n        }",
    "comment": "Specifies the time to wait before timing out the test.\n\n<p>If this is not called, or is called with a {@code timeout} of\n{@code 0}, the returned {@code Statement} will wait forever for the\ntest to complete, however the test will still launch from a separate\nthread. This can be useful for disabling timeouts in environments\nwhere they are dynamically set based on some property.\n\n@param timeout the maximum time to wait\n@param unit the time unit of the {@code timeout} argument\n@return {@code this} for method chaining."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ExceptionUtilsTests.java",
    "type": "method",
    "name": "throwAsUncheckedExceptionWithNullException",
    "code": "void throwAsUncheckedExceptionWithNullException() {\n\t\tassertThrows(PreconditionViolationException.class, () -> throwAsUncheckedException(null));\n\t}",
    "comment": "Unit tests for {@link ExceptionUtils}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProfileActivation.java",
    "type": "method",
    "name": "getActiveProfiles",
    "code": "public List<String> getActiveProfiles() {\n        return Collections.unmodifiableList(new ArrayList<>(getProfileIds(pa -> pa.active())));\n    }",
    "comment": "Mimics the pre-Maven 4 \"active profiles\" list.\n@deprecated Use {@link #getRequiredActiveProfileIds()} and {@link #getOptionalActiveProfileIds()} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaUserDefinedTypedAggregation.java",
    "type": "method",
    "name": "finish",
    "code": "public Double finish(Average reduction) {\n      return ((double) reduction.getSum()) / reduction.getCount();\n    }",
    "comment": "Transform the output of the reduction"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/MetadataResolutionResult.java",
    "type": "method",
    "name": "addVersionRangeViolation",
    "code": "public MetadataResolutionResult addVersionRangeViolation(Exception e) {\n        versionRangeViolations = initList(versionRangeViolations);\n\n        versionRangeViolations.add(e);\n\n        exceptions = initList(exceptions);\n\n        exceptions.add(e);\n\n        return this;\n    }",
    "comment": "TODO this needs to accept a {@link OverConstrainedVersionException} as returned by\n{@link #getVersionRangeViolation(int)} but it's not used like that in\n{@link org.apache.maven.repository.legacy.resolver.DefaultLegacyArtifactCollector}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Boolean> create(boolean[][][][] data) {\n    return Tensor.create(data, Boolean.class);\n  }",
    "comment": "Creates a rank-4 tensor of {@code boolean} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/ChildProcAppHandle.java",
    "type": "method",
    "name": "monitorChild",
    "code": "void monitorChild() {\n    Process proc = childProc;\n    if (proc == null) {\n      // Process may have already been disposed of, e.g. by calling kill().\n      return;\n    }\n\n    while (proc.isAlive()) {\n      try {\n        proc.waitFor();\n      } catch (Exception e) {\n        LOG.log(Level.WARNING, \"Exception waiting for child process to exit.\", e);\n      }\n    }\n\n    synchronized (this) {\n      if (isDisposed()) {\n        return;\n      }\n\n      int ec;\n      try {\n        ec = proc.exitValue();\n      } catch (Exception e) {\n        LOG.log(Level.WARNING, \"Exception getting child process exit code, assuming failure.\", e);\n        ec = 1;\n      }\n\n      if (ec != 0) {\n        State currState = getState();\n        // Override state with failure if the current state is not final, or is success.\n        if (!currState.isFinal() || currState == State.FINISHED) {\n          setState(State.FAILED, true);\n        }\n      }\n\n      dispose();\n    }\n  }",
    "comment": "Wait for the child process to exit and update the handle's state if necessary, according to\nthe exit code."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/graph/FilteredProjectDependencyGraph.java",
    "type": "method",
    "name": "getUpstreamProjects",
    "code": "public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive) {\n        Key key = new Key(project, transitive, true);\n        List<MavenProject> list = cache.get(key);\n        if (list == null) {\n            list = applyFilter(projectDependencyGraph.getUpstreamProjects(project, transitive), transitive, true);\n            cache.put(key, list);\n        }\n        return list;\n    }",
    "comment": "Do not use computeIfAbsent here, as the computation is recursive\nand this is not supported by computeIfAbsent."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "setProperty",
    "code": "public Object setProperty(String key, String value) {\n        return this.put(key, value);\n    }",
    "comment": "Calls the map method put. Provided for parallelism with the getProperty method.\nEnforces use of strings for property keys and values. The value returned is the result of the map call to put.\n\n@param key the key to be placed into this property list.\n@param value the value corresponding to the key.\n@return the previous value of the specified key in this property list, or null if it did not have one."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/util/collection/TestTimSort.java",
    "type": "method",
    "name": "runsJDKWorstCase",
    "code": "private static List<Long> runsJDKWorstCase(int minRun, int length) {\n    List<Long> runs = new ArrayList<>();\n\n    long runningTotal = 0, Y = minRun + 4, X = minRun;\n\n    while (runningTotal + Y + X <= length) {\n      runningTotal += X + Y;\n      generateJDKWrongElem(runs, minRun, X);\n      runs.add(0, Y);\n      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}\n      X = Y + runs.get(1) + 1;\n      // Y_{i+1} = X_{i+1} + Y_i + 1\n      Y += X + 1;\n    }\n\n    if (runningTotal + X <= length) {\n      runningTotal += X;\n      generateJDKWrongElem(runs, minRun, X);\n    }\n\n    runs.add(length - runningTotal);\n    return runs;\n  }",
    "comment": "Fills <code>runs</code> with a sequence of run lengths of the form<br>\nY_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>\nY_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>\n... <br>\nY_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>\nThe Y_i's are chosen to satisfy the invariant throughout execution,\nbut the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)\ninto an X_i that violates the invariant.\n\n@param length The sum of all run lengths that will be added to <code>runs</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/interpreter/src/test/java/com/iluwatar/interpreter/NumberExpressionTest.java",
    "type": "method",
    "name": "testFromString",
    "code": "void testFromString(NumberExpression first) {\n    final var expectedValue = first.interpret();\n    final var testStringValue = String.valueOf(expectedValue);\n    final var numberExpression = new NumberExpression(testStringValue);\n    assertEquals(expectedValue, numberExpression.interpret());\n  }",
    "comment": "Verify if the {@link NumberExpression#NumberExpression(String)} constructor works as expected"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "lookup",
    "code": "public Location lookup(Object keyBase, long keyOffset, int keyLength) {\n    safeLookup(keyBase, keyOffset, keyLength, loc,\n      Murmur3_x86_32.hashUnsafeWords(keyBase, keyOffset, keyLength, 42));\n    return loc;\n  }",
    "comment": "Looks up a key, and return a {@link Location} handle that can be used to test existence\nand read/write values.\n\nThis function always returns the same {@link Location} instance to avoid object allocation.\nThis function is not thread-safe."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/AnnotatedElementContext.java",
    "type": "method",
    "name": "findRepeatableAnnotations",
    "code": "default <A extends Annotation> List<A> findRepeatableAnnotations(Class<A> annotationType) {\n\t\treturn AnnotationSupport.findRepeatableAnnotations(getAnnotatedElement(), annotationType);\n\t}",
    "comment": "Find all <em>repeatable</em> {@linkplain Annotation annotations} of\n{@code annotationType} that are either <em>present</em> or\n<em>meta-present</em> on the {@link AnnotatedElement} for this context.\n\n<h4>WARNING</h4>\n<p>Favor the use of this method over directly invoking annotation lookup\nmethods in the {@link AnnotatedElement} API due to a bug in {@code javac} on JDK\nversions prior to JDK 9.\n\n@param <A> the annotation type\n@param annotationType the repeatable annotation type to search for; never\n{@code null}\n@return the list of all such annotations found; neither {@code null} nor\nmutable, but potentially empty\n@see #isAnnotated(Class)\n@see #findAnnotation(Class)\n@see java.lang.annotation.Repeatable"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java",
    "type": "method",
    "name": "parseClasspathResourcesWithFilePosition",
    "code": "void parseClasspathResourcesWithFilePosition() {\n\t\t\tvar filePosition = FilePosition.from(12, 34);\n\t\t\tvar selector = parseIdentifier(selectClasspathResource(\"/foo/bar/spec.xml\", FilePosition.from(12, 34)));\n\t\t\tassertThat(selector) //\n\t\t\t\t\t.asInstanceOf(type(ClasspathResourceSelector.class)) //\n\t\t\t\t\t.extracting(ClasspathResourceSelector::getClasspathResourceName,\n\t\t\t\t\t\tClasspathResourceSelector::getPosition) //\n\t\t\t\t\t.containsExactly(\"foo/bar/spec.xml\", Optional.of(filePosition));\n\n\t\t\tselector = parseIdentifier(selectClasspathResource(\"A/B/C/spec.json\", FilePosition.from(12, 34)));\n\t\t\tassertThat(selector) //\n\t\t\t\t\t.asInstanceOf(type(ClasspathResourceSelector.class)) //\n\t\t\t\t\t.extracting(ClasspathResourceSelector::getClasspathResourceName,\n\t\t\t\t\t\tClasspathResourceSelector::getPosition) //\n\t\t\t\t\t.containsExactly(\"A/B/C/spec.json\", Optional.of(filePosition));\n\t\t}",
    "comment": "with unnecessary \"/\" prefix\nstandard use case"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testNormalize2",
    "code": "public void testNormalize2() {\n        Money expected = new Money(7, \"USD\");\n        assertEquals(expected, fMB1.subtract(f12CHF));\n    }",
    "comment": "{[12 CHF][7 USD]} - [12 CHF] == [7 USD]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(float unexpected, Float actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Float) unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-layer/src/main/java/com/iluwatar/servicelayer/hibernate/HibernateUtil.java",
    "type": "method",
    "name": "dropSession",
    "code": "public static void dropSession() {\n    getSessionFactory().close();\n    sessionFactory = null;\n  }",
    "comment": "Drop the current connection, resulting in a create-drop clean database next time. This is\nmainly used for JUnit testing since one test should not influence the other"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaLatentDirichletAllocationExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaKLatentDirichletAllocationExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    String path = \"data/mllib/sample_lda_data.txt\";\n    JavaRDD<String> data = jsc.textFile(path);\n    JavaRDD<Vector> parsedData = data.map(s -> {\n      String[] sarray = s.trim().split(\" \");\n      double[] values = new double[sarray.length];\n      for (int i = 0; i < sarray.length; i++) {\n        values[i] = Double.parseDouble(sarray[i]);\n      }\n      return Vectors.dense(values);\n    });\n    JavaPairRDD<Long, Vector> corpus =\n      JavaPairRDD.fromJavaRDD(parsedData.zipWithIndex().map(Tuple2::swap));\n    corpus.cache();\n\n    LDAModel ldaModel = new LDA().setK(3).run(corpus);\n\n    System.out.println(\"Learned topics (as distributions over vocab of \" + ldaModel.vocabSize()\n      + \" words):\");\n    Matrix topics = ldaModel.topicsMatrix();\n    for (int topic = 0; topic < 3; topic++) {\n      System.out.print(\"Topic \" + topic + \":\");\n      for (int word = 0; word < ldaModel.vocabSize(); word++) {\n        System.out.print(\" \" + topics.apply(word, topic));\n      }\n      System.out.println();\n    }\n\n    ldaModel.save(jsc.sc(),\n      \"target/org/apache/spark/JavaLatentDirichletAllocationExample/LDAModel\");\n    DistributedLDAModel sameModel = DistributedLDAModel.load(jsc.sc(),\n      \"target/org/apache/spark/JavaLatentDirichletAllocationExample/LDAModel\");\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data\nIndex documents with unique IDs\nCluster the documents into three topics using LDA\nOutput topics. Each is a distribution over words (matching word count vectors)\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/FunctionUtilsTests.java",
    "type": "method",
    "name": "whereWithNullFunction",
    "code": "void whereWithNullFunction() {\n\t\tvar exception = assertThrows(PreconditionViolationException.class, () -> FunctionUtils.where(null, o -> true));\n\t\tassertEquals(\"function must not be null\", exception.getMessage());\n\t}",
    "comment": "Unit tests for {@link FunctionUtils}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/SelectorResolutionResult.java",
    "type": "method",
    "name": "failed",
    "code": "public static SelectorResolutionResult failed(Throwable throwable) {\n\t\treturn new SelectorResolutionResult(Status.FAILED, throwable);\n\t}",
    "comment": "Create a {@code SelectorResolutionResult} for a <em>failed</em>\nselector resolution.\n@return the {@code SelectorResolutionResult}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/ReflectionValueExtractor.java",
    "type": "method",
    "name": "nextPropertyName",
    "code": "public String nextPropertyName() {\n            final int start = idx;\n\n            while (idx < expression.length() && Character.isJavaIdentifierPart(expression.charAt(idx))) {\n                idx++;\n            }\n\n            if (idx <= start || idx > expression.length()) {\n                return null;\n            }\n\n            return expression.substring(start, idx);\n        }",
    "comment": "property name does not require delimiter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "registerExecutor",
    "code": "public void registerExecutor(String appId, ExecutorShuffleInfo executorInfo) {\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"register executor with RemoteBlockPushResolver {} local-dirs {} \"\n        + \"num sub-dirs {} shuffleManager {}\", appId, Arrays.toString(executorInfo.localDirs),\n        executorInfo.subDirsPerLocalDir, executorInfo.shuffleManager);\n    }\n    String shuffleManagerMeta = executorInfo.shuffleManager;\n    if (shuffleManagerMeta.contains(SHUFFLE_META_DELIMITER)) {\n      String mergeDirInfo =\n        shuffleManagerMeta.substring(shuffleManagerMeta.indexOf(SHUFFLE_META_DELIMITER) + 1);\n      try {\n        ObjectMapper mapper = new ObjectMapper();\n        TypeReference<Map<String, String>> typeRef\n          = new TypeReference<Map<String, String>>(){};\n        if (attemptId == UNDEFINED_ATTEMPT_ID) {\n          appsShuffleInfo.computeIfAbsent(appId, id -> {\n            AppPathsInfo appPathsInfo = new AppPathsInfo(appId, executorInfo.localDirs,\n                mergeDir, executorInfo.subDirsPerLocalDir);\n            writeAppPathsInfoToDb(appId, UNDEFINED_ATTEMPT_ID, appPathsInfo);\n            return new AppShuffleInfo(appId, UNDEFINED_ATTEMPT_ID, appPathsInfo);\n          });\n        } else {\n          AtomicReference<AppShuffleInfo> originalAppShuffleInfo = new AtomicReference<>();\n          appsShuffleInfo.compute(appId, (id, appShuffleInfo) -> {\n            if (appShuffleInfo == null || attemptId > appShuffleInfo.attemptId) {\n              originalAppShuffleInfo.set(appShuffleInfo);\n              AppPathsInfo appPathsInfo = new AppPathsInfo(appId, executorInfo.localDirs,\n                  mergeDir, executorInfo.subDirsPerLocalDir);\n              if (appShuffleInfo != null) {\n                removeAppAttemptPathInfoFromDB(appId, appShuffleInfo.attemptId);\n              }\n              writeAppPathsInfoToDb(appId, attemptId, appPathsInfo);\n              appShuffleInfo =\n                new AppShuffleInfo(\n                  appId, attemptId,\n                  new AppPathsInfo(appId, executorInfo.localDirs,\n                    mergeDir, executorInfo.subDirsPerLocalDir));\n            }\n            return appShuffleInfo;\n          });\n          if (originalAppShuffleInfo.get() != null) {\n            AppShuffleInfo appShuffleInfo = originalAppShuffleInfo.get();\n            logger.warn(\"Cleanup shuffle info and merged shuffle files for {}_{} as new \" +\n        }\n      } catch (JsonProcessingException e) {\n        logger.warn(\"Failed to get the merge directory information from ExecutorShuffleInfo: \", e);\n      }\n    } else {\n      logger.warn(\"ExecutorShuffleInfo does not have the expected merge directory information\");\n    }\n  }\n\n  @Override\n  public void close() {\n    if (!mergedShuffleCleaner.isShutdown()) {\n      // SPARK-40186：Use two phases shutdown refer to\n      // https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html\n      // Use two phases shutdown can prevent new tasks and wait for executing tasks to\n      // complete gracefully, and once timeout is reached, we want to interrupt running tasks,\n      // so that they fail. This is to prevent updates to shuffle state db after it is closed.\n      try {\n        mergedShuffleCleaner.shutdown();\n        // Wait a while for existing tasks to terminate\n        if (!mergedShuffleCleaner.awaitTermination(cleanerShutdownTimeout, TimeUnit.SECONDS)) {\n          shutdownMergedShuffleCleanerNow();\n        }\n      } catch (InterruptedException e) {\n        logger.info(\"mergedShuffleCleaner is interrupted in the process of graceful shutdown\", e);\n        shutdownMergedShuffleCleanerNow();\n        Thread.currentThread().interrupt();\n      }\n    }\n    if (db != null) {\n      try {\n        db.close();\n      } catch (IOException e) {\n        logger.error(\"Exception closing leveldb with registered app paths info and \"\n            + \"shuffle partition info\", e);\n      }\n    }\n  }\n\n  private void shutdownMergedShuffleCleanerNow() {\n    try {\n      List<Runnable> unfinishedTasks = mergedShuffleCleaner.shutdownNow();\n      logger.warn(\"There are still {} tasks not completed in mergedShuffleCleaner \" +\n        \"after {} ms.\",\n         MDC.of(LogKeys.COUNT$.MODULE$, unfinishedTasks.size()),\n         MDC.of(LogKeys.TIMEOUT$.MODULE$, cleanerShutdownTimeout * 1000L));\n      // Wait a while for tasks to respond to being cancelled\n      if (!mergedShuffleCleaner.awaitTermination(cleanerShutdownTimeout, TimeUnit.SECONDS)) {\n        logger.warn(\"mergedShuffleCleaner did not terminate in {} ms.\",\n          MDC.of(LogKeys.TIMEOUT$.MODULE$, cleanerShutdownTimeout * 1000L));\n      }\n    } catch (InterruptedException ignored) {\n      Thread.currentThread().interrupt();\n    }\n  }\n\n  private void writeAppPathsInfoToDb(String appId, int attemptId, AppPathsInfo appPathsInfo) {\n    if (db != null && AppsWithRecoveryDisabled.isRecoveryEnabledForApp(appId)) {\n      AppAttemptId appAttemptId = new AppAttemptId(appId, attemptId);\n      try {\n        byte[] key = getDbAppAttemptPathsKey(appAttemptId);\n        String valueStr = mapper.writeValueAsString(appPathsInfo);\n        byte[] value = valueStr.getBytes(StandardCharsets.UTF_8);\n        db.put(key, value);\n      } catch (Exception e) {\n        logger.error(\"Error saving registered app paths info for {}\", e,\n          MDC.of(LogKeys.APP_ATTEMPT_ID$.MODULE$, appAttemptId));\n      }\n    }\n  }\n\n  private void writeAppAttemptShuffleMergeInfoToDB(\n      AppAttemptShuffleMergeId appAttemptShuffleMergeId) {\n    if (db != null && AppsWithRecoveryDisabled.isRecoveryEnabledForApp(\n        appAttemptShuffleMergeId.appId)) {\n      // Write AppAttemptShuffleMergeId into LevelDB for finalized shuffles\n      try{\n        byte[] dbKey = getDbAppAttemptShufflePartitionKey(appAttemptShuffleMergeId);\n        db.put(dbKey, new byte[0]);\n      } catch (Exception e) {\n        logger.error(\"Error saving active app shuffle partition {}\", e,\n          MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId));\n      }\n    }\n  }\n\n  private <T> T parseDbKey(String key, String prefix, Class<T> valueType) throws IOException {\n    String json = key.substring(prefix.length() + 1);\n    return mapper.readValue(json, valueType);\n  }\n\n  private AppAttemptId parseDbAppAttemptPathsKey(String key) throws IOException {\n    return parseDbKey(key, APP_ATTEMPT_PATH_KEY_PREFIX, AppAttemptId.class);\n  }\n\n  private AppAttemptShuffleMergeId parseDbAppAttemptShufflePartitionKey(\n      String key) throws IOException {\n    return parseDbKey(\n        key, APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX, AppAttemptShuffleMergeId.class);\n  }\n\n  private byte[] getDbKey(Object key, String prefix) throws IOException {\n    // We add a common prefix on all the keys so we can find them in the DB\n    String keyJsonString = prefix + DB_KEY_DELIMITER + mapper.writeValueAsString(key);\n    return keyJsonString.getBytes(StandardCharsets.UTF_8);\n  }\n\n  private byte[] getDbAppAttemptShufflePartitionKey(\n      AppAttemptShuffleMergeId appAttemptShuffleMergeId) throws IOException {\n    return getDbKey(appAttemptShuffleMergeId, APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX);\n  }\n\n  private byte[] getDbAppAttemptPathsKey(AppAttemptId appAttemptId) throws IOException {\n    return getDbKey(appAttemptId, APP_ATTEMPT_PATH_KEY_PREFIX);\n  }\n\n  @VisibleForTesting\n  void reloadAndCleanUpAppShuffleInfo(DB db) throws IOException {\n    logger.info(\"Reload applications merged shuffle information from DB\");\n    List<byte[]> dbKeysToBeRemoved = new ArrayList<>();\n    dbKeysToBeRemoved.addAll(reloadActiveAppAttemptsPathInfo(db));\n    dbKeysToBeRemoved.addAll(reloadFinalizedAppAttemptsShuffleMergeInfo(db));\n    removeOutdatedKeyValuesInDB(dbKeysToBeRemoved);\n  }\n\n  @VisibleForTesting\n  List<byte[]> reloadActiveAppAttemptsPathInfo(DB db) throws IOException {\n    List<byte[]> dbKeysToBeRemoved = new ArrayList<>();\n    if (db != null) {\n      try (DBIterator itr = db.iterator()) {\n        itr.seek(APP_ATTEMPT_PATH_KEY_PREFIX.getBytes(StandardCharsets.UTF_8));\n        while (itr.hasNext()) {\n          Map.Entry<byte[], byte[]> entry = itr.next();\n          String key = new String(entry.getKey(), StandardCharsets.UTF_8);\n          if (!key.startsWith(APP_ATTEMPT_PATH_KEY_PREFIX)) {\n            break;\n          }\n          AppAttemptId appAttemptId = parseDbAppAttemptPathsKey(key);\n          AppPathsInfo appPathsInfo = mapper.readValue(entry.getValue(), AppPathsInfo.class);\n          logger.debug(\"Reloading Application paths info for application {}\", appAttemptId);\n          appsShuffleInfo.compute(appAttemptId.appId,\n              (appId, existingAppShuffleInfo) -> {\n                if (existingAppShuffleInfo == null ||\n                    existingAppShuffleInfo.attemptId < appAttemptId.attemptId) {\n                  if (existingAppShuffleInfo != null) {\n                    AppAttemptId existingAppAttemptId = new AppAttemptId(\n                        existingAppShuffleInfo.appId, existingAppShuffleInfo.attemptId);\n                    try {\n                      // Add the former outdated DB key to deletion list\n                      dbKeysToBeRemoved.add(getDbAppAttemptPathsKey(existingAppAttemptId));\n                    } catch (IOException e) {\n                      logger.error(\"Failed to get the DB key for {}\", e,\n                        MDC.of(LogKeys.APP_ATTEMPT_ID$.MODULE$, existingAppAttemptId));\n                    }\n                  }\n                  return new AppShuffleInfo(\n                      appAttemptId.appId, appAttemptId.attemptId, appPathsInfo);\n                } else {\n                  // Add the current DB key to deletion list as it is outdated\n                  dbKeysToBeRemoved.add(entry.getKey());\n                  return existingAppShuffleInfo;\n                }\n          });\n        }\n      }\n    }\n    return dbKeysToBeRemoved;\n  }\n\n  @VisibleForTesting\n  List<byte[]> reloadFinalizedAppAttemptsShuffleMergeInfo(DB db) throws IOException {\n    List<byte[]> dbKeysToBeRemoved = new ArrayList<>();\n    if (db != null) {\n      try (DBIterator itr = db.iterator()) {\n        itr.seek(APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX.getBytes(StandardCharsets.UTF_8));\n        while (itr.hasNext()) {\n          Map.Entry<byte[], byte[]> entry = itr.next();\n          String key = new String(entry.getKey(), StandardCharsets.UTF_8);\n          if (!key.startsWith(APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX)) {\n            break;\n          }\n          AppAttemptShuffleMergeId partitionId = parseDbAppAttemptShufflePartitionKey(key);\n          logger.debug(\"Reloading finalized shuffle info for partitionId {}\", partitionId);\n          AppShuffleInfo appShuffleInfo = appsShuffleInfo.get(partitionId.appId);\n          if (appShuffleInfo != null && appShuffleInfo.attemptId == partitionId.attemptId) {\n            appShuffleInfo.shuffles.compute(partitionId.shuffleId,\n                (shuffleId, existingMergePartitionInfo) -> {\n                  if (existingMergePartitionInfo == null ||\n                      existingMergePartitionInfo.shuffleMergeId < partitionId.shuffleMergeId) {\n                    if (existingMergePartitionInfo != null) {\n                      AppAttemptShuffleMergeId appAttemptShuffleMergeId =\n                          new AppAttemptShuffleMergeId(\n                              appShuffleInfo.appId, appShuffleInfo.attemptId,\n                              shuffleId, existingMergePartitionInfo.shuffleMergeId);\n                      try{\n                        dbKeysToBeRemoved.add(\n                            getDbAppAttemptShufflePartitionKey(appAttemptShuffleMergeId));\n                      } catch (Exception e) {\n                        logger.error(\"Error getting the DB key for {}\", e, MDC.of(\n                          LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId));\n                      }\n                    }\n                    return new AppShuffleMergePartitionsInfo(partitionId.shuffleMergeId, true);\n                  } else {\n                    dbKeysToBeRemoved.add(entry.getKey());\n                    return existingMergePartitionInfo;\n                  }\n            });\n          } else {\n            dbKeysToBeRemoved.add(entry.getKey());\n          }\n        }\n      }\n    }\n    return dbKeysToBeRemoved;\n  }\n\n  @VisibleForTesting\n  void removeOutdatedKeyValuesInDB(List<byte[]> dbKeysToBeRemoved) {\n      dbKeysToBeRemoved.forEach(\n          (key) -> {\n            try {\n              db.delete(key);\n            } catch (Exception e) {\n              logger.error(\"Error deleting dangling key {} in DB\", e,\n                MDC.of(LogKeys.KEY$.MODULE$, key));\n            }\n          }\n      );\n  }\n\n  @VisibleForTesting\n  void submitCleanupTask(Runnable task) {\n    mergedShuffleCleaner.execute(task);\n  }\n\n  @VisibleForTesting\n  boolean isCleanerShutdown() {\n    return mergedShuffleCleaner.isShutdown();\n  }\n\n  static class PushBlockStreamCallback implements StreamCallbackWithID {\n\n    private final RemoteBlockPushResolver mergeManager;\n    private final AppShuffleInfo appShuffleInfo;\n    private final String streamId;\n    private final int mapIndex;\n    private final AppShufflePartitionInfo partitionInfo;\n    private int length = 0;\n    // This indicates that this stream got the opportunity to write the blocks to the merged file.\n    // Once this is set to true and the stream encounters a failure then it will unset the\n    // currentMapId of the partition so that another stream can start merging the blocks to the\n    // partition. This is reset to false when the stream completes.\n    private boolean isWriting = false;\n    // Use on-heap instead of direct ByteBuffer since these buffers will be GC'ed very quickly\n    private List<ByteBuffer> deferredBufs;\n\n    // This collects the total pushed block bytes received in the onData method. Once these bytes\n    // are not being used, we add them to the ignoredBlockBytes of the pushMergeMetrics.\n    private long receivedBytes = 0;\n\n    private PushBlockStreamCallback(\n        RemoteBlockPushResolver mergeManager,\n        AppShuffleInfo appShuffleInfo,\n        String streamId,\n        AppShufflePartitionInfo partitionInfo,\n        int mapIndex) {\n      Preconditions.checkArgument(mergeManager != null);\n      this.mergeManager = mergeManager;\n      Preconditions.checkArgument(appShuffleInfo != null);\n      this.appShuffleInfo = appShuffleInfo;\n      this.streamId = streamId;\n      Preconditions.checkArgument(partitionInfo != null);\n      this.partitionInfo = partitionInfo;\n      this.mapIndex = mapIndex;\n      abortIfNecessary();\n    }\n\n    @Override\n    public String getID() {\n      return streamId;\n    }\n\n    @Override\n    public ByteBuffer getCompletionResponse() {\n      return SUCCESS_RESPONSE.duplicate();\n    }\n\n    private void writeBuf(ByteBuffer buf) throws IOException {\n      while (buf.hasRemaining()) {\n        long updatedPos = partitionInfo.getDataFilePos() + length;\n        logger.debug(\"{} current pos {} updated pos {}\", partitionInfo,\n          partitionInfo.getDataFilePos(), updatedPos);\n        int bytesWritten = partitionInfo.dataChannel.write(buf, updatedPos);\n        length += bytesWritten;\n        mergeManager.pushMergeMetrics.blockBytesWritten.mark(bytesWritten);\n      }\n    }\n\n    private boolean allowedToWrite() {\n      return partitionInfo.getCurrentMapIndex() < 0\n        || partitionInfo.getCurrentMapIndex() == mapIndex;\n    }\n\n    private boolean isDuplicateBlock() {\n      return (partitionInfo.getCurrentMapIndex() == mapIndex && length == 0)\n        || partitionInfo.mapTracker.contains(mapIndex);\n    }\n\n    private void writeDeferredBufs() throws IOException {\n      long totalSize = 0;\n      for (ByteBuffer deferredBuf : deferredBufs) {\n        totalSize += deferredBuf.limit();\n        writeBuf(deferredBuf);\n        mergeManager.pushMergeMetrics.deferredBlocks.mark(-1);\n      }\n      mergeManager.pushMergeMetrics.deferredBlockBytes.dec(totalSize);\n      deferredBufs = null;\n    }\n\n    private void freeDeferredBufs() {\n      if (deferredBufs != null && !deferredBufs.isEmpty()) {\n        long totalSize = 0;\n        for (ByteBuffer deferredBuf : deferredBufs) {\n          totalSize += deferredBuf.limit();\n          mergeManager.pushMergeMetrics.deferredBlocks.mark(-1);\n        }\n        mergeManager.pushMergeMetrics.deferredBlockBytes.dec(totalSize);\n      }\n      deferredBufs = null;\n    }\n\n    private void abortIfNecessary() {\n      if (partitionInfo.shouldAbort(mergeManager.ioExceptionsThresholdDuringMerge)) {\n        freeDeferredBufs();\n        throw new IllegalStateException(String.format(\"%s when merging %s\",\n          ErrorHandler.BlockPushErrorHandler.IOEXCEPTIONS_EXCEEDED_THRESHOLD_PREFIX,\n          streamId));\n      }\n    }\n\n    private void updateIgnoredBlockBytes() {\n      if (receivedBytes > 0) {\n        mergeManager.pushMergeMetrics.ignoredBlockBytes.mark(receivedBytes);\n        receivedBytes = 0;\n      }\n    }\n\n    private void incrementIOExceptionsAndAbortIfNecessary() {\n      // Update the count of IOExceptions\n      partitionInfo.incrementIOExceptions();\n      abortIfNecessary();\n    }\n\n    private boolean isStale(\n        AppShuffleMergePartitionsInfo appShuffleMergePartitionsInfo,\n        int shuffleMergeId) {\n      return null == appShuffleMergePartitionsInfo ||\n        appShuffleMergePartitionsInfo.shuffleMergeId > shuffleMergeId;\n    }\n\n    private boolean isTooLate(\n        AppShuffleMergePartitionsInfo appShuffleMergePartitionsInfo,\n        int reduceId) {\n      return null == appShuffleMergePartitionsInfo ||\n        appShuffleMergePartitionsInfo.isFinalized() ||\n        !appShuffleMergePartitionsInfo.shuffleMergePartitions.containsKey(reduceId);\n    }\n\n    @Override\n    public void onData(String streamId, ByteBuffer buf) throws IOException {\n      receivedBytes += buf.remaining();\n      // When handling the block data using StreamInterceptor, it can help to reduce the amount\n      // of data that needs to be buffered in memory since it does not wait till the completion\n      // of the frame before handling the message, thus releasing the ByteBuf earlier. However,\n      // this also means it would chunk a block into multiple buffers. Here, we want to preserve\n      // the benefit of handling the block data using StreamInterceptor as much as possible while\n      // providing the guarantee that one block would be continuously written to the merged\n      // shuffle file before the next block starts. For each shuffle partition, we would track\n      // the current map index to make sure only block matching the map index can be written to\n      // disk. If one server thread sees the block being handled is the current block, it would\n      // directly write the block to disk. Otherwise, it would buffer the block chunks in memory.\n      // If the block becomes the current block before we see the end of it, we would then dump\n      // all buffered block data to disk and write the remaining portions of the block directly\n      // to disk as well. This way, we avoid having to buffer the entirety of every blocks in\n      // memory, while still providing the necessary guarantee.\n      synchronized (partitionInfo) {\n        AppShuffleMergePartitionsInfo info =\n            appShuffleInfo.shuffles.get(partitionInfo.appAttemptShuffleMergeId.shuffleId);\n        boolean isStaleBlockPush =\n            isStale(info, partitionInfo.appAttemptShuffleMergeId.shuffleMergeId);\n        boolean isTooLateBlockPush = isTooLate(info, partitionInfo.reduceId);\n        if (isStaleBlockPush || isTooLateBlockPush) {\n          freeDeferredBufs();\n          if (isTooLateBlockPush) {\n            mergeManager.pushMergeMetrics.lateBlockPushes.mark();\n          } else {\n            mergeManager.pushMergeMetrics.staleBlockPushes.mark();\n          }\n          return;\n        }\n        // Check whether we can write to disk\n        if (allowedToWrite()) {\n          // Identify duplicate block generated by speculative tasks. We respond success to\n          // the client in cases of duplicate even though no data is written.\n          if (isDuplicateBlock()) {\n            freeDeferredBufs();\n            return;\n          }\n          abortIfNecessary();\n          logger.trace(\"{} onData writable\", partitionInfo);\n          if (partitionInfo.getCurrentMapIndex() < 0) {\n            partitionInfo.setCurrentMapIndex(mapIndex);\n          }\n\n          // If we got here, it's safe to write the block data to the merged shuffle file. We\n          // first write any deferred block.\n          isWriting = true;\n          try {\n            if (deferredBufs != null && !deferredBufs.isEmpty()) {\n              writeDeferredBufs();\n            }\n            writeBuf(buf);\n          } catch (IOException ioe) {\n            incrementIOExceptionsAndAbortIfNecessary();\n            // If the above doesn't throw a RuntimeException, then we propagate the IOException\n            // back to the client so the block could be retried.\n            throw ioe;\n          }\n        } else {\n          logger.trace(\"{} onData deferred\", partitionInfo);\n          // If we cannot write to disk, we buffer the current block chunk in memory so it could\n          // potentially be written to disk later. We take our best effort without guarantee\n          // that the block will be written to disk. If the block data is divided into multiple\n          // chunks during TCP transportation, each #onData invocation is an attempt to write\n          // the block to disk. If the block is still not written to disk after all #onData\n          // invocations, the final #onComplete invocation is the last attempt to write the\n          // block to disk. If we still couldn't write this block to disk after this, we give up\n          // on this block push request and respond failure to client. We could potentially\n          // buffer the block longer or wait for a few iterations inside #onData or #onComplete\n          // to increase the chance of writing the block to disk, however this would incur more\n          // memory footprint or decrease the server processing throughput for the shuffle\n          // service. In addition, during test we observed that by randomizing the order in\n          // which clients sends block push requests batches, only ~0.5% blocks failed to be\n          // written to disk due to this reason. We thus decide to optimize for server\n          // throughput and memory usage.\n          if (deferredBufs == null) {\n            deferredBufs = new ArrayList<>();\n          }\n          // Write the buffer to the in-memory deferred cache. Since buf is a slice of a larger\n          // byte buffer, we cache only the relevant bytes not the entire large buffer to save\n          // memory.\n          int deferredLen = buf.remaining();\n          ByteBuffer deferredBuf = ByteBuffer.allocate(deferredLen);\n          deferredBuf.put(buf);\n          deferredBuf.flip();\n          deferredBufs.add(deferredBuf);\n          mergeManager.pushMergeMetrics.deferredBlockBytes.inc(deferredLen);\n          mergeManager.pushMergeMetrics.deferredBlocks.mark();\n        }\n      }\n    }\n\n    @Override\n    public void onComplete(String streamId) throws IOException {\n      synchronized (partitionInfo) {\n        logger.trace(\"{} onComplete invoked\", partitionInfo);\n        // Initially when this request got to the server, the shuffle merge finalize request\n        // was not received yet or this was the latest stage attempt (or latest shuffleMergeId)\n        // generating shuffle output for the shuffle ID. By the time we finish reading this\n        // message, the block request is either stale or too late. We should thus respond\n        // the error code to the client.\n        AppShuffleMergePartitionsInfo info =\n            appShuffleInfo.shuffles.get(partitionInfo.appAttemptShuffleMergeId.shuffleId);\n        if (isTooLate(info, partitionInfo.reduceId)) {\n          freeDeferredBufs();\n          mergeManager.pushMergeMetrics.lateBlockPushes.mark();\n          throw new BlockPushNonFatalFailure(\n            new BlockPushReturnCode(ReturnCode.TOO_LATE_BLOCK_PUSH.id(), streamId).toByteBuffer(),\n            BlockPushNonFatalFailure.getErrorMsg(streamId, ReturnCode.TOO_LATE_BLOCK_PUSH));\n        }\n        if (isStale(info, partitionInfo.appAttemptShuffleMergeId.shuffleMergeId)) {\n          freeDeferredBufs();\n          mergeManager.pushMergeMetrics.staleBlockPushes.mark();\n          throw new BlockPushNonFatalFailure(\n            new BlockPushReturnCode(ReturnCode.STALE_BLOCK_PUSH.id(), streamId).toByteBuffer(),\n            BlockPushNonFatalFailure.getErrorMsg(streamId, ReturnCode.STALE_BLOCK_PUSH));\n        }\n\n        // Check if we can commit this block\n        if (allowedToWrite()) {\n          // Identify duplicate block generated by speculative tasks. We respond success to\n          // the client in cases of duplicate even though no data is written.\n          if (isDuplicateBlock()) {\n            freeDeferredBufs();\n            // Since we just return without throwing exception, and the received bytes are ignored,\n            // thus we need to add them to ignoredBlockBytes in pushMergeMetrics.\n            updateIgnoredBlockBytes();\n            return;\n          }\n          if (partitionInfo.getCurrentMapIndex() < 0) {\n            try {\n              if (deferredBufs != null && !deferredBufs.isEmpty()) {\n                abortIfNecessary();\n                isWriting = true;\n                writeDeferredBufs();\n              }\n            } catch (IOException ioe) {\n              incrementIOExceptionsAndAbortIfNecessary();\n              // If the above doesn't throw a RuntimeException, then we propagate the IOException\n              // back to the client so the block could be retried.\n              throw ioe;\n            }\n          }\n          long updatedPos = partitionInfo.getDataFilePos() + length;\n          boolean indexUpdated = false;\n          if (updatedPos - partitionInfo.getLastChunkOffset() >= mergeManager.minChunkSize) {\n            try {\n              partitionInfo.updateChunkInfo(updatedPos, mapIndex);\n              indexUpdated = true;\n            } catch (IOException ioe) {\n              incrementIOExceptionsAndAbortIfNecessary();\n              // If the above doesn't throw a RuntimeException, then we do not propagate the\n              // IOException to the client. This may increase the chunk size however the increase is\n              // still limited because of the limit on the number of IOExceptions for a\n              // particular shuffle partition.\n            }\n          }\n          partitionInfo.setDataFilePos(updatedPos);\n          partitionInfo.setCurrentMapIndex(-1);\n\n          // update merged results\n          partitionInfo.blockMerged(mapIndex);\n          if (indexUpdated) {\n            partitionInfo.resetChunkTracker();\n          }\n        } else {\n          freeDeferredBufs();\n          mergeManager.pushMergeMetrics.blockAppendCollisions.mark();\n          throw new BlockPushNonFatalFailure(\n            new BlockPushReturnCode(ReturnCode.BLOCK_APPEND_COLLISION_DETECTED.id(), streamId)\n              .toByteBuffer(), BlockPushNonFatalFailure.getErrorMsg(\n                streamId, ReturnCode.BLOCK_APPEND_COLLISION_DETECTED));\n        }\n      }\n      isWriting = false;\n    }\n\n    @Override\n    public void onFailure(String streamId, Throwable throwable) throws IOException {\n      if (ERROR_HANDLER.shouldLogError(throwable)) {\n        logger.error(\"Encountered issue when merging {}\", throwable,\n          MDC.of(LogKeys.STREAM_ID$.MODULE$, streamId));\n      } else {\n        logger.debug(\"Encountered issue when merging {}\", streamId, throwable);\n      }\n      // The block was received by ESS but didn't get merged, so it is considered as \"ignored\".\n      // Capturing them in ignoredBlockBytes would help measure any server side improvement.\n      updateIgnoredBlockBytes();\n      // Only update partitionInfo if the failure corresponds to a valid request. If the\n      // request is too late, i.e. received after shuffle merge finalize or stale block push,\n      // #onFailure will also be triggered, and we can just ignore. Also, if we couldn't find\n      // an opportunity to write the block data to disk, we should also ignore here.\n      if (isWriting) {\n        synchronized (partitionInfo) {\n          AppShuffleMergePartitionsInfo info =\n            appShuffleInfo.shuffles.get(partitionInfo.appAttemptShuffleMergeId.shuffleId);\n          if (!isTooLate(info, partitionInfo.reduceId) &&\n              !isStale(info, partitionInfo.appAttemptShuffleMergeId.shuffleMergeId)) {\n            logger.debug(\"{} encountered failure\", partitionInfo);\n            partitionInfo.setCurrentMapIndex(-1);\n          }\n        }\n      }\n      isWriting = false;\n    }\n\n    @VisibleForTesting\n    AppShufflePartitionInfo getPartitionInfo() {\n      return partitionInfo;\n    }\n  }\n\n  public static class AppAttemptId {\n    public final String appId;\n    public final int attemptId;\n\n    @JsonCreator\n    public AppAttemptId(\n        @JsonProperty(\"appId\") String appId,\n        @JsonProperty(\"attemptId\") int attemptId) {\n      this.appId = appId;\n      this.attemptId = attemptId;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n\n      AppAttemptId appAttemptId = (AppAttemptId) o;\n      return attemptId == appAttemptId.attemptId &&\n          Objects.equals(appId, appAttemptId.appId);\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(appId, attemptId);\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\"Application %s_%s\", appId, attemptId);\n    }\n  }\n\n  public static class AppShuffleMergePartitionsInfo {\n    // ConcurrentHashMap doesn't allow null for keys or values which is why this is required.\n    // Marker to identify finalized shuffle partitions.\n    private static final Map<Integer, AppShufflePartitionInfo> SHUFFLE_FINALIZED_MARKER =\n        Collections.emptyMap();\n    private final int shuffleMergeId;\n    private final Map<Integer, AppShufflePartitionInfo> shuffleMergePartitions;\n\n    private final AtomicReference<int[]> reduceIds = new AtomicReference<>(new int[0]);\n\n    public AppShuffleMergePartitionsInfo(int shuffleMergeId, boolean shuffleFinalized) {\n      this.shuffleMergeId = shuffleMergeId;\n      this.shuffleMergePartitions = shuffleFinalized ? SHUFFLE_FINALIZED_MARKER :\n          new ConcurrentHashMap<>();\n    }\n\n    @VisibleForTesting\n    public Map<Integer, AppShufflePartitionInfo> getShuffleMergePartitions() {\n      return shuffleMergePartitions;\n    }\n\n    public boolean isFinalized() {\n      return shuffleMergePartitions == SHUFFLE_FINALIZED_MARKER;\n    }\n\n    public void setReduceIds(int[] reduceIds) {\n      this.reduceIds.set(reduceIds);\n    }\n\n    public int[] getReduceIds() {\n      return this.reduceIds.get();\n    }\n  }\n\n  public static class AppAttemptShuffleMergeId {\n    public final String appId;\n    public final int attemptId;\n    public final int shuffleId;\n    public final int shuffleMergeId;\n\n    @JsonCreator\n    public AppAttemptShuffleMergeId(\n        @JsonProperty(\"appId\") String appId,\n        @JsonProperty(\"attemptId\") int attemptId,\n        @JsonProperty(\"shuffleId\") int shuffleId,\n        @JsonProperty(\"shuffleMergeId\") int shuffleMergeId) {\n      Preconditions.checkArgument(appId != null, \"app id is null\");\n      this.appId = appId;\n      this.attemptId = attemptId;\n      this.shuffleId = shuffleId;\n      this.shuffleMergeId = shuffleMergeId;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n\n      AppAttemptShuffleMergeId appAttemptShuffleMergeId = (AppAttemptShuffleMergeId) o;\n      return attemptId == appAttemptShuffleMergeId.attemptId &&\n          shuffleId == appAttemptShuffleMergeId.shuffleId &&\n          shuffleMergeId == appAttemptShuffleMergeId.shuffleMergeId &&\n          Objects.equals(appId, appAttemptShuffleMergeId.appId);\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(appId, attemptId, shuffleId, shuffleMergeId);\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\"Application %s_%s shuffleId %s shuffleMergeId %s\",\n        appId, attemptId, shuffleId, shuffleMergeId);\n    }\n  }\n\n    void updateChunkInfo(long chunkOffset, int mapIndex) throws IOException {\n      try {\n        logger.trace(\"{} index current {} updated {}\", this, this.lastChunkOffset,\n          chunkOffset);\n        if (indexMetaUpdateFailed) {\n          indexFile.getChannel().position(indexFile.getPos());\n        }\n        indexFile.getDos().writeLong(chunkOffset);\n        // Chunk bitmap should be written to the meta file after the index file because if there are\n        // any exceptions during writing the offset to the index file, meta file should not be\n        // updated. If the update to the index file is successful but the update to meta file isn't\n        // then the index file position is not updated.\n        writeChunkTracker(mapIndex);\n        indexFile.updatePos(8);\n        this.lastChunkOffset = chunkOffset;\n        indexMetaUpdateFailed = false;\n      } catch (IOException ioe) {\n        logger.warn(\"{} reduceId {} update to index/meta failed\",\n          MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n          MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        indexMetaUpdateFailed = true;\n        // Any exception here is propagated to the caller and the caller can decide whether to\n        // abort or not.\n        throw ioe;\n      }\n    }\n\n    private void writeChunkTracker(int mapIndex) throws IOException {\n      if (mapIndex == -1) {\n        return;\n      }\n      chunkTracker.add(mapIndex);\n      logger.trace(\"{} mapIndex {} write chunk to meta file\", this, mapIndex);\n      if (indexMetaUpdateFailed) {\n        metaFile.getChannel().position(metaFile.getPos());\n      }\n      chunkTracker.serialize(metaFile.getDos());\n      metaFile.updatePos(metaFile.getChannel().position() - metaFile.getPos());\n    }\n\n    private void incrementIOExceptions() {\n      numIOExceptions++;\n    }\n\n    private boolean shouldAbort(int ioExceptionsThresholdDuringMerge) {\n      return numIOExceptions > ioExceptionsThresholdDuringMerge;\n    }\n\n    private void finalizePartition() throws IOException {\n      if (dataFilePos != lastChunkOffset) {\n        try {\n          updateChunkInfo(dataFilePos, lastMergedMapIndex);\n        } catch (IOException ioe) {\n          // Any exceptions here while updating the meta files can be ignored. If the files\n          // aren't successfully updated they will be truncated.\n        }\n      }\n      // Get rid of any partial block data at the end of the file. This could either\n      // be due to failure, or a request still being processed when the shuffle\n      // merge gets finalized, or any exceptions while updating index/meta files.\n      logger.trace(\"{} reduceId {} truncating files data {} index {} meta {}\",\n          appAttemptShuffleMergeId, reduceId, lastChunkOffset,\n          indexFile.getPos(), metaFile.getPos());\n      dataChannel.truncate(lastChunkOffset);\n      indexFile.getChannel().truncate(indexFile.getPos());\n      metaFile.getChannel().truncate(metaFile.getPos());\n    }\n\n    private void deleteAllFiles() {\n      if (!dataFile.delete()) {\n        logger.info(\"Error deleting data file for {} reduceId {}\",\n          MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n          MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n      }\n      metaFile.delete();\n      indexFile.delete();\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\"Application %s_%s shuffleId %s shuffleMergeId %s reduceId %s\",\n          appAttemptShuffleMergeId.appId, appAttemptShuffleMergeId.attemptId,\n          appAttemptShuffleMergeId.shuffleId, appAttemptShuffleMergeId.shuffleMergeId,\n          reduceId);\n    }\n\n    @VisibleForTesting\n    MergeShuffleFile getIndexFile() {\n      return indexFile;\n    }\n\n    @VisibleForTesting\n    MergeShuffleFile getMetaFile() {\n      return metaFile;\n    }\n\n    @VisibleForTesting\n    FileChannel getDataChannel() {\n      return dataChannel;\n    }\n\n    @VisibleForTesting\n    public RoaringBitmap getMapTracker() {\n      return mapTracker;\n    }\n\n    @VisibleForTesting\n    int getNumIOExceptions() {\n      return numIOExceptions;\n    }\n\n    @VisibleForTesting\n    Cleaner.Cleanable getCleanable() {\n      return cleanable;\n    }\n\n    private record ResourceCleaner(\n        FileChannel dataChannel,\n        MergeShuffleFile indexFile,\n        MergeShuffleFile metaFile,\n        AppAttemptShuffleMergeId appAttemptShuffleMergeId,\n        int reduceId) implements Runnable {\n\n      @Override\n      public void run() {\n        closeAllFiles(dataChannel, indexFile, metaFile, appAttemptShuffleMergeId,\n          reduceId);\n      }\n\n      private void closeAllFiles(\n          FileChannel dataChannel,\n          MergeShuffleFile indexFile,\n          MergeShuffleFile metaFile,\n          AppAttemptShuffleMergeId appAttemptShuffleMergeId,\n          int reduceId) {\n        try {\n          if (dataChannel.isOpen()) {\n            dataChannel.close();\n          }\n        } catch (IOException ioe) {\n          logger.warn(\"Error closing data channel for {} reduceId {}\",\n            MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n            MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        }\n        try {\n          metaFile.close();\n        } catch (IOException ioe) {\n          logger.warn(\"Error closing meta file for {} reduceId {}\",\n            MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n            MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        }\n        try {\n          indexFile.close();\n        } catch (IOException ioe) {\n          logger.warn(\"Error closing index file for {} reduceId {}\",\n            MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n            MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        }\n      }\n    }\n  }",
    "comment": "Appends the chunk offset to the index file and adds the map index to the chunk tracker.\n\n@param chunkOffset the offset of the chunk in the data file.\n@param mapIndex the map index to be added to chunk tracker."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dynamic-proxy/src/main/java/com/iluwatar/dynamicproxy/AlbumInvocationHandler.java",
    "type": "method",
    "name": "AlbumInvocationHandler",
    "code": "public AlbumInvocationHandler(String baseUrl, HttpClient httpClient) {\n    this.restClient = new TinyRestClient(baseUrl, httpClient);\n  }",
    "comment": "Class constructor. It instantiates a TinyRestClient object.\n\n@param baseUrl Root url for endpoints.\n@param httpClient Handle the http communication."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/logging/Slf4jConfigurationFactory.java",
    "type": "method",
    "name": "getConfiguration",
    "code": "public static Slf4jConfiguration getConfiguration(ILoggerFactory loggerFactory) {\n        String slf4jBinding = loggerFactory.getClass().getCanonicalName();\n\n        try {\n            Enumeration<URL> resources =\n                    Slf4jConfigurationFactory.class.getClassLoader().getResources(RESOURCE);\n\n            while (resources.hasMoreElements()) {\n                URL resource = resources.nextElement();\n                try {\n                    InputStream is = resource.openStream();\n                    final Properties properties = new Properties();\n                    if (is != null) {\n                        try (InputStream in = is) {\n                            properties.load(in);\n                        }\n                    }\n                    String impl = properties.getProperty(slf4jBinding);\n                    if (impl != null) {\n                        return (Slf4jConfiguration)\n                                Class.forName(impl).getDeclaredConstructor().newInstance();\n                    }\n                } catch (IOException\n                        | ClassNotFoundException\n                        | NoSuchMethodException\n                        | InvocationTargetException\n                        | IllegalAccessException\n                        | InstantiationException ex) {\n                    // ignore and move on to the next\n                }\n            }\n        } catch (IOException ex) {\n            // ignore\n        }\n\n        return new UnsupportedSlf4jBindingConfiguration();\n    }",
    "comment": "Slf4jConfiguration factory, loading implementations from <code>META-INF/maven/slf4j-configuration.properties</code>\nconfiguration files in class loader: key is the class name of the ILoggerFactory, value is the class name of\nthe corresponding Slf4jConfiguration.\n\n@since 3.1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ModuleUtils.java",
    "type": "method",
    "name": "getModuleVersion",
    "code": "public static Optional<String> getModuleVersion(Class<?> type) {\n\t\treturn Optional.empty();\n\t}",
    "comment": "Return the raw version of the module that the class or interface is a member of.\n\n@param type class or interface to analyze\n@return the raw module version; never {@code null} but potentially empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java",
    "type": "method",
    "name": "initParent",
    "code": "private void initParent(MavenProject project, ModelBuilderResult result) {\n            Model parentModel = result.getParentModel();\n\n            if (parentModel != null) {\n                final String parentGroupId = getGroupId(parentModel);\n                final String parentVersion = getVersion(parentModel);\n\n                project.setParentArtifact(repositorySystem.createProjectArtifact(\n                        parentGroupId, parentModel.getArtifactId(), parentVersion));\n\n                MavenProject parent = projectIndex.get(parentModel.getId());\n                if (parent == null) {\n                    request.getRemoteRepositories().addAll(project.getRemoteArtifactRepositories());\n                    Path parentPomFile = parentModel.getPomFile();\n                    if (parentPomFile != null) {\n                        project.setParentFile(parentPomFile.toFile());\n                        try {\n                            parent = build(true, parentPomFile, Sources.buildSource(parentPomFile))\n                                    .getProject();\n                        } catch (ProjectBuildingException e) {\n                            if (logger.isDebugEnabled()) {\n                                logger.warn(\"Failed to build parent project for \" + project.getId(), e);\n                            } else {\n                                logger.warn(\"Failed to build parent project for \" + project.getId());\n                            }\n                        }\n                    } else {\n                        Artifact parentArtifact = project.getParentArtifact();\n                        try {\n                            parent = build(true, parentArtifact, false).getProject();\n                        } catch (ProjectBuildingException e) {\n                            if (logger.isDebugEnabled()) {\n                                logger.warn(\"Failed to build parent project for \" + project.getId(), e);\n                            } else {\n                                logger.warn(\"Failed to build parent project for \" + project.getId());\n                            }\n                        }\n                    }\n                }\n                project.setParent(parent);\n                if (project.getParentFile() == null && parent != null) {\n                    project.setParentFile(parent.getFile());\n                }\n            }\n        }",
    "comment": "At this point the DefaultModelBuildingListener has fired, and it populates the\nremote repositories with those found in the pom.xml, along with the existing externally\ndefined repositories.\n\nMNG-4488 where let invalid parents slide on by\nMessage below is checked for in the MNG-2199 core IT.\nMessage below is checked for in the MNG-2199 core IT.\nMNG-4488 where let invalid parents slide on by\nMessage below is checked for in the MNG-2199 core IT.\nMessage below is checked for in the MNG-2199 core IT."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedRleValuesReader.java",
    "type": "method",
    "name": "if",
    "code": "ParquetVectorUpdater updater) {\n\n    int leftInBatch = state.rowsToReadInBatch;\n    int leftInPage = state.valuesToReadInPage;\n    long rowId = state.rowId;\n\n    DefLevelProcessor defLevelProcessor = new DefLevelProcessor(defLevelsReader, state, defLevels,\n      values, nulls, valuesReused, valueReader, updater);\n\n    while ((leftInBatch > 0 || !state.lastListCompleted) && leftInPage > 0) {\n      if (currentCount == 0 && !readNextGroup()) break;\n\n      // Values to read in the current RLE/PACKED block, must be <= what's left in the page\n      int valuesLeftInBlock = Math.min(leftInPage, currentCount);\n\n      // The current row range start and end\n      long rangeStart = state.currentRangeStart();\n      long rangeEnd = state.currentRangeEnd();\n\n      switch (mode) {\n        case RLE -> {\n          // This RLE block is consist of top-level rows, so we'll need to check\n          // if the rows should be skipped according to row indexes.\n          if (currentValue == 0) {\n            if (leftInBatch == 0) {\n              state.lastListCompleted = true;\n            } else {\n              // # of rows to read in the block, must be <= what's left in the current batch\n              int n = Math.min(leftInBatch, valuesLeftInBlock);\n\n              if (rowId + n < rangeStart) {\n                // Need to skip all rows in [rowId, rowId + n)\n                defLevelProcessor.skipValues(n);\n                rowId += n;\n                currentCount -= n;\n                leftInPage -= n;\n              } else if (rowId > rangeEnd) {\n                // The current row index already beyond the current range: move to the next range\n                // and repeat\n                state.nextRange();\n              } else {\n                // The range [rowId, rowId + n) overlaps with the current row range\n                long start = Math.max(rangeStart, rowId);\n                long end = Math.min(rangeEnd, rowId + n - 1);\n\n                // Skip the rows in [rowId, start)\n                int toSkip = (int) (start - rowId);\n                if (toSkip > 0) {\n                  defLevelProcessor.skipValues(toSkip);\n                  rowId += toSkip;\n                  currentCount -= toSkip;\n                  leftInPage -= toSkip;\n                }\n\n                // Read the rows in [start, end]\n                n = (int) (end - start + 1);\n\n                if (n > 0) {\n                  repLevels.appendInts(n, 0);\n                  defLevelProcessor.readValues(n);\n                }\n\n                rowId += n;\n                currentCount -= n;\n                leftInBatch -= n;\n                leftInPage -= n;\n              }\n            }\n          } else {\n            // Not a top-level row: just read all the repetition levels in the block if the row\n            // should be included according to row indexes, else skip the rows.\n            if (!state.shouldSkip) {\n              repLevels.appendInts(valuesLeftInBlock, currentValue);\n            }\n            state.numBatchedDefLevels += valuesLeftInBlock;\n            leftInPage -= valuesLeftInBlock;\n            currentCount -= valuesLeftInBlock;\n          }\n        }\n        case PACKED -> {\n          int i = 0;\n\n          for (; i < valuesLeftInBlock; i++) {\n            int currentValue = currentBuffer[currentBufferIdx + i];\n            if (currentValue == 0) {\n              if (leftInBatch == 0) {\n                state.lastListCompleted = true;\n                break;\n              } else if (rowId < rangeStart) {\n                // This is a top-level row, therefore check if we should skip it with row indexes\n                // the row is before the current range, skip it\n                defLevelProcessor.skipValues(1);\n              } else if (rowId > rangeEnd) {\n                // The row is after the current range, move to the next range and compare again\n                state.nextRange();\n                break;\n              } else {\n                // The row is in the current range, decrement the row counter and read it\n                leftInBatch--;\n                repLevels.appendInt(0);\n                defLevelProcessor.readValues(1);\n              }\n              rowId++;\n            } else {\n              if (!state.shouldSkip) {\n                repLevels.appendInt(currentValue);\n              }\n              state.numBatchedDefLevels += 1;\n            }\n          }\n\n          leftInPage -= i;\n          currentCount -= i;\n          currentBufferIdx += i;\n        }\n      }\n    }\n\n    // Process all the batched def levels\n    defLevelProcessor.finish();\n\n    state.rowsToReadInBatch = leftInBatch;\n    state.valuesToReadInPage = leftInPage;\n    state.rowId = rowId;\n  }",
    "comment": "Keep reading repetition level values from the page until either: 1) we've read enough\ntop-level rows to fill the current batch, or 2) we've drained the data page completely.\n\n@param valuesReused whether 'values' vector is reused for 'nulls'"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "enabledCipherSuites",
    "code": "String[] supportedCiphers, String[] defaultCiphers, String[] requestedCiphers) {\n    String[] baseCiphers = new String[]{\n    String[] enabledCiphers =\n      ((requestedCiphers == null || requestedCiphers.length == 0) ? baseCiphers : requestedCiphers);\n\n    List<String> ciphers = addIfSupported(supportedCiphers, enabledCiphers);\n    if (!ciphers.isEmpty()) {\n      return ciphers.toArray(new String[ciphers.size()]);\n    } else {\n      return defaultCiphers;\n    }\n  }\n\n  private static String[] enabledCipherSuites(SSLEngine engine, String[] requestedCiphers) {\n    return enabledCipherSuites(\n      engine.getSupportedCipherSuites(), engine.getEnabledCipherSuites(), requestedCiphers);\n  }\n\n  private static List<String> addIfSupported(String[] supported, String... names) {\n    List<String> enabled = new ArrayList<>();\n    Set<String> supportedSet = new HashSet<>(Arrays.asList(supported));\n    for (String n : names) {\n      if (supportedSet.contains(n)) {\n        enabled.add(n);\n      }\n    }\n    return enabled;\n  }\n}",
    "comment": "Use the default from JDK as fallback."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/Statistics.java",
    "type": "method",
    "name": "columnStats",
    "code": "default Map<NamedReference, ColumnStatistics> columnStats() {\n    return new HashMap<>();\n  }",
    "comment": "An interface to represent statistics for a data source, which is returned by\n{@link SupportsReportStatistics#estimateStatistics()}.\n\n@since 3.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/SerializableValueDescription.java",
    "type": "method",
    "name": "SerializableValueDescription",
    "code": "private SerializableValueDescription(Object value) {\n        this.value = String.valueOf(value);\n    }",
    "comment": "This class exists solely to provide a serializable description of a value to be serialized as a field in\n{@link AssumptionViolatedException}. Being a {@link Throwable}, it is required to be {@link Serializable}, but a\nvalue of type Object provides no guarantee to be serializable. This class works around that limitation as\n{@link AssumptionViolatedException} only every uses the string representation of the value, while still retaining\nbackwards compatibility with classes compiled against its class signature before 4.14 and/or deserialization of\npreviously serialized instances."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/ovic/src/main/java/org/tensorflow/ovic/OvicDetectorBenchmarker.java",
    "type": "method",
    "name": "getReadyToTest",
    "code": "public void getReadyToTest(InputStream labelInputStream, MappedByteBuffer model) {\n    try {\n      Log.i(TAG, \"Creating detector.\");\n      detector = new OvicDetector(labelInputStream, model);\n      int[] inputDims = detector.getInputDims();\n      imgHeight = inputDims[1];\n      imgWidth = inputDims[2];\n      imgData = ByteBuffer.allocateDirect(DIM_BATCH_SIZE * imgHeight * imgWidth * DIM_PIXEL_SIZE);\n      imgData.order(ByteOrder.nativeOrder());\n      intValues = new int[imgHeight * imgWidth];\n      benchmarkStarted = false;\n    } catch (Exception e) {\n      Log.e(TAG, e.getMessage());\n      Log.e(TAG, \"Failed to initialize COCO detector for the benchmarker.\", e);\n    }\n  }",
    "comment": "Getting the benchmarker ready for detecting images.\n\n@param labelInputStream: an {@link InputStream} specifying where the list of labels should be\nread from.\n@param model: a {@link MappedByteBuffer} model to benchmark."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/app/AppClient.java",
    "type": "method",
    "name": "run",
    "code": "public void run() {\n      try (var socket = new DatagramSocket()) {\n            LOGGER.info(new String(reply.getData(), 0, reply.getLength()));\n          }\n\n          artificialDelayOf(100);\n        }",
    "comment": "Creates a new UDP logging client.\n\n@param clientName the name of the client to be sent in logging requests.\n@param port the port on which client will send logging requests.\n@throws UnknownHostException if localhost is unknown"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/DynamicTestIntegrationTests.java",
    "type": "method",
    "name": "generateDynamicTestsThatReferenceLargeAmountsOfMemory",
    "code": "Stream<DynamicTest> generateDynamicTestsThatReferenceLargeAmountsOfMemory() {\n\t\treturn Stream.generate(() -> new byte[TEN_MB])//\n\t\t\t\t// The lambda Executable in the following line *must* reference\n\t\t\t\t// the `bytes` array in order to hold onto the allocated memory.\n\t\t\t\t.map(bytes -> dynamicTest(\"test\", () -> assertNotNull(bytes)))//\n\t\t\t\t.limit(200);\n\t}",
    "comment": "Without the fix in {@code DynamicTestTestDescriptor}, setting the\n{@code -mx200m} VM argument will cause an {@link OutOfMemoryError} before\nthe 200 limit is reached.\n\n@see <a href=\"https://github.com/junit-team/junit5/issues/1865\">Issue 1865</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "runCount",
    "code": "public synchronized int runCount() {\n        return fRunTests;\n    }",
    "comment": "Gets the number of run tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/impl/Graph.java",
    "type": "method",
    "name": "if",
    "code": "Collection<Vertex> children, Map<Vertex, DfsState> stateMap, LinkedList<String> cycle) {\n        for (Vertex v : children) {\n            DfsState state = stateMap.putIfAbsent(v, DfsState.VISITING);\n            if (state == null) {\n                cycle.addLast(v.label);\n                List<String> ret = visitCycle(v.children, stateMap, cycle);\n                if (ret != null) {\n                    return ret;\n                }\n                cycle.removeLast();\n                stateMap.put(v, DfsState.VISITED);\n            } else if (state == DfsState.VISITING) {\n                int pos = cycle.lastIndexOf(v.label);\n                List<String> ret = cycle.subList(pos, cycle.size());\n                ret.add(v.label);\n                return ret;\n            }\n        }\n        return null;\n    }",
    "comment": "we are already visiting this vertex, this mean we have a cycle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(short expected, short actual) {\n        assertEquals(null, expected, actual);\n    }",
    "comment": "Asserts that two shorts are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaStandardScalerExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaStandardScalerExample\")\n      .getOrCreate();\n\n    Dataset<Row> dataFrame =\n      spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    StandardScaler scaler = new StandardScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\")\n      .setWithStd(true)\n      .setWithMean(false);\n\n    StandardScalerModel scalerModel = scaler.fit(dataFrame);\n\n    Dataset<Row> scaledData = scalerModel.transform(dataFrame);\n    scaledData.show();\n    spark.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nCompute summary statistics by fitting the StandardScaler\nNormalize each feature to have unit standard deviation.\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "TimSort",
    "code": "public TimSort(SortDataFormat<K, Buffer> sortDataFormat) {\n    this.s = sortDataFormat;\n  }",
    "comment": "This is the minimum sized sequence that will be merged.  Shorter\nsequences will be lengthened by calling binarySort.  If the entire\narray is less than this length, no merges will be performed.\n\nThis constant should be a power of two.  It was 64 in Tim Peter's C\nimplementation, but 32 was empirically determined to work better in\nthis implementation.  In the unlikely event that you set this constant\nto be a number that's not a power of two, you'll need to change the\nminRunLength computation.\n\nIf you decrease this constant, you must change the stackLen\ncomputation in the TimSort constructor, or you risk an\nArrayOutOfBounds exception.  See listsort.txt for a discussion\nof the minimum stack length required as a function of the length\nof the array being sorted and the minimum merge sequence length."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/ResourceUtils.java",
    "type": "method",
    "name": "packageName",
    "code": "static Predicate<Resource> packageName(Predicate<String> packageFilter) {\n\t\treturn resource -> packageFilter.test(packageName(resource.getName()));\n\t}",
    "comment": "Match resources against a package filter.\n\n<p>The {@code /} separated path of a resource is rewritten to a\n{@code .} separated package names. The package filter is applied to that\npackage name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExecutorDiskUtils.java",
    "type": "method",
    "name": "getFilePath",
    "code": "public static String getFilePath(String[] localDirs, int subDirsPerLocalDir, String filename) {\n    int hash = JavaUtils.nonNegativeHash(filename);\n    String localDir = localDirs[hash % localDirs.length];\n    int subDirId = (hash / localDirs.length) % subDirsPerLocalDir;\n    final String notNormalizedPath =\n      localDir + File.separator + String.format(\"%02x\", subDirId) + File.separator + filename;\n    // Interning the normalized path as according to measurements, in some scenarios such\n    // duplicate strings may waste a lot of memory (~ 10% of the heap).\n    // Unfortunately, we cannot just call the normalization code that java.io.File\n    // uses, since it is in the package-private class java.io.FileSystem.\n    // So we are creating a File just to get the normalized path back to intern it.\n    // We return this interned normalized path.\n    return new File(notNormalizedPath).getPath().intern();\n  }",
    "comment": "Hashes a filename into the corresponding local directory, in a manner consistent with\nSpark's DiskBlockManager.getFile()."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeArrayWriter.java",
    "type": "method",
    "name": "setNull4Bytes",
    "code": "public void setNull4Bytes(int ordinal) {\n    setNullBit(ordinal);\n    writeInt(getElementOffset(ordinal), 0);\n  }",
    "comment": "put zero into the corresponding field when set null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/test/java/com/example/android/persistence/migrations/UserRepositoryTest.java",
    "type": "method",
    "name": "getUserWithUserInDataSource",
    "code": "public void getUserWithUserInDataSource() {\n        LoadUserCallback callback = mock(LoadUserCallback.class);\n        when(mUserDataSource.getUser()).thenReturn(USER);\n\n        mUserRepository.getUser(callback);\n\n        verify(mUserDataSource).getUser();\n        verify(callback).onUserLoaded(USER);\n    }",
    "comment": "Given a callback for loading the user\nAnd user in the data source\nWhen requesting a user from the repository\nThe user is requested from the user data source\nand the callback triggers correct method"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/ExceptionHandlingTests.java",
    "type": "method",
    "name": "failureInTestMethodIsRegistered",
    "code": "void failureInTestMethodIsRegistered() {\n\t\tEngineExecutionResults executionResults = executeTests(selectMethod(FailureTestCase.class, \"failingTest\"));\n\t\tEvents tests = executionResults.testEvents();\n\n\t\ttests.assertStatistics(stats -> stats.started(1).failed(1));\n\n\t\ttests.failed().assertEventsMatchExactly( //\n\t\t\tevent(test(\"failingTest\"),\n\t\t\t\tfinishedWithFailure(instanceOf(AssertionFailedError.class), message(\"always fails\"))));\n\t}",
    "comment": "Integration tests that verify correct exception handling in the {@link JupiterTestEngine}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Double> create(Scope scope, double[][][][] data) {\n    return create(scope, data, Double.class);\n  }",
    "comment": "Creates a rank-4 constant of {@code double} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, Double actual) {\n\t\tAssertEquals.assertEquals((Double) expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/double-checked-locking/src/test/java/com/iluwatar/doublechecked/locking/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/WorkManagerMultiprocessSample/app/src/main/java/com/example/background/multiprocess/ExampleRemoteListenableWorker.java",
    "type": "method",
    "name": "ExampleRemoteListenableWorker",
    "code": "public ExampleRemoteListenableWorker(Context appContext, WorkerParameters workerParams) {\n        super(appContext, workerParams);\n    }",
    "comment": "Example of implementing a RemoteListenableWorker. This worker simply returns Success.\n<p>\nUse RemoteListenableWorker if your worker is implemented in Java, otherwise use\nRemoteCoroutineWorker if your worker is implemented in Kotlin."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/builder/multithreaded/ConcurrencyDependencyGraph.java",
    "type": "method",
    "name": "markAsFinished",
    "code": "public List<MavenProject> markAsFinished(MavenProject mavenProject) {\n        finishedProjects.add(mavenProject);\n        return getSchedulableNewProcesses(mavenProject);\n    }",
    "comment": "Marks the provided project as finished. Returns a list of\n\n@param mavenProject The project\n@return The list of builds that are eligible for starting now that the provided project is done"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-plugin/src/test/java/org/apache/maven/api/plugin/descriptor/another/ExtendedPluginDescriptorTest.java",
    "type": "method",
    "name": "testExtendedPluginDescriptor",
    "code": "void testExtendedPluginDescriptor() {\n        ExtendedPluginDescriptor.Builder builder = new ExtendedPluginDescriptor.Builder();\n        builder.additionalField(\"additional\")\n                .groupId(\"org.apache.maven\")\n                .artifactId(\"maven-plugin-api\")\n                .version(\"1.0.0\");\n        ExtendedPluginDescriptor descriptor = builder.build();\n        assertEquals(\"additional\", descriptor.getAdditionalField());\n        assertEquals(\"org.apache.maven\", descriptor.getGroupId());\n    }",
    "comment": "make sure to call the subclasses' builder methods first, otherwise fluent API would not work"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MavenBuilderException.java",
    "type": "method",
    "name": "buildMessage",
    "code": "protected static String buildMessage(String message, ProblemCollector<BuilderProblem> problems) {\n        StringBuilder msg = new StringBuilder(message);\n        problems.problems().forEach(problem -> msg.append(\"\\n * \")\n                .append(problem.getSeverity().name())\n                .append(\": \")\n                .append(problem.getMessage()));\n        return msg.toString();\n    }",
    "comment": "Formats message out of problems: problems are sorted (in natural order of {@link BuilderProblem.Severity})\nand then a list is built. These exceptions are usually thrown in \"fatal\" cases (and usually prevent Maven\nfrom starting), and these exceptions may end up very early on output.\n\n@param message the base message to enhance\n@param problems the collection of problems to include in the message\n@return a formatted message including details of all problems"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/DisabledTests.java",
    "type": "method",
    "name": "executeTestsWithDisabledTestClass",
    "code": "void executeTestsWithDisabledTestClass() {\n\t\tEngineExecutionResults results = executeTestsForClass(DisabledTestClassTestCase.class);\n\n\t\tresults.containerEvents().assertStatistics(stats -> stats.skipped(1));\n\t\tresults.testEvents().assertStatistics(stats -> stats.started(0));\n\t}",
    "comment": "Integration tests that verify support for {@link Disabled @Disabled} in the\n{@link JupiterTestEngine}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/EnabledIfEnvironmentVariableConditionTests.java",
    "type": "method",
    "name": "EnabledIfEnvironmentVariableCondition",
    "code": "private ExecutionCondition condition = new EnabledIfEnvironmentVariableCondition() {\n\t};",
    "comment": "Stubbed subclass of {@link EnabledIfEnvironmentVariableCondition}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/ArtifactDescriptorReaderDelegate.java",
    "type": "method",
    "name": "populateResult",
    "code": "public void populateResult(RepositorySystemSession session, ArtifactDescriptorResult result, Model model) {\n        ArtifactTypeRegistry stereotypes = session.getArtifactTypeRegistry();\n\n        for (Repository r : model.getRepositories()) {\n            result.addRepository(ArtifactDescriptorUtils.toRemoteRepository(r));\n        }\n\n        for (org.apache.maven.model.Dependency dependency : model.getDependencies()) {\n            result.addDependency(convert(dependency, stereotypes));\n        }\n\n        DependencyManagement mgmt = model.getDependencyManagement();\n        if (mgmt != null) {\n            for (org.apache.maven.model.Dependency dependency : mgmt.getDependencies()) {\n                result.addManagedDependency(convert(dependency, stereotypes));\n            }\n        }\n\n        Map<String, Object> properties = new LinkedHashMap<>();\n\n        Prerequisites prerequisites = model.getPrerequisites();\n        if (prerequisites != null) {\n            properties.put(\"prerequisites.maven\", prerequisites.getMaven());\n        }\n\n        List<License> licenses = model.getLicenses();\n        properties.put(\"license.count\", licenses.size());\n        for (int i = 0; i < licenses.size(); i++) {\n            License license = licenses.get(i);\n            properties.put(\"license.\" + i + \".name\", license.getName());\n            properties.put(\"license.\" + i + \".url\", license.getUrl());\n            properties.put(\"license.\" + i + \".comments\", license.getComments());\n            properties.put(\"license.\" + i + \".distribution\", license.getDistribution());\n        }\n\n        result.setProperties(properties);\n\n        setArtifactProperties(result, model);\n    }",
    "comment": "Populates Aether {@link ArtifactDescriptorResult} from Maven project {@link Model}.\n<p>\n<strong>Note:</strong> This class is part of work in progress and can be changed or removed without notice.\n@since 3.2.4\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "makeAccessible",
    "code": "public static Field makeAccessible(Field field) {\n\t\treturn ReflectionUtils.makeAccessible(Preconditions.notNull(field, \"field must not be null\"));\n\t}",
    "comment": "Make the supplied field accessible via reflection.\n\n<p>If you're looking for similar functionality for constructors or\nmethods, consider using {@link #newInstance(Class, Object...)} or\n{@link #invokeMethod(Method, Object, Object...)}.\n\n@param field the field to make accessible; never {@code null}\n@return the supplied field\n@since 1.12\n@see Field#setAccessible(boolean)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "if",
    "code": "if (mergePartitionsInfo == null) {\n          logger.info(\"{} attempt {} shuffle {} shuffleMerge {}: creating a new shuffle \" +\n          int latestShuffleMergeId = mergePartitionsInfo.shuffleMergeId;\n          if (latestShuffleMergeId > shuffleMergeId) {\n            // Reject the request as we have already seen a higher shuffleMergeId than the one\n            // in the current request.\n            throw new BlockPushNonFatalFailure(\n              new BlockPushReturnCode(ReturnCode.STALE_BLOCK_PUSH.id(), blockId).toByteBuffer(),\n              BlockPushNonFatalFailure.getErrorMsg(blockId, ReturnCode.STALE_BLOCK_PUSH));\n          } else if (latestShuffleMergeId < shuffleMergeId){\n            // Higher shuffleMergeId seen for the shuffle ID meaning new stage attempt is being\n            // run for the shuffle ID. Close and clean up old shuffleMergeId files,\n            // happens in the indeterminate stage retries\n            AppAttemptShuffleMergeId currentAppAttemptShuffleMergeId =\n                new AppAttemptShuffleMergeId(appShuffleInfo.appId, appShuffleInfo.attemptId,\n                    shuffleId, latestShuffleMergeId);\n            logger.info(\"{}: creating a new shuffle merge metadata since received \" +\n              MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$,\n                currentAppAttemptShuffleMergeId),\n              MDC.of(LogKeys.SHUFFLE_MERGE_ID$.MODULE$, shuffleMergeId),\n              MDC.of(LogKeys.LATEST_SHUFFLE_MERGE_ID$.MODULE$, latestShuffleMergeId));\n            submitCleanupTask(() ->\n                closeAndDeleteOutdatedPartitions(currentAppAttemptShuffleMergeId,\n                    mergePartitionsInfo.shuffleMergePartitions));\n            return new AppShuffleMergePartitionsInfo(shuffleMergeId, false);\n          } else {\n            // The request is for block with same shuffleMergeId as the latest shuffleMergeId\n            if (mergePartitionsInfo.isFinalized()) {\n              throw new BlockPushNonFatalFailure(\n                  new BlockPushReturnCode(\n                      ReturnCode.TOO_LATE_BLOCK_PUSH.id(), blockId).toByteBuffer(),\n                  BlockPushNonFatalFailure.getErrorMsg(blockId, ReturnCode.TOO_LATE_BLOCK_PUSH));\n            }\n            return mergePartitionsInfo;\n          }\n        }",
    "comment": "Given the appShuffleInfo, shuffleId, shuffleMergeId and reduceId that uniquely identifies\na given shuffle partition of an application, retrieves the associated metadata. If not\npresent and the corresponding merged shuffle does not exist, initializes the metadata."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/metadata/AbstractArtifactMetadata.java",
    "type": "method",
    "name": "AbstractArtifactMetadata",
    "code": "protected AbstractArtifactMetadata(Artifact artifact) {\n        this.artifact = artifact;\n    }",
    "comment": "Common elements of artifact metadata."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/BenchmarkAccuracyActivity.java",
    "type": "method",
    "name": "onCreate",
    "code": "public void onCreate(Bundle savedInstanceState) {\n    Log.i(TAG, \"Create benchmark accuracy activity.\");\n    super.onCreate(savedInstanceState);\n\n    Intent intent = getIntent();\n    Bundle bundle = intent.getExtras();\n    String[] tfliteSettingsJsonFiles = bundle.getStringArray(TFLITE_SETTINGS_FILES_INTENT_KEY_0);\n    new BenchmarkAccuracyImpl().benchmark(this, tfliteSettingsJsonFiles);\n  }",
    "comment": "{@link Activity} class for Delegate Performance Accuracy Benchmark.\n\n<p>This Activity receives test arguments via a command line specified in an intent extra. It\nperforms accuracy benchmark tests via TFLite MiniBenchmark based on the input arguments. Please\ncheck the test example in\ntensorflow/lite/tools/benchmark/experimental/delegate_performance/android/README.md."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/NewestConflictResolverTest.java",
    "type": "method",
    "name": "testDepthReversed",
    "code": "void testDepthReversed() {\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a2n, a2n, a1n);\n    }",
    "comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\nb:1.0 -&gt; a:2.0\na:1.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(long expected, Long actual, String message) {\n\t\tAssertEquals.assertEquals((Long) expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Graph.java",
    "type": "method",
    "name": "operations",
    "code": "public Iterator<Operation> operations() {\n    return new OperationIterator(this);\n  }",
    "comment": "Iterator over all the {@link Operation}s in the graph.\n\n<p>The order of iteration is unspecified. Consumers of the iterator will receive no\nnotification should the underlying graph change during iteration."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/Sources.java",
    "type": "method",
    "name": "PathSource",
    "code": "protected PathSource(Path path, String location) {\n            this.path = requireNonNull(path, \"path\").normalize();\n            this.location = location != null ? location : this.path.toString();\n        }",
    "comment": "Constructs a new PathSource with the specified path and location.\n\n@param path the filesystem path to the source content\n@param location the logical location of the source, used for reporting purposes.\nIf null, the path string representation is used"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/testFixtures/java/org/junit/platform/commons/test/TestClassLoader.java",
    "type": "method",
    "name": "forClasses",
    "code": "public static TestClassLoader forClasses(Class<?>... classes) {\n\t\tPredicate<String> classNameFilter = name -> Arrays.stream(classes).map(Class::getName).anyMatch(name::equals);\n\t\treturn new TestClassLoader(getCodeSourceUrl(stackWalker.getCallerClass()), classNameFilter);\n\t}",
    "comment": "Create a {@link TestClassLoader} that filters the provided classes.\n\n@see #forClasses(List)\n@see #forClassNamePrefix(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toIntExact",
    "code": "public int toIntExact() {\n    IntWrapper result = new IntWrapper();\n    if (toInt(result, false)) {\n      return result.value;\n    }\n    throw new NumberFormatException(\"invalid input syntax for type numeric: '\" + this + \"'\");\n  }",
    "comment": "Parses UTF8String(trimmed if needed) to int. This method is used when ANSI is enabled.\n\n@return If string contains valid numeric value then it returns the int value otherwise a\nNumberFormatException  is thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolver.java",
    "type": "method",
    "name": "addClassContainerSelectorResolver",
    "code": "public Builder<T> addClassContainerSelectorResolver(Predicate<Class<?>> classFilter) {\n\t\t\tPreconditions.notNull(classFilter, \"classFilter must not be null\");\n\t\t\treturn addClassContainerSelectorResolverWithContext(__ -> classFilter);\n\t\t}",
    "comment": "Add a predefined resolver that resolves {@link ClasspathRootSelector\nClasspathRootSelectors}, {@link ModuleSelector ModuleSelectors}, and\n{@link PackageSelector PackageSelectors} into {@link ClassSelector\nClassSelectors} by scanning for classes that satisfy the supplied\npredicate in the respective class containers to this builder.\n\n@param classFilter predicate the resolved classes must satisfy; never\n{@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java",
    "type": "method",
    "name": "create",
    "code": "public static Namespace create(Object... parts) {\n\t\t\tPreconditions.notEmpty(parts, \"parts array must not be null or empty\");\n\t\t\tPreconditions.containsNoNullElements(parts, \"individual parts must not be null\");\n\t\t\treturn new Namespace(new ArrayList<>(Arrays.asList(parts)));\n\t\t}",
    "comment": "Create a namespace which restricts access to data to all extensions\nwhich use the same sequence of {@code parts} for creating a namespace.\n\n<p>The order of the {@code parts} is significant.\n\n<p>Internally the {@code parts} are compared using {@link Object#equals(Object)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Float> create(Scope scope, float[][][][][] data) {\n    return create(scope, data, Float.class);\n  }",
    "comment": "Creates a rank-5 constant of {@code float} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/CWD.java",
    "type": "method",
    "name": "change",
    "code": "public void change(String seg) {\n        Path newCwd = resolve(seg);\n        if (Files.isDirectory(newCwd)) {\n            this.directory = newCwd;\n        } else {\n            throw new IllegalArgumentException(\"Directory '\" + directory + \"' does not exist\");\n        }\n    }",
    "comment": "Changes current cwd, if the new path is existing directory.\n\n@throws NullPointerException if {@code seg} is {@code null}.\n@throws IllegalArgumentException if {@code seg} leads to non-existent directory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/builder/multithreaded/ConcurrencyDependencyGraph.java",
    "type": "method",
    "name": "getActiveDependencies",
    "code": "public List<MavenProject> getActiveDependencies(MavenProject p) {\n        List<MavenProject> activeDependencies = projectDependencyGraph.getUpstreamProjects(p, false);\n        activeDependencies.removeAll(finishedProjects);\n        return activeDependencies;\n    }",
    "comment": "For the given {@link MavenProject} {@code p} return {@code p}'s uncompleted dependencies.\n\n@param p\n@return List of uncompleted prerequisite projects"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng6391PrintVersionTest.java",
    "type": "method",
    "name": "extractReactorBuildOrder",
    "code": "private List<String> extractReactorBuildOrder(List<String> loadedLines) {\n        List<String> resultingLines = new LinkedList<>();\n        boolean start = false;\n        for (String line : loadedLines) {\n            if (start) {\n                if (line.startsWith(\"[INFO] -------------\")) {\n                    start = false;\n                } else if (!line.endsWith(\"[INFO] \")) {\n                    resultingLines.add(line);\n                }\n            } else {\n                if (line.startsWith(\"[INFO] Reactor Summary\")) {\n                    start = true;\n                    resultingLines.add(line);\n                }\n            }\n        }\n        return resultingLines;\n    }",
    "comment": "Extract the lines at the end of the Maven output:\n\n<pre>\n[INFO] Reactor Summary..: XXX\n[INFO]\n[INFO] ...SUCCESS [  0.035 s]\n[INFO] ...SUCCESS [  0.035 s]\n[INFO] ...SUCCESS [  0.035 s]\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Long expected, long actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Long) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/ServiceLoaderRegistry.java",
    "type": "method",
    "name": "getLogger",
    "code": "private static Logger getLogger() {\n\t\treturn LoggerFactory.getLogger(ServiceLoaderRegistry.class);\n\t}",
    "comment": "Not a constant to avoid problems with building GraalVM native images"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/object-mother/src/main/java/com/iluwatar/objectmother/King.java",
    "type": "method",
    "name": "flirt",
    "code": "public void flirt(Queen queen) {\n    var flirtStatus = queen.getFlirted(this);\n    if (!flirtStatus) {\n      this.makeUnhappy();\n    } else {\n      this.makeHappy();\n    }\n  }",
    "comment": "Method to flirt to a queen.\n\n@param queen Queen which should be flirted."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "feed",
    "code": "public Runner feed(String operation, Tensor<?> t) {\n      return feed(parseOutput(operation), t);\n    }",
    "comment": "Avoid evaluating {@code operation} and substitute {@code t} for the value it produces.\n\n@param operation Is either the string name of the operation, in which case this method is a\nshorthand for {@code feed(operation, 0)}, or it is a string of the form\n<tt>operation_name:output_index</tt> , in which case this method acts like {@code\nfeed(operation_name, output_index)}. These colon-separated names are commonly used in the\n{@code SignatureDef} protocol buffer messages that are included in {@link\nSavedModelBundle#metaGraphDef()}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/JUnitCore.java",
    "type": "method",
    "name": "runClasses",
    "code": "public static Result runClasses(Class<?>... classes) {\n        return runClasses(defaultComputer(), classes);\n    }",
    "comment": "Run the tests contained in <code>classes</code>. Write feedback while the tests\nare running and write stack traces for all failed tests after all tests complete. This is\nsimilar to {@link #main(String[])}, but intended to be used programmatically.\n\n@param classes Classes in which to find tests\n@return a {@link Result} describing the details of the test run and the failed tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/saga/src/main/java/com/iluwatar/saga/choreography/Saga.java",
    "type": "method",
    "name": "create",
    "code": "public static Saga create() {\n    return new Saga();\n  }",
    "comment": "Saga representation. Saga consists of chapters. Every ChoreographyChapter is executed a certain\nservice."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/MyDoubleSum.java",
    "type": "method",
    "name": "evaluate",
    "code": "@Override public Object evaluate(Row buffer) {\n    if (buffer.isNullAt(0)) {\n      return null;\n    } else {\n      return buffer.getDouble(0);\n    }\n  }",
    "comment": "If the buffer value is still null, we return null.\nOtherwise, the intermediate sum is the final result."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/hexagonal-architecture/src/main/java/com/iluwatar/hexagonal/domain/LotteryNumbers.java",
    "type": "method",
    "name": "createRandom",
    "code": "public static LotteryNumbers createRandom() {\n    return new LotteryNumbers();\n  }",
    "comment": "Creates a random lottery number.\n\n@return random LotteryNumbers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "portMaxRetries",
    "code": "public int portMaxRetries() {\n    return conf.getInt(\"spark.port.maxRetries\", 16);\n  }",
    "comment": "Maximum number of retries when binding to a port before giving up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java",
    "type": "method",
    "name": "nodeSkipped",
    "code": "public void nodeSkipped(JupiterEngineExecutionContext context, TestDescriptor descriptor, SkipResult result) {\n\t\t/* no-op */\n\t}",
    "comment": "Override {@link TestMethodTestDescriptor#nodeSkipped} as a no-op, since\nthe {@code TestWatcher} API is not supported for {@code @TestFactory}\ncontainers.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java",
    "type": "method",
    "name": "after",
    "code": "public void after(JupiterEngineExecutionContext context) {\n\t\tthis.invocationContext = null;\n\t}",
    "comment": "forget invocationContext so it can be garbage collected"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, double expected, double actual, double delta) {\n        if (Double.compare(expected, actual) == 0) {\n            return;\n        }\n        if (!(Math.abs(expected - actual) <= delta)) {\n            failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));\n        }\n    }",
    "comment": "Asserts that two doubles are equal concerning a delta.  If they are not\nan AssertionFailedError is thrown with the given message.  If the expected\nvalue is infinity then the delta value is ignored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(PackageSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link PackageSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "DeleteColumn",
    "code": "private DeleteColumn(String[] fieldNames, Boolean ifExists) {\n      this.fieldNames = fieldNames;\n      this.ifExists = ifExists;\n    }",
    "comment": "A TableChange to delete a field.\n<p>\nIf the field does not exist, the change must result in an {@link IllegalArgumentException}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/combinator/src/main/java/com/iluwatar/combinator/Finders.java",
    "type": "method",
    "name": "specializedFinder",
    "code": "public static Finder specializedFinder(String... queries) {\n    var finder = identMult();\n\n    for (String query : queries) {\n      finder = finder.and(Finder.contains(query));\n    }\n    return finder;\n  }",
    "comment": "Specialized query. Every next query is looked in previous result.\n\n@param queries array with queries\n@return new finder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/builder/multithreaded/ConcurrencyDependencyGraph.java",
    "type": "method",
    "name": "getRootSchedulableBuilds",
    "code": "public List<MavenProject> getRootSchedulableBuilds() {\n        Set<MavenProject> result = new LinkedHashSet<>();\n        for (ProjectSegment projectBuild : projectBuilds) {\n            if (projectDependencyGraph\n                    .getUpstreamProjects(projectBuild.getProject(), false)\n                    .isEmpty()) {\n                result.add(projectBuild.getProject());\n            }\n        }\n        if (result.isEmpty() && projectBuilds.size() > 0) {\n            // Must return at least one project\n            result.add(projectBuilds.get(0).getProject());\n        }\n        return new ArrayList<>(result);\n    }",
    "comment": "Gets all the builds that have no reactor-dependencies\n\n@return A set of all the initial builds"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/test/java/org/apache/spark/util/kvstore/LevelDBSuite.java",
    "type": "method",
    "name": "createCustomType1",
    "code": "for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        ArrayKeyIndexType o = new ArrayKeyIndexType();\n        o.key = new int[] { i, j, 0 };\n        o.id = new String[] { \"things\" };\n        o.key = new int[] { i, j, 1 };\n        o.id = new String[] { \"more things\" };\n    }\n\n    ArrayKeyIndexType o = new ArrayKeyIndexType();\n    o.key = new int[] { 2, 2, 2 };\n    o.id = new String[] { \"things\" };\n      ImmutableSet.of(new int[] {0, 0, 0}, new int[] { 2, 2, 2 }));\n      ImmutableSet.of(new String[] { \"things\" }));\n      ImmutableSet.of(new String[] { \"more things\" }));\n\n  @Test\n  public void testSkip() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      db.write(createCustomType1(i));\n    }\n\n    try (KVStoreIterator<CustomType1> it = db.view(CustomType1.class).closeableIterator()) {\n      assertTrue(it.hasNext());\n      assertTrue(it.skip(5));\n      assertEquals(\"key5\", it.next().key);\n      assertTrue(it.skip(3));\n      assertEquals(\"key9\", it.next().key);\n      assertFalse(it.hasNext());\n    }\n  }\n\n  @Test\n  public void testNegativeIndexValues() throws Exception {\n    List<Integer> expected = Arrays.asList(-100, -50, 0, 50, 100);\n\n    expected.forEach(i -> {\n      try {\n        db.write(createCustomType1(i));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    try (KVStoreIterator<CustomType1> iterator =\n      db.view(CustomType1.class).index(\"int\").closeableIterator()) {\n      List<Integer> results = StreamSupport\n        .stream(Spliterators.spliteratorUnknownSize(iterator, 0), false)\n        .map(e -> e.num)\n        .collect(Collectors.toList());\n\n      assertEquals(expected, results);\n    }\n  }\n\n  @Test\n  public void testCloseLevelDBIterator() throws Exception {\n    File dbPathForCloseTest = File\n      .createTempFile(\n        \"test_db_close.\",\n        \".ldb\");\n    dbPathForCloseTest.delete();\n    LevelDB dbForCloseTest = new LevelDB(dbPathForCloseTest);\n    for (int i = 0; i < 8192; i++) {\n      dbForCloseTest.write(createCustomType1(i));\n    }\n    String key = dbForCloseTest\n      .view(CustomType1.class).iterator().next().key;\n    assertEquals(\"key0\", key);\n    Iterator<CustomType1> it0 = dbForCloseTest\n      .view(CustomType1.class).max(1).iterator();\n    while (it0.hasNext()) {\n      it0.next();\n    }\n    System.gc();\n    Iterator<CustomType1> it1 = dbForCloseTest\n      .view(CustomType1.class).iterator();\n    assertEquals(\"key0\", it1.next().key);\n    try (KVStoreIterator<CustomType1> it2 = dbForCloseTest\n      .view(CustomType1.class).closeableIterator()) {\n      assertEquals(\"key0\", it2.next().key);\n    }\n    dbForCloseTest.close();\n    assertTrue(dbPathForCloseTest.exists());\n    FileUtils.deleteQuietly(dbPathForCloseTest);\n    assertTrue(!dbPathForCloseTest.exists());\n  }\n\n  @Test\n  public void testHasNextAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertFalse(iter.hasNext());\n  }\n\n  @Test\n  public void testHasNextAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    db.close();\n    assertFalse(iter.hasNext());\n  }\n\n  @Test\n  public void testNextAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertThrows(NoSuchElementException.class, iter::next);\n  }\n\n  @Test\n  public void testNextAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertThrows(NoSuchElementException.class, iter::next);\n  }\n\n  @Test\n  public void testSkipAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    iter.close();\n    assertFalse(iter.skip(0));\n    assertFalse(iter.skip(1));\n  }\n\n  @Test\n  public void testSkipAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    db.close();\n    assertFalse(iter.skip(0));\n    assertFalse(iter.skip(1));\n  }\n\n  @Test\n  public void testResourceCleaner() throws Exception {\n    File dbPathForCleanerTest = File.createTempFile(\n      \"test_db_cleaner.\", \".rdb\");\n    dbPathForCleanerTest.delete();\n\n    LevelDB dbForCleanerTest = new LevelDB(dbPathForCleanerTest);\n    try {\n      for (int i = 0; i < 8192; i++) {\n        dbForCleanerTest.write(createCustomType1(i));\n      }\n      LevelDBIterator<CustomType1> levelDBIterator =\n        (LevelDBIterator<CustomType1>) dbForCleanerTest.view(CustomType1.class).iterator();\n      Reference<LevelDBIterator<?>> reference = new WeakReference<>(levelDBIterator);\n      assertNotNull(reference);\n      LevelDBIterator.ResourceCleaner resourceCleaner = levelDBIterator.getResourceCleaner();\n      assertFalse(resourceCleaner.isCompleted());\n      levelDBIterator = null;\n      int count = 0;\n      while (count < 100 && !reference.refersTo(null)) {\n        System.gc();\n        count++;\n        Thread.sleep(100);\n      }\n      assertTrue(reference.refersTo(null));\n      assertTrue(resourceCleaner.isCompleted());\n    } finally {\n      dbForCleanerTest.close();\n      FileUtils.deleteQuietly(dbPathForCleanerTest);\n    }\n  }\n\n  @Test\n  public void testMultipleTypesWriteAll() throws Exception {\n\n    List<CustomType1> type1List = Arrays.asList(\n      createCustomType1(1),\n      createCustomType1(2),\n      createCustomType1(3),\n      createCustomType1(4)\n    );\n\n    List<CustomType2> type2List = Arrays.asList(\n      createCustomType2(10),\n      createCustomType2(11),\n      createCustomType2(12),\n      createCustomType2(13)\n    );\n\n    List fullList = new ArrayList();\n    fullList.addAll(type1List);\n    fullList.addAll(type2List);\n\n    db.writeAll(fullList);\n    for (CustomType1 value : type1List) {\n      assertEquals(value, db.read(value.getClass(), value.key));\n    }\n    for (CustomType2 value : type2List) {\n      assertEquals(value, db.read(value.getClass(), value.key));\n    }\n  }\n\n\n  private CustomType1 createCustomType1(int i) {\n    CustomType1 t = new CustomType1();\n    t.key = \"key\" + i;\n    t.id = \"id\" + i;\n    t.name = \"name\" + i;\n    t.num = i;\n    t.child = \"child\" + i;\n    return t;\n  }\n\n  private CustomType2 createCustomType2(int i) {\n    CustomType2 t = new CustomType2();\n    t.key = \"key\" + i;\n    t.id = \"id\" + i;\n    t.parentId = \"parent_id\" + (i / 2);\n    return t;\n  }\n\n  private int countKeys(Class<?> type) throws Exception {\n    byte[] prefix = db.getTypeInfo(type).keyPrefix();\n    int count = 0;\n\n    try (DBIterator it = db.db().iterator()) {\n      it.seek(prefix);\n\n      while (it.hasNext()) {\n        byte[] key = it.next().getKey();\n        if (LevelDBIterator.startsWith(key, prefix)) {\n          count++;\n        }\n      }\n    }\n\n    return count;\n  }\n}",
    "comment": "Look into the actual DB and make sure that all the keys related to the type have been\nremoved.\nThere should be one \"id\" index entry with two values.\nDelete the first entry; now there should be 3 remaining keys, since one of the \"name\"\nindex entries should have been removed.\nMake sure there's a single entry in the \"id\" index now.\nDelete the remaining entry, make sure all data is gone.\nSPARK-31929: test when LevelDB.close() is called, related LevelDBIterators\nare closed. And files opened by iterators are also closed.\niter should be true\nclose iter\niter.hasNext should be false after iter close\niter should be true\nclose db\niter.hasNext should be false after db close\niter should be true\nclose iter\niter.next should throw NoSuchElementException after iter close\niter should be true\nclose db\niter.next should throw NoSuchElementException after db close\nclose iter\nskip should always return false after iter close\niter should be true\nclose db\nskip should always return false after db close\nManually set levelDBIterator to null, to be GC.\n100 times gc, the levelDBIterator should be GCed.\ncheck rocksDBIterator should be GCed\nVerify that the Cleaner will be executed after a period of time, isAllocated is true."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/HealthCheckRepositoryTest.java",
    "type": "method",
    "name": "whenPerformTestTransaction_andPersistFails_thenThrowsException",
    "code": "void whenPerformTestTransaction_andPersistFails_thenThrowsException() {\n    // Arrange\n    doThrow(new RuntimeException()).when(entityManager).persist(any(HealthCheck.class));\n\n    // Act & Assert\n    assertThrows(RuntimeException.class, () -> healthCheckRepository.performTestTransaction());\n\n    // Verify that remove is not called if persist fails\n    verify(entityManager, never()).remove(any(HealthCheck.class));\n  }",
    "comment": "Test case for the `performTestTransaction()` method when the persist operation fails.\n\n<p>Asserts that when the `performTestTransaction()` method is called and the persist operation\nfails, it throws a RuntimeException."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/classification/JavaDecisionTreeClassifierSuite.java",
    "type": "method",
    "name": "runDT",
    "code": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 2);\n\n    DecisionTreeClassifier dt = new DecisionTreeClassifier()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String impurity : DecisionTreeClassifier.supportedImpurities()) {\n      dt.setImpurity(impurity);\n    }\n    DecisionTreeClassificationModel model = dt.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.numNodes();\n    model.depth();\n    model.toDebugString();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model3.save(sc.sc(), path);\n      DecisionTreeClassificationModel sameModel =\n        DecisionTreeClassificationModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model3, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
    "comment": "This tests setters. Training with various options is tested in Scala.\nTODO: Add test once save/load are implemented.  SPARK-6725"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/AlbumPage.java",
    "type": "method",
    "name": "cancelChanges",
    "code": "public AlbumListPage cancelChanges() {\n    var cancelButton = (HtmlSubmitInput) page.getElementById(\"cancelButton\");\n    try {\n      cancelButton.click();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return new AlbumListPage(webClient);\n  }",
    "comment": "Cancel changes made by clicking the cancel button\n\n@return {@link AlbumListPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/EngineDescriptor.java",
    "type": "method",
    "name": "EngineDescriptor",
    "code": "public EngineDescriptor(UniqueId uniqueId, String displayName) {\n\t\tsuper(uniqueId, displayName);\n\t}",
    "comment": "Create a new {@code EngineDescriptor} with the supplied {@link UniqueId}\nnever {@code null}\n@param displayName the display name for the described {@code TestEngine};\nnever {@code null} or blank\n@see org.junit.platform.engine.TestEngine#getId()\n@see org.junit.platform.engine.TestDescriptor#getDisplayName()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicSample/app/src/main/java/com/example/android/persistence/viewmodel/ProductViewModel.java",
    "type": "method",
    "name": "Factory",
    "code": "public Factory(@NonNull Application application, int productId) {\n            mApplication = application;\n            mProductId = productId;\n            mRepository = ((BasicApp) application).getRepository();\n        }",
    "comment": "A creator is used to inject the product ID into the ViewModel\n<p>\nThis creator is to showcase how to inject dependencies into ViewModels. It's not\nactually necessary in this case, as the product ID can be passed in a public method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "suite",
    "code": "public SuiteLauncherDiscoveryRequestBuilder suite(Class<?> suiteClass) {\n\t\tPreconditions.notNull(suiteClass, \"Suite class must not be null\");\n\t\tapplyConfigurationParametersFromSuite(suiteClass);\n\t\tapplySelectorsAndFiltersFromSuite(suiteClass);\n\t\treturn this;\n\t}",
    "comment": "Apply a suite's annotation-based configuration, selectors, and filters to\nthis builder.\n\n@param suiteClass the class to apply the annotations from; never {@code null}\n@return this builder for method chaining\n@see org.junit.platform.suite.api.Suite\n@deprecated as of JUnit Platform 1.11 in favor of\n{@link #applyConfigurationParametersFromSuite} and\n{@link #applySelectorsAndFiltersFromSuite}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestWatcherTests.java",
    "type": "method",
    "name": "testWatcherSemanticsWhenRegisteredAtMethodLevel",
    "code": "void testWatcherSemanticsWhenRegisteredAtMethodLevel() {\n\t\tClass<?> testClass = MethodLevelTestWatcherTestCase.class;\n\t\tassertStatsForAbstractDisabledMethodsTestCase(testClass);\n\n\t\tassertThat(TrackingTestWatcher.results.get(\"testDisabled\")).containsExactly(\"test\", \"repeatedTest\");\n\t}",
    "comment": "We get \"testDisabled\" events for the @Test method and the @RepeatedTest container."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assume.java",
    "type": "method",
    "name": "assumeFalse",
    "code": "public static void assumeFalse(String message, boolean b) {\n        assumeTrue(message, !b);\n    }",
    "comment": "The inverse of {@link #assumeTrue(String, boolean)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/anti-corruption-layer/src/main/java/com/iluwatar/corruption/system/AntiCorruptionLayer.java",
    "type": "method",
    "name": "findOrderInLegacySystem",
    "code": "public Optional<ModernOrder> findOrderInLegacySystem(String id) {\n\n    return legacyShop\n        .findOrder(id)\n        .map(\n            o ->\n                new ModernOrder(\n                    o.getId(),\n                    new Customer(o.getCustomer()),\n                    new Shipment(o.getItem(), o.getQty(), o.getPrice()),\n                    \"\"));\n  }",
    "comment": "The method converts the order from the legacy system to the modern system.\n\n@param id the id of the order\n@return the order in the modern system"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng2739RequiredRepositoryElementsTest.java",
    "type": "method",
    "name": "MavenITmng2739RequiredRepositoryElementsTest",
    "code": "public MavenITmng2739RequiredRepositoryElementsTest() {\n        super(\"(2.0.9,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-2739\">MNG-2739</a>.\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/OutputMode.java",
    "type": "method",
    "name": "Update",
    "code": "public static OutputMode Update() {\n    return InternalOutputModes.Update$.MODULE$;\n  }",
    "comment": "OutputMode in which only the rows that were updated in the streaming DataFrame/Dataset will\nbe written to the sink every time there are some updates. If the query doesn't contain\naggregations, it will be equivalent to `Append` mode.\n\n@since 2.1.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/transfer/SimplexTransferListener.java",
    "type": "method",
    "name": "SimplexTransferListener",
    "code": "public SimplexTransferListener(TransferListener delegate) {\n        this(delegate, QUEUE_SIZE, BATCH_MAX_SIZE, true);\n    }",
    "comment": "Constructor that makes passed in delegate run on single thread, and will block on last event."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/ChunkFetchSuccess.java",
    "type": "method",
    "name": "ChunkFetchSuccess",
    "code": "public ChunkFetchSuccess(StreamChunkId streamChunkId, ManagedBuffer buffer) {\n    super(buffer, true);\n    this.streamChunkId = streamChunkId;\n  }",
    "comment": "Response to {@link ChunkFetchRequest} when a chunk exists and has been successfully fetched.\n\nNote that the server-side encoding of this messages does NOT include the buffer itself, as this\nmay be written by Netty in a more efficient manner (i.e., zero-copy write).\nSimilarly, the client-side decoding will reuse the Netty ByteBuf as the buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "cursorUpLine",
    "code": "public Ansi cursorUpLine(final int n) {\n        return n < 0 ? cursorDownLine(-n) : appendEscapeSequence('F', n);\n    }",
    "comment": "Moves the cursor to the beginning of the n-th line above. If the parameter n is negative it\nmoves the cursor to the beginning of the n-th line below.\n\n@param n the number of lines to move the cursor\n@return this Ansi instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelValidator.java",
    "type": "method",
    "name": "validateRawModel",
    "code": "public void validateRawModel(Model m, int validationLevel, ModelProblemCollector problems) {\n        String minVersion = new MavenModelVersion().getModelVersion(m);\n        if (m.getModelVersion() != null && compareModelVersions(minVersion, m.getModelVersion()) > 0) {\n            addViolation(\n                    problems,\n                    Severity.FATAL,\n                    Version.V40,\n                    \"model\",\n                    null,\n                    \"the model contains elements that require a model version of \" + minVersion,\n                    m);\n        }\n\n        Parent parent = m.getParent();\n\n        if (parent != null) {\n            validateStringNotEmpty(\n                    \"parent.groupId\", problems, Severity.FATAL, Version.BASE, parent.getGroupId(), parent);\n\n            validateStringNotEmpty(\n                    \"parent.artifactId\", problems, Severity.FATAL, Version.BASE, parent.getArtifactId(), parent);\n\n            validateStringNotEmpty(\n                    \"parent.version\", problems, Severity.FATAL, Version.BASE, parent.getVersion(), parent);\n\n            if (equals(parent.getGroupId(), m.getGroupId()) && equals(parent.getArtifactId(), m.getArtifactId())) {\n                addViolation(\n                        problems,\n                        Severity.FATAL,\n                        Version.BASE,\n                        \"parent.artifactId\",\n                        null,\n                        \"must be changed\"\n                                + \", the parent element cannot have the same groupId:artifactId as the project.\",\n                        parent);\n            }\n\n            if (equals(\"LATEST\", parent.getVersion()) || equals(\"RELEASE\", parent.getVersion())) {\n                addViolation(\n                        problems,\n                        Severity.WARNING,\n                        Version.BASE,\n                        \"parent.version\",\n                        null,\n                        \"is either LATEST or RELEASE (both of them are being deprecated)\",\n                        parent);\n            }\n        }\n    }",
    "comment": "Check that the model version is correctly set wrt the model definition, i.e., that the\nuser does not use an attribute or element that is not available in the modelVersion used."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeoutPreemptively.java",
    "type": "method",
    "name": "newThread",
    "code": "public Thread newThread(Runnable r) {\n\t\t\treturn new Thread(r, \"junit-timeout-thread-\" + threadNumber.getAndIncrement());\n\t\t}",
    "comment": "The thread factory used for preemptive timeout.\n\n<p>The factory creates threads with meaningful names, helpful for debugging\npurposes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/functions/BoundFunction.java",
    "type": "method",
    "name": "canonicalName",
    "code": "default String canonicalName() {\n    // by default, use a random UUID so a function is never equivalent to another, even itself.\n    // this method is not required so that generated implementations (or careless ones) are not\n    // added and forgotten. for example, returning \"\" as a place-holder could cause unnecessary\n    // bugs if not replaced before release.\n    return UUID.randomUUID().toString();\n  }",
    "comment": "Returns the canonical name of this function, used to determine if functions are equivalent.\n<p>\nThe canonical name is used to determine whether two functions are the same when loaded by\ndifferent catalogs. For example, the same catalog implementation may be used for by two\nenvironments, \"prod\" and \"test\". Functions produced by the catalogs may be equivalent, but\nloaded using different names, like \"test.func_name\" and \"prod.func_name\".\n<p>\nNames returned by this function should be unique and unlikely to conflict with similar\nfunctions in other catalogs. For example, many catalogs may define a \"bucket\" function with a\ndifferent implementation. Adding context, like \"com.mycompany.bucket(string)\", is recommended\nto avoid unintentional collisions.\n\n@return a canonical name for this function"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "with",
    "code": "private Location with(Object base, long offset, int length) {\n      this.isDefined = true;\n      this.memoryPage = null;\n      baseObject = base;\n      int uaoSize = UnsafeAlignedOffset.getUaoSize();\n      keyOffset = offset + uaoSize;\n      keyLength = UnsafeAlignedOffset.getSize(base, offset);\n      valueOffset = offset + uaoSize + keyLength;\n      valueLength = length - uaoSize - keyLength;\n      return this;\n    }",
    "comment": "This is only used for spilling"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/MojoExecution.java",
    "type": "method",
    "name": "MojoExecution",
    "code": "public MojoExecution(Plugin plugin, String goal, String executionId) {\n        this.plugin = plugin;\n        this.goal = goal;\n        this.executionId = executionId;\n    }",
    "comment": "The executions to fork before this execution, indexed by the groupId:artifactId:version of the project on which\nthe forked execution are to be run and in reactor build order."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/LauncherDiscoveryListener.java",
    "type": "method",
    "name": "LauncherDiscoveryListener",
    "code": "LauncherDiscoveryListener NOOP = new LauncherDiscoveryListener() {\n\n\t@API(status = STABLE, since = \"1.10\")\n\tdefault void launcherDiscoveryStarted(LauncherDiscoveryRequest request) {\n\t}\n\n\t@API(status = STABLE, since = \"1.10\")\n\tdefault void launcherDiscoveryFinished(LauncherDiscoveryRequest request) {\n\t}\n\n\tdefault void engineDiscoveryStarted(UniqueId engineId) {\n\t}\n\n\tdefault void engineDiscoveryFinished(UniqueId engineId, EngineDiscoveryResult result) {\n\t}\n\n}",
    "comment": "Called when test discovery has finished for an engine.\n\n<p>Exceptions thrown by implementations of this method will cause the\ncomplete test discovery to be aborted.\n\n@param engineId the unique ID of the engine descriptor\n@param result the discovery result of the supplied engine\n@see EngineDiscoveryResult"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/AbstractExecutionConditionTests.java",
    "type": "method",
    "name": "ensureAllTestMethodsAreCovered",
    "code": "void ensureAllTestMethodsAreCovered() {\n\t\tPredicate<Method> isTestMethod = method -> method.isAnnotationPresent(Test.class);\n\n\t\tList<String> methodsToTest = findMethods(getTestClass(), isTestMethod, TOP_DOWN).stream()//\n\t\t\t\t.map(Method::getName).sorted().toList();\n\n\t\tList<String> localTestMethods = findMethods(getClass(), isTestMethod, TOP_DOWN).stream()//\n\t\t\t\t.map(Method::getName).sorted().toList();\n\n\t\tassertThat(localTestMethods).containsExactlyElementsOf(methodsToTest);\n\t}",
    "comment": "Abstract base class for unit testing a concrete {@link ExecutionCondition}\nimplementation.\n\n<p><strong>WARNING</strong>: this abstract base class currently does not\nsupport tests in {@code @Nested} test classes within the\n{@linkplain #getTestClass() test class}, since {@link #beforeEach(TestInfo)}\ninstantiates the test class using the no-args default constructor.\n\n@since 5.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/iterator/src/main/java/com/iluwatar/iterator/bst/TreeNode.java",
    "type": "method",
    "name": "insertNewChild",
    "code": "private void insertNewChild(T valToInsert) {\n    if (this.isLessThanOrEqualTo(valToInsert)) {\n      this.setRight(new TreeNode<>(valToInsert));\n    } else {\n      this.setLeft(new TreeNode<>(valToInsert));\n    }\n  }",
    "comment": "Add a new Child TreeNode of given value to self. WARNING: This method is destructive (will\noverwrite existing tree structure, if any), and should be called only by this class's insert()\nmethod.\n\n@param valToInsert Value of the new TreeNode to be inserted"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcKeyStore",
    "code": "public File sslRpcKeyStore() {\n    String keyStore = conf.get(\"spark.ssl.rpc.keyStore\", null);\n    if (keyStore != null) {\n      return new File(keyStore);\n    } else {\n      return null;\n    }\n  }",
    "comment": "The key-store file; can be relative to the current directory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaQuantileDiscretizerExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaQuantileDiscretizerExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(0, 18.0),\n      RowFactory.create(1, 19.0),\n      RowFactory.create(2, 8.0),\n      RowFactory.create(3, 5.0),\n      RowFactory.create(4, 2.2)\n    );\n\n    StructType schema = new StructType(new StructField[]{\n\n    Dataset<Row> df = spark.createDataFrame(data, schema);\n    df = df.repartition(1);\n    QuantileDiscretizer discretizer = new QuantileDiscretizer()\n      .setInputCol(\"hour\")\n      .setOutputCol(\"result\")\n      .setNumBuckets(3);\n\n    Dataset<Row> result = discretizer.fit(df).transform(df);\n    result.show(false);\n    spark.stop();\n  }\n}",
    "comment": "$example on$\n$example off$\n$example on$\n$example off$\nOutput of QuantileDiscretizer for such small datasets can depend on the number of\npartitions. Here we force a single partition to ensure consistent results.\nNote this is not necessary for normal use cases\n$example on$\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/Checks.java",
    "type": "method",
    "name": "notNull",
    "code": "public static <T> T notNull(T value, String message) {\n        if (value == null) {\n            throw new NullPointerException(message);\n        }\n        return value;\n    }",
    "comment": "Checks that the given value is not {@code null}, using the given message\nas the exception message if an exception is thrown.\n\n@param value object reference to check\n@param message message to use if {@code value} is {@code null}\n@return the passed-in value, if not {@code null}\n@throws NullPointerException if {@code value} is {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/DuplicateProjectException.java",
    "type": "method",
    "name": "getCollisions",
    "code": "public Map<String, List<File>> getCollisions() {\n        return collisions;\n    }",
    "comment": "Gets the POM files of the projects that collided.\n\n@return The POM files of the projects that collided, indexed by their g:a:v, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/main/java/com/iluwatar/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    var form = new RegisterWorkerForm(NAME, OCCUPATION, DATE_OF_BIRTH);\n    form.submit();\n  }",
    "comment": "The notification pattern captures information passed between layers, validates the information,\nand returns any errors to the presentation layer if needed.\n\n<p>In this code, this pattern is implemented through the example of a form being submitted to\nregister a worker. The worker inputs their name, occupation, and date of birth to the\nRegisterWorkerForm (which acts as our presentation layer), and passes it to the RegisterWorker\nclass (our domain layer) which validates it. Any errors caught by the domain layer are then\npassed back to the presentation layer through the RegisterWorkerDto."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/protocol/FetchShuffleBlockChunks.java",
    "type": "method",
    "name": "encode",
    "code": "public void encode(ByteBuf buf) {\n    super.encode(buf);\n    buf.writeInt(shuffleMergeId);\n    Encoders.IntArrays.encode(buf, reduceIds);\n    buf.writeInt(chunkIds.length);\n    for (int[] ids: chunkIds) {\n      Encoders.IntArrays.encode(buf, ids);\n    }\n  }",
    "comment": "Even though reduceIds.length == chunkIds.length, we are explicitly setting the length in the\ninterest of forward compatibility."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/MetadataOperation.java",
    "type": "method",
    "name": "convertSchemaPattern",
    "code": "protected String convertSchemaPattern(final String pattern) {\n    if ((pattern == null) || pattern.isEmpty()) {\n      return convertPattern(\"%\", true);\n    } else {\n      return convertPattern(pattern, true);\n    }\n  }",
    "comment": "Convert wildchars and escape sequence of schema pattern from JDBC format to datanucleous/regex\nThe schema pattern treats empty string also as wildchar"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ForkJoinPoolHierarchicalTestExecutorService.java",
    "type": "method",
    "name": "getRawResult",
    "code": "public final Void getRawResult() {\n\t\t\treturn null;\n\t\t}",
    "comment": "Always returns {@code null}.\n\n@return {@code null} always"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelPathTranslator.java",
    "type": "method",
    "name": "DefaultModelPathTranslator",
    "code": "public DefaultModelPathTranslator(PathTranslator pathTranslator) {\n        this.pathTranslator = pathTranslator;\n    }",
    "comment": "Resolves relative paths within a model against a specific base directory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/CalendarInterval.java",
    "type": "method",
    "name": "extractAsPeriod",
    "code": "public Period extractAsPeriod() { return Period.of(0, months, days); }",
    "comment": "Extracts the date part of the interval.\n@return an instance of {@code java.time.Period} based on the months and days fields\nof the given interval, not null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/options/MainCommand.java",
    "type": "method",
    "name": "getLikelyExecutedCommand",
    "code": "private static CommandLine getLikelyExecutedCommand(final CommandLine commandLine) {\n\t\treturn Optional.ofNullable(commandLine.getParseResult().subcommand()) //\n\t\t\t\t.map(parseResult -> parseResult.commandSpec().commandLine()) //\n\t\t\t\t.orElse(commandLine);\n\t}",
    "comment": "Get the most likely executed subcommand, if any, or the main command otherwise.\n@see <a href=\"https://picocli.info/#_executing_commands_with_subcommands\">Executing Commands with Subcommands</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestClassInheritanceTests.java",
    "type": "method",
    "name": "before",
    "code": "void before() {\n\t\t\tcountBeforeInvoked++;\n\t\t\tthis.throwExceptionInAfterMethod = false;\n\t\t}",
    "comment": "Reset state, since the test instance is retained across all test methods;\notherwise, after() always throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassUtils.java",
    "type": "method",
    "name": "nullSafeToString",
    "code": "public static String nullSafeToString(Class<?>... classes) {\n\t\treturn nullSafeToString(Class::getName, classes);\n\t}",
    "comment": "Generate a comma-separated list of fully qualified class names for the\nsupplied classes.\n\n@param classes the classes whose names should be included in the\ngenerated string\n@return a comma-separated list of fully qualified class names, or an empty\nstring if the supplied class array is {@code null} or empty\n@see #nullSafeToString(Function, Class...)\n@see StringUtils#nullSafeToString(Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java",
    "type": "method",
    "name": "concatPath",
    "code": "private void concatPath(StringBuilder url, String path) {\n            if (path.length() > 0) {\n                boolean initialUrlEndsWithSlash = url.charAt(url.length() - 1) == '/';\n                boolean pathStartsWithSlash = path.charAt(0) == '/';\n\n                if (pathStartsWithSlash) {\n                    if (initialUrlEndsWithSlash) {\n                        url.setLength(url.length() - 1);\n                    }\n                } else if (!initialUrlEndsWithSlash) {\n                    url.append('/');\n                }\n\n                url.append(path);\n\n                if (initialUrlEndsWithSlash && !path.endsWith(\"/\")) {\n                    url.append('/');\n                }\n            }\n        }",
    "comment": "1 extra '/' to remove\nadd missing '/' between url and path\nensure resulting url ends with slash if initial url was"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "find",
    "code": "public int find(UTF8String str, int start) {\n    assert (str.numBytes > 0);\n    while (start <= numBytes - str.numBytes) {\n      if (ByteArrayMethods.arrayEquals(base, offset + start, str.base, str.offset, str.numBytes)) {\n        return start;\n      }\n      start += 1;\n    }\n    return -1;\n  }",
    "comment": "Find the `str` from left to right."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/classification/JavaGBTClassifierSuite.java",
    "type": "method",
    "name": "runDT",
    "code": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 2);\n\n    GBTClassifier rf = new GBTClassifier()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setSubsamplingRate(1.0)\n      .setSeed(1234)\n      .setMaxIter(3)\n      .setStepSize(0.1)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String lossType : GBTClassifier.supportedLossTypes()) {\n      rf.setLossType(lossType);\n    }\n    GBTClassificationModel model = rf.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.totalNumNodes();\n    model.toDebugString();\n    model.trees();\n    model.treeWeights();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model3.save(sc.sc(), path);\n      GBTClassificationModel sameModel = GBTClassificationModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model3, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
    "comment": "This tests setters. Training with various options is tested in Scala.\nTODO: Add test once save/load are implemented.  SPARK-6725"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/DuplicateArtifactAttachmentException.java",
    "type": "method",
    "name": "DuplicateArtifactAttachmentException",
    "code": "public DuplicateArtifactAttachmentException(MavenProject project, Artifact artifact) {\n        super(constructMessage(project, artifact));\n        this.project = project;\n        this.artifact = artifact;\n    }",
    "comment": "This exception is thrown if an application attempts to attach\ntwo of the same artifacts to a single project.\n\nTODO Make this a checked exception, and modify the API of MavenProjectHelper.\nCurrently, this modification would create compatibility problems for existing plugins."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java",
    "type": "method",
    "name": "setUp",
    "code": "void setUp() {\n\t\twhen(configuration.getDefaultDisplayNameGenerator()).thenReturn(new DisplayNameGenerator.Standard());\n\t\twhen(configuration.getDefaultExecutionMode()).thenReturn(ExecutionMode.SAME_THREAD);\n\t\twhen(configuration.getDefaultClassesExecutionMode()).thenReturn(ExecutionMode.SAME_THREAD);\n\t\twhen(configuration.getOutputDirectoryProvider()).thenReturn(dummyOutputDirectoryProvider());\n\t}",
    "comment": "Unit tests for concrete implementations of {@link ExtensionContext}:\n{@link JupiterEngineExtensionContext}, {@link ClassExtensionContext}, and\n{@link MethodExtensionContext}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestPlan.java",
    "type": "method",
    "name": "accept",
    "code": "public void accept(Visitor visitor) {\n\t\tgetRoots().forEach(it -> accept(visitor, it));\n\t}",
    "comment": "Accept the supplied {@link Visitor} for a depth-first traversal of the\ntest plan.\n\n@param visitor the visitor to accept; never {@code null}\n@since 1.10"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertionFailureBuilder.java",
    "type": "method",
    "name": "cause",
    "code": "public AssertionFailureBuilder cause(Throwable cause) {\n\t\tthis.cause = cause;\n\t\treturn this;\n\t}",
    "comment": "Set the cause of the assertion failure.\n\n@param cause the failure cause; may be {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "indexOfEmpty",
    "code": "public int indexOfEmpty(int start) {\n    return 0; // TODO: Fix this behaviour (SPARK-48284)\n  }",
    "comment": "Returns the (default) position of the first occurrence of an empty substr in the current\nstring from the specified position (0-based index).\n\n@param start the start position of the current string for searching\n@return the position of the first occurrence of the empty substr (now, always 0)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/running/classes/SuiteTest.java",
    "type": "method",
    "name": "whatHappensWhenASuiteContainsItselfIndirectly",
    "code": "public void whatHappensWhenASuiteContainsItselfIndirectly() {\n        Result result = JUnitCore.runClasses(Hydra.class);\n        assertEquals(2, result.getFailureCount());\n    }",
    "comment": "The interesting case here is that Hydra indirectly contains two copies of\nitself (if it only contains one, Java's StackOverflowError eventually\nbails us out)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterApi.java",
    "type": "method",
    "name": "isCancellable",
    "code": "public boolean isCancellable() {\n      return allowCancellation != null && allowCancellation;\n    }",
    "comment": "Advanced: Returns whether the interpreter is able to be cancelled.\n\n<p>Interpreters may have an experimental API <a\nhref=\"https://www.tensorflow.org/lite/api_docs/java/org/tensorflow/lite/Interpreter#setCancelled(boolean)\">setCancelled(boolean)</a>.\nIf this interpreter is cancellable and such a method is invoked, a cancellation flag will be\nset to true. The interpreter will check the flag between Op invocations, and if it's {@code\ntrue}, the interpreter will stop execution. The interpreter will remain a cancelled state\nuntil explicitly \"uncancelled\" by {@code setCancelled(false)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/Arguments.java",
    "type": "method",
    "name": "argumentSet",
    "code": "static ArgumentSet argumentSet(String name, Object... arguments) {\n\t\treturn new ArgumentSet(name, arguments);\n\t}",
    "comment": "Factory method for creating an {@link ArgumentSet} based on the supplied\n{@code name} and {@code arguments}.\n\n<p>Favor this method over {@link Arguments#of Arguments.of(...)} and\n{@link Arguments#arguments arguments(...)} when you wish to assign a name\nto the entire set of arguments.\n\n<p>This method is well suited to be used as a static import &mdash; for\nexample, via:\n{@code import static org.junit.jupiter.params.provider.Arguments.argumentSet;}.\n\n@param name the name of the argument set; must not be {@code null} or blank\n@param arguments the arguments to be used for an invocation of the test\nmethod; must not be {@code null}\n@return an {@code ArgumentSet}; never {@code null}\n@since 5.11\n@see ArgumentSet\n@see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_PLACEHOLDER\n@see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/util/V2ExpressionSQLBuilder.java",
    "type": "method",
    "name": "escapeSpecialCharsForLikePattern",
    "code": "protected String escapeSpecialCharsForLikePattern(String str) {\n    StringBuilder builder = new StringBuilder();\n\n    for (char c : str.toCharArray()) {\n      switch (c) {\n        case '_' -> builder.append(\"\\\\_\");\n        case '%' -> builder.append(\"\\\\%\");\n        default -> builder.append(c);\n      }\n    }\n\n    return builder.toString();\n  }",
    "comment": "Escape the special chars for like pattern.\n\nNote: This method adopts the escape representation within Spark and is not bound to any JDBC\ndialect. JDBC dialect should overwrite this API if the underlying database have more special\nchars other than _ and %."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/matchers/JUnitMatchers.java",
    "type": "method",
    "name": "isThrowable",
    "code": "public static <T extends Throwable> Matcher<T> isThrowable(Matcher<T> throwableMatcher) {\n        return StacktracePrintingMatcher.isThrowable(throwableMatcher);\n    }",
    "comment": "@return A matcher that delegates to throwableMatcher and in addition\nappends the stacktrace of the actual Throwable in case of a mismatch."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/config/PrefixedConfigurationParameters.java",
    "type": "method",
    "name": "PrefixedConfigurationParameters",
    "code": "public PrefixedConfigurationParameters(ConfigurationParameters delegate, String prefix) {\n\t\tthis.delegate = Preconditions.notNull(delegate, \"delegate must not be null\");\n\t\tthis.prefix = Preconditions.notBlank(prefix, \"prefix must not be null or blank\");\n\t}",
    "comment": "Create a new view of the supplied {@link ConfigurationParameters} that\n{@code null}\n@param prefix the prefix to apply to all queries; never {@code null} or\nblank"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/database/VirtualDb.java",
    "type": "method",
    "name": "updateDb",
    "code": "public UserAccount updateDb(final UserAccount userAccount) {\n    return writeToDb(userAccount);\n  }",
    "comment": "Update reecord in DB.\n\n@param userAccount {@link UserAccount}\n@return {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "timeStringAs",
    "code": "public static long timeStringAs(String str, TimeUnit unit) {\n    String lower = str.toLowerCase(Locale.ROOT).trim();\n\n    try {\n      Matcher m = TIME_STRING_PATTERN.matcher(lower);\n      if (!m.matches()) {\n        throw new NumberFormatException(\"Failed to parse time string: \" + str);\n      }\n\n      long val = Long.parseLong(m.group(1));\n      String suffix = m.group(2);\n\n      // Check for invalid suffixes\n      if (suffix != null && !timeSuffixes.containsKey(suffix)) {\n        throw new NumberFormatException(\"Invalid suffix: \\\"\" + suffix + \"\\\"\");\n      }\n\n      // If suffix is valid use that, otherwise none was provided and use the default passed\n      return unit.convert(val, suffix != null ? timeSuffixes.get(suffix) : unit);\n    } catch (NumberFormatException e) {\n      String timeError = \"Time must be specified as seconds (s), \" +\n              \"milliseconds (ms), microseconds (us), minutes (m or min), hour (h), or day (d). \" +\n              \"E.g. 50s, 100ms, or 250us.\";\n\n      throw new NumberFormatException(timeError + \"\\n\" + e.getMessage());\n    }\n  }",
    "comment": "Convert a passed time string (e.g. 50s, 100ms, or 250us) to a time count in the given unit.\nThe unit is also considered the default if the given string does not specify a unit."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "updateUserName",
    "code": "void updateUserName(String userName, UpdateUserCallback callback) {\n        final WeakReference<UpdateUserCallback> updateUserCallback = new WeakReference<>(callback);\n\n        final User user = mCachedUser == null\n                ? new User(userName)\n                : new User(mCachedUser.getId(), userName);\n\n        // update the user on the I/O thread\n        mAppExecutors.diskIO().execute(() -> {\n            mUserDataSource.insertOrUpdateUser(user);\n            mCachedUser = user;\n            // notify on the main thread\n            mAppExecutors.mainThread().execute(() -> {\n                UpdateUserCallback userCallback = updateUserCallback.get();\n                if (userCallback != null) {\n                    userCallback.onUserUpdated(user);\n                }\n            });\n        });\n    }",
    "comment": "Insert an new user or update the name of the user.\n\n@param userName the user name\n@param callback callback that gets triggered when the user was updated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/StylizeActivity.java",
    "type": "method",
    "name": "onKeyDown",
    "code": "public boolean onKeyDown(int keyCode, KeyEvent event) {\n    int moveOffset = 0;\n    switch (keyCode) {\n      case KeyEvent.KEYCODE_DPAD_LEFT:\n        moveOffset = -1;\n        break;\n      case KeyEvent.KEYCODE_DPAD_RIGHT:\n        moveOffset = 1;\n        break;\n      case KeyEvent.KEYCODE_DPAD_UP:\n        moveOffset = -1 * grid.getNumColumns();\n        break;\n      case KeyEvent.KEYCODE_DPAD_DOWN:\n        moveOffset = grid.getNumColumns();\n        break;\n      default:\n        return super.onKeyDown(keyCode, event);\n    }\n\n    int currentSelect = 0;\n    float highestValue = 0;\n    for (int i = 0; i < adapter.getCount(); i++) {\n      if (adapter.items[i].value > highestValue) {\n        currentSelect = i;\n        highestValue = adapter.items[i].value;\n      }\n    }\n    setStyle(adapter.items[(currentSelect + moveOffset + adapter.getCount()) % adapter.getCount()], 1);\n\n    return true;\n  }",
    "comment": "get the highest selected style"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createStructType",
    "code": "public static StructType createStructType(List<StructField> fields) {\n    return createStructType(fields.toArray(new StructField[fields.size()]));\n  }",
    "comment": "Creates a StructType with the given list of StructFields ({@code fields})."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestPlan.java",
    "type": "method",
    "name": "getTestIdentifier",
    "code": "public TestIdentifier getTestIdentifier(UniqueId uniqueId) {\n\t\tPreconditions.notNull(uniqueId, () -> \"uniqueId must not be null\");\n\t\treturn Preconditions.notNull(allIdentifiers.get(uniqueId),\n\t\t\t() -> \"No TestIdentifier with unique ID [\" + uniqueId + \"] has been added to this TestPlan.\");\n\t}",
    "comment": "Get the {@link TestIdentifier} with the supplied unique ID.\n\n@param uniqueId the unique ID to look up the identifier for; never\n{@code null}\n@return the identifier with the supplied unique ID; never {@code null}\n@throws PreconditionViolationException if no {@code TestIdentifier}\nwith the supplied unique ID is present in this test plan"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/OffHeapColumnVector.java",
    "type": "method",
    "name": "OffHeapColumnVector",
    "code": "public OffHeapColumnVector(int capacity, DataType type) {\n    super(capacity, type);\n\n    nulls = 0;\n    data = 0;\n    lengthData = 0;\n    offsetData = 0;\n\n    reserveInternal(capacity);\n    reset();\n  }",
    "comment": "The data stored in these two allocations need to maintain binary compatible. We can\ndirectly pass this buffer to external components.\nOnly set if type is Array or Map."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestWatcherTests.java",
    "type": "method",
    "name": "testWatcherSemanticsWhenRegisteredAtInstanceLevelWithTestInstanceLifecyclePerMethod",
    "code": "void testWatcherSemanticsWhenRegisteredAtInstanceLevelWithTestInstanceLifecyclePerMethod() {\n\t\tClass<?> testClass = TestInstancePerMethodInstanceLevelTestWatcherTestCase.class;\n\t\tassertStatsForAbstractDisabledMethodsTestCase(testClass);\n\n\t\tassertThat(TrackingTestWatcher.results.get(\"testDisabled\")).containsExactly(\"test\");\n\t}",
    "comment": "Since the TestWatcher is registered at the instance level with test instance\nlifecycle per-method semantics, we get a \"testDisabled\" event only for the @Test\nmethod and NOT for the @RepeatedTest container."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ConditionEvaluationResult.java",
    "type": "method",
    "name": "enabled",
    "code": "public static ConditionEvaluationResult enabled(String reason) {\n\t\treturn new ConditionEvaluationResult(true, reason);\n\t}",
    "comment": "Factory for creating <em>enabled</em> results.\n\n@param reason the reason why the container or test should be enabled\n@return an enabled {@code ConditionEvaluationResult} with the given reason"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarBatch.java",
    "type": "method",
    "name": "ColumnarBatch",
    "code": "public ColumnarBatch(ColumnVector[] columns, int numRows) {\n    this.columns = columns;\n    this.numRows = numRows;\n    this.row = new ColumnarBatchRow(columns);\n  }",
    "comment": "Create a new batch from existing column vectors.\n@param columns The columns of this batch\n@param numRows The number of rows in this batch"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenIT0108SnapshotUpdateTest.java",
    "type": "method",
    "name": "getLocalRepoFile",
    "code": "private static File getLocalRepoFile(Verifier verifier) {\n        return new File(verifier.getArtifactPath(\"org.apache.maven\", \"maven-core-it-support\", \"1.0-SNAPSHOT\", \"jar\"));\n    }",
    "comment": "this is to delete metadata - TODO: incorporate into deleteArtifact in verifier"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/Transport.java",
    "type": "method",
    "name": "getString",
    "code": "default Optional<String> getString(@Nonnull URI relativeSource) {\n        return getString(relativeSource, StandardCharsets.UTF_8);\n    }",
    "comment": "GETs the source URI content as string using UTF8 charset. The source MUST BE relative from the\n{@link RemoteRepository#getUrl()} root.\n\n@return the string if operation succeeded, {@code null} if source does not exist.\n@throws RuntimeException If failed (and not due source not exists)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tooling-support-tests/src/archUnit/java/platform/tooling/support/tests/ArchUnitTests.java",
    "type": "method",
    "name": "allAreIn",
    "code": "void allAreIn(JavaClasses classes) {\n\t\tassertTrue(classes.size() > 800, \"expected more than 800 classes, got: \" + classes.size());\n\t}",
    "comment": "about 928 classes found in all jars"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/LifecyclePhaseNotFoundException.java",
    "type": "method",
    "name": "LifecyclePhaseNotFoundException",
    "code": "public LifecyclePhaseNotFoundException(String message, String lifecyclePhase) {\n        super(message);\n        this.lifecyclePhase = (lifecyclePhase != null) ? lifecyclePhase : \"\";\n    }",
    "comment": "Creates a new exception to indicate that the specified lifecycle phase is not defined by any known lifecycle.\n\n@param message The detail message, may be {@code null}.\n@param lifecyclePhase The name of the lifecycle phase that could not be located, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Float> create(float data) {\n    return Tensor.create(data, Float.class);\n  }",
    "comment": "Creates a scalar tensor containing a single {@code float} element.\n\n@param data The value to put into the new scalar tensor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/entity/Car.java",
    "type": "method",
    "name": "Car",
    "code": "public Car(String manufacturer, String model, int noOfPassengers, int engineCapacity) {\n    super(manufacturer, model, noOfPassengers);\n    this.engineCapacity = engineCapacity;\n  }",
    "comment": "A class that extends the PassengerVehicle class and provides the concrete inheritance\nimplementation of the Car.\n\n@see PassengerVehicle PassengerVehicle\n@see Vehicle Vehicle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/bloc/src/main/java/com/iluwatar/bloc/Main.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    BlocUi blocUi = new BlocUi();\n    blocUi.createAndShowUi();\n  }",
    "comment": "The entry point of the application. Initializes the GUI.\n\n@param args command-line arguments (not used in this example)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-aggregator/src/test/java/com/iluwatar/event/aggregator/EventEmitterTest.java",
    "type": "method",
    "name": "testAllDaysWithoutDefaultObserver",
    "code": "private void testAllDaysWithoutDefaultObserver(final Weekday specialDay, final Event event) {\n    final var observer1 = mock(EventObserver.class);\n    final var observer2 = mock(EventObserver.class);\n\n    final var emitter = this.factoryWithoutDefaultObserver.get();\n    emitter.registerObserver(observer1, event);\n    emitter.registerObserver(observer2, event);\n\n    testAllDays(specialDay, event, emitter, observer1, observer2);\n  }",
    "comment": "Go over every day of the month, and check if the event is emitted on the given day. Use an\nevent emitter without a default observer\n\n@param specialDay The special day on which an event is emitted\n@param event The expected event emitted by the test object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/DiscoveryIssueReporter.java",
    "type": "method",
    "name": "forwarding",
    "code": "static DiscoveryIssueReporter forwarding(EngineDiscoveryListener engineDiscoveryListener, UniqueId engineId) {\n\t\tPreconditions.notNull(engineDiscoveryListener, \"engineDiscoveryListener must not be null\");\n\t\tPreconditions.notNull(engineId, \"engineId must not be null\");\n\t\treturn issue -> engineDiscoveryListener.issueEncountered(engineId, issue);\n\t}",
    "comment": "Create a new {@code DiscoveryIssueReporter} that reports issues to the\n\n@param engineDiscoveryListener the listener to report issues to; never\n{@code null}\n@param engineId the unique identifier of the engine; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4400RepositoryOrderTest.java",
    "type": "method",
    "name": "assertChecksum",
    "code": "private void assertChecksum(String checksum, Properties checksums) {\n        assertEquals(checksum, checksums.getProperty(\"dep-0.1.jar\").toLowerCase(java.util.Locale.ENGLISH));\n    }",
    "comment": "Verify that repositories declared in the POM are accessed in their declaration order.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/update-method/src/main/java/com/iluwatar/updatemethod/World.java",
    "type": "method",
    "name": "gameLoop",
    "code": "private void gameLoop() {\n    while (isRunning) {\n      processInput();\n      update();\n      render();\n    }\n  }",
    "comment": "Main game loop. This loop will always run until the game is over. For each loop it will process\nuser input, update internal status, and render the next frames. For more detail please refer to\nthe game-loop pattern."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/Phase.java",
    "type": "method",
    "name": "setExecutions",
    "code": "public void setExecutions(java.util.List<Execution> executions) {\n        this.executions = executions;\n    } // -- void setExecutions( java.util.List )",
    "comment": "Set the goals to execute within the phase.\n\n@param executions a executions object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelBuildingException.java",
    "type": "method",
    "name": "ModelBuildingException",
    "code": "public ModelBuildingException(Model model, String modelId, List<ModelProblem> problems) {\n        super(toMessage(modelId, problems));\n\n        if (model != null) {\n            DefaultModelBuildingResult tmp = new DefaultModelBuildingResult();\n            if (modelId == null) {\n                modelId = \"\";\n            }\n            tmp.addModelId(modelId);\n            tmp.setRawModel(modelId, model);\n            tmp.setProblems(problems);\n            result = tmp;\n        } else {\n            result = null;\n        }\n    }",
    "comment": "Creates a new exception with the specified problems.\n\n@param model The model that could not be built, may be {@code null}.\n@param modelId The identifier of the model that could not be built, may be {@code null}.\n@param problems The problems that causes this exception, may be {@code null}.\n@deprecated Use {@link #ModelBuildingException(ModelBuildingResult)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, double expected, double actual, double delta) {\n        Assert.assertEquals(message, expected, actual, delta);\n    }",
    "comment": "Asserts that two doubles are equal concerning a delta.  If they are not\nan AssertionFailedError is thrown with the given message.  If the expected\nvalue is infinity then the delta value is ignored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getElementAtIndex",
    "code": "public Variant getElementAtIndex(int index) {\n    return handleArray(value, pos, (size, offsetSize, offsetStart, dataStart) -> {\n      if (index < 0 || index >= size) return null;\n      int offset = readUnsigned(value, offsetStart + offsetSize * index, offsetSize);\n      return new Variant(value, metadata, dataStart + offset);\n    });\n  }",
    "comment": "Get the array element at the `index` slot. Return null if `index` is out of the bound of\n`[0, arraySize())`.\nIt is only legal to call it when `getType()` is `Type.ARRAY`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Double unexpected, Double actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/ParquetAvroCompat.java",
    "type": "method",
    "name": "setStringToIntColumn",
    "code": "public void setStringToIntColumn(java.util.Map<java.lang.String,java.lang.Integer> value) {\n    this.string_to_int_column = value;\n  }",
    "comment": "Sets the value of the 'string_to_int_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/NioDatagramChannel.java",
    "type": "method",
    "name": "write",
    "code": "public void write(Object data, SelectionKey key) {\n    super.write(data, key);\n  }",
    "comment": "Writes the outgoing {@link DatagramPacket} to the channel. The intended receiver of the\ndatagram packet must be set in the <code>data</code> using {@link\nDatagramPacket#setReceiver(SocketAddress)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java",
    "type": "method",
    "name": "validateConstructor",
    "code": "protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n        validateZeroArgConstructor(errors);\n    }",
    "comment": "Adds to {@code errors} if the test class has more than one constructor,\nor if the constructor takes parameters. Override if a subclass requires\ndifferent validation rules."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/simple/SimpleFluentIterable.java",
    "type": "method",
    "name": "getRemainingElementsCount",
    "code": "public final int getRemainingElementsCount() {\n    var counter = 0;\n    for (var ignored : this) {\n      counter++;\n    }\n    return counter;\n  }",
    "comment": "Find the count of remaining objects of current iterable.\n\n@return the count of remaining objects of the current Iterable"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/condition/OS.java",
    "type": "method",
    "name": "current",
    "code": "public static OS current() {\n\t\treturn CURRENT_OS;\n\t}",
    "comment": "Get the current operating system.\n\n@since 5.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/ErrorHandlerSuite.java",
    "type": "method",
    "name": "testErrorRetry",
    "code": "public void testErrorRetry() {\n    ErrorHandler.BlockPushErrorHandler pushHandler = new ErrorHandler.BlockPushErrorHandler();\n    assertFalse(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.TOO_LATE_BLOCK_PUSH, \"\")));\n    assertFalse(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.TOO_OLD_ATTEMPT_PUSH, \"\")));\n    assertFalse(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.STALE_BLOCK_PUSH, \"\")));\n    assertFalse(pushHandler.shouldRetryError(new RuntimeException(new ConnectException())));\n    assertTrue(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.BLOCK_APPEND_COLLISION_DETECTED, \"\")));\n    assertTrue(pushHandler.shouldRetryError(new Throwable()));\n\n    ErrorHandler.BlockFetchErrorHandler fetchHandler = new ErrorHandler.BlockFetchErrorHandler();\n    assertFalse(fetchHandler.shouldRetryError(new RuntimeException(\n      ErrorHandler.BlockFetchErrorHandler.STALE_SHUFFLE_BLOCK_FETCH)));\n  }",
    "comment": "Test suite for {@link ErrorHandler}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Timeout.java",
    "type": "method",
    "name": "getLookingForStuckThread",
    "code": "protected final boolean getLookingForStuckThread() {\n        return lookForStuckThread;\n    }",
    "comment": "Gets whether this {@code Timeout} will look for a stuck thread\nwhen the test times out.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/commander/src/main/java/com/iluwatar/commander/RetryParams.java",
    "type": "method",
    "name": "RetryParams",
    "code": "public record RetryParams(int numOfRetries, long retryDuration) {\n  public static final RetryParams DEFAULT = new RetryParams(3, 30000L);\n}",
    "comment": "Record to hold the parameters related to retries.\n\n@param numOfRetries number of retries\n@param retryDuration retry duration"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestInstancePostProcessorAndPreDestroyCallbackTests.java",
    "type": "method",
    "name": "postProcessorAndPreDestroyCallbacks",
    "code": "void postProcessorAndPreDestroyCallbacks() {\n\t\t// @formatter:off\n\t\tassertPostProcessorAndPreDestroyCallbacks(TopLevelTestCase.class,\n\t\t\t\"fooPostProcessTestInstance\",\n\t\t\t\"barPostProcessTestInstance\",\n\t\t\t\t\"test-1\",\n\t\t\t\"barPreDestroyTestInstance\",\n\t\t\t\"fooPreDestroyTestInstance\"\n\t\t);\n\t\t// @formatter:on\n\t}",
    "comment": "Integration tests that verify support for {@link TestInstancePostProcessor}\nand {@link TestInstancePreDestroyCallback} in the {@link JupiterTestEngine}.\n\n@since 5.6"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Short unexpected, Short actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/lazy/LazyFluentIterable.java",
    "type": "method",
    "name": "last",
    "code": "public FluentIterable<E> last(int count) {\n    return new LazyFluentIterable<>() {\n        return new DecoratingIterator<>(iterable.iterator()) {\n            if (currentIndex >= stopIndex && fromIterator.hasNext()) {\n              return fromIterator.next();\n            }\n            return null;\n          }\n\n          private void initialize() {\n            if (list == null) {\n              list = new ArrayList<>();\n              iterable.forEach(list::add);\n              totalElementsCount = list.size();\n              stopIndex = totalElementsCount - count;\n            }\n          }\n        };\n      }",
    "comment": "Can be used to collect objects from the Iterable. Is a terminating operation. This operation is\nmemory intensive, because the contents of this Iterable are collected into a List, when the\nnext object is requested.\n\n@param count defines the number of objects to return\n@return the same FluentIterable with a collection decimated to a maximum of 'count' last\nobjects"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/function-composition/src/main/java/com/iluwatar/function/composition/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    Function<Integer, Integer> timesTwo = x -> x * 2;\n    Function<Integer, Integer> square = x -> x * x;\n\n    Function<Integer, Integer> composedFunction =\n        FunctionComposer.composeFunctions(timesTwo, square);\n\n    int result = composedFunction.apply(3);\n    LOGGER.info(\"Result of composing 'timesTwo' and 'square' functions applied to 3 is: \" + result);\n  }",
    "comment": "Main method to demonstrate function composition using FunctionComposer.\n\n@param args command line arguments (not used)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testSimpleBagAdd",
    "code": "public void testSimpleBagAdd() {\n        IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n        assertEquals(expected, f14CHF.add(fMB1));\n    }",
    "comment": "[14 CHF] + {[12 CHF][7 USD]} == {[26 CHF][7 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/RunListenerAdapter.java",
    "type": "method",
    "name": "testSuiteStarted",
    "code": "public void testSuiteStarted(Description description) {\n\t\tRunnerTestDescriptor runnerTestDescriptor = testRun.getRunnerTestDescriptor();\n\t\tif (!runnerTestDescriptor.getDescription().equals(description)) {\n\t\t\ttestStarted(lookupOrRegisterNextTestDescriptor(description), EventType.REPORTED);\n\t\t}\n\t}",
    "comment": "runnerTestDescriptor is reported in testRunStarted"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTimeoutPreemptively",
    "code": "public static void assertTimeoutPreemptively(Duration timeout, Executable executable, String message) {\n\t\tAssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable, message);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code executable}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>See the {@linkplain Assertions Preemptive Timeouts} section of the\nclass-level Javadoc for further details.\n\n<p>Fails with the supplied failure {@code message}.\n\n@see #assertTimeoutPreemptively(Duration, Executable)\n@see #assertTimeoutPreemptively(Duration, Executable, Supplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, String)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeout(Duration, Executable, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultSourceRoot.java",
    "type": "method",
    "name": "hashCode",
    "code": "public int hashCode() {\n        return Objects.hash(\n                directory,\n                includes,\n                excludes,\n                scope,\n                language,\n                moduleName,\n                targetVersion,\n                targetPath,\n                stringFiltering,\n                enabled);\n    }",
    "comment": "{@return a hash code value computed from all properties}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Double unexpected, Double actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedRleValuesReader.java",
    "type": "method",
    "name": "VectorizedRleValuesReader",
    "code": "public VectorizedRleValuesReader() {\n    this.fixedWidth = false;\n    this.readLength = false;\n  }",
    "comment": "A values reader for Parquet's run-length encoded data. This is based off of the version in\nparquet-mr with these changes:\n- Supports the vectorized interface.\n- Works on byte arrays(byte[]) instead of making byte streams.\n\nThis encoding is used in multiple places:\n- Definition/Repetition levels\n- Dictionary ids.\n- Boolean type values of Parquet DataPageV2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/util/Os.java",
    "type": "method",
    "name": "getOsFamily",
    "code": "private static String getOsFamily() {\n        return Stream.of(\n                        FAMILY_DOS,\n                        FAMILY_MAC,\n                        FAMILY_NETWARE,\n                        FAMILY_NT,\n                        FAMILY_OPENVMS,\n                        FAMILY_OS2,\n                        FAMILY_OS400,\n                        FAMILY_TANDEM,\n                        FAMILY_UNIX,\n                        FAMILY_WIN9X,\n                        FAMILY_WINDOWS,\n                        FAMILY_ZOS,\n                        FAMILY_UNKNOWN)\n                .filter(Os::isFamily)\n                .findFirst()\n                .orElse(null);\n    }",
    "comment": "Helper method to determine the current OS family.\n\n@return name of current OS family."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "verboseMetrics",
    "code": "public boolean verboseMetrics() {\n    return conf.getBoolean(SPARK_NETWORK_VERBOSE_METRICS, false);\n  }",
    "comment": "Whether to track Netty memory detailed metrics. If true, the detailed metrics of Netty\nPoolByteBufAllocator will be gotten, otherwise only general memory usage will be tracked."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/ParserRequest.java",
    "type": "method",
    "name": "mvnenc",
    "code": "static Builder mvnenc(@Nonnull String[] args, @Nonnull MessageBuilderFactory messageBuilderFactory) {\n        return mvnenc(Arrays.asList(args), messageBuilderFactory);\n    }",
    "comment": "Creates a new Builder instance for constructing a Maven Encrypting Tool ParserRequest.\n\n@param args the command-line arguments\n@param messageBuilderFactory the factory for creating message builders\n@return a new Builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/value-object/src/test/java/com/iluwatar/value/object/HeroStatTest.java",
    "type": "method",
    "name": "testToString",
    "code": "void testToString() {\n    var heroStatA = HeroStat.valueOf(3, 9, 2);\n    var heroStatB = HeroStat.valueOf(3, 9, 2);\n    var heroStatC = HeroStat.valueOf(3, 9, 8);\n    assertEquals(heroStatA.toString(), heroStatB.toString());\n    assertNotEquals(heroStatA.toString(), heroStatC.toString());\n  }",
    "comment": "The toString() for two equal values must be the same. For two non-equal values it must be\ndifferent."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/Promise.java",
    "type": "method",
    "name": "thenApply",
    "code": "public <V> Promise<V> thenApply(Function<? super T, V> func) {\n    Promise<V> dest = new Promise<>();\n    fulfillmentAction = new TransformAction<>(this, dest, func);\n    return dest;\n  }",
    "comment": "Returns a new promise that, when this promise is fulfilled normally, is fulfilled with result\nof this promise as argument to the function provided.\n\n@param func function to be executed.\n@return a new promise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaRobustScalerExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaRobustScalerExample\")\n      .getOrCreate();\n\n    Dataset<Row> dataFrame =\n      spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    RobustScaler scaler = new RobustScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\")\n      .setWithScaling(true)\n      .setWithCentering(false)\n      .setLower(0.25)\n      .setUpper(0.75);\n\n    RobustScalerModel scalerModel = scaler.fit(dataFrame);\n\n    Dataset<Row> scaledData = scalerModel.transform(dataFrame);\n    scaledData.show();\n    spark.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nCompute summary statistics by fitting the RobustScaler\nTransform each feature to have unit quantile range.\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "RenameColumn",
    "code": "private RenameColumn(String[] fieldNames, String newName) {\n      this.fieldNames = fieldNames;\n      this.newName = newName;\n    }",
    "comment": "A TableChange to rename a field.\n<p>\nThe name is used to find the field to rename. The new name will replace the leaf field name.\nFor example, renameColumn(\"a.b.c\", \"x\") should produce column a.b.x.\n<p>\nIf the field does not exist, the change must result in an {@link IllegalArgumentException}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "splitIntoTwo",
    "code": "public static TwoPartSplitResult splitIntoTwo(String separator, String value) {\n\t\tPreconditions.notNull(separator, \"separator must not be null\");\n\t\tPreconditions.notNull(value, \"value must not be null\");\n\t\treturn splitIntoTwo(value, value.indexOf(separator), separator.length());\n\t}",
    "comment": "Split the supplied {@link String} into up to two parts using the supplied\nseparator string.\n\n@param separator the separator string; never {@code null}\n@param value the value to split; never {@code null}\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/LoggingListener.java",
    "type": "method",
    "name": "forBiConsumer",
    "code": "public static LoggingListener forBiConsumer(BiConsumer<Throwable, Supplier<String>> logger) {\n\t\treturn new LoggingListener(logger);\n\t}",
    "comment": "Create a {@code LoggingListener} which delegates to the supplied\n{@link BiConsumer} for consumption of logging messages.\n\n<p>The {@code BiConsumer's} arguments are a {@link Throwable} (potentially\n{@code null}) and a {@link Supplier} (never {@code null}) for the log\nmessage.\n\n@param logger a logger implemented as a {@code BiConsumer};\nnever {@code null}\n\n@see #forJavaUtilLogging()\n@see #forJavaUtilLogging(Level)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(BooleanSupplier booleanSupplier, Supplier<String> messageSupplier) {\n\t\tAssertTrue.assertTrue(booleanSupplier, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that the boolean condition supplied by {@code booleanSupplier} is {@code true}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/DataWriter.java",
    "type": "method",
    "name": "currentMetricsValues",
    "code": "default CustomTaskMetric[] currentMetricsValues() {\n    return new CustomTaskMetric[]{};\n}",
    "comment": "Returns an array of custom task metrics. By default it returns empty array. Note that it is\nnot recommended to put heavy logic in this method as it may affect writing performance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/collector/MultiModuleCollectionStrategy.java",
    "type": "method",
    "name": "MultiModuleCollectionStrategy",
    "code": "public MultiModuleCollectionStrategy(ModelProcessor modelProcessor, ProjectsSelector projectsSelector) {\n        this.modelProcessor = modelProcessor;\n        this.projectsSelector = projectsSelector;\n    }",
    "comment": "Strategy for collecting Maven projects from the multi-module project root, even when executed in a submodule."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "isAssignableTo",
    "code": "public static boolean isAssignableTo(Object obj, Class<?> targetType) {\n\t\tPreconditions.notNull(targetType, \"target type must not be null\");\n\n\t\tif (obj == null) {\n\t\t\treturn !targetType.isPrimitive();\n\t\t}\n\n\t\tif (targetType.isInstance(obj)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (targetType.isPrimitive()) {\n\t\t\tClass<?> sourceType = obj.getClass();\n\t\t\treturn sourceType == primitiveToWrapperMap.get(targetType) || isWideningConversion(sourceType, targetType);\n\t\t}\n\n\t\treturn false;\n\t}",
    "comment": "Determine if the supplied object can be assigned to the supplied target\ntype for the purpose of reflective method invocations.\n\n<p>In contrast to {@link Class#isInstance(Object)}, this method returns\n{@code true} if the target type represents a primitive type whose wrapper\nmatches the supplied object's type. In addition, this method also supports\n<a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2\">\nwidening conversions</a> for primitive types and their corresponding\nwrapper types.\n\n<p>If the supplied object is {@code null} and the supplied type does not\nrepresent a primitive type, this method returns {@code true}.\n\n@param obj the object to test for assignment compatibility; potentially {@code null}\n@param targetType the type to check against; never {@code null}\n@return {@code true} if the object is assignment compatible\n@see Class#isInstance(Object)\n@see Class#isAssignableFrom(Class)\n@see #isAssignableTo(Class, Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/game-loop/src/main/java/com/iluwatar/gameloop/GameController.java",
    "type": "method",
    "name": "moveBullet",
    "code": "public void moveBullet(float offset) {\n    var currentPosition = bullet.getPosition();\n    bullet.setPosition(currentPosition + offset);\n  }",
    "comment": "Move bullet position by the provided offset.\n\n@param offset moving offset"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "substring",
    "code": "public UTF8String substring(final int start, final int until) {\n    if (until <= start || start >= numBytes) {\n      return EMPTY_UTF8;\n    }\n\n    int i = 0;\n    int c = 0;\n    while (i < numBytes && c < start) {\n      i += numBytesForFirstByte(getByte(i));\n      c += 1;\n    }\n\n    int j = i;\n    while (i < numBytes && c < until) {\n      i += numBytesForFirstByte(getByte(i));\n      c += 1;\n    }\n\n    if (i > j) {\n      byte[] bytes = new byte[i - j];\n      copyMemory(base, offset + j, bytes, BYTE_ARRAY_OFFSET, i - j);\n      return fromBytes(bytes);\n    } else {\n      return EMPTY_UTF8;\n    }\n  }",
    "comment": "Returns a substring of this.\n@param start the position of first code point\n@param until the position after last code point, exclusive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java",
    "type": "method",
    "name": "beforeAll",
    "code": "public void beforeAll(ExtensionContext context) {\n\t\tinstallFailureTracker(context);\n\t\tinjectStaticFields(context, context.getRequiredTestClass());\n\t}",
    "comment": "Perform field injection for non-private, {@code static} fields (i.e.,\nclass fields) of type {@link Path} or {@link File} that are annotated with\n{@link TempDir @TempDir}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3710PollutedClonedPluginsTest.java",
    "type": "method",
    "name": "MavenITmng3710PollutedClonedPluginsTest",
    "code": "public MavenITmng3710PollutedClonedPluginsTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3710\">MNG-3710</a>.\n\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/virtual-proxy/src/main/java/com/iluwatar/virtual/proxy/VideoObjectProxy.java",
    "type": "method",
    "name": "process",
    "code": "public void process() {\n    if (realVideoObject == null) {\n      realVideoObject = new RealVideoObject();\n    }\n    realVideoObject.process();\n  }",
    "comment": "A proxy class for the real video object, providing a layer of control over the object\ninstantiation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room2/java/com/example/android/persistence/migrations/UsersDatabase.java",
    "type": "method",
    "name": "Migration",
    "code": "static final Migration MIGRATION_1_2 = new Migration(1, 2) {\n    };",
    "comment": "Migrate from:\nversion 1 - using the SQLiteDatabase API\nto\nversion 2 - using Room"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/sasl/ShuffleSecretManager.java",
    "type": "method",
    "name": "ShuffleSecretManager",
    "code": "public ShuffleSecretManager() {\n    shuffleSecretMap = new ConcurrentHashMap<>();\n  }",
    "comment": "A class that manages shuffle secret used by the external shuffle service."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java",
    "type": "method",
    "name": "getMethodParameterTypes",
    "code": "public final String getMethodParameterTypes() {\n\t\treturn this.methodParameterTypes;\n\t}",
    "comment": "Get the method parameter types of this source."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/StylizeActivity.java",
    "type": "method",
    "name": "processImage",
    "code": "protected void processImage() {\n    if (desiredSize != initializedSize) {\n      LOGGER.i(\n          \"Initializing at size preview size %dx%d, stylize size %d\",\n          previewWidth, previewHeight, desiredSize);\n\n      rgbFrameBitmap = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);\n      croppedBitmap = Bitmap.createBitmap(desiredSize, desiredSize, Config.ARGB_8888);\n      frameToCropTransform = ImageUtils.getTransformationMatrix(\n          previewWidth, previewHeight,\n          desiredSize, desiredSize,\n          sensorOrientation, true);\n\n      cropToFrameTransform = new Matrix();\n      frameToCropTransform.invert(cropToFrameTransform);\n      intValues = new int[desiredSize * desiredSize];\n      floatValues = new float[desiredSize * desiredSize * 3];\n      initializedSize = desiredSize;\n    }\n    rgbFrameBitmap.setPixels(getRgbBytes(), 0, previewWidth, 0, 0, previewWidth, previewHeight);\n    final Canvas canvas = new Canvas(croppedBitmap);\n    canvas.drawBitmap(rgbFrameBitmap, frameToCropTransform, null);\n\n    if (SAVE_PREVIEW_BITMAP) {\n      ImageUtils.saveBitmap(croppedBitmap);\n    }\n\n    runInBackground(\n        new Runnable() {\n        });\n    if (desiredSize != initializedSize) {\n      resetPreviewBuffers();\n    }\n  }",
    "comment": "For examining the actual TF input."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProjectActivation.java",
    "type": "method",
    "name": "deactivateOptionalProject",
    "code": "public void deactivateOptionalProject(String selector) {\n        this.activations.add(new ProjectActivationSettings(selector, ActivationSettings.deactivatedOpt()));\n    }",
    "comment": "Mark a project as optional and deactivated.\n@param selector The selector of the project."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassNameFilter.java",
    "type": "method",
    "name": "excludeClassNamePatterns",
    "code": "static ClassNameFilter excludeClassNamePatterns(String... patterns) {\n\t\treturn new ExcludeClassNameFilter(patterns);\n\t}",
    "comment": "Create a new <em>exclude</em> {@link ClassNameFilter} based on the\n@see Class#getName()\n@see #includeClassNamePatterns(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarArray.java",
    "type": "method",
    "name": "ColumnarArray",
    "code": "public ColumnarArray(ColumnVector data, int offset, int length) {\n    this.data = data;\n    this.offset = offset;\n    this.length = length;\n  }",
    "comment": "Array abstraction in {@link ColumnVector}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Integer expected, int actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Integer) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, float actual, float delta) {\n        assertEquals(null, expected, actual, delta);\n    }",
    "comment": "Asserts that two floats are equal to within a positive delta.\nIf they are not, an {@link AssertionError} is thrown. If the expected\nvalue is infinity then the delta value is ignored. NaNs are considered\nequal: <code>assertEquals(Float.NaN, Float.NaN, *)</code> passes\n\n@param expected expected value\n@param actual the value to check against <code>expected</code>\n@param delta the maximum delta between <code>expected</code> and\n<code>actual</code> for which both numbers are still\nconsidered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/MyDoubleAvg.java",
    "type": "method",
    "name": "MyDoubleAvg",
    "code": "public MyDoubleAvg() {\n    List<StructField> inputFields = new ArrayList<>();\n    inputFields.add(DataTypes.createStructField(\"inputDouble\", DataTypes.DoubleType, true));\n    _inputDataType = DataTypes.createStructType(inputFields);\n\n    // The buffer has two values, bufferSum for storing the current sum and\n    // bufferCount for storing the number of non-null input values that have been contributed\n    // to the current sum.\n    List<StructField> bufferFields = new ArrayList<>();\n    bufferFields.add(DataTypes.createStructField(\"bufferSum\", DataTypes.DoubleType, true));\n    bufferFields.add(DataTypes.createStructField(\"bufferCount\", DataTypes.LongType, true));\n    _bufferSchema = DataTypes.createStructType(bufferFields);\n\n    _returnDataType = DataTypes.DoubleType;\n  }",
    "comment": "An example {@link UserDefinedAggregateFunction} to calculate a special average value of a\n{@link org.apache.spark.sql.types.DoubleType} column. This special average value is the sum\nof the average value of input values and 100.0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3461MirrorMatchingTest.java",
    "type": "method",
    "name": "AbstractHandler",
    "code": "Handler repoHandler = new AbstractHandler() {\n                    response.setStatus(HttpServletResponse.SC_OK);\n                    response.getWriter().println(\"<project>\");\n                    response.getWriter().println(\"  <modelVersion>4.0.0</modelVersion>\");\n                    response.getWriter().println(\"  <groupId>org.apache.maven.its.mng3461</groupId>\");\n                    response.getWriter().println(\"  <artifactId>b</artifactId>\");\n                    response.getWriter().println(\"  <version>0.1</version>\");\n                    response.getWriter().println(\"</project>\");\n                } else {\n                    response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                }",
    "comment": "Test that mirror definitions are properly evaluated. In particular, the wildcard external:* should not\nmatch file:// and localhost repos but only external repos.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom2/java/com/example/android/persistence/migrations/MigrationTest.java",
    "type": "method",
    "name": "getMigratedRoomDatabase",
    "code": "private UsersDatabase getMigratedRoomDatabase() {\n        UsersDatabase database = Room.databaseBuilder(ApplicationProvider.getApplicationContext(),\n                UsersDatabase.class, TEST_DB_NAME)\n                .addMigrations(MIGRATION_1_2, MIGRATION_2_3)\n                .build();\n        // close the database and release any stream resources when the test finishes\n        mMigrationTestHelper.closeWhenFinished(database);\n        return database;\n    }",
    "comment": "Test the migration from versions 1 and 2, to version 3."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/special-case/src/main/java/com/iluwatar/specialcase/MaintenanceLock.java",
    "type": "method",
    "name": "getInstance",
    "code": "public static synchronized MaintenanceLock getInstance() {\n    if (instance == null) {\n      instance = new MaintenanceLock();\n    }\n    return instance;\n  }",
    "comment": "Get the instance of MaintenanceLock.\n\n@return singleton instance of MaintenanceLock"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "addTarget",
    "code": "public Runner addTarget(Operation operation) {\n      if (!(operation instanceof GraphOperation)) {\n        throw new IllegalArgumentException(\n            \"Operation of type \"\n                + operation.getClass().getName()\n                + \" is not supported in graph sessions\");\n      }\n      targets.add((GraphOperation) operation);\n      return this;\n    }",
    "comment": "Make {@link #run()} execute {@code operation}, but not return any evaluated {@link Tensor\nTensors}.\n\n@throws IllegalArgumentException if the operation is not a {@link GraphOperation}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/CountMinSketchImpl.java",
    "type": "method",
    "name": "hash",
    "code": "private int hash(long item, int count) {\n    long hash = hashA[count] * item;\n    hash += hash >> 32;\n    hash &= PRIME_MODULUS;\n    return ((int) hash) % width;\n  }",
    "comment": "A super fast way of computing x mod 2^p-1\nSee http://www.cs.princeton.edu/courses/archive/fall09/cos521/Handouts/universalclasses.pdf\npage 149, right after Proposition 7.\nDoing \"%\" after (int) conversion is ~2x faster than %'ing longs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnenc/goals/ConfiguredGoalSupport.java",
    "type": "method",
    "name": "ConfiguredGoalSupport",
    "code": "protected ConfiguredGoalSupport(MessageBuilderFactory messageBuilderFactory, SecDispatcher secDispatcher) {\n        super(messageBuilderFactory, secDispatcher);\n    }",
    "comment": "The support class for goal implementations that requires valid/workable config."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/HashMapGrowthStrategy.java",
    "type": "method",
    "name": "nextCapacity",
    "code": "public int nextCapacity(int currentCapacity) {\n      assert (currentCapacity > 0);\n      int doubleCapacity = currentCapacity * 2;\n      // Guard against overflow\n      return (doubleCapacity > 0 && doubleCapacity <= ARRAY_MAX) ? doubleCapacity : ARRAY_MAX;\n    }",
    "comment": "Double the size of the hash map every time."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/serialized-lob/src/main/java/com/iluwatar/slob/lob/Animal.java",
    "type": "method",
    "name": "createObjectFromXml",
    "code": "public void createObjectFromXml(Node node) {\n    name = node.getAttributes().getNamedItem(\"name\").getNodeValue();\n    NodeList childNodes = node.getChildNodes();\n    iterateXmlForAnimalAndPlants(childNodes, animalsEaten, plantsEaten);\n  }",
    "comment": "Parses the Animal Object from the input XML Node.\n\n@param node the XML Node from which the Animal Object is to be parsed"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerTestDescriptorPostProcessor.java",
    "type": "method",
    "name": "addChildrenRecursively",
    "code": "private void addChildrenRecursively(VintageTestDescriptor parent) {\n\t\tif (parent.getDescription().isTest()) {\n\t\t\treturn;\n\t\t}\n\t\tList<Description> children = parent.getDescription().getChildren();\n\t\tMap<String, List<Description>> childrenByUniqueId = children.stream().collect(\n\t\t\tgroupingBy(uniqueIdReader.andThen(uniqueIdStringifier), LinkedHashMap::new, toCollection(ArrayList::new)));\n\t\tfor (Entry<String, List<Description>> entry : childrenByUniqueId.entrySet()) {\n\t\t\tString uniqueId = entry.getKey();\n\t\t\tList<Description> childrenWithSameUniqueId = entry.getValue();\n\t\t\tIntFunction<String> uniqueIdGenerator = determineUniqueIdGenerator(uniqueId, childrenWithSameUniqueId);\n\t\t\tfor (int index = 0; index < childrenWithSameUniqueId.size(); index++) {\n\t\t\t\tString reallyUniqueId = uniqueIdGenerator.apply(index);\n\t\t\t\tDescription description = childrenWithSameUniqueId.get(index);\n\t\t\t\tUniqueId id = parent.getUniqueId().append(VintageTestDescriptor.SEGMENT_TYPE_TEST, reallyUniqueId);\n\t\t\t\tVintageTestDescriptor child = new VintageTestDescriptor(id, description,\n\t\t\t\t\ttestSourceProvider.findTestSource(description));\n\t\t\t\tparent.addChild(child);\n\t\t\t\taddChildrenRecursively(child);\n\t\t\t}\n\t\t}\n\t}",
    "comment": "Use LinkedHashMap to preserve order, ArrayList for fast access by index"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/settings/SettingsUtilsTest.java",
    "type": "method",
    "name": "testRoundTripProfiles",
    "code": "void testRoundTripProfiles() {\n        Random entropy = new Random();\n        ActivationFile af = ActivationFile.newBuilder()\n                .exists(\"exists\" + Long.toHexString(entropy.nextLong()))\n                .missing(\"missing\" + Long.toHexString(entropy.nextLong()))\n                .build();\n        ActivationProperty ap = ActivationProperty.newBuilder()\n                .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                .value(\"value\" + Long.toHexString(entropy.nextLong()))\n                .build();\n        ActivationOS ao = ActivationOS.newBuilder()\n                .arch(\"arch\" + Long.toHexString(entropy.nextLong()))\n                .family(\"family\" + Long.toHexString(entropy.nextLong()))\n                .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                .version(\"version\" + Long.toHexString(entropy.nextLong()))\n                .build();\n        Activation a = Activation.newBuilder()\n                .activeByDefault(entropy.nextBoolean())\n                .jdk(\"jdk\" + Long.toHexString(entropy.nextLong()))\n                .file(af)\n                .property(ap)\n                .os(ao)\n                .packaging(\"pom\")\n                .build();\n        Map<String, String> props = new HashMap<>();\n        int count = entropy.nextInt(10);\n        for (int i = 0; i < count; i++) {\n            props.put(\"name\" + Long.toHexString(entropy.nextLong()), \"value\" + Long.toHexString(entropy.nextLong()));\n        }\n        count = entropy.nextInt(3);\n        List<Repository> repos = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            Repository r = Repository.newBuilder()\n                    .id(\"id\" + Long.toHexString(entropy.nextLong()))\n                    .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                    .url(\"url\" + Long.toHexString(entropy.nextLong()))\n                    .build();\n            repos.add(r);\n        }\n        count = entropy.nextInt(3);\n        List<Repository> pluginRepos = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            Repository r = Repository.newBuilder()\n                    .id(\"id\" + Long.toHexString(entropy.nextLong()))\n                    .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                    .url(\"url\" + Long.toHexString(entropy.nextLong()))\n                    .build();\n            pluginRepos.add(r);\n        }\n        Profile p = Profile.newBuilder()\n                .id(\"id\" + Long.toHexString(entropy.nextLong()))\n                .activation(a)\n                .properties(props)\n                .repositories(repos)\n                .pluginRepositories(pluginRepos)\n                .build();\n\n        Profile clone = SettingsUtilsV4.convertToSettingsProfile(SettingsUtilsV4.convertFromSettingsProfile(p));\n\n        assertEquals(p.getId(), clone.getId());\n        assertEquals(p.getActivation().getJdk(), clone.getActivation().getJdk());\n        assertEquals(\n                p.getActivation().getFile().getExists(),\n                clone.getActivation().getFile().getExists());\n        assertEquals(\n                p.getActivation().getFile().getMissing(),\n                clone.getActivation().getFile().getMissing());\n        assertEquals(\n                p.getActivation().getProperty().getName(),\n                clone.getActivation().getProperty().getName());\n        assertEquals(\n                p.getActivation().getProperty().getValue(),\n                clone.getActivation().getProperty().getValue());\n        assertEquals(\n                p.getActivation().getOs().getArch(),\n                clone.getActivation().getOs().getArch());\n        assertEquals(\n                p.getActivation().getOs().getFamily(),\n                clone.getActivation().getOs().getFamily());\n        assertEquals(\n                p.getActivation().getOs().getName(),\n                clone.getActivation().getOs().getName());\n        assertEquals(\n                p.getActivation().getOs().getVersion(),\n                clone.getActivation().getOs().getVersion());\n        assertEquals(p.getActivation().getPackaging(), clone.getActivation().getPackaging());\n        assertEquals(p.getProperties(), clone.getProperties());\n        assertEquals(p.getRepositories().size(), clone.getRepositories().size());\n        assertEquals(\n                p.getPluginRepositories().size(), clone.getPluginRepositories().size());\n    }",
    "comment": "TODO deep compare the lists\nTODO deep compare the lists"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/iterator/src/test/java/com/iluwatar/iterator/list/TreasureChestTest.java",
    "type": "method",
    "name": "dataProvider",
    "code": "public static List<Object[]> dataProvider() {\n    return List.of(\n        new Object[] {new Item(ItemType.POTION, \"Potion of courage\")},\n        new Object[] {new Item(ItemType.RING, \"Ring of shadows\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of wisdom\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of blood\")},\n        new Object[] {new Item(ItemType.WEAPON, \"Sword of silver +1\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of rust\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of healing\")},\n        new Object[] {new Item(ItemType.RING, \"Ring of armor\")},\n        new Object[] {new Item(ItemType.WEAPON, \"Steel halberd\")},\n        new Object[] {new Item(ItemType.WEAPON, \"Dagger of poison\")});\n\n  @ParameterizedTest\n  @MethodSource(\"dataProvider\")\n  void testIterator(Item expectedItem) {\n    final var chest = new TreasureChest();\n    final var iterator = chest.iterator(expectedItem.getType());\n    assertNotNull(iterator);\n\n    while (iterator.hasNext()) {\n      final var item = iterator.next();\n      assertNotNull(item);\n      assertEquals(expectedItem.getType(), item.getType());\n\n      final var name = item.toString();\n      assertNotNull(name);\n      if (expectedItem.toString().equals(name)) {\n        return;\n      }\n    }\n\n    fail(\"Expected to find item [\" + expectedItem + \"] using iterator, but we didn't.\");\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"dataProvider\")\n  void testGetItems(Item expectedItem) {\n    final var chest = new TreasureChest();\n    final var items = chest.getItems();\n    assertNotNull(items);\n\n    for (final var item : items) {\n      assertNotNull(item);\n      assertNotNull(item.getType());\n      assertNotNull(item.toString());\n\n      final var sameType = expectedItem.getType() == item.getType();\n      final var sameName = expectedItem.toString().equals(item.toString());\n      if (sameType && sameName) {\n        return;\n      }\n    }\n\n    fail(\"Expected to find item [\" + expectedItem + \"] in the item list, but we didn't.\");\n  }\n}",
    "comment": "Test if the expected item can be retrieved from the chest using the {@link\nTreasureChest#getItems()} method"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "addConstraint",
    "code": "static TableChange addConstraint(Constraint constraint, String validatedTableVersion) {\n    return new AddConstraint(constraint, validatedTableVersion);\n  }",
    "comment": "Create a TableChange for adding a new table constraint"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/LayeredOptions.java",
    "type": "method",
    "name": "LayeredOptions",
    "code": "protected LayeredOptions(List<O> options) {\n        this.options = new ArrayList<>(options);\n    }",
    "comment": "Options that are \"layered\" by precedence order.\n\n@param <O> The type of options."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isPublic",
    "code": "public static boolean isPublic(Class<?> clazz) {\n\t\treturn ReflectionUtils.isPublic(clazz);\n\t}",
    "comment": "Determine if the supplied class is {@code public}.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is {@code public}\n@see java.lang.reflect.Modifier#isPublic(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationSupport.java",
    "type": "method",
    "name": "if",
    "code": "final int collationId) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType && !collation.supportsSpaceTrimming) {\n        return execBinary(srcString, trimString);\n      }\n\n      if (collation.isUtf8BinaryType) {\n        return execBinaryTrim(srcString, trimString, collationId);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(srcString, trimString, collationId);\n      } else {\n        return execICU(srcString, trimString, collationId);\n      }\n    }",
    "comment": "special handling needed for utf8_binary_rtrim collation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/PlexusContainerCapsuleFactory.java",
    "type": "method",
    "name": "getCustomModule",
    "code": "protected Module getCustomModule(C context, CoreExports exports) {\n        return new AbstractModule() {\n        };\n    }",
    "comment": "Note: overriding this method should be avoided. Preferred way to replace Maven components is the \"normal\" way\nwhere the components are on index (are annotated with JSR330 annotations and Sisu index is created) and, they\nhave priorities set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/ring/RingMessageManager.java",
    "type": "method",
    "name": "sendHeartbeatInvokeMessage",
    "code": "public void sendHeartbeatInvokeMessage(int currentId) {\n    var nextInstance = this.findNextInstance(currentId);\n    var heartbeatInvokeMessage = new Message(MessageType.HEARTBEAT_INVOKE, \"\");\n    nextInstance.onMessage(heartbeatInvokeMessage);\n  }",
    "comment": "Send heartbeat invoke message to the next instance.\n\n@param currentId Instance ID of which sends this message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "DropConstraint",
    "code": "private DropConstraint(String name, boolean ifExists, Mode mode) {\n      this.name = name;\n      this.ifExists = ifExists;\n      this.mode = mode;\n    }",
    "comment": "Defines modes for dropping a constraint.\n<p>\nRESTRICT - Prevents dropping a constraint if it is referenced by other objects.\nCASCADE - Automatically drops objects that depend on the constraint."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/EngineFilter.java",
    "type": "method",
    "name": "includeEngines",
    "code": "public static EngineFilter includeEngines(List<String> engineIds) {\n\t\treturn new EngineFilter(engineIds, Type.INCLUDE);\n\t}",
    "comment": "Create a new <em>include</em> {@code EngineFilter} based on the\n<em>included</em> within the test discovery and execution.\n\n@param engineIds the list of engine IDs to match against; never {@code null}\nor empty; individual IDs must also not be null or blank\n@see #includeEngines(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertNotEqualsAssertionsTests.java",
    "type": "method",
    "name": "assertNotEqualsByte",
    "code": "void assertNotEqualsByte() {\n\t\t\tbyte unexpected = 1;\n\t\t\tbyte actual = 2;\n\t\t\tassertNotEquals(unexpected, actual);\n\t\t\tassertNotEquals(unexpected, actual, \"message\");\n\t\t\tassertNotEquals(unexpected, actual, () -> \"message\");\n\t\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/streaming/JavaStructuredComplexSessionization.java",
    "type": "method",
    "name": "mergeSessions",
    "code": "private void mergeSessions(List<SessionAcc> sessionAccs, GroupState<Sessions> state) {\n\n            int curIdx = 0;\n            while (curIdx < sessionAccs.size() - 1) {\n              SessionAcc curSession = sessionAccs.get(curIdx);\n              SessionAcc nextSession = sessionAccs.get(curIdx + 1);\n\n              if (curSession.endTime().getTime() > nextSession.startTime().getTime()) {\n                List<SessionEvent> accumulatedEvents = new ArrayList<>(curSession.getEvents());\n                accumulatedEvents.addAll(nextSession.getEvents());\n                accumulatedEvents.sort(\n                    Comparator.comparingLong(e -> e.getStartTimestamp().getTime()));\n\n                List<SessionAcc> newSessions = new ArrayList<>();\n                List<SessionEvent> eventsForCurSession = new ArrayList<>();\n                for (SessionEvent event : accumulatedEvents) {\n                  eventsForCurSession.add(event);\n                  if (event.eventType == EventTypes.CLOSE_SESSION) {\n                    SessionAcc newSessionAcc = SessionAcc.newInstance(eventsForCurSession);\n                    newSessions.add(newSessionAcc);\n                    eventsForCurSession = new ArrayList<>();\n                  }\n                }\n                if (!eventsForCurSession.isEmpty()) {\n                  SessionAcc newSessionAcc = SessionAcc.newInstance(eventsForCurSession);\n                  newSessions.add(newSessionAcc);\n                }\n\n                sessionAccs.remove(curIdx + 1);\n                sessionAccs.set(curIdx, newSessions.get(0));\n                if (newSessions.size() > 1) {\n                  sessionAccs.addAll(curIdx + 1,\n                      newSessions.stream().skip(1).collect(Collectors.toList()));\n                }\n\n                curIdx += newSessions.size() - 1;\n              } else {\n                curIdx++;\n              }\n            }\n\n            state.update(Sessions.newInstance(sessionAccs));\n          }",
    "comment": "we sorted sessionAccs by timestamp\nCurrent session and next session can be merged\nreplace current session and next session with new session(s)\nmove the cursor to the last new session(s)\nmove to the next session\nupdate state"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestInstanceFactoryTests.java",
    "type": "method",
    "name": "createTestInstance",
    "code": "public Object createTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext extensionContext) {\n\t\t\treturn \"bogus\";\n\t\t}",
    "comment": "{@link TestInstanceFactory} that returns an object of a type that does\nnot match the supplied test class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(short unexpected, short actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java",
    "type": "method",
    "name": "runChild",
    "code": "protected void runChild(final FrameworkMethod method, RunNotifier notifier) {\n        Description description = describeChild(method);\n        if (isIgnored(method)) {\n            notifier.fireTestIgnored(description);\n        } else {\n            Statement statement = new Statement() {\n            };\n            runLeaf(statement, description, notifier);\n        }\n    }",
    "comment": "Creates a BlockJUnit4ClassRunner to run {@code testClass}.\n\n@throws InitializationError if the test class is malformed.\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "parse",
    "code": "public static Optional<? extends DiscoverySelector> parse(String identifier) {\n\t\treturn DiscoverySelectorIdentifierParsers.parse(identifier);\n\t}",
    "comment": "Parse the supplied string representation of a {@link DiscoverySelectorIdentifier}.\n\n@param identifier the string representation of a {@code DiscoverySelectorIdentifier};\nnever {@code null} or blank\n@return an {@link Optional} containing the corresponding {@link DiscoverySelector};\nnever {@code null} but potentially empty\n@since 1.11\n@see DiscoverySelectorIdentifierParser"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/testkit/engine/ExecutionsIntegrationTests.java",
    "type": "method",
    "name": "executionsFromSucceededTestEvents",
    "code": "void executionsFromSucceededTestEvents() {\n\t\tvar testEvents = getTestEvents();\n\n\t\tassertThat(testEvents.executions().succeeded().count()).isEqualTo(1);\n\t\tassertThat(testEvents.succeeded().executions().count()).isEqualTo(0);\n\t}",
    "comment": "We expect 1 if the executions are created BEFORE filtering out \"finished\" events.\nWe expect 0 if the executions are created AFTER filtering out \"finished\" events."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/LookupInvoker.java",
    "type": "method",
    "name": "createLocalArtifactRepository",
    "code": "private ArtifactRepository createLocalArtifactRepository(Path baseDirectory) {\n        DefaultRepositoryLayout layout = new DefaultRepositoryLayout();\n        ArtifactRepositoryPolicy blah = new ArtifactRepositoryPolicy(\n                true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE);\n        return new MavenArtifactRepository(\n                \"local\", \"file://\" + baseDirectory.toUri().getRawPath(), layout, blah, blah);\n    }",
    "comment": "TODO: get rid of this!!!"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TemporaryFolder.java",
    "type": "method",
    "name": "assureDeletion",
    "code": "public Builder assureDeletion() {\n            this.assureDeletion = true;\n            return this;\n        }",
    "comment": "Setting this flag assures that no resources are left undeleted. Failure\nto fulfill the assurance results in failure of tests with an\n{@link AssertionError}.\n\n@return this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/model/MavenModelMergerTest.java",
    "type": "method",
    "name": "testMergeModelModelVersion",
    "code": "void testMergeModelModelVersion() {\n        Model parent = Model.newBuilder().modelVersion(\"4.0.0\").build();\n        Model model = Model.newInstance();\n        Model.Builder builder = Model.newBuilder(model);\n        modelMerger.mergeModel_ModelVersion(builder, model, parent, false, null);\n        assertNull(builder.build().getModelVersion());\n\n        model = Model.newBuilder().modelVersion(\"5.0.0\").build();\n        builder = Model.newBuilder(model);\n        modelMerger.mergeModel_ModelVersion(builder, model, parent, false, null);\n        assertEquals(\"5.0.0\", builder.build().getModelVersion());\n    }",
    "comment": "modelVersion is neither inherited nor injected"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java21/example/DynamicTestsNamedDemo.java",
    "type": "method",
    "name": "dynamicTestsFromStreamFactoryMethodWithNames",
    "code": "Stream<DynamicTest> dynamicTestsFromStreamFactoryMethodWithNames() {\n\t\tvar inputStream = Stream.of(\n\t\t\tnamed(\"racecar is a palindrome\", \"racecar\"),\n\t\t\tnamed(\"radar is also a palindrome\", \"radar\"),\n\t\t\tnamed(\"mom also seems to be a palindrome\", \"mom\"),\n\t\t\tnamed(\"dad is yet another palindrome\", \"dad\")\n\t\t);\n\n\t\treturn DynamicTest.stream(inputStream, text -> assertTrue(isPalindrome(text)));\n\t}",
    "comment": "tag::user_guide[]\nStream of palindromes to check\nend::user_guide[]\n@formatter:off\ntag::user_guide[]\nend::user_guide[]\n@formatter:on\ntag::user_guide[]\nReturns a stream of dynamic tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlan.java",
    "type": "method",
    "name": "merge",
    "code": "private Map<String, BuildStep> merge(Map<String, BuildStep> org, Map<String, BuildStep> add) {\n        List<BuildStep> lasts =\n                org.values().stream().filter(b -> b.successors.isEmpty()).toList();\n        List<BuildStep> firsts =\n                add.values().stream().filter(b -> b.predecessors.isEmpty()).toList();\n        firsts.stream()\n                .filter(addNode -> !org.containsKey(addNode.name))\n                .forEach(addNode -> lasts.forEach(orgNode -> addNode.executeAfter(orgNode)));\n        add.forEach((name, node) -> org.merge(name, node, this::merge));\n        return org;\n    }",
    "comment": "all new phases should be added after the existing ones"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "a",
    "code": "default MessageBuilder a(CharSequence value) {\n        return append(value);\n    }",
    "comment": "Append content to the message buffer.\n\n@param value the content to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/SavedModelBundle.java",
    "type": "method",
    "name": "withConfigProto",
    "code": "public Loader withConfigProto(byte[] configProto) {\n      this.configProto = configProto;\n      return this;\n    }",
    "comment": "Set configuration of the <code>Session</code> object created when loading the model.\n\n@param configProto Serialized <a\nhref=\"https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto\">ConfigProto\nprotocol buffer</a>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java",
    "type": "method",
    "name": "runJsonDatasetExample",
    "code": "private static void runJsonDatasetExample(SparkSession spark) {\n    Dataset<Row> people = spark.read().json(\"examples/src/main/resources/people.json\");\n\n    people.printSchema();\n\n    people.createOrReplaceTempView(\"people\");\n\n    Dataset<Row> namesDF = spark.sql(\"SELECT name FROM people WHERE age BETWEEN 13 AND 19\");\n    namesDF.show();\n\n    List<String> jsonData = Arrays.asList(\n            \"{\\\"name\\\":\\\"Yin\\\",\\\"address\\\":{\\\"city\\\":\\\"Columbus\\\",\\\"state\\\":\\\"Ohio\\\"}}\");\n    Dataset<String> anotherPeopleDataset = spark.createDataset(jsonData, Encoders.STRING());\n    Dataset<Row> anotherPeople = spark.read().json(anotherPeopleDataset);\n    anotherPeople.show();\n  }",
    "comment": "$example on:json_dataset$\nA JSON dataset is pointed to by path.\nThe path can be either a single text file or a directory storing text files\nThe inferred schema can be visualized using the printSchema() method\nroot\n|-- age: long (nullable = true)\n|-- name: string (nullable = true)\nCreates a temporary view using the DataFrame\nSQL statements can be run by using the sql methods provided by spark\n+------+\n|  name|\n+------+\n|Justin|\n+------+\nAlternatively, a DataFrame can be created for a JSON dataset represented by\na Dataset<String> storing one JSON object per string.\n+---------------+----+\n|        address|name|\n+---------------+----+\n|[Columbus,Ohio]| Yin|\n+---------------+----+\n$example off:json_dataset$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "configurationParameter",
    "code": "public SuiteLauncherDiscoveryRequestBuilder configurationParameter(String key, String value) {\n\t\tthis.delegate.configurationParameter(key, value);\n\t\treturn this;\n\t}",
    "comment": "Add the supplied <em>configuration parameter</em> to the request.\n\n@param key the configuration parameter key under which to store the\nvalue; never {@code null} or blank\n@param value the value to store\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Stopwatch.java",
    "type": "method",
    "name": "runtime",
    "code": "public long runtime(TimeUnit unit) {\n        return unit.convert(getNanos(), TimeUnit.NANOSECONDS);\n    }",
    "comment": "Gets the runtime for the test.\n\n@param unit time unit for returned runtime\n@return runtime measured during the test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/CLIReportingUtils.java",
    "type": "method",
    "name": "showVersion",
    "code": "public static String showVersion(String commandLine, String terminal) {\n        final String ls = System.lineSeparator();\n        Properties properties = getBuildProperties();\n        StringBuilder version = new StringBuilder(256);\n        version.append(MessageUtils.builder().strong(createMavenVersionString(properties)))\n                .append(ls);\n        version.append(reduce(properties.getProperty(\"distributionShortName\") + \" home: \"\n                        + System.getProperty(\"maven.home\", \"<unknown Maven \" + \"home>\")))\n                .append(ls);\n        version.append(\"Java version: \")\n                .append(System.getProperty(\"java.version\", \"<unknown Java version>\"))\n                .append(\", vendor: \")\n                .append(System.getProperty(\"java.vendor\", \"<unknown vendor>\"))\n                .append(\", runtime: \")\n                .append(System.getProperty(\"java.home\", \"<unknown runtime>\"))\n                .append(ls);\n        version.append(\"Default locale: \")\n                .append(Locale.getDefault())\n                .append(\", platform encoding: \")\n                .append(System.getProperty(\"file.encoding\", \"<unknown encoding>\"))\n                .append(ls);\n        version.append(\"OS name: \\\"\")\n                .append(Os.OS_NAME)\n                .append(\"\\\", version: \\\"\")\n                .append(Os.OS_VERSION)\n                .append(\"\\\", arch: \\\"\")\n                .append(Os.OS_ARCH)\n                .append(\"\\\", family: \\\"\")\n                .append(Os.OS_FAMILY)\n                .append('\\\"');\n        if (commandLine != null) {\n            version.append(ls).append(\"Command line: \").append(commandLine);\n        }\n        if (terminal != null) {\n            version.append(ls).append(\"Terminal: \").append(terminal);\n        }\n        return version.toString();\n    }",
    "comment": "Add process information using modern Java API"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "findAllResourcesInModule",
    "code": "public static List<Resource> findAllResourcesInModule(String moduleName, Predicate<Resource> resourceFilter) {\n\t\treturn ReflectionUtils.findAllResourcesInModule(moduleName, resourceFilter);\n\t}",
    "comment": "Find all {@linkplain Resource resources} in the supplied {@code moduleName}\nthat match the specified {@code resourceFilter} predicate.\n\n<p>The module-path scanning algorithm searches recursively in all\npackages contained in the module.\n\n@param moduleName the name of the module to scan; never {@code null} or\n<em>empty</em>\n@param resourceFilter the resource type filter; never {@code null}\n@return an immutable list of all such resources found; never {@code null}\nbut potentially empty\n@since 1.11\n@see #findAllResourcesInClasspathRoot(URI, Predicate)\n@see #findAllResourcesInPackage(String, Predicate)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/JavaAPISuite.java",
    "type": "method",
    "name": "testQueueStream",
    "code": "public void testQueueStream() {\n    ssc.stop();\n    SparkConf conf = new SparkConf()\n        .setMaster(\"local[2]\")\n        .setAppName(\"test\")\n        .set(\"spark.streaming.clock\", \"org.apache.spark.util.ManualClock\");\n    ssc = new JavaStreamingContext(conf, new Duration(1000));\n\n    List<List<Integer>> expected = Arrays.asList(\n        Arrays.asList(1,2,3),\n        Arrays.asList(4,5,6),\n        Arrays.asList(7,8,9));\n\n    JavaSparkContext jsc = new JavaSparkContext(ssc.ssc().sc());\n    JavaRDD<Integer> rdd1 = jsc.parallelize(Arrays.asList(1, 2, 3));\n    JavaRDD<Integer> rdd2 = jsc.parallelize(Arrays.asList(4, 5, 6));\n    JavaRDD<Integer> rdd3 = jsc.parallelize(Arrays.asList(7,8,9));\n\n    Queue<JavaRDD<Integer>> rdds = new LinkedList<>();\n    rdds.add(rdd1);\n    rdds.add(rdd2);\n    rdds.add(rdd3);\n\n    JavaDStream<Integer> stream = ssc.queueStream(rdds);\n    JavaTestUtils.attachTestOutputStream(stream);\n    List<List<Integer>> result = JavaTestUtils.runStreams(ssc, 3, 3);\n    Assertions.assertEquals(expected, result);\n  }",
    "comment": "Create a new JavaStreamingContext without checkpointing"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/main/java/com/iluwatar/circuitbreaker/DefaultCircuitBreaker.java",
    "type": "method",
    "name": "evaluateState",
    "code": "protected void evaluateState() {\n    if (failureCount >= failureThreshold) { // Then something is wrong with remote service\n      if ((System.nanoTime() - lastFailureTime) > retryTimePeriod) {\n        state = State.HALF_OPEN;\n      } else {\n        state = State.OPEN;\n      }\n    } else {\n      state = State.CLOSED;\n    }\n  }",
    "comment": "Evaluate the current state based on failureThreshold, failureCount and lastFailureTime.\nWe have waited long enough and should try checking if service is up\nService would still probably be down\nEverything is working fine"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "failures",
    "code": "public synchronized Enumeration<TestFailure> failures() {\n        return Collections.enumeration(fFailures);\n    }",
    "comment": "Returns an Enumeration for the failures."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java",
    "type": "method",
    "name": "comparableQualifier",
    "code": "public static String comparableQualifier(String qualifier) {\n            if (RELEASE_QUALIFIERS.contains(qualifier)) {\n                return String.valueOf(QUALIFIERS.indexOf(\"\"));\n            }\n\n            int i = QUALIFIERS.indexOf(qualifier);\n\n            // Just returning an Integer with the index here is faster, but requires a lot of if/then/else to check for\n            // -1\n            //  or QUALIFIERS.size and then resort to lexical ordering. Most comparisons are decided by the first\n            // character,\n            // so this is still fast. If more characters are needed then it requires a lexical sort anyway.\n            return i == -1 ? (QUALIFIERS.size() + \"-\" + qualifier) : String.valueOf(i);\n        }",
    "comment": "Returns a comparable value for a qualifier.\n<p>\nThis method takes into account the ordering of known qualifiers then unknown qualifiers with lexical\nordering.\n<p>\n\n@param qualifier\n@return an equivalent value that can be used with lexical comparison"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "setClassRealm",
    "code": "public void setClassRealm(ClassRealm classRealm) {\n        this.classRealm = classRealm;\n    }",
    "comment": "Sets the project's class realm. <strong>Warning:</strong> This is an internal utility method that is only public\nfor technical reasons, it is not part of the public API. In particular, this method can be changed or deleted\nwithout prior notice and must not be used by plugins.\n\n@param classRealm The class realm hosting the build extensions of this project, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/injection/sample/DoubleParameterResolver.java",
    "type": "method",
    "name": "supportsParameter",
    "code": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn parameterContext.getParameter().getType() == Double.class;\n\t}",
    "comment": "Example {@link ParameterResolver} that always resolves a {@link Double}\nparameter to {@code 42.0}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/ArtifactResolutionResult.java",
    "type": "method",
    "name": "hasMetadataResolutionExceptions",
    "code": "public boolean hasMetadataResolutionExceptions() {\n        return metadataResolutionExceptions != null;\n    }",
    "comment": "------------------------------------------------------------------------\nMetadata Resolution Exceptions: ArtifactResolutionExceptions\n------------------------------------------------------------------------"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/composite-entity/src/test/java/com/iluwatar/compositeentity/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertThat",
    "code": "public static <T> void assertThat(T actual, Matcher<? super T> matcher) {\n        assertThat(\"\", actual, matcher);\n    }",
    "comment": "Asserts that <code>actual</code> satisfies the condition specified by\n<code>matcher</code>. If not, an {@link AssertionError} is thrown with\ninformation about the matcher and failing value. Example:\n\n<pre>\nassertThat(0, is(1)); // fails:\n// failure message:\n// expected: is &lt;1&gt;\n// got value: &lt;0&gt;\nassertThat(0, is(not(1))) // passes\n</pre>\n\n<code>org.hamcrest.Matcher</code> does not currently document the meaning\nof its type parameter <code>T</code>.  This method assumes that a matcher\ntyped as <code>Matcher&lt;T&gt;</code> can be meaningfully applied only\nto values that could be assigned to a variable of type <code>T</code>.\n\n@param <T> the static type accepted by the matcher (this can flag obvious\ncompile-time problems such as {@code assertThat(1, is(\"a\"))}\n@param actual the computed value being compared\n@param matcher an expression, built of {@link Matcher}s, specifying allowed\nvalues\n@see org.hamcrest.CoreMatchers\n@deprecated use {@code org.hamcrest.MatcherAssert.assertThat()}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/app/AppClient.java",
    "type": "method",
    "name": "TcpLoggingClient",
    "code": "public TcpLoggingClient(String clientName, int serverPort) {\n      this.clientName = clientName;\n      this.serverPort = serverPort;\n    }",
    "comment": "Creates a new TCP logging client.\n\n@param clientName the name of the client to be sent in logging requests.\n@param serverPort the port on which client will send logging requests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/CommonsCliOptions.java",
    "type": "method",
    "name": "prepareOptions",
    "code": "protected void prepareOptions(org.apache.commons.cli.Options options) {\n            options.addOption(Option.builder(HELP)\n                    .longOpt(\"help\")\n                    .desc(\"Display help information\")\n                    .build());\n            options.addOption(Option.builder(USER_PROPERTY)\n                    .numberOfArgs(2)\n                    .valueSeparator('=')\n                    .desc(\"Define a user property\")\n                    .build());\n            options.addOption(Option.builder(SHOW_VERSION_AND_EXIT)\n                    .longOpt(\"version\")\n                    .desc(\"Display version information\")\n                    .build());\n            options.addOption(Option.builder(QUIET)\n                    .longOpt(\"quiet\")\n                    .desc(\"Quiet output - only show errors\")\n                    .build());\n            options.addOption(Option.builder(VERBOSE)\n                    .longOpt(\"verbose\")\n                    .desc(\"Produce execution verbose output\")\n                    .build());\n            options.addOption(Option.builder(SHOW_ERRORS)\n                    .longOpt(\"errors\")\n                    .desc(\"Produce execution error messages\")\n                    .build());\n            options.addOption(Option.builder(BATCH_MODE)\n                    .longOpt(\"batch-mode\")\n                    .desc(\"Run in non-interactive mode. Alias for --non-interactive (kept for backwards compatability)\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(NON_INTERACTIVE)\n                    .desc(\"Run in non-interactive mode. Alias for --batch-mode\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(FORCE_INTERACTIVE)\n                    .desc(\n                            \"Run in interactive mode. Overrides, if applicable, the CI environment variable and --non-interactive/--batch-mode options\")\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_USER_SETTINGS)\n                    .longOpt(\"settings\")\n                    .desc(\"Alternate path for the user settings file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_PROJECT_SETTINGS)\n                    .longOpt(\"project-settings\")\n                    .desc(\"Alternate path for the project settings file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_INSTALLATION_SETTINGS)\n                    .longOpt(\"install-settings\")\n                    .desc(\"Alternate path for the installation settings file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_USER_TOOLCHAINS)\n                    .longOpt(\"toolchains\")\n                    .desc(\"Alternate path for the user toolchains file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_INSTALLATION_TOOLCHAINS)\n                    .longOpt(\"install-toolchains\")\n                    .desc(\"Alternate path for the installation toolchains file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(FAIL_ON_SEVERITY)\n                    .longOpt(\"fail-on-severity\")\n                    .desc(\"Configure which severity of logging should cause the build to fail\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(LOG_FILE)\n                    .longOpt(\"log-file\")\n                    .hasArg()\n                    .desc(\"Log file where all build output will go (disables output color)\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(RAW_STREAMS)\n                    .desc(\"Do not decorate standard output and error streams\")\n                    .build());\n            options.addOption(Option.builder(SHOW_VERSION)\n                    .longOpt(\"show-version\")\n                    .desc(\"Display version information WITHOUT stopping build\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(COLOR)\n                    .hasArg()\n                    .optionalArg(true)\n                    .desc(\"Defines the color mode of the output. Supported are 'auto', 'always', 'never'.\")\n                    .build());\n            options.addOption(Option.builder(OFFLINE)\n                    .longOpt(\"offline\")\n                    .desc(\"Work offline\")\n                    .build());\n\n            options.addOption(Option.builder()\n                    .longOpt(DEBUG)\n                    .desc(\"Launch the JVM in debug mode (script option).\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(ENC)\n                    .desc(\"Launch the Maven Encryption tool (script option).\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(SHELL)\n                    .desc(\"Launch the Maven Shell tool (script option).\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(YJP)\n                    .desc(\"Launch the JVM with Yourkit profiler (script option).\")\n                    .build());\n\n            options.addOption(Option.builder(ALTERNATE_GLOBAL_SETTINGS)\n                    .longOpt(\"global-settings\")\n                    .desc(\"<deprecated> Alternate path for the global settings file.\")\n                    .hasArg()\n                    .deprecated(DeprecatedAttributes.builder()\n                            .setForRemoval(true)\n                            .setSince(\"4.0.0\")\n                            .setDescription(\"Use -is,--install-settings instead.\")\n                            .get())\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_GLOBAL_TOOLCHAINS)\n                    .longOpt(\"global-toolchains\")\n                    .desc(\"<deprecated> Alternate path for the global toolchains file.\")\n                    .hasArg()\n                    .deprecated(DeprecatedAttributes.builder()\n                            .setForRemoval(true)\n                            .setSince(\"4.0.0\")\n                            .setDescription(\"Use -it,--install-toolchains instead.\")\n                            .get())\n                    .build());\n        }",
    "comment": "Parameters handled by script\nDeprecated"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/ReactorModelPool.java",
    "type": "method",
    "name": "get",
    "code": "public File get(String groupId, String artifactId, String version) {\n        return pomFiles.get(new CacheKey(groupId, artifactId, version));\n    }",
    "comment": "Holds all POM files that are known to the reactor. This allows the project builder to resolve imported POMs from the\nreactor when building another project's effective model."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/migrationsupport/rules/ExternalResourceSupportForMixedMethodAndFieldRulesTests.java",
    "type": "method",
    "name": "afterMethodsOfAllRulesWereExecuted",
    "code": "static void afterMethodsOfAllRulesWereExecuted() {\n\t\tif (!asList(initEvents.get(2), initEvents.get(3), initEvents.get(0), initEvents.get(1)).equals(afterEvents))\n\t\t\tfail();\n\t}",
    "comment": "beforeEach methods of rules from methods are run before those from fields but in reverse order"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/AbstractExtensionContext.java",
    "type": "method",
    "name": "getStore",
    "code": "public Store getStore(StoreScope scope, Namespace namespace) {\n\t\tswitch (scope) {\n\t\t\tcase LAUNCHER_SESSION:\n\t\t\t\treturn launcherStoreFacade.getSessionLevelStore(namespace);\n\t\t\tcase EXECUTION_REQUEST:\n\t\t\t\treturn launcherStoreFacade.getRequestLevelStore(namespace);\n\t\t\tcase EXTENSION_CONTEXT:\n\t\t\t\treturn getStore(namespace);\n\t\t}\n\t\tthrow new JUnitException(\"Unknown StoreScope: \" + scope);\n\t}",
    "comment": "TODO [#4246] Use switch expression"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expressions.java",
    "type": "method",
    "name": "apply",
    "code": "public static Transform apply(String name, Expression... args) {\n    return LogicalExpressions.apply(name,\n        CollectionConverters.asScala(Arrays.asList(args)).toSeq());\n  }",
    "comment": "Create a logical transform for applying a named transform.\n<p>\nThis transform can represent applying any named transform.\n\n@param name the transform name\n@param args expression arguments to the transform\n@return a logical transform"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom2/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "updateAndGetUser",
    "code": "public void updateAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        User updatedUser = new User(USER.getId(), \"new username\", USER.getDate());\n        mDataSource.insertOrUpdateUser(updatedUser);\n\n        User dbUser = mDataSource.getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), \"new username\");\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are updating the name of the user\nThe retrieved user has the updated username"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/test/java/com/example/android/observability/UserViewModelTest.java",
    "type": "method",
    "name": "getUserName_whenUserSaved",
    "code": "public void getUserName_whenUserSaved() {\n        User user = new User(\"user name\");\n        when(mDataSource.getUser()).thenReturn(Flowable.just(user));\n\n        mViewModel.getUserName()\n                .test()\n                .assertValue(\"user name\");\n    }",
    "comment": "Given that the UserDataSource returns a user\nWhen getting the user name\nThe correct user name is emitted"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ShuffleIndexInformation.java",
    "type": "method",
    "name": "getIndex",
    "code": "public ShuffleIndexRecord getIndex(int startReduceId, int endReduceId) {\n    long offset = offsets.get(startReduceId);\n    long nextOffset = offsets.get(endReduceId);\n    return new ShuffleIndexRecord(offset, nextOffset - offset);\n  }",
    "comment": "Get index offset for the reducer range of [startReduceId, endReduceId)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java",
    "type": "method",
    "name": "findMethodsDoesNotReturnOverriddenMethods",
    "code": "void findMethodsDoesNotReturnOverriddenMethods() {\n\t\t\tPredicate<Method> isSpecial = method -> method.isAnnotationPresent(Special.class);\n\n\t\t\t// Search for all @Special methods.\n\t\t\tvar methods = findMethods(SuperclassWithInstanceMethods.class, isSpecial);\n\n\t\t\tassertThat(signaturesOf(methods))//\n\t\t\t\t\t.containsExactlyInAnyOrder(\"specialFoo()\", \"specialFoo(int)\", \"specialFoo(char)\", \"specialBar()\",\n\t\t\t\t\t\t\"specialBaz()\");\n\n\t\t\t// Search for all @Special methods.\n\t\t\tmethods = findMethods(SubclassWithOverriddenInstanceMethods.class, isSpecial);\n\n\t\t\tassertThat(signaturesOf(methods))//\n\t\t\t\t\t.containsExactlyInAnyOrder(\"foo()\", \"specialFoo()\", \"specialFoo(int)\", \"specialBar()\");\n\t\t}",
    "comment": "In legacy mode, \"static hiding\" occurs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/ExpressionImplUtils.java",
    "type": "method",
    "name": "isLuhnNumber",
    "code": "public static boolean isLuhnNumber(UTF8String numberString) {\n    String digits = numberString.toString();\n    // Empty string is not a valid Luhn number.\n    if (digits.isEmpty()) return false;\n    int checkSum = 0;\n    boolean isSecond = false;\n    for (int i = digits.length() - 1; i >= 0; i--) {\n      char ch = digits.charAt(i);\n      if (!Character.isDigit(ch)) return false;\n\n      int digit = Character.getNumericValue(ch);\n      // Double the digit if it's the second digit in the sequence.\n      int doubled = isSecond ? digit * 2 : digit;\n      // Add the two digits of the doubled number to the sum.\n      checkSum += doubled % 10 + doubled / 10;\n      // Toggle the isSecond flag for the next iteration.\n      isSecond = !isSecond;\n    }\n    // Check if the final sum is divisible by 10.\n    return checkSum % 10 == 0;\n  }",
    "comment": "Function to check if a given number string is a valid Luhn number\n@param numberString\nthe number string to check\n@return\ntrue if the number string is a valid Luhn number, false otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "addDelegates",
    "code": "private void addDelegates(InterpreterImpl.Options options) {\n    if (originalGraphHasUnresolvedFlexOp) {\n      Delegate optionalFlexDelegate = maybeCreateFlexDelegate(options.getDelegates());\n      if (optionalFlexDelegate != null) {\n        ownedDelegates.add(optionalFlexDelegate);\n        delegates.add(optionalFlexDelegate);\n      }\n    }\n    addUserProvidedDelegates(options);\n    for (DelegateFactory delegateFactory : options.getDelegateFactories()) {\n      Delegate delegate = delegateFactory.create(RUNTIME_FLAVOR);\n      ownedDelegates.add(delegate);\n      delegates.add(delegate);\n    }\n    if (options.getUseNNAPI()) {\n      NnApiDelegate optionalNnApiDelegate = new NnApiDelegate();\n      ownedDelegates.add(optionalNnApiDelegate);\n      delegates.add(optionalNnApiDelegate);\n    }\n  }",
    "comment": "Add all the delegates specified in the options (other than XNNPACK) to this.delegates.\nFirst add the flex delegate if necessary. This ensures the graph is fully resolved before\napplying other delegates.\nNow add the user-supplied delegates."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/InMemoryProductRepository.java",
    "type": "method",
    "name": "InMemoryProductRepository",
    "code": "public InMemoryProductRepository() {\n    products.put(\"1\", new Product(\"1\", \"Laptop\", LAPTOP_PRICE));\n    products.put(\"2\", new Product(\"2\", \"Smartphone\", SMARTPHONE_PRICE));\n  }",
    "comment": "Constructs an {@code InMemoryProductRepository} and initializes it with some example products."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/feature/Features.java",
    "type": "method",
    "name": "consumerPom",
    "code": "public static boolean consumerPom(@Nullable Map<String, String> userProperties, boolean def) {\n        return doGet(userProperties, Constants.MAVEN_CONSUMER_POM, def);\n    }",
    "comment": "Check if the consumer POM feature is active."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/object-mother/src/main/java/com/iluwatar/objectmother/RoyaltyObjectMother.java",
    "type": "method",
    "name": "createFlirtyQueen",
    "code": "public static Queen createFlirtyQueen() {\n    var queen = new Queen();\n    queen.setFlirtiness(true);\n    return queen;\n  }",
    "comment": "Method to create a flirty queen.\n\n@return A flirty {@link com.iluwatar.objectmother.Queen}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/InMemoryCartRepository.java",
    "type": "method",
    "name": "calculateTotal",
    "code": "public double calculateTotal(final String userId) {\n    return userCarts.getOrDefault(userId, new ArrayList<>()).stream()\n        .mapToDouble(Cart::getTotalPrice)\n        .sum();\n  }",
    "comment": "Calculates the total price of items in the user's cart.\n\n@param userId The ID of the user.\n@return The total price of the cart."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultSourceRoot.java",
    "type": "method",
    "name": "equals",
    "code": "public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof DefaultSourceRoot other) {\n            return directory.equals(other.directory)\n                    && includes.equals(other.includes)\n                    && excludes.equals(other.excludes)\n                    && Objects.equals(scope, other.scope)\n                    && Objects.equals(language, other.language)\n                    && Objects.equals(moduleName, other.moduleName)\n                    && Objects.equals(targetVersion, other.targetVersion)\n                    && stringFiltering == other.stringFiltering\n                    && enabled == other.enabled;\n        }\n        return false;\n    }",
    "comment": "{@return whether the two objects are of the same class with equal property values}.\n\n@param obj the other object to compare with this object, or {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "removeProperty",
    "code": "static TableChange removeProperty(String property) {\n    return new RemoveProperty(property);\n  }",
    "comment": "Create a TableChange for removing a table property.\n<p>\nIf the property does not exist, the change will succeed.\n\n@param property the property name\n@return a TableChange for the addition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/UsingTheLauncherDemo.java",
    "type": "method",
    "name": "execution",
    "code": "void execution() {\n\t\tLauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()\n\t\t\t.selectors(\n\t\t\t\tselectPackage(\"com.example.mytests\"),\n\t\t\t\tselectClass(MyTestClass.class)\n\t\t\t)\n\t\t\t.filters(\n\t\t\t\tincludeClassNamePatterns(\".*Tests\")\n\t\t\t)\n\t\t\t.configurationParameter(\"enableHttpServer\", \"false\")\n\t\t\t.build();\n\n\t\tSummaryGeneratingListener listener = new SummaryGeneratingListener();\n\n\t\ttry (LauncherSession session = LauncherFactory.openSession()) {\n\t\t\tLauncher launcher = session.getLauncher();\n\t\t\tlauncher.registerTestExecutionListeners(listener);\n\t\t\tTestPlan testPlan = launcher.discover(request);\n\t\t\tlauncher.execute(testPlan);\n\t\t\tlauncher.execute(request);\n\t\t}\n\n\t\tTestExecutionSummary summary = listener.getSummary();\n\n\t}",
    "comment": "@formatter:off\ntag::execution[]\nend::execution[]\ntag::execution[]\nRegister a listener of your choice\nDiscover tests and build a test plan\nExecute test plan\nAlternatively, execute the request directly\nDo something with the summary...\nend::execution[]\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/SupportsPushDownLimit.java",
    "type": "method",
    "name": "isPartiallyPushed",
    "code": "default boolean isPartiallyPushed() { return true; }\n}",
    "comment": "Whether the LIMIT is partially pushed or not. If it returns true, then Spark will do LIMIT\nagain. This method will only be called when {@link #pushLimit} returns true."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3723ConcreteParentProjectTest.java",
    "type": "method",
    "name": "MavenITmng3723ConcreteParentProjectTest",
    "code": "public MavenITmng3723ConcreteParentProjectTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3723\">MNG-3723</a>.\n\nTests that the parent MavenProject instance of the current project has been\ntransitioned into a concrete state before a mojo is executed. If this is true,\nthen injecting ${project} into the mojo and traversing to project.getParent().getBasedir()\nshould retrieve a File instance that is interpolated and exists (since we're\ngoing to be using a parent-child project set in the projects directory).\n\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryResultValidator.java",
    "type": "method",
    "name": "validate",
    "code": "void validate(TestEngine testEngine, TestDescriptor root) {\n\t\tPreconditions.notNull(root,\n\t\t\t() -> String.format(\n\t\t\t\t\"The discover() method for TestEngine with ID '%s' must return a non-null root TestDescriptor.\",\n\t\t\t\ttestEngine.getId()));\n\t\tOptional<String> cyclicGraphInfo = getCyclicGraphInfo(root);\n\t\tPreconditions.condition(!cyclicGraphInfo.isPresent(),\n\t\t\t() -> String.format(\"The discover() method for TestEngine with ID '%s' returned a cyclic graph; %s\",\n\t\t\t\ttestEngine.getId(), cyclicGraphInfo.get()));\n\t}",
    "comment": "Perform common validation checks.\n\n@throws org.junit.platform.commons.PreconditionViolationException if any check fails"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicSample/app/src/main/java/com/example/android/persistence/db/AppDatabase.java",
    "type": "method",
    "name": "Callback",
    "code": "final AppExecutors executors) {\n        return Room.databaseBuilder(appContext, AppDatabase.class, DATABASE_NAME)\n                .addCallback(new Callback() {\n                    }\n                })",
    "comment": "Build the database. {@link Builder#build()} only sets up the database configuration and\ncreates a new instance of the database.\nThe SQLite database is only created when it's accessed for the first time."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/CommandBuilderUtils.java",
    "type": "method",
    "name": "findJarsDir",
    "code": "static String findJarsDir(String sparkHome, String scalaVersion, boolean failIfNotFound) {\n    // TODO: change to the correct directory once the assembly build is changed.\n    File libdir = new File(sparkHome, \"jars\");\n    if (!libdir.isDirectory()) {\n      libdir = new File(sparkHome, String.format(\"assembly/target/scala-%s/jars\", scalaVersion));\n      if (!libdir.isDirectory()) {\n        checkState(!failIfNotFound,\n          \"Library directory '%s' does not exist; make sure Spark is built.\",\n          libdir.getAbsolutePath());\n        return null;\n      }\n    }\n    return libdir.getAbsolutePath();\n  }",
    "comment": "Find the location of the Spark jars dir, depending on whether we're looking at a build\nor a distribution directory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "setMaster",
    "code": "public T setMaster(String master) {\n    checkNotNull(master, \"master\");\n    builder.master = master;\n    return self();\n  }",
    "comment": "Set the Spark master for the application.\n\n@param master Spark master.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "SetProperty",
    "code": "private SetProperty(String property, String value) {\n      this.property = property;\n      this.value = value;\n    }",
    "comment": "A TableChange to set a table property.\n<p>\nIf the property already exists, it must be replaced with the new value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/orc/OrcFooterReader.java",
    "type": "method",
    "name": "readStatistics",
    "code": "public static OrcColumnStatistics readStatistics(Reader orcReader) {\n    TypeDescription orcSchema = orcReader.getSchema();\n    ColumnStatistics[] orcStatistics = orcReader.getStatistics();\n    StructType sparkSchema = OrcUtils.toCatalystSchema(orcSchema);\n    return convertStatistics(sparkSchema, new LinkedList<>(Arrays.asList(orcStatistics)));\n  }",
    "comment": "Read the columns statistics from ORC file footer.\n\n@param orcReader the reader to read ORC file footer.\n@return Statistics for all columns in the file."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestTemplateInvocationContextProvider.java",
    "type": "method",
    "name": "mayReturnZeroTestTemplateInvocationContexts",
    "code": "default boolean mayReturnZeroTestTemplateInvocationContexts(ExtensionContext context) {\n\t\treturn false;\n\t}",
    "comment": "Signal that this provider may provide zero\n{@linkplain TestTemplateInvocationContext invocation contexts} for the test\ntemplate method represented by the supplied {@code context}.\n\n<p>If this method returns {@code false} (which is the default) and the\nprovider returns an empty stream from\n{@link #provideTestTemplateInvocationContexts}, this will be considered\nan execution error. Override this method to return {@code true} to ignore\nthe absence of invocation contexts for this provider.\n\n@param context the extension context for the test template method about\nto be invoked; never {@code null}\n@return {@code true} to allow zero contexts, {@code false} to fail\nexecution in case of zero contexts\n\n@since 5.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/BeforeAllAndAfterAllComposedAnnotationTests.java",
    "type": "method",
    "name": "beforeAllAndAfterAllAsMetaAnnotations",
    "code": "void beforeAllAndAfterAllAsMetaAnnotations() {\n\t\texecuteTestsForClass(TestCase.class).testEvents().assertStatistics(stats -> stats.started(1).succeeded(1));\n\n\t\tassertThat(methodsInvoked).containsExactly(\"beforeAll\", \"test\", \"afterAll\");\n\t}",
    "comment": "Integration tests that verify support for {@link BeforeAll} and {@link AfterAll}\nwhen used as meta-annotations in the {@link JupiterTestEngine}.\n\n@since 5.0\n@see BeforeEachAndAfterEachComposedAnnotationTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(char expected, Character actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals((Character) expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-settings-builder/src/main/java/org/apache/maven/settings/building/DefaultSettingsBuilderFactory.java",
    "type": "method",
    "name": "newSettingsReader",
    "code": "protected SettingsReader newSettingsReader() {\n        return new DefaultSettingsReader();\n    }",
    "comment": "A factory to create settings builder instances when no dependency injection is available. <em>Note:</em> This class\nis only meant as a utility for developers that want to employ the settings builder outside of the Maven build system,\nMaven plugins should always acquire settings builder instances via dependency injection. Developers might want to\nsubclass this factory to provide custom implementations for some of the components used by the settings builder.\n\n@deprecated since 4.0.0, use {@link org.apache.maven.api.services.SettingsBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaCorrelationsExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaCorrelationsExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    JavaDoubleRDD seriesX = jsc.parallelizeDoubles(\n      Arrays.asList(1.0, 2.0, 3.0, 3.0, 5.0));  // a series\n\n    JavaDoubleRDD seriesY = jsc.parallelizeDoubles(\n      Arrays.asList(11.0, 22.0, 33.0, 33.0, 555.0));\n\n    double correlation = Statistics.corr(seriesX.srdd(), seriesY.srdd(), \"pearson\");\n    System.out.println(\"Correlation is: \" + correlation);\n\n    JavaRDD<Vector> data = jsc.parallelize(\n      Arrays.asList(\n        Vectors.dense(1.0, 10.0, 100.0),\n        Vectors.dense(2.0, 20.0, 200.0),\n        Vectors.dense(5.0, 33.0, 366.0)\n      )\n    );\n\n    Matrix correlMatrix = Statistics.corr(data.rdd(), \"pearson\");\n    System.out.println(correlMatrix.toString());\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nmust have the same number of partitions and cardinality as seriesX\ncompute the correlation using Pearson's method. Enter \"spearman\" for Spearman's method.\nIf a method is not specified, Pearson's method will be used by default.\nnote that each Vector is a row and not a column\ncalculate the correlation matrix using Pearson's method.\nUse \"spearman\" for Spearman's method.\nIf a method is not specified, Pearson's method will be used by default.\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/Table.java",
    "type": "method",
    "name": "properties",
    "code": "default Map<String, String> properties() {\n    return Collections.emptyMap();\n  }",
    "comment": "Returns the string map of table properties."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java",
    "type": "method",
    "name": "rootCause",
    "code": "public static Condition<Throwable> rootCause(Condition<Throwable>... conditions) {\n\t\tList<Condition<Throwable>> list = Arrays.stream(conditions)//\n\t\t\t\t.map(TestExecutionResultConditions::rootCause)//\n\t\t\t\t.collect(toList());\n\n\t\treturn Assertions.allOf(list);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if a\nall supplied conditions.\n\n@since 1.11\n@see #cause(Condition...)\n@see #suppressed(int, Condition...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/CompositeService.java",
    "type": "method",
    "name": "start",
    "code": "public synchronized void start() {\n    int i = 0;\n    try {\n      for (int n = serviceList.size(); i < n; i++) {\n        Service service = serviceList.get(i);\n        service.start();\n      }\n      super.start();\n    } catch (Throwable e) {\n      LOG.error(\"Error starting services {}\", e, MDC.of(LogKeys.SERVICE_NAME$.MODULE$, getName()));\n      stop(i);\n      throw new ServiceException(\"Failed to Start \" + getName(), e);\n    }\n\n  }",
    "comment": "Note that the state of the failed service is still INITED and not\nSTARTED. Even though the last service is not started completely, still\ncall stop() on all services including failed service to make sure cleanup\nhappens."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTimeout",
    "code": "public static void assertTimeout(Duration timeout, Executable executable, Supplier<String> messageSupplier) {\n\t\tAssertTimeout.assertTimeout(timeout, executable, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code executable}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>Note: the {@code executable} will be executed in the same thread as that\nof the calling code. Consequently, execution of the {@code executable} will\nnot be preemptively aborted if the timeout is exceeded.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@see #assertTimeout(Duration, Executable)\n@see #assertTimeout(Duration, Executable, String)\n@see #assertTimeout(Duration, ThrowingSupplier)\n@see #assertTimeout(Duration, ThrowingSupplier, String)\n@see #assertTimeout(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeoutPreemptively(Duration, Executable, Supplier)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/DefaultLifecycles.java",
    "type": "method",
    "name": "getLifeCycles",
    "code": "public List<Lifecycle> getLifeCycles() {\n        List<String> lifecycleIds = Arrays.asList(STANDARD_LIFECYCLES);\n\n        Comparator<String> comparator = (l, r) -> {\n            int lx = lifecycleIds.indexOf(l);\n            int rx = lifecycleIds.indexOf(r);\n\n            if (lx < 0 || rx < 0) {\n                return rx - lx;\n            } else {\n                return lx - rx;\n            }\n        };\n\n        Map<String, Lifecycle> lifecyclesMap = lookupLifecycles();\n\n        // ensure canonical order of standard lifecycles\n        return lifecyclesMap.values().stream()\n                .peek(l -> Objects.requireNonNull(l.getId(), \"A lifecycle must have an id.\"))\n                .sorted(Comparator.comparing(Lifecycle::getId, comparator))\n                .collect(Collectors.toList());\n    }",
    "comment": "Returns an ordered list of lifecycles"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ErrorHandler.java",
    "type": "method",
    "name": "shouldLogError",
    "code": "default boolean shouldLogError(Throwable t) {\n    return true;\n  }",
    "comment": "Plugs into {@link RetryingBlockTransferor} to further control when an exception should be retried\nand logged.\nNote: {@link RetryingBlockTransferor} will delegate the exception to this handler only when\n- remaining retries  &lt; max retries\n- exception is an IOException\n\n@since 3.1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarBatch.java",
    "type": "method",
    "name": "column",
    "code": "public ColumnVector column(int ordinal) { return columns[ordinal]; }",
    "comment": "Returns the column at `ordinal`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng7464ReadOnlyMojoParametersWarningTest.java",
    "type": "method",
    "name": "findReadOnlyWarning",
    "code": "private List<String> findReadOnlyWarning(List<String> logLines) {\n        Pattern pattern = Pattern.compile(\".* Parameter .* is read-only.*\");\n        List<String> result = new ArrayList<>();\n        for (String line : logLines) {\n            if (pattern.matcher(line).matches()) {\n                result.add(line);\n            }\n        }\n        return result;\n    }",
    "comment": "Test that ensures that warning is printed for read-only parameter set by plugin configuration."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/master-worker/src/main/java/com/iluwatar/masterworker/ArrayUtilityMethods.java",
    "type": "method",
    "name": "arraysSame",
    "code": "public static boolean arraysSame(int[] a1, int[] a2) {\n    // compares if 2 arrays have the same value\n    if (a1.length != a2.length) {\n      return false;\n    } else {\n      var answer = false;\n      for (var i = 0; i < a1.length; i++) {\n        if (a1[i] == a2[i]) {\n          answer = true;\n        } else {\n          answer = false;\n          break;\n        }\n      }\n      return answer;\n    }\n  }",
    "comment": "Method arraysSame compares 2 arrays @param a1 and @param a2 and @return whether their values\nare equal (boolean)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/test/java/org/apache/maven/api/MonotonicClockTest.java",
    "type": "method",
    "name": "testSystemTimeAlignment",
    "code": "void testSystemTimeAlignment() {\n        Instant monotonic = MonotonicClock.now();\n        Instant system = Instant.now();\n\n        Duration difference = Duration.between(monotonic, system).abs();\n        assertTrue(difference.getSeconds() <= 1, \"Monotonic time should be reasonably aligned with system time\");\n    }",
    "comment": "The difference should be relatively small (allow for 1 second max)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/MetadataResolutionResult.java",
    "type": "method",
    "name": "hasMetadataResolutionExceptions",
    "code": "public boolean hasMetadataResolutionExceptions() {\n        return metadataResolutionExceptions != null;\n    }",
    "comment": "------------------------------------------------------------------------\nMetadata Resolution Exceptions: ArtifactResolutionExceptions\n------------------------------------------------------------------------"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/AsynchronousHealthCheckerTest.java",
    "type": "method",
    "name": "whenHealthCheckThrowsException_thenReturnsDown",
    "code": "void whenHealthCheckThrowsException_thenReturnsDown() {\n    // Arrange\n    Supplier<Health> healthSupplier =\n        () -> {\n          throw new RuntimeException(\"Health check failed\");\n        };\n    // Act\n    CompletableFuture<Health> healthFuture = healthChecker.performCheck(healthSupplier, 10);\n    // Assert\n    Health health = healthFuture.join();\n    assertEquals(Status.DOWN, health.getStatus());\n    String errorMessage = health.getDetails().get(\"error\").toString();\n    assertTrue(errorMessage.contains(\"Health check failed\"));\n  }",
    "comment": "Tests that the {@link performCheck()} method returns a healthy health status when the health\nsupplier returns a healthy status.\n\n<p>Given a health supplier that throws a RuntimeException, the test verifies that the {@link\nperformCheck()} method returns a health object with a status of DOWN and an error message\ncontaining the exception message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SaslClientBootstrap.java",
    "type": "method",
    "name": "SaslClientBootstrap",
    "code": "public SaslClientBootstrap(TransportConf conf, String appId, SecretKeyHolder secretKeyHolder) {\n    this.conf = conf;\n    this.appId = appId;\n    this.secretKeyHolder = secretKeyHolder;\n  }",
    "comment": "Bootstraps a {@link TransportClient} by performing SASL authentication on the connection. The\nserver should be setup with a {@link SaslRpcHandler} with matching keys for the given appId."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectIteration",
    "code": "public static IterationSelector selectIteration(DiscoverySelector parentSelector, int... iterationIndices) {\n\t\tPreconditions.notNull(parentSelector, \"Parent selector must not be null\");\n\t\tPreconditions.notEmpty(iterationIndices, \"iteration indices must not be empty\");\n\t\treturn new IterationSelector(parentSelector, iterationIndices);\n\t}",
    "comment": "Create an {@code IterationSelector} for the supplied parent selector and\niteration indices.\n\n@param parentSelector the parent selector to select iterations for; never\n{@code null}\n@param iterationIndices the iteration indices to select; never {@code null}\nor empty\n@since 1.9\n@see IterationSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "makeValidBytes",
    "code": "private byte[] makeValidBytes() {\n    assert(numBytesValid > 0);\n    byte[] bytes = new byte[numBytesValid];\n    int byteIndex = 0, byteIndexValid = 0;\n    while (byteIndex < numBytes) {\n      // Read the first byte.\n      byte firstByte = getByte(byteIndex);\n      int expectedLen = bytesOfCodePointInUTF8[firstByte & 0xFF];\n      int codePointLen = Math.min(expectedLen, numBytes - byteIndex);\n      // 0B UTF-8 sequence (invalid first byte).\n      if (codePointLen == 0) {\n        insertReplacementCharacter(bytes, byteIndexValid);\n        byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        ++byteIndex;\n        continue;\n      }\n      // 1B UTF-8 sequence (ASCII or truncated).\n      if (codePointLen == 1) {\n        if (firstByte >= 0) {\n          bytes[byteIndexValid++] = firstByte;\n        }\n        else {\n          insertReplacementCharacter(bytes, byteIndexValid);\n          byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        }\n        ++byteIndex;\n        continue;\n      }\n      // Read the second byte.\n      byte secondByte = getByte(byteIndex + 1);\n      if (!isValidSecondByte(secondByte, firstByte)) {\n        insertReplacementCharacter(bytes, byteIndexValid);\n        byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        ++byteIndex;\n        continue;\n      }\n      // Read remaining continuation bytes.\n      int continuationBytes = 2;\n      for (; continuationBytes < codePointLen; ++continuationBytes) {\n        byte nextByte = getByte(byteIndex + continuationBytes);\n        if (!isValidContinuationByte(nextByte)) {\n          break;\n        }\n      }\n      // Invalid UTF-8 sequence (not enough continuation bytes).\n      if (continuationBytes < expectedLen) {\n        insertReplacementCharacter(bytes, byteIndexValid);\n        byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        byteIndex += continuationBytes;\n        continue;\n      }\n      // Valid UTF-8 sequence.\n      for (int i = 0; i < codePointLen; ++i) {\n        bytes[byteIndexValid++] = getByte(byteIndex + i);\n      }\n      byteIndex += codePointLen;\n    }\n    return bytes;\n  }",
    "comment": "Private helper method to create a valid UTF-8 byte sequence from the current UTF8String.\nIn order to use this method, the number of bytes of the validated version of the current\nstring (after possible replacement) must be evaluated first by calling `getIsValid`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultSourceRoot.java",
    "type": "method",
    "name": "DefaultSourceRoot",
    "code": "public DefaultSourceRoot(final Session session, final Path baseDir, final Source source) {\n        includes = source.getIncludes();\n        excludes = source.getExcludes();\n        stringFiltering = source.isStringFiltering();\n        enabled = source.isEnabled();\n        moduleName = nonBlank(source.getModule());\n\n        String value = nonBlank(source.getScope());\n        scope = (value != null) ? session.requireProjectScope(value) : ProjectScope.MAIN;\n\n        value = nonBlank(source.getLang());\n        language = (value != null) ? session.requireLanguage(value) : Language.JAVA_FAMILY;\n\n        value = nonBlank(source.getDirectory());\n        if (value != null) {\n            directory = baseDir.resolve(value);\n        } else {\n            directory = baseDir.resolve(\"src\").resolve(scope.id()).resolve(language.id());\n        }\n\n        value = nonBlank(source.getTargetVersion());\n        targetVersion = (value != null) ? session.parseVersion(value) : null;\n\n        value = nonBlank(source.getTargetPath());\n        targetPath = (value != null) ? baseDir.resolve(value) : null;\n    }",
    "comment": "Creates a new instance from the given model.\n\n@param session the session of resolving extensible enumerations\n@param baseDir the base directory for resolving relative paths\n@param source a source element from the model"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/di/testing/MavenDIExtension.java",
    "type": "method",
    "name": "getTestFile",
    "code": "public static File getTestFile(String path) {\n        return new File(getBasedir(), path);\n    }",
    "comment": "Creates a File object for a path relative to the base directory.\n\n@param path The relative path\n@return A File object representing the path"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerOperationBuilder.java",
    "type": "method",
    "name": "setAttr",
    "code": "public EagerOperationBuilder setAttr(String name, Tensor<?>[] values) {\n    throw new UnsupportedOperationException(\n        \"Tensor list attributes are not supported in eager mode\");\n  }",
    "comment": "TODO (karllessard) could be supported by adding this attribute type in the eager C API"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/RocksDB.java",
    "type": "method",
    "name": "closeIterator",
    "code": "void closeIterator(RocksIterator it) {\n    notifyIteratorClosed(it);\n    synchronized (this._db) {\n      org.rocksdb.RocksDB _db = this._db.get();\n      if (_db != null) {\n        it.close();\n      }\n    }\n  }",
    "comment": "Closes the given iterator if the DB is still open. Trying to close a JNI RocksDB handle\nwith a closed DB can cause JVM crashes, so this ensures that situation does not happen."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectNestedClass",
    "code": "public static NestedClassSelector selectNestedClass(List<Class<?>> enclosingClasses, Class<?> nestedClass) {\n\t\tPreconditions.notEmpty(enclosingClasses, \"Enclosing classes must not be null or empty\");\n\t\tPreconditions.notNull(nestedClass, \"Nested class must not be null\");\n\t\treturn new NestedClassSelector(enclosingClasses, nestedClass);\n\t}",
    "comment": "Create a {@code NestedClassSelector} for the supplied nested {@link Class} and its\nenclosing classes.\n\n@param enclosingClasses the path to the nested class to select; never {@code null} or empty\n@param nestedClass the nested class to select; never {@code null}\n@since 1.6\n@see NestedClassSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaSummaryStatisticsExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaSummaryStatisticsExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    JavaRDD<Vector> mat = jsc.parallelize(\n      Arrays.asList(\n        Vectors.dense(1.0, 10.0, 100.0),\n        Vectors.dense(2.0, 20.0, 200.0),\n        Vectors.dense(3.0, 30.0, 300.0)\n      )\n    ); // an RDD of Vectors\n\n    MultivariateStatisticalSummary summary = Statistics.colStats(mat.rdd());\n    System.out.println(summary.mean());  // a dense vector containing the mean value for each column\n    System.out.println(summary.variance());  // column-wise variance\n    System.out.println(summary.numNonzeros());  // number of nonzeros in each column\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nCompute column summary statistics.\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/JavaHdfsLR.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    if (args.length < 2) {\n      System.err.println(\"Usage: JavaHdfsLR <file> <iters>\");\n      System.exit(1);\n    }\n\n    showWarning();\n\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaHdfsLR\")\n      .getOrCreate();\n\n    JavaRDD<String> lines = spark.read().textFile(args[0]).javaRDD();\n    JavaRDD<DataPoint> points = lines.map(new ParsePoint()).cache();\n    int ITERATIONS = Integer.parseInt(args[1]);\n\n    double[] w = new double[D];\n    for (int i = 0; i < D; i++) {\n      w[i] = 2 * rand.nextDouble() - 1;\n    }\n\n    System.out.print(\"Initial w: \");\n    printWeights(w);\n\n    for (int i = 1; i <= ITERATIONS; i++) {\n      System.out.println(\"On iteration \" + i);\n\n      double[] gradient = points.map(\n        new ComputeGradient(w)\n      ).reduce(new VectorSum());\n\n      for (int j = 0; j < D; j++) {\n        w[j] -= gradient[j];\n      }\n\n    }\n\n    System.out.print(\"Final w: \");\n    printWeights(w);\n    spark.stop();\n  }",
    "comment": "Initialize w to a random value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/validator/AnnotationsValidator.java",
    "type": "method",
    "name": "validateTestClass",
    "code": "public List<Exception> validateTestClass(TestClass testClass) {\n        List<Exception> validationErrors= new ArrayList<Exception>();\n        for (AnnotatableValidator<?> validator : VALIDATORS) {\n            List<Exception> additionalErrors= validator\n                    .validateTestClass(testClass);\n            validationErrors.addAll(additionalErrors);\n        }\n        return validationErrors;\n    }",
    "comment": "Validate all annotations of the specified test class that are be\nannotated with {@link ValidateWith}.\n\n@param testClass\nthe {@link TestClass} that is validated.\n@return the errors found by the validator."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, float actual, float delta) {\n        Assert.assertEquals(expected, actual, delta);\n    }",
    "comment": "Asserts that two floats are equal concerning a delta. If the expected\nvalue is infinity then the delta value is ignored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(byte expected, Byte actual, String message) {\n\t\tAssertEquals.assertEquals((Byte) expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectDirectory",
    "code": "public static DirectorySelector selectDirectory(String path) {\n\t\tPreconditions.notBlank(path, \"Directory path must not be null or blank\");\n\t\treturn new DirectorySelector(path);\n\t}",
    "comment": "Create a {@code DirectorySelector} for the supplied directory path.\n\n<p>This method selects the directory using the supplied path <em>as is</em>,\nwithout verifying if the directory exists.\n\n@param path the path to the directory to select; never {@code null} or blank\n@see DirectorySelector\n@see #selectDirectory(File)\n@see #selectFile(String)\n@see #selectFile(File)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "collectInitializationErrors",
    "code": "protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        applyValidators(errors);\n    }",
    "comment": "Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\nDefault implementation adds an error for each method annotated with\n{@code @BeforeClass} or {@code @AfterClass} that is not\n{@code public static void} with no arguments."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ShuffleIndexInformation.java",
    "type": "method",
    "name": "getIndex",
    "code": "public ShuffleIndexRecord getIndex(int reduceId) {\n    return getIndex(reduceId, reduceId + 1);\n  }",
    "comment": "Get index offset for a particular reducer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/experimental/categories/MultiCategoryTest.java",
    "type": "method",
    "name": "runSuite",
    "code": "public void runSuite() {\n        // Targeting Test:\n        Result testResult= JUnitCore.runClasses(MultiCategorySuite.class);\n\n        assertThat(\"unexpected run count\", testResult.getRunCount(), is(equalTo(2)));\n        assertThat(\"unexpected failure count\", testResult.getFailureCount(), is(equalTo(0)));\n        assertThat(\"unexpected failure count\", testResult.getIgnoreCount(), is(equalTo(0)));\n    }",
    "comment": "This test is mentioned in {@code Categories} and any changes\nmust be reflected."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "getNumChars",
    "code": "private int getNumChars() {\n    int len = 0;\n    for (int i = 0; i < numBytes; i += numBytesForFirstByte(getByte(i))) {\n      len += 1;\n    }\n    return len;\n  }",
    "comment": "Private helper method to calculate the number of code points in the UTF-8 string. Counting\nthe code points is a linear time operation, as we need to scan the entire UTF-8 string.\nHence, this method should generally only be called once for non-empty UTF-8 strings."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/business-delegate/src/main/java/com/iluwatar/business/delegate/BusinessLookup.java",
    "type": "method",
    "name": "getBusinessService",
    "code": "public VideoStreamingService getBusinessService(String movie) {\n    if (movie.toLowerCase(Locale.ROOT).contains(\"die hard\")) {\n      return netflixService;\n    } else {\n      return youTubeService;\n    }\n  }",
    "comment": "Gets service instance based on given movie search string.\n\n@param movie Search string for the movie.\n@return Service instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setArray",
    "code": "public void setArray(ColumnarArray value) {\n    arrayData = value;\n  }",
    "comment": "Sets the `ColumnarArray` `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "showToast",
    "code": "private void showToast(final String text) {\n    final Activity activity = getActivity();\n    if (activity != null) {\n      activity.runOnUiThread(\n          new Runnable() {\n          });\n    }\n  }",
    "comment": "Shows a {@link Toast} on the UI thread.\n\n@param text The message to show"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/memory/TaskMemoryManagerSuite.java",
    "type": "method",
    "name": "selfSpillIsLowestPriorities",
    "code": "public void selfSpillIsLowestPriorities() {\n    final TestMemoryManager memoryManager = new TestMemoryManager(new SparkConf());\n    memoryManager.limit(100);\n    final TaskMemoryManager manager = new TaskMemoryManager(memoryManager, 0);\n\n    TestMemoryConsumer c1 = new TestMemoryConsumer(manager);\n    TestMemoryConsumer c2 = new TestMemoryConsumer(manager);\n    TestMemoryConsumer c3 = new TestMemoryConsumer(manager);\n\n    c1.use(50);\n    c2.use(40);\n    c3.use(10);\n    c1.use(50);\n    Assertions.assertEquals(100, c1.getUsed());\n    Assertions.assertEquals(0, c2.getUsed());\n    Assertions.assertEquals(0, c3.getUsed());\n    c1.use(50);\n    Assertions.assertEquals(50, c1.getUsed());\n    c2.use(10);\n    c1.use(60);\n    Assertions.assertEquals(60, c1.getUsed());\n    Assertions.assertEquals(0, c2.getUsed());\n\n    c1.free(c1.getUsed());\n\n    c1.use(50);\n    c2.use(40);\n    c3.use(10);\n    c3.use(50);\n    Assertions.assertEquals(0, c1.getUsed());\n    Assertions.assertEquals(40, c2.getUsed());\n    Assertions.assertEquals(60, c3.getUsed());\n  }",
    "comment": "Test that requesting memory consumer (a \"self-spill\") is chosen last to spill.\nSelf-spill is the lowest priority: c2 and c3 are spilled first even though they have less\nmemory.\nForce a self-spill.\nForce a self-spill after c2 is spilled.\nRedo a similar scenario but with a different memory requester."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelBuildingException.java",
    "type": "method",
    "name": "ModelBuildingException",
    "code": "public ModelBuildingException(ModelBuildingResult result) {\n        super(toMessage(result));\n        this.result = result;\n    }",
    "comment": "Creates a new exception from the specified interim result and its associated problems.\n\n@param result The interim result, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/ProjectSorter.java",
    "type": "method",
    "name": "getTopLevelProject",
    "code": "public MavenProject getTopLevelProject() {\n        return sortedProjects.stream()\n                .filter(MavenProject::isExecutionRoot)\n                .findFirst()\n                .orElse(null);\n    }",
    "comment": "TODO !![jc; 28-jul-2005] check this; if we're using '-r' and there are aggregator tasks, this will result in\nweirdness."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/artifact/resolver/ArtifactResolutionExceptionTest.java",
    "type": "method",
    "name": "testMissingArtifactMessageFormat",
    "code": "void testMissingArtifactMessageFormat() {\n        String message = \"Missing artifact\";\n        String indentation = \"  \";\n        String groupId = \"aGroupId\";\n        String artifactId = \"anArtifactId\";\n        String version = \"aVersion\";\n        String type = \"jar\";\n        String classifier = \"aClassifier\";\n        String downloadUrl = \"http://somewhere.com/download\";\n        List<String> path = Arrays.asList(\"dependency1\", \"dependency2\");\n        String expected = \"Missing artifact\" + LS + LS + \"  Try downloading the file manually from: \" + LS\n                + \"      http://somewhere.com/download\" + LS + LS + \"  Then, install it using the command: \" + LS\n                + \"      mvn install:install-file -DgroupId=aGroupId -DartifactId=anArtifactId -Dversion=aVersion \"\n                + \"-Dclassifier=aClassifier -Dpackaging=jar -Dfile=/path/to/file\" + LS + LS\n                + \"  Alternatively, if you host your own repository you can deploy the file there: \" + LS\n                + \"      mvn deploy:deploy-file -DgroupId=aGroupId -DartifactId=anArtifactId\"\n                + \" -Dversion=aVersion -Dclassifier=aClassifier -Dpackaging=jar -Dfile=/path/to/file\"\n                + \" -Durl=[url] -DrepositoryId=[id]\" + LS + LS + \"  Path to dependency: \" + LS + \"  \\t1) dependency1\"\n                + LS + \"  \\t2) dependency2\" + LS + LS;\n        String actual = AbstractArtifactResolutionException.constructMissingArtifactMessage(\n                message, indentation, groupId, artifactId, version, type, classifier, downloadUrl, path);\n        assertEquals(expected, actual);\n    }",
    "comment": "Test the artifact resolution exception message"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(byte expected, Byte actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals((Byte) expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Character expected, Character actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/test/java/org/apache/maven/cling/transfer/FileSizeFormatTest.java",
    "type": "method",
    "name": "testFormatRateEdgeCases",
    "code": "void testFormatRateEdgeCases() {\n        FileSizeFormat format = new FileSizeFormat();\n\n        MessageBuilder builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 0.0);\n        assertEquals(\"0.0 B/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000.0);\n        assertEquals(\"1.0 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000000.0);\n        assertEquals(\"1.0 MB/s\", builder.build());\n    }",
    "comment": "Test zero rate\nTest rate at exactly 1000 (1 kB/s)\nTest rate at exactly 1000000 (1 MB/s)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java",
    "type": "method",
    "name": "preferNewTestsOverTestsThatFailed",
    "code": "public void preferNewTestsOverTestsThatFailed() {\n        Request one = Request.method(TwoTests.class, \"dontSucceed\");\n        fMax.run(one);\n        Request two = Request.aClass(TwoTests.class);\n        List<Description> things = fMax.sortedLeavesForTest(two);\n        Description succeed = Description.createTestDescription(TwoTests.class,\n                \"succeed\");\n        assertEquals(succeed, things.get(0));\n        assertEquals(2, things.size());\n    }",
    "comment": "This covers a seemingly-unlikely case, where you had a test that failed\non the\nlast run and you also introduced new tests. In such a case it pretty much\ndoesn't matter\nwhich order they run, you just want them both to be early in the sequence"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/Requirement.java",
    "type": "method",
    "name": "clone",
    "code": "public Requirement clone() {\n        try {\n            return (Requirement) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e);\n        }\n    }",
    "comment": "Creates a shallow copy of this requirement."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(boolean condition, String message) {\n\t\tAssertTrue.assertTrue(condition, message);\n\t}",
    "comment": "<em>Assert</em> that the supplied {@code condition} is {@code true}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-to-worker/src/main/java/com/iluwatar/servicetoworker/Action.java",
    "type": "method",
    "name": "Action",
    "code": "public Action(GiantModel giant) {\n    this.giant = giant;\n  }",
    "comment": "Instantiates a new Action.\n\n@param giant the giant"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/function/Try.java",
    "type": "method",
    "name": "orElse",
    "code": "public Try<V> orElse(Supplier<Try<V>> supplier) {\n\t\t\treturn this;\n\t\t}",
    "comment": "don't call supplier because this Try is a success"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n    return new String(getBytes(), StandardCharsets.UTF_8);\n  }",
    "comment": "Returns a string representation of this UTF8String object. The string representation consists\nof the string's characters encoded in UTF-8 and the result of this method is always a valid\nUTF-8 string. However, if the current UTF8String contains illegal UTF-8 byte sequences, the\nmethod will replace the illegal byte sequences with the Unicode replacement character U+FFFD,\naccording to Java specification. Using this method with invalid UTF8Strings is NOT RECOMMENDED."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/CompositeTestSourceTests.java",
    "type": "method",
    "name": "createSerializableInstances",
    "code": "Stream<CompositeTestSource> createSerializableInstances() {\n\t\tvar fileSource = FileSource.from(new File(\"sample.instance\"));\n\t\tvar classSource = ClassSource.from(getClass());\n\t\tvar sources = List.of(fileSource, classSource);\n\t\treturn Stream.of(CompositeTestSource.from(sources));\n\t}",
    "comment": "Unit tests for {@link CompositeTestSource}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/StringUtilsTests.java",
    "type": "method",
    "name": "blankness",
    "code": "void blankness() {\n\t\t// @formatter:off\n\t\tassertAll(\"Blankness\",\n\t\t\t() -> assertTrue(isBlank(null)),\n\t\t\t() -> assertTrue(isBlank(\"\")),\n\t\t\t() -> assertTrue(isBlank(\" \\t\\n\\r\")),\n\t\t\t() -> assertTrue(isNotBlank(\".\"))\n\t\t);\n\t\t// @formatter:on\n\t}",
    "comment": "Unit tests for {@link StringUtils}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "nestedContainer",
    "code": "public static Condition<Event> nestedContainer(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(clazz.getEnclosingClass(), () -> clazz.getName() + \" must be a nested class\");\n\n\t\tList<String> classNames = new ArrayList<>();\n\t\tfor (Class<?> current = clazz; current != null; current = current.getEnclosingClass()) {\n\t\t\tclassNames.add(0, current.getSimpleName());\n\t\t}\n\n\t\treturn allOf(container(), uniqueIdSubstrings(classNames));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\na {@linkplain TestDescriptor#isContainer() container} and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the\nsimple names of the supplied {@link Class} and all of its\n{@linkplain Class#getEnclosingClass() enclosing classes}.\n\n<p>Please note that this method does not differentiate between static\nnested classes and non-static member classes (e.g., inner classes).\n\n@see #nestedContainer(Class, Condition)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "removeCIEnvironmentVariables",
    "code": "public void removeCIEnvironmentVariables() {\n        environmentVariables.putAll(Map.of(\n                \"CIRCLECI\", \"\",\n                \"CI\", \"false\",\n                \"GITHUB_ACTIONS\", \"\",\n                \"WORKSPACE\", \"\",\n                \"TEAMCITY_VERSION\", \"\",\n                \"TRAVIS\", \"\"));\n    }",
    "comment": "This method renders all env variables that are used for CI detection (by all known detector) to not trigger."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/JUnitCore.java",
    "type": "method",
    "name": "run",
    "code": "public Result run(junit.framework.Test test) {\n        return run(new JUnit38ClassRunner(test));\n    }",
    "comment": "Run all the tests contained in JUnit 3.8.x <code>test</code>. Here for backward compatibility.\n\n@param test the old-style test\n@return a {@link Result} describing the details of the test run and the failed tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/textui/ResultPrinter.java",
    "type": "method",
    "name": "printDefectHeader",
    "code": "protected void printDefectHeader(TestFailure booBoo, int count) {\n        getWriter().print(count + \") \" + booBoo.failedTest());\n    }",
    "comment": "I feel like making this a println, then adding a line giving the throwable a chance to print something\nbefore we get to the stack trace."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStore.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n\t\tif (!this.closed) {\n\t\t\ttry {\n\t\t\t\tif (this.closeAction != null) {\n\t\t\t\t\tThrowableCollector throwableCollector = new ThrowableCollector(__ -> false);\n\t\t\t\t\tthis.storedValues.entrySet().stream() //\n\t\t\t\t\t\t\t.map(e -> e.getValue().evaluateSafely(e.getKey())) //\n\t\t\t\t\t\t\t.filter(it -> it != null && it.value != null) //\n\t\t\t\t\t\t\t.sorted(EvaluatedValue.REVERSE_INSERT_ORDER) //\n\t\t\t\t\t\t\t.forEach(it -> throwableCollector.execute(() -> it.close(this.closeAction)));\n\t\t\t\t\tthrowableCollector.assertEmpty();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.closed = true;\n\t\t\t}\n\t\t}\n\t}",
    "comment": "If a {@link CloseAction} is configured, it will be called with all successfully\nstored values in reverse insertion order.\n\n<p>Closing a store does not close its parent or any of its children.\n\n<p>Invocations of this method after the store has already been closed will\nbe ignored.\n\n@see #isClosed()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/util/collection/unsafe/sort/UnsafeInMemorySorterSuite.java",
    "type": "method",
    "name": "testNoOOMDuringReset",
    "code": "public void testNoOOMDuringReset() {\n    final SparkConf sparkConf = new SparkConf();\n    sparkConf.set(package$.MODULE$.MEMORY_OFFHEAP_ENABLED(), false);\n\n    final TestMemoryManager testMemoryManager =\n            new TestMemoryManager(sparkConf);\n    final TaskMemoryManager memoryManager = new TaskMemoryManager(\n            testMemoryManager, 0);\n    final TestMemoryConsumer consumer = new TestMemoryConsumer(memoryManager);\n\n    final PrefixComparator prefixComparator = PrefixComparators.LONG;\n    final RecordComparator recordComparator = new RecordComparator() {\n    };\n    UnsafeInMemorySorter sorter = new UnsafeInMemorySorter(consumer, memoryManager,\n            recordComparator, prefixComparator, 100, shouldUseRadixSort());\n\n    testMemoryManager.markconsequentOOM(Integer.MAX_VALUE);\n    sorter.freeMemory();\n    testMemoryManager.resetConsequentOOM();\n    Assertions.assertFalse(sorter.hasSpaceForAnotherRecord());\n\n    LongArray array = consumer.allocateArray(1000);\n    sorter.expandPointerArray(array);\n\n    testMemoryManager.markconsequentOOM(Integer.MAX_VALUE);\n    sorter.freeMemory();\n    sorter.freeMemory();\n    testMemoryManager.resetConsequentOOM();\n    Assertions.assertFalse(sorter.hasSpaceForAnotherRecord());\n\n    assertEquals(0L, memoryManager.cleanUpAllAllocatedMemory());\n  }",
    "comment": "Use integer comparison for comparing prefixes (which are partition ids, in this case)\nEnsure that the sorter does not OOM while freeing its memory.\nGet the sorter in an usable state again by allocating a new pointer array.\nEnsure that it is safe to call freeMemory() multiple times."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/BuildResumptionPersistenceException.java",
    "type": "method",
    "name": "BuildResumptionPersistenceException",
    "code": "public BuildResumptionPersistenceException(String message, Throwable cause) {\n        super(message, cause);\n    }",
    "comment": "This exception will be thrown when something fails while persisting build resumption data.\n@see BuildResumptionDataRepository#persistResumptionData"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/gen/java/org/tensorflow/processor/OperatorProcessor.java",
    "type": "method",
    "name": "process",
    "code": "public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n    if (roundEnv.processingOver()) {\n      return false;\n    }\n\n    if (annotations.size() == 0) {\n      return false;\n    }\n\n    if (annotations.size() != 1) {\n      throw new IllegalStateException(\n          \"Unexpected - multiple annotations registered: \" + annotations);\n    }\n    TypeElement annotation = annotations.iterator().next();\n    Set<? extends Element> annotated = roundEnv.getElementsAnnotatedWith(annotation);\n\n    if (annotated.size() == 0) {\n      return false;\n    }\n\n    if (hasRun) {\n      for (Element e : annotated) {\n        error(\n            e,\n            \"The Operator processor has already processed @Operator annotated sources\\n\"\n                + \"and written out an Ops API. It cannot process additional @Operator sources.\\n\"\n                + \"One reason this can happen is if other annotation processors generate\\n\"\n                + \"new @Operator source files.\");\n      }\n      return false;\n    }\n\n    Multimap<String, MethodSpec> groupedMethods = HashMultimap.create();\n    if (!collectOpsMethods(roundEnv, groupedMethods, annotation)) {\n      return false;\n    }\n\n    if (groupedMethods.isEmpty()) {\n      return false;\n    }\n\n    writeApi(groupedMethods);\n\n    hasRun = true;\n    return false;\n  }",
    "comment": "Nothing needs to be done at the end of all rounds.\nNothing to look at in this round.\nWe expect to be registered for exactly one annotation.\nIf there are no annotated elements, claim the annotation but do nothing.\nThis processor has to aggregate all op classes in one round, as it generates a single Ops\nAPI class which cannot be modified once generated. If we find an annotation after we've\ngenerated our code, flag the location of each such class.\nCollect all classes tagged with our annotation.\nNothing to do when there are no tagged classes.\nValidate operator classes and generate Op API."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-mapper/src/test/java/com/iluwatar/datamapper/StudentTest.java",
    "type": "method",
    "name": "testEquality",
    "code": "void testEquality() {\n\n    /* Create some students */\n    final var firstStudent = new Student(1, \"Adam\", 'A');\n    final var secondStudent = new Student(2, \"Donald\", 'B');\n    final var secondSameStudent = new Student(2, \"Donald\", 'B');\n\n    /* Check equals functionality: should return 'true' */\n    assertEquals(firstStudent, firstStudent);\n\n    /* Check equals functionality: should return 'false' */\n    assertNotEquals(firstStudent, secondStudent);\n\n    /* Check equals functionality: should return 'true' */\n    assertEquals(secondStudent, secondSameStudent);\n  }",
    "comment": "This API tests the equality behaviour of Student object Object Equality should work as per\nlogic defined in equals method\n\n@throws Exception if any execution error during test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/checksum/ShuffleChecksumHelper.java",
    "type": "method",
    "name": "if",
    "code": "long checksumByReader) {\n    Cause cause;\n    long duration = -1L;\n    long checksumByWriter = -1L;\n    long checksumByReCalculation = -1L;\n    try {\n      long diagnoseStartNs = System.nanoTime();\n      // Try to get the checksum instance before reading the checksum file so that\n      // `UnsupportedOperationException` can be thrown first before `FileNotFoundException`\n      // when the checksum algorithm isn't supported.\n      Checksum checksumAlgo = getChecksumByAlgorithm(algorithm);\n      checksumByWriter = readChecksumByReduceId(checksumFile, reduceId);\n      checksumByReCalculation = calculateChecksumForPartition(partitionData, checksumAlgo);\n      duration = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - diagnoseStartNs);\n      if (checksumByWriter != checksumByReCalculation) {\n        cause = Cause.DISK_ISSUE;\n      } else if (checksumByWriter != checksumByReader) {\n        cause = Cause.NETWORK_ISSUE;\n      } else {\n        cause = Cause.CHECKSUM_VERIFY_PASS;\n      }\n    } catch (UnsupportedOperationException e) {\n      cause = Cause.UNSUPPORTED_CHECKSUM_ALGORITHM;\n    } catch (FileNotFoundException e) {\n      // Even if checksum is enabled, a checksum file may not exist if error throws during writing.\n      logger.warn(\"Checksum file {} doesn't exit\",\n        MDC.of(LogKeys.PATH$.MODULE$, checksumFile.getName()));\n      cause = Cause.UNKNOWN_ISSUE;\n    } catch (Exception e) {\n      logger.warn(\"Unable to diagnose shuffle block corruption\", e);\n      cause = Cause.UNKNOWN_ISSUE;\n    }\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Shuffle corruption diagnosis took {} ms, checksum file {}, cause {}, \" +\n        \"checksumByReader {}, checksumByWriter {}, checksumByReCalculation {}\",\n        duration, checksumFile.getAbsolutePath(), cause,\n        checksumByReader, checksumByWriter, checksumByReCalculation);\n    } else {\n      logger.info(\"Shuffle corruption diagnosis took {} ms, checksum file {}, cause {}\",\n        MDC.of(LogKeys.TIME$.MODULE$, duration),\n        MDC.of(LogKeys.PATH$.MODULE$, checksumFile.getAbsolutePath()),\n        MDC.of(LogKeys.REASON$.MODULE$, cause));\n    }\n    return cause;\n  }",
    "comment": "Diagnose the possible cause of the shuffle data corruption by verifying the shuffle checksums.\n\nThere're 3 different kinds of checksums for the same shuffle partition:\n- checksum (c1) that is calculated by the shuffle data reader\n- checksum (c2) that is calculated by the shuffle data writer and stored in the checksum file\n- checksum (c3) that is recalculated during diagnosis\n\nAnd the diagnosis mechanism works like this:\nIf c2 != c3, we suspect the corruption is caused by the DISK_ISSUE. Otherwise, if c1 != c3,\nwe suspect the corruption is caused by the NETWORK_ISSUE. Otherwise, the cause remains\nCHECKSUM_VERIFY_PASS. In case of the any other failures, the cause remains UNKNOWN_ISSUE.\n\n@param algorithm The checksum algorithm that is used for calculating checksum value\nof partitionData\n@param checksumFile The checksum file that written by the shuffle writer\n@param reduceId The reduceId of the shuffle block\n@param partitionData The partition data of the shuffle block\n@param checksumByReader The checksum value that calculated by the shuffle data reader\n@return The cause of data corruption"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Double> create(Scope scope, long[] shape, DoubleBuffer data) {\n    try (Tensor<Double> value = Tensor.create(shape, data)) {\n      return createWithTensor(scope, value);\n    }\n  }",
    "comment": "Create a {@link DataType#DOUBLE} constant with data from the given buffer.\n\n<p>Creates a constant with the given shape by copying elements from the buffer (starting from\nits current position) into the tensor. For example, if {@code shape = {2,3} } (which represents\na 2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param scope is a scope used to add the underlying operation.\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@return a double constant\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/special-case/src/main/java/com/iluwatar/specialcase/DomainServicesImpl.java",
    "type": "method",
    "name": "purchase",
    "code": "private ReceiptViewModel purchase(Db.User user, Db.Account account, String itemName) {\n    Db.Product item = Db.getInstance().findProductByItemName(itemName);\n    if (item == null) {\n      return new OutOfStock(user.getUserName(), itemName);\n    }\n\n    ReceiptDto receipt = user.purchase(item);\n    MoneyTransaction transaction = account.withdraw(receipt.getPrice());\n    if (transaction == null) {\n      return new InsufficientFunds(user.getUserName(), account.getAmount(), itemName);\n    }\n\n    return receipt;\n  }",
    "comment": "Domain purchase with user, account and itemName, with validation for whether product is out of\nstock and whether user has insufficient funds in the account.\n\n@param user in Db\n@param account in Db\n@param itemName of the item\n@return instance of ReceiptViewModel"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dirty-flag/src/test/java/org/dirty/flag/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/SupportsCatalogOptions.java",
    "type": "method",
    "name": "extractCatalog",
    "code": "default String extractCatalog(CaseInsensitiveStringMap options) {\n    return CatalogManager.SESSION_CATALOG_NAME();\n  }",
    "comment": "Return the name of a catalog that can be used to check the existence of, load, and create\na table for this DataSource given the identifier that will be extracted by\n{@link #extractIdentifier(CaseInsensitiveStringMap) extractIdentifier}. A `null` value can\nbe used to defer to the V2SessionCatalog.\n\n@param options the user-specified options that can identify a table, e.g. file path, Kafka\ntopic name, etc. It's an immutable case-insensitive string-to-string map."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, Float actual, String message) {\n\t\tAssertEquals.assertEquals((Float) expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/Phase.java",
    "type": "method",
    "name": "setConfiguration",
    "code": "public void setConfiguration(Object configuration) {\n        this.configuration = configuration;\n    } // -- void setConfiguration( Object )",
    "comment": "Set configuration to pass to all goals run in this phase.\n\n@param configuration a configuration object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "getProperty",
    "code": "public String getProperty(String key) {\n        return this.get(key);\n    }",
    "comment": "Searches for the property with the specified key in this property list.\n\n@param key the property key.\n@return the value in this property list with the specified key value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/ErrorCollector.java",
    "type": "method",
    "name": "checkThat",
    "code": "public <T> void checkThat(final String reason, final T value, final Matcher<T> matcher) {\n        checkSucceeds(new Callable<Object>() {\n        });\n    }",
    "comment": "Adds a failure with the given {@code reason}\nto the table if {@code matcher} does not match {@code value}.\nExecution continues, but the test will fail at the end if the match fails."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "getInts",
    "code": "public int[] getInts(int rowId, int count) {\n    int[] res = new int[count];\n    for (int i = 0; i < count; i++) {\n      res[i] = getInt(rowId + i);\n    }\n    return res;\n  }",
    "comment": "Gets int type values from {@code [rowId, rowId + count)}. The return values for the null slots\nare undefined and can be anything."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/BaseParser.java",
    "type": "method",
    "name": "populateSystemProperties",
    "code": "protected Map<String, String> populateSystemProperties(LocalContext context) {\n        Properties systemProperties = new Properties();\n\n\n        EnvironmentUtils.addEnvVars(systemProperties);\n        SystemProperties.addSystemProperties(systemProperties);\n\n\n        Properties buildProperties = CLIReportingUtils.getBuildProperties();\n\n        String mavenVersion = buildProperties.getProperty(CLIReportingUtils.BUILD_VERSION_PROPERTY);\n        systemProperties.setProperty(Constants.MAVEN_VERSION, mavenVersion);\n\n        boolean snapshot = mavenVersion.endsWith(\"SNAPSHOT\");\n        if (snapshot) {\n            mavenVersion = mavenVersion.substring(0, mavenVersion.length() - \"SNAPSHOT\".length());\n            if (mavenVersion.endsWith(\"-\")) {\n                mavenVersion = mavenVersion.substring(0, mavenVersion.length() - 1);\n            }\n        }\n        String[] versionElements = mavenVersion.split(\"\\\\.\");\n        if (versionElements.length != 3) {\n            throw new IllegalStateException(\"Maven version is expected to have 3 segments: '\" + mavenVersion + \"'\");\n        }\n        systemProperties.setProperty(Constants.MAVEN_VERSION_MAJOR, versionElements[0]);\n        systemProperties.setProperty(Constants.MAVEN_VERSION_MINOR, versionElements[1]);\n        systemProperties.setProperty(Constants.MAVEN_VERSION_PATCH, versionElements[2]);\n        systemProperties.setProperty(Constants.MAVEN_VERSION_SNAPSHOT, Boolean.toString(snapshot));\n\n        String mavenBuildVersion = CLIReportingUtils.createMavenVersionString(buildProperties);\n        systemProperties.setProperty(Constants.MAVEN_BUILD_VERSION, mavenBuildVersion);\n\n        Map<String, String> result = toMap(systemProperties);\n        result.putAll(context.systemPropertiesOverrides);\n        return result;\n    }",
    "comment": "----------------------------------------------------------------------\nLoad environment and system properties\n----------------------------------------------------------------------\n----------------------------------------------------------------------\nProperties containing info about the currently running version of Maven\nThese override any corresponding properties set on the command line\n----------------------------------------------------------------------"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/ViewCatalog.java",
    "type": "method",
    "name": "viewExists",
    "code": "default boolean viewExists(Identifier ident) {\n    try {\n      return loadView(ident) != null;\n    } catch (NoSuchViewException e) {\n      return false;\n    }\n  }",
    "comment": "Test whether a view exists using an {@link Identifier identifier} from the catalog.\n<p>\nIf the catalog supports views and contains a view for the identifier and not a table,\nthis must return false.\n\n@param ident a view identifier\n@return true if the view exists, false otherwise"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedDeltaBinaryPackedReader.java",
    "type": "method",
    "name": "skipValues",
    "code": "private void skipValues(int total) {\n    readValues(total, null, -1, (w, r, v) -> {});\n  }",
    "comment": "Read the values but don't write them out (the writer output method is a no-op)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/ExecutionRecorder.java",
    "type": "method",
    "name": "executionSkipped",
    "code": "public void executionSkipped(TestDescriptor testDescriptor, String reason) {\n\t\tthis.events.add(Event.executionSkipped(testDescriptor, reason));\n\t}",
    "comment": "Record an {@link Event} for a container or test that was skipped."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestWatcherTests.java",
    "type": "method",
    "name": "testWatcherSemanticsWhenRegisteredAtInstanceLevelWithTestInstanceLifecyclePerClass",
    "code": "void testWatcherSemanticsWhenRegisteredAtInstanceLevelWithTestInstanceLifecyclePerClass() {\n\t\tClass<?> testClass = TestInstancePerClassInstanceLevelTestWatcherTestCase.class;\n\t\tassertStatsForAbstractDisabledMethodsTestCase(testClass);\n\n\t\tassertThat(TrackingTestWatcher.results.get(\"testDisabled\")).containsExactly(\"test\", \"repeatedTest\");\n\t}",
    "comment": "We get \"testDisabled\" events for the @Test method and the @RepeatedTest container."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/test/java/org/apache/spark/launcher/LauncherServerSuite.java",
    "type": "method",
    "name": "infoChanged",
    "code": "handle.addListener(new SparkAppHandle.Listener() {\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });",
    "comment": "Make sure the server matched the client to the handle.\nLauncherServer will immediately close the server-side socket when the timeout is set\nto 0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/money/src/test/java/com/iluwater/money/MoneyTest.java",
    "type": "method",
    "name": "testMultiply_NegativeFactor",
    "code": "void testMultiply_NegativeFactor() {\n    Money money = new Money(100.00, \"USD\");\n\n    assertThrows(IllegalArgumentException.class, () -> money.multiply(-2));\n  }",
    "comment": "Test multiplying by a negative factor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "updateColumnDefaultValue",
    "code": "static TableChange updateColumnDefaultValue(String[] fieldNames, String newDefaultValue) {\n    return new UpdateColumnDefaultValue(fieldNames, newDefaultValue);\n  }",
    "comment": "Create a TableChange for updating the default value of a field.\n<p>\nThe name is used to find the field to update.\n<p>\nIf the field does not exist, the change will result in an {@link IllegalArgumentException}.\n\n@param fieldNames field names of the column to update\n@param newDefaultValue the new default value SQL string (Spark SQL dialect).\n@return a TableChange for the update"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/logging/Slf4jStdoutLogger.java",
    "type": "method",
    "name": "error",
    "code": "public void error(String msg) {\n        out.print(ERROR);\n        out.println(msg);\n    }",
    "comment": "These are the only methods we need in our primordial logger"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/DebugConfigurationListener.java",
    "type": "method",
    "name": "toString",
    "code": "private String toString(Object obj) {\n        String str;\n        if (obj != null && obj.getClass().isArray()) {\n            int n = Array.getLength(obj);\n            StringBuilder buf = new StringBuilder(256);\n            buf.append('[');\n            for (int i = 0; i < n; i++) {\n                if (i > 0) {\n                    buf.append(\", \");\n                }\n                buf.append(Array.get(obj, i));\n            }\n            buf.append(']');\n            str = buf.toString();\n        } else {\n            str = String.valueOf(obj);\n        }\n        return str;\n    }",
    "comment": "Creates a human-friendly string representation of the specified object.\n\n@param obj The object to create a string representation for, may be <code>null</code>.\n@return The string representation, never <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/CacheStore.java",
    "type": "method",
    "name": "set",
    "code": "public void set(final String userId, final UserAccount userAccount) {\n    cache.set(userId, userAccount);\n  }",
    "comment": "Delegate to backing cache store.\n\n@param userId {@link String}\n@param userAccount {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/memory/HeapMemoryAllocator.java",
    "type": "method",
    "name": "free",
    "code": "public void free(MemoryBlock memory) {\n    assert (memory.obj != null) :\n      \"baseObject was null; are you trying to use the on-heap allocator to free off-heap memory?\";\n    assert (memory.pageNumber != MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER) :\n      \"page has already been freed\";\n    assert ((memory.pageNumber == MemoryBlock.NO_PAGE_NUMBER)\n            || (memory.pageNumber == MemoryBlock.FREED_IN_TMM_PAGE_NUMBER)) :\n      \"TMM-allocated pages must first be freed via TMM.freePage(), not directly in allocator \" +\n        \"free()\";\n\n    final long size = memory.size();\n    if (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) {\n      memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_FREED_VALUE);\n    }\n\n    memory.pageNumber = MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER;\n\n    long[] array = (long[]) memory.obj;\n    memory.setObjAndOffset(null, 0);\n\n    long alignedSize = ((size + 7) / 8) * 8;\n    if (shouldPool(alignedSize)) {\n      synchronized (this) {\n        LinkedList<WeakReference<long[]>> pool =\n          bufferPoolsBySize.computeIfAbsent(alignedSize, k -> new LinkedList<>());\n        pool.add(new WeakReference<>(array));\n      }\n    }\n  }",
    "comment": "Mark the page as freed (so we can detect double-frees).\nAs an additional layer of defense against use-after-free bugs, we mutate the\nMemoryBlock to null out its reference to the long[] array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/object-mother/src/main/java/com/iluwatar/objectmother/RoyaltyObjectMother.java",
    "type": "method",
    "name": "createNotFlirtyQueen",
    "code": "public static Queen createNotFlirtyQueen() {\n    return new Queen();\n  }",
    "comment": "Method to create a not flirty queen.\n\n@return A not flirty {@link com.iluwatar.objectmother.Queen}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/distributions/Distributions.java",
    "type": "method",
    "name": "unspecified",
    "code": "public static UnspecifiedDistribution unspecified() {\n    return LogicalDistributions.unspecified();\n  }",
    "comment": "Creates a distribution where no promises are made about co-location of data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java",
    "type": "method",
    "name": "withMessage",
    "code": "default DiscoveryIssue withMessage(UnaryOperator<String> messageModifier) {\n\t\tString oldMessage = message();\n\t\tString newMessage = messageModifier.apply(oldMessage);\n\t\tif (oldMessage.equals(newMessage)) {\n\t\t\treturn this;\n\t\t}\n\t\treturn DiscoveryIssue.builder(severity(), newMessage) //\n\t\t\t\t.source(source()) //\n\t\t\t\t.cause(cause()) //\n\t\t\t\t.build();\n\t}",
    "comment": "Create a copy of this issue with the modified message produced by the\nsupplied operator."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/test/java/org/apache/maven/artifact/versioning/ComparableVersionTest.java",
    "type": "method",
    "name": "checkVersionsArrayEqual",
    "code": "private void checkVersionsArrayEqual(String[] array) {\n        for (int i = 0; i < array.length; ++i) {\n            for (int j = i; j < array.length; ++j) {\n                checkVersionsEqual(array[i], array[j]);\n            }\n        }\n    }",
    "comment": "compare against each other (including itself)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/AlbumListPage.java",
    "type": "method",
    "name": "navigateToPage",
    "code": "public AlbumListPage navigateToPage() {\n    try {\n      page = this.webClient.getPage(PAGE_URL);\n    } catch (IOException e) {\n      LOGGER.error(\"An error occurred on navigateToPage.\", e);\n    }\n    return this;\n  }",
    "comment": "Navigates to the Album List Page.\n\n@return {@link AlbumListPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "saslEncryption",
    "code": "public boolean saslEncryption() {\n    return conf.getBoolean(\"spark.authenticate.enableSaslEncryption\", false);\n  }",
    "comment": "Whether to enable SASL-based encryption when authenticating using SASL."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/TensorImpl.java",
    "type": "method",
    "name": "setTo",
    "code": "void setTo(Object src) {\n    if (src == null) {\n      if (hasDelegateBufferHandle(nativeHandle)) {\n        return;\n      }\n      throw new IllegalArgumentException(\n          \"Null inputs are allowed only if the Tensor is bound to a buffer handle.\");\n    }\n    throwIfTypeIsIncompatible(src);\n    throwIfSrcShapeIsIncompatible(src);\n    if (isBuffer(src)) {\n      setTo((Buffer) src);\n    } else if (dtype == DataType.STRING && shapeCopy.length == 0) {\n      // Update scalar string input with 1-d byte array.\n      writeScalar(nativeHandle, src);\n    } else if (src.getClass().isArray()) {\n      writeMultiDimensionalArray(nativeHandle, src);\n    } else {\n      writeScalar(nativeHandle, src);\n    }\n  }",
    "comment": "Copies the contents of the provided {@code src} object to the Tensor.\n\n<p>The {@code src} should either be a (multi-dimensional) array with a shape matching that of\nthis tensor, a {@link ByteBuffer} of compatible primitive type with a matching flat size, or\n{@code null} iff the tensor has an underlying delegate buffer handle.\n\n@throws IllegalArgumentException if the tensor is a scalar or if {@code src} is not compatible\nwith the tensor (for example, mismatched data types or shapes)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeRowWriter.java",
    "type": "method",
    "name": "getRow",
    "code": "public UnsafeRow getRow() {\n    row.setTotalSize(totalSize());\n    return row;\n  }",
    "comment": "Updates total size of the UnsafeRow using the size collected by BufferHolder, and returns\nthe UnsafeRow created at a constructor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/Logger.java",
    "type": "method",
    "name": "info",
    "code": "default void info(@Nonnull String message) {\n        log(Level.INFO, message);\n    }",
    "comment": "Logs an info message without an associated exception.\n\n@param message the info message to be logged"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryMetaAnnotationTests.java",
    "type": "method",
    "name": "annotationOnField",
    "code": "void annotationOnField() {\n\t\texecuteTestsForClass(AnnotationOnFieldTestCase.class).testEvents()//\n\t\t\t\t.assertStatistics(stats -> stats.started(1).succeeded(1));\n\t}",
    "comment": "Integration tests for the use of {@link TempDir} as a meta-annotation.\n\n@since 5.10"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/crypto/GcmTransportCipher.java",
    "type": "method",
    "name": "createHeaderByteBuffer",
    "code": "private ByteBuffer createHeaderByteBuffer() {\n            ByteBuffer encrypterHeader = encrypter.getHeader();\n            return ByteBuffer\n                    .allocate(encrypterHeader.remaining() + LENGTH_HEADER_BYTES)\n                    .putLong(encryptedCount)\n                    .put(encrypterHeader)\n                    .flip();\n        }",
    "comment": "If the ciphertext buffer cannot be fully written the target, transferTo may\nreturn with it containing some unwritten data. The initial call we'll explicitly\nset its limit to 0 to indicate the first call to transferTo.\nThe format of the output is:\n[8 byte length][Internal IV and header][Ciphertext][Auth Tag]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/InitializationError.java",
    "type": "method",
    "name": "InitializationError",
    "code": "public InitializationError(List<Throwable> errors) {\n        this.fErrors = errors;\n    }",
    "comment": "Construct a new {@code InitializationError} with one or more"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/saga/src/main/java/com/iluwatar/saga/choreography/Saga.java",
    "type": "method",
    "name": "setInValue",
    "code": "public Saga setInValue(Object value) {\n    if (chapters.isEmpty()) {\n      return this;\n    }\n    chapters.get(chapters.size() - 1).setInValue(value);\n    return this;\n  }",
    "comment": "set value to last chapter.\n\n@param value invalue\n@return this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/categories/IncludeCategories.java",
    "type": "method",
    "name": "createFilter",
    "code": "protected Filter createFilter(List<Class<?>> categories) {\n        return new IncludesAny(categories);\n    }",
    "comment": "Creates a {@link Filter} which is only passed by tests that are\ncategorized with any of the specified categories.\n\n@param categories Category classes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testNormalize4",
    "code": "public void testNormalize4() {\n        IMoney ms1 = MoneyBag.create(new Money(12, \"CHF\"), new Money(3, \"USD\"));\n        Money expected = new Money(-3, \"USD\");\n        assertEquals(expected, f12CHF.subtract(ms1));\n    }",
    "comment": "[12 CHF] - {[12 CHF][3 USD]} == [-3 USD]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Integer> create(int[][][] data) {\n    return Tensor.create(data, Integer.class);\n  }",
    "comment": "Creates a rank-3 tensor of {@code int} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/tracking/ObjectTracker.java",
    "type": "method",
    "name": "Keypoint",
    "code": "public Keypoint(final float x, final float y) {\n      this.x = x;\n      this.y = y;\n      this.score = 0;\n      this.type = -1;\n    }",
    "comment": "A simple class that records keypoint information, which includes\nlocal location, score and type. This will be used in calculating\nFrameChange."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "parseFullyQualifiedMethodName",
    "code": "public static String[] parseFullyQualifiedMethodName(String fullyQualifiedMethodName) {\n\t\tPreconditions.notBlank(fullyQualifiedMethodName, \"fullyQualifiedMethodName must not be null or blank\");\n\n\t\tint indexOfFirstHashtag = fullyQualifiedMethodName.indexOf('#');\n\t\tboolean validSyntax = (indexOfFirstHashtag > 0)\n\t\t\t\t&& (indexOfFirstHashtag < fullyQualifiedMethodName.length() - 1);\n\n\t\tPreconditions.condition(validSyntax,\n\t\t\t() -> \"[\" + fullyQualifiedMethodName + \"] is not a valid fully qualified method name: \"\n\t\t\t\t\t+ \"it must start with a fully qualified class name followed by a '#' \"\n\t\t\t\t\t+ \"and then the method name, optionally followed by a parameter list enclosed in parentheses.\");\n\n\t\tString className = fullyQualifiedMethodName.substring(0, indexOfFirstHashtag);\n\t\tString methodPart = fullyQualifiedMethodName.substring(indexOfFirstHashtag + 1);\n\t\tString methodName = methodPart;\n\t\tString methodParameters = \"\";\n\n\t\tif (methodPart.endsWith(\"()\")) {\n\t\t\tmethodName = methodPart.substring(0, methodPart.length() - 2);\n\t\t}\n\t\telse if (methodPart.endsWith(\")\")) {\n\t\t\tint indexOfLastOpeningParenthesis = methodPart.lastIndexOf('(');\n\t\t\tif ((indexOfLastOpeningParenthesis > 0) && (indexOfLastOpeningParenthesis < methodPart.length() - 1)) {\n\t\t\t\tmethodName = methodPart.substring(0, indexOfLastOpeningParenthesis);\n\t\t\t\tmethodParameters = methodPart.substring(indexOfLastOpeningParenthesis + 1, methodPart.length() - 1);\n\t\t\t}\n\t\t}\n\t\treturn new String[] { className, methodName, methodParameters };\n\n\t@API(status = INTERNAL, since = \"1.11\")\n\tpublic static String[] parseFullyQualifiedFieldName(String fullyQualifiedFieldName) {\n\t\tPreconditions.notBlank(fullyQualifiedFieldName, \"fullyQualifiedFieldName must not be null or blank\");\n\n\t\tint indexOfHashtag = fullyQualifiedFieldName.indexOf('#');\n\t\tboolean validSyntax = (indexOfHashtag > 0) && (indexOfHashtag < fullyQualifiedFieldName.length() - 1);\n\t\tPreconditions.condition(validSyntax,\n\t\t\t() -> \"[\" + fullyQualifiedFieldName + \"] is not a valid fully qualified field name: \"\n\t\t\t\t\t+ \"it must start with a fully qualified class name followed by a '#' \"\n\t\t\t\t\t+ \"and then the field name.\");\n\t\treturn fullyQualifiedFieldName.split(\"#\");\n\t}\n\n\tpublic static Set<Path> getAllClasspathRootDirectories() {\n\t\t// This is quite a hack, since sometimes the classpath is quite different\n\t\tString fullClassPath = System.getProperty(\"java.class.path\");\n\t\t// @formatter:off\n\t\treturn Arrays.stream(fullClassPath.split(File.pathSeparator))\n\t\t\t\t.map(Paths::get)\n\t\t\t\t.filter(Files::isDirectory)\n\t\t\t\t.collect(toSet());\n\t\t// @formatter:on\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInClasspathRoot(URI root, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\t// unmodifiable since returned by public, non-internal method(s)\n\t\treturn findAllClassesInClasspathRoot(root, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInClasspathRoot(URI root, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\treturn streamAllClassesInClasspathRoot(root, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInClasspathRoot(URI root, ClassFilter classFilter) {\n\t\treturn Collections.unmodifiableList(classpathScanner.scanForClassesInClasspathRoot(root, classFilter));\n\t}\n\n\tpublic static List<Resource> findAllResourcesInClasspathRoot(URI root, Predicate<Resource> resourceFilter) {\n\t\treturn Collections.unmodifiableList(classpathScanner.scanForResourcesInClasspathRoot(root, resourceFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInClasspathRoot(URI root, ClassFilter classFilter) {\n\t\treturn findAllClassesInClasspathRoot(root, classFilter).stream();\n\t}\n\n\tpublic static Stream<Resource> streamAllResourcesInClasspathRoot(URI root, Predicate<Resource> resourceFilter) {\n\t\treturn findAllResourcesInClasspathRoot(root, resourceFilter).stream();\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInPackage(String basePackageName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\t// unmodifiable since returned by public, non-internal method(s)\n\t\treturn findAllClassesInPackage(basePackageName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInPackage(String basePackageName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\treturn streamAllClassesInPackage(basePackageName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInPackage(String basePackageName, ClassFilter classFilter) {\n\t\treturn Collections.unmodifiableList(classpathScanner.scanForClassesInPackage(basePackageName, classFilter));\n\t}\n\n\tpublic static List<Resource> findAllResourcesInPackage(String basePackageName, Predicate<Resource> resourceFilter) {\n\t\treturn Collections.unmodifiableList(\n\t\t\tclasspathScanner.scanForResourcesInPackage(basePackageName, resourceFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInPackage(String basePackageName, ClassFilter classFilter) {\n\t\treturn findAllClassesInPackage(basePackageName, classFilter).stream();\n\t}\n\n\tpublic static Stream<Resource> streamAllResourcesInPackage(String basePackageName,\n\t\t\tPredicate<Resource> resourceFilter) {\n\t\treturn findAllResourcesInPackage(basePackageName, resourceFilter).stream();\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInModule(String moduleName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\t// unmodifiable since returned by public, non-internal method(s)\n\t\treturn findAllClassesInModule(moduleName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInModule(String moduleName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\treturn streamAllClassesInModule(moduleName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInModule(String moduleName, ClassFilter classFilter) {\n\t\treturn Collections.unmodifiableList(ModuleUtils.findAllClassesInModule(moduleName, classFilter));\n\t}\n\n\tpublic static List<Resource> findAllResourcesInModule(String moduleName, Predicate<Resource> resourceFilter) {\n\t\treturn Collections.unmodifiableList(ModuleUtils.findAllResourcesInModule(moduleName, resourceFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInModule(String moduleName, ClassFilter classFilter) {\n\t\treturn findAllClassesInModule(moduleName, classFilter).stream();\n\t}\n\n\tpublic static Stream<Resource> streamAllResourcesInModule(String moduleName, Predicate<Resource> resourceFilter) {\n\t\treturn findAllResourcesInModule(moduleName, resourceFilter).stream();\n\t}\n\n\tpublic static List<Class<?>> findNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\tSet<Class<?>> candidates = new LinkedHashSet<>();\n\t\tvisitNestedClasses(clazz, predicate, nestedClass -> {\n\t\t\tcandidates.add(nestedClass);\n\t\t\treturn true;\n\t\t});\n\t\treturn Collections.unmodifiableList(new ArrayList<>(candidates));\n\t}\n\n\t@API(status = INTERNAL, since = \"1.13\")\n\tpublic static boolean isNestedClassPresent(Class<?> clazz, Predicate<Class<?>> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\tboolean visitorWasNotCalled = visitNestedClasses(clazz, predicate, __ -> false);\n\t\treturn !visitorWasNotCalled;\n\t}\n\n\tpublic static Stream<Class<?>> streamNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate) {\n\t\treturn findNestedClasses(clazz, predicate).stream();\n\t}\n\n\tprivate static boolean visitNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate,\n\t\t\tVisitor<Class<?>> visitor) {\n\t\tif (!isSearchable(clazz)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isInnerClass(clazz) && predicate.test(clazz)) {\n\t\t\tdetectInnerClassCycle(clazz);\n\t\t}\n\n\t\ttry {\n\t\t\t// Candidates in current class\n\t\t\tfor (Class<?> nestedClass : clazz.getDeclaredClasses()) {\n\t\t\t\tif (predicate.test(nestedClass)) {\n\t\t\t\t\tdetectInnerClassCycle(nestedClass);\n\t\t\t\t\tboolean shouldContinue = visitor.accept(nestedClass);\n\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoClassDefFoundError error) {\n\t\t\tlogger.debug(error, () -> \"Failed to retrieve declared classes for \" + clazz.getName());\n\t\t}\n\n\t\t// Search class hierarchy\n\t\tboolean shouldContinue = visitNestedClasses(clazz.getSuperclass(), predicate, visitor);\n\t\tif (!shouldContinue) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Search interface hierarchy\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tshouldContinue = visitNestedClasses(ifc, predicate, visitor);\n\t\t\tif (!shouldContinue) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static void detectInnerClassCycle(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tString className = clazz.getName();\n\n\t\tif (noCyclesDetectedCache.contains(className)) {\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (isInnerClass(clazz) && isSearchable(superclass)) {\n\t\t\tfor (Class<?> enclosing = clazz.getEnclosingClass(); enclosing != null; enclosing = enclosing.getEnclosingClass()) {\n\t\t\t\tif (superclass.equals(enclosing)) {\n\t\t\t\t\tthrow new JUnitException(String.format(\"Detected cycle in inner class hierarchy between %s and %s\",\n\t\t\t\t\t\tclassName, enclosing.getName()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnoCyclesDetectedCache.add(className);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> Constructor<T> getDeclaredConstructor(Class<T> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\tConstructor<?>[] constructors = Arrays.stream(clazz.getDeclaredConstructors())//\n\t\t\t\t\t.filter(ctor -> !ctor.isSynthetic())//\n\t\t\t\t\t.toArray(Constructor[]::new);\n\n\t\t\tPreconditions.condition(constructors.length == 1,\n\t\t\t\t() -> String.format(\"Class [%s] must declare a single constructor\", clazz.getName()));\n\n\t\t\treturn (Constructor<T>) constructors[0];\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\n\t\t}\n\t}\n\n\tpublic static List<Constructor<?>> findConstructors(Class<?> clazz, Predicate<Constructor<?>> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\ttry {\n\t\t\t// @formatter:off\n\t\t\treturn Arrays.stream(clazz.getDeclaredConstructors())\n\t\t\t\t\t.filter(predicate)\n\t\t\t\t\t.collect(toUnmodifiableList());\n\t\t\t// @formatter:on\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\n\t\t}\n\t}\n\n\tpublic static List<Field> findFields(Class<?> clazz, Predicate<Field> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\treturn streamFields(clazz, predicate, traversalMode).collect(toUnmodifiableList());\n\t}\n\n\tpublic static Stream<Field> streamFields(Class<?> clazz, Predicate<Field> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\treturn findAllFieldsInHierarchy(clazz, traversalMode).stream()\n\t\t\t\t.filter(predicate)\n\t\t\t\t.distinct();\n\t\t// @formatter:on\n\t}\n\n\tprivate static List<Field> findAllFieldsInHierarchy(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\tField[] localFields = getDeclaredFields(clazz).stream()\n\t\t\t\t.filter(field -> !field.isSynthetic())\n\t\t\t\t.toArray(Field[]::new);\n\t\tField[] superclassFields = getSuperclassFields(clazz, traversalMode).stream()\n\t\t\t\t.filter(field -> isNotShadowedByLocalFields(field, localFields))\n\t\t\t\t.toArray(Field[]::new);\n\t\tField[] interfaceFields = getInterfaceFields(clazz, traversalMode).stream()\n\t\t\t\t.filter(field -> isNotShadowedByLocalFields(field, localFields))\n\t\t\t\t.toArray(Field[]::new);\n\t\t// @formatter:on\n\n\t\tList<Field> fields = new ArrayList<>(superclassFields.length + interfaceFields.length + localFields.length);\n\t\tif (traversalMode == TOP_DOWN) {\n\t\t\tCollections.addAll(fields, superclassFields);\n\t\t\tCollections.addAll(fields, interfaceFields);\n\t\t}\n\t\tCollections.addAll(fields, localFields);\n\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\tCollections.addAll(fields, interfaceFields);\n\t\t\tCollections.addAll(fields, superclassFields);\n\t\t}\n\t\treturn fields;\n\t}\n\n\tpublic static boolean isMethodPresent(Class<?> clazz, Predicate<Method> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\treturn findMethod(clazz, predicate).isPresent();\n\t}\n\n\t@API(status = DEPRECATED, since = \"1.4\")\n\t@Deprecated\n\tstatic Optional<Method> getMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\treturn tryToGetMethod(clazz, methodName, parameterTypes).toOptional();\n\t}\n\n\t@API(status = INTERNAL, since = \"1.4\")\n\tpublic static Try<Method> tryToGetMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\n\t\treturn Try.call(() -> clazz.getMethod(methodName, parameterTypes));\n\t}\n\n\t@API(status = INTERNAL, since = \"1.11\")\n\tpublic static Method getInterfaceMethodIfPossible(Method method, Class<?> targetClass) {\n\t\tif (!isPublic(method) || method.getDeclaringClass().isInterface()) {\n\t\t\treturn method;\n\t\t}\n\t\t// Try cached version of method in its declaring class\n\t\tMethod result = interfaceMethodCache.computeIfAbsent(method,\n\t\t\tm -> findInterfaceMethodIfPossible(m, m.getParameterTypes(), m.getDeclaringClass(), Object.class));\n\t\tif (result == method && targetClass != null) {\n\t\t\t// No interface method found yet -> try given target class (possibly a subclass of the\n\t\t\t// declaring class, late-binding a base class method to a subclass-declared interface:\n\t\t\t// see e.g. HashMap.HashIterator.hasNext)\n\t\t\tresult = findInterfaceMethodIfPossible(method, method.getParameterTypes(), targetClass,\n\t\t\t\tmethod.getDeclaringClass());\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static Method findInterfaceMethodIfPossible(Method method, Class<?>[] parameterTypes, Class<?> startClass,\n\t\t\tClass<?> endClass) {\n\n\t\tClass<?> current = startClass;\n\t\twhile (current != null && current != endClass) {\n\t\t\tfor (Class<?> ifc : current.getInterfaces()) {\n\t\t\t\ttry {\n\t\t\t\t\treturn ifc.getMethod(method.getName(), parameterTypes);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.getSuperclass();\n\t\t}\n\t\treturn method;\n\t}\n\n\tpublic static Optional<Method> findMethod(Class<?> clazz, String methodName, String parameterTypeNames) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\t\treturn findMethod(clazz, methodName, resolveParameterTypes(clazz, methodName, parameterTypeNames));\n\t}\n\n\t@API(status = INTERNAL, since = \"1.10\")\n\tpublic static Class<?>[] resolveParameterTypes(Class<?> clazz, String methodName, String parameterTypeNames) {\n\t\tif (StringUtils.isBlank(parameterTypeNames)) {\n\t\t\treturn EMPTY_CLASS_ARRAY;\n\t\t}\n\n\t\t// @formatter:off\n\t\treturn Arrays.stream(parameterTypeNames.split(\",\"))\n\t\t\t\t.map(String::trim)\n\t\t\t\t.map(typeName -> loadRequiredParameterType(clazz, methodName, typeName))\n\t\t\t\t.toArray(Class[]::new);\n\t\t// @formatter:on\n\t}\n\n\tprivate static Class<?> loadRequiredParameterType(Class<?> clazz, String methodName, String typeName) {\n\t\tClassLoader classLoader = ClassLoaderUtils.getClassLoader(clazz);\n\n\t\t// @formatter:off\n\t\treturn tryToLoadClass(typeName, classLoader)\n\t\t\t\t.getOrThrow(cause -> new JUnitException(\n\t\t\t\t\t\tString.format(\"Failed to load parameter type [%s] for method [%s] in class [%s].\",\n\t\t\t\t\t\t\t\ttypeName, methodName, clazz.getName()), cause));\n\t\t// @formatter:on\n\t}\n\n\tpublic static Optional<Method> findMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\t\tPreconditions.notNull(parameterTypes, \"Parameter types array must not be null\");\n\t\tPreconditions.containsNoNullElements(parameterTypes, \"Individual parameter types must not be null\");\n\n\t\treturn findMethod(clazz, method -> hasCompatibleSignature(method, methodName, parameterTypes));\n\t}\n\n\tprivate static Optional<Method> findMethod(Class<?> clazz, Predicate<Method> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\tfor (Class<?> current = clazz; isSearchable(current); current = current.getSuperclass()) {\n\t\t\t// Search for match in current type\n\t\t\tList<Method> methods = current.isInterface() ? getMethods(current) : getDeclaredMethods(current, BOTTOM_UP);\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (predicate.test(method)) {\n\t\t\t\t\treturn Optional.of(method);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Search for match in interfaces implemented by current type\n\t\t\tfor (Class<?> ifc : current.getInterfaces()) {\n\t\t\t\tOptional<Method> optional = findMethod(ifc, predicate);\n\t\t\t\tif (optional.isPresent()) {\n\t\t\t\t\treturn optional;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Optional.empty();\n\t}\n\n\t@API(status = STABLE, since = \"1.7\")\n\tpublic static Method getRequiredMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\treturn ReflectionUtils.findMethod(clazz, methodName, parameterTypes).orElseThrow(\n\t\t\t() -> new JUnitException(format(\"Could not find method [%s] in class [%s]\", methodName, clazz.getName())));\n\t}\n\n\tpublic static List<Method> findMethods(Class<?> clazz, Predicate<Method> predicate) {\n\t\treturn findMethods(clazz, predicate, TOP_DOWN);\n\t}\n\n\tpublic static List<Method> findMethods(Class<?> clazz, Predicate<Method> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\treturn streamMethods(clazz, predicate, traversalMode).collect(toUnmodifiableList());\n\t}\n\n\tpublic static Stream<Method> streamMethods(Class<?> clazz, Predicate<Method> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\treturn findAllMethodsInHierarchy(clazz, traversalMode).stream()\n\t\t\t\t.filter(predicate)\n\t\t\t\t.distinct();\n\t\t// @formatter:on\n\t}\n\n\tprivate static List<Method> findAllMethodsInHierarchy(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\tMethod[] localMethods = getDeclaredMethods(clazz, traversalMode).stream()\n\t\t\t\t.filter(method -> !method.isSynthetic())\n\t\t\t\t.toArray(Method[]::new);\n\t\tMethod[] superclassMethods = getSuperclassMethods(clazz, traversalMode).stream()\n\t\t\t\t.filter(method -> isNotOverriddenByLocalMethods(method, localMethods))\n\t\t\t\t.toArray(Method[]::new);\n\t\tMethod[] interfaceMethods = getInterfaceMethods(clazz, traversalMode).stream()\n\t\t\t\t.filter(method -> isNotOverriddenByLocalMethods(method, localMethods))\n\t\t\t\t.toArray(Method[]::new);\n\t\t// @formatter:on\n\n\t\tList<Method> methods = new ArrayList<>(\n\t\t\tsuperclassMethods.length + interfaceMethods.length + localMethods.length);\n\t\tif (traversalMode == TOP_DOWN) {\n\t\t\tCollections.addAll(methods, superclassMethods);\n\t\t\tCollections.addAll(methods, interfaceMethods);\n\t\t}\n\t\tCollections.addAll(methods, localMethods);\n\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\tCollections.addAll(methods, interfaceMethods);\n\t\t\tCollections.addAll(methods, superclassMethods);\n\t\t}\n\t\treturn methods;\n\t}\n\n\tprivate static List<Field> getFields(Class<?> clazz) {\n\t\treturn toSortedMutableList(clazz.getFields());\n\t}\n\n\tprivate static List<Field> getDeclaredFields(Class<?> clazz) {\n\t\treturn toSortedMutableList(clazz.getDeclaredFields());\n\t}\n\n\tprivate static List<Method> getMethods(Class<?> clazz) {\n\t\treturn toSortedMutableList(clazz.getMethods());\n\t}\n\n\tprivate static List<Method> getDeclaredMethods(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\t// Note: getDefaultMethods() already sorts the methods,\n\t\tList<Method> defaultMethods = getDefaultMethods(clazz);\n\t\tList<Method> declaredMethods = toSortedMutableList(clazz.getDeclaredMethods());\n\n\t\t// Take the traversal mode into account in order to retain the inherited\n\t\t// nature of interface default methods.\n\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\tdeclaredMethods.addAll(defaultMethods);\n\t\t\treturn declaredMethods;\n\t\t}\n\t\telse {\n\t\t\tdefaultMethods.addAll(declaredMethods);\n\t\t\treturn defaultMethods;\n\t\t}\n\t}\n\n\tprivate static List<Method> getDefaultMethods(Class<?> clazz) {\n\t\t// @formatter:off\n\t\t// Visible default methods are interface default methods that have not\n\t\t// been overridden.\n\t\tList<Method> visibleDefaultMethods = Arrays.stream(clazz.getMethods())\n\t\t\t\t.filter(Method::isDefault)\n\t\t\t\t.collect(toCollection(ArrayList::new));\n\t\tif (visibleDefaultMethods.isEmpty()) {\n\t\t\treturn visibleDefaultMethods;\n\t\t}\n\t\treturn Arrays.stream(clazz.getInterfaces())\n\t\t\t\t.map(ReflectionUtils::getMethods)\n\t\t\t\t.flatMap(List::stream)\n\t\t\t\t.filter(visibleDefaultMethods::contains)\n\t\t\t\t.collect(toCollection(ArrayList::new));\n\t\t// @formatter:on\n\t}\n\n\tprivate static List<Field> toSortedMutableList(Field[] fields) {\n\t\treturn toSortedMutableList(fields, ReflectionUtils::defaultFieldSorter);\n\t}\n\n\tprivate static List<Method> toSortedMutableList(Method[] methods) {\n\t\treturn toSortedMutableList(methods, ReflectionUtils::defaultMethodSorter);\n\t}\n\n\tprivate static <T> List<T> toSortedMutableList(T[] items, Comparator<? super T> comparator) {\n\t\tList<T> result = new ArrayList<>(items.length);\n\t\tCollections.addAll(result, items);\n\t\tresult.sort(comparator);\n\t\treturn result;\n\t}\n\n\tprivate static int defaultFieldSorter(Field field1, Field field2) {\n\t\treturn Integer.compare(field1.getName().hashCode(), field2.getName().hashCode());\n\t}\n\n\tprivate static int defaultMethodSorter(Method method1, Method method2) {\n\t\tString name1 = method1.getName();\n\t\tString name2 = method2.getName();\n\t\tint comparison = Integer.compare(name1.hashCode(), name2.hashCode());\n\t\tif (comparison == 0) {\n\t\t\tcomparison = name1.compareTo(name2);\n\t\t\tif (comparison == 0) {\n\t\t\t\tcomparison = method1.toString().compareTo(method2.toString());\n\t\t\t}\n\t\t}\n\t\treturn comparison;\n\t}\n\n\tprivate static List<Method> getInterfaceMethods(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tList<Method> allInterfaceMethods = new ArrayList<>();\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\n\t\t\t// @formatter:off\n\t\t\tMethod[] localInterfaceMethods = getMethods(ifc).stream()\n\t\t\t\t\t.filter(m -> !isAbstract(m))\n\t\t\t\t\t.toArray(Method[]::new);\n\n\t\t\tMethod[] superinterfaceMethods = getInterfaceMethods(ifc, traversalMode).stream()\n\t\t\t\t\t.filter(method -> isNotOverriddenByLocalMethods(method, localInterfaceMethods))\n\t\t\t\t\t.toArray(Method[]::new);\n\t\t\t// @formatter:on\n\n\t\t\tif (traversalMode == TOP_DOWN) {\n\t\t\t\tCollections.addAll(allInterfaceMethods, superinterfaceMethods);\n\t\t\t}\n\t\t\tCollections.addAll(allInterfaceMethods, localInterfaceMethods);\n\t\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\t\tCollections.addAll(allInterfaceMethods, superinterfaceMethods);\n\t\t\t}\n\t\t}\n\t\treturn allInterfaceMethods;\n\t}\n\n\tprivate static List<Field> getInterfaceFields(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tList<Field> allInterfaceFields = new ArrayList<>();\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tField[] localInterfaceFields = ifc.getFields();\n\t\t\tArrays.sort(localInterfaceFields, ReflectionUtils::defaultFieldSorter);\n\n\t\t\t// @formatter:off\n\t\t\tField[] superinterfaceFields = getInterfaceFields(ifc, traversalMode).stream()\n\t\t\t\t\t.filter(field -> isNotShadowedByLocalFields(field, localInterfaceFields))\n\t\t\t\t\t.toArray(Field[]::new);\n\t\t\t// @formatter:on\n\n\t\t\tif (traversalMode == TOP_DOWN) {\n\t\t\t\tCollections.addAll(allInterfaceFields, superinterfaceFields);\n\t\t\t}\n\t\t\tCollections.addAll(allInterfaceFields, localInterfaceFields);\n\t\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\t\tCollections.addAll(allInterfaceFields, superinterfaceFields);\n\t\t\t}\n\t\t}\n\t\treturn allInterfaceFields;\n\t}\n\n\tprivate static List<Field> getSuperclassFields(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (!isSearchable(superclass)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn findAllFieldsInHierarchy(superclass, traversalMode);\n\t}\n\n\tprivate static boolean isNotShadowedByLocalFields(Field field, Field[] localFields) {\n\t\tif (useLegacySearchSemantics) {\n\t\t\tfor (Field local : localFields) {\n\t\t\t\tif (local.getName().equals(field.getName())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static List<Method> getSuperclassMethods(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (!isSearchable(superclass)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn findAllMethodsInHierarchy(superclass, traversalMode);\n\t}\n\n\tprivate static boolean isNotOverriddenByLocalMethods(Method method, Method[] localMethods) {\n\t\tfor (Method local : localMethods) {\n\t\t\tif (isMethodOverriddenBy(method, local)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static boolean isMethodOverriddenBy(Method upper, Method lower) {\n\t\t// If legacy search semantics are enabled, skip to hasCompatibleSignature() check.\n\t\tif (!useLegacySearchSemantics) {\n\t\t\t// A static method cannot override anything.\n\t\t\tif (Modifier.isStatic(lower.getModifiers())) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Cannot override a private, static, or final method.\n\t\t\tint modifiers = upper.getModifiers();\n\t\t\tif (Modifier.isPrivate(modifiers) || Modifier.isStatic(modifiers) || Modifier.isFinal(modifiers)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Cannot override a package-private method in another package.\n\t\t\tif (isPackagePrivate(upper) && !declaredInSamePackage(upper, lower)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn hasCompatibleSignature(upper, lower.getName(), lower.getParameterTypes());\n\t}\n\n\tprivate static boolean isPackagePrivate(Member member) {\n\t\tint modifiers = member.getModifiers();\n\t\treturn !(Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers) || Modifier.isPrivate(modifiers));\n\t}\n\n\tprivate static boolean declaredInSamePackage(Method m1, Method m2) {\n\t\treturn getPackageName(m1.getDeclaringClass()).equals(getPackageName(m2.getDeclaringClass()));\n\t}\n\n\tprivate static boolean hasCompatibleSignature(Method candidate, String methodName, Class<?>[] parameterTypes) {\n\t\tif (!methodName.equals(candidate.getName())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (parameterTypes.length != candidate.getParameterCount()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?>[] candidateParameterTypes = candidate.getParameterTypes();\n\t\t// trivial case: parameter types exactly match\n\t\tif (Arrays.equals(parameterTypes, candidateParameterTypes)) {\n\t\t\treturn true;\n\t\t}\n\t\t// param count is equal, but types do not match exactly: check for method sub-signatures\n\t\t// https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.2\n\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\tClass<?> lowerType = parameterTypes[i];\n\t\t\tClass<?> upperType = candidateParameterTypes[i];\n\t\t\tif (!upperType.isAssignableFrom(lowerType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t// lower is sub-signature of upper: check for generics in upper method\n\t\tif (isGeneric(candidate)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean isGeneric(Method method) {\n\t\treturn isGeneric(method.getGenericReturnType())\n\t\t\t\t|| Arrays.stream(method.getGenericParameterTypes()).anyMatch(ReflectionUtils::isGeneric);\n\t}\n\n\tprivate static boolean isGeneric(Type type) {\n\t\treturn type instanceof TypeVariable || type instanceof GenericArrayType;\n\t}\n\n\t@API(status = INTERNAL, since = \"1.11\")\n\t@SuppressWarnings(\"deprecation\") // \"AccessibleObject.isAccessible()\" is deprecated in Java 9\n\tpublic static <T extends Executable> T makeAccessible(T executable) {\n\t\tif ((!isPublic(executable) || !isPublic(executable.getDeclaringClass())) && !executable.isAccessible()) {\n\t\t\texecutable.setAccessible(true);\n\t\t}\n\t\treturn executable;\n\t}\n\n\t@API(status = INTERNAL, since = \"1.12\")\n\t@SuppressWarnings(\"deprecation\") // \"AccessibleObject.isAccessible()\" is deprecated in Java 9\n\tpublic static Field makeAccessible(Field field) {\n\t\tif ((!isPublic(field) || !isPublic(field.getDeclaringClass()) || isFinal(field)) && !field.isAccessible()) {\n\t\t\tfield.setAccessible(true);\n\t\t}\n\t\treturn field;\n\t}\n\n\tpublic static Set<Class<?>> getAllAssignmentCompatibleClasses(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\n\t\tSet<Class<?>> result = new LinkedHashSet<>();\n\t\tgetAllAssignmentCompatibleClasses(clazz, result);\n\t\treturn result;\n\t}\n\n\tprivate static void getAllAssignmentCompatibleClasses(Class<?> clazz, Set<Class<?>> result) {\n\t\tfor (Class<?> current = clazz; current != null; current = current.getSuperclass()) {\n\t\t\tresult.add(current);\n\t\t\tfor (Class<?> interfaceClass : current.getInterfaces()) {\n\t\t\t\tif (!result.contains(interfaceClass)) {\n\t\t\t\t\tgetAllAssignmentCompatibleClasses(interfaceClass, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static boolean isSearchable(Class<?> clazz) {\n\t\treturn (clazz != null && clazz != Object.class);\n\t}\n\n\tprivate static Throwable getUnderlyingCause(Throwable t) {\n\t\tif (t instanceof InvocationTargetException) {\n\t\t\treturn getUnderlyingCause(((InvocationTargetException) t).getTargetException());\n\t\t}\n\t\treturn t;\n\t}\n\n\tprivate static boolean getLegacySearchSemanticsFlag() {\n\t\tString rawValue = System.getProperty(USE_LEGACY_SEARCH_SEMANTICS_PROPERTY_NAME);\n\t\tif (StringUtils.isBlank(rawValue)) {\n\t\t\treturn false;\n\t\t}\n\t\tString value = rawValue.trim().toLowerCase();\n\t\tboolean isTrue = \"true\".equals(value);\n\t\tPreconditions.condition(isTrue || \"false\".equals(value), () -> USE_LEGACY_SEARCH_SEMANTICS_PROPERTY_NAME\n\t\t\t\t+ \" property must be 'true' or 'false' (ignoring case): \" + rawValue);\n\t\treturn isTrue;\n\t}\n\n\tprivate interface Visitor<T> {\n\n\t\tboolean accept(T value);\n\n\t}\n\n}",
    "comment": "@return {@code true} if the visitor should continue searching;\n{@code false} if the visitor should stop"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/ClassMap.java",
    "type": "method",
    "name": "getPublicMethod",
    "code": "private static Method getPublicMethod(Class<?> clazz, String name, Class<?>... paramTypes) {\n        // if this class is public, then try to get it\n        if ((clazz.getModifiers() & Modifier.PUBLIC) != 0) {\n            try {\n                return clazz.getMethod(name, paramTypes);\n            } catch (NoSuchMethodException e) {\n                // If the class does not have the method, then neither its superclass\n                // nor any of its interfaces has it so quickly return null.\n                return null;\n            }\n        }\n\n        //  try the superclass\n        Class<?> superclazz = clazz.getSuperclass();\n\n        if (superclazz != null) {\n            Method superclazzMethod = getPublicMethod(superclazz, name, paramTypes);\n\n            if (superclazzMethod != null) {\n                return superclazzMethod;\n            }\n        }\n\n        // and interfaces\n        Class<?>[] interfaces = clazz.getInterfaces();\n\n        for (Class<?> anInterface : interfaces) {\n            Method interfaceMethod = getPublicMethod(anInterface, name, paramTypes);\n\n            if (interfaceMethod != null) {\n                return interfaceMethod;\n            }\n        }\n\n        return null;\n    }",
    "comment": "Looks up the method with specified name and signature in the first public\nsuperclass or implemented interface of the class.\n\n@param clazz      the class whose method is sought\n@param name       the name of the method\n@param paramTypes the classes of method parameters"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProjectBuilderRequest.java",
    "type": "method",
    "name": "build",
    "code": "static ProjectBuilderRequest build(@Nonnull Session session, @Nonnull Path path) {\n        return builder()\n                .session(requireNonNull(session, \"session cannot be null\"))\n                .path(requireNonNull(path, \"path cannot be null\"))\n                .build();\n    }",
    "comment": "Creates a new ProjectBuilderRequest with the specified session and path.\n\n@param session the Maven session\n@param path the path to the project to build\n@return a new ProjectBuilderRequest\n@throws NullPointerException if session or path is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/AppsWithRecoveryDisabled.java",
    "type": "method",
    "name": "disableRecoveryOfApp",
    "code": "public static void disableRecoveryOfApp(String appId) {\n    Preconditions.checkNotNull(appId);\n    INSTANCE.appsWithRecoveryDisabled.add(appId);\n  }",
    "comment": "Add an application for which recovery is disabled.\n@param appId application id"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "filter",
    "code": "public Builder filter(MetricFilter filter) {\n            this.filter = filter;\n            return this;\n        }",
    "comment": "Only report metrics which match the given filter.\n\n@param filter a {@link MetricFilter}\n@return {@code this}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "getTotalMemoryConsumption",
    "code": "public long getTotalMemoryConsumption() {\n    long totalDataPagesSize = 0L;\n    for (MemoryBlock dataPage : dataPages) {\n      totalDataPagesSize += dataPage.size();\n    }\n    return totalDataPagesSize + ((longArray != null) ? longArray.memoryBlock().size() : 0L);\n  }",
    "comment": "Returns the total amount of memory, in bytes, consumed by this map's managed structures."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Short expected, Short actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "setProjectBuildingRequest",
    "code": "public void setProjectBuildingRequest(ProjectBuildingRequest projectBuildingRequest) {\n        this.projectBuilderConfiguration = projectBuildingRequest;\n    }",
    "comment": "Sets the project building request from which this project instance was created. <strong>Warning:</strong> This is\na utility method that is meant to assist integrators of Maven, it must not be used by Maven plugins.\n\n@param projectBuildingRequest The project building request, may be {@code null}.\n@since 2.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "replaceIsoControlCharacters",
    "code": "public static String replaceIsoControlCharacters(String str, String replacement) {\n\t\tPreconditions.notNull(replacement, \"replacement must not be null\");\n\t\treturn str == null ? null : ISO_CONTROL_PATTERN.matcher(str).replaceAll(replacement);\n\t}",
    "comment": "Replace all ISO control characters in the supplied {@link String}.\n\n@param str the string in which to perform the replacement; may be {@code null}\n@param replacement the replacement string; never {@code null}\n@return the supplied string with all control characters replaced, or\n{@code null} if the supplied string was {@code null}\n@since 1.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/DefaultParallelExecutionConfigurationStrategy.java",
    "type": "method",
    "name": "createConfiguration",
    "code": "public ParallelExecutionConfiguration createConfiguration(ConfigurationParameters configurationParameters) {\n\t\t\tBigDecimal factor = configurationParameters.get(CONFIG_DYNAMIC_FACTOR_PROPERTY_NAME,\n\t\t\t\tBigDecimal::new).orElse(BigDecimal.ONE);\n\n\t\t\tPreconditions.condition(factor.compareTo(BigDecimal.ZERO) > 0,\n\t\t\t\t() -> String.format(\"Factor '%s' specified via configuration parameter '%s' must be greater than 0\",\n\t\t\t\t\tfactor, CONFIG_DYNAMIC_FACTOR_PROPERTY_NAME));\n\n\t\t\tint parallelism = Math.max(1,\n\t\t\t\tfactor.multiply(BigDecimal.valueOf(Runtime.getRuntime().availableProcessors())).intValue());\n\n\t\t\tint maxPoolSize = configurationParameters.get(CONFIG_DYNAMIC_MAX_POOL_SIZE_FACTOR_PROPERTY_NAME,\n\t\t\t\tBigDecimal::new).map(maxPoolSizeFactor -> {\n\t\t\t\t\tPreconditions.condition(maxPoolSizeFactor.compareTo(BigDecimal.ONE) >= 0,\n\t\t\t\t\t\t() -> String.format(\n\t\t\t\t\t\t\t\"Factor '%s' specified via configuration parameter '%s' must be greater than or equal to 1\",\n\t\t\t\t\t\t\tfactor, CONFIG_DYNAMIC_MAX_POOL_SIZE_FACTOR_PROPERTY_NAME));\n\t\t\t\t\treturn maxPoolSizeFactor.multiply(BigDecimal.valueOf(parallelism)).intValue();\n\t\t\t\t}).orElseGet(() -> 256 + parallelism);\n\n\t\t\tboolean saturate = configurationParameters.get(CONFIG_DYNAMIC_SATURATE_PROPERTY_NAME,\n\t\t\t\tBoolean::valueOf).orElse(true);\n\n\t\t\treturn new DefaultParallelExecutionConfiguration(parallelism, parallelism, maxPoolSize, parallelism,\n\t\t\t\tKEEP_ALIVE_SECONDS, __ -> saturate);\n\t\t}",
    "comment": "Computes the desired parallelism based on the number of available\nprocessors/cores multiplied by the {@value #CONFIG_DYNAMIC_FACTOR_PROPERTY_NAME}\nconfiguration parameter."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java",
    "type": "method",
    "name": "beforeEach",
    "code": "public void beforeEach(ExtensionContext context) {\n\t\tinstallFailureTracker(context);\n\t\tcontext.getRequiredTestInstances().getAllInstances() //\n\t\t\t\t.forEach(instance -> injectInstanceFields(context, instance));\n\t}",
    "comment": "Perform field injection for non-private, non-static fields (i.e.,\ninstance fields) of type {@link Path} or {@link File} that are annotated\nwith {@link TempDir @TempDir}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(short expected, short actual) {\n        Assert.assertEquals(expected, actual);\n    }",
    "comment": "Asserts that two shorts are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelBuilder.java",
    "type": "method",
    "name": "transformFileToRaw",
    "code": "Model transformFileToRaw(Model model) {\n            if (model.getDependencies().isEmpty()) {\n                return model;\n            }\n            List<Dependency> newDeps = new ArrayList<>(model.getDependencies().size());\n            boolean changed = false;\n            for (Dependency dep : model.getDependencies()) {\n                Dependency newDep = null;\n                if (dep.getVersion() == null) {\n                    newDep = inferDependencyVersion(model, dep);\n                    if (newDep != null) {\n                        changed = true;\n                    }\n                }\n                newDeps.add(newDep == null ? dep : newDep);\n            }\n            return changed ? model.withDependencies(newDeps) : model;\n        }",
    "comment": "Transform raw model to build pom.\nInfer inner reactor dependencies version"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestFailure.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n        return fFailedTest + \": \" + fThrownException.getMessage();\n    }",
    "comment": "Returns a short description of the failure."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "parseAll",
    "code": "public static Stream<? extends DiscoverySelector> parseAll(Collection<DiscoverySelectorIdentifier> identifiers) {\n\t\treturn DiscoverySelectorIdentifierParsers.parseAll(identifiers);\n\t}",
    "comment": "Parse the supplied {@link DiscoverySelectorIdentifier\nDiscoverySelectorIdentifiers}.\n\n@param identifiers the {@code DiscoverySelectorIdentifiers} to parse;\nnever {@code null}\n@return a stream of the corresponding {@link DiscoverySelector DiscoverySelectors};\nnever {@code null} but potentially empty\n@since 1.11\n@see DiscoverySelectorIdentifierParser"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/runner/BaseTestRunner.java",
    "type": "method",
    "name": "processArguments",
    "code": "protected String processArguments(String[] args) {\n        String suiteName = null;\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].equals(\"-noloading\")) {\n                setLoading(false);\n            } else if (args[i].equals(\"-nofilterstack\")) {\n                fgFilterStack = false;\n            } else if (args[i].equals(\"-c\")) {\n                if (args.length > i + 1) {\n                    suiteName = extractClassName(args[i + 1]);\n                } else {\n                    System.out.println(\"Missing Test class name\");\n                }\n                i++;\n            } else {\n                suiteName = args[i];\n            }\n        }\n        return suiteName;\n    }",
    "comment": "Processes the command line arguments and\nreturns the name of the suite class to run or null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/map-reduce/src/main/java/com/iluwatar/Mapper.java",
    "type": "method",
    "name": "Mapper",
    "code": "private Mapper() {\n    throw new UnsupportedOperationException(\n        \"Mapper is a utility class and cannot be instantiated.\");\n  }",
    "comment": "The Mapper class is responsible for processing an input string and generating a map of word\noccurrences."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/MyDoubleSum.java",
    "type": "method",
    "name": "merge",
    "code": "@Override public void merge(MutableAggregationBuffer buffer1, Row buffer2) {\n    if (!buffer2.isNullAt(0)) {\n      if (buffer1.isNullAt(0)) {\n        buffer1.update(0, buffer2.getDouble(0));\n      } else {\n        Double newValue = buffer2.getDouble(0) + buffer1.getDouble(0);\n        buffer1.update(0, newValue);\n      }\n    }\n  }",
    "comment": "buffer1 and buffer2 have the same structure.\nWe only update the buffer1 when the input buffer2's value is not null.\nIf the buffer value (intermediate result of the sum) is still null,\nwe set the it as the input buffer's value.\nOtherwise, we add the input buffer's value (buffer1) to the mutable\nbuffer's value (buffer2)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/Scope.java",
    "type": "method",
    "name": "withName",
    "code": "public Scope withName(String opName) {\n    return new Scope(env, nameScope.withName(opName), controlDependencies);\n  }",
    "comment": "Return a new scope that uses the provided name for an op.\n\n<p>Operations created within this scope will have a name of the form {@code\nname/opName[_suffix]}. This lets you name a specific operator more meaningfully.\n\n<p>Names must match the regular expression {@code [A-Za-z0-9.][A-Za-z0-9_.\\-]*}\n\n@param opName name for an operator in the returned scope\n@return a new Scope that uses opName for operations.\n@throws IllegalArgumentException if the name is invalid"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "findMethod",
    "code": "public static Optional<Method> findMethod(Class<?> clazz, String methodName, String parameterTypeNames) {\n\t\treturn ReflectionUtils.findMethod(clazz, methodName, parameterTypeNames);\n\t}",
    "comment": "Find the first {@link Method} of the supplied class or interface that\nmeets the specified criteria, beginning with the specified class or\ninterface and traversing up the type hierarchy until such a method is\nfound or the type hierarchy is exhausted.\n\n<p>As of JUnit Platform 1.10, this method uses the {@link ClassLoader} of\nthe supplied {@code clazz} to load parameter types instead of using the\n<em>default</em> {@code ClassLoader}, which allows parameter types to be\nresolved in different {@code ClassLoader} arrangements.\n\n<p>The algorithm does not search for methods in {@link java.lang.Object}.\n\n@param clazz the class or interface in which to find the method; never {@code null}\n@param methodName the name of the method to find; never {@code null} or empty\n@param parameterTypeNames the fully qualified names of the types of parameters\naccepted by the method, if any, provided as a comma-separated list\n@return an {@code Optional} containing the method found; never {@code null}\nbut potentially empty if no such method could be found\n@see #findMethod(Class, String, Class...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/AlbumPage.java",
    "type": "method",
    "name": "changeNumberOfSongs",
    "code": "public AlbumPage changeNumberOfSongs(int numberOfSongs) {\n    var numberOfSongsNumberField = (HtmlNumberInput) page.getElementById(\"numberOfSongs\");\n    numberOfSongsNumberField.setText(Integer.toString(numberOfSongs));\n    return this;\n  }",
    "comment": "Sets the number of songs number input field.\n\n@param numberOfSongs the new number of songs value to be set\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "exists",
    "code": "public Object exists(List<Object> args) {\n        if (args.size() != 1) {\n            throw new IllegalArgumentException(\"exists function requires exactly one argument\");\n        }\n        String path = ConditionParser.toString(args.get(0));\n        return context.exists(path, true);\n    }",
    "comment": "Checks if a file or directory exists at the given path.\n\n@param args A list containing a single string argument representing the path\n@return {@code true} if the file or directory exists, {@code false} otherwise\n@throws IllegalArgumentException if the number of arguments is not exactly one\n@throws ModelBuilderException if a problem occurs while walking the file system\n@throws InterpolatorException if an error occurs during interpolation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-di/src/main/java/org/apache/maven/di/Injector.java",
    "type": "method",
    "name": "create",
    "code": "static Injector create() {\n        return new InjectorImpl();\n    }",
    "comment": "Creates a new Injector instance with default settings.\n\n@return a new Injector instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/repository/Authentication.java",
    "type": "method",
    "name": "setPassword",
    "code": "public void setPassword(String password) {\n        this.password = password;\n    }",
    "comment": "Set the user's password which is used when connecting to the repository.\n\n@param password password of the user"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProjectActivation.java",
    "type": "method",
    "name": "deactivateRequiredProject",
    "code": "public void deactivateRequiredProject(String selector) {\n        this.activations.add(new ProjectActivationSettings(selector, ActivationSettings.deactivated()));\n    }",
    "comment": "Mark a project as required and deactivated.\n@param selector The selector of the project."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "nestedContainer",
    "code": "public static Condition<Event> nestedContainer(Class<?> clazz, Condition<Event> condition) {\n\t\treturn allOf(nestedContainer(clazz), condition);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@linkplain Event#getTestDescriptor() test descriptor} is\na {@linkplain TestDescriptor#isContainer() container}, and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the\nsimple names of the supplied {@link Class} and all of its\n{@linkplain Class#getEnclosingClass() enclosing classes}.\n\n<p>For example, {@code nestedContainer(MyNestedTests.class, displayName(\"my display name\"))}\ncan be used to match against a nested container with the given display name.\n\n<p>Please note that this method does not differentiate between static\nnested classes and non-static member classes (e.g., inner classes).\n\n@since 1.8\n@see #nestedContainer(Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/JupiterEngineExecutionContext.java",
    "type": "method",
    "name": "beforeAllMethodsExecuted",
    "code": "public void beforeAllMethodsExecuted(boolean beforeAllMethodsExecuted) {\n\t\tthis.beforeAllMethodsExecuted = beforeAllMethodsExecuted;\n\t}",
    "comment": "Track that an attempt was made to execute {@code @BeforeAll} methods."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/transfer/TransferResourceIdentifier.java",
    "type": "method",
    "name": "TransferResourceIdentifier",
    "code": "record TransferResourceIdentifier(String repositoryId, String repositoryUrl, String resourceName, @Nullable File file) {\n    TransferResourceIdentifier(TransferResource resource) {\n        this(resource.getRepositoryId(), resource.getRepositoryUrl(), resource.getResourceName(), resource.getFile());\n    }\n}",
    "comment": "Immutable identifier of a {@link TransferResource}.\nThe {@link TransferResource} is not immutable and does not implement {@code Objects#equals} and {@code Objects#hashCode} methods,\nmaking it not very suitable for usage in collections."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/RequestTraceHelper.java",
    "type": "method",
    "name": "enter",
    "code": "public static ResolverTrace enter(Session session, Object data) {\n        InternalSession iSession = InternalSession.from(session);\n        org.apache.maven.api.services.RequestTrace trace = data instanceof Request<?> req && req.getTrace() != null\n                ? req.getTrace()\n                : new org.apache.maven.api.services.RequestTrace(iSession.getCurrentTrace(), data);\n        iSession.setCurrentTrace(trace);\n        return new ResolverTrace(session, trace.context(), toResolver(trace), trace);\n    }",
    "comment": "Creates a new trace entry and updates the session's current trace\n@param session The current Maven session\n@param data The data object to associate with the trace\n@return A new ResolverTrace containing both Maven and Resolver trace information"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/server/StreamManager.java",
    "type": "method",
    "name": "checkAuthorization",
    "code": "public void checkAuthorization(TransportClient client, long streamId) { }",
    "comment": "Verify that the client is authorized to read from the given stream.\n\n@throws SecurityException If client is not authorized."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/PhaseId.java",
    "type": "method",
    "name": "of",
    "code": "public static synchronized PhaseId of(String phase) {\n        return INSTANCES.computeIfAbsent(phase, PhaseId::new);\n    }",
    "comment": "Parses the phase identifier.\n\n@param phase the phase identifier.\n@return the {@link PhaseId}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "makeValid",
    "code": "public UTF8String makeValid() {\n    if (isValid()) return this;\n    return UTF8String.fromBytes(makeValidBytes());\n  }",
    "comment": "Returns a validated version of the current UTF-8 string by replacing invalid UTF-8 sequences\nwith the Unicode replacement character (U+FFFD), as per the rules defined in the Unicode\nstandard 15, Section 3.9, Paragraph D86, Table 3-7. This behaviour is consistent with the\nbehaviour of `UnicodeString` in ICU4C.\n\n@return A new UTF8String that is a valid UTF8 string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "allocateDoubleBuffer",
    "code": "public static DoubleBuffer allocateDoubleBuffer(int numElements) {\n    return ByteBuffer.allocateDirect(numElements * DOUBLE_SIZE_BYTES)\n        .order(ByteOrder.nativeOrder())\n        .asDoubleBuffer();\n  }",
    "comment": "Allocates a new direct {@link java.nio.DoubleBuffer} with native byte order with specified\n\n@param numElements capacity (number of elements) of result buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "stringToBytes",
    "code": "public static ByteBuffer stringToBytes(String s) {\n    return ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8));\n  }",
    "comment": "Convert the given string to a byte buffer. The resulting buffer can be\nconverted back to the same string through {@link #bytesToString(ByteBuffer)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/Murmur3_x86_32.java",
    "type": "method",
    "name": "hashUnsafeBytes2",
    "code": "public static int hashUnsafeBytes2(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes >= 0): \"lengthInBytes cannot be negative\";\n    int lengthAligned = lengthInBytes - lengthInBytes % 4;\n    int h1 = hashBytesByInt(base, offset, lengthAligned, seed);\n    int k1 = 0;\n    for (int i = lengthAligned, shift = 0; i < lengthInBytes; i++, shift += 8) {\n      k1 ^= (Platform.getByte(base, offset + i) & 0xFF) << shift;\n    }\n    h1 ^= mixK1(k1);\n    return fmix(h1, lengthInBytes);\n  }",
    "comment": "This is compatible with original and another implementations.\nUse this method for new components after Spark 2.3."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionParser.java",
    "type": "method",
    "name": "parse",
    "code": "public Object parse(String expression) {\n        this.tokens = tokenize(expression);\n        this.current = 0;\n        return parseExpression();\n    }",
    "comment": "Parses the given expression and returns the result of the evaluation.\n\n@param expression the expression to be parsed\n@return the result of parsing and evaluating the expression"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/ExpressionImplUtils.java",
    "type": "method",
    "name": "getSparkVersion",
    "code": "public static UTF8String getSparkVersion() {\n    String shortVersion = VersionUtils.shortVersion(SparkBuildInfo.spark_version());\n    String revision = SparkBuildInfo.spark_revision();\n    return UTF8String.fromString(shortVersion + \" \" + revision);\n  }",
    "comment": "Function to return the Spark version.\n@return\nSpace separated version and revision."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/metric/CustomAvgMetric.java",
    "type": "method",
    "name": "aggregateTaskMetrics",
    "code": "public String aggregateTaskMetrics(long[] taskMetrics) {\n    if (taskMetrics.length > 0) {\n      long sum = 0L;\n      for (long taskMetric : taskMetrics) {\n        sum += taskMetric;\n      }\n      double average = ((double) sum) / taskMetrics.length;\n      return new DecimalFormat(\"#0.000\").format(average);\n    } else {\n      return \"0\";\n    }\n  }",
    "comment": "Built-in `CustomMetric` that computes average of metric values. Note that please extend this\nclass and override `name` and `description` to create your custom metric for real usage.\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/RuleContainer.java",
    "type": "method",
    "name": "setOrder",
    "code": "public void setOrder(Object rule, int order) {\n        orderValues.put(rule, order);\n    }",
    "comment": "Sets order value for the specified rule."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestWatcher.java",
    "type": "method",
    "name": "testDisabled",
    "code": "default void testDisabled(ExtensionContext context, Optional<String> reason) {\n\t\t/* no-op */\n\t}",
    "comment": "Invoked after a disabled test has been skipped.\n\n<p>The default implementation does nothing. Concrete implementations can\noverride this method as appropriate.\n\n@param context the current extension context; never {@code null}\n@param reason the reason the test is disabled; never {@code null} but\npotentially <em>empty</em>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/SerializableValueDescription.java",
    "type": "method",
    "name": "asSerializableValue",
    "code": "static Object asSerializableValue(Object value) {\n        if (value == null || value instanceof Serializable) {\n            return value;\n        } else {\n            return new SerializableValueDescription(value);\n        }\n    }",
    "comment": "Factory method that checks to see if the value is already serializable.\n@param value the value to make serializable\n@return The provided value if it is null or already serializable,\nthe SerializableValueDescription representation of it if it is not."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaDataFrameSuite.java",
    "type": "method",
    "name": "testwithColumns",
    "code": "public void testwithColumns() {\n    Dataset<Row> df = spark.table(\"testData2\");\n    Map<String, Column> colMaps = new HashMap<>();\n    colMaps.put(\"a1\", col(\"a\"));\n    colMaps.put(\"b1\", col(\"b\"));\n\n    StructType expected = df.withColumn(\"a1\", col(\"a\")).withColumn(\"b1\", col(\"b\")).schema();\n    StructType actual = df.withColumns(colMaps).schema();\n    Assertions.assertEquals(expected, actual);\n    Assertions.assertArrayEquals(actual.fieldNames(), new String[] {\"a\", \"b\", \"a1\", \"b1\"});\n\n  @Test\n  public void testSampleByColumn() {\n    Dataset<Row> df = spark.range(0, 100, 1, 2).select(col(\"id\").mod(3).as(\"key\"));\n    Dataset<Row> sampled = df.stat().sampleBy(col(\"key\"), ImmutableMap.of(0, 0.1, 1, 0.2), 0L);\n    List<Row> actual = sampled.groupBy(\"key\").count().orderBy(\"key\").collectAsList();\n    Assertions.assertEquals(0, actual.get(0).getLong(0));\n    Assertions.assertTrue(0 <= actual.get(0).getLong(1) && actual.get(0).getLong(1) <= 8);\n    Assertions.assertEquals(1, actual.get(1).getLong(0));\n    Assertions.assertTrue(2 <= actual.get(1).getLong(1) && actual.get(1).getLong(1) <= 13);\n  }\n\n  @Test\n  public void pivot() {\n    Dataset<Row> df = spark.table(\"courseSales\");\n    List<Row> actual = df.groupBy(\"year\")\n      .pivot(\"course\", Arrays.asList(\"dotNET\", \"Java\"))\n      .agg(sum(\"earnings\")).orderBy(\"year\").collectAsList();\n\n    Assertions.assertEquals(2012, actual.get(0).getInt(0));\n    Assertions.assertEquals(15000.0, actual.get(0).getDouble(1), 0.01);\n    Assertions.assertEquals(20000.0, actual.get(0).getDouble(2), 0.01);\n\n    Assertions.assertEquals(2013, actual.get(1).getInt(0));\n    Assertions.assertEquals(48000.0, actual.get(1).getDouble(1), 0.01);\n    Assertions.assertEquals(30000.0, actual.get(1).getDouble(2), 0.01);\n  }\n\n  @Test\n  public void pivotColumnValues() {\n    Dataset<Row> df = spark.table(\"courseSales\");\n    List<Row> actual = df.groupBy(\"year\")\n      .pivot(col(\"course\"), Arrays.asList(lit(\"dotNET\"), lit(\"Java\")))\n      .agg(sum(\"earnings\")).orderBy(\"year\").collectAsList();\n\n    Assertions.assertEquals(2012, actual.get(0).getInt(0));\n    Assertions.assertEquals(15000.0, actual.get(0).getDouble(1), 0.01);\n    Assertions.assertEquals(20000.0, actual.get(0).getDouble(2), 0.01);\n\n    Assertions.assertEquals(2013, actual.get(1).getInt(0));\n    Assertions.assertEquals(48000.0, actual.get(1).getDouble(1), 0.01);\n    Assertions.assertEquals(30000.0, actual.get(1).getDouble(2), 0.01);\n  }\n\n  private String getResource(String resource) {\n    try {\n      URL url = Thread.currentThread().getContextClassLoader().getResource(resource);\n      return url.toURI().getPath();\n    } catch (URISyntaxException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Test\n  public void testGenericLoad() {\n    Dataset<Row> df1 = spark.read().format(\"text\").load(getResource(\"test-data/text-suite.txt\"));\n    Assertions.assertEquals(4L, df1.count());\n\n    Dataset<Row> df2 = spark.read().format(\"text\").load(\n      getResource(\"test-data/text-suite.txt\"),\n      getResource(\"test-data/text-suite2.txt\"));\n    Assertions.assertEquals(5L, df2.count());\n  }\n\n  @Test\n  public void testTextLoad() {\n    Dataset<String> ds1 = spark.read().textFile(getResource(\"test-data/text-suite.txt\"));\n    Assertions.assertEquals(4L, ds1.count());\n\n    Dataset<String> ds2 = spark.read().textFile(\n      getResource(\"test-data/text-suite.txt\"),\n      getResource(\"test-data/text-suite2.txt\"));\n    Assertions.assertEquals(5L, ds2.count());\n  }\n\n  @Test\n  public void testCountMinSketch() {\n    Dataset<Long> df = spark.range(1000);\n\n    CountMinSketch sketch1 = df.stat().countMinSketch(\"id\", 10, 20, 42);\n    Assertions.assertEquals(1000, sketch1.totalCount());\n    Assertions.assertEquals(10, sketch1.depth());\n    Assertions.assertEquals(20, sketch1.width());\n\n    CountMinSketch sketch2 = df.stat().countMinSketch(col(\"id\"), 10, 20, 42);\n    Assertions.assertEquals(1000, sketch2.totalCount());\n    Assertions.assertEquals(10, sketch2.depth());\n    Assertions.assertEquals(20, sketch2.width());\n\n    CountMinSketch sketch3 = df.stat().countMinSketch(\"id\", 0.001, 0.99, 42);\n    Assertions.assertEquals(1000, sketch3.totalCount());\n    Assertions.assertEquals(0.001, sketch3.relativeError(), 1.0e-4);\n    Assertions.assertEquals(0.99, sketch3.confidence(), 5.0e-3);\n\n    CountMinSketch sketch4 = df.stat().countMinSketch(col(\"id\"), 0.001, 0.99, 42);\n    Assertions.assertEquals(1000, sketch4.totalCount());\n    Assertions.assertEquals(0.001, sketch4.relativeError(), 1.0e-4);\n    Assertions.assertEquals(0.99, sketch4.confidence(), 5.0e-3);\n  }\n\n  @Test\n  public void testBloomFilter() {\n    Dataset<Long> df = spark.range(1000);\n\n    BloomFilter filter1 = df.stat().bloomFilter(\"id\", 1000, 0.03);\n    Assertions.assertTrue(filter1.expectedFpp() - 0.03 < 1e-3);\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter1.mightContain(i));\n    }\n\n    BloomFilter filter2 = df.stat().bloomFilter(col(\"id\").multiply(3), 1000, 0.03);\n    Assertions.assertTrue(filter2.expectedFpp() - 0.03 < 1e-3);\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter2.mightContain(i * 3));\n    }\n\n    BloomFilter filter3 = df.stat().bloomFilter(\"id\", 1000, 64 * 5);\n    Assertions.assertEquals(64 * 5, filter3.bitSize());\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter3.mightContain(i));\n    }\n\n    BloomFilter filter4 = df.stat().bloomFilter(col(\"id\").multiply(3), 1000, 64 * 5);\n    Assertions.assertEquals(64 * 5, filter4.bitSize());\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter4.mightContain(i * 3));\n    }\n  }\n\n  public static class BeanWithoutGetter implements Serializable {\n    private String a;\n\n    public void setA(String a) {\n      this.a = a;\n    }\n  }\n\n  @Test\n  public void testBeanWithoutGetter() {\n    BeanWithoutGetter bean = new BeanWithoutGetter();\n    List<BeanWithoutGetter> data = Arrays.asList(bean);\n    Dataset<Row> df = spark.createDataFrame(data, BeanWithoutGetter.class);\n    Assertions.assertEquals(0, df.schema().length());\n    Assertions.assertEquals(1, df.collectAsList().size());\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @Test\n  public void testJsonRDDToDataFrame() {\n    JavaRDD<String> rdd = jsc.parallelize(Arrays.asList(\"{\\\"a\\\": 2}\"));\n    Dataset<Row> df = spark.read().json(rdd);\n    Assertions.assertEquals(1L, df.count());\n    Assertions.assertEquals(2L, df.collectAsList().get(0).getLong(0));\n  }\n\n  public class CircularReference1Bean implements Serializable {\n    private CircularReference2Bean child;\n\n    public CircularReference2Bean getChild() {\n      return child;\n    }\n\n    public void setChild(CircularReference2Bean child) {\n      this.child = child;\n    }\n  }\n\n  public class CircularReference2Bean implements Serializable {\n    private CircularReference1Bean child;\n\n    public CircularReference1Bean getChild() {\n      return child;\n    }\n\n    public void setChild(CircularReference1Bean child) {\n      this.child = child;\n    }\n  }\n\n  @Test\n  public void testCircularReferenceBean() {\n    CircularReference1Bean bean = new CircularReference1Bean();\n    Assertions.assertThrows(UnsupportedOperationException.class,\n      () -> spark.createDataFrame(Arrays.asList(bean), CircularReference1Bean.class));\n  }\n\n  @Test\n  public void testUDF() {\n    UserDefinedFunction foo = udf((Integer i, String s) -> i.toString() + s, DataTypes.StringType);\n    Dataset<Row> df = spark.table(\"testData\").select(foo.apply(col(\"key\"), col(\"value\")));\n    String[] result = df.collectAsList().stream().map(row -> row.getString(0))\n      .toArray(String[]::new);\n    String[] expected = spark.table(\"testData\").collectAsList().stream()\n      .map(row -> row.get(0).toString() + row.getString(1)).toArray(String[]::new);\n    Assertions.assertArrayEquals(expected, result);\n  }\n\n  @Test\n  public void testTransformBase() {\n    Dataset<Integer> ds = spark.createDataset(Arrays.asList(1,2), Encoders.INT());\n    Dataset<Integer> transformed = ds.transform((Dataset<Integer> d) ->\n            ds.selectExpr(\"(value + 1) value\").as(Encoders.INT()));\n    Integer[] expected = {2, 3};\n    Integer[] got = transformed.collectAsList().toArray(new Integer[0]);\n    Arrays.sort(got);\n    Assertions.assertArrayEquals(expected, got);\n  }\n\n  @Test\n  public void testTransformAsClassic() {\n    org.apache.spark.sql.classic.Dataset<Integer> ds =\n            spark.createDataset(Arrays.asList(1,2), Encoders.INT());\n    org.apache.spark.sql.classic.Dataset<Integer> transformed =\n            ds.transform((Dataset<Integer> d) ->\n              ds.selectExpr(\"(value + 1) value\").as(Encoders.INT()));\n    Integer[] expected = {2, 3};\n    Integer[] got = transformed.collectAsList().toArray(new Integer[0]);\n    Arrays.sort(got);\n    Assertions.assertArrayEquals(expected, got);\n  }\n}",
    "comment": "Validate geting same result with withColumn loop call\nValidate the col names\nThe following \"getResource\" has different behaviors in SBT and Maven.\nWhen running in Jenkins, the file path may contain \"@\" when there are multiple\nSparkPullRequestBuilders running in the same worker\n(e.g., /home/jenkins/workspace/SparkPullRequestBuilder@2)\nWhen running in SBT, \"@\" in the file path will be returned as \"@\", however,\nwhen running in Maven, \"@\" will be encoded as \"%40\".\nTherefore, we convert it to URI then call \"getPath\" to decode it back so that it can both\nwork both in SBT and Maven.\nThis is a test for the deprecated API in SPARK-15615.\nChecks a simple case for DataFrame here and put exhaustive tests for the issue\nof circular references in `JavaDatasetSuite`.\nSPARK-49961 - transform must have the correct type\nSPARK-49961 - transform must have the correct type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/io/xpp3/MavenXpp3Reader.java",
    "type": "method",
    "name": "setAddDefaultEntities",
    "code": "public void setAddDefaultEntities(boolean addDefaultEntities) {\n        delegate.setAddLocationInformation(addDefaultEntities);\n    } // -- void setAddDefaultEntities( boolean )",
    "comment": "Sets the state of the \"add default entities\" flag.\n\n@param addDefaultEntities a addDefaultEntities object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/AbstractMessageManager.java",
    "type": "method",
    "name": "findNextInstance",
    "code": "protected Instance findNextInstance(int currentId) {\n    Instance result = null;\n    var candidateList =\n        instanceMap.keySet().stream()\n            .filter((i) -> i > currentId && instanceMap.get(i).isAlive())\n            .sorted()\n            .toList();\n    if (candidateList.isEmpty()) {\n      var index =\n          instanceMap.keySet().stream()\n              .filter((i) -> instanceMap.get(i).isAlive())\n              .sorted()\n              .toList()\n              .get(0);\n      result = instanceMap.get(index);\n    } else {\n      var index = candidateList.get(0);\n      result = instanceMap.get(index);\n    }\n    return result;\n  }",
    "comment": "Find the next instance with the smallest ID.\n\n@return The next instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "classBlock",
    "code": "protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        if (!areAllChildrenIgnored()) {\n            statement = withBeforeClasses(statement);\n            statement = withAfterClasses(statement);\n            statement = withClassRules(statement);\n            statement = withInterruptIsolation(statement);\n        }\n        return statement;\n    }",
    "comment": "Constructs a {@code Statement} to run all of the tests in the test class.\nOverride to add pre-/post-processing. Here is an outline of the\nimplementation:\n<ol>\n<li>Determine the children to be run using {@link #getChildren()}\n(subject to any imposed filter and sort).</li>\n<li>If there are any children remaining after filtering and ignoring,\nconstruct a statement that will:\n<ol>\n<li>Apply all {@code ClassRule}s on the test-class and superclasses.</li>\n<li>Run all non-overridden {@code @BeforeClass} methods on the test-class\nand superclasses; if any throws an Exception, stop execution and pass the\nexception on.</li>\n<li>Run all remaining tests on the test-class.</li>\n<li>Run all non-overridden {@code @AfterClass} methods on the test-class\nand superclasses: exceptions thrown by previous steps are combined, if\nnecessary, with exceptions from AfterClass methods into a\n{@link org.junit.runners.model.MultipleFailureException}.</li>\n</ol>\n</li>\n</ol>\n\n@return {@code Statement}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/command-query-responsibility-segregation/src/main/java/com/iluwatar/cqrs/queries/QueryServiceImpl.java",
    "type": "method",
    "name": "getAuthorByUsername",
    "code": "public Author getAuthorByUsername(String username) {\n    Author authorDto;\n    try (var session = sessionFactory.openSession()) {\n      Query<Author> sqlQuery =\n          session.createQuery(\n              \"select new com.iluwatar.cqrs.dto.Author(a.name, a.email, a.username)\"\n                  + \" from com.iluwatar.cqrs.domain.model.Author a where a.username=:username\");\n      sqlQuery.setParameter(AppConstants.USER_NAME, username);\n      authorDto = sqlQuery.uniqueResult();\n    }\n    return authorDto;\n  }",
    "comment": "This class is an implementation of {@link QueryService}. It uses Hibernate native queries to\nreturn DTOs from the database."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/NumericHistogram.java",
    "type": "method",
    "name": "allocate",
    "code": "public void allocate(int num_bins) {\n    nbins = num_bins;\n    bins = new ArrayList<>();\n    nusedbins = 0;\n  }",
    "comment": "Sets the number of histogram bins to use for approximating data.\n\n@param num_bins Number of non-uniform-width histogram bins to use"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultPluginConfigurationExpander.java",
    "type": "method",
    "name": "expandPluginConfiguration",
    "code": "public Model expandPluginConfiguration(Model model, ModelBuilderRequest request, ModelProblemCollector problems) {\n        Build build = model.getBuild();\n        if (build != null) {\n            build = build.withPlugins(expandPlugin(build.getPlugins()));\n            PluginManagement pluginManagement = build.getPluginManagement();\n            if (pluginManagement != null) {\n                build = build.withPluginManagement(\n                        pluginManagement.withPlugins(expandPlugin(pluginManagement.getPlugins())));\n            }\n            model = model.withBuild(build);\n        }\n        Reporting reporting = model.getReporting();\n        if (reporting != null) {\n            expandReport(reporting.getPlugins());\n        }\n        return model.withBuild(build);\n    }",
    "comment": "Handles expansion of general build plugin configuration into individual executions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(byte[] expected, byte[] actual, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} byte arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/locator/DefaultModelLocator.java",
    "type": "method",
    "name": "locatePom",
    "code": "public File locatePom(File projectDirectory) {\n        return new File(projectDirectory, \"pom.xml\");\n    }",
    "comment": "Locates a POM file within a project base directory.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethod.java",
    "type": "method",
    "name": "isCompatibleContainerType",
    "code": "private static boolean isCompatibleContainerType(Method method, DiscoveryIssueReporter issueReporter) {\n\t\tType genericReturnType = method.getGenericReturnType();\n\n\t\tif (genericReturnType instanceof ParameterizedType) {\n\t\t\tType[] typeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();\n\t\t\tif (typeArguments.length == 1) {\n\t\t\t\tType typeArgument = typeArguments[0];\n\t\t\t\tif (typeArgument instanceof Class) {\n\t\t\t\t\treturn DynamicNode.class.isAssignableFrom((Class<?>) typeArgument);\n\t\t\t\t}\n\t\t\t\tif (typeArgument instanceof WildcardType) {\n\t\t\t\t\tWildcardType wildcardType = (WildcardType) typeArgument;\n\t\t\t\t\tType[] upperBounds = wildcardType.getUpperBounds();\n\t\t\t\t\tType[] lowerBounds = wildcardType.getLowerBounds();\n\t\t\t\t\tif (upperBounds.length == 1 && lowerBounds.length == 0 && upperBounds[0] instanceof Class) {\n\t\t\t\t\t\tClass<?> upperBound = (Class<?>) upperBounds[0];\n\t\t\t\t\t\tif (Object.class.equals(upperBound)) { // Stream<?> etc.\n\t\t\t\t\t\t\tissueReporter.reportIssue(createTooGenericReturnTypeIssue(method));\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn DynamicNode.class.isAssignableFrom(upperBound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tissueReporter.reportIssue(createTooGenericReturnTypeIssue(method));\n\t\treturn true;\n\t}",
    "comment": "Stream<DynamicNode> etc.\nStream<? extends DynamicNode> etc.\nRaw Stream etc. without type argument"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/PyTorchCodegenLoader.java",
    "type": "method",
    "name": "loadNativeLibs",
    "code": "public static void loadNativeLibs() {\n    try {\n      NativeLoader.loadLibrary(\"torch-code-gen\");\n    } catch (Throwable t) {\n    }\n  }",
    "comment": "Loading the codegen lib is best-effort since it's only there for query based builds."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeDefaultParameter",
    "code": "void cleanupModeDefaultParameter() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(DefaultParameterCase.class, \"testDefaultParameter\", \"java.nio.file.Path\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(defaultParameterDir).doesNotExist();\n\t\t}",
    "comment": "Ensure the cleanup mode defaults to ALWAYS for parameters.\n<p/>\nExpect the TempDir to be cleaned up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestEngine.java",
    "type": "method",
    "name": "createThrowableCollectorFactory",
    "code": "protected ThrowableCollector.Factory createThrowableCollectorFactory(ExecutionRequest request) {\n\t\treturn OpenTest4JAwareThrowableCollector::new;\n\t}",
    "comment": "Create the {@linkplain ThrowableCollector.Factory factory} for creating\n{@link ThrowableCollector} instances used to handle exceptions that occur\nduring execution of this engine's tests.\n\n<p>An engine may use the information in the supplied <em>request</em>\nsuch as the contained\n{@linkplain ExecutionRequest#getConfigurationParameters() configuration parameters}\nto decide what kind of factory to return or how to configure it.\n\n<p>By default, this method returns a factory that always creates instances of\n{@link OpenTest4JAwareThrowableCollector}.\n\n@param request the request about to be executed\n@since 1.3\n@see OpenTest4JAwareThrowableCollector\n@see ThrowableCollector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "mergedIndexCacheSize",
    "code": "public long mergedIndexCacheSize() {\n    return JavaUtils.byteStringAsBytes(\n      conf.get(\"spark.shuffle.push.server.mergedIndexCacheSize\", \"100m\"));\n  }",
    "comment": "The maximum size of cache in memory which is used in push-based shuffle for storing merged\nindex files. This cache is in addition to the one configured via\nspark.shuffle.service.index.cache.size."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "getDefinitionOrigin",
    "code": "private static DefinitionOrigin getDefinitionOrigin(int collationId) {\n        return DefinitionOrigin.values()[SpecifierUtils.getSpecValue(collationId,\n          DEFINITION_ORIGIN_OFFSET, DEFINITION_ORIGIN_MASK)];\n      }",
    "comment": "Utility function to retrieve `DefinitionOrigin` enum instance from collation ID."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/SingleTableInheritance.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SpringApplication.run(SingleTableInheritance.class, args);\n  }",
    "comment": "The entry point of the Spring Boot Application.\n\n@param args program runtime arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/InputSource.java",
    "type": "method",
    "name": "getLocation",
    "code": "public String getLocation() {\n        return this.location;\n    } // -- String getLocation()",
    "comment": "Get the path/URL of the POM or {@code null} if unknown.\n\n@return String"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/publish-subscribe/src/main/java/com/iluwatar/publish/subscribe/model/Topic.java",
    "type": "method",
    "name": "publish",
    "code": "public void publish(Message message) {\n    for (Subscriber subscriber : subscribers) {\n      CompletableFuture.runAsync(() -> subscriber.onMessage(message));\n    }\n  }",
    "comment": "Publish a message to subscribers.\n\n@param message message with content to publish"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/types/UTF8StringSuite.java",
    "type": "method",
    "name": "testCodePointFrom",
    "code": "public void testCodePointFrom() {\n    String str = \"abcde\";\n    UTF8String s = fromString(str);\n    for (int i = 0; i < str.length(); ++i) {\n      assertEquals(str.charAt(i), s.codePointFrom(i));\n    }\n    assertThrows(IndexOutOfBoundsException.class, () -> s.codePointFrom(-1));\n    assertThrows(IndexOutOfBoundsException.class, () -> s.codePointFrom(str.length()));\n    assertThrows(IndexOutOfBoundsException.class, () -> s.codePointFrom(str.length() + 1));\n\n    byte[] invalidString = new byte[] {(byte) 0x41, (byte) 0x42, (byte) 0x80};\n        assertEquals(0, invalidUTF8String.codePointFrom(i));\n      }",
    "comment": "Valid UTF-8 string\nValid character index handling\nInvalid character index handling\nInvalid UTF-8 string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Byte expected, byte actual) {\n\t\tAssertEquals.assertEquals(expected, (Byte) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/Java8APISuite.java",
    "type": "method",
    "name": "testStreamingContextTransform",
    "code": "public void testStreamingContextTransform() {\n    List<List<Integer>> stream1input = Arrays.asList(\n      Arrays.asList(1),\n      Arrays.asList(2)\n    );\n\n    List<List<Integer>> stream2input = Arrays.asList(\n      Arrays.asList(3),\n      Arrays.asList(4)\n    );\n\n    List<List<Tuple2<Integer, String>>> pairStream1input = Arrays.asList(\n      Arrays.asList(new Tuple2<>(1, \"x\")),\n      Arrays.asList(new Tuple2<>(2, \"y\"))\n    );\n\n    List<List<Tuple2<Integer, Tuple2<Integer, String>>>> expected = Arrays.asList(\n      Arrays.asList(new Tuple2<>(1, new Tuple2<>(1, \"x\"))),\n      Arrays.asList(new Tuple2<>(2, new Tuple2<>(2, \"y\")))\n    );\n\n    JavaDStream<Integer> stream1 = JavaTestUtils.attachTestInputStream(ssc, stream1input, 1);\n    JavaDStream<Integer> stream2 = JavaTestUtils.attachTestInputStream(ssc, stream2input, 1);\n    JavaPairDStream<Integer, String> pairStream1 = JavaPairDStream.fromJavaDStream(\n      JavaTestUtils.attachTestInputStream(ssc, pairStream1input, 1));\n\n    List<JavaDStream<?>> listOfDStreams1 = Arrays.asList(stream1, stream2);\n\n    JavaDStream<Long> transformed1 = ssc.transform(\n      listOfDStreams1, (List<JavaRDD<?>> listOfRDDs, Time time) -> {\n      Assertions.assertEquals(2, listOfRDDs.size());\n      return null;\n    });\n\n    List<JavaDStream<?>> listOfDStreams2 =\n      Arrays.asList(stream1, stream2, pairStream1.toJavaDStream());\n\n    JavaPairDStream<Integer, Tuple2<Integer, String>> transformed2 = ssc.transformToPair(\n      listOfDStreams2, (List<JavaRDD<?>> listOfRDDs, Time time) -> {\n      Assertions.assertEquals(3, listOfRDDs.size());\n      JavaRDD<Integer> rdd1 = (JavaRDD<Integer>) listOfRDDs.get(0);\n      JavaRDD<Integer> rdd2 = (JavaRDD<Integer>) listOfRDDs.get(1);\n      JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>) listOfRDDs.get(2);\n      JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3);\n      PairFunction<Integer, Integer, Integer> mapToTuple =\n        (Integer i) -> new Tuple2<>(i, i);\n      return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3);\n    });\n    JavaTestUtils.attachTestOutputStream(transformed2);\n    List<List<Tuple2<Integer, Tuple2<Integer, String>>>> result =\n      JavaTestUtils.runStreams(ssc, 2, 2);\n    Assertions.assertEquals(expected, result);\n  }",
    "comment": "This is just to test whether this transform to JavaStream compiles"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/MethodValidator.java",
    "type": "method",
    "name": "MethodValidator",
    "code": "public MethodValidator(TestClass testClass) {\n        this.testClass = testClass;\n    }",
    "comment": "@deprecated Included for backwards compatibility with JUnit 4.4. Will be\nremoved in the next major release. Please use\n{@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "checkCombineLines",
    "code": "private static boolean checkCombineLines(String line) {\n            int bsCount = 0;\n            for (int idx = line.length() - 1; idx >= 0 && line.charAt(idx) == '\\\\'; idx--) {\n                bsCount++;\n            }\n\n            return bsCount % 2 != 0;\n        }",
    "comment": "Checks if the passed in line should be combined with the following.\nThis is true, if the line ends with an odd number of backslashes.\n\n@param line the line\n@return a flag if the lines should be combined"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnenc/ConsolePasswordPrompt.java",
    "type": "method",
    "name": "ConsolePasswordPrompt",
    "code": "public ConsolePasswordPrompt(Prompter prompter) {\n        this.prompter = prompter;\n    }",
    "comment": "Trivial master password source using Maven {@link Prompter} service."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java",
    "type": "method",
    "name": "cpuTime",
    "code": "private long cpuTime(Thread thr) {\n        ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n        if (mxBean.isThreadCpuTimeSupported()) {\n            try {\n                return mxBean.getThreadCpuTime(thr.getId());\n            } catch (UnsupportedOperationException e) {\n            }\n        }\n        return 0;\n    }",
    "comment": "Returns the CPU time used by a thread, if possible.\n@param thr The thread to query.\n@return The CPU time used by {@code thr}, or 0 if it cannot be determined."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/queue-based-load-leveling/src/main/java/com/iluwatar/queue/load/leveling/MessageQueue.java",
    "type": "method",
    "name": "retrieveMsg",
    "code": "public Message retrieveMsg() {\n    try {\n      return blkQueue.poll();\n    } catch (Exception e) {\n      LOGGER.error(e.getMessage());\n    }\n    return null;\n  }",
    "comment": "All the messages will be retrieved by the ServiceExecutor by calling this method and process\nthem. Retrieves and removes the head of this queue, or returns null if this queue is empty."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/ReactorReader.java",
    "type": "method",
    "name": "installIntoProjectLocalRepository",
    "code": "private void installIntoProjectLocalRepository(MavenProject project) {\n        if (\"pom\".equals(project.getPackaging())\n                        && !\"clean\".equals(getLifecycles(project).peekLast())\n                || hasBeenPackagedDuringThisSession(project)) {\n            getProjectArtifacts(project).filter(this::isRegularFile).forEach(this::installIntoProjectLocalRepository);\n        }\n    }",
    "comment": "Copy packaged and attached artifacts from this project to the\nproject local repository.\nThis allows a subsequent build to resume while still being able\nto locate attached artifacts.\n\n@param project the project to copy artifacts from"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-settings-builder/src/main/java/org/apache/maven/settings/building/SettingsBuildingException.java",
    "type": "method",
    "name": "SettingsBuildingException",
    "code": "public SettingsBuildingException(List<SettingsProblem> problems) {\n        super(toMessage(problems));\n\n        this.problems = new ArrayList<>();\n        if (problems != null) {\n            this.problems.addAll(problems);\n        }\n    }",
    "comment": "Creates a new exception with the specified problems.\n\n@param problems The problems that cause this exception, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "addUserProvidedDelegates",
    "code": "private void addUserProvidedDelegates(Options options) {\n    for (Delegate delegate : options.getDelegates()) {\n      if (options.getRuntime() != TfLiteRuntime.FROM_APPLICATION_ONLY\n          && !(delegate instanceof NnApiDelegate)) {\n        throw new IllegalArgumentException(\n            \"Instantiated delegates (other than NnApiDelegate) are not allowed when using TF Lite\"\n                + \" from Google Play Services. Please use\"\n                + \" InterpreterApi.Options.addDelegateFactory() with an appropriate DelegateFactory\"\n                + \" instead.\");\n      }\n      delegates.add(delegate);\n    }\n  }",
    "comment": "NnApiDelegate is compatible with both the system and built-in runtimes and therefore can be\nadded directly even when using TF Lite from the system."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/resolver/DefaultLegacyArtifactCollector.java",
    "type": "method",
    "name": "if",
    "code": "Artifact originatingArtifact, Map<String, Artifact> managedVersions) {\n        ManagedVersionMap versionMap;\n        if (managedVersions instanceof ManagedVersionMap managedVersionMap) {\n            versionMap = managedVersionMap;\n        } else {\n            versionMap = new ManagedVersionMap(managedVersions);\n        }\n\n        // remove the originating artifact if it is also in managed versions to avoid being modified during resolution\n        Artifact managedOriginatingArtifact = versionMap.get(originatingArtifact.getDependencyConflictId());\n\n        if (managedOriginatingArtifact != null) {\n            // TODO we probably want to warn the user that he is building an artifact with\n            // different values than in dependencyManagement\n            if (managedVersions instanceof ManagedVersionMap) {\n                /* avoid modifying the managedVersions parameter creating a new map */\n                versionMap = new ManagedVersionMap(managedVersions);\n            }\n            versionMap.remove(originatingArtifact.getDependencyConflictId());\n        }\n\n        return versionMap;\n    }",
    "comment": "Get the map of managed versions, removing the originating artifact if it is also in managed versions\n\n@param originatingArtifact artifact we are processing\n@param managedVersions original managed versions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/streaming/JavaCustomReceiver.java",
    "type": "method",
    "name": "JavaCustomReceiver",
    "code": "public JavaCustomReceiver(String host_ , int port_) {\n    super(StorageLevel.MEMORY_AND_DISK_2());\n    host = host_;\n    port = port_;\n  }",
    "comment": "Create the context with a 1 second batch size\nCreate an input stream with the custom receiver on target ip:port and count the\nwords in input stream of \\n delimited text (e.g. generated by 'nc')\n============= Receiver code that receives data over a socket =============="
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "ConditionFunctions",
    "code": "public ConditionFunctions(ProfileActivationContext context, VersionParser versionParser) {\n        this.context = context;\n        this.versionParser = versionParser;\n    }",
    "comment": "Constructs a new ConditionFunctions instance.\n\n@param context The profile activation context\n@param versionParser The version parser for comparing versions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "getByteBuffer",
    "code": "public ByteBuffer getByteBuffer() {\n    if (base instanceof byte[] bytes && offset >= BYTE_ARRAY_OFFSET) {\n\n      // the offset includes an object header... this is only needed for unsafe copies\n      final long arrayOffset = offset - BYTE_ARRAY_OFFSET;\n\n      // verify that the offset and length points somewhere inside the byte array\n      // and that the offset can safely be truncated to a 32-bit integer\n      if ((long) bytes.length < arrayOffset + numBytes) {\n        throw new ArrayIndexOutOfBoundsException();\n      }\n\n      return ByteBuffer.wrap(bytes, (int) arrayOffset, numBytes);\n    } else {\n      return ByteBuffer.wrap(getBytes());\n    }\n  }",
    "comment": "Returns a {@link ByteBuffer} wrapping the base object if it is a byte array\nor a copy of the data if the base object is not a byte array.\n\nUnlike getBytes this will not create a copy the array if this is a slice."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java",
    "type": "method",
    "name": "calculateExecutionPlan",
    "code": "public MavenExecutionPlan calculateExecutionPlan(MavenSession session, String... tasks) {\n        return new MavenExecutionPlan(null, new DefaultLifecycles());\n    }",
    "comment": "A stub implementation that assumes an empty lifecycle to bypass interaction with the plugin manager and to avoid\nplugin artifact resolution from repositories."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "closeIfFreeable",
    "code": "public void closeIfFreeable() {\n    // By default, we just call close() for all column vectors. If a column vector is writable or\n    // constant, it should override this method and do nothing.\n    close();\n  }",
    "comment": "Cleans up memory for this column vector if it's resources are freeable between batches.\nThe column vector is not usable after this.\n\nIf this is a writable column vector or constant column vector, it is a no-op."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "byTestDescriptor",
    "code": "public static Predicate<Event> byTestDescriptor(Predicate<? super TestDescriptor> testDescriptorPredicate) {\n\t\treturn where(Event::getTestDescriptor, testDescriptorPredicate);\n\t}",
    "comment": "Create a {@link Predicate} for {@linkplain Event events} whose\n{@link TestDescriptor TestDescriptors} match the supplied\n{@code testDescriptorPredicate}.\n\n@param testDescriptorPredicate a {@code Predicate} to match against test\ndescriptors\n@return the resulting {@link Predicate}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/strangler/src/main/java/com/iluwatar/strangler/NewSource.java",
    "type": "method",
    "name": "accumulateSum",
    "code": "public int accumulateSum(int... nums) {\n    LOGGER.info(SOURCE_MODULE, VERSION);\n    return Arrays.stream(nums).reduce(0, Integer::sum);\n  }",
    "comment": "New source. Completely covers functionalities of old source with new techniques and also has some\nnew features."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProjectBuilderRequest.java",
    "type": "method",
    "name": "build",
    "code": "public ProjectBuilderRequest build() {\n            return new DefaultProjectBuilderRequest(\n                    session, trace, path, source, allowStubModel, recursive, processPlugins, repositories);\n        }",
    "comment": "Builds a new ProjectBuilderRequest with the current builder settings.\n\n@return a new ProjectBuilderRequest instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaVectorIndexerExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaVectorIndexerExample\")\n      .getOrCreate();\n\n    Dataset<Row> data = spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    VectorIndexer indexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexed\")\n      .setMaxCategories(10);\n    VectorIndexerModel indexerModel = indexer.fit(data);\n\n    Map<Integer, Map<Double, Integer>> categoryMaps = indexerModel.javaCategoryMaps();\n    System.out.print(\"Chose \" + categoryMaps.size() + \" categorical features:\");\n\n    for (Integer feature : categoryMaps.keySet()) {\n      System.out.print(\" \" + feature);\n    }\n    System.out.println();\n\n    Dataset<Row> indexedData = indexerModel.transform(data);\n    indexedData.show();\n    spark.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nCreate new column \"indexed\" with categorical values transformed to indices\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/ServiceLoaderTestEngineRegistry.java",
    "type": "method",
    "name": "getLogger",
    "code": "private static Logger getLogger() {\n\t\treturn LoggerFactory.getLogger(ServiceLoaderTestEngineRegistry.class);\n\t}",
    "comment": "Not a constant to avoid problems with building GraalVM native images"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "fail",
    "code": "public static <V> V fail() {\n\t\tAssertionUtils.fail();\n\t\treturn null; // appeasing the compiler: this line will never be executed.\n\t}",
    "comment": "<em>Fail</em> the test <em>without</em> a failure message.\n\n<p>Although failing <em>with</em> an explicit failure message is recommended,\nthis method may be useful when maintaining legacy code.\n\n<p>See Javadoc for {@link #fail(String)} for an explanation of this method's\ngeneric return type {@code V}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroOptionalPrimitives.java",
    "type": "method",
    "name": "put",
    "code": "public void put(int field$, java.lang.Object value$) {\n    switch (field$) {\n    case 0: maybe_bool_column = (java.lang.Boolean)value$; break;\n    case 1: maybe_int_column = (java.lang.Integer)value$; break;\n    case 2: maybe_long_column = (java.lang.Long)value$; break;\n    case 3: maybe_float_column = (java.lang.Float)value$; break;\n    case 4: maybe_double_column = (java.lang.Double)value$; break;\n    case 5: maybe_binary_column = (java.nio.ByteBuffer)value$; break;\n    case 6: maybe_string_column = (java.lang.String)value$; break;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumReader.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ArrowColumnVector.java",
    "type": "method",
    "name": "getUTF8String",
    "code": "final UTF8String getUTF8String(int rowId) {\n      accessor.get(rowId, stringResult);\n      if (stringResult.isSet == 0) {\n        return null;\n      } else {\n        return UTF8String.fromAddress(null,\n          stringResult.buffer.memoryAddress() + stringResult.start,\n          (int)(stringResult.end - stringResult.start));\n      }\n    }",
    "comment": "A single string cannot be larger than the max integer size, so the conversion is safe"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "started",
    "code": "public Events started() {\n\t\treturn new Events(eventsByType(EventType.STARTED), this.category + \" Started\");\n\t}",
    "comment": "Get the started {@link Events} contained in this {@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java",
    "type": "method",
    "name": "isChildOfRootNode",
    "code": "public boolean isChildOfRootNode() {\n        return parent != null && parent.parent == null;\n    }",
    "comment": "Test whether the node is direct or transitive dependency.\n\n@return whether the node is direct or transitive dependency"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java",
    "type": "method",
    "name": "handleCsvException",
    "code": "static RuntimeException handleCsvException(Throwable throwable, Annotation annotation) {\n\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(throwable);\n\t\tif (throwable instanceof PreconditionViolationException) {\n\t\t\tthrow (PreconditionViolationException) throwable;\n\t\t}\n\t\tthrow new CsvParsingException(\"Failed to parse CSV input configured via \" + annotation, throwable);\n\t}",
    "comment": "@return this method always throws an exception and therefore never\nreturns anything; the return type is merely present to allow this\nmethod to be supplied as the operand in a {@code throw} statement"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/injection/sample/PrimitiveArrayParameterResolver.java",
    "type": "method",
    "name": "supportsParameter",
    "code": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn int[].class == parameterContext.getParameter().getType();\n\t}",
    "comment": "Example {@link ParameterResolver} that resolves arrays of primitive integers.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/streaming/ReadLimit.java",
    "type": "method",
    "name": "minRows",
    "code": "static ReadLimit minRows(long rows, long maxTriggerDelayMs) {\n    return new ReadMinRows(rows, maxTriggerDelayMs);\n  }",
    "comment": "Interface representing limits on how much to read from a {@link MicroBatchStream} when it\nimplements {@link SupportsAdmissionControl}. There are several child interfaces representing\nvarious kinds of limits.\n\n@see SupportsAdmissionControl#latestOffset(Offset, ReadLimit)\n@see ReadAllAvailable\n@see ReadMaxRows\n@since 3.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/AggregateHashMap.java",
    "type": "method",
    "name": "find",
    "code": "public int find(long key) {\n    long h = hash(key);\n    int step = 0;\n    int idx = (int) h & (numBuckets - 1);\n    while (step < maxSteps) {\n      if (buckets[idx] == -1) {\n        return idx;\n      } else if (equals(idx, key)) {\n        return idx;\n      }\n      idx = (idx + 1) & (numBuckets - 1);\n      step++;\n    }\n    return -1;\n  }",
    "comment": "Return bucket index if it's either an empty slot or already contains the key\nDidn't find it"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/MojoFailureException.java",
    "type": "method",
    "name": "MojoFailureException",
    "code": "public MojoFailureException(Object source, String shortMessage, String longMessage) {\n        super(shortMessage);\n        this.source = source;\n        this.longMessage = longMessage;\n    }",
    "comment": "Construct a new <code>MojoFailureException</code> exception providing the source and a short and long message:\nthese messages are used to improve the message written at the end of Maven build.\n\n@param source\n@param shortMessage\n@param longMessage"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/test/java/com/iluwatar/circuitbreaker/AppTest.java",
    "type": "method",
    "name": "testFailure_HalfOpenStateTransition",
    "code": "void testFailure_HalfOpenStateTransition() {\n    assertEquals(\"Delayed service is down\", monitoringService.delayedServiceResponse());\n    assertEquals(\"OPEN\", delayedServiceCircuitBreaker.getState());\n\n    try {\n      LOGGER.info(\"Waiting 2s for delayed service to become responsive\");\n      Thread.sleep(2000);\n    } catch (InterruptedException e) {\n      LOGGER.error(\"An error occurred: \", e);\n    }\n    assertEquals(\"HALF_OPEN\", delayedServiceCircuitBreaker.getState());\n  }",
    "comment": "Calling delayed service, which will be unhealthy till 4 seconds\nAs failure threshold is \"1\", the circuit breaker is changed to OPEN\nWaiting for recovery period of 2 seconds for circuit breaker to retry service.\nAfter 2 seconds, the circuit breaker should move to \"HALF_OPEN\" state and retry fetching\nresponse from service again"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "getAnnotation",
    "code": "public <T extends Annotation> T getAnnotation(Class<T> annotationType) {\n        for (Annotation each : fAnnotations) {\n            if (each.annotationType().equals(annotationType)) {\n                return annotationType.cast(each);\n            }\n        }\n        return null;\n    }",
    "comment": "@return the annotation of type annotationType that is attached to this description node,\nor null if none exists"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/database/MongoDb.java",
    "type": "method",
    "name": "readFromDb",
    "code": "public UserAccount readFromDb(final String userId) {\n    var iterable =\n        db.getCollection(CachingConstants.USER_ACCOUNT).find(new Document(USER_ID, userId));\n    if (iterable.first() == null) {\n      return null;\n    }\n    Document doc = iterable.first();\n    if (doc != null) {\n      String userName = doc.getString(USER_NAME);\n      String appInfo = doc.getString(ADD_INFO);\n      return new UserAccount(userId, userName, appInfo);\n    } else {\n      return null;\n    }\n  }",
    "comment": "Read data from DB.\n\n@param userId {@link String}\n@return {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "put",
    "code": "public String put(String key, List<String> commentLines, List<String> valueLines) {\n        commentLines = new ArrayList<>(commentLines);\n        valueLines = new ArrayList<>(valueLines);\n        String escapedKey = escapeKey(key);\n        StringBuilder sb = new StringBuilder();\n        if (valueLines.isEmpty()) {\n            valueLines.add(escapedKey + \"=\");\n            sb.append(escapedKey).append(\"=\");\n        } else {\n            String val0 = valueLines.get(0);\n            String rv0 = typed ? val0 : escapeJava(val0);\n            if (!val0.trim().startsWith(escapedKey)) {\n                valueLines.set(0, escapedKey + \" = \" + rv0 /*+ (0 < lastLine? \"\\\\\": \"\")*/);\n                sb.append(escapedKey).append(\" = \").append(rv0);\n            } else {\n                valueLines.set(0, rv0 /*+ (0 < lastLine? \"\\\\\": \"\")*/);\n                sb.append(rv0);\n            }\n        }\n        for (int i = 1; i < valueLines.size(); i++) {\n            String val = valueLines.get(i);\n            valueLines.set(i, typed ? val : escapeJava(val) /*+ (i < lastLine? \"\\\\\": \"\")*/);\n            while (!val.isEmpty() && Character.isWhitespace(val.charAt(0))) {\n                val = val.substring(1);\n            }\n            sb.append(val);\n        }\n        String[] property = PropertiesReader.parseProperty(sb.toString());\n        this.layout.put(key, new Layout(commentLines, valueLines));\n        return storage.put(key, property[1]);\n    }",
    "comment": "int lastLine = valueLines.size() - 1;"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectClass",
    "code": "public static ClassSelector selectClass(ClassLoader classLoader, String className) {\n\t\tPreconditions.notBlank(className, \"Class name must not be null or blank\");\n\t\treturn new ClassSelector(classLoader, className);\n\t}",
    "comment": "Create a {@code ClassSelector} for the supplied class name and class loader.\n\n@param classLoader the class loader to use to load the class, or {@code null}\nto signal that the default {@code ClassLoader} should be used\n@param className the fully qualified name of the class to select; never\n{@code null} or blank\n@since 1.10\n@see ClassSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/session/GlobalSetupTeardownListener.java",
    "type": "method",
    "name": "launcherSessionOpened",
    "code": "public void launcherSessionOpened(LauncherSession session) {\n\t\tsession.getLauncher().registerTestExecutionListeners(new TestExecutionListener() {\n\t\t\t\tNamespacedHierarchicalStore<Namespace> store = session.getStore(); // <1>\n\t\t\t\tstore.getOrComputeIfAbsent(Namespace.GLOBAL, \"httpServer\", key -> { // <2>\n\t\t\t\t\tInetSocketAddress address = new InetSocketAddress(getLoopbackAddress(), 0);\n\t\t\t\t\tHttpServer server;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tserver = HttpServer.create(address, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t\tthrow new UncheckedIOException(\"Failed to start HTTP server\", e);\n\t\t\t\t\t}\n\t\t\t\t\tserver.createContext(\"/test\", exchange -> {\n\t\t\t\t\t\texchange.sendResponseHeaders(204, -1);\n\t\t\t\t\t\texchange.close();\n\t\t\t\t\t});\n\t\t\t\t\tExecutorService executorService = Executors.newCachedThreadPool();\n\t\t\t\t\tserver.setExecutor(executorService);\n\t\t\t\t\tserver.start(); // <3>\n\n\t\t\t\t\treturn new CloseableHttpServer(server, executorService);\n\t\t\t\t});\n\t\t\t}\n\t\t});",
    "comment": "tag::user_guide[]\nAvoid setup for test discovery by delaying it until tests are about to be executed\ntag::user_guide[]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlob",
    "code": "public static Tensor fromBlob(IntBuffer data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_BUFFER_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.capacity(), shape);\n    checkArgument(data.isDirect(), ERROR_MSG_DATA_BUFFER_MUST_BE_DIRECT);\n    checkArgument(\n        (data.order() == ByteOrder.nativeOrder()),\n        ERROR_MSG_DATA_BUFFER_MUST_HAVE_NATIVE_BYTE_ORDER);\n    return new Tensor_int32(data, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.int32 with specified shape and data.\n\n@param data Direct buffer with native byte order that contains {@code Tensor.numel(shape)}\nelements. The buffer is used directly without copying, and changes to its content will\nchange the tensor.\n@param shape Tensor shape"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Byte unexpected, byte actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Byte) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/LifecycleMethodExecutionExceptionHandlerTests.java",
    "type": "method",
    "name": "resetStatics",
    "code": "void resetStatics() {\n\t\tthrowExceptionBeforeAll = true;\n\t\tthrowExceptionBeforeEach = true;\n\t\tthrowExceptionAfterEach = true;\n\t\tthrowExceptionAfterAll = true;\n\t\thandlerCalls.clear();\n\n\t\tSwallowExceptionHandler.callCounter.reset();\n\n\t\tRethrowExceptionHandler.callCounter.reset();\n\n\t\tConvertExceptionHandler.callCounter.reset();\n\n\t\tUnrecoverableExceptionHandler.callCounter.reset();\n\n\t\tShouldNotBeCalledHandler.callCounter.reset();\n\t}",
    "comment": "Tests that verify the support for lifecycle method execution exception handling\nvia {@link LifecycleMethodExecutionExceptionHandler}\n\n@since 5.5"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/ArtifactDescriptorUtils.java",
    "type": "method",
    "name": "toPomArtifact",
    "code": "public static Artifact toPomArtifact(Artifact artifact) {\n        Artifact pomArtifact = artifact;\n\n        if (!pomArtifact.getClassifier().isEmpty() || !\"pom\".equals(pomArtifact.getExtension())) {\n            pomArtifact =\n                    new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), \"pom\", artifact.getVersion());\n        }\n\n        return pomArtifact;\n    }",
    "comment": "<strong>Warning:</strong> This is an internal utility class that is only public for technical reasons, it is not part\nof the public API. In particular, this class can be changed or deleted without prior notice."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/DependencyResolver.java",
    "type": "method",
    "name": "collect",
    "code": "default DependencyResolverResult collect(@Nonnull DependencyResolverRequest request) {\n        if (request.getRequestType() != DependencyResolverRequest.RequestType.COLLECT) {\n            throw new IllegalArgumentException(\"requestType should be COLLECT when calling collect()\");\n        }\n        return resolve(request);\n    }",
    "comment": "Collects the transitive dependencies and builds a dependency graph.\nNote that this operation is only concerned about determining the coordinates of the\ntransitive dependencies and does not actually resolve the artifact files.\n\n@param request the dependency collection request, must not be {@code null}\n@return the collection result, never {@code null}\n@throws DependencyResolverException if the dependency tree could not be built\n@throws IllegalArgumentException if an argument is null or invalid\n\n@see DependencyResolver#collect(Session, Project, PathScope)\n@see DependencyResolver#collect(Session, DependencyCoordinates, PathScope)\n@see DependencyResolver#collect(Session, Artifact, PathScope)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroOptionalPrimitives.java",
    "type": "method",
    "name": "setMaybeStringColumn",
    "code": "public void setMaybeStringColumn(java.lang.String value) {\n    this.maybe_string_column = value;\n  }",
    "comment": "Sets the value of the 'maybe_string_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/CompositeTestSource.java",
    "type": "method",
    "name": "getSources",
    "code": "public final List<TestSource> getSources() {\n\t\treturn this.sources;\n\t}",
    "comment": "Get an immutable list of the {@linkplain TestSource sources} stored in this\n{@code CompositeTestSource}.\n\n@return the sources stored in this {@code CompositeTestSource}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/BlockJUnit4ClassRunnerOverrideTest.java",
    "type": "method",
    "name": "createTest",
    "code": "protected Object createTest() {\n            final CreateTestDefersToNoArgCreateTestTest obj = new CreateTestDefersToNoArgCreateTestTest();\n\n            obj.createTestCalled = true;\n\n            return obj;\n        }",
    "comment": "Runner for testing override of {@link org.junit.runners.BlockJUnit4ClassRunner#createTest()}\nis still called by default if no other {@code createTest} method override\nis in place. This is tested by setting a boolean flag in a field of the\ntest class so it can be checked to confirm that the createTest method was\ncalled."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/Nested.java",
    "type": "method",
    "name": "setNestedIntsColumn",
    "code": "public void setNestedIntsColumn(java.util.List<java.lang.Integer> value) {\n    this.nested_ints_column = value;\n  }",
    "comment": "Sets the value of the 'nested_ints_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/main/java/com/example/android/persistence/migrations/UserPresenter.java",
    "type": "method",
    "name": "UserPresenter",
    "code": "public UserPresenter(UserRepository dataSource, @Nullable UserView view) {\n        mDataSource = dataSource;\n        mView = view;\n\n        mLoadUserCallback = createLoadUserCallback();\n        mUpdateUserCallback = createUpdateUserCallback();\n    }",
    "comment": "Listens for users's actions from the UI {@link UserActivity}, retrieves the data and updates\nthe UI as required."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicSample/app/src/main/java/com/example/android/persistence/BasicApp.java",
    "type": "method",
    "name": "onCreate",
    "code": "public void onCreate() {\n        super.onCreate();\n\n        mAppExecutors = new AppExecutors();\n    }",
    "comment": "Android Application class. Used for accessing singletons."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "byPayload",
    "code": "public static <T> Predicate<Event> byPayload(Class<T> payloadType, Predicate<? super T> payloadPredicate) {\n\t\treturn event -> event.getPayload(payloadType).filter(payloadPredicate).isPresent();\n\t}",
    "comment": "Create a {@link Predicate} for {@linkplain Event events} whose payload\ntypes match the supplied {@code payloadType} and whose payloads match the\nsupplied {@code payloadPredicate}.\n\n@param payloadType the required payload type\n@param payloadPredicate a {@code Predicate} to match against payloads\n@return the resulting {@code Predicate}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(float unexpected, float actual, float delta, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, delta, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal\nwithin the given {@code delta}.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/test/java/org/apache/maven/cling/transfer/FileSizeFormatTest.java",
    "type": "method",
    "name": "testFormatRateThresholds",
    "code": "void testFormatRateThresholds() {\n        FileSizeFormat format = new FileSizeFormat();\n\n        MessageBuilder builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 45.0); // 45 B/s\n        assertEquals(\"45.0 B/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 15000.0); // 15 kB/s\n        assertEquals(\"15.0 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 5500.0); // 5.5 kB/s\n        assertEquals(\"5.5 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000.0); // 1 kB/s\n        assertEquals(\"1.0 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000000.0); // 1 MB/s\n        assertEquals(\"1.0 MB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000000000.0); // 1 GB/s\n        assertEquals(\"1.0 GB/s\", builder.build());\n    }",
    "comment": "Test value less than 0.05\nTest exact unit thresholds\nTest value greater than or equal to 10\nTest value between 0.05 and 10\nTest exact unit thresholds"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/regression/JavaDecisionTreeRegressorSuite.java",
    "type": "method",
    "name": "runDT",
    "code": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 0);\n\n    DecisionTreeRegressor dt = new DecisionTreeRegressor()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String impurity : DecisionTreeRegressor.supportedImpurities()) {\n      dt.setImpurity(impurity);\n    }\n    DecisionTreeRegressionModel model = dt.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.numNodes();\n    model.depth();\n    model.toDebugString();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model2.save(sc.sc(), path);\n      DecisionTreeRegressionModel sameModel = DecisionTreeRegressionModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model2, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
    "comment": "This tests setters. Training with various options is tested in Scala.\nTODO: Add test once save/load are implemented.   SPARK-6725"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/Filter.java",
    "type": "method",
    "name": "toPredicate",
    "code": "default Predicate<T> toPredicate() {\n\t\treturn object -> apply(object).included();\n\t}",
    "comment": "Return a {@link Predicate} that returns {@code true} if this filter\n<em>includes</em> the object supplied to the predicate's\n{@link Predicate#test test} method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/console/tasks/ColorPaletteTests.java",
    "type": "method",
    "name": "verbose_default",
    "code": "void verbose_default() {\n\t\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\tTestExecutionListener listener = new VerboseTreePrintingListener(out, ColorPalette.DEFAULT, 16,\n\t\t\t\tTheme.ASCII);\n\n\t\t\tdemoTestRun(listener);\n\n\t\t\tassertDoesNotThrow(out::flush);\n\t\t}",
    "comment": "TODO Actually assert something in these \"demo\" tests and stop printing to SYSOUT."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/DefaultMaven.java",
    "type": "method",
    "name": "validateOptionalProfiles",
    "code": "private void validateOptionalProfiles(MavenSession session, ProfileActivation profileActivation) {\n        final Set<String> allAvailableProfiles = getAllProfiles(session);\n\n        final Set<String> optionalProfiles = new HashSet<>();\n        optionalProfiles.addAll(profileActivation.getOptionalActiveProfileIds());\n        optionalProfiles.addAll(profileActivation.getOptionalInactiveProfileIds());\n\n        final Set<String> notFoundOptionalProfiles = optionalProfiles.stream()\n                .filter(rap -> !allAvailableProfiles.contains(rap))\n                .collect(toSet());\n\n        if (!notFoundOptionalProfiles.isEmpty()) {\n            logger.info(\n                    \"The requested optional profiles {} could not be activated or deactivated because they do not\"\n                            + \" exist.\",\n                    notFoundOptionalProfiles);\n        }\n    }",
    "comment": "Check whether any of the requested optional profiles were not activated or deactivated.\n@param session the Maven session.\n@param profileActivation the requested optional and required profiles."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "result",
    "code": "public static Condition<Event> result(Condition<TestExecutionResult> condition) {\n\t\treturn new Condition<>(byPayload(TestExecutionResult.class, condition::matches), \"event with result where %s\",\n\t\t\tcondition);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link TestExecutionResult} that matches the supplied {@code Condition}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroArrayOfArray.java",
    "type": "method",
    "name": "setIntArraysColumn",
    "code": "public void setIntArraysColumn(java.util.List<java.util.List<java.lang.Integer>> value) {\n    this.int_arrays_column = value;\n  }",
    "comment": "Sets the value of the 'int_arrays_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "rfind",
    "code": "public int rfind(UTF8String str, int start) {\n    assert (str.numBytes > 0);\n    while (start >= 0) {\n      if (ByteArrayMethods.arrayEquals(base, offset + start, str.base, str.offset, str.numBytes)) {\n        return start;\n      }\n      start -= 1;\n    }\n    return -1;\n  }",
    "comment": "Find the `str` from right to left."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java",
    "type": "method",
    "name": "TestClassPredicates",
    "code": "public TestClassPredicates(DiscoveryIssueReporter issueReporter) {\n\t\tthis.isTestOrTestFactoryOrTestTemplateMethod = new IsTestMethod(issueReporter) //\n\t\t\t\t.or(new IsTestFactoryMethod(issueReporter)) //\n\t\t\t\t.or(new IsTestTemplateMethod(issueReporter));\n\t\tthis.isValidNestedTestClass = isNotPrivateUnlessAbstract(\"@Nested\", issueReporter) //\n\t\t\t\t.and(isInner(issueReporter));\n\t\tthis.isValidStandaloneTestClass = isNotPrivateUnlessAbstract(\"Test\", issueReporter) //\n\t\t\t\t.and(isNotLocal(issueReporter)) //\n\t\t\t\t.and(isNotInner(issueReporter)) // or should be annotated with @Nested!\n\t\t\t\t.and(isNotAnonymous(issueReporter));\n\t}",
    "comment": "Predicates for determining whether a class is a JUnit Jupiter test class.\n\n@since 5.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/OneForOneBlockPusher.java",
    "type": "method",
    "name": "onSuccess",
    "code": "public void onSuccess(ByteBuffer response) {\n      BlockPushReturnCode pushResponse =\n        (BlockPushReturnCode) BlockTransferMessage.Decoder.fromByteBuffer(response);\n      ReturnCode returnCode = BlockPushNonFatalFailure.getReturnCode(pushResponse.returnCode);\n      if (returnCode != ReturnCode.SUCCESS) {\n        String blockId = pushResponse.failureBlockId;\n        Preconditions.checkArgument(!blockId.isEmpty());\n        checkAndFailRemainingBlocks(index, new BlockPushNonFatalFailure(returnCode,\n          BlockPushNonFatalFailure.getErrorMsg(blockId, returnCode)));\n      } else {\n        listener.onBlockPushSuccess(blockId, new NioManagedBuffer(ByteBuffer.allocate(0)));\n      }\n    }",
    "comment": "If the return code is not SUCCESS, the server has responded some error code. Handle\nthe error accordingly.\nOn receipt of a successful block push"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroMapOfArray.java",
    "type": "method",
    "name": "setStringToIntsColumn",
    "code": "public void setStringToIntsColumn(java.util.Map<java.lang.String,java.util.List<java.lang.Integer>> value) {\n    this.string_to_ints_column = value;\n  }",
    "comment": "Sets the value of the 'string_to_ints_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/Preconditions.java",
    "type": "method",
    "name": "checkState",
    "code": "public static void checkState(boolean expression) {\n    if (!expression) {\n      throw new IllegalStateException();\n    }\n  }",
    "comment": "Ensures the truth of an expression involving the state of the calling instance, but not\ninvolving any parameters to the calling method.\n\n@param expression a boolean expression\n@throws IllegalStateException if {@code expression} is false"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/balking/src/main/java/com/iluwatar/balking/WashingMachine.java",
    "type": "method",
    "name": "WashingMachine",
    "code": "public WashingMachine(DelayProvider delayProvider) {\n    this.delayProvider = delayProvider;\n    this.washingMachineState = WashingMachineState.ENABLED;\n  }",
    "comment": "Creates a new instance of WashingMachine using provided delayProvider. This constructor is used\nonly for unit testing purposes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/test/java/com/example/android/persistence/migrations/UserPresenterTest.java",
    "type": "method",
    "name": "onUserLoaded_updatesView",
    "code": "public void onUserLoaded_updatesView() {\n        mPresenter.start();\n        verify(mUserRepository).getUser(mLoadUserCallbackArgumentCaptor.capture());\n\n        User user = new User(\"user name\");\n        mLoadUserCallbackArgumentCaptor.getValue().onUserLoaded(user);\n\n        verify(mView).showUserName(\"user name\");\n    }",
    "comment": "Given that start is called\nCallback is captured\nWhen the user is loaded\nThe view is updated with the correct user name"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/converter/src/test/java/com/iluwatar/converter/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-xml/src/main/java/org/apache/maven/internal/xml/XmlNodeImpl.java",
    "type": "method",
    "name": "merge",
    "code": "public static XmlNode merge(XmlNode dominant, XmlNode recessive) {\n        return XmlService.merge(dominant, recessive);\n    }",
    "comment": "Merge two DOMs, with one having dominance in the case of collision. Merge mechanisms (vs. override for nodes, or\nvs. append for children) is determined by attributes of the dominant root node.\n\n@see XmlService#CHILDREN_COMBINATION_MODE_ATTRIBUTE\n@see XmlService#SELF_COMBINATION_MODE_ATTRIBUTE\n@param dominant The dominant DOM into which the recessive value/attributes/children will be merged\n@param recessive The recessive DOM, which will be merged into the dominant DOM\n@return merged DOM\n\n@deprecated use {@link XmlService#merge(XmlNode, XmlNode, Boolean)} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(byte unexpected, Byte actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Byte) unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Boolean> create(boolean data) {\n    return Tensor.create(data, Boolean.class);\n  }",
    "comment": "Creates a scalar tensor containing a single {@code boolean} element.\n\n@param data The value to put into the new scalar tensor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java",
    "type": "method",
    "name": "registerAfterEachMethodAdapters",
    "code": "private void registerAfterEachMethodAdapters(ExtensionRegistrar registrar) {\n\t\tList<Method> afterEachMethods = new ArrayList<>(this.lifecycleMethods.afterEach);\n\n\t\tCollections.reverse(afterEachMethods);\n\n\t\tregisterMethodsAsExtensions(afterEachMethods, registrar, this::synthesizeAfterEachMethodAdapter);\n\t}",
    "comment": "Make a local copy since findAfterEachMethods() returns an immutable list.\nSince the bottom-up ordering of afterEachMethods will later be reversed when the\nsynthesized AfterEachMethodAdapters are executed within TestMethodTestDescriptor,\nwe have to reverse the afterEachMethods list to put them in top-down order before\nwe register them as synthesized extensions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/BeforeAndAfterAllTests.java",
    "type": "method",
    "name": "beforeAllCallbackThrowsAnException",
    "code": "void beforeAllCallbackThrowsAnException() {\n\t\tassertBeforeAllAndAfterAllCallbacks(ExceptionInBeforeAllCallbackTestCase.class, 0, 0,\n\t\t\t\"fooBeforeAllCallback\",\n\t\t\t\"exceptionThrowingBeforeAllCallback\", // throws an exception.\n\t\t\t\"fooAfterAllCallback\"\n\t\t);\n\n\t\tassertThat(actualExceptionInAfterAllCallback).containsInstanceOf(EnigmaException.class);\n\t}",
    "comment": "@formatter:off\nbeforeAllMethod should not get invoked.\ntest should not get invoked.\nafterAllMethod should not get invoked.\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "reset",
    "code": "public void reset() {\n    updatePeakMemoryUsed();\n    numKeys = 0;\n    numValues = 0;\n    freeArray(longArray);\n    longArray = null;\n    while (dataPages.size() > 0) {\n      MemoryBlock dataPage = dataPages.removeLast();\n      freePage(dataPage);\n    }\n    allocate(initialCapacity);\n    canGrowArray = true;\n    currentPage = null;\n    pageCursor = 0;\n  }",
    "comment": "Reset this map to initialized state."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/factory-kit/src/main/java/com/iluwatar/factorykit/WeaponFactory.java",
    "type": "method",
    "name": "factory",
    "code": "static WeaponFactory factory(Consumer<Builder> consumer) {\n    var map = new HashMap<WeaponType, Supplier<Weapon>>();\n    consumer.accept(map::put);\n    return name -> map.get(name).get();\n  }",
    "comment": "Creates an instance of the given type.\n\n@param name representing enum of an object type to be created.\n@return new instance of a requested class implementing {@link Weapon} interface.\n\n@param consumer for the new builder to the factory.\n@return factory with specified {@link Builder}s"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/ovic/src/main/java/org/tensorflow/ovic/OvicDetector.java",
    "type": "method",
    "name": "detectByteBuffer",
    "code": "boolean detectByteBuffer(ByteBuffer imgData, int imageId) {\n    if (tflite == null) {\n      throw new RuntimeException(TAG + \": Detector has not been initialized; Failed.\");\n    }\n\n    Object[] inputArray = {imgData};\n    tflite.runForMultipleInputsOutputs(inputArray, outputMap);\n\n    Long latencyMilli = getLastNativeInferenceLatencyMilliseconds();\n    Long latencyNano = getLastNativeInferenceLatencyNanoseconds();\n\n    // Update the results.\n    result.resetTo(latencyMilli, latencyNano, imageId);\n    for (int i = 0; i < NUM_RESULTS; i++) {\n      // The model returns normalized coordinates [start_y, start_x, end_y, end_x].\n      // The boxes expect pixel coordinates [x1, y1, x2, y2].\n      // The height and width of the input are in inputDims[1] and inputDims[2].\n      // The following command converts between model outputs to bounding boxes.\n      result.addBox(\n          outputLocations[0][i][1] * inputDims[2],\n          outputLocations[0][i][0] * inputDims[1],\n          outputLocations[0][i][3] * inputDims[2],\n          outputLocations[0][i][2] * inputDims[1],\n          Math.round(outputClasses[0][i] + 1 /* Label offset */),\n          outputScores[0][i]);\n    }\n    return true;  // Marks that the result is available.\n  }",
    "comment": "The interface to run the detection. This method currently only support float mobilenet_ssd\nmodel. The quantized models will be added in the future.\n\n@param imgData The image buffer in ByteBuffer format.\n@return boolean indicator of whether detection was a success. If success, the detection results\nis available in the result member variable.\nSee OvicDetectionResult.java for details."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/path/DefaultPathTranslator.java",
    "type": "method",
    "name": "alignToBaseDirectory",
    "code": "public String alignToBaseDirectory(String path, File basedir) {\n        String result = path;\n\n        if (path != null && basedir != null) {\n            path = path.replace('\\\\', File.separatorChar).replace('/', File.separatorChar);\n\n            File file = new File(path);\n            if (file.isAbsolute()) {\n                // path was already absolute, just normalize file separator and we're done\n                result = file.getPath();\n            } else if (file.getPath().startsWith(File.separator)) {\n                // drive-relative Windows path, don't align with project directory but with drive root\n                result = file.getAbsolutePath();\n            } else {\n                // an ordinary relative path, align with project directory\n                result = new File(new File(basedir, path).toURI().normalize()).getAbsolutePath();\n            }\n        }\n\n        return result;\n    }",
    "comment": "Resolves relative paths against a specific base directory.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/entity/TransportVehicle.java",
    "type": "method",
    "name": "TransportVehicle",
    "code": "protected TransportVehicle(String manufacturer, String model, int loadCapacity) {\n    super(manufacturer, model);\n    this.loadCapacity = loadCapacity;\n  }",
    "comment": "An abstract class that extends the Vehicle class and provides properties for the Transport type\nof Vehicles.\n\n@see Vehicle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/support/scanning/CloseablePathTests.java",
    "type": "method",
    "name": "closeAll",
    "code": "private static void closeAll(List<CloseablePath> paths) {\n\t\tvar throwableCollector = new OpenTest4JAwareThrowableCollector();\n\t\tpaths.forEach(closeablePath -> throwableCollector.execute(closeablePath::close));\n\t\tthrowableCollector.assertEmpty();\n\t}",
    "comment": "Close all but the first path\nClose last remaining path"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/androidTest/java/com/example/android/observability/persistence/UserDaoTest.java",
    "type": "method",
    "name": "insertAndGetUser",
    "code": "public void insertAndGetUser() {\n        mDatabase.userDao().insertUser(USER).blockingAwait();\n\n        mDatabase.userDao().getUser()\n                .test()\n                .assertValue(user -> {\n                    return user != null && user.getId().equals(USER.getId()) &&\n                            user.getUserName().equals(USER.getUserName());\n                });\n    }",
    "comment": "When inserting a new user in the data source\nWhen subscribing to the emissions of the user\nassertValue asserts that there was only one emission of the user\nThe emitted user is the expected one"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "appendEngine",
    "code": "public UniqueId appendEngine(String engineId) {\n\t\treturn append(new Segment(ENGINE_SEGMENT_TYPE, engineId));\n\t}",
    "comment": "Construct a new {@code UniqueId} by appending a new {@link Segment}, based\n\n<p>This {@code UniqueId} will not be modified.\n\n<p>The engine ID will be stored in a {@link Segment} with\n{@link Segment#getType type} {@value #ENGINE_SEGMENT_TYPE}.\n\n@param engineId the engine ID; never {@code null} or blank\n\n@since 1.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/internal/runners/statements/FailOnTimeoutTest.java",
    "type": "method",
    "name": "throwsTestTimedOutExceptionWithMeaningfulMessage",
    "code": "public void throwsTestTimedOutExceptionWithMeaningfulMessage() {\n        Exception e = assertThrows(\n                TestTimedOutException.class,\n                run(failAfter50Ms(new RunForASecond())));\n        assertEquals(\"test timed out after 50 milliseconds\", e.getMessage());\n    }",
    "comment": "test is successful when no exception is thrown"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/LegacyCameraConnectionFragment.java",
    "type": "method",
    "name": "onResume",
    "code": "public void onResume() {\n    super.onResume();\n    startBackgroundThread();\n\n    if (textureView.isAvailable()) {\n      camera.startPreview();\n    } else {\n      textureView.setSurfaceTextureListener(surfaceTextureListener);\n    }\n  }",
    "comment": "When the screen is turned off and turned back on, the SurfaceTexture is already\navailable, and \"onSurfaceTextureAvailable\" will not be called. In that case, we can open\na camera and start preview from here (otherwise, we wait until the surface is ready in\nthe SurfaceTextureListener)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/model-view-intent/src/main/java/com/iluwatar/model/view/intent/CalculatorViewModel.java",
    "type": "method",
    "name": "setVariable",
    "code": "private void setVariable(final Double variable) {\n    model = new CalculatorModel(variable, model.getOutput());\n  }",
    "comment": "Set new calculator model variable.\n\n@param variable -> value of new calculator model variable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/UnknownRepositoryLayoutException.java",
    "type": "method",
    "name": "UnknownRepositoryLayoutException",
    "code": "public UnknownRepositoryLayoutException(String repositoryId, String layoutId) {\n        super(\"Cannot find ArtifactRepositoryLayout instance for: \" + layoutId, repositoryId);\n        this.layoutId = layoutId;\n    }",
    "comment": "Exception which is meant to occur when a layout specified for a particular\nrepository doesn't have a corresponding {@link org.apache.maven.artifact.repository.layout.ArtifactRepositoryLayout}\ncomponent in the current container."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/feature/JavaVectorIndexerSuite.java",
    "type": "method",
    "name": "vectorIndexerAPI",
    "code": "public void vectorIndexerAPI() {\n    List<FeatureData> points = Arrays.asList(\n      new FeatureData(Vectors.dense(0.0, -2.0)),\n      new FeatureData(Vectors.dense(1.0, 3.0)),\n      new FeatureData(Vectors.dense(1.0, 4.0))\n    );\n    Dataset<Row> data = spark.createDataFrame(jsc.parallelize(points, 2), FeatureData.class);\n    VectorIndexer indexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexed\")\n      .setMaxCategories(2);\n    VectorIndexerModel model = indexer.fit(data);\n    Assertions.assertEquals(2, model.numFeatures());\n    Map<Integer, Map<Double, Integer>> categoryMaps = model.javaCategoryMaps();\n    Assertions.assertEquals(1, categoryMaps.size());\n    Dataset<Row> indexedData = model.transform(data);\n  }",
    "comment": "The tests are to check Java compatibility."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "acquireNewPage",
    "code": "private boolean acquireNewPage(long required) {\n    try {\n      currentPage = allocatePage(required);\n    } catch (SparkOutOfMemoryError e) {\n      return false;\n    }\n    dataPages.add(currentPage);\n    UnsafeAlignedOffset.putSize(currentPage.getBaseObject(), currentPage.getBaseOffset(), 0);\n    pageCursor = UnsafeAlignedOffset.getUaoSize();\n    return true;\n  }",
    "comment": "Acquire a new page from the memory manager.\n@return whether there is enough space to allocate the new page."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/feature/JavaTfIdfSuite.java",
    "type": "method",
    "name": "tfIdfMinimumDocumentFrequency",
    "code": "public void tfIdfMinimumDocumentFrequency() {\n    HashingTF tf = new HashingTF();\n    JavaRDD<List<String>> documents = jsc.parallelize(Arrays.asList(\n      Arrays.asList(\"this is a sentence\".split(\" \")),\n      Arrays.asList(\"this is another sentence\".split(\" \")),\n      Arrays.asList(\"this is still a sentence\".split(\" \"))), 2);\n    JavaRDD<Vector> termFreqs = tf.transform(documents);\n    termFreqs.collect();\n    IDF idf = new IDF(2);\n    JavaRDD<Vector> tfIdfs = idf.fit(termFreqs).transform(termFreqs);\n    List<Vector> localTfIdfs = tfIdfs.collect();\n    int indexOfThis = tf.indexOf(\"this\");\n    for (Vector v : localTfIdfs) {\n      Assertions.assertEquals(0.0, v.apply(indexOfThis), 1e-15);\n    }\n  }",
    "comment": "The tests are to check Java compatibility."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/collection-pipeline/src/main/java/com/iluwatar/collectionpipeline/FunctionalProgramming.java",
    "type": "method",
    "name": "getModelsAfter2000",
    "code": "public static List<String> getModelsAfter2000(List<Car> cars) {\n    return cars.stream()\n        .filter(car -> car.year() > 2000)\n        .sorted(Comparator.comparing(Car::year))\n        .map(Car::model)\n        .toList();\n  }",
    "comment": "Method to get models using for collection pipeline.\n\n@param cars {@link List} of {@link Car} to be used for filtering\n@return {@link List} of {@link String} representing models built after year 2000"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "setMainClass",
    "code": "public T setMainClass(String mainClass) {\n    checkNotNull(mainClass, \"mainClass\");\n    builder.mainClass = mainClass;\n    return self();\n  }",
    "comment": "Sets the application class name for Java/Scala applications.\n\n@param mainClass Application's main class.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng0187CollectedProjectsTest.java",
    "type": "method",
    "name": "getProjects",
    "code": "private List<String> getProjects(Properties props) {\n        List<String> projects = new ArrayList<>();\n\n        for (Object o : props.keySet()) {\n            String key = o.toString();\n            if (key.startsWith(\"project.collectedProjects.\") && !key.endsWith(\".size\")) {\n                projects.add(props.getProperty(key));\n            }\n        }\n\n        Collections.sort(projects);\n\n        return projects;\n    }",
    "comment": "Verify that MavenProject.getCollectedProjects() provides access to the direct and indirect modules\nof the current project.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/ChildProcAppHandle.java",
    "type": "method",
    "name": "getError",
    "code": "public Optional<Throwable> getError() {\n    return redirector != null ? Optional.ofNullable(redirector.getError()) : Optional.empty();\n  }",
    "comment": "Parses the logs of {@code spark-submit} and returns the last exception thrown.\n<p>\nSince {@link SparkLauncher} runs {@code spark-submit} in a sub-process, it's difficult to\naccurately retrieve the full {@link Throwable} from the {@code spark-submit} process.\nThis method parses the logs of the sub-process and provides a best-effort attempt at\nreturning the last exception thrown by the {@code spark-submit} process. Only the exception\nmessage is parsed, the associated stacktrace is meaningless.\n\n@return an {@link Optional} containing a {@link RuntimeException} with the parsed\nexception, otherwise returns a {@link Optional#EMPTY}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProjectManager.java",
    "type": "method",
    "name": "attachArtifact",
    "code": "default void attachArtifact(@Nonnull Session session, @Nonnull Project project, @Nonnull Path path) {\n        String name = path.getFileName().toString();\n        int dot = name.lastIndexOf('.');\n        String ext = dot >= 1 ? name.substring(dot + 1) : \"\";\n        ProducedArtifact artifact = session.createProducedArtifact(\n                project.getGroupId(), project.getArtifactId(), project.getVersion(), ext);\n        attachArtifact(project, artifact, path);\n    }",
    "comment": "Attaches an artifact to the project using the given file path. The artifact type will be\ndetermined from the file extension. This method is thread-safe and ensures proper\nsynchronization of the project's artifact state.\n\n@param session the current build session\n@param project the project to attach the artifact to\n@param path the path to the artifact file"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/api/services/model/ModelResolverException.java",
    "type": "method",
    "name": "ModelResolverException",
    "code": "public ModelResolverException(String message, String groupId, String artifactId, String version) {\n        super(message);\n        this.groupId = (groupId != null) ? groupId : \"\";\n        this.artifactId = (artifactId != null) ? artifactId : \"\";\n        this.version = (version != null) ? version : \"\";\n    }",
    "comment": "Creates a new exception with specified detail message.\n\n@param message The detail message, may be {@code null}.\n@param groupId The group id of the unresolvable model, may be {@code null}.\n@param artifactId The artifact id of the unresolvable model, may be {@code null}.\n@param version The version of the unresolvable model, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/test/java/com/iluwatar/async/method/invocation/ThreadAsyncExecutorTest.java",
    "type": "method",
    "name": "testSuccessfulTaskWithCallback",
    "code": "void testSuccessfulTaskWithCallback() {\n    assertTimeout(\n        ofMillis(3000),\n        () -> {\n          // Instantiate a new executor and start a new 'null' task ...\n          final var executor = new ThreadAsyncExecutor();\n\n          final var result = new Object();\n          when(task.call()).thenReturn(result);\n\n          final var asyncResult = executor.startProcess(task, callback);\n          assertNotNull(asyncResult);\n          asyncResult.await(); // Prevent timing issues, and wait until the result is available\n          assertTrue(asyncResult.isCompleted());\n\n          // Our task should only execute once ...\n          verify(task, times(1)).call();\n\n          // ... same for the callback, we expect our object\n          verify(callback, times(1)).onComplete(eq(result));\n          verify(callback, times(0)).onError(exceptionCaptor.capture());\n\n          // ... and the result should be exactly the same object\n          assertSame(result, asyncResult.getValue());\n        });\n  }",
    "comment": "Test used to verify the happy path of {@link ThreadAsyncExecutor#startProcess(Callable,\nAsyncCallback)}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/mute-idiom/src/main/java/com/iluwatar/mute/Mute.java",
    "type": "method",
    "name": "mute",
    "code": "public static void mute(CheckedRunnable runnable) {\n    try {\n      runnable.run();\n    } catch (Exception e) {\n      throw new AssertionError(e);\n    }\n  }",
    "comment": "Executes the <code>runnable</code> and throws the exception occurred within a {@link\nAssertionError}. This method should be utilized to mute the operations that are guaranteed not\nto throw an exception. For instance {@link ByteArrayOutputStream#write(byte[])} declares in its\nsignature that it can throw an {@link IOException}, but in reality it cannot. This is because\nthe bulk write method is not overridden in {@link ByteArrayOutputStream}.\n\n@param runnable a runnable that should never throw an exception on execution."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/lockable-object/src/main/java/com/iluwatar/lockableobject/domain/Creature.java",
    "type": "method",
    "name": "isAlive",
    "code": "public synchronized boolean isAlive() {\n    return getHealth() > 0;\n  }",
    "comment": "Checks if the creature is still alive.\n\n@return true of creature is alive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Timeout.java",
    "type": "method",
    "name": "millis",
    "code": "public static Timeout millis(long millis) {\n        return new Timeout(millis, TimeUnit.MILLISECONDS);\n    }",
    "comment": "Creates a {@link Timeout} that will timeout a test after the\ngiven duration, in milliseconds.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "getMethodName",
    "code": "public String getMethodName() {\n        return methodAndClassNamePatternGroupOrDefault(1, null);\n    }",
    "comment": "@return If this describes a method invocation,\nthe name of the method (or null if not)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/feature/JavaStandardScalerSuite.java",
    "type": "method",
    "name": "standardScaler",
    "code": "public void standardScaler() {\n    List<VectorIndexerSuite.FeatureData> points = Arrays.asList(\n      new VectorIndexerSuite.FeatureData(Vectors.dense(0.0, -2.0)),\n      new VectorIndexerSuite.FeatureData(Vectors.dense(1.0, 3.0)),\n      new VectorIndexerSuite.FeatureData(Vectors.dense(1.0, 4.0))\n    );\n    Dataset<Row> dataFrame = spark.createDataFrame(jsc.parallelize(points, 2),\n      VectorIndexerSuite.FeatureData.class);\n    StandardScaler scaler = new StandardScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\")\n      .setWithStd(true)\n      .setWithMean(false);\n\n    StandardScalerModel scalerModel = scaler.fit(dataFrame);\n\n    Dataset<Row> scaledData = scalerModel.transform(dataFrame);\n    scaledData.count();\n  }",
    "comment": "The tests are to check Java compatibility.\nCompute summary statistics by fitting the StandardScaler\nNormalize each feature to have unit standard deviation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Short unexpected, short actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Short) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationSupport.java",
    "type": "method",
    "name": "exec",
    "code": "public static UTF8String exec(final UTF8String v, final int collationId, boolean useICU) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType) {\n        return useICU ? execBinaryICU(v) : execBinary(v);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(v);\n      } else {\n        return execICU(v, collationId);\n      }\n    }",
    "comment": "Space trimming does not affect the output of this expression."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/BenchmarkLatencyImpl.java",
    "type": "method",
    "name": "tryLoadLatencyCriteria",
    "code": "private LatencyCriteria tryLoadLatencyCriteria(String fileBasename) {\n    try {\n      return loadLatencyCriteria(fileBasename);\n    } catch (IOException e) {\n      Log.w(\n          TAG,\n          \"Failed to load the latency criteria of \"\n              + fileBasename\n              + \". Fallback to the default latency criteria.\");\n    }\n    return defaultLatencyCriteria;\n  }",
    "comment": "Tries to load the model-specific latency criteria file by the model name.\n\n<p>Returns the latency criteria for the specific model if the loading was successful.\nOtherwise, returns the default latency criteria."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/feature-toggle/src/main/java/com/iluwatar/featuretoggle/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    // Demonstrates the PropertiesFeatureToggleVersion running with properties\n    // that set the feature toggle to enabled.\n\n    final var properties = new Properties();\n    properties.put(\"enhancedWelcome\", true);\n    var service = new PropertiesFeatureToggleVersion(properties);\n    final var welcomeMessage = service.getWelcomeMessage(new User(\"Jamie No Code\"));\n    LOGGER.info(welcomeMessage);\n\n    // Demonstrates the PropertiesFeatureToggleVersion running with properties\n    // that set the feature toggle to disabled. Note the difference in the printed welcome message\n    // where the username is not included.\n\n    final var turnedOff = new Properties();\n    turnedOff.put(\"enhancedWelcome\", false);\n    var turnedOffService = new PropertiesFeatureToggleVersion(turnedOff);\n    final var welcomeMessageturnedOff =\n        turnedOffService.getWelcomeMessage(new User(\"Jamie No Code\"));\n    LOGGER.info(welcomeMessageturnedOff);\n\n    // Demonstrates the TieredFeatureToggleVersion setup with\n    // two users: one on the free tier and the other on the paid tier. When the\n    // Service#getWelcomeMessage(User) method is called with the paid user, the welcome\n    // message includes their username. In contrast, calling the same service with the free tier\n    // user results\n    // in a more generic welcome message without the username.\n\n    var service2 = new TieredFeatureToggleVersion();\n\n    final var paidUser = new User(\"Jamie Coder\");\n    final var freeUser = new User(\"Alan Defect\");\n\n    UserGroup.addUserToPaidGroup(paidUser);\n    UserGroup.addUserToFreeGroup(freeUser);\n\n    final var welcomeMessagePaidUser = service2.getWelcomeMessage(paidUser);\n    final var welcomeMessageFreeUser = service2.getWelcomeMessage(freeUser);\n    LOGGER.info(welcomeMessageFreeUser);\n    LOGGER.info(welcomeMessagePaidUser);\n  }",
    "comment": "Block 1 shows the {@link PropertiesFeatureToggleVersion} being run with {@link Properties}\nsetting the feature toggle to enabled.\n\n<p>Block 2 shows the {@link PropertiesFeatureToggleVersion} being run with {@link Properties}\nsetting the feature toggle to disabled. Notice the difference with the printed welcome message\nthe username is not included.\n\n<p>Block 3 shows the {@link\ncom.iluwatar.featuretoggle.pattern.tieredversion.TieredFeatureToggleVersion} being set up with\ntwo users on who is on the free level, while the other is on the paid level. When the {@link\nService#getWelcomeMessage(User)} is called with the paid {@link User} note that the welcome\nmessage contains their username, while the same service call with the free tier user is more\ngeneric. No username is printed.\n\n@see User\n@see UserGroup\n@see Service\n@see PropertiesFeatureToggleVersion\n@see com.iluwatar.featuretoggle.pattern.tieredversion.TieredFeatureToggleVersion"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/WagonA.java",
    "type": "method",
    "name": "getSupportedProtocols",
    "code": "public String[] getSupportedProtocols() {\n        return new String[] {\"a\"};\n}",
    "comment": "Wagon for testing, for protocol <code>a</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/server/ThreadFactoryWithGarbageCleanup.java",
    "type": "method",
    "name": "ThreadFactoryWithGarbageCleanup",
    "code": "public ThreadFactoryWithGarbageCleanup(String threadPoolName) {\n    namePrefix = threadPoolName;\n  }",
    "comment": "A ThreadFactory for constructing new HiveServer2 threads that lets you plug\nin custom cleanup code to be called before this thread is GC-ed.\nCurrently cleans up the following:\n1. ThreadLocal RawStore object:\nIn case of an embedded metastore, HiveServer2 threads (foreground and background)\nend up caching a ThreadLocal RawStore object. The ThreadLocal RawStore object has\nan instance of PersistenceManagerFactory and PersistenceManager.\nThe PersistenceManagerFactory keeps a cache of PersistenceManager objects,\nwhich are only removed when PersistenceManager#close method is called.\nHiveServer2 uses ExecutorService for managing thread pools for foreground and background threads.\nExecutorService unfortunately does not provide any hooks to be called,\nwhen a thread from the pool is terminated.\nAs a solution, we're using this ThreadFactory to keep a cache of RawStore objects per thread.\nAnd we are doing clean shutdown in the finalizer for each thread."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertDoesNotThrowAssertionsTests.java",
    "type": "method",
    "name": "assertDoesNotThrowWithMethodReferenceForNonVoidReturnType",
    "code": "void assertDoesNotThrowWithMethodReferenceForNonVoidReturnType() {\n\t\tFutureTask<String> future = new FutureTask<>(() -> {\n\t\tfuture.run();\n\n\t\tString result;\n\n\t\t// Current compiler's type inference: does NOT compile since the compiler\n\t\t// cannot figure out which overloaded variant of assertDoesNotThrow() to\n\t\t// invoke (i.e., Executable vs. ThrowingSupplier).\n\t\t//\n\t\t// result = assertDoesNotThrow(future::get);\n\n\t\t// Explicitly as an Executable\n\t\tassertDoesNotThrow((Executable) future::get);\n\n\t\t// Explicitly as a ThrowingSupplier\n\t\tresult = assertDoesNotThrow((ThrowingSupplier<String>) future::get);\n\t\tassertEquals(\"foo\", result);\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithMethodReferenceForVoidReturnType() {\n\t\tvar foo = new Foo();\n\n\t\t// Note: the following does not compile since the compiler cannot properly\n\t\t// perform type inference for a method reference for an overloaded method\n\t\t// that has a void return type such as Foo.overloaded(...), IFF the\n\t\t// compiler is simultaneously trying to pick which overloaded variant\n\t\t// of assertDoesNotThrow() to invoke.\n\t\t//\n\t\t// assertDoesNotThrow(foo::overloaded);\n\n\t\t// Current compiler's type inference\n\t\tassertDoesNotThrow(foo::normalMethod);\n\n\t\t// Explicitly as an Executable\n\t\tassertDoesNotThrow(foo::normalMethod);\n\t\tassertDoesNotThrow((Executable) foo::overloaded);\n\t}\n\n\t// --- executable ----------------------------------------------------------\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithExecutable() {\n\t\tassertDoesNotThrow(nix);\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithExecutableAndMessage() {\n\t\tassertDoesNotThrow(nix, \"message\");\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithExecutableAndMessageSupplier() {\n\t\tassertDoesNotThrow(nix, () -> \"message\");\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsACheckedException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IOException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IOException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsACheckedExceptionWithMessage() {\n\t\tString message = \"Checked exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IOException(message);\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IOException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsARuntimeException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsARuntimeExceptionWithMessage() {\n\t\tString message = \"Runtime exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Unexpected exception thrown: \" + IllegalStateException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnError() {\n\t\ttry {\n\t\t\tassertDoesNotThrow(AssertionTestUtils::recurseIndefinitely);\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + StackOverflowError.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageString() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageWithMessageString() {\n\t\tString message = \"Runtime exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t}, \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Custom message ==> Unexpected exception thrown: \"\n\t\t\t\t\t+ IllegalStateException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageSupplier() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, () -> \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageWithMessageSupplier() {\n\t\tString message = \"Runtime exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t}, () -> \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Custom message ==> Unexpected exception thrown: \"\n\t\t\t\t\t+ IllegalStateException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t// --- supplier ------------------------------------------------------------\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithSupplier() {\n\t\tassertEquals(\"enigma\", assertDoesNotThrow(something));\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithSupplierAndMessage() {\n\t\tassertEquals(\"enigma\", assertDoesNotThrow(something, \"message\"));\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithSupplierAndMessageSupplier() {\n\t\tassertEquals(\"enigma\", assertDoesNotThrow(something, () -> \"message\"));\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsACheckedException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IOException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IOException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsARuntimeException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsAnError() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new StackOverflowError();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + StackOverflowError.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsAnExceptionWithMessageString() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsAnExceptionWithMessageSupplier() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, () -> \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\tprivate static class Foo {\n\n\t\tvoid normalMethod() {\n\t\t}\n\n\t\tvoid overloaded() {\n\t\t}\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tvoid overloaded(int i) {\n\t\t}\n\n\t}\n\n}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/CommandBuilderUtils.java",
    "type": "method",
    "name": "quoteForBatchScript",
    "code": "static String quoteForBatchScript(String arg) {\n\n    boolean needsQuotes = false;\n    for (int i = 0; i < arg.length(); i++) {\n      int c = arg.codePointAt(i);\n      if (Character.isWhitespace(c) || c == '\"' || c == '=' || c == ',' || c == ';') {\n        needsQuotes = true;\n        break;\n      }\n    }\n    if (!needsQuotes) {\n      return arg;\n    }\n    StringBuilder quoted = new StringBuilder();\n    quoted.append(\"\\\"\");\n    for (int i = 0; i < arg.length(); i++) {\n      int cp = arg.codePointAt(i);\n      switch (cp) {\n        case '\"' -> quoted.append('\"');\n        default -> {}\n      }\n      quoted.appendCodePoint(cp);\n    }\n    if (arg.codePointAt(arg.length() - 1) == '\\\\') {\n      quoted.append(\"\\\\\");\n    }\n    quoted.append(\"\\\"\");\n    return quoted.toString();\n  }",
    "comment": "Quote a command argument for a command to be run by a Windows batch script, if the argument\nneeds quoting. Arguments only seem to need quotes in batch scripts if they have certain\nspecial characters, some of which need extra (and different) escaping.\n\nFor example:\noriginal single argument: ab=\"cde fgh\"\nquoted: \"ab^=\"\"cde fgh\"\"\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/lifecycle/LifecycleExecutorTest.java",
    "type": "method",
    "name": "getExecutions",
    "code": "List<MojoExecution> getExecutions(MavenExecutionPlan mavenExecutionPlan) {\n        List<MojoExecution> result = new ArrayList<>();\n        for (ExecutionPlanItem executionPlanItem : mavenExecutionPlan) {\n            result.add(executionPlanItem.getMojoExecution());\n        }\n        return result;\n    }",
    "comment": "-----------------------------------------------------------------------------------------------\nTests which exercise the lifecycle executor when it is dealing with default lifecycle phases.\n-----------------------------------------------------------------------------------------------\nWe are doing something like \"mvn resources:resources\" where no version is specified but this\nproject we are working on has the version specified in the POM so the version should come from there.\nWe are doing something like \"mvn clean:clean\" where no version is specified but this\nproject we are working on has the version specified in the POM so the version should come from there.\nWe are doing something like \"mvn clean:clean\" where no version is specified but this\nproject we are working on has the version specified in the POM so the version should come from there."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RetryingBlockTransferor.java",
    "type": "method",
    "name": "initiateRetry",
    "code": "synchronized boolean initiateRetry(Throwable e) {\n    if (enableSaslRetries && e instanceof SaslTimeoutException) {\n      saslRetryCount += 1;\n    }\n    retryCount += 1;\n    currentListener = new RetryingBlockTransferListener();\n\n    logger.info(\"Retrying {} ({}/{}) for {} outstanding blocks after {} ms\",\n      MDC.of(LogKeys.TRANSFER_TYPE$.MODULE$, listener.getTransferType()),\n      MDC.of(LogKeys.NUM_RETRY$.MODULE$, retryCount),\n      MDC.of(LogKeys.MAX_ATTEMPTS$.MODULE$, maxRetries),\n      MDC.of(LogKeys.NUM_BLOCKS$.MODULE$, outstandingBlocksIds.size()),\n      MDC.of(LogKeys.RETRY_WAIT_TIME$.MODULE$, retryWaitTime));\n\n    try {\n      executorService.execute(() -> {\n        Uninterruptibles.sleepUninterruptibly(retryWaitTime, TimeUnit.MILLISECONDS);\n        transferAllOutstanding();\n      });\n    } catch (Throwable t) {\n      logger.error(\"Exception while trying to initiate retry\", t);\n      return false;\n    }\n\n    return true;\n  }",
    "comment": "Lightweight method which initiates a retry in a different thread. The retry will involve\ncalling transferAllOutstanding() after a configured wait time.\nReturns true if the retry was successfully initiated, false otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "compare",
    "code": "public int compare(final Size lhs, final Size rhs) {\n      // We cast here to ensure the multiplications won't overflow\n      return Long.signum(\n          (long) lhs.getWidth() * lhs.getHeight() - (long) rhs.getWidth() * rhs.getHeight());\n    }",
    "comment": "Compares two {@code Size}s based on their areas."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(int expected, int actual) {\n        assertEquals(null, expected, actual);\n    }",
    "comment": "Asserts that two ints are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/RemoteBlockPushResolverSuite.java",
    "type": "method",
    "name": "testFinalizationResultIsEmptyWhenTheServerDidNotReceiveAnyBlocks",
    "code": "public void testFinalizationResultIsEmptyWhenTheServerDidNotReceiveAnyBlocks() {\n    MergeStatuses statuses = pushResolver.finalizeShuffleMerge(\n        new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 1, 0));\n    assertEquals(0, statuses.reduceIds.length, \"no partitions were merged\");\n    RemoteBlockPushResolver.AppShuffleInfo appShuffleInfo =\n        pushResolver.validateAndGetAppShuffleInfo(TEST_APP);\n    assertTrue(appShuffleInfo.getShuffles().get(1).isFinalized(),\n      \"shuffle 1 should be marked finalized\");\n    removeApplication(TEST_APP);\n  }",
    "comment": "For the previous merge id\nstream 2 now completes\nshuffle 1 0 is finalized even though the server didn't receive any blocks for it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/PropertyProfileActivator.java",
    "type": "method",
    "name": "isActive",
    "code": "public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        Activation activation = profile.getActivation();\n\n        if (activation == null) {\n            return false;\n        }\n\n        ActivationProperty property = activation.getProperty();\n\n        if (property == null) {\n            return false;\n        }\n\n        String name = property.getName();\n        boolean reverseName = false;\n\n        if (name != null && name.startsWith(\"!\")) {\n            reverseName = true;\n            name = name.substring(1);\n        }\n\n        if (name == null || name.isEmpty()) {\n            problems.add(\n                    BuilderProblem.Severity.ERROR,\n                    ModelProblem.Version.BASE,\n                    \"The property name is required to activate the profile \" + profile.getId(),\n                    property.getLocation(\"\"));\n            return false;\n        }\n\n        String sysValue = context.getUserProperty(name);\n        if (sysValue == null && \"packaging\".equals(name)) {\n            sysValue = context.getModelPackaging();\n        }\n        if (sysValue == null) {\n            sysValue = context.getSystemProperty(name);\n        }\n\n        String propValue = property.getValue();\n        if (propValue != null && !propValue.isEmpty()) {\n            boolean reverseValue = false;\n            if (propValue.startsWith(\"!\")) {\n                reverseValue = true;\n                propValue = propValue.substring(1);\n            }\n\n            // we have a value, so it has to match the system value...\n            return reverseValue != propValue.equals(sysValue);\n        } else {\n            return reverseName != (sysValue != null && !sysValue.isEmpty());\n        }\n    }",
    "comment": "Determines profile activation based on the existence or value of some execution property.\n\n@see ActivationProperty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "fromBytes",
    "code": "public static UTF8String fromBytes(byte[] bytes) {\n    if (bytes != null) {\n      return new UTF8String(bytes, BYTE_ARRAY_OFFSET, bytes.length);\n    } else {\n      return null;\n    }\n  }",
    "comment": "Creates an UTF8String from byte array, which should be encoded in UTF-8.\n\nNote: `bytes` will be hold by returned UTF8String."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "lookup",
    "code": "public Location lookup(Object keyBase, long keyOffset, int keyLength, int hash) {\n    safeLookup(keyBase, keyOffset, keyLength, loc, hash);\n    return loc;\n  }",
    "comment": "Looks up a key, and return a {@link Location} handle that can be used to test existence\nand read/write values.\n\nThis function always returns the same {@link Location} instance to avoid object allocation.\nThis function is not thread-safe."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java",
    "type": "method",
    "name": "from",
    "code": "public static MethodSource from(String className, String methodName, String methodParameterTypes) {\n\t\treturn new MethodSource(className, methodName, methodParameterTypes);\n\t}",
    "comment": "Create a new {@code MethodSource} using the supplied class name, method\n@param methodName the method name; must not be {@code null} or blank\n@param methodParameterTypes a comma-separated list of fully qualified\nclass names representing the method parameter types"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Float> create(Scope scope, long[] shape, FloatBuffer data) {\n    try (Tensor<Float> value = Tensor.create(shape, data)) {\n      return createWithTensor(scope, value);\n    }\n  }",
    "comment": "Create a {@link DataType#FLOAT} constant with data from the given buffer.\n\n<p>Creates a constant with the given shape by copying elements from the buffer (starting from\nits current position) into the tensor. For example, if {@code shape = {2,3} } (which represents\na 2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param scope is a scope used to add the underlying operation.\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@return a float constant\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/util/V2ExpressionSQLBuilder.java",
    "type": "method",
    "name": "visitContains",
    "code": "protected String visitContains(String l, String r) {\n    String value = r.substring(1, r.length() - 1);\n    return l + \" LIKE '%\" + escapeSpecialCharsForLikePattern(value) + \"%' ESCAPE '\\\\'\";\n  }",
    "comment": "Remove quotes at the beginning and end.\ne.g. converts \"'str'\" to \"str\"."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/logging/LoggingExecutionListener.java",
    "type": "method",
    "name": "afterProjectExecutionFailure",
    "code": "public void afterProjectExecutionFailure(ProjectExecutionEvent projectExecutionEvent) {\n        MavenSession session = projectExecutionEvent.getSession();\n        boolean halted;\n        ReactorBuildStatus status =\n                (ReactorBuildStatus) session.getRepositorySession().getData().get(ReactorBuildStatus.class);\n        if (status != null) {\n            halted = status.isHalted();\n        } else {\n            Throwable t = projectExecutionEvent.getCause();\n            halted = (t instanceof RuntimeException || !(t instanceof Exception))\n                    || !MavenExecutionRequest.REACTOR_FAIL_NEVER.equals(session.getReactorFailureBehavior())\n                            && !MavenExecutionRequest.REACTOR_FAIL_AT_END.equals(session.getReactorFailureBehavior());\n        }\n        Throwable cause = projectExecutionEvent.getCause();\n        buildEventListener.executionFailure(\n                projectExecutionEvent.getProject().getArtifactId(), halted, cause != null ? cause.toString() : null);\n    }",
    "comment": "The ReactorBuildStatus is only available if the SmartBuilder is used\nassume sensible default"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "test",
    "code": "public static Condition<Event> test(String uniqueIdSubstring) {\n\t\treturn test(uniqueIdSubstring(uniqueIdSubstring));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\na {@linkplain TestDescriptor#isTest() test} and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the supplied\n{@link String}.\n\n@see #test()\n@see #uniqueIdSubstring(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "setInterval",
    "code": "public void setInterval(int ordinal, CalendarInterval value) {\n    assertIndexIsValid(ordinal);\n    long cursor = getLong(ordinal) >>> 32;\n    assert cursor > 0 : \"invalid cursor \" + cursor;\n    if (value == null) {\n      setNullAt(ordinal);\n      Platform.putLong(baseObject, baseOffset + cursor, 0L);\n      Platform.putLong(baseObject, baseOffset + cursor + 8, 0L);\n      Platform.putLong(baseObject, getFieldOffset(ordinal), (cursor << 32) | 16L);\n    } else {\n      long longVal =\n        ((long) value.months & 0xFFFFFFFFL) | (((long) value.days << 32) & 0xFFFFFFFF00000000L);\n      Platform.putLong(baseObject, baseOffset + cursor, longVal);\n      Platform.putLong(baseObject, baseOffset + cursor + 8, value.microseconds);\n      setLong(ordinal, (cursor << 32) | 16L);\n    }\n  }",
    "comment": "zero-out the bytes\nkeep the offset for future update"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/reporting/ReportEntry.java",
    "type": "method",
    "name": "from",
    "code": "public static ReportEntry from(Map<String, String> keyValuePairs) {\n\t\tPreconditions.notNull(keyValuePairs, \"keyValuePairs must not be null\");\n\n\t\tReportEntry reportEntry = new ReportEntry();\n\t\tkeyValuePairs.forEach(reportEntry::add);\n\t\treturn reportEntry;\n\t}",
    "comment": "Factory for creating a new {@code ReportEntry} from a map of key-value pairs.\n{@code null} or blank"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaMinHashLSHExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaMinHashLSHExample\")\n      .getOrCreate();\n\n    // $example on$\n    List<Row> dataA = Arrays.asList(\n      RowFactory.create(0, Vectors.sparse(6, new int[]{0, 1, 2}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(1, Vectors.sparse(6, new int[]{2, 3, 4}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(2, Vectors.sparse(6, new int[]{0, 2, 4}, new double[]{1.0, 1.0, 1.0}))\n      RowFactory.create(0, Vectors.sparse(6, new int[]{1, 3, 5}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(1, Vectors.sparse(6, new int[]{2, 3, 5}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(2, Vectors.sparse(6, new int[]{1, 2, 4}, new double[]{1.0, 1.0, 1.0}))\n    StructType schema = new StructType(new StructField[]{\n    Dataset<Row> dfA = spark.createDataFrame(dataA, schema);\n    Dataset<Row> dfB = spark.createDataFrame(dataB, schema);\n\n    int[] indices = {1, 3};\n    double[] values = {1.0, 1.0};\n    Vector key = Vectors.sparse(6, indices, values);\n\n    MinHashLSH mh = new MinHashLSH()\n      .setNumHashTables(5)\n      .setInputCol(\"features\")\n      .setOutputCol(\"hashes\");\n\n    MinHashLSHModel model = mh.fit(dfA);\n\n    // Feature Transformation\n    System.out.println(\"The hashed dataset where hashed values are stored in the column 'hashes':\");\n    model.transform(dfA).show();\n\n    // Compute the locality sensitive hashes for the input rows, then perform approximate\n    // similarity join.\n    // We could avoid computing hashes by passing in the already-transformed dataset, e.g.\n    // `model.approxSimilarityJoin(transformedA, transformedB, 0.6)`\n    System.out.println(\"Approximately joining dfA and dfB on Jaccard distance smaller than 0.6:\");\n    model.approxSimilarityJoin(dfA, dfB, 0.6, \"JaccardDistance\")\n      .select(col(\"datasetA.id\").alias(\"idA\"),\n        col(\"datasetB.id\").alias(\"idB\"),\n        col(\"JaccardDistance\")).show();\n\n    // Compute the locality sensitive hashes for the input rows, then perform approximate nearest\n    // neighbor search.\n    // We could avoid computing hashes by passing in the already-transformed dataset, e.g.\n    // `model.approxNearestNeighbors(transformedA, key, 2)`\n    // It may return less than 2 rows when not enough approximate near-neighbor candidates are\n    // found.\n    System.out.println(\"Approximately searching dfA for 2 nearest neighbors of the key:\");\n    model.approxNearestNeighbors(dfA, key, 2).show();\n    // $example off$\n\n    spark.stop();\n  }\n}",
    "comment": "An example demonstrating MinHashLSH.\nRun with:\nbin/run-example ml.JavaMinHashLSHExample"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvn/MavenParser.java",
    "type": "method",
    "name": "parseMavenConfigOptions",
    "code": "protected MavenOptions parseMavenConfigOptions(Path configFile) {\n        try (Stream<String> lines = Files.lines(configFile, Charset.defaultCharset())) {\n            List<String> args =\n                    lines.filter(arg -> !arg.isEmpty() && !arg.startsWith(\"#\")).toList();\n            MavenOptions options = parseArgs(\"maven.config\", args);\n            if (options.goals().isPresent()) {\n                throw new IllegalArgumentException(\"Unrecognized entries in maven.config (\" + configFile + \") file: \"\n                        + options.goals().get());\n            }\n            return options;\n        } catch (ParseException e) {\n            throw new IllegalArgumentException(\n                    \"Failed to parse arguments from maven.config file (\" + configFile + \"): \" + e.getMessage(),\n                    e.getCause());\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Error reading config file: \" + configFile, e);\n        }\n    }",
    "comment": "This file can only contain options, not args (goals or phases)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfig.java",
    "type": "method",
    "name": "enablePostDiscoveryFilterAutoRegistration",
    "code": "public Builder enablePostDiscoveryFilterAutoRegistration(boolean enabled) {\n\t\t\tthis.postDiscoveryFilterAutoRegistrationEnabled = enabled;\n\t\t\treturn this;\n\t\t}",
    "comment": "Configure the auto-registration flag for post discovery filters.\n\n<p>Defaults to {@code true}.\n\n@param enabled {@code true} if post discovery filters should be automatically\nregistered\n@return this builder for method chaining\n@since 1.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/JUnit4ParameterizedTestCase.java",
    "type": "method",
    "name": "data",
    "code": "public static Object[] data() {\n\t\treturn new Object[] { 1, 2, 3 };\n\n\tpublic JUnit4ParameterizedTestCase(int i) {\n\t}\n\n\t@Test\n\tpublic void test1() {\n\t\tfail(\"this test should fail\");\n\t}\n\n\t@Test\n\tpublic void endingIn_test1() {\n\t\tfail(\"this test should fail\");\n\t}\n\n\t@Test\n\tpublic void test1_atTheBeginning() {\n\t\tfail(\"this test should fail\");\n\t}\n\n\t@Test\n\tpublic void test2() {\n\t\t/* always succeeds */\n\t}\n\n}",
    "comment": "Test case used in {@link JUnit4ParameterizedTests}.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/LevelDBTypeInfo.java",
    "type": "method",
    "name": "childPrefix",
    "code": "byte[] childPrefix(Object value) {\n      Preconditions.checkState(parent == null, \"Not a parent index.\");\n      return buildKey(name, toParentKey(value));\n    }",
    "comment": "Creates a key prefix for child indices of this index. This allows the prefix to be\ncalculated only once, avoiding redundant work when multiple child indices of the\nsame parent index exist."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-client-side-ui-composition/src/main/java/com/iluwatar/clientsideuicomposition/ClientSideIntegrator.java",
    "type": "method",
    "name": "composeUi",
    "code": "public void composeUi(String path, Map<String, String> params) {\n    // Fetch data dynamically based on the route and parameters\n    String data = apiGateway.handleRequest(path, params);\n    LOGGER.info(\"Composed UI Component for path '\" + path + \"':\");\n    LOGGER.info(data);\n  }",
    "comment": "Composes the user interface dynamically by fetching data from different frontend components\nbased on provided parameters.\n\n@param path the route of the frontend component\n@param params a map of dynamic parameters to influence the data fetching"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "redirectError",
    "code": "public SparkLauncher redirectError(File errFile) {\n    errorStream = ProcessBuilder.Redirect.to(errFile);\n    return this;\n  }",
    "comment": "Redirects error output to the specified File.\n\n@param errFile The file to which stderr is written.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "append",
    "code": "public boolean append(Object kbase, long koff, int klen, Object vbase, long voff, int vlen) {\n      assert (klen % 8 == 0);\n      assert (vlen % 8 == 0);\n      assert (longArray != null);\n\n      // We should not increase number of keys to be MAX_CAPACITY. The usage pattern of this map is\n      // lookup + append. If we append key until the number of keys to be MAX_CAPACITY, next time\n      // the call of lookup will hang forever because it cannot find an empty slot.\n      if (numKeys == MAX_CAPACITY - 1\n        // The map could be reused from last spill (because of no enough memory to grow),\n        // then we don't try to grow again if hit the `growthThreshold`.\n        || !canGrowArray && numKeys >= growthThreshold) {\n        return false;\n      }\n\n      // Here, we'll copy the data into our data pages. Because we only store a relative offset from\n      // the key address instead of storing the absolute address of the value, the key and value\n      // must be stored in the same memory page.\n      // (total length) (key length) (key) (value) (8 byte pointer to next value)\n      int uaoSize = UnsafeAlignedOffset.getUaoSize();\n      final long recordLength = (2L * uaoSize) + klen + vlen + 8;\n      if (currentPage == null || currentPage.size() - pageCursor < recordLength) {\n        if (!acquireNewPage(recordLength + uaoSize)) {\n          return false;\n        }\n      }\n\n      // --- Append the key and value data to the current data page --------------------------------\n      final Object base = currentPage.getBaseObject();\n      long offset = currentPage.getBaseOffset() + pageCursor;\n      final long recordOffset = offset;\n      UnsafeAlignedOffset.putSize(base, offset, klen + vlen + uaoSize);\n      UnsafeAlignedOffset.putSize(base, offset + uaoSize, klen);\n      offset += (2L * uaoSize);\n      Platform.copyMemory(kbase, koff, base, offset, klen);\n      offset += klen;\n      Platform.copyMemory(vbase, voff, base, offset, vlen);\n      offset += vlen;\n      // put this value at the beginning of the list\n      Platform.putLong(base, offset, isDefined ? longArray.get(pos * 2) : 0);\n\n      // --- Update bookkeeping data structures ----------------------------------------------------\n      offset = currentPage.getBaseOffset();\n      UnsafeAlignedOffset.putSize(base, offset, UnsafeAlignedOffset.getSize(base, offset) + 1);\n      pageCursor += recordLength;\n      final long storedKeyAddress = taskMemoryManager.encodePageNumberAndOffset(\n        currentPage, recordOffset);\n      longArray.set(pos * 2, storedKeyAddress);\n      updateAddressesAndSizes(storedKeyAddress);\n      numValues++;\n      if (!isDefined) {\n        numKeys++;\n        longArray.set(pos * 2 + 1, keyHashcode);\n        isDefined = true;\n\n        // If the map has reached its growth threshold, try to grow it.\n        if (numKeys >= growthThreshold) {\n          // We use two array entries per key, so the array size is twice the capacity.\n          // We should compare the current capacity of the array, instead of its size.\n          if (longArray.size() / 2 < MAX_CAPACITY) {\n            try {\n              growAndRehash();\n            } catch (SparkOutOfMemoryError oom) {\n              canGrowArray = false;\n            }\n          } else {\n            // The map is already at MAX_CAPACITY and cannot grow. Instead, we prevent it from\n            // accepting any more new elements to make sure we don't exceed the load factor. If we\n            // need to spill later, this allows UnsafeKVExternalSorter to reuse the array for\n            // sorting.\n            canGrowArray = false;\n          }\n        }\n      }\n      return true;\n    }",
    "comment": "Append a new value for the key. This method could be called multiple times for a given key.\nThe return value indicates whether the put succeeded or whether it failed because additional\nmemory could not be acquired.\n<p>\nIt is only valid to call this method immediately after calling `lookup()` using the same key.\n</p>\n<p>\nThe key and value must be word-aligned (that is, their sizes must be a multiple of 8).\n</p>\n<p>\nAfter calling this method, calls to `get[Key|Value]Address()` and `get[Key|Value]Length`\nwill return information on the data stored by this `append` call.\n</p>\n<p>\nAs an example usage, here's the proper way to store a new key:\n</p>\n<pre>\nLocation loc = map.lookup(keyBase, keyOffset, keyLength);\nif (!loc.isDefined()) {\nif (!loc.append(keyBase, keyOffset, keyLength, ...)) {\n// handle failure to grow map (by spilling, for example)\n}\n}\n</pre>\n<p>\nUnspecified behavior if the key is not defined.\n</p>\n\n@return true if the put() was successful and false if the put() failed because memory could\nnot be acquired."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/ModelProblemUtils.java",
    "type": "method",
    "name": "formatLocation",
    "code": "public static String formatLocation(ModelProblem problem, String projectId) {\n        StringBuilder buffer = new StringBuilder(256);\n\n        if (!problem.getModelId().equals(projectId)) {\n            buffer.append(problem.getModelId());\n            if (!problem.getSource().isEmpty()) {\n                if (!buffer.isEmpty()) {\n                    buffer.append(\", \");\n                }\n                buffer.append(problem.getSource());\n            }\n        }\n\n        if (problem.getLineNumber() > 0) {\n            if (!buffer.isEmpty()) {\n                buffer.append(\", \");\n            }\n            buffer.append(\"line \").append(problem.getLineNumber());\n        }\n\n        if (problem.getColumnNumber() > 0) {\n            if (!buffer.isEmpty()) {\n                buffer.append(\", \");\n            }\n            buffer.append(\"column \").append(problem.getColumnNumber());\n        }\n\n        return buffer.toString();\n    }",
    "comment": "Creates a string with all location details for the specified model problem. If the project identifier is\nprovided, the generated location will omit the model id and source information and only give line/column\ninformation for problems originating directly from this POM.\n\n@param problem The problem whose location should be formatted, must not be {@code null}.\n@param projectId The {@code <groupId>:<artifactId>:<version>} of the corresponding project, may be {@code null}\nto force output of model id and source.\n@return The formatted problem location or an empty string if unknown, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/session-facade/src/main/java/com/iluwatar/sessionfacade/OrderService.java",
    "type": "method",
    "name": "OrderService",
    "code": "public OrderService(Map<Integer, Product> cart) {\n    this.cart = cart;\n  }",
    "comment": "Instantiates a new Order service.\n\n@param cart the cart"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/execution/sort/RecordBinaryComparatorSuite.java",
    "type": "method",
    "name": "relativeOffset",
    "code": "private long relativeOffset(int numFields) {\n    return 8 + numFields * 8L;\n  }",
    "comment": "Compute the relative offset of variable-length values.\nAll the UnsafeRows in this suite contains less than 64 columns, so the bitSetSize shall\nalways be 8."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/crypto/GcmTransportCipher.java",
    "type": "method",
    "name": "if",
    "code": "while (nettyBufReadableBytes > 0 && !completed) {\n                    int readableBytes = Integer.min(\n                            nettyBufReadableBytes,\n                            ciphertextBuffer.remaining());\n                    int expectedRemaining = (int) (expectedLength - ciphertextRead);\n                    int bytesToRead = Integer.min(readableBytes, expectedRemaining);\n                    ciphertextBuffer.limit(ciphertextBuffer.position() + bytesToRead);\n                    ciphertextNettyBuf.readBytes(ciphertextBuffer);\n                    ciphertextRead += bytesToRead;\n                    if (ciphertextRead == expectedLength) {\n                        completed = true;\n                    } else if (ciphertextRead > expectedLength) {\n                        throw new IllegalStateException(\"Read more ciphertext than expected.\");\n                    }\n                    if (ciphertextBuffer.limit() == ciphertextBuffer.capacity() || completed) {\n                        ByteBuffer plaintextBuffer = ByteBuffer.allocate(plaintextSegmentSize);\n                        ciphertextBuffer.flip();\n                        decrypter.decryptSegment(\n                                ciphertextBuffer,\n                                segmentNumber,\n                                completed,\n                                plaintextBuffer);\n                        segmentNumber++;\n                        ciphertextBuffer.clear();\n                        plaintextBuffer.flip();\n                        ctx.fireChannelRead(Unpooled.wrappedBuffer(plaintextBuffer));\n                    } else {\n                        ciphertextBuffer.limit(ciphertextBuffer.capacity());\n                    }\n                    nettyBufReadableBytes = ciphertextNettyBuf.readableBytes();\n                }",
    "comment": "Read the ciphertext into the local buffer\nThe smallest ciphertext size is 16 bytes for the auth tag\nCheck if this is the last segment\nIf the ciphertext buffer is full, or this is the last segment,\nthen decrypt it and fire a read.\nClear the ciphertext buffer because it's been read\nSet the ciphertext buffer up to read the next chunk"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaUserDefinedUntypedAggregation.java",
    "type": "method",
    "name": "finish",
    "code": "public Double finish(Average reduction) {\n      return ((double) reduction.getSum()) / reduction.getCount();\n    }",
    "comment": "Transform the output of the reduction"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "setRemote",
    "code": "public T setRemote(String remote) {\n    checkNotNull(remote, \"remote\");\n    builder.remote = remote;\n    return self();\n  }",
    "comment": "Set the Spark master for the application.\n\n@param remote Spark remote url.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/MutableExtensionRegistry.java",
    "type": "method",
    "name": "isAlreadyRegistered",
    "code": "private boolean isAlreadyRegistered(Class<? extends Extension> extensionType) {\n\t\treturn this.registeredExtensionTypes.contains(extensionType);\n\t}",
    "comment": "Determine if the supplied type is already registered in this registry or in a\nparent registry."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "getElementsAppended",
    "code": "public final int getElementsAppended() { return elementsAppended; }",
    "comment": "Returns the elements appended. This is useful"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/main/java/com/iluwatar/circuitbreaker/MonitoringService.java",
    "type": "method",
    "name": "delayedServiceResponse",
    "code": "public String delayedServiceResponse() {\n    try {\n      return this.delayedService.attemptRequest();\n    } catch (RemoteServiceException e) {\n      return e.getMessage();\n    }\n  }",
    "comment": "Fetch response from the delayed service (with some simulated startup time).\n\n@return response string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTimeoutPreemptively",
    "code": "public static void assertTimeoutPreemptively(Duration timeout, Executable executable) {\n\t\tAssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code executable}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>See the {@linkplain Assertions Preemptive Timeouts} section of the\nclass-level Javadoc for further details.\n\n@see #assertTimeoutPreemptively(Duration, Executable, String)\n@see #assertTimeoutPreemptively(Duration, Executable, Supplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, String)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeout(Duration, Executable)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "getBinary",
    "code": "public byte[] getBinary(int rowId) {\n    if (isNullAt(rowId)) return null;\n    if (dictionary == null) {\n      return arrayData().getBytes(getArrayOffset(rowId), getArrayLength(rowId));\n    } else {\n      return dictionary.decodeToBinary(dictionaryIds.getDictId(rowId));\n    }\n  }",
    "comment": "Gets the values of bytes from [rowId, rowId + count), as a UTF8String.\nThis method is similar to {@link ColumnVector#getBytes(int, int)}, but can save data copy as\nUTF8String is used as a pointer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/ShuffleInMemorySorter.java",
    "type": "method",
    "name": "getUsableCapacity",
    "code": "private int getUsableCapacity() {\n    return (int) (array.size() / (useRadixSort ? 2 : 1.5));\n  }",
    "comment": "Radix sort requires same amount of used memory as buffer, Tim sort requires\nhalf of the used memory as buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room2/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "UserRepository",
    "code": "public UserRepository(AppExecutors appExecutors, UserDataSource userDataSource) {\n        mAppExecutors = appExecutors;\n        mUserDataSource = userDataSource;\n    }",
    "comment": "The repository is responsible of handling user data operations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/Java8DatasetAggregatorSuite.java",
    "type": "method",
    "name": "testTypedAggregationAverage",
    "code": "public void testTypedAggregationAverage() {\n    KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset();\n    Dataset<Tuple2<String, Double>> aggregated = grouped.agg(\n      org.apache.spark.sql.expressions.javalang.typed.avg(v -> (double)(v._2() * 2)));\n    Assertions.assertEquals(\n        Arrays.asList(new Tuple2<>(\"a\", 3.0), new Tuple2<>(\"b\", 6.0)),\n        aggregated.collectAsList());\n  }",
    "comment": "Suite that replicates tests in JavaDatasetAggregatorSuite using lambda syntax."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toLongExact",
    "code": "public long toLongExact() {\n    LongWrapper result = new LongWrapper();\n    if (toLong(result, false)) {\n      return result.value;\n    }\n    throw new NumberFormatException(\"invalid input syntax for type numeric: '\" + this + \"'\");\n  }",
    "comment": "Parses UTF8String(trimmed if needed) to long. This method is used when ANSI is enabled.\n\n@return If string contains valid numeric value then it returns the long value otherwise a\nNumberFormatException  is thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/Trigger.java",
    "type": "method",
    "name": "ProcessingTime",
    "code": "public static Trigger ProcessingTime(long intervalMs) {\n      return ProcessingTimeTrigger.create(intervalMs, TimeUnit.MILLISECONDS);\n  }",
    "comment": "A trigger policy that runs a query periodically based on an interval in processing time.\nIf `interval` is 0, the query will run as fast as possible.\n\n@since 2.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestEngine.java",
    "type": "method",
    "name": "getVersion",
    "code": "default Optional<String> getVersion() {\n\t\tOptional<String> standalone = PackageUtils.getAttribute(getClass(), \"Engine-Version-\" + getId());\n\t\tif (standalone.isPresent()) {\n\t\t\treturn standalone;\n\t\t}\n\t\treturn Optional.of(PackageUtils.getModuleOrImplementationVersion(getClass()).orElse(\"DEVELOPMENT\"));\n\t}",
    "comment": "Get the version of this test engine.\n\n<p>This information is used solely for debugging and reporting purposes.\n\n<p>Initially, the default implementation tries to retrieve the engine\nversion from the manifest attribute named: {@code \"Engine-Version-\" + getId()}\n\n<p>Then the default implementation attempts to query the\n{@linkplain Package#getImplementationVersion() implementation version}\nfrom the package attributes for the {@link Package} in which the engine\nresides. Note that a package only has attributes if the information is\ndefined in the {@link java.util.jar.Manifest Manifest} of the JAR\ncontaining that package, and if the class loader created the\n{@link Package} instance with the attributes from the manifest.\n\n<p>If the implementation version cannot be queried from the package\nattributes, the default implementation returns {@code \"DEVELOPMENT\"}.\n\n<p>Concrete test engine implementations may override this method to\ndetermine the version by some other means.\n\n<p>implNote: Since JUnit Platform version 1.1 this default implementation\nhonors the \"raw version\" information stored in the module (modular jar\non the module-path) of this test engine.\n\n@return an {@code Optional} containing the version; never {@code null}\nbut potentially empty if the version is unknown\n@see Class#getPackage()\n@see Package#getImplementationVersion()\n@see #getGroupId()\n@see #getArtifactId()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/LogDivertAppender.java",
    "type": "method",
    "name": "setCurrentNamePattern",
    "code": "private void setCurrentNamePattern(OperationLog.LoggingLevel mode) {\n      if (mode == OperationLog.LoggingLevel.VERBOSE) {\n        this.namePattern = verboseExcludeNamePattern;\n      } else if (mode == OperationLog.LoggingLevel.EXECUTION) {\n        this.namePattern = executionIncludeNamePattern;\n      } else if (mode == OperationLog.LoggingLevel.PERFORMANCE) {\n        this.namePattern = performanceIncludeNamePattern;\n      }\n    }",
    "comment": "A log filter that filters messages coming from the logger with the given names.\nIt be used as a white list filter or a black list filter.\nWe apply black list filter on the Loggers used by the log diversion stuff, so that\nthey don't generate more logs for themselves when they process logs.\nWhite list filter is used for less verbose log collection"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/LruCache.java",
    "type": "method",
    "name": "remove",
    "code": "public void remove(final Node node) {\n    if (node.previous != null) {\n      node.previous.next = node.next;\n    } else {\n      head = node.next;\n    }\n    if (node.next != null) {\n      node.next.previous = node.previous;\n    } else {\n      end = node.previous;\n    }\n  }",
    "comment": "Remove node from linked list.\n\n@param node {@link Node}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/gpu/java/src/main/java/org/tensorflow/lite/gpu/GpuDelegateFactory.java",
    "type": "method",
    "name": "setPrecisionLossAllowed",
    "code": "public Options setPrecisionLossAllowed(boolean precisionLossAllowed) {\n      this.precisionLossAllowed = precisionLossAllowed;\n      return this;\n    }",
    "comment": "Sets whether precision loss is allowed.\n\n@param precisionLossAllowed When `true` (default), the GPU may quantify tensors, downcast\nvalues, process in FP16. When `false`, computations are carried out in 32-bit floating\npoint."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/AssumptionViolatedException.java",
    "type": "method",
    "name": "AssumptionViolatedException",
    "code": "public <T> AssumptionViolatedException(String message, T expected, Matcher<T> matcher) {\n        super(message, expected, matcher);\n    }",
    "comment": "An assumption exception with a message with the given <i>actual</i> value and a\n<i>matcher</i> describing the expectation that failed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Long unexpected, Long actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicSample/app/src/androidTest/java/com/example/android/persistence/EspressoTestUtil.java",
    "type": "method",
    "name": "disableProgressBarAnimation",
    "code": "private static void disableProgressBarAnimation(ProgressBar progressBar) {\n        progressBar.setIndeterminateDrawable(new ColorDrawable(Color.BLUE));\n    }",
    "comment": "necessary to run tests on older API levels where progress bar uses handler loop to animate.\n\n@param progressBar The progress bar whose animation will be swapped with a drawable"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/RunnerBuilder.java",
    "type": "method",
    "name": "runners",
    "code": "private List<Runner> runners(Class<?>[] children) {\n        List<Runner> runners = new ArrayList<Runner>();\n        for (Class<?> each : children) {\n            Runner childRunner = safeRunnerForClass(each);\n            if (childRunner != null) {\n                runners.add(childRunner);\n            }\n        }\n        return runners;\n    }",
    "comment": "Constructs and returns a list of Runners, one for each child class in\n{@code children}.  Care is taken to avoid infinite recursion:\nthis builder will throw an exception if it is requested for another\nrunner for {@code parent} before this call completes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/VersionRangeResolverResult.java",
    "type": "method",
    "name": "getHighestVersion",
    "code": "default Optional<Version> getHighestVersion() {\n        return getVersions().isEmpty()\n                ? Optional.empty()\n                : Optional.of(getVersions().get(getVersions().size() - 1));\n    }",
    "comment": "Gets the highest version matching the requested range.\n\n@return An Optional containing the highest matching version, or empty Optional if no versions\nmatched the requested range"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/collection-pipeline/src/main/java/com/iluwatar/collectionpipeline/FunctionalProgramming.java",
    "type": "method",
    "name": "getSedanCarsOwnedSortedByDate",
    "code": "public static List<Car> getSedanCarsOwnedSortedByDate(List<Person> persons) {\n    return persons.stream()\n        .map(Person::cars)\n        .flatMap(List::stream)\n        .filter(car -> Category.SEDAN.equals(car.category()))\n        .sorted(Comparator.comparing(Car::year))\n        .toList();\n  }",
    "comment": "Method to get all Sedan cars belonging to a group of persons sorted by year of manufacture.\n\n@param persons {@link List} of {@link Person} to be used\n@return {@link List} of {@link Car} to belonging to the group"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaTokenizerExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaTokenizerExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(0, \"Hi I heard about Spark\"),\n      RowFactory.create(1, \"I wish Java could use case classes\"),\n      RowFactory.create(2, \"Logistic,regression,models,are,neat\")\n    );\n\n    StructType schema = new StructType(new StructField[]{\n\n    Dataset<Row> sentenceDataFrame = spark.createDataFrame(data, schema);\n\n    Tokenizer tokenizer = new Tokenizer().setInputCol(\"sentence\").setOutputCol(\"words\");\n\n    RegexTokenizer regexTokenizer = new RegexTokenizer()\n        .setInputCol(\"sentence\")\n        .setOutputCol(\"words\")\n        .setPattern(\"\\\\W\");  // alternatively .setPattern(\"\\\\w+\").setGaps(false);\n\n    spark.udf().register(\n      \"countTokens\", (Seq<?> words) -> words.size(), DataTypes.IntegerType);\n\n    Dataset<Row> tokenized = tokenizer.transform(sentenceDataFrame);\n    tokenized.select(\"sentence\", \"words\")\n        .withColumn(\"tokens\", call_udf(\"countTokens\", col(\"words\")))\n        .show(false);\n\n    Dataset<Row> regexTokenized = regexTokenizer.transform(sentenceDataFrame);\n    regexTokenized.select(\"sentence\", \"words\")\n        .withColumn(\"tokens\", call_udf(\"countTokens\", col(\"words\")))\n        .show(false);\n\n    spark.stop();\n  }\n}",
    "comment": "$example on$\ncol(\"...\") is preferable to df.col(\"...\")\n$example off$\n$example on$\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenFailOnSeverityLogger.java",
    "type": "method",
    "name": "error",
    "code": "public void error(String format, Object arg1, Object arg2) {\n        super.error(format, arg1, arg2);\n        logLevelRecorder.record(Level.ERROR);\n    }",
    "comment": "Perform double parameter substitution before logging the message of level\nERROR according to the format outlined above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "addElementsAppended",
    "code": "public final void addElementsAppended(int num) {\n    elementsAppended += num;\n  }",
    "comment": "Increment number of elements appended by 'num'.\n\nThis is useful when one wants to use the 'putXXX' API to add new elements to the vector, but\nstill want to keep count of how many elements have been added (since the 'putXXX' APIs don't\nincrement count)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "if",
    "code": "if (loggerName == null && (outputToLog || errorToLog)) {\n      String appName;\n      if (builder.appName != null) {\n        appName = builder.appName;\n      } else if (builder.mainClass != null) {\n        int dot = builder.mainClass.lastIndexOf(\".\");\n        if (dot >= 0 && dot < builder.mainClass.length() - 1) {\n          appName = builder.mainClass.substring(dot + 1, builder.mainClass.length());\n        } else {\n          appName = builder.mainClass;\n        }\n      } else if (builder.appResource != null) {\n        appName = new File(builder.appResource).getName();\n      } else {\n        appName = String.valueOf(COUNTER.incrementAndGet());\n      }\n      String loggerPrefix = getClass().getPackage().getName();\n      loggerName = String.format(\"%s.app.%s\", loggerPrefix, appName);\n    }",
    "comment": "Only setup stderr + stdout to logger redirection if user has not otherwise configured output\nredirection."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/main/java/com/example/android/observability/ui/UserActivity.java",
    "type": "method",
    "name": "updateUserName",
    "code": "private void updateUserName() {\n        String userName = mUserNameInput.getText().toString();\n        mUpdateButton.setEnabled(false);\n        mDisposable.add(mViewModel.updateUserName(userName)\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(() -> mUpdateButton.setEnabled(true),\n                        throwable -> Log.e(TAG, \"Unable to update username\", throwable)));\n    }",
    "comment": "Disable the update button until the user name update has been done\nSubscribe to updating the user name.\nRe-enable the button once the user name has been updated"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/connector/catalog/Identifier.java",
    "type": "method",
    "name": "of",
    "code": "static Identifier of(String[] namespace, String name) {\n    return new IdentifierImpl(namespace, name);\n  }",
    "comment": "Identifies an object in a catalog.\n\n@since 3.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "setActiveProfileIds",
    "code": "public DefaultProfileActivationContext setActiveProfileIds(List<String> activeProfileIds) {\n        if (activeProfileIds != null) {\n            this.activeProfileIds = Collections.unmodifiableList(activeProfileIds);\n        } else {\n            this.activeProfileIds = Collections.emptyList();\n        }\n\n        return this;\n    }",
    "comment": "Sets the identifiers of those profiles that should be activated by explicit demand.\n\n@param activeProfileIds The identifiers of those profiles to activate, may be {@code null}.\n@return This context, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/test/java/org/apache/spark/sql/hive/execution/UDFRawList.java",
    "type": "method",
    "name": "evaluate",
    "code": "public List evaluate(Object o) {\n    return Collections.singletonList(\"data1\");\n  }",
    "comment": "UDF that returns a raw (non-parameterized) java List."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/server/HiveServer2.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    HiveConf.setLoadHiveServer2Config(true);\n    ServerOptionsProcessor oproc = new ServerOptionsProcessor(\"hiveserver2\");\n    ServerOptionsProcessorResponse oprocResponse = oproc.parse(args);\n\n    HiveStringUtils.startupShutdownMessage(HiveServer2.class, args, LOG.getSlf4jLogger());\n\n    oprocResponse.getServerOptionsExecutor().execute();\n  }",
    "comment": "Call the executor which will execute the appropriate command based on the parsed options"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/ArtifactDescriptorReaderDelegate.java",
    "type": "method",
    "name": "populateResult",
    "code": "public void populateResult(InternalSession session, ArtifactDescriptorResult result, Model model) {\n        ArtifactTypeRegistry stereotypes = session.getSession().getArtifactTypeRegistry();\n\n        for (Repository r : model.getRepositories()) {\n            result.addRepository(session.toRepository(\n                    session.getService(RepositoryFactory.class).createRemote(r)));\n        }\n\n        for (org.apache.maven.api.model.Dependency dependency : model.getDependencies()) {\n            result.addDependency(convert(dependency, stereotypes));\n        }\n\n        DependencyManagement mgmt = model.getDependencyManagement();\n        if (mgmt != null) {\n            for (org.apache.maven.api.model.Dependency dependency : mgmt.getDependencies()) {\n                result.addManagedDependency(convert(dependency, stereotypes));\n            }\n        }\n\n        Map<String, Object> properties = new LinkedHashMap<>();\n\n        Prerequisites prerequisites = model.getPrerequisites();\n        if (prerequisites != null) {\n            properties.put(\"prerequisites.maven\", prerequisites.getMaven());\n        }\n\n        List<License> licenses = model.getLicenses();\n        properties.put(\"license.count\", licenses.size());\n        for (int i = 0; i < licenses.size(); i++) {\n            License license = licenses.get(i);\n            properties.put(\"license.\" + i + \".name\", license.getName());\n            properties.put(\"license.\" + i + \".url\", license.getUrl());\n            properties.put(\"license.\" + i + \".comments\", license.getComments());\n            properties.put(\"license.\" + i + \".distribution\", license.getDistribution());\n        }\n\n        result.setProperties(properties);\n\n        setArtifactProperties(result, model);\n    }",
    "comment": "Populates Aether {@link ArtifactDescriptorResult} from Maven project {@link Model}.\n<p>\n<strong>Note:</strong> This class is part of work in progress and can be changed or removed without notice.\n@since 3.2.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testNormalize3",
    "code": "public void testNormalize3() {\n        IMoney ms1 = MoneyBag.create(new Money(12, \"CHF\"), new Money(3, \"USD\"));\n        Money expected = new Money(4, \"USD\");\n        assertEquals(expected, fMB1.subtract(ms1));\n    }",
    "comment": "{[12 CHF][7 USD]} - {[12 CHF][3 USD]} == [4 USD]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/cache/SoftIdentityMapTest.java",
    "type": "method",
    "name": "shouldUseIdentityComparison",
    "code": "void shouldUseIdentityComparison() {\n        String key1 = new String(\"key\");\n        String key2 = new String(\"key\");\n\n        assertTrue(key1.equals(key2), \"Sanity check: keys should be equal\");\n        assertNotSame(key1, key2, \"Sanity check: keys should be distinct objects\");\n\n        AtomicInteger computeCount = new AtomicInteger(0);\n\n        map.computeIfAbsent(key1, k -> {\n            computeCount.incrementAndGet();\n            return \"value1\";\n        });\n\n        map.computeIfAbsent(key2, k -> {\n            computeCount.incrementAndGet();\n            return \"value2\";\n        });\n\n        assertEquals(1, computeCount.get(), \"Should compute once for equal but distinct keys\");\n    }",
    "comment": "Create two equal but distinct keys"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "setProjectDirectory",
    "code": "public DefaultProfileActivationContext setProjectDirectory(File projectDirectory) {\n        this.projectDirectory = projectDirectory;\n\n        return this;\n    }",
    "comment": "Sets the base directory of the current project.\n\n@param projectDirectory The base directory of the current project, may be {@code null} if profile activation\nhappens in the context of metadata retrieval rather than project building.\n@return This context, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TestWatcher.java",
    "type": "method",
    "name": "failed",
    "code": "protected void failed(Throwable e, Description description) {\n    }",
    "comment": "Invoked when a test fails"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/UnsafeFixedWidthAggregationMap.java",
    "type": "method",
    "name": "getAggregationBuffer",
    "code": "public UnsafeRow getAggregationBuffer(InternalRow groupingKey) {\n    final UnsafeRow unsafeGroupingKeyRow = this.groupingKeyProjection.apply(groupingKey);\n\n    return getAggregationBufferFromUnsafeRow(unsafeGroupingKeyRow);\n  }",
    "comment": "Return the aggregation buffer for the current group. For efficiency, all calls to this method\nreturn the same object. If additional memory could not be allocated, then this method will\nsignal an error by returning null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestExecutionResult.java",
    "type": "method",
    "name": "successful",
    "code": "public static TestExecutionResult successful() {\n\t\treturn SUCCESSFUL_RESULT;\n\t}",
    "comment": "Create a {@code TestExecutionResult} for a <em>successful</em> execution\nof a test or container.\n\n@return the {@code TestExecutionResult}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java",
    "type": "method",
    "name": "getWithTypeSafety",
    "code": "void getWithTypeSafety() {\n\t\t\tInteger key = 42;\n\t\t\tString value = \"enigma\";\n\t\t\tstore.put(namespace, key, value);\n\n\t\t\tString requiredTypeValue = store.get(namespace, key, String.class);\n\t\t\tassertEquals(value, requiredTypeValue);\n\t\t}",
    "comment": "The fact that we can declare this as a String suffices for testing the required type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(short unexpected, Short actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Short) unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/lockable-object/src/main/java/com/iluwatar/lockableobject/domain/Creature.java",
    "type": "method",
    "name": "hit",
    "code": "public synchronized void hit(int damage) {\n    if (damage < 0) {\n      throw new IllegalArgumentException(\"Damage cannot be a negative number\");\n    }\n    if (isAlive()) {\n      setHealth(getHealth() - damage);\n      if (!isAlive()) {\n        kill();\n      }\n    }\n  }",
    "comment": "When a creature gets hit it removed the amount of damage from the creature's life.\n\n@param damage as the damage that was taken."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableProvider.java",
    "type": "method",
    "name": "inferPartitioning",
    "code": "default Transform[] inferPartitioning(CaseInsensitiveStringMap options) {\n    return new Transform[0];\n  }",
    "comment": "Infer the partitioning of the table identified by the given options.\n<p>\nBy default this method returns empty partitioning, please override it if this source support\npartitioning.\n\n@param options an immutable case-insensitive string-to-string map that can identify a table,\ne.g. file path, Kafka topic name, etc."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-idempotent-consumer/src/main/java/com/iluwatar/idempotentconsumer/RequestService.java",
    "type": "method",
    "name": "complete",
    "code": "public Request complete(UUID uuid) {\n    Optional<Request> optReq = requestRepository.findById(uuid);\n    if (optReq.isEmpty()) {\n      throw new RequestNotFoundException(uuid);\n    }\n    return requestRepository.save(requestStateMachine.next(optReq.get(), Request.Status.COMPLETED));\n  }",
    "comment": "Complete the Request assigned with the given UUID.\n\n@param uuid The unique identifier for the Request.\n@return The completed Request.\n@throws RequestNotFoundException if a Request with the given UUID is not found."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "toTitleCaseICU",
    "code": "public static UTF8String toTitleCaseICU(UTF8String source) {\n    // In the default UTF8String implementation, `toLowerCase` method implicitly does UTF8String\n    // validation (replacing invalid UTF-8 byte sequences with Unicode replacement character\n    // U+FFFD), but now we have to do the validation manually.\n    source = source.makeValid();\n\n    // Building the title cased source with 'sb'.\n    UTF8StringBuilder sb = new UTF8StringBuilder();\n\n    // 'isNewWord' is true if the current character is the beginning of a word, false otherwise.\n    boolean isNewWord = true;\n    // We are maintaining if the current character is preceded by a cased letter.\n    // This is used when lowercasing capital Greek letter sigma ('Σ'), to figure out if it should be\n    // lowercased into σ or ς.\n    boolean precededByCasedLetter = false;\n\n    // 'offset' is a byte offset in source's byte array pointing to the beginning of the character\n    // that we need to process next.\n    int offset = 0;\n    int len = source.numBytes();\n\n    while (offset < len) {\n      // We will actually call 'codePointFrom()' 2 times for each character in the worst case (once\n      // here, and once in 'followedByCasedLetter'). Example of a string where we call it 2 times\n      // for almost every character is 'ΣΣΣΣΣ' (a string consisting only of Greek capital sigma)\n      // and 'Σ`````' (a string consisting of a Greek capital sigma, followed by case-ignorable\n      // characters).\n      int codepoint = source.codePointFrom(offset);\n      // Appending the correctly cased character onto 'sb'.\n      appendTitleCasedCodepoint(sb, codepoint, isNewWord, precededByCasedLetter, source, offset);\n      // Updating 'isNewWord', 'precededByCasedLetter' and 'offset' to be ready for the next\n      // character that we will process.\n      isNewWord = (codepoint == SpecialCodePointConstants.ASCII_SPACE);\n      if (!UCharacter.hasBinaryProperty(codepoint, UProperty.CASE_IGNORABLE)) {\n        precededByCasedLetter = UCharacter.hasBinaryProperty(codepoint, UProperty.CASED);\n      }\n      offset += UTF8String.numBytesForFirstByte(source.getByte(offset));\n    }\n    return sb.build();\n  }",
    "comment": "Title-casing a string using ICU case mappings. Iterates over the string and title-cases\nthe first character in each word, and lowercases every other character. Handles lowercasing\ncapital Greek letter sigma ('Σ') separately, taking into account if it should be a small final\nGreek sigma ('ς') or small non-final Greek sigma ('σ'). Words are separated by ASCII\nspace(\\u0020).\n\n@param source UTF8String to be title cased\n@return title cased source"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetReadState.java",
    "type": "method",
    "name": "RowRange",
    "code": "private record RowRange(long start, long end) {\n  }",
    "comment": "Helper struct to represent a range of row indexes `[start, end]`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Long expected, long actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Long) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "numDimensions",
    "code": "private static int numDimensions(Object o, DataType dtype) {\n    int ret = numArrayDimensions(o);\n    if (dtype == DataType.STRING && ret > 0) {\n      return ret - 1;\n    }\n    return ret;\n  }",
    "comment": "Return the number of dimensions of the tensor that object {@code o} represents as a tensor\nwhose datatype is {@code dtype}. Normally this is the same as the number of dimensions of o\nitself, but is one smaller for tensors of strings.\n\n@param o The object to inspect. It must be a valid representation of the given data type.\n@param dtype The expected data type of the tensor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/runner/BaseTestRunner.java",
    "type": "method",
    "name": "truncate",
    "code": "public static String truncate(String s) {\n        if (fgMaxMessageLength != -1 && s.length() > fgMaxMessageLength) {\n            s = s.substring(0, fgMaxMessageLength) + \"...\";\n        }\n        return s;\n    }",
    "comment": "Truncates a String to the maximum length."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Shape.java",
    "type": "method",
    "name": "make",
    "code": "public static Shape make(long firstDimensionSize, long... otherDimensionSizes) {\n    long[] shape = new long[otherDimensionSizes.length + 1];\n    shape[0] = firstDimensionSize;\n    System.arraycopy(otherDimensionSizes, 0, shape, 1, otherDimensionSizes.length);\n    return new Shape(shape);\n  }",
    "comment": "Create a Shape representing an N-dimensional value.\n\n<p>Creates a Shape representing an N-dimensional value (N being at least 1), with the provided\nsize for each dimension. A -1 indicates that the size of the corresponding dimension is\nunknown. For example:\n\n<pre>{@code\n// A 2-element vector.\nShape vector = Shape.create(2);\n\n// A 2x3 matrix.\nShape matrix = Shape.create(2, 3);\n\n// A matrix with 4 columns but an unknown number of rows.\n// This is typically used to indicate the shape of tensors that represent\n// a variable-sized batch of values. The Shape below might represent a\n// variable-sized batch of 4-element vectors.\nShape batch = Shape.create(-1, 4);\n}</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "ioExceptionsThresholdDuringMerge",
    "code": "public int ioExceptionsThresholdDuringMerge() {\n    return conf.getInt(\"spark.shuffle.push.server.ioExceptionsThresholdDuringMerge\", 4);\n  }",
    "comment": "The threshold for number of IOExceptions while merging shuffle blocks to a shuffle partition.\nWhen the number of IOExceptions while writing to merged shuffle data/index/meta file exceed\nthis threshold then the shuffle server will respond back to client to stop pushing shuffle\nblocks for this shuffle partition."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java",
    "type": "method",
    "name": "registerExtensionsFromStaticFields",
    "code": "static void registerExtensionsFromStaticFields(ExtensionRegistrar registrar, Class<?> clazz) {\n\t\tstreamExtensionRegisteringFields(clazz, ModifierSupport::isStatic) //\n\t\t\t\t.forEach(field -> {\n\t\t\t\t\tList<Class<? extends Extension>> extensionTypes = streamDeclarativeExtensionTypes(field).collect(\n\t\t\t\t\t\ttoList());\n\t\t\t\t\tboolean isExtendWithPresent = !extensionTypes.isEmpty();\n\n\t\t\t\t\tif (isExtendWithPresent) {\n\t\t\t\t\t\textensionTypes.forEach(registrar::registerExtension);\n\t\t\t\t\t}\n\t\t\t\t\tif (isAnnotated(field, RegisterExtension.class)) {\n\t\t\t\t\t\tExtension extension = readAndValidateExtensionFromField(field, null, extensionTypes);\n\t\t\t\t\t\tregistrar.registerExtension(extension, field);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}",
    "comment": "Register extensions using the supplied registrar from static fields in\nthe supplied class that are annotated with {@link ExtendWith @ExtendWith}\nor {@link RegisterExtension @RegisterExtension}.\n\n<p>The extensions will be sorted according to {@link Order @Order} semantics\nprior to registration.\n\n@param registrar the registrar with which to register the extensions; never {@code null}\n@param clazz the class or interface in which to find the fields; never {@code null}\n@since 5.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/event/ExecutionEventLogger.java",
    "type": "method",
    "name": "forkStarted",
    "code": "public void forkStarted(ExecutionEvent event) {\n        if (logger.isInfoEnabled()) {\n            init();\n            logger.info(\"\");\n\n            MessageBuilder buffer = builder().strong(\">>> \");\n            append(buffer, event.getMojoExecution());\n            buffer.strong(\" > \");\n            appendForkInfo(buffer, event.getMojoExecution().getMojoDescriptor());\n            append(buffer, event.getProject());\n            buffer.strong(\" >>>\");\n\n            logger.info(buffer.toString());\n        }\n    }",
    "comment": "<pre>&gt;&gt;&gt; mojo-artifactId:version:goal (mojo-executionId) &gt; :forked-goal @ project-artifactId &gt;&gt;&gt;</pre>\n<pre>&gt;&gt;&gt; mojo-artifactId:version:goal (mojo-executionId) &gt; [lifecycle]phase @ project-artifactId &gt;&gt;&gt;</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/resolution/UnresolvableModelException.java",
    "type": "method",
    "name": "UnresolvableModelException",
    "code": "public UnresolvableModelException(Throwable cause, String groupId, String artifactId, String version) {\n        super(cause);\n        this.groupId = groupId;\n        this.artifactId = artifactId;\n        this.version = version;\n    }",
    "comment": "Creates a new exception with specified cause\n\n@param cause\n@param groupId\n@param artifactId\n@param version"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "isAssignableTo",
    "code": "public static boolean isAssignableTo(Class<?> sourceType, Class<?> targetType) {\n\t\tPreconditions.notNull(sourceType, \"source type must not be null\");\n\t\tPreconditions.condition(!sourceType.isPrimitive(), \"source type must not be a primitive type\");\n\t\tPreconditions.notNull(targetType, \"target type must not be null\");\n\n\t\tif (targetType.isAssignableFrom(sourceType)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (targetType.isPrimitive()) {\n\t\t\treturn sourceType == primitiveToWrapperMap.get(targetType) || isWideningConversion(sourceType, targetType);\n\t\t}\n\n\t\treturn false;\n\t}",
    "comment": "Determine if an object of the supplied source type can be assigned to the\nsupplied target type for the purpose of reflective method invocations.\n\n<p>In contrast to {@link Class#isAssignableFrom(Class)}, this method\nreturns {@code true} if the target type represents a primitive type whose\nwrapper matches the supplied source type. In addition, this method also supports\n<a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2\">\nwidening conversions</a> for primitive target types.\n\n@param sourceType the non-primitive target type; never {@code null}\n@param targetType the target type; never {@code null}\n@return {@code true} if an object of the source type is assignment compatible\nwith the target type\n@since 1.8\n@see Class#isInstance(Object)\n@see Class#isAssignableFrom(Class)\n@see #isAssignableTo(Object, Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room3/java/com/example/android/persistence/migrations/UsersDatabase.java",
    "type": "method",
    "name": "Migration",
    "code": "static final Migration MIGRATION_2_3 = new Migration(2, 3) {\n    };",
    "comment": "Migrate from:\nversion 2 - using Room\nto\nversion 3 - using Room where the {@link User} has an extra field: date"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/matchers/JUnitMatchers.java",
    "type": "method",
    "name": "both",
    "code": "public static <T> CombinableBothMatcher<T> both(Matcher<? super T> matcher) {\n        return CoreMatchers.both(matcher);\n    }",
    "comment": "This is useful for fluently combining matchers that must both pass.  For example:\n<pre>\nassertThat(string, both(containsString(\"a\")).and(containsString(\"b\")));\n</pre>\n\n@deprecated Please use {@link CoreMatchers#both(Matcher)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/parameter-object/src/test/java/com/iluwatar/parameter/object/SearchServiceTest.java",
    "type": "method",
    "name": "setUp",
    "code": "void setUp() {\n    parameterObject = ParameterObject.newBuilder().withType(\"sneakers\").build();\n\n    searchService = new SearchService();\n  }",
    "comment": "Creating parameter object with default values set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Double expected, double actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Double) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/PreInterruptCallbackTests.java",
    "type": "method",
    "name": "testCaseWithDeclaredInterruptCallbackThrowsException",
    "code": "void testCaseWithDeclaredInterruptCallbackThrowsException() {\n\t\tinterruptCallbackShallThrowException.set(true);\n\t\tEvents tests = executeTestsForClass(DefaultPreInterruptCallbackWithExplicitCallbackTestCase.class).testEvents();\n\t\ttests.failed().assertEventsMatchExactly(event(test(TC),\n\t\t\tfinishedWithFailure(instanceOf(TimeoutException.class), message(TIMEOUT_ERROR_MSG),\n\t\t\t\tsuppressed(0, instanceOf(InterruptedException.class)),\n\t\t\t\tsuppressed(1, instanceOf(IllegalStateException.class)))));\n\t\tassertTrue(interruptedTest.get());\n\t\tPreInterruptContext preInterruptContext = calledPreInterruptContext.get();\n\t\tassertNotNull(preInterruptContext);\n\t\tassertNotNull(preInterruptContext.getThreadToInterrupt());\n\t\tassertEquals(preInterruptContext.getThreadToInterrupt(), interruptedTestThread.get());\n\t}",
    "comment": "Wait until the real test thread was interrupted due to executor.shutdown(), otherwise the asserts below will be flaky."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/iterator/src/main/java/com/iluwatar/iterator/bst/TreeNode.java",
    "type": "method",
    "name": "traverseOneLevelDown",
    "code": "private TreeNode<T> traverseOneLevelDown(T value) {\n    if (this.isGreaterThan(value)) {\n      return this.left;\n    }\n    return this.right;\n  }",
    "comment": "Returns left or right child of self based on a value that would be inserted; maintaining the\nintegrity of the BST.\n\n@param value The value of the TreeNode that would be inserted beneath self\n@return The child TreeNode of self which represents the subtree where `value` would be inserted"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/resolver/conflict/NewestConflictResolver.java",
    "type": "method",
    "name": "resolveConflict",
    "code": "public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2) {\n        try {\n            ArtifactVersion version1 = node1.getArtifact().getSelectedVersion();\n            ArtifactVersion version2 = node2.getArtifact().getSelectedVersion();\n\n            return version1.compareTo(version2) > 0 ? node1 : node2;\n        } catch (OverConstrainedVersionException exception) {\n            // TODO log message or throw exception?\n\n            return null;\n        }\n    }",
    "comment": "Resolves conflicting artifacts by always selecting the <em>newest</em> declaration. Newest is defined as the\ndeclaration whose version is greater according to <code>ArtifactVersion.compareTo</code>.\n\n@see ArtifactVersion#compareTo\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaVectorSlicerExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaVectorSlicerExample\")\n      .getOrCreate();\n\n    Attribute[] attrs = {\n      NumericAttribute.defaultAttr().withName(\"f1\"),\n      NumericAttribute.defaultAttr().withName(\"f2\"),\n      NumericAttribute.defaultAttr().withName(\"f3\")\n    };\n    AttributeGroup group = new AttributeGroup(\"userFeatures\", attrs);\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(Vectors.sparse(3, new int[]{0, 1}, new double[]{-2.0, 2.3})),\n    vectorSlicer.setIndices(new int[]{1}).setNames(new String[]{\"f3\"});\n}",
    "comment": "$example on$\n$example off$\n$example on$\nor slicer.setIndices(new int[]{1, 2}), or slicer.setNames(new String[]{\"f2\", \"f3\"})"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/Credentials.java",
    "type": "method",
    "name": "of",
    "code": "public static Credentials of(final String username, final String password) {\n      return new Credentials(username, password);\n   }",
    "comment": "Construct an immutable Credentials object with the supplied username and password.\n\n@param username the username\n@param password the password\n@return a new Credentials object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlanExecutor.java",
    "type": "method",
    "name": "buildInitialPlan",
    "code": "public BuildPlan buildInitialPlan(List<TaskSegment> taskSegments) {\n            int nThreads = Math.min(\n                    session.getRequest().getDegreeOfConcurrency(),\n                    session.getProjects().size());\n            boolean parallel = nThreads > 1;\n            session.setParallel(parallel);\n\n            ProjectDependencyGraph dependencyGraph = session.getProjectDependencyGraph();\n            MavenProject rootProject = session.getTopLevelProject();\n\n            Map<MavenProject, List<MavenProject>> allProjects = new LinkedHashMap<>();\n            dependencyGraph\n                    .getSortedProjects()\n                    .forEach(p -> allProjects.put(p, dependencyGraph.getUpstreamProjects(p, false)));\n\n            BuildPlan plan = new BuildPlan(allProjects);\n            for (TaskSegment taskSegment : taskSegments) {\n                Map<MavenProject, List<MavenProject>> projects = taskSegment.isAggregating()\n                        ? Collections.singletonMap(rootProject, allProjects.get(rootProject))\n                        : allProjects;\n\n                BuildPlan segment = calculateMojoExecutions(projects, taskSegment.getTasks());\n                plan.then(segment);\n            }\n\n            for (MavenProject project : plan.getAllProjects().keySet()) {\n                BuildStep pplan = new BuildStep(PLAN, project, null);\n                pplan.status.set(PLANNING); // the plan step always need planning\n                BuildStep setup = new BuildStep(SETUP, project, null);\n                BuildStep teardown = new BuildStep(TEARDOWN, project, null);\n                teardown.executeAfter(setup);\n                setup.executeAfter(pplan);\n                plan.steps(project).forEach(step -> {\n                    if (step.predecessors.stream().noneMatch(s -> s.project == project)) {\n                        step.executeAfter(setup);\n                    } else if (step.successors.stream().noneMatch(s -> s.project == project)) {\n                        teardown.executeAfter(step);\n                    }\n                });\n                Stream.of(pplan, setup, teardown).forEach(step -> plan.addStep(project, step.name, step));\n            }\n\n            return plan;\n        }",
    "comment": "Propagate the parallel flag to the root session\nCreate plan, setup and teardown"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/MojoExecutionException.java",
    "type": "method",
    "name": "MojoExecutionException",
    "code": "public MojoExecutionException(Object source, String shortMessage, String longMessage) {\n        super(shortMessage);\n        this.source = source;\n        this.longMessage = longMessage;\n    }",
    "comment": "Construct a new <code>MojoExecutionException</code> exception providing the source and a short and long message:\nthese messages are used to improve the message written at the end of Maven build.\n\n@param source\n@param shortMessage\n@param longMessage"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationSupport.java",
    "type": "method",
    "name": "exec",
    "code": "public static UTF8String exec(final UTF8String v, final int collationId, boolean useICU) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType) {\n        return useICU ? execBinaryICU(v) : execBinary(v);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(v);\n      } else {\n        return execICU(v, collationId);\n      }\n    }",
    "comment": "Space trimming does not affect the output of this expression."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/memory/MemoryConsumer.java",
    "type": "method",
    "name": "MemoryConsumer",
    "code": "protected MemoryConsumer(TaskMemoryManager taskMemoryManager, long pageSize, MemoryMode mode) {\n    this.taskMemoryManager = taskMemoryManager;\n    this.pageSize = pageSize;\n    this.mode = mode;\n  }",
    "comment": "A memory consumer of {@link TaskMemoryManager} that supports spilling.\n\nNote: this only supports allocation / spilling of Tungsten memory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaModelSelectionViaCrossValidationExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaModelSelectionViaCrossValidationExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Prepare training documents, which are labeled.\n    Dataset<Row> training = spark.createDataFrame(Arrays.asList(\n      new JavaLabeledDocument(0L, \"a b c d e spark\", 1.0),\n      new JavaLabeledDocument(1L, \"b d\", 0.0),\n      new JavaLabeledDocument(2L,\"spark f g h\", 1.0),\n      new JavaLabeledDocument(3L, \"hadoop mapreduce\", 0.0),\n      new JavaLabeledDocument(4L, \"b spark who\", 1.0),\n      new JavaLabeledDocument(5L, \"g d a y\", 0.0),\n      new JavaLabeledDocument(6L, \"spark fly\", 1.0),\n      new JavaLabeledDocument(7L, \"was mapreduce\", 0.0),\n      new JavaLabeledDocument(8L, \"e spark program\", 1.0),\n      new JavaLabeledDocument(9L, \"a e c l\", 0.0),\n      new JavaLabeledDocument(10L, \"spark compile\", 1.0),\n      new JavaLabeledDocument(11L, \"hadoop software\", 0.0)\n    ), JavaLabeledDocument.class);\n\n    // Configure an ML pipeline, which consists of three stages: tokenizer, hashingTF, and lr.\n    Tokenizer tokenizer = new Tokenizer()\n      .setInputCol(\"text\")\n      .setOutputCol(\"words\");\n    HashingTF hashingTF = new HashingTF()\n      .setNumFeatures(1000)\n      .setInputCol(tokenizer.getOutputCol())\n      .setOutputCol(\"features\");\n    LogisticRegression lr = new LogisticRegression()\n      .setMaxIter(10)\n      .setRegParam(0.01);\n    Pipeline pipeline = new Pipeline()\n      .setStages(new PipelineStage[] {tokenizer, hashingTF, lr});\n      .addGrid(hashingTF.numFeatures(), new int[] {10, 100, 1000})\n      .addGrid(lr.regParam(), new double[] {0.1, 0.01})\n    // $example off$\n\n    spark.stop();\n  }",
    "comment": "Java example for Model Selection via Cross Validation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenBaseLogger.java",
    "type": "method",
    "name": "write",
    "code": "protected void write(StringBuilder buf, Throwable t) {\n        PrintStream targetStream = CONFIG_PARAMS.outputChoice.getTargetPrintStream();\n\n        synchronized (CONFIG_PARAMS) {\n            targetStream.println(buf.toString());\n            writeThrowable(t, targetStream);\n            targetStream.flush();\n        }\n    }",
    "comment": "To avoid intermingling of log messages and associated stack traces, the two\noperations are done in a synchronized block.\n\n@param buf   The StringBuilder containing the log message to be written\n@param t     The Throwable object whose stack trace should be written, may be null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/sqlite/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "UserRepository",
    "code": "public UserRepository(AppExecutors appExecutors, UserDataSource userDataSource) {\n        mAppExecutors = appExecutors;\n        mUserDataSource = userDataSource;\n    }",
    "comment": "The repository is responsible of handling user data operations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultModelUrlNormalizer.java",
    "type": "method",
    "name": "DefaultModelUrlNormalizer",
    "code": "public DefaultModelUrlNormalizer(UrlNormalizer urlNormalizer) {\n        this.urlNormalizer = urlNormalizer;\n    }",
    "comment": "Normalizes URLs to remove the ugly parent references \"../\" that got potentially inserted by URL adjustment during\nmodel inheritance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/ThreadPoolDispatcher.java",
    "type": "method",
    "name": "onChannelReadEvent",
    "code": "public void onChannelReadEvent(AbstractNioChannel channel, Object readObject, SelectionKey key) {\n    executorService.execute(() -> channel.getHandler().handleChannelRead(channel, readObject, key));\n  }",
    "comment": "Submits the work of dispatching the read event to worker pool, where it gets picked up by\nworker threads. <br>\nNote that this is a non-blocking call and returns immediately. It is not guaranteed that the\nevent has been handled by associated handler."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/SelectorResolutionResult.java",
    "type": "method",
    "name": "resolved",
    "code": "public static SelectorResolutionResult resolved() {\n\t\treturn RESOLVED_RESULT;\n\t}",
    "comment": "Create a {@code SelectorResolutionResult} for a <em>resolved</em>\nselector.\n@return the {@code SelectorResolutionResult}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/testkit/engine/ExecutionsIntegrationTests.java",
    "type": "method",
    "name": "executionsFromStartedTestEvents",
    "code": "void executionsFromStartedTestEvents() {\n\t\tvar testEvents = getTestEvents();\n\n\t\tassertThat(testEvents.executions().started().count()).isEqualTo(3);\n\t\tassertThat(testEvents.started().executions().count()).isEqualTo(0);\n\t}",
    "comment": "We expect 3 if the executions are created BEFORE filtering out \"finished\" events.\nWe expect 0 if the executions are created AFTER filtering out \"finished\" events."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-log-aggregation/src/main/java/com/iluwatar/logaggregation/LogAggregator.java",
    "type": "method",
    "name": "collectLog",
    "code": "public void collectLog(LogEntry logEntry) {\n    if (logEntry.getLevel() == null || minLogLevel == null) {\n      LOGGER.warn(\"Log level or threshold level is null. Skipping.\");\n      return;\n    }\n\n    if (logEntry.getLevel().compareTo(minLogLevel) < 0) {\n      LOGGER.debug(\"Log level below threshold. Skipping.\");\n      return;\n    }\n\n    buffer.offer(logEntry);\n\n    if (logCount.incrementAndGet() >= BUFFER_THRESHOLD) {\n      flushBuffer();\n    }\n  }",
    "comment": "Collects a given log entry, and filters it by the defined log level.\n\n@param logEntry The log entry to collect."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/ArgumentsUtils.java",
    "type": "method",
    "name": "toArguments",
    "code": "static Arguments toArguments(Object item) {\n\t\t// Nothing to do except cast.\n\t\tif (item instanceof Arguments) {\n\t\t\treturn (Arguments) item;\n\t\t}\n\n\t\t// Pass all multidimensional arrays \"as is\", in contrast to Object[].\n\t\t// See https://github.com/junit-team/junit5/issues/1665\n\t\tif (ReflectionUtils.isMultidimensionalArray(item)) {\n\t\t\treturn arguments(item);\n\t\t}\n\n\t\t// Special treatment for one-dimensional reference arrays.\n\t\t// See https://github.com/junit-team/junit5/issues/1665\n\t\tif (item instanceof Object[]) {\n\t\t\treturn arguments((Object[]) item);\n\t\t}\n\n\t\t// Pass everything else \"as is\".\n\t\treturn arguments(item);\n\t}",
    "comment": "Convert the supplied object into an {@link Arguments} instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ShuffleIndexRecord.java",
    "type": "method",
    "name": "ShuffleIndexRecord",
    "code": "public record ShuffleIndexRecord(long offset, long length) {\n}",
    "comment": "Contains offset and length of the shuffle block data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/VariantVal.java",
    "type": "method",
    "name": "equals",
    "code": "public boolean equals(Object other) {\n    if (other instanceof VariantVal o) {\n      return Arrays.equals(value, o.value) && Arrays.equals(metadata, o.metadata);\n    } else {\n      return false;\n    }\n  }",
    "comment": "Compare two variants in bytes. The variant equality is more complex than it, and we haven't\nsupported it in the user surface yet. This method is only intended for tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionParser.java",
    "type": "method",
    "name": "ConditionParser",
    "code": "public ConditionParser(Map<String, ExpressionFunction> functions, UnaryOperator<String> propertyResolver) {\n        this.functions = functions;\n        this.propertyResolver = propertyResolver;\n    }",
    "comment": "Constructs a new {@code ConditionParser} with the given function mappings.\n@param propertyResolver the property resolver"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestDescriptor.java",
    "type": "method",
    "name": "getDescendants",
    "code": "default Set<? extends TestDescriptor> getDescendants() {\n\t\tSet<TestDescriptor> descendants = new LinkedHashSet<>();\n\t\tdescendants.addAll(getChildren());\n\t\tfor (TestDescriptor child : getChildren()) {\n\t\t\tdescendants.addAll(child.getDescendants());\n\t\t}\n\t\treturn Collections.unmodifiableSet(descendants);\n\t}",
    "comment": "Get the immutable set of all <em>descendants</em> of this descriptor.\n\n<p>A <em>descendant</em> is a child of this descriptor or a child of one of\nits children, recursively.\n\n@see #getChildren()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/AssumptionViolatedException.java",
    "type": "method",
    "name": "describeTo",
    "code": "public void describeTo(Description description) {\n        if (fAssumption != null) {\n            description.appendText(fAssumption);\n        }\n\n        if (fValueMatcher) {\n            if (fAssumption != null) {\n                description.appendText(\": \");\n            }\n\n            description.appendText(\"got: \");\n            description.appendValue(fValue);\n\n            if (fMatcher != null) {\n                description.appendText(\", expected: \");\n                description.appendDescriptionOf(fMatcher);\n            }\n        }\n    }",
    "comment": "a value was passed in when this instance was constructed; print it"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/DefaultLogLevelRecorder.java",
    "type": "method",
    "name": "hasReachedMaxLevel",
    "code": "public boolean hasReachedMaxLevel() {\n        return maxReached.get().ordinal() > maxAllowed.ordinal();\n    }",
    "comment": "Responsible for keeping state of whether the threshold of the --fail-on-severity flag has been hit."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java",
    "type": "method",
    "name": "cause",
    "code": "public static Condition<Throwable> cause(Condition<Throwable>... conditions) {\n\t\tList<Condition<Throwable>> list = Arrays.stream(conditions)//\n\t\t\t\t.map(TestExecutionResultConditions::cause)//\n\t\t\t\t.collect(toList());\n\n\t\treturn Assertions.allOf(list);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if a\nsupplied conditions.\n\n@see #rootCause(Condition...)\n@see #suppressed(int, Condition...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "finished",
    "code": "public Executions finished() {\n\t\treturn new Executions(finishedExecutions(), this.category + \" Finished\");\n\t}",
    "comment": "Get the finished {@link Executions} contained in this {@code Executions} object.\n\n@return the filtered {@code Executions}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/resolver/conflict/NearestConflictResolver.java",
    "type": "method",
    "name": "resolveConflict",
    "code": "public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2) {\n        return node1.getDepth() <= node2.getDepth() ? node1 : node2;\n    }",
    "comment": "Resolves conflicting artifacts by always selecting the <em>nearest</em> declaration. Nearest is defined as the\ndeclaration that has the least transitive steps away from the project being built.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "checkCombineLines",
    "code": "private static boolean checkCombineLines(String line) {\n            int bsCount = 0;\n            for (int idx = line.length() - 1; idx >= 0 && line.charAt(idx) == '\\\\'; idx--) {\n                bsCount++;\n            }\n\n            return bsCount % 2 != 0;\n        }",
    "comment": "Checks if the passed in line should be combined with the following.\nThis is true, if the line ends with an odd number of backslashes.\n\n@param line the line\n@return a flag if the lines should be combined"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/ambassador/src/main/java/com/iluwatar/ambassador/RemoteService.java",
    "type": "method",
    "name": "doRemoteFunction",
    "code": "public long doRemoteFunction(int value) {\n\n    long waitTime = (long) Math.floor(randomProvider.random() * 1000);\n\n    try {\n      sleep(waitTime);\n    } catch (InterruptedException e) {\n      LOGGER.error(\"Thread sleep state interrupted\", e);\n      Thread.currentThread().interrupt();\n    }\n    return waitTime <= THRESHOLD\n        ? value * 10\n        : RemoteServiceStatus.FAILURE.getRemoteServiceStatusValue();\n  }",
    "comment": "Remote function takes a value and multiplies it by 10 taking a random amount of time. Will\nsometimes return -1. This imitates connectivity issues a client might have to account for.\n\n@param value integer value to be multiplied.\n@return if waitTime is less than {@link RemoteService#THRESHOLD}, it returns value * 10,\notherwise {@link RemoteServiceStatus#FAILURE}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "setDeployMode",
    "code": "public T setDeployMode(String mode) {\n    checkNotNull(mode, \"mode\");\n    builder.deployMode = mode;\n    return self();\n  }",
    "comment": "Set the deploy mode for the application.\n\n@param mode Deploy mode.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(short[] expected, short[] actual, Supplier<String> messageSupplier) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} short arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/RocksDBTypeInfo.java",
    "type": "method",
    "name": "toParentKey",
    "code": "byte[] toParentKey(Object value) {\n      return toKey(value, SECONDARY_IDX_PREFIX);\n    }",
    "comment": "Remove a value from the index.\n\n@param batch Write batch with other related changes.\n@param entity The entity being removed, to identify the index entry to modify.\n@param naturalKey The value's natural key (to avoid re-computing it for every index).\n@param prefix The parent index prefix, if this is a child index."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/di/testing/MavenDIExtension.java",
    "type": "method",
    "name": "getInjector",
    "code": "public Injector getInjector() {\n        if (injector == null) {\n            setupContainer();\n        }\n        return injector;\n    }",
    "comment": "Returns the DI injector, creating it if necessary.\n\n@return The configured injector instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/demo/app/src/main/java/com/example/android/tflitecamerademo/AutoFitTextureView.java",
    "type": "method",
    "name": "setAspectRatio",
    "code": "public void setAspectRatio(int width, int height) {\n    if (width < 0 || height < 0) {\n      throw new IllegalArgumentException(\"Size cannot be negative.\");\n    }\n    mRatioWidth = width;\n    mRatioHeight = height;\n    requestLayout();\n  }",
    "comment": "Sets the aspect ratio for this view. The size of the view will be measured based on the ratio\ncalculated from the parameters. Note that the actual sizes of parameters don't matter, that is,\ncalling setAspectRatio(2, 3) and setAspectRatio(4, 6) make the same result.\n\n@param width Relative horizontal size\n@param height Relative vertical size"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/FileSource.java",
    "type": "method",
    "name": "from",
    "code": "public static FileSource from(File file) {\n\t\treturn new FileSource(file);\n\t}",
    "comment": "Create a new {@code FileSource} using the supplied {@link File file}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/NamespaceChange.java",
    "type": "method",
    "name": "SetProperty",
    "code": "private SetProperty(String property, String value) {\n      this.property = property;\n      this.value = value;\n    }",
    "comment": "A NamespaceChange to set a namespace property.\n<p>\nIf the property already exists, it must be replaced with the new value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertInstanceOf",
    "code": "public static <T> T assertInstanceOf(Class<T> expectedType, Object actualValue) {\n\t\treturn AssertInstanceOf.assertInstanceOf(expectedType, actualValue);\n\t}",
    "comment": "<em>Assert</em> that the supplied {@code actualValue} is an instance of the\n{@code expectedType}.\n\n<p>Like the {@code instanceof} operator a {@code null} value is not\nconsidered to be of the {@code expectedType} and does not pass the assertion.\n\n@since 5.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/exception/DefaultExceptionHandlerTest.java",
    "type": "method",
    "name": "testHandleExceptionLoopInCause",
    "code": "void testHandleExceptionLoopInCause() {\n        AtomicReference<Throwable> causeRef = new AtomicReference<>(null);\n        Exception cause2 = new RuntimeException(\"loop\") {\n        };\n        causeRef.set(cause2);\n\n        Plugin plugin = new Plugin();\n        Exception cause = new PluginContainerException(plugin, null, null, cause2);\n        cause2.initCause(cause);\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n        MojoDescriptor mojoDescriptor = new MojoDescriptor();\n        mojoDescriptor.setPluginDescriptor(pluginDescriptor);\n        MojoExecution mojoExecution = new MojoExecution(mojoDescriptor);\n        Throwable exception = new PluginExecutionException(mojoExecution, null, cause);\n\n        DefaultExceptionHandler handler = new DefaultExceptionHandler();\n        ExceptionSummary summary = handler.handleException(exception);\n\n        String expectedReference = \"http://cwiki.apache.org/confluence/display/MAVEN/PluginContainerException\";\n        assertEquals(expectedReference, summary.getReference());\n    }",
    "comment": "Some broken exception that does return \"this\" as getCause"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/OverlayView.java",
    "type": "method",
    "name": "OverlayView",
    "code": "public OverlayView(final Context context, final AttributeSet attrs) {\n    super(context, attrs);\n  }",
    "comment": "A simple View providing a render callback to other classes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/test/java/org/apache/spark/sql/hive/test/Complex.java",
    "type": "method",
    "name": "findByName",
    "code": "public static _Fields findByName(String name) {\n      return byName.get(name);\n    }",
    "comment": "Find the _Fields constant that matches name, or null if its not found."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultDependencyResolverResult.java",
    "type": "method",
    "name": "containsPatches",
    "code": "private boolean containsPatches(Set<PathType> types) {\n        for (PathType type : types) {\n            if (type instanceof JavaPathType.Modular modular) {\n                type = modular.rawType();\n            }\n            if (JavaPathType.PATCH_MODULE.equals(type)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "comment": "Returns whether the given set of path types contains at least one patch for a module."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testSimpleNegate",
    "code": "public void testSimpleNegate() {\n        Money expected = new Money(-14, \"CHF\");\n        assertEquals(expected, f14CHF.negate());\n    }",
    "comment": "[14 CHF] negate == [-14 CHF]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/test/java/com/iluwatar/async/method/invocation/ThreadAsyncExecutorTest.java",
    "type": "method",
    "name": "testNullTaskWithNullCallback",
    "code": "void testNullTaskWithNullCallback() {\n    assertTimeout(\n        ofMillis(3000),\n        () -> {\n          // Instantiate a new executor and start a new 'null' task ...\n          final var executor = new ThreadAsyncExecutor();\n          final var asyncResult = executor.startProcess(null, null);\n\n          assertNotNull(\n              asyncResult,\n              \"The AsyncResult should not be 'null', even though the task and callback were 'null'.\");\n          asyncResult.await(); // Prevent timing issues, and wait until the result is available\n          assertTrue(asyncResult.isCompleted());\n\n          try {\n            asyncResult.getValue();\n            fail(\"Expected ExecutionException with NPE as cause\");\n          } catch (final ExecutionException e) {\n            assertNotNull(e.getMessage());\n            assertNotNull(e.getCause());\n            assertEquals(NullPointerException.class, e.getCause().getClass());\n          }\n        });\n  }",
    "comment": "Test used to verify the behaviour of {@link ThreadAsyncExecutor#startProcess(Callable,\nAsyncCallback)} when both the callable and the asynchronous callback are 'null'"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/LruCache.java",
    "type": "method",
    "name": "getCacheDataInListForm",
    "code": "public List<UserAccount> getCacheDataInListForm() {\n    var listOfCacheData = new ArrayList<UserAccount>();\n    var temp = head;\n    while (temp != null) {\n      listOfCacheData.add(temp.userAccount);\n      temp = temp.next;\n    }\n    return listOfCacheData;\n  }",
    "comment": "Returns cache data in list form.\n\n@return {@link List}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClasspathResourceSource.java",
    "type": "method",
    "name": "getPosition",
    "code": "public final Optional<FilePosition> getPosition() {\n\t\treturn Optional.ofNullable(this.filePosition);\n\t}",
    "comment": "Get the {@link FilePosition}, if available."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/FilePosition.java",
    "type": "method",
    "name": "from",
    "code": "public static FilePosition from(int line, int column) {\n\t\treturn new FilePosition(line, column);\n\t}",
    "comment": "Create a new {@code FilePosition} using the supplied {@code line} and\n\n@param line the line number; must be greater than zero\n@param column the column number; must be greater than zero\n@return a {@link FilePosition} with the given line and column numbers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/LoginPage.java",
    "type": "method",
    "name": "enterUsername",
    "code": "public LoginPage enterUsername(String username) {\n    var usernameInputTextField = (HtmlTextInput) page.getElementById(\"username\");\n    usernameInputTextField.setText(username);\n    return this;\n  }",
    "comment": "Enters the username into the username input text field.\n\n@param username the username to enter\n@return {@link LoginPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/ShoppingCartService.java",
    "type": "method",
    "name": "checkout",
    "code": "public Order checkout(final String userId) {\n    List<Cart> items = cartRepository.getItemsInCart(userId);\n    String orderId = \"ORDER-\" + System.currentTimeMillis();\n    Order order = new Order(orderId, items);\n    orderRepository.saveOrder(order);\n    cartRepository.clearCart(userId);\n    return order;\n  }",
    "comment": "Checks out the user's cart and creates an order.\n\n<p>This method retrieves the cart items, generates an order ID, creates a new order, saves it,\nand clears the cart.\n\n@param userId The ID of the user.\n@return The created order containing purchased items."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createArrayType",
    "code": "public static ArrayType createArrayType(DataType elementType) {\n    if (elementType == null) {\n      throw new IllegalArgumentException(\"elementType should not be null.\");\n    }\n    return new ArrayType(elementType, true);\n  }",
    "comment": "Creates an ArrayType by specifying the data type of elements ({@code elementType}).\nThe field of {@code containsNull} is set to {@code true}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/gateway/src/main/java/com/iluwatar/gateway/GatewayFactory.java",
    "type": "method",
    "name": "registerGateway",
    "code": "public void registerGateway(String key, Gateway gateway) {\n    gateways.put(key, gateway);\n  }",
    "comment": "The \"GatewayFactory\" class is responsible for providing different external services in this\nGateway design pattern example. It allows clients to register and retrieve specific gateways\nbased on unique keys."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/ShuffleInMemorySorter.java",
    "type": "method",
    "name": "getSortedIterator",
    "code": "public ShuffleSorterIterator getSortedIterator() {\n    int offset = 0;\n    if (useRadixSort) {\n      offset = RadixSort.sort(\n        array, pos,\n        PackedRecordPointer.PARTITION_ID_START_BYTE_INDEX,\n        PackedRecordPointer.PARTITION_ID_END_BYTE_INDEX, false, false);\n    } else {\n      MemoryBlock unused = new MemoryBlock(\n        array.getBaseObject(),\n        array.getBaseOffset() + pos * 8L,\n        (array.size() - pos) * 8L);\n      LongArray buffer = new LongArray(unused);\n      Sorter<PackedRecordPointer, LongArray> sorter =\n        new Sorter<>(new ShuffleSortDataFormat(buffer));\n\n      sorter.sort(array, 0, pos, SORT_COMPARATOR);\n    }\n    return new ShuffleSorterIterator(pos, array, offset);\n  }",
    "comment": "Return an iterator over record pointers in sorted order."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/procedures/ProcedureParameter.java",
    "type": "method",
    "name": "Builder",
    "code": "private Builder(Mode mode, String name, DataType dataType) {\n      this.mode = mode;\n      this.name = name;\n      this.dataType = dataType;\n    }",
    "comment": "An enum representing procedure parameter modes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Character expected, char actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Character) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/sharding/src/main/java/com/iluwatar/sharding/LookupShardManager.java",
    "type": "method",
    "name": "storeData",
    "code": "public int storeData(Data data) {\n    var shardId = allocateShard(data);\n    lookupMap.put(data.getKey(), shardId);\n    var shard = shardMap.get(shardId);\n    shard.storeData(data);\n    LOGGER.info(data + \" is stored in Shard \" + shardId);\n    return shardId;\n  }",
    "comment": "ShardManager with lookup strategy. In this strategy the sharding logic implements a map that\nroutes a request for data to the shard that contains that data by using the shard key."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java",
    "type": "method",
    "name": "TempDirectory",
    "code": "public TempDirectory(JupiterConfiguration configuration) {\n\t\tthis.configuration = configuration;\n\t}",
    "comment": "{@code TempDirectory} is a JUnit Jupiter extension that creates and cleans\nup temporary directories if a field in a test class or a parameter in a\ntest class constructor, lifecycle method, or test method is annotated with\n{@code @TempDir}.\n\n<p>Consult the Javadoc for {@link TempDir} for details on the contract.\n\n@since 5.4\n@see TempDir @TempDir\n@see Files#createTempDirectory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaRecommendationExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf conf = new SparkConf().setAppName(\"Java Collaborative Filtering Example\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    String path = \"data/mllib/als/test.data\";\n    JavaRDD<String> data = jsc.textFile(path);\n    JavaRDD<Rating> ratings = data.map(s -> {\n      String[] sarray = s.split(\",\");\n      return new Rating(Integer.parseInt(sarray[0]),\n        Integer.parseInt(sarray[1]),\n        Double.parseDouble(sarray[2]));\n    });\n\n    int rank = 10;\n    int numIterations = 10;\n    MatrixFactorizationModel model = ALS.train(JavaRDD.toRDD(ratings), rank, numIterations, 0.01);\n\n    JavaRDD<Tuple2<Object, Object>> userProducts =\n      ratings.map(r -> new Tuple2<>(r.user(), r.product()));\n    JavaPairRDD<Tuple2<Integer, Integer>, Double> predictions = JavaPairRDD.fromJavaRDD(\n      model.predict(JavaRDD.toRDD(userProducts)).toJavaRDD()\n          .map(r -> new Tuple2<>(new Tuple2<>(r.user(), r.product()), r.rating()))\n    );\n    JavaRDD<Tuple2<Double, Double>> ratesAndPreds = JavaPairRDD.fromJavaRDD(\n        ratings.map(r -> new Tuple2<>(new Tuple2<>(r.user(), r.product()), r.rating())))\n      .join(predictions).values();\n    double MSE = ratesAndPreds.mapToDouble(pair -> {\n      double err = pair._1() - pair._2();\n      return err * err;\n    }).mean();\n    System.out.println(\"Mean Squared Error = \" + MSE);\n\n    model.save(jsc.sc(), \"target/tmp/myCollaborativeFilter\");\n    MatrixFactorizationModel sameModel = MatrixFactorizationModel.load(jsc.sc(),\n      \"target/tmp/myCollaborativeFilter\");\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data\nBuild the recommendation model using ALS\nEvaluate the model on rating data\nSave and load model\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/WagonMock.java",
    "type": "method",
    "name": "setConfigurableField",
    "code": "public void setConfigurableField(String configurableField) {\n        this.configurableField = configurableField;\n    }",
    "comment": "A field that can be configured in the Wagon\n\n@component.configuration default=\"configurableField\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarRow.java",
    "type": "method",
    "name": "copy",
    "code": "public InternalRow copy() {\n    GenericInternalRow row = new GenericInternalRow(numFields);\n    for (int i = 0; i < numFields(); i++) {\n      if (isNullAt(i)) {\n        row.setNullAt(i);\n      } else {\n        DataType dt = data.getChild(i).dataType();\n        PhysicalDataType pdt = PhysicalDataType.apply(dt);\n        if (pdt instanceof PhysicalBooleanType) {\n          row.setBoolean(i, getBoolean(i));\n        } else if (pdt instanceof PhysicalByteType) {\n          row.setByte(i, getByte(i));\n        } else if (pdt instanceof PhysicalShortType) {\n          row.setShort(i, getShort(i));\n        } else if (pdt instanceof PhysicalIntegerType) {\n          row.setInt(i, getInt(i));\n        } else if (pdt instanceof PhysicalLongType) {\n          row.setLong(i, getLong(i));\n        } else if (pdt instanceof PhysicalFloatType) {\n          row.setFloat(i, getFloat(i));\n        } else if (pdt instanceof PhysicalDoubleType) {\n          row.setDouble(i, getDouble(i));\n        } else if (pdt instanceof PhysicalStringType) {\n          row.update(i, getUTF8String(i).copy());\n        } else if (pdt instanceof PhysicalBinaryType) {\n          row.update(i, getBinary(i));\n        } else if (pdt instanceof PhysicalDecimalType t) {\n          row.setDecimal(i, getDecimal(i, t.precision(), t.scale()), t.precision());\n        } else if (pdt instanceof PhysicalStructType t) {\n          row.update(i, getStruct(i, t.fields().length).copy());\n        } else if (pdt instanceof PhysicalArrayType) {\n          row.update(i, getArray(i).copy());\n        } else if (pdt instanceof PhysicalMapType) {\n          row.update(i, getMap(i).copy());\n        } else {\n          throw new RuntimeException(\"Not implemented. \" + dt);\n        }\n      }\n    }\n    return row;\n  }",
    "comment": "Revisit this. This is expensive. This is currently only used in test paths."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/AlbumPage.java",
    "type": "method",
    "name": "changeAlbumRating",
    "code": "public AlbumPage changeAlbumRating(String albumRating) {\n    var albumRatingInputTextField = (HtmlTextInput) page.getElementById(\"albumRating\");\n    albumRatingInputTextField.setText(albumRating);\n    return this;\n  }",
    "comment": "Sets the album rating input text field\n\n@param albumRating the new album rating value to set\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/Result.java",
    "type": "method",
    "name": "error",
    "code": "public static <T> Result<T> error(Iterable<? extends ModelProblem> problems) {\n        return error(null, problems);\n    }",
    "comment": "Error with problems describing the cause\n\n@param problems"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlService.java",
    "type": "method",
    "name": "merge",
    "code": "public static XmlNode merge(XmlNode dominant, XmlNode recessive) {\n        return merge(dominant, recessive, null);\n    }",
    "comment": "Convenience method to merge two XML nodes using default settings."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "isCommentLine",
    "code": "static boolean isCommentLine(String line) {\n        String s = line.trim();\n        // blank lines are also treated as comment lines\n        return s.isEmpty() || COMMENT_CHARS.indexOf(s.charAt(0)) >= 0;\n    }",
    "comment": "Tests whether a line is a comment, i.e. whether it starts with a comment\ncharacter.\n\n@param line the line\n@return a flag if this is a comment line"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java",
    "type": "method",
    "name": "selectClasspathResourcesWithFilePosition",
    "code": "void selectClasspathResourcesWithFilePosition() {\n\t\t\tvar filePosition = FilePosition.from(12, 34);\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(null, filePosition));\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(\"\", filePosition));\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(\"    \", filePosition));\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(\"\\t\", filePosition));\n\n\t\t\tvar selector = selectClasspathResource(\"/foo/bar/spec.xml\", filePosition);\n\t\t\tassertEquals(\"foo/bar/spec.xml\", selector.getClasspathResourceName());\n\t\t\tassertEquals(FilePosition.from(12, 34), selector.getPosition().orElseThrow());\n\n\t\t\tselector = selectClasspathResource(\"A/B/C/spec.json\", filePosition);\n\t\t\tassertEquals(\"A/B/C/spec.json\", selector.getClasspathResourceName());\n\t\t\tassertEquals(filePosition, selector.getPosition().orElseThrow());\n\t\t}",
    "comment": "with unnecessary \"/\" prefix\nstandard use case"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/aggregate/Count.java",
    "type": "method",
    "name": "Count",
    "code": "public Count(Expression column, boolean isDistinct) {\n    this.input = column;\n    this.isDistinct = isDistinct;\n  }",
    "comment": "An aggregate function that returns the number of the specific row in a group.\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getAttachedArtifacts",
    "code": "public List<Artifact> getAttachedArtifacts() {\n        if (attachedArtifacts == null) {\n            attachedArtifacts = new ArrayList<>();\n        }\n        return Collections.unmodifiableList(attachedArtifacts);\n    }",
    "comment": "Returns a read-only list of the attached artifacts to this project.\n\n@return the attached artifacts of this project"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/ClassMap.java",
    "type": "method",
    "name": "makeMethodKey",
    "code": "private String makeMethodKey(Method method) {\n        Class<?>[] parameterTypes = method.getParameterTypes();\n\n        StringBuilder methodKey = new StringBuilder(method.getName());\n\n        for (Class<?> parameterType : parameterTypes) {\n            // If the argument type is primitive then we want\n            // to convert our primitive type signature to the\n            // corresponding Object type so introspection for\n            // methods with primitive types will work correctly.\n            if (parameterType.isPrimitive()) {\n                if (parameterType.equals(Boolean.TYPE)) {\n                    methodKey.append(\"java.lang.Boolean\");\n                } else if (parameterType.equals(Byte.TYPE)) {\n                    methodKey.append(\"java.lang.Byte\");\n                } else if (parameterType.equals(Character.TYPE)) {\n                    methodKey.append(\"java.lang.Character\");\n                } else if (parameterType.equals(Double.TYPE)) {\n                    methodKey.append(\"java.lang.Double\");\n                } else if (parameterType.equals(Float.TYPE)) {\n                    methodKey.append(\"java.lang.Float\");\n                } else if (parameterType.equals(Integer.TYPE)) {\n                    methodKey.append(\"java.lang.Integer\");\n                } else if (parameterType.equals(Long.TYPE)) {\n                    methodKey.append(\"java.lang.Long\");\n                } else if (parameterType.equals(Short.TYPE)) {\n                    methodKey.append(\"java.lang.Short\");\n                }\n            } else {\n                methodKey.append(parameterType.getName());\n            }\n        }\n\n        return methodKey.toString();\n    }",
    "comment": "Make a methodKey for the given method using\nthe concatenation of the name and the\ntypes of the method parameters."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceContentProviderSample/app/src/main/java/com/example/android/contentprovidersample/MainActivity.java",
    "type": "method",
    "name": "onCreate",
    "code": "protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main_activity);\n\n        final RecyclerView list = findViewById(R.id.list);\n        list.setLayoutManager(new LinearLayoutManager(list.getContext()));\n        mCheeseAdapter = new CheeseAdapter();\n        list.setAdapter(mCheeseAdapter);\n\n        LoaderManager.getInstance(this).initLoader(LOADER_CHEESES, null, mLoaderCallbacks);\n    }",
    "comment": "Not very relevant to Room. This just shows data from {@link SampleContentProvider}.\n\n<p>Since the data is exposed through the ContentProvider, other apps can read and write the\ncontent in a similar manner to this.</p>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelData.java",
    "type": "method",
    "name": "getVersion",
    "code": "public String getVersion() {\n        return (version != null) ? version : \"\";\n    }",
    "comment": "Gets the effective version of the model.\n\n@return The effective version of the model or an empty string if unknown, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaDataFrameSuite.java",
    "type": "method",
    "name": "testShow",
    "code": "public void testShow() {\n    Dataset<Row> df = spark.table(\"testData\");\n    df.show();\n    df.show(1000);\n  }",
    "comment": "This test case is intended ignored, but to make sure it compiles correctly"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/LookupInvoker.java",
    "type": "method",
    "name": "printErrors",
    "code": "protected void printErrors(C context, boolean showStackTrace, List<Logger.Entry> entries, Logger logger) {\n        if (logger instanceof AccumulatingLogger) {\n            logger = new SystemLogger(context.invokerRequest.stdErr().orElse(null));\n        }\n        logger.error(\"Error executing \" + context.invokerRequest.parserRequest().commandName() + \".\");\n        for (Logger.Entry entry : entries) {\n            if (showStackTrace) {\n                logger.log(entry.level(), entry.message(), entry.error());\n            } else {\n                logger.error(entry.message());\n                for (Throwable cause = entry.error();\n                        cause != null && cause != cause.getCause();\n                        cause = cause.getCause()) {\n                    logger.log(entry.level(), \"Caused by: \" + cause.getMessage());\n                }\n            }\n        }\n    }",
    "comment": "if accumulating logger passed, this is \"early failure\", swap logger for stdErr and use that to emit log\nthis is important message; many Maven IT assert for presence of this message"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "TransportConf",
    "code": "public TransportConf(String module, ConfigProvider conf) {\n    this.module = module;\n    this.conf = conf;\n    SPARK_NETWORK_IO_MODE_KEY = getConfKey(\"io.mode\");\n    SPARK_NETWORK_IO_PREFERDIRECTBUFS_KEY = getConfKey(\"io.preferDirectBufs\");\n    SPARK_NETWORK_IO_CONNECTIONTIMEOUT_KEY = getConfKey(\"io.connectionTimeout\");\n    SPARK_NETWORK_IO_CONNECTIONCREATIONTIMEOUT_KEY = getConfKey(\"io.connectionCreationTimeout\");\n    SPARK_NETWORK_IO_BACKLOG_KEY = getConfKey(\"io.backLog\");\n    SPARK_NETWORK_IO_NUMCONNECTIONSPERPEER_KEY =  getConfKey(\"io.numConnectionsPerPeer\");\n    SPARK_NETWORK_IO_SERVERTHREADS_KEY = getConfKey(\"io.serverThreads\");\n    SPARK_NETWORK_IO_CLIENTTHREADS_KEY = getConfKey(\"io.clientThreads\");\n    SPARK_NETWORK_IO_RECEIVEBUFFER_KEY = getConfKey(\"io.receiveBuffer\");\n    SPARK_NETWORK_IO_SENDBUFFER_KEY = getConfKey(\"io.sendBuffer\");\n    SPARK_NETWORK_SASL_TIMEOUT_KEY = getConfKey(\"sasl.timeout\");\n    SPARK_NETWORK_IO_MAXRETRIES_KEY = getConfKey(\"io.maxRetries\");\n    SPARK_NETWORK_IO_RETRYWAIT_KEY = getConfKey(\"io.retryWait\");\n    SPARK_NETWORK_IO_LAZYFD_KEY = getConfKey(\"io.lazyFD\");\n    SPARK_NETWORK_VERBOSE_METRICS = getConfKey(\"io.enableVerboseMetrics\");\n    SPARK_NETWORK_IO_ENABLETCPKEEPALIVE_KEY = getConfKey(\"io.enableTcpKeepAlive\");\n  }",
    "comment": "A central location that tracks all the settings we expose to users."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/max/MaxCore.java",
    "type": "method",
    "name": "run",
    "code": "public Result run(Request request) {\n        return run(request, new JUnitCore());\n    }",
    "comment": "Run all the tests contained in <code>request</code>.\n\n@param request the request describing tests\n@return a {@link Result} describing the details of the test run and the failed tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/commander/src/main/java/com/iluwatar/commander/Commander.java",
    "type": "method",
    "name": "updateQueue",
    "code": "private void updateQueue(QueueTask qt) {\n    if (System.currentTimeMillis() - qt.order.createdTime >= this.queueTime) {\n      LOG.trace(ORDER_ID + \": Queue time for order over, failed..\", qt.order.id);\n      return;\n    } else if (qt.taskType.equals(TaskType.PAYMENT) && !qt.order.paid.equals(PaymentStatus.TRYING)\n        || qt.taskType.equals(TaskType.MESSAGING)\n            && (qt.messageType == 1 && !qt.order.messageSent.equals(MessageSent.NONE_SENT)\n                || qt.order.messageSent.equals(MessageSent.PAYMENT_FAIL)\n                || qt.order.messageSent.equals(MessageSent.PAYMENT_SUCCESSFUL))\n        || qt.taskType.equals(TaskType.EMPLOYEE_DB) && qt.order.addedToEmployeeHandle) {\n      LOG.trace(ORDER_ID + \": Not queueing task since task already done..\", qt.order.id);\n      return;\n    }\n    var list = queue.exceptionsList;\n    Thread t =\n        new Thread(\n            () -> {\n              Retry.Operation op =\n                  list1 -> {\n                    if (!list1.isEmpty()) {\n                      LOG.warn(\n                          ORDER_ID + \": Error in connecting to queue db, trying again..\",\n                          qt.order.id);\n                      throw list1.remove(0);\n                    }\n                    queue.add(qt);\n                    queueItems++;\n                    LOG.info(ORDER_ID + \": {}\" + \" task enqueued..\", qt.order.id, qt.getType());\n                    tryDoingTasksInQueue();\n                  };\n              Retry.HandleErrorIssue<QueueTask> handleError =\n                  (qt1, err) -> {\n                    if (qt1.taskType.equals(TaskType.PAYMENT)) {\n                      qt1.order.paid = PaymentStatus.NOT_DONE;\n                      sendPaymentFailureMessage(qt1.order);\n                      LOG.error(\n                          ORDER_ID + \": Unable to enqueue payment task,\" + \" payment failed..\",\n                          qt1.order.id);\n                    }\n                    LOG.error(\n                        ORDER_ID\n                            + \": Unable to enqueue task of type {}\"\n                            + \", trying to add to employee handle..\",\n                        qt1.order.id,\n                        qt1.getType());\n                    employeeHandleIssue(qt1.order);\n                  };\n              var r =\n                  new Retry<>(\n                      op,\n                      handleError,\n                      numOfRetries,\n                      retryDuration,\n                      e -> DatabaseUnavailableException.class.isAssignableFrom(e.getClass()));\n              try {\n                r.perform(list, qt);\n              } catch (Exception e1) {\n                LOG.error(DEFAULT_EXCEPTION_MESSAGE, e1);\n              }\n            });\n    t.start();\n  }",
    "comment": "since payment time is lesser than queuetime it would have already failed..\nadditional check not needed"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/ConsoleLauncher.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String... args) {\n\t\tCommandFacade facade = newCommandFacade(CustomClassLoaderCloseStrategy.KEEP_OPEN);\n\t\tCommandResult<?> result = facade.run(args);\n\t\tSystem.exit(result.getExitCode());\n\t}",
    "comment": "The {@code ConsoleLauncher} is a stand-alone application for launching the\nJUnit Platform from the console.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/ExecutionPlanItem.java",
    "type": "method",
    "name": "ExecutionPlanItem",
    "code": "public ExecutionPlanItem(MojoExecution mojoExecution) {\n        this.mojoExecution = mojoExecution;\n    }",
    "comment": "<p>\nWraps individual MojoExecutions, containing information about completion status and scheduling.\n</p>\n<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expression.java",
    "type": "method",
    "name": "references",
    "code": "default NamedReference[] references() {\n    // SPARK-40398: Replace `Arrays.stream()...distinct()`\n    // to this for perf gain, the result order is not important.\n    Set<NamedReference> set = new HashSet<>();\n    for (Expression e : children()) {\n      Collections.addAll(set, e.references());\n    }\n    return set.toArray(EMPTY_NAMED_REFERENCE);\n  }",
    "comment": "List of fields or columns that are referenced by this expression."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Object expected, Object actual) {\n        Assert.assertEquals(expected, actual);\n    }",
    "comment": "Asserts that two objects are equal. If they are not\nan AssertionFailedError is thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SparkSaslServer.java",
    "type": "method",
    "name": "if",
    "code": "for (Callback callback : callbacks) {\n        if (callback instanceof NameCallback nc) {\n          logger.trace(\"SASL server callback: setting username\");\n          nc.setName(encodeIdentifier(secretKeyHolder.getSaslUser(secretKeyId)));\n        } else if (callback instanceof PasswordCallback pc) {\n          logger.trace(\"SASL server callback: setting password\");\n          pc.setPassword(encodePassword(secretKeyHolder.getSecretKey(secretKeyId)));\n        } else if (callback instanceof RealmCallback rc) {\n          logger.trace(\"SASL server callback: setting realm\");\n          rc.setText(rc.getDefaultText());\n        } else if (callback instanceof AuthorizeCallback ac) {\n          String authId = ac.getAuthenticationID();\n          String authzId = ac.getAuthorizationID();\n          ac.setAuthorized(authId.equals(authzId));\n          if (ac.isAuthorized()) {\n            ac.setAuthorizedID(authzId);\n          }\n          logger.debug(\"SASL Authorization complete, authorized set to {}\", ac.isAuthorized());\n        } else {\n          throw new UnsupportedCallbackException(callback, \"Unrecognized SASL DIGEST-MD5 Callback\");\n        }\n      }",
    "comment": "Implementation of javax.security.auth.callback.CallbackHandler for SASL DIGEST-MD5 mechanism."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/trampoline/src/main/java/com/iluwatar/trampoline/Trampoline.java",
    "type": "method",
    "name": "done",
    "code": "static <T> Trampoline<T> done(final T result) {\n    return () -> result;\n  }",
    "comment": "Created a completed Trampoline.\n\n@param result Completed result\n@return Completed Trampoline"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "setFooter",
    "code": "public void setFooter(List<String> footer) {\n        this.footer = footer;\n    }",
    "comment": "Set the comment footer.\n\n@param footer the footer to use"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/collector/DefaultProjectsSelector.java",
    "type": "method",
    "name": "DefaultProjectsSelector",
    "code": "public DefaultProjectsSelector(ProjectBuilder projectBuilder) {\n        this.projectBuilder = projectBuilder;\n    }",
    "comment": "Utility to select projects for a given set of pom.xml files."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestSqlite/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "deleteAndGetUser",
    "code": "public void deleteAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        mDataSource.deleteAllUsers();\n\n        User dbUser = mDataSource.getUser();\n        assertNull(dbUser);\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are deleting all users\nThe user is no longer in the data source"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/Platform.java",
    "type": "method",
    "name": "unaligned",
    "code": "public static boolean unaligned() {\n    return unaligned;\n  }",
    "comment": "@return true when running JVM is having sun's Unsafe package available in it and underlying\nsystem having unaligned-access capability."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClassSource.java",
    "type": "method",
    "name": "from",
    "code": "public static ClassSource from(URI uri) {\n\t\tPreconditions.notNull(uri, \"URI must not be null\");\n\t\tPreconditions.condition(CLASS_SCHEME.equals(uri.getScheme()),\n\t\t\t() -> \"URI [\" + uri + \"] must have [\" + CLASS_SCHEME + \"] scheme\");\n\n\t\tString className = uri.getSchemeSpecificPart();\n\t\tFilePosition filePosition = null;\n\t\tint indexOfQuery = className.indexOf('?');\n\t\tif (indexOfQuery >= 0) {\n\t\t\tfilePosition = FilePosition.fromQuery(className.substring(indexOfQuery + 1)).orElse(null);\n\t\t\tclassName = className.substring(0, indexOfQuery);\n\t\t}\n\n\t\treturn ClassSource.from(className, filePosition);\n\t}",
    "comment": "Create a new {@code ClassSource} from the supplied {@link URI}.\nThe {@linkplain URI#getQuery() query} component of the {@code URI}, if\npresent, will be used to retrieve the {@link FilePosition} via\n{@link FilePosition#fromQuery(String)}. For example, line 42 and column\n13 can be referenced in class {@code org.example.MyType} via the following\nURI: {@code class:com.example.MyType?line=42&column=13}. The URI fragment,\nif present, will be ignored.\n\n@param uri the {@code URI} for the class source; never {@code null}\n@return a new {@code ClassSource}; never {@code null}\n{@code null}, if the scheme of the supplied {@code URI} is not equal\nto the {@link #CLASS_SCHEME}, or if the specified class name is empty\n@since 1.8\n@see #CLASS_SCHEME"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/MetadataOperation.java",
    "type": "method",
    "name": "convertPattern",
    "code": "private String convertPattern(final String pattern, boolean datanucleusFormat) {\n    String wStr;\n    if (datanucleusFormat) {\n      wStr = \"*\";\n    } else {\n      wStr = \".*\";\n    }\n    return pattern\n        .replaceAll(\"([^\\\\\\\\])%\", \"$1\" + wStr).replaceAll(\"\\\\\\\\%\", \"%\").replaceAll(\"^%\", wStr)\n        .replaceAll(\"([^\\\\\\\\])_\", \"$1.\").replaceAll(\"\\\\\\\\_\", \"_\").replaceAll(\"^_\", \".\");\n  }",
    "comment": "Convert a pattern containing JDBC catalog search wildcards into\nJava regex patterns.\n\n@param pattern input which may contain '%' or '_' wildcard characters, or\nthese characters escaped using {@link #getSearchStringEscape()}.\n@return replace %/_ with regex search characters, also handle escaped\ncharacters.\n\nThe datanucleus module expects the wildchar as '*'. The columns search on the\nother hand is done locally inside the hive code and that requires the regex wildchar\nformat '.*'  This is driven by the datanucleusFormat flag."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/impl/DefaultArtifactManager.java",
    "type": "method",
    "name": "getProjectArtifacts",
    "code": "private Stream<org.apache.maven.artifact.Artifact> getProjectArtifacts(MavenProject project) {\n        return Stream.concat(Stream.of(project.getArtifact()), project.getAttachedArtifacts().stream());\n    }",
    "comment": "Retrieve a stream of the project's artifacts.\nDo not include the POM artifact as the file can't be set anyway."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Request.java",
    "type": "method",
    "name": "filterWith",
    "code": "public Request filterWith(Filter filter) {\n        return new FilterRequest(this, filter);\n    }",
    "comment": "Returns a Request that only contains those tests that should run when\n<code>filter</code> is applied\n\n@param filter The {@link Filter} to apply to this Request\n@return the filtered Request"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectModules",
    "code": "public static List<ModuleSelector> selectModules(Set<String> moduleNames) {\n\t\tPreconditions.notNull(moduleNames, \"Module names must not be null\");\n\t\tPreconditions.containsNoNullElements(moduleNames, \"Individual module name must not be null\");\n\n\t\t// @formatter:off\n\t\treturn moduleNames.stream()\n\t\t\t\t.map(DiscoverySelectors::selectModule)\n\t\t\t\t// unmodifiable since this is a public, non-internal method\n\t\t\t\t.collect(toUnmodifiableList());\n\t\t// @formatter:on\n\t}",
    "comment": "Create a list of {@code ModuleSelectors} for the supplied module names.\n\n<p>The unnamed module is not supported.\n\n@param moduleNames the module names to select; never {@code null}, never\ncontaining {@code null} or blank\n@since 1.1\n@see ModuleSelector"
  }
]