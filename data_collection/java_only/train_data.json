[
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testSimpleAdd",
    "code": "public void testSimpleAdd() {\n        Money expected = new Money(26, \"CHF\");\n        assertEquals(expected, f12CHF.add(f14CHF));\n    }",
    "comment": "[12 CHF] + [14 CHF] == [26 CHF]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Integer> create(Scope scope, long[] shape, IntBuffer data) {\n    try (Tensor<Integer> value = Tensor.create(shape, data)) {\n      return createWithTensor(scope, value);\n    }\n  }",
    "comment": "Create a {@link DataType#INT32} constant with data from the given buffer.\n\n<p>Creates a constant with the given shape by copying elements from the buffer (starting from\nits current position) into the tensor. For example, if {@code shape = {2,3} } (which represents\na 2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param scope is a scope used to add the underlying operation.\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@return an integer constant\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/artifact/AttachedArtifact.java",
    "type": "method",
    "name": "AttachedArtifact",
    "code": "public AttachedArtifact(Artifact parent, String type, String classifier, ArtifactHandler artifactHandler) {\n        super(\n                parent.getGroupId(),\n                parent.getArtifactId(),\n                parent.getVersionRange(),\n                parent.getScope(),\n                type,\n                classifier,\n                artifactHandler,\n                parent.isOptional());\n\n        setDependencyTrail(Collections.singletonList(parent.getId()));\n\n        this.parent = parent;\n\n        if (getId().equals(parent.getId())) {\n            throw new InvalidArtifactRTException(\n                    parent.getGroupId(),\n                    parent.getArtifactId(),\n                    parent.getVersion(),\n                    parent.getType(),\n                    \"An attached artifact must have a different ID\" + \" than its corresponding main artifact.\");\n        }\n    }",
    "comment": "<strong>Warning:</strong> This is an internal utility class that is only public for technical reasons, it is not part\nof the public API. In particular, this class can be changed or deleted without prior notice. Use\n{@link org.apache.maven.project.MavenProjectHelper#attachArtifact} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "streamAllResourcesInModule",
    "code": "public static Stream<Resource> streamAllResourcesInModule(String moduleName, Predicate<Resource> resourceFilter) {\n\t\treturn ReflectionUtils.streamAllResourcesInModule(moduleName, resourceFilter);\n\t}",
    "comment": "Find all {@linkplain Resource resources} in the supplied {@code moduleName}\nthat match the specified {@code resourceFilter} predicate.\n\n<p>The module-path scanning algorithm searches recursively in all\npackages contained in the module.\n\n@param moduleName the name of the module to scan; never {@code null} or\n<em>empty</em>\n@param resourceFilter the resource type filter; never {@code null}\n@return a stream of all such resources found; never {@code null}\nbut potentially empty\n@since 1.11\n@see #streamAllResourcesInClasspathRoot(URI, Predicate)\n@see #streamAllResourcesInPackage(String, Predicate)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "setHeader",
    "code": "public void setHeader(List<String> header) {\n        this.header = header;\n    }",
    "comment": "Set the comment header.\n\n@param header the header to use"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "isBlank",
    "code": "public static boolean isBlank(String str) {\n\t\treturn (str == null || str.trim().isEmpty());\n\t}",
    "comment": "Determine if the supplied {@link String} is <em>blank</em> (i.e.,\n{@code null} or consisting only of whitespace characters).\n\n@param str the string to check; may be {@code null}\n@return {@code true} if the string is blank\n@see #isNotBlank(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/sharding/src/main/java/com/iluwatar/sharding/ShardManager.java",
    "type": "method",
    "name": "getShardById",
    "code": "public Shard getShardById(final int shardId) {\n    return shardMap.get(shardId);\n  }",
    "comment": "Get shard instance by provided shardId.\n\n@param shardId id of shard instance to get\n@return required shard instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "append",
    "code": "public final UniqueId append(Segment segment) {\n\t\tPreconditions.notNull(segment, \"segment must not be null\");\n\t\tList<Segment> baseSegments = new ArrayList<>(this.segments.size() + 1);\n\t\tbaseSegments.addAll(this.segments);\n\t\tbaseSegments.add(segment);\n\t\treturn new UniqueId(this.uniqueIdFormat, baseSegments);\n\t}",
    "comment": "Construct a new {@code UniqueId} by appending a new {@link Segment} to\n\n<p>This {@code UniqueId} will not be modified.\n\n@param segment the segment to be appended; never {@code null}\n\n@since 1.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/queue-based-load-leveling/src/test/java/com/iluwatar/queue/load/leveling/TaskGenSrvExeTest.java",
    "type": "method",
    "name": "taskGeneratorTest",
    "code": "void taskGeneratorTest() {\n    var msgQueue = new MessageQueue();\n\n    // Create a task generator thread with 1 job to submit.\n    var taskRunnable = new TaskGenerator(msgQueue, 1);\n    var taskGenThr = new Thread(taskRunnable);\n    taskGenThr.start();\n\n    assertNotNull(taskGenThr);\n\n    // Create a service executor thread.\n    var srvRunnable = new ServiceExecutor(msgQueue);\n    var srvExeThr = new Thread(srvRunnable);\n    srvExeThr.start();\n\n    assertNotNull(srvExeThr);\n  }",
    "comment": "Test case for submitting Message to Blocking Queue by TaskGenerator and retrieve the message by\nServiceExecutor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/impl/EventSpyImpl.java",
    "type": "method",
    "name": "convert",
    "code": "protected EventType convert(ExecutionEvent.Type type) {\n        return EventType.values()[type.ordinal()];\n    }",
    "comment": "Simple \"conversion\" from Maven3 event type enum to Maven4 enum."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Integer> create(int data) {\n    return Tensor.create(data, Integer.class);\n  }",
    "comment": "Creates a scalar tensor containing a single {@code int} element.\n\n@param data The value to put into the new scalar tensor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/combinator/src/main/java/com/iluwatar/combinator/Finders.java",
    "type": "method",
    "name": "advancedFinder",
    "code": "public static Finder advancedFinder(String query, String orQuery, String notQuery) {\n    return Finder.contains(query).or(Finder.contains(orQuery)).not(Finder.contains(notQuery));\n  }",
    "comment": "Finder to find a complex query.\n\n@param query to find\n@param orQuery alternative to find\n@param notQuery exclude from search\n@return new finder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/AbstractTestDescriptor.java",
    "type": "method",
    "name": "AbstractTestDescriptor",
    "code": "protected AbstractTestDescriptor(UniqueId uniqueId, String displayName, TestSource source) {\n\t\tthis.uniqueId = Preconditions.notNull(uniqueId, \"UniqueId must not be null\");\n\t\tthis.displayName = Preconditions.notBlank(displayName, \"displayName must not be null or blank\");\n\t\tthis.source = source;\n\t}",
    "comment": "Create a new {@code AbstractTestDescriptor} with the supplied\n\n@param uniqueId the unique ID of this {@code TestDescriptor}; never\n{@code null}\n@param displayName the display name for this {@code TestDescriptor};\nnever {@code null} or blank\n@param source the source of the test or container described by this\n{@code TestDescriptor}; can be {@code null}\n@see #AbstractTestDescriptor(UniqueId, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "readFieldValues",
    "code": "public static List<Object> readFieldValues(List<Field> fields, Object instance, Predicate<Field> predicate) {\n\t\tPreconditions.notNull(fields, \"fields list must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\t// @formatter:off\n\t\treturn fields.stream()\n\t\t\t\t.filter(predicate)\n\t\t\t\t.map(field ->\n\t\t\t\t\ttryToReadFieldValue(field, instance)\n\t\t\t\t\t\t.getOrThrow(ExceptionUtils::throwAsUncheckedException))\n\t\t\t\t.collect(toUnmodifiableList());\n\t\t// @formatter:on\n\t}",
    "comment": "Read the values of the supplied fields, making each field accessible if\nnecessary, {@linkplain ExceptionUtils#throwAsUncheckedException masking}\nany checked exception as an unchecked exception, and filtering out fields\nthat do not pass the supplied {@code predicate}.\n\n@param fields the list of fields to read; never {@code null}\n@param instance the instance from which the values are to be read; may\nbe {@code null} for static fields\n@param predicate the field filter; never {@code null}\n@return an immutable list of the values of the specified fields; never\n{@code null} but may be empty or contain {@code null} entries"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, int expected, int actual) {\n        Assert.assertEquals(message, expected, actual);\n    }",
    "comment": "Asserts that two ints are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/MyDoubleAvg.java",
    "type": "method",
    "name": "initialize",
    "code": "@Override public void initialize(MutableAggregationBuffer buffer) {\n    buffer.update(0, null);\n    buffer.update(1, 0L);\n  }",
    "comment": "The initial value of the sum is null.\nThe initial value of the count is 0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/templateview/src/test/java/com/iluwatar/templateview/TemplateViewTest.java",
    "type": "method",
    "name": "testRenderHomePage",
    "code": "void testRenderHomePage() {\n    TemplateView homePage = spy(HomePageView.class);\n\n    homePage.render();\n\n    verify(homePage).printHeader(); // Header is printed\n    verify(homePage).renderDynamicContent(); // Dynamic content specific to home page\n    verify(homePage).printFooter(); // Footer is printed\n  }",
    "comment": "Create a spy for HomePageView\nCall the render method\nVerify that the steps of rendering are executed in the correct order"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java",
    "type": "method",
    "name": "matchesLayout",
    "code": "static boolean matchesLayout(String repoLayout, String mirrorLayout) {\n        boolean result = false;\n\n        // simple checks first to short circuit processing below.\n        if ((mirrorLayout == null || mirrorLayout.isEmpty()) || WILDCARD.equals(mirrorLayout)) {\n            result = true;\n        } else if (mirrorLayout.equals(repoLayout)) {\n            result = true;\n        } else {\n            // process the list\n            String[] layouts = mirrorLayout.split(\",\");\n            for (String layout : layouts) {\n                // see if this is a negative match\n                if (layout.length() > 1 && layout.startsWith(\"!\")) {\n                    if (layout.substring(1).equals(repoLayout)) {\n                        // explicitly exclude. Set result and stop processing.\n                        result = false;\n                        break;\n                    }\n                }\n                // check for exact match\n                else if (layout.equals(repoLayout)) {\n                    result = true;\n                    break;\n                } else if (WILDCARD.equals(layout)) {\n                    result = true;\n                    // don't stop processing in case a future segment explicitly excludes this repo\n                }\n            }\n        }\n\n        return result;\n    }",
    "comment": "Checks whether the layouts configured for a mirror match with the layout of the repository.\n\n@param repoLayout The layout of the repository, may be {@code null}.\n@param mirrorLayout The layouts supported by the mirror, may be {@code null}.\n@return {@code true} if the layouts associated with the mirror match the layout of the original repository,\n{@code false} otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/metadata/ClasspathContainer.java",
    "type": "method",
    "name": "ClasspathContainer",
    "code": "public ClasspathContainer(ArtifactScopeEnum scope) {\n        this.scope = ArtifactScopeEnum.checkScope(scope);\n    }",
    "comment": "classpath container that is aware of the classpath scope"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/MonotonicClock.java",
    "type": "method",
    "name": "elapsed",
    "code": "public static Duration elapsed() {\n        return get().elapsedTime();\n    }",
    "comment": "Returns the elapsed time since clock initialization.\nThis is a convenience method equivalent to {@code get().elapsedTime()}.\n\n@return the duration since clock initialization"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/scanning/ClassFilter.java",
    "type": "method",
    "name": "of",
    "code": "public static ClassFilter of(Predicate<Class<?>> classPredicate) {\n\t\treturn of(name -> true, classPredicate);\n\t}",
    "comment": "Create a {@link ClassFilter} instance that accepts all names but filters classes.\n\n@param classPredicate the class type predicate; never {@code null}\n@return an instance of {@code ClassFilter}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/results/ResultMatchers.java",
    "type": "method",
    "name": "isSuccessful",
    "code": "public static Matcher<PrintableResult> isSuccessful() {\n        return failureCountIs(0);\n    }",
    "comment": "Matches if the tests are all successful"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "expand",
    "code": "public Set<? extends DiscoverySelector> expand() {\n\t\t\treturn childSelectorsSupplier.get();\n\t\t}",
    "comment": "Expand this match in order to resolve the children of the contained\n{@link TestDescriptor}.\n\n@return the set of {@code DiscoverySelectors} that represent the\nchildren of the contained {@code TestDescriptor}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/ClassSelectorTests.java",
    "type": "method",
    "name": "equalsAndHashCode",
    "code": "void equalsAndHashCode() {\n\t\tvar selector1 = new ClassSelector(null, \"org.example.TestClass\");\n\t\tvar selector2 = new ClassSelector(null, \"org.example.TestClass\");\n\t\tvar selector3 = new ClassSelector(null, \"org.example.X\");\n\n\t\tassertEqualsAndHashCode(selector1, selector2, selector3);\n\t}",
    "comment": "Unit tests for {@link ClassSelector}.\n\n@since 1.3\n@see DiscoverySelectorsTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarBatch.java",
    "type": "method",
    "name": "getRow",
    "code": "public InternalRow getRow(int rowId) {\n    assert(rowId >= 0 && rowId < numRows);\n    row.rowId = rowId;\n    return row;\n  }",
    "comment": "Returns the row in this batch at `rowId`. Returned row is reused across calls."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/test/java/org/tensorflow/EagerSessionTest.java",
    "type": "method",
    "name": "cleanupResourceOnSafePoints",
    "code": "public void cleanupResourceOnSafePoints() {\n    TestGarbageCollectorQueue gcQueue = new TestGarbageCollectorQueue();\n    try (EagerSession s =\n        EagerSession.options()\n            .resourceCleanupStrategy(ResourceCleanupStrategy.ON_SAFE_POINTS)\n            .buildForGcTest(gcQueue)) {\n\n      TestReference ref = new TestReference(s, new Object());\n      assertFalse(ref.isDeleted());\n\n      gcQueue.collect(ref);\n      assertFalse(ref.isDeleted());\n      buildOp(s); // safe point\n      assertTrue(ref.isDeleted());\n      assertTrue(gcQueue.isEmpty());\n    }\n  }",
    "comment": "garbage collecting the reference won't release until we reached safe point"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/MediaType.java",
    "type": "method",
    "name": "create",
    "code": "public static MediaType create(String type, String subtype, Charset charset) {\n\t\tPreconditions.notNull(type, \"type must not be null\");\n\t\tPreconditions.notNull(subtype, \"subtype must not be null\");\n\t\tPreconditions.notNull(charset, \"charset must not be null\");\n\t\treturn new MediaType(type + \"/\" + subtype + \"; charset=\" + charset.name());\n\t}",
    "comment": "Create a media type with the given type, subtype, and charset.\n\n@param type the type; never {@code null}\n@param subtype the subtype; never {@code null}\n@param charset the charset; never {@code null}\n@return the media type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/monolithic-architecture/src/main/java/com/iluwatar/monolithic/EcommerceApp.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String... args) {\n    SpringApplication.run(EcommerceApp.class, args);\n  }",
    "comment": "The main entry point for the Monolithic E-commerce application. Initializes the Spring Boot\napplication and starts the embedded server."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/event/ExecutionEventLogger.java",
    "type": "method",
    "name": "forkSucceeded",
    "code": "public void forkSucceeded(ExecutionEvent event) {\n        if (logger.isInfoEnabled()) {\n            init();\n            logger.info(\"\");\n\n            MessageBuilder buffer = builder().strong(\"<<< \");\n            append(buffer, event.getMojoExecution());\n            buffer.strong(\" < \");\n            appendForkInfo(buffer, event.getMojoExecution().getMojoDescriptor());\n            append(buffer, event.getProject());\n            buffer.strong(\" <<<\");\n\n            logger.info(buffer.toString());\n\n            logger.info(\"\");\n        }\n    }",
    "comment": "<pre>&lt;&lt;&lt; mojo-artifactId:version:goal (mojo-executionId) &lt; :forked-goal @ project-artifactId &lt;&lt;&lt;</pre>\n<pre>&lt;&lt;&lt; mojo-artifactId:version:goal (mojo-executionId) &lt; [lifecycle]phase @ project-artifactId &lt;&lt;&lt;</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/FunctionCatalog.java",
    "type": "method",
    "name": "functionExists",
    "code": "default boolean functionExists(Identifier ident) {\n    try {\n      loadFunction(ident);\n      return true;\n    } catch (NoSuchFunctionException e) {\n      return false;\n    }\n  }",
    "comment": "Returns true if the function exists, false otherwise.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/iterator/src/main/java/com/iluwatar/iterator/bst/BstIterator.java",
    "type": "method",
    "name": "pushPathToNextSmallest",
    "code": "private void pushPathToNextSmallest(TreeNode<T> node) {\n    while (node != null) {\n      pathStack.push(node);\n      node = node.getLeft();\n    }\n  }",
    "comment": "This BstIterator manages to use O(h) extra space, where h is the height of the tree It achieves\nthis by maintaining a stack of the nodes to handle (pushing all left nodes first), before\nhandling self or right node.\n\n@param node TreeNode that acts as root of the subtree we're interested in."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/CustomHealthIndicatorTest.java",
    "type": "method",
    "name": "whenDatabaseIsDown_thenHealthIsDown",
    "code": "void whenDatabaseIsDown_thenHealthIsDown() {\n    CompletableFuture<Health> future =\n        CompletableFuture.completedFuture(\n            Health.down().withDetail(\"database\", \"unreachable\").build());\n    when(healthChecker.performCheck(any(), anyLong())).thenReturn(future);\n    when(healthCheckRepository.checkHealth()).thenReturn(null);\n\n    Health health = customHealthIndicator.health();\n\n    assertEquals(Status.DOWN, health.getStatus());\n  }",
    "comment": "Test case for the `health()` method when the database is down.\n\n<p>Asserts that when the `health()` method is called and the database is down, it returns a\nHealth object with Status.DOWN."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "cursor",
    "code": "public Ansi cursor(final int row, final int column) {\n        return appendEscapeSequence('H', Math.max(1, row), Math.max(1, column));\n    }",
    "comment": "Moves the cursor to row n, column m. The values are 1-based.\nAny values less than 1 are mapped to 1.\n\n@param row    row (1-based) from top\n@param column column (1 based) from left\n@return this Ansi instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/logging/Slf4jLogger.java",
    "type": "method",
    "name": "Slf4jLogger",
    "code": "public Slf4jLogger(org.slf4j.Logger logger) {\n        this.logger = logger;\n        this.projectId = ProjectBuildLogAppender.getProjectId();\n    }",
    "comment": "Adapt an SLF4J logger to a Plexus logger, ignoring Plexus logger API parts that are not classical and\nprobably not really used.\n\n@since 3.1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getBinary",
    "code": "public byte[] getBinary() {\n    return VariantUtil.getBinary(value, pos);\n  }",
    "comment": "Get a binary value from the variant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assume.java",
    "type": "method",
    "name": "assumeTrue",
    "code": "public static void assumeTrue(String message, boolean b) {\n        if (!b) throw new AssumptionViolatedException(message);\n    }",
    "comment": "If called with an expression evaluating to {@code false}, the test will halt and be ignored.\n\n@param b If <code>false</code>, the method will attempt to stop the test and ignore it by\nthrowing {@link AssumptionViolatedException}.\n@param message A message to pass to {@link AssumptionViolatedException}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "uniqueId",
    "code": "public static Condition<Event> uniqueId(Condition<? super UniqueId> condition) {\n\t\treturn new Condition<>(byTestDescriptor(where(TestDescriptor::getUniqueId, condition::matches)),\n\t\t\t\"descriptor with uniqueId %s\", condition.description().value());\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if the\n{@linkplain Event#getTestDescriptor() test descriptor} matches the\nsupplied {@link Condition}.\n\n@since 1.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/money/src/main/java/com/iluwatar/Money.java",
    "type": "method",
    "name": "roundToTwoDecimals",
    "code": "private double roundToTwoDecimals(double value) {\n    return Math.round(value * 100.0) / 100.0;\n  }",
    "comment": "Rounds the given value to two decimal places.\n\n@param value the value to round.\n@return the rounded value, up to two decimal places."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Object unexpected, Object actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails if both are {@code null}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@see Object#equals(Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/repository/Authentication.java",
    "type": "method",
    "name": "setUsername",
    "code": "public void setUsername(final String userName) {\n        this.username = userName;\n    }",
    "comment": "Set username used to access the repository.\n\n@param userName the username used to access repository"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng1021EqualAttachmentBuildNumberTest.java",
    "type": "method",
    "name": "getSnapshotVersion",
    "code": "private String getSnapshotVersion(File artifactDir) {\n        File[] files = artifactDir.listFiles();\n        for (File file : files) {\n            String name = file.getName();\n            if (name.endsWith(\".pom\")) {\n                return name.substring(\"test-\".length(), name.length() - \".pom\".length());\n            }\n        }\n        throw new IllegalStateException(\"POM not found in \" + artifactDir);\n    }",
    "comment": "Test that source attachments have the same build number and timestamp as the main\nartifact when deployed.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/CalendarInterval.java",
    "type": "method",
    "name": "CalendarInterval",
    "code": "public CalendarInterval(int months, int days, long microseconds) {\n    this.months = months;\n    this.days = days;\n    this.microseconds = microseconds;\n  }",
    "comment": "The class representing calendar intervals. The calendar interval is stored internally in\nthree components:\n<ul>\n<li>an integer value representing the number of `months` in this interval,</li>\n<li>an integer value representing the number of `days` in this interval,</li>\n<li>a long value representing the number of `microseconds` in this interval.</li>\n</ul>\n\nThe `months` and `days` are not units of time with a constant length (unlike hours, seconds), so\nthey are two separated fields from microseconds. One month may be equal to 28, 29, 30 or 31 days\nand one day may be equal to 23, 24 or 25 hours (daylight saving).\n\n@since 3.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "setHeader",
    "code": "public void setHeader(List<String> header) {\n        this.header = header;\n    }",
    "comment": "Set the comment header.\n\n@param header the header to use"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/AlbumPage.java",
    "type": "method",
    "name": "changeNumberOfSongs",
    "code": "public AlbumPage changeNumberOfSongs(int numberOfSongs) {\n    var numberOfSongsNumberField = (HtmlNumberInput) page.getElementById(\"numberOfSongs\");\n    numberOfSongsNumberField.setText(Integer.toString(numberOfSongs));\n    return this;\n  }",
    "comment": "Sets the number of songs number input field\n\n@param numberOfSongs the new number of songs value to be set\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java",
    "type": "method",
    "name": "isAssignableTo",
    "code": "void isAssignableTo() {\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(\"string\", String.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(\"string\", CharSequence.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(\"string\", Object.class));\n\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(new Object(), String.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(Integer.valueOf(\"1\"), StringBuilder.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(new StringBuilder(), String.class));\n\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(new int[0], int[].class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(new double[0], Object.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(new String[0], String[].class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(new String[0], Object.class));\n\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(1, int.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(Long.valueOf(\"1\"), long.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(Boolean.TRUE, boolean.class));\n\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(1, long.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(1f, double.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo((byte) 1, double.class));\n\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(1, Long.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(1f, Double.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo((byte) 1, Double.class));\n\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(1, char.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(1L, byte.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(1L, int.class));\n\t\t}",
    "comment": "Reference Types\nArrays\nPrimitive Types\nWidening Conversions to Primitives\nWidening Conversions to Wrappers (not supported by Java)\nNarrowing Conversions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/Execution.java",
    "type": "method",
    "name": "getConfiguration",
    "code": "public Object getConfiguration() {\n        return this.configuration;\n    } // -- Object getConfiguration()",
    "comment": "Get configuration to pass to the goals.\n\n@return Object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/OperationManager.java",
    "type": "method",
    "name": "initOperationLogCapture",
    "code": "private void initOperationLogCapture(String loggingMode) {\n    Appender ap = LogDivertAppender.create(this, OperationLog.getLoggingLevel(loggingMode));\n    ((org.apache.logging.log4j.core.Logger)org.apache.logging.log4j.LogManager.getRootLogger()).addAppender(ap);\n    ap.start();\n  }",
    "comment": "Register another Appender (with the same layout) that talks to us."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java",
    "type": "method",
    "name": "CumulativeScopeArtifactFilter",
    "code": "public CumulativeScopeArtifactFilter(CumulativeScopeArtifactFilter... filters) {\n        this.scopes = new HashSet<>();\n\n        if (filters != null) {\n            for (CumulativeScopeArtifactFilter filter : filters) {\n                addScopes(filter.getScopes());\n            }\n        }\n    }",
    "comment": "Creates a new filter that combines the specified filters.\n\n@param filters The filters to combine, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "copy",
    "code": "public UnsafeRow copy() {\n    UnsafeRow rowCopy = new UnsafeRow(numFields);\n    final byte[] rowDataCopy = new byte[sizeInBytes];\n    Platform.copyMemory(\n      baseObject,\n      baseOffset,\n      rowDataCopy,\n      Platform.BYTE_ARRAY_OFFSET,\n      sizeInBytes\n    );\n    rowCopy.pointTo(rowDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes);\n    return rowCopy;\n  }",
    "comment": "Copies this row, returning a self-contained UnsafeRow that stores its data in an internal\nbyte array rather than referencing data stored in a data page."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/DefaultArgumentConverter.java",
    "type": "method",
    "name": "DefaultArgumentConverter",
    "code": "public DefaultArgumentConverter(ExtensionContext context) {\n\t\tthis.context = context;\n\t}",
    "comment": "Property name used to set the format for the conversion of {@link Locale}\narguments: {@value}\n\n<h4>Supported Values</h4>\n<ul>\n<li>{@code bcp_47}: uses the IETF BCP 47 language tag format, delegating\nthe conversion to {@link Locale#forLanguageTag(String)}</li>\n<li>{@code iso_639}: uses the ISO 639 alpha-2 or alpha-3 language code\nformat, delegating the conversion to {@link Locale#Locale(String)}</li>\n</ul>\n\n<p>If not specified, the default is {@code bcp_47}.\n\n@since 5.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterApi.java",
    "type": "method",
    "name": "setUseXNNPACK",
    "code": "public Options setUseXNNPACK(boolean useXNNPACK) {\n      this.useXNNPACK = useXNNPACK;\n      return this;\n    }",
    "comment": "Enable or disable an optimized set of CPU kernels (provided by XNNPACK). Enabled by default."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/sqlite/java/com/example/android/persistence/migrations/LocalUserDataSource.java",
    "type": "method",
    "name": "LocalUserDataSource",
    "code": "private LocalUserDataSource(@NonNull Context context) {\n        mDbHelper = new UsersDbHelper(context);\n    }",
    "comment": "Concrete implementation of the UserDataSource, working directly with SQLite APIs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ForkJoinPoolHierarchicalTestExecutorService.java",
    "type": "method",
    "name": "createForkJoinPool",
    "code": "private ForkJoinPool createForkJoinPool(ParallelExecutionConfiguration configuration) {\n\t\tForkJoinWorkerThreadFactory threadFactory = new WorkerThreadFactory();\n\t\tCallable<ForkJoinPool> constructorInvocation = sinceJava9Constructor() //\n\t\t\t\t.map(sinceJava9ConstructorInvocation(configuration, threadFactory))\n\t\t\t\t.orElse(sinceJava7ConstructorInvocation(configuration, threadFactory));\n\t\treturn Try.call(constructorInvocation) //\n\t\t\t\t.getOrThrow(cause -> new JUnitException(\"Failed to create ForkJoinPool\", cause));\n\t}",
    "comment": "Try to use constructor available in Java >= 9\nFallback for Java 8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/CachingJupiterConfiguration.java",
    "type": "method",
    "name": "CachingJupiterConfiguration",
    "code": "public CachingJupiterConfiguration(JupiterConfiguration delegate) {\n\t\tthis.delegate = delegate;\n\t}",
    "comment": "Caching implementation of the {@link JupiterConfiguration} API.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/Artifact.java",
    "type": "method",
    "name": "key",
    "code": "default String key() {\n        String c = getClassifier();\n        return getGroupId()\n                + ':'\n                + getArtifactId()\n                + ':'\n                + getExtension()\n                + (c.isEmpty() ? \"\" : \":\" + c)\n                + ':'\n                + getVersion();\n    }",
    "comment": "{@return a unique identifier for this artifact}\nThe identifier is composed of groupId, artifactId, extension, classifier, and version.\n\n@see ArtifactCoordinates#getId()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/domain-model/src/main/java/com/iluwatar/domainmodel/Customer.java",
    "type": "method",
    "name": "buyProduct",
    "code": "public void buyProduct(Product product) {\n    LOGGER.info(\n        String.format(\n            \"%s want to buy %s($%.2f)...\",\n            name, product.getName(), product.getSalePrice().getAmount()));\n    try {\n      withdraw(product.getSalePrice());\n    } catch (IllegalArgumentException ex) {\n      LOGGER.error(ex.getMessage());\n      return;\n    }\n    try {\n      customerDao.addProduct(product, this);\n      purchases.add(product);\n      LOGGER.info(String.format(\"%s bought %s!\", name, product.getName()));\n    } catch (SQLException exception) {\n      receiveMoney(product.getSalePrice());\n      LOGGER.error(exception.getMessage());\n    }\n  }",
    "comment": "Add product to purchases, save to db and withdraw money.\n\n@param product to buy."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "preferDirectBufsForSharedByteBufAllocators",
    "code": "public boolean preferDirectBufsForSharedByteBufAllocators() {\n    return conf.getBoolean(\"spark.network.io.preferDirectBufs\", true);\n  }",
    "comment": "If enabled then off-heap byte buffers will be preferred for the shared ByteBuf allocators."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/options/ConsoleUtils.java",
    "type": "method",
    "name": "charset",
    "code": "public static Charset charset() {\n\t\treturn Charset.defaultCharset();\n\t}",
    "comment": "{@return the charset of the console}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/simple/SimpleFluentIterable.java",
    "type": "method",
    "name": "from",
    "code": "public static <E> FluentIterable<E> from(Iterable<E> iterable) {\n    return new SimpleFluentIterable<>(iterable);\n  }",
    "comment": "Constructs FluentIterable from iterable.\n\n@return a FluentIterable from a given iterable. Calls the SimpleFluentIterable constructor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4326LocalSnapshotSuppressesRemoteCheckTest.java",
    "type": "method",
    "name": "AbstractHandler",
    "code": "Handler repoHandler = new AbstractHandler() {\n\n                if (uri.endsWith(\"dep/0.1-SNAPSHOT/maven-metadata.xml\")) {\n                    java.text.DateFormat fmt = new java.text.SimpleDateFormat(\"yyyyMMddHHmmss\");\n                    fmt.setTimeZone(java.util.TimeZone.getTimeZone(\"UTC\"));\n                    String now = fmt.format(new Date(System.currentTimeMillis() + 3000));\n\n                    response.setStatus(HttpServletResponse.SC_OK);\n                    writer.println(\"<metadata>\");\n                    writer.println(\"  <groupId>org.apache.maven.its.mng4326</groupId>\");\n                    writer.println(\"  <artifactId>dep</artifactId>\");\n                    writer.println(\"  <version>0.1-SNAPSHOT</version>\");\n                    writer.println(\"  <versioning>\");\n                    writer.println(\"    <snapshot>\");\n                    writer.println(\"      <timestamp>20100329.235556</timestamp>\");\n                    writer.println(\"      <buildNumber>1</buildNumber>\");\n                    writer.println(\"    </snapshot>\");\n                    writer.println(\"    <lastUpdated>\" + now + \"</lastUpdated>\");\n                    writer.println(\"  </versioning>\");\n                    writer.println(\"</metadata>\");\n                } else if (uri.endsWith(\".pom\")) {\n                    response.setStatus(HttpServletResponse.SC_OK);\n                    writer.println(\"<project>\");\n                    writer.println(\"  <modelVersion>4.0.0</modelVersion>\");\n                    writer.println(\"  <groupId>org.apache.maven.its.mng4326</groupId>\");\n                    writer.println(\"  <artifactId>dep</artifactId>\");\n                    writer.println(\"  <version>0.1-SNAPSHOT</version>\");\n                    writer.println(\"</project>\");\n                } else if (uri.endsWith(\".jar\")) {\n                    response.setStatus(HttpServletResponse.SC_OK);\n                    writer.println(\"empty\");\n                } else {\n                    response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                }\n\n                ((Request) request).setHandled(true);\n            }",
    "comment": "Verify that locally built/installed snapshot artifacts suppress remote update checks (as long as the local copy\nstill satisfies the update policy configured for the remote repository).\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Long> create(Scope scope, long[][][][] data) {\n    return create(scope, data, Long.class);\n  }",
    "comment": "Creates a rank-4 constant of {@code long} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Double> create(double[][][][][] data) {\n    return Tensor.create(data, Double.class);\n  }",
    "comment": "Creates a rank-5 tensor of {@code double} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/CatalogPlugin.java",
    "type": "method",
    "name": "defaultNamespace",
    "code": "default String[] defaultNamespace() {\n    return new String[0];\n  }",
    "comment": "Return a default namespace for the catalog.\n<p>\nWhen this catalog is set as the current catalog, the namespace returned by this method will be\nset as the current namespace.\n<p>\nThe namespace returned by this method is not required to exist.\n\n@return a multi-part namespace"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/function/Try.java",
    "type": "method",
    "name": "call",
    "code": "public static <V> Try<V> call(Callable<V> action) {\n\t\tcheckNotNull(action, \"action\");\n\t\treturn Try.of(() -> success(action.call()));\n\t}",
    "comment": "Call the supplied {@link Callable} and return a successful {@code Try}\nthat contains the returned value or, in case an exception was thrown, a\nfailed {@code Try} that contains the exception.\n\n@param action the action to try; must not be {@code null}\n@return a succeeded or failed {@code Try} depending on the outcome of the\nsupplied action; never {@code null}\n@see #success(Object)\n@see #failure(Exception)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-class-loader/dep-b/src/main/java/org/apache/maven/plugin/coreit/ClassB.java",
    "type": "method",
    "name": "methodB",
    "code": "public static String methodB() {\n        return \"B\";\n    }",
    "comment": "A test class that is unique to this artifact.\n\n@author Benjamin Bentmann"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenPropertiesLoader.java",
    "type": "method",
    "name": "nextLocation",
    "code": "private static String nextLocation(StringTokenizer st) {\n        boolean optional = false;\n        String retVal = null;\n\n        if (st.countTokens() > 0) {\n            String tokenList = \"?\\\",\";\n            StringBuilder tokBuf = new StringBuilder(10);\n            String tok;\n            boolean inQuote = false;\n            boolean tokStarted = false;\n            boolean exit = false;\n            while ((st.hasMoreTokens()) && (!exit)) {\n                tok = st.nextToken(tokenList);\n                switch (tok) {\n                    case \"\\\"\":\n                        inQuote = !inQuote;\n                        if (inQuote) {\n                            tokenList = \"\\\"\";\n                        } else {\n                            tokenList = \"\\\" \";\n                        }\n                        break;\n                    case \",\":\n                        if (tokStarted) {\n                            retVal = tokBuf.toString();\n                            tokStarted = false;\n                            tokBuf = new StringBuilder(10);\n                            exit = true;\n                        }\n                        break;\n                    case \"?\":\n                        optional = true;\n                        break;\n                    default:\n                        tokStarted = true;\n                        tokBuf.append(tok.trim());\n                        break;\n                }\n            }\n\n            if ((!exit) && (tokStarted)) {\n                retVal = tokBuf.toString();\n            }\n        }\n\n        return optional ? \"?\" + retVal : retVal;\n    }",
    "comment": "Handle case where end of token stream and\nstill got data"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/JRETests.java",
    "type": "method",
    "name": "jre17",
    "code": "void jre17() {\n\t\tassertThat(CURRENT_JRE).as(\"current version\").isEqualTo(JAVA_17);\n\t\tassertThat(CURRENT_JRE.version()).as(\"current feature version\").isEqualTo(17);\n\t}",
    "comment": "Unit tests for {@link JRE}\n\n@since 5.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ExceptionUtils.java",
    "type": "method",
    "name": "readStackTrace",
    "code": "public static String readStackTrace(Throwable throwable) {\n\t\tPreconditions.notNull(throwable, \"Throwable must not be null\");\n\t\tStringWriter stringWriter = new StringWriter();\n\t\ttry (PrintWriter printWriter = new PrintWriter(stringWriter)) {\n\t\treturn stringWriter.toString();\n\t}\n\n\t@API(status = INTERNAL, since = \"1.10\")\n\tpublic static void pruneStackTrace(Throwable throwable, List<String> classNames) {\n\t\tPreconditions.notNull(throwable, \"Throwable must not be null\");\n\t\tPreconditions.notNull(classNames, \"List of class names must not be null\");\n\n\t\tList<StackTraceElement> stackTrace = Arrays.asList(throwable.getStackTrace());\n\t\tList<StackTraceElement> prunedStackTrace = new ArrayList<>();\n\n\t\tCollections.reverse(stackTrace);\n\n\t\tfor (int i = 0; i < stackTrace.size(); i++) {\n\t\t\tStackTraceElement element = stackTrace.get(i);\n\t\t\tString className = element.getClassName();\n\n\t\t\tif (classNames.contains(className)) {\n\t\t\t\t// Include all elements called by the test\n\t\t\t\tprunedStackTrace.addAll(stackTrace.subList(i, stackTrace.size()));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (className.startsWith(JUNIT_PLATFORM_LAUNCHER_PACKAGE_PREFIX)) {\n\t\t\t\tprunedStackTrace.clear();\n\t\t\t}\n\t\t\telse if (STACK_TRACE_ELEMENT_FILTER.test(className)) {\n\t\t\t\tprunedStackTrace.add(element);\n\t\t\t}\n\t\t}\n\n\t\tCollections.reverse(prunedStackTrace);\n\t\tthrowable.setStackTrace(prunedStackTrace.toArray(new StackTraceElement[0]));\n\t}\n\n\t@API(status = INTERNAL, since = \"1.10\")\n\tpublic static List<Throwable> findNestedThrowables(Throwable rootThrowable) {\n\t\tPreconditions.notNull(rootThrowable, \"Throwable must not be null\");\n\n\t\tSet<Throwable> visited = new LinkedHashSet<>();\n\t\tDeque<Throwable> toVisit = new ArrayDeque<>();\n\t\ttoVisit.add(rootThrowable);\n\n\t\twhile (!toVisit.isEmpty()) {\n\t\t\tThrowable current = toVisit.remove();\n\t\t\tboolean isFirstVisit = visited.add(current);\n\t\t\tif (isFirstVisit) {\n\t\t\t\tThrowable cause = current.getCause();\n\t\t\t\tif (cause != null) {\n\t\t\t\t\ttoVisit.add(cause);\n\t\t\t\t}\n\t\t\t\ttoVisit.addAll(Arrays.asList(current.getSuppressed()));\n\t\t\t}\n\t\t}\n\n\t\treturn Collections.unmodifiableList(new ArrayList<>(visited));\n\t}\n\n}",
    "comment": "Find all causes and suppressed exceptions in the stack trace of the\nsupplied {@link Throwable}.\n\n@param rootThrowable the {@code Throwable} to explore; never {@code null}\n@return an immutable list of all throwables found, including the supplied\none; never {@code null}\n\n@since 1.10"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertNotNull",
    "code": "public static void assertNotNull(String message, Object object) {\n        assertTrue(message, object != null);\n    }",
    "comment": "Asserts that an object isn't null. If it is\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/main/java/org/apache/hadoop/hive/ql/exec/HiveFunctionRegistryUtils.java",
    "type": "method",
    "name": "filterMethodsByTypeAffinity",
    "code": "static void filterMethodsByTypeAffinity(List<Method> udfMethods, List<TypeInfo> argumentsPassed) {\n    if (udfMethods.size() > 1) {\n      // Prefer methods with a closer signature based on the primitive grouping of each argument.\n      // Score each method based on its similarity to the passed argument types.\n      int currentScore = 0;\n      int bestMatchScore = 0;\n      Method bestMatch = null;\n      for (Method m: udfMethods) {\n        currentScore = 0;\n        List<TypeInfo> argumentsAccepted =\n            TypeInfoUtils.getParameterTypeInfos(m, argumentsPassed.size());\n        Iterator<TypeInfo> argsPassedIter = argumentsPassed.iterator();\n        for (TypeInfo acceptedType : argumentsAccepted) {\n          // Check the affinity of the argument passed in with the accepted argument,\n          // based on the PrimitiveGrouping\n          TypeInfo passedType = argsPassedIter.next();\n          if (acceptedType.getCategory() == Category.PRIMITIVE\n              && passedType.getCategory() == Category.PRIMITIVE) {\n            PrimitiveGrouping acceptedPg = PrimitiveObjectInspectorUtils.getPrimitiveGrouping(\n                ((PrimitiveTypeInfo) acceptedType).getPrimitiveCategory());\n            PrimitiveGrouping passedPg = PrimitiveObjectInspectorUtils.getPrimitiveGrouping(\n                ((PrimitiveTypeInfo) passedType).getPrimitiveCategory());\n            if (acceptedPg == passedPg) {\n              // The passed argument matches somewhat closely with an accepted argument\n              ++currentScore;\n            }\n          }\n        }\n        // Check if the score for this method is any better relative to others\n        if (currentScore > bestMatchScore) {\n          bestMatchScore = currentScore;\n          bestMatch = m;\n        } else if (currentScore == bestMatchScore) {\n          bestMatch = null; // no longer a best match if more than one.\n        }\n      }\n\n      if (bestMatch != null) {\n        // Found a best match during this processing, use it.\n        udfMethods.clear();\n        udfMethods.add(bestMatch);\n      }\n    }\n  }",
    "comment": "Given a set of candidate methods and list of argument types, try to\nselect the best candidate based on how close the passed argument types are\nto the candidate argument types.\nFor a varchar argument, we would prefer evaluate(string) over evaluate(double).\n@param udfMethods  list of candidate methods\n@param argumentsPassed list of argument types to match to the candidate methods"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "setName",
    "code": "public void setName(String name) {\n        fName = name;\n    }",
    "comment": "Sets the name of a TestCase.\n\n@param name the name to set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/DefaultBuildResumptionAnalyzer.java",
    "type": "method",
    "name": "determineBuildResumptionData",
    "code": "public Optional<BuildResumptionData> determineBuildResumptionData(final MavenExecutionResult result) {\n        if (!result.hasExceptions()) {\n            return Optional.empty();\n        }\n\n        List<MavenProject> sortedProjects = result.getTopologicallySortedProjects();\n\n        boolean hasNoSuccess =\n                sortedProjects.stream().noneMatch(project -> result.getBuildSummary(project) instanceof BuildSuccess);\n\n        if (hasNoSuccess) {\n            return Optional.empty();\n        }\n\n        List<String> remainingProjects = sortedProjects.stream()\n                .filter(project -> result.getBuildSummary(project) == null\n                        || result.getBuildSummary(project) instanceof BuildFailure)\n                .map(project -> project.getGroupId() + \":\" + project.getArtifactId())\n                .collect(Collectors.toList());\n\n        if (remainingProjects.isEmpty()) {\n            LOGGER.info(\"No remaining projects found, resuming the build would not make sense.\");\n            return Optional.empty();\n        }\n\n        return Optional.of(new BuildResumptionData(remainingProjects));\n    }",
    "comment": "Default implementation of {@link BuildResumptionAnalyzer}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/NestedMethodSelectorTests.java",
    "type": "method",
    "name": "equalsAndHashCode",
    "code": "void equalsAndHashCode() {\n\t\tvar selector1 = new NestedMethodSelector(null, List.of(\"EnclosingClass\"), \"NestedTestClass\", \"method\",\n\t\t\t\"int, boolean\");\n\t\tvar selector2 = new NestedMethodSelector(null, List.of(\"EnclosingClass\"), \"NestedTestClass\", \"method\",\n\t\t\t\"int, boolean\");\n\n\t\tassertEqualsAndHashCode(selector1, selector2,\n\t\t\tnew NestedMethodSelector(null, List.of(\"X\"), \"NestedTestClass\", \"method\", \"int, boolean\"));\n\t\tassertEqualsAndHashCode(selector1, selector2,\n\t\t\tnew NestedMethodSelector(null, List.of(\"X\"), \"NestedTestClass\", \"method\", \"\"));\n\t\tassertEqualsAndHashCode(selector1, selector2,\n\t\t\tnew NestedMethodSelector(null, List.of(\"EnclosingClass\"), \"NestedTestClass\", \"method\", \"int\"));\n\t\tassertEqualsAndHashCode(selector1, selector2,\n\t\t\tnew NestedMethodSelector(null, List.of(\"EnclosingClass\"), \"NestedTestClass\", \"method\", \"\"));\n\t\tassertEqualsAndHashCode(selector1, selector2,\n\t\t\tnew NestedMethodSelector(null, List.of(\"EnclosingClass\"), \"NestedTestClass\", \"X\", \"int, boolean\"));\n\t\tassertEqualsAndHashCode(selector1, selector2,\n\t\t\tnew NestedMethodSelector(null, List.of(\"EnclosingClass\"), \"NestedTestClass\", \"X\", \"\"));\n\t\tassertEqualsAndHashCode(selector1, selector2,\n\t\t\tnew NestedMethodSelector(null, List.of(\"EnclosingClass\"), \"X\", \"method\", \"int, boolean\"));\n\t\tassertEqualsAndHashCode(selector1, selector2,\n\t\t\tnew NestedMethodSelector(null, List.of(\"EnclosingClass\"), \"X\", \"method\", \"\"));\n\t}",
    "comment": "Unit tests for {@link NestedMethodSelector}.\n\n@since 1.6\n@see DiscoverySelectorsTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportFrameDecoder.java",
    "type": "method",
    "name": "decodeNext",
    "code": "private ByteBuf decodeNext() {\n    long frameSize = decodeFrameSize();\n    if (frameSize == UNKNOWN_FRAME_SIZE) {\n      return null;\n    }\n\n    if (frameBuf == null) {\n      Preconditions.checkArgument(frameSize < MAX_FRAME_SIZE,\n          \"Too large frame: %s\", frameSize);\n      Preconditions.checkArgument(frameSize > 0,\n          \"Frame length should be positive: %s\", frameSize);\n      frameRemainingBytes = (int) frameSize;\n\n      if (buffers.isEmpty()) {\n        return null;\n      }\n      if (buffers.getFirst().readableBytes() >= frameRemainingBytes) {\n        frameBuf = null;\n        nextFrameSize = UNKNOWN_FRAME_SIZE;\n        return nextBufferForFrame(frameRemainingBytes);\n      }\n      frameBuf = buffers.getFirst().alloc().compositeBuffer(Integer.MAX_VALUE);\n    }\n\n    while (frameRemainingBytes > 0 && !buffers.isEmpty()) {\n      ByteBuf next = nextBufferForFrame(frameRemainingBytes);\n      frameRemainingBytes -= next.readableBytes();\n      frameBuf.addComponent(true, next);\n    }\n    if (frameBuf.capacity() - consolidatedFrameBufSize > consolidateThreshold) {\n      int newNumComponents = frameBuf.numComponents() - consolidatedNumComponents;\n      frameBuf.consolidate(consolidatedNumComponents, newNumComponents);\n      consolidatedFrameBufSize = frameBuf.capacity();\n      consolidatedNumComponents = frameBuf.numComponents();\n    }\n    if (frameRemainingBytes > 0) {\n      return null;\n    }\n\n    return consumeCurrentFrameBuf();\n  }",
    "comment": "If buffers is empty, then return immediately for more input data.\nOtherwise, if the first buffer holds the entire frame, we attempt to\nbuild frame with it and return.\nReset buf and size for next frame.\nOther cases, create a composite buffer to manage all the buffers.\nIf the delta size of frameBuf exceeds the threshold, then we do consolidation\nto reduce memory consumption."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/special-case/src/main/java/com/iluwatar/specialcase/Db.java",
    "type": "method",
    "name": "findProductByItemName",
    "code": "public Product findProductByItemName(String itemName) {\n    if (!itemName2Product.containsKey(itemName)) {\n      return null;\n    }\n    return itemName2Product.get(itemName);\n  }",
    "comment": "Find a product with the itemName.\n\n@param itemName of the item\n@return instance of Product"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/retry/src/test/java/com/iluwatar/retry/RetryTest.java",
    "type": "method",
    "name": "ignore",
    "code": "void ignore() {\n    final var e = new CustomerNotFoundException(\"customer not found\");\n    final var retry =\n        new Retry<String>(\n            () -> {\n              throw e;\n            },\n            2,\n            0,\n            ex -> CustomerNotFoundException.class.isAssignableFrom(ex.getClass()));\n    try {\n      retry.perform();\n    } catch (BusinessException ex) {\n      // ignore\n    }\n\n    assertThat(retry.attempts(), is(2));\n  }",
    "comment": "Final number of attempts should be equal to the number of attempts asked because we are asking\nit to ignore the exception that will be thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStore.java",
    "type": "method",
    "name": "newChild",
    "code": "public NamespacedHierarchicalStore<N> newChild() {\n\t\treturn new NamespacedHierarchicalStore<>(this, this.closeAction);\n\t}",
    "comment": "Create a child store with this store as its parent and this store's close\naction."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/NearestConflictResolverTest.java",
    "type": "method",
    "name": "testEqualReversed",
    "code": "void testEqualReversed() {\n        ResolutionNode a2n = createResolutionNode(a2);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a2n, a2n, a1n);\n    }",
    "comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\na:2.0\na:1.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java",
    "type": "method",
    "name": "selectUriByName",
    "code": "void selectUriByName() {\n\t\t\tassertViolatesPrecondition(() -> selectUri((String) null));\n\t\t\tassertViolatesPrecondition(() -> selectUri(\"   \"));\n\t\t\tassertViolatesPrecondition(() -> selectUri(\"foo:\"));\n\n\t\t\tvar uri = \"https://junit.org\";\n\n\t\t\tvar selector = selectUri(uri);\n\t\t\tassertEquals(uri, selector.getUri().toString());\n\t\t}",
    "comment": "Unit tests for {@link DiscoverySelectors}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/test/java/org/apache/maven/artifact/versioning/DefaultArtifactVersionTest.java",
    "type": "method",
    "name": "testVersionParsing",
    "code": "void testVersionParsing() {\n        checkVersionParsing(\"1\", 1, 0, 0, 0, null);\n        checkVersionParsing(\"1.2\", 1, 2, 0, 0, null);\n        checkVersionParsing(\"1.2.3\", 1, 2, 3, 0, null);\n        checkVersionParsing(\"1.2.3-1\", 1, 2, 3, 1, null);\n        checkVersionParsing(\"1.2.3-alpha-1\", 1, 2, 3, 0, \"alpha-1\");\n        checkVersionParsing(\"1.2-alpha-1\", 1, 2, 0, 0, \"alpha-1\");\n        checkVersionParsing(\"1.2-alpha-1-20050205.060708-1\", 1, 2, 0, 0, \"alpha-1-20050205.060708-1\");\n        checkVersionParsing(\"RELEASE\", 0, 0, 0, 0, \"RELEASE\");\n        checkVersionParsing(\"2.0-1\", 2, 0, 0, 1, null);\n\n        checkVersionParsing(\"02\", 0, 0, 0, 0, \"02\");\n        checkVersionParsing(\"0.09\", 0, 0, 0, 0, \"0.09\");\n        checkVersionParsing(\"0.2.09\", 0, 0, 0, 0, \"0.2.09\");\n        checkVersionParsing(\"2.0-01\", 2, 0, 0, 0, \"01\");\n\n        checkVersionParsing(\"1.0.1b\", 0, 0, 0, 0, \"1.0.1b\");\n        checkVersionParsing(\"1.0M2\", 0, 0, 0, 0, \"1.0M2\");\n        checkVersionParsing(\"1.0RC2\", 0, 0, 0, 0, \"1.0RC2\");\n        checkVersionParsing(\"1.1.2.beta1\", 1, 1, 2, 0, \"beta1\");\n        checkVersionParsing(\"1.7.3.beta1\", 1, 7, 3, 0, \"beta1\");\n        checkVersionParsing(\"1.7.3.0\", 0, 0, 0, 0, \"1.7.3.0\");\n        checkVersionParsing(\"1.7.3.0-1\", 0, 0, 0, 0, \"1.7.3.0-1\");\n        checkVersionParsing(\"PATCH-1193602\", 0, 0, 0, 0, \"PATCH-1193602\");\n        checkVersionParsing(\"5.0.0alpha-2006020117\", 0, 0, 0, 0, \"5.0.0alpha-2006020117\");\n        checkVersionParsing(\"1.0.0.-SNAPSHOT\", 0, 0, 0, 0, \"1.0.0.-SNAPSHOT\");\n        checkVersionParsing(\"1..0-SNAPSHOT\", 0, 0, 0, 0, \"1..0-SNAPSHOT\");\n        checkVersionParsing(\"1.0.-SNAPSHOT\", 0, 0, 0, 0, \"1.0.-SNAPSHOT\");\n        checkVersionParsing(\".1.0-SNAPSHOT\", 0, 0, 0, 0, \".1.0-SNAPSHOT\");\n\n        checkVersionParsing(\"1.2.3.200705301630\", 0, 0, 0, 0, \"1.2.3.200705301630\");\n        checkVersionParsing(\"1.2.3-200705301630\", 1, 2, 3, 0, \"200705301630\");\n    }",
    "comment": "0 at the beginning of a number has a special handling\nversion schemes not really supported: fully transformed as qualifier"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/ComparisonFailure.java",
    "type": "method",
    "name": "DiffExtractor",
    "code": "private DiffExtractor() {\n                sharedPrefix = sharedPrefix();\n                sharedSuffix = sharedSuffix(sharedPrefix);\n            }",
    "comment": "Can not be instantiated outside {@link org.junit.ComparisonFailure.ComparisonCompactor}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(long unexpected, long actual) {\n        assertNotEquals(null, unexpected, actual);\n    }",
    "comment": "Asserts that two longs are <b>not</b> equals. If they are, an\n{@link AssertionError} without a message is thrown.\n\n@param unexpected unexpected value to check\n@param actual the value to check against <code>unexpected</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "getValueBase",
    "code": "public Object getValueBase() {\n      assert (isDefined);\n      return baseObject;\n    }",
    "comment": "Returns the base object for value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dependency-injection/src/test/java/com/iluwatar/dependency/injection/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProblemCollector.java",
    "type": "method",
    "name": "hasProblemsFor",
    "code": "default boolean hasProblemsFor(BuilderProblem.Severity severity) {\n        requireNonNull(severity, \"severity\");\n        for (BuilderProblem.Severity s : BuilderProblem.Severity.values()) {\n            if (s.ordinal() <= severity.ordinal() && problemsReportedFor(s) > 0) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "comment": "Returns {@code true} if there is at least one problem collected with severity equal or more severe than\npassed in severity."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/clustering/JavaLDASuite.java",
    "type": "method",
    "name": "distributedLDAModel",
    "code": "public void distributedLDAModel() {\n    int k = 3;\n    double topicSmoothing = 1.2;\n    double termSmoothing = 1.2;\n\n    LDA lda = new LDA();\n    lda.setK(k)\n      .setDocConcentration(topicSmoothing)\n      .setTopicConcentration(termSmoothing)\n      .setMaxIterations(5)\n      .setSeed(12345);\n\n    DistributedLDAModel model = (DistributedLDAModel) lda.run(corpus);\n\n    LocalLDAModel localModel = model.toLocal();\n    assertEquals(k, model.k());\n    assertEquals(k, localModel.k());\n    assertEquals(tinyVocabSize, model.vocabSize());\n    assertEquals(tinyVocabSize, localModel.vocabSize());\n    assertEquals(localModel.topicsMatrix(), model.topicsMatrix());\n\n    Tuple2<int[], double[]>[] roundedTopicSummary = model.describeTopics();\n    assertEquals(k, roundedTopicSummary.length);\n    Tuple2<int[], double[]>[] roundedLocalTopicSummary = localModel.describeTopics();\n    assertEquals(k, roundedLocalTopicSummary.length);\n\n    assertTrue(model.logLikelihood() < 0.0);\n    assertTrue(model.logPrior() < 0.0);\n\n    JavaPairRDD<Long, Vector> topicDistributions = model.javaTopicDistributions();\n    JavaPairRDD<Long, Vector> nonEmptyCorpus =\n        corpus.filter(tuple2 -> Vectors.norm(tuple2._2(), 1.0) != 0.0);\n    assertEquals(topicDistributions.count(), nonEmptyCorpus.count());\n\n    Tuple3<Long, int[], double[]> topTopics = model.javaTopTopicsPerDocument(3).first();\n    Long docId = topTopics._1(); // confirm doc ID type\n    int[] topicIndices = topTopics._2();\n    double[] topicWeights = topTopics._3();\n    assertEquals(3, topicIndices.length);\n    assertEquals(3, topicWeights.length);\n\n    Tuple3<Long, int[], int[]> topicAssignment = model.javaTopicAssignments().first();\n    Long docId2 = topicAssignment._1();\n    int[] termIndices2 = topicAssignment._2();\n    int[] topicIndices2 = topicAssignment._3();\n    assertEquals(termIndices2.length, topicIndices2.length);\n  }",
    "comment": "Train a model\nCheck: basic parameters\nCheck: topic summaries\nCheck: log probabilities\nCheck: topic distributions\nSPARK-5562. since the topicDistribution returns the distribution of the non empty docs\nover topics. Compare it against nonEmptyCorpus instead of corpus\nCheck: javaTopTopicsPerDocuments\nCheck: topTopicAssignments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStore.java",
    "type": "method",
    "name": "getOrComputeIfAbsent",
    "code": "public <K, V> Object getOrComputeIfAbsent(N namespace, K key, Function<K, V> defaultCreator) {\n\t\tPreconditions.notNull(defaultCreator, \"defaultCreator must not be null\");\n\t\tCompositeKey<N> compositeKey = new CompositeKey<>(namespace, key);\n\t\tStoredValue storedValue = getStoredValue(compositeKey);\n\t\tif (storedValue == null) {\n\t\t\tstoredValue = this.storedValues.computeIfAbsent(compositeKey,\n\t\t\t\t__ -> storedValue(new MemoizingSupplier(() -> {\n\t\t}\n\t\treturn storedValue.evaluate();\n\t}\n\n\tpublic <K, V> V getOrComputeIfAbsent(N namespace, K key, Function<K, V> defaultCreator, Class<V> requiredType)\n\t\t\tthrows NamespacedHierarchicalStoreException {\n\n\t\tObject value = getOrComputeIfAbsent(namespace, key, defaultCreator);\n\t\treturn castToRequiredType(key, value, requiredType);\n\t}\n\n\tpublic Object put(N namespace, Object key, Object value) throws NamespacedHierarchicalStoreException {\n\t\trejectIfClosed();\n\t\tStoredValue oldValue = this.storedValues.put(new CompositeKey<>(namespace, key), storedValue(() -> value));\n\t\treturn StoredValue.evaluateIfNotNull(oldValue);\n\t}\n\n\tpublic Object remove(N namespace, Object key) {\n\t\trejectIfClosed();\n\t\tStoredValue previous = this.storedValues.remove(new CompositeKey<>(namespace, key));\n\t\treturn StoredValue.evaluateIfNotNull(previous);\n\t}\n\n\tpublic <T> T remove(N namespace, Object key, Class<T> requiredType) throws NamespacedHierarchicalStoreException {\n\t\trejectIfClosed();\n\t\tObject value = remove(namespace, key);\n\t\treturn castToRequiredType(key, value, requiredType);\n\t}\n\n\tprivate StoredValue storedValue(Supplier<Object> value) {\n\t\treturn new StoredValue(this.insertOrderSequence.getAndIncrement(), value);\n\t}\n\n\tprivate StoredValue getStoredValue(CompositeKey<N> compositeKey) {\n\t\tStoredValue storedValue = this.storedValues.get(compositeKey);\n\t\tif (storedValue != null) {\n\t\t\treturn storedValue;\n\t\t}\n\t\tif (this.parentStore != null) {\n\t\t\treturn this.parentStore.getStoredValue(compositeKey);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T> T castToRequiredType(Object key, Object value, Class<T> requiredType) {\n\t\tPreconditions.notNull(requiredType, \"requiredType must not be null\");\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (isAssignableTo(value, requiredType)) {\n\t\t\tif (requiredType.isPrimitive()) {\n\t\t\t\treturn (T) getWrapperType(requiredType).cast(value);\n\t\t\t}\n\t\t\treturn requiredType.cast(value);\n\t\t}\n\t\t// else\n\t\tthrow new NamespacedHierarchicalStoreException(\n\t\t\tString.format(\"Object stored under key [%s] is not of required type [%s], but was [%s]: %s\", key,\n\t\t\t\trequiredType.getName(), value.getClass().getName(), value));\n\t}\n\n\tprivate void rejectIfClosed() {\n\t\tif (this.closed) {\n\t\t\tthrow new NamespacedHierarchicalStoreException(\n\t\t\t\t\"A NamespacedHierarchicalStore cannot be modified or queried after it has been closed\");\n\t\t}\n\t}\n\n\tprivate static class CompositeKey<N> {\n\n\t\tprivate final N namespace;\n\t\tprivate final Object key;\n\n\t\tprivate CompositeKey(N namespace, Object key) {\n\t\t\tthis.namespace = Preconditions.notNull(namespace, \"namespace must not be null\");\n\t\t\tthis.key = Preconditions.notNull(key, \"key must not be null\");\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (this == o) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tCompositeKey<?> that = (CompositeKey<?>) o;\n\t\t\treturn this.namespace.equals(that.namespace) && this.key.equals(that.key);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Objects.hash(this.namespace, this.key);\n\t\t}\n\n\t}\n\n\tprivate static class StoredValue {\n\n\t\tprivate final int order;\n\t\tprivate final Supplier<Object> supplier;\n\n\t\tStoredValue(int order, Supplier<Object> supplier) {\n\t\t\tthis.order = order;\n\t\t\tthis.supplier = supplier;\n\t\t}\n\n\t\tprivate <N> EvaluatedValue<N> evaluateSafely(CompositeKey<N> compositeKey) {\n\t\t\ttry {\n\t\t\t\treturn new EvaluatedValue<>(compositeKey, this.order, evaluate());\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(t);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tprivate Object evaluate() {\n\t\t\treturn this.supplier.get();\n\t\t}\n\n\t\tstatic Object evaluateIfNotNull(StoredValue value) {\n\t\t\treturn value != null ? value.evaluate() : null;\n\t\t}\n\n\t}\n\n\tprivate static class EvaluatedValue<N> {\n\n\t\tprivate static final Comparator<EvaluatedValue<?>> REVERSE_INSERT_ORDER = comparing(\n\t\t\t(EvaluatedValue<?> it) -> it.order).reversed();\n\n\t\tprivate final CompositeKey<N> compositeKey;\n\t\tprivate final int order;\n\t\tprivate final Object value;\n\n\t\tprivate EvaluatedValue(CompositeKey<N> compositeKey, int order, Object value) {\n\t\t\tthis.compositeKey = compositeKey;\n\t\t\tthis.order = order;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tprivate void close(CloseAction<N> closeAction) throws Throwable {\n\t\t\tcloseAction.close(this.compositeKey.namespace, this.compositeKey.key, this.value);\n\t\t}\n\n\t}\n\n\tprivate static class MemoizingSupplier implements Supplier<Object> {\n\n\t\tprivate static final Object NO_VALUE_SET = new Object();\n\n\t\tprivate final Supplier<Object> delegate;\n\t\tprivate volatile Object value = NO_VALUE_SET;\n\n\t\tprivate MemoizingSupplier(Supplier<Object> delegate) {\n\t\t\tthis.delegate = delegate;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object get() {\n\t\t\tif (this.value == NO_VALUE_SET) {\n\t\t\t\tcomputeValue();\n\t\t\t}\n\t\t\tif (this.value instanceof Failure) {\n\t\t\t\tthrow ExceptionUtils.throwAsUncheckedException(((Failure) this.value).throwable);\n\t\t\t}\n\t\t\treturn this.value;\n\t\t}\n\n\t\tprivate synchronized void computeValue() {\n\t\t\ttry {\n\t\t\t\tif (this.value == NO_VALUE_SET) {\n\t\t\t\t\tthis.value = this.delegate.get();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tthis.value = new Failure(t);\n\t\t\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(t);\n\t\t\t}\n\t\t}\n\n\t\tprivate static class Failure {\n\n\t\t\tprivate final Throwable throwable;\n\n\t\t\tpublic Failure(Throwable throwable) {\n\t\t\t\tthis.throwable = throwable;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@FunctionalInterface\n\tpublic interface CloseAction<N> {\n\n\t\t@API(status = EXPERIMENTAL, since = \"1.13\")\n\t\tstatic <N> CloseAction<N> closeAutoCloseables() {\n\t\t\treturn (__, ___, value) -> {\n\t\t\t\tif (value instanceof AutoCloseable) {\n\t\t\t\t\t((AutoCloseable) value).close();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tvoid close(N namespace, Object key, Object value) throws Throwable;\n\n\t}\n\n}",
    "comment": "Close the supplied {@code value}.\n\n@param namespace the namespace; never {@code null}\n@param key the key; never {@code null}\n@param value the value; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/logging/LogRecordListener.java",
    "type": "method",
    "name": "stream",
    "code": "public Stream<LogRecord> stream(Class<?> clazz) {\n\t\t// NOTE: we cannot use org.junit.platform.commons.util.Preconditions here\n\t\t// since that would introduce a package cycle.\n\t\tif (clazz == null) {\n\t\t\tthrow new JUnitException(\"Class must not be null\");\n\t\t}\n\n\t\treturn stream().filter(logRecord -> logRecord.getLoggerName().equals(clazz.getName()));\n\t}",
    "comment": "Get a stream of {@link LogRecord log records} that have been\n{@linkplain #logRecordSubmitted submitted} to this listener by the current\nthread for the logger name equal to the name of the given class.\n\n<p>As stated in the Javadoc for {@code LogRecord}, a submitted\n{@code LogRecord} should not be updated by the client application. Thus,\nthe {@code LogRecords} in the returned stream should only be inspected for\ntesting purposes and not modified in any way.\n\n@param clazz the class for which to get the log records; never {@code null}\n@see #stream()\n@see #stream(Level)\n@see #stream(Class, Level)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/simple/SimpleFluentIterable.java",
    "type": "method",
    "name": "toList",
    "code": "public static <E> List<E> toList(Iterator<E> iterator) {\n    var copy = new ArrayList<E>();\n    iterator.forEachRemaining(copy::add);\n    return copy;\n  }",
    "comment": "Collects the remaining objects of the given iterator into a List.\n\n@return a new List with the remaining objects."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaNormalizerExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaNormalizerExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n        RowFactory.create(0, Vectors.dense(1.0, 0.1, -8.0)),\n        RowFactory.create(1, Vectors.dense(2.0, 1.0, -4.0)),\n        RowFactory.create(2, Vectors.dense(4.0, 10.0, 8.0))\n    );\n    StructType schema = new StructType(new StructField[]{\n    Dataset<Row> dataFrame = spark.createDataFrame(data, schema);\n\n    Normalizer normalizer = new Normalizer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"normFeatures\")\n      .setP(1.0);\n\n    Dataset<Row> l1NormData = normalizer.transform(dataFrame);\n    l1NormData.show();\n\n    Dataset<Row> lInfNormData =\n      normalizer.transform(dataFrame, normalizer.p().w(Double.POSITIVE_INFINITY));\n    lInfNormData.show();\n\n    spark.stop();\n  }\n}",
    "comment": "$example on$\n$example off$\n$example on$\nNormalize each Vector using $L^1$ norm.\nNormalize each Vector using $L^\\infty$ norm.\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java",
    "type": "method",
    "name": "from",
    "code": "public static MethodSource from(String className, String methodName, Class<?>... methodParameterTypes) {\n\t\treturn new MethodSource(className, methodName, nullSafeToString(methodParameterTypes));\n\t}",
    "comment": "Create a new {@code MethodSource} using the supplied class name, method\n@param methodName the method name; must not be {@code null} or blank\n@param methodParameterTypes a varargs array of classes representing the\nmethod parameter types\n@since 1.5"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/ProjectIndex.java",
    "type": "method",
    "name": "ProjectIndex",
    "code": "public ProjectIndex(List<MavenProject> projects) {\n        this.projects = new HashMap<>(projects.size() * 2);\n        this.indices = new HashMap<>(projects.size() * 2);\n\n        for (int i = 0; i < projects.size(); i++) {\n            MavenProject project = projects.get(i);\n            String key = BuilderCommon.getKey(project);\n\n            this.getProjects().put(key, project);\n            this.getIndices().put(key, i);\n        }\n    }",
    "comment": "<p>\nProvides the positional index of the project\n</p>\n<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/session/HiveSessionProxy.java",
    "type": "method",
    "name": "HiveSessionProxy",
    "code": "public HiveSessionProxy(HiveSession hiveSession, UserGroupInformation ugi) {\n    this.base = hiveSession;\n    this.ugi = ugi;\n  }",
    "comment": "Proxy wrapper on HiveSession to execute operations\nby impersonating given user"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String... args) {\n        System.out.println(\"Display parameters as parsed by Maven (in canonical form and as a list of tokens) and\"\n                + \" comparison result:\");\n        if (args.length == 0) {\n            return;\n        }\n\n        ComparableVersion prev = null;\n        int i = 1;\n        for (String version : args) {\n            ComparableVersion c = new ComparableVersion(version);\n\n            if (prev != null) {\n                int compare = prev.compareTo(c);\n                System.out.println(\n                        \"   \" + prev + ' ' + ((compare == 0) ? \"==\" : ((compare < 0) ? \"<\" : \">\")) + ' ' + version);\n            }\n\n            System.out.println(\n                    (i++) + \". \" + version + \" -> \" + c.getCanonical() + \"; tokens: \" + c.items.toListString());\n\n            prev = c;\n        }\n    }",
    "comment": "Main to test version parsing and comparison.\n<p>\nTo check how \"1.2.7\" compares to \"1.2-SNAPSHOT\", for example, you can issue\n<pre>java -jar ${maven.repo.local}/org/apache/maven/maven-artifact/${maven.version}/maven-artifact-${maven.version}.jar \"1.2.7\" \"1.2-SNAPSHOT\"</pre>\ncommand to command line. Result of given command will be something like this:\n<pre>\nDisplay parameters as parsed by Maven (in canonical form) and comparison result:\n1. 1.2.7 == 1.2.7\n1.2.7 &gt; 1.2-SNAPSHOT\n2. 1.2-SNAPSHOT == 1.2-snapshot\n</pre>\n\n@param args the version strings to parse and compare. You can pass arbitrary number of version strings and always\ntwo adjacent will be compared."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/ExpressionImplUtils.java",
    "type": "method",
    "name": "tryValidateUTF8String",
    "code": "public static UTF8String tryValidateUTF8String(UTF8String utf8String) {\n    if (utf8String.isValid()) return utf8String;\n    else return null;\n  }",
    "comment": "Function to try to validate a given UTF8 string according to Unicode rules.\n\n@param utf8String\nthe input string to validate against possible invalid byte sequences\n@return\nthe original string if the input string is a valid UTF8String, null otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/DiscoveryIssueReporter.java",
    "type": "method",
    "name": "collecting",
    "code": "static DiscoveryIssueReporter collecting(Collection<? super DiscoveryIssue> collection) {\n\t\tPreconditions.notNull(collection, \"collection must not be null\");\n\t\treturn consuming(collection::add);\n\t}",
    "comment": "Create a new {@code DiscoveryIssueReporter} that adds reported issues to"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/repository/MavenArtifactRepository.java",
    "type": "method",
    "name": "find",
    "code": "public Artifact find(Artifact artifact) {\n        File artifactFile = new File(getBasedir(), pathOf(artifact));\n\n        artifact.setFile(artifactFile);\n\n        return artifact;\n    }",
    "comment": "We need to set the file here or the resolver will fail with an NPE, not fully equipped to deal\nwith multiple local repository implementations yet."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "filter",
    "code": "public Stream<Event> filter(Predicate<? super Event> predicate) {\n\t\tPreconditions.notNull(predicate, \"Filter predicate must not be null\");\n\t\treturn stream().filter(predicate);\n\t}",
    "comment": "Shortcut for {@code events.stream().filter(predicate)}.\n\n@param predicate a {@code Predicate} to apply to each event to decide if\nit should be included in the filtered stream; never {@code null}\n@return the filtered stream of events; never {@code null}\n@see #stream()\n@see Stream#filter(Predicate)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/composite/src/test/java/com/iluwatar/composite/MessengerTest.java",
    "type": "method",
    "name": "testMessage",
    "code": "private void testMessage(final LetterComposite composedMessage, final String message) {\n    // Test is the composed message has the correct number of words\n    final var words = message.split(\" \");\n    assertNotNull(composedMessage);\n    assertEquals(words.length, composedMessage.count());\n\n    // Print the message to the mocked stdOut ...\n    composedMessage.print();\n\n    // ... and verify if the message matches with the expected one\n    assertEquals(message, new String(this.stdOutBuffer.toByteArray()).trim());\n  }",
    "comment": "Test if the given composed message matches the expected message\n\n@param composedMessage The composed message, received from the messenger\n@param message The expected message"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/Java8APISuite.java",
    "type": "method",
    "name": "testVariousTransformWith",
    "code": "public void testVariousTransformWith() {\n\n    List<List<Integer>> inputData1 = Arrays.asList(Arrays.asList(1));\n    List<List<String>> inputData2 = Arrays.asList(Arrays.asList(\"x\"));\n    JavaDStream<Integer> stream1 = JavaTestUtils.attachTestInputStream(ssc, inputData1, 1);\n    JavaDStream<String> stream2 = JavaTestUtils.attachTestInputStream(ssc, inputData2, 1);\n\n    List<List<Tuple2<String, Integer>>> pairInputData1 =\n      Arrays.asList(Arrays.asList(new Tuple2<>(\"x\", 1)));\n    List<List<Tuple2<Double, Character>>> pairInputData2 =\n      Arrays.asList(Arrays.asList(new Tuple2<>(1.0, 'x')));\n    JavaPairDStream<String, Integer> pairStream1 = JavaPairDStream.fromJavaDStream(\n      JavaTestUtils.attachTestInputStream(ssc, pairInputData1, 1));\n    JavaPairDStream<Double, Character> pairStream2 = JavaPairDStream.fromJavaDStream(\n      JavaTestUtils.attachTestInputStream(ssc, pairInputData2, 1));\n\n    JavaDStream<Double> transformed1 = stream1.transformWith(stream2, (x, y, z) -> null);\n    JavaDStream<Double> transformed2 = stream1.transformWith(pairStream1,(x, y, z) -> null);\n\n    JavaPairDStream<Double, Double> transformed3 =\n      stream1.transformWithToPair(stream2,(x, y, z) -> null);\n\n    JavaPairDStream<Double, Double> transformed4 =\n      stream1.transformWithToPair(pairStream1,(x, y, z) -> null);\n\n    JavaDStream<Double> pairTransformed1 = pairStream1.transformWith(stream2,(x, y, z) -> null);\n\n    JavaDStream<Double> pairTransformed2_ =\n      pairStream1.transformWith(pairStream1,(x, y, z) -> null);\n\n    JavaPairDStream<Double, Double> pairTransformed3 =\n      pairStream1.transformWithToPair(stream2,(x, y, z) -> null);\n\n    JavaPairDStream<Double, Double> pairTransformed4 =\n      pairStream1.transformWithToPair(pairStream2,(x, y, z) -> null);\n  }",
    "comment": "tests whether all variations of transformWith can be called from Java"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ClassSupport.java",
    "type": "method",
    "name": "nullSafeToString",
    "code": "public static String nullSafeToString(Function<? super Class<?>, ? extends String> mapper, Class<?>... classes) {\n\t\treturn ClassUtils.nullSafeToString(mapper, classes);\n\t}",
    "comment": "Generate a comma-separated list of mapped values for the supplied classes.\n\n<p>The values are generated by the supplied {@code mapper}\n(e.g., {@code Class::getName}, {@code Class::getSimpleName}, etc.), unless\na class reference is {@code null} in which case it will be mapped to\n{@code \"null\"}.\n\n@param mapper the mapper to use; never {@code null}\n@param classes the classes to map\n@return a comma-separated list of mapped values, or an empty string if\nthe supplied class array is {@code null} or empty\n@see #nullSafeToString(Class...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "removeSourceRoot",
    "code": "public void removeSourceRoot(@Nonnull ProjectScope scope, @Nonnull Language language, @Nonnull Path directory) {\n        Path path = getBaseDirectory()\n                .resolve(Objects.requireNonNull(directory, \"directory cannot be null\"))\n                .normalize();\n        sources.removeIf(source -> source.scope() == scope\n                && source.language() == language\n                && source.directory().equals(path));\n    }",
    "comment": "Removes a source root from the project.\n\n@param scope the scope of the source root\n@param language the language of the source root\n@param directory the directory of the source root"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "collationInvalidNameException",
    "code": "public static SparkException collationInvalidNameException(String collationName) {\n    Map<String, String> params = new HashMap<>();\n    final int maxSuggestions = 3;\n    params.put(\"collationName\", collationName);\n    params.put(\"proposals\", getClosestSuggestionsOnInvalidName(collationName, maxSuggestions));\n    return new SparkException(\"COLLATION_INVALID_NAME\",\n        SparkException.constructMessageParams(params), null);\n  }",
    "comment": "Method for constructing errors thrown on providing invalid collation name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/DebugResolutionListener.java",
    "type": "method",
    "name": "manageArtifactSystemPath",
    "code": "public void manageArtifactSystemPath(Artifact artifact, Artifact replacement) {\n        if (!replacement.getScope().equals(artifact.getScope())) {\n            String msg = indent + artifact + \" (applying system path: \" + replacement.getFile() + \")\";\n            logger.debug(msg);\n        }\n    }",
    "comment": "only show msg if a change is actually taking place"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java9/org/junit/platform/commons/util/ModuleUtils.java",
    "type": "method",
    "name": "isJavaPlatformModuleSystemAvailable",
    "code": "public static boolean isJavaPlatformModuleSystemAvailable() {\n\t\treturn true;\n\t}",
    "comment": "Java 9+ runtime supports the Java Platform Module System.\n\n@return {@code true}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/DefaultLifecycleExecutor.java",
    "type": "method",
    "name": "getPluginsBoundByDefaultToAllLifecycles",
    "code": "public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles(String packaging) {\n        return lifeCyclePluginAnalyzer.getPluginsBoundByDefaultToAllLifecycles(packaging);\n    }",
    "comment": "These methods deal with construction intact Plugin object that look like they come from a standard\n<plugin/> block in a Maven POM. We have to do some wiggling to pull the sources of information\ntogether and this really shows the problem of constructing a sensible default configuration, but\nit's all encapsulated here so it appears normalized to the POM builder.\nWe are going to take the project packaging and find all plugin in the default lifecycle and create\nfully populated Plugin objects, including executions with goals and default configuration taken\nfrom the plugin.xml inside a plugin.\n\nTODO This whole method could probably removed by injecting lifeCyclePluginAnalyzer straight into client site.\nTODO But for some reason the whole plexus appcontext refuses to start when I try this."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroOptionalPrimitives.java",
    "type": "method",
    "name": "getSchema",
    "code": "public org.apache.avro.Schema getSchema() { return SCHEMA$; }\n  public java.lang.Object get(int field$) {\n    switch (field$) {\n    case 0: return maybe_bool_column;\n    case 1: return maybe_int_column;\n    case 2: return maybe_long_column;\n    case 3: return maybe_float_column;\n    case 4: return maybe_double_column;\n    case 5: return maybe_binary_column;\n    case 6: return maybe_string_column;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumWriter.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/hash/Murmur3_x86_32.java",
    "type": "method",
    "name": "hashUnsafeBytes2",
    "code": "public static int hashUnsafeBytes2(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes >= 0): \"lengthInBytes cannot be negative\";\n    int lengthAligned = lengthInBytes - lengthInBytes % 4;\n    int h1 = hashBytesByInt(base, offset, lengthAligned, seed);\n    int k1 = 0;\n    for (int i = lengthAligned, shift = 0; i < lengthInBytes; i++, shift += 8) {\n      k1 ^= (Platform.getByte(base, offset + i) & 0xFF) << shift;\n    }\n    h1 ^= mixK1(k1);\n    return fmix(h1, lengthInBytes);\n  }",
    "comment": "This is compatible with original and another implementations.\nUse this method for new components after Spark 2.3."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setVariant",
    "code": "public void setVariant(VariantVal value) {\n    this.childData[0].setBinary(value.getValue());\n    this.childData[1].setBinary(value.getMetadata());\n  }",
    "comment": "Sets the Variant `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/aether/ReverseTreeRepositoryListener.java",
    "type": "method",
    "name": "isInScope",
    "code": "static boolean isInScope(Artifact artifact, Artifact nodeArtifact) {\n        return Objects.equals(artifact.getGroupId(), nodeArtifact.getGroupId())\n                && Objects.equals(artifact.getArtifactId(), nodeArtifact.getArtifactId())\n                && Objects.equals(artifact.getVersion(), nodeArtifact.getVersion());\n    }",
    "comment": "The event \"artifact resolved\" if fired WHENEVER an artifact is resolved, BUT it happens also when an artifact\ndescriptor (model, the POM) is being built, and parent (and parent of parent...) is being asked for. Hence, this\nmethod \"filters\" out in WHICH artifact are we interested in, but it intentionally neglects extension as\nArtifactDescriptorReader modifies extension to \"pom\" during collect. So all we have to rely on is GAV only."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/lib_package/LibTensorFlowTest.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    System.out.println(TensorFlow.version());\n  }",
    "comment": "Companion source file for libtensorflow_java_test.sh"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/shuffledb/RocksDB.java",
    "type": "method",
    "name": "RocksDB",
    "code": "public RocksDB(org.rocksdb.RocksDB db) {\n      this.db = db;\n    }",
    "comment": "RocksDB implementation of the local KV storage used to persist the shuffle state."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicSample/app/src/main/java/com/example/android/persistence/viewmodel/ProductListViewModel.java",
    "type": "method",
    "name": "setQuery",
    "code": "public void setQuery(CharSequence query) {\n        mSavedStateHandler.set(QUERY_KEY, query);\n    }",
    "comment": "Save the user's query into the SavedStateHandle.\nThis ensures that we retain the value across process death\nand is used as the input into the Transformations.switchMap above"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java",
    "type": "method",
    "name": "evaluateExecutionCondition",
    "code": "public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {\n\t\t\ttrackLifecycle(context);\n\t\t\tString testMethod = context.getTestMethod().map(Method::getName).orElse(null);\n\t\t\tif (testMethod == null) {\n\t\t\t\tassertThat(context.getTestInstance()).isNotPresent();\n\t\t\t\tif (!isAnnotated(context.getRequiredTestClass().getEnclosingClass(), ClassTemplate.class)) {\n\t\t\t\t\tassertThat(instanceCount.getOrDefault(context.getRequiredTestClass(), 0)).isEqualTo(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tinstanceMap.put(executionConditionKey(context.getRequiredTestClass(), testMethod),\n\t\t\t\tcontext.getTestInstances().orElse(null));\n\n\t\t\treturn ConditionEvaluationResult.enabled(\"enigma\");\n\t\t}",
    "comment": "Intentionally not implementing BeforeTestExecutionCallback, AfterTestExecutionCallback,\nand TestExecutionExceptionHandler, since they are analogous to BeforeEachCallback and\nAfterEachCallback with regard to instance scope and Lifecycle."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/LoginPage.java",
    "type": "method",
    "name": "navigateToPage",
    "code": "public LoginPage navigateToPage() {\n    try {\n      page = this.webClient.getPage(PAGE_URL);\n    } catch (IOException e) {\n      LOGGER.error(\"An error occurred on navigateToPage.\", e);\n    }\n    return this;\n  }",
    "comment": "Navigates to the Login page.\n\n@return {@link LoginPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room3/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "getUser",
    "code": "void getUser(final LoadUserCallback callback) {\n        final WeakReference<LoadUserCallback> loadUserCallback = new WeakReference<>(callback);\n\n        // request the user on the I/O thread\n        mAppExecutors.diskIO().execute(new Runnable() {\n                mAppExecutors.mainThread().execute(new Runnable() {\n                        if (user == null) {\n                            userCallback.onDataNotAvailable();\n                        } else {\n                            mCachedUser = user;\n                            userCallback.onUserLoaded(mCachedUser);\n                        }\n                    }\n                });\n            }",
    "comment": "Get the user from the data source, cache it and notify via the callback that the user has\nbeen retrieved.\n\n@param callback callback that gets called when the user was retrieved from the data source."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertInstanceOf",
    "code": "public static <T> T assertInstanceOf(Class<T> expectedType, Object actualValue, String message) {\n\t\treturn AssertInstanceOf.assertInstanceOf(expectedType, actualValue, message);\n\t}",
    "comment": "<em>Assert</em> that the supplied {@code actualValue} is an instance of the\n{@code expectedType}.\n\n<p>Like the {@code instanceof} operator a {@code null} value is not\nconsidered to be of the {@code expectedType} and does not pass the assertion.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/acyclic-visitor/src/test/java/com/iluwatar/acyclicvisitor/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "newInstance",
    "code": "static XmlNode newInstance(String name) {\n        return newBuilder().name(name).build();\n    }",
    "comment": "Creates a new XmlNode instance with the specified name.\n\n@param name the name for the new node\n@return a new XmlNode instance\n@throws NullPointerException if name is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/GraphOperationBuilder.java",
    "type": "method",
    "name": "setAttr",
    "code": "public GraphOperationBuilder setAttr(String name, Shape[] value) {\n    int[] numDimensions = new int[value.length];\n    int totalNumDimensions = 0;\n    for (int idx = 0; idx < value.length; ++idx) {\n      int n = value[idx].numDimensions();\n      numDimensions[idx] = n;\n      if (n > 0) {\n        totalNumDimensions += n;\n      }\n    }\n    long[] shapes = new long[totalNumDimensions];\n    int shapeIdx = 0;\n    for (Shape shape : value) {\n      if (shape.numDimensions() > 0) {\n        for (long dim : shape.asArray()) {\n          shapes[shapeIdx++] = dim;\n        }\n      }\n    }\n    Graph.Reference r = graph.ref();\n    try {\n      setAttrShapeList(unsafeNativeHandle, name, shapes, numDimensions);\n    } finally {\n      r.close();\n    }\n    return this;\n  }",
    "comment": "Flatten the shapes into a single array to avoid too much overhead in the\nnative part"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaLBFGSExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf conf = new SparkConf().setAppName(\"L-BFGS Example\");\n    SparkContext sc = new SparkContext(conf);\n\n    String path = \"data/mllib/sample_libsvm_data.txt\";\n    JavaRDD<LabeledPoint> data = MLUtils.loadLibSVMFile(sc, path).toJavaRDD();\n    int numFeatures = data.take(1).get(0).features().size();\n\n    JavaRDD<LabeledPoint> trainingInit = data.sample(false, 0.6, 11L);\n    JavaRDD<LabeledPoint> test = data.subtract(trainingInit);\n\n    JavaPairRDD<Object, Vector> training = data.mapToPair(p ->\n      new Tuple2<>(p.label(), MLUtils.appendBias(p.features())));\n    training.cache();\n\n    int numCorrections = 10;\n    double convergenceTol = 1e-4;\n    int maxNumIterations = 20;\n    double regParam = 0.1;\n    Vector initialWeightsWithIntercept = Vectors.dense(new double[numFeatures + 1]);\n\n    Tuple2<Vector, double[]> result = LBFGS.runLBFGS(\n      training.rdd(),\n      new LogisticGradient(),\n      new SquaredL2Updater(),\n      numCorrections,\n      convergenceTol,\n      maxNumIterations,\n      regParam,\n      initialWeightsWithIntercept);\n    Vector weightsWithIntercept = result._1();\n    double[] loss = result._2();\n\n    LogisticRegressionModel model = new LogisticRegressionModel(\n      Vectors.dense(Arrays.copyOf(weightsWithIntercept.toArray(), weightsWithIntercept.size() - 1)),\n      (weightsWithIntercept.toArray())[weightsWithIntercept.size() - 1]);\n\n    model.clearThreshold();\n\n    JavaPairRDD<Object, Object> scoreAndLabels = test.mapToPair(p ->\n      new Tuple2<>(model.predict(p.features()), p.label()));\n\n    BinaryClassificationMetrics metrics =\n      new BinaryClassificationMetrics(scoreAndLabels.rdd());\n    double auROC = metrics.areaUnderROC();\n\n    System.out.println(\"Loss of each step in training process\");\n    for (double l : loss) {\n      System.out.println(l);\n    }\n    System.out.println(\"Area under ROC = \" + auROC);\n\n    sc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nSplit initial RDD into two... [60% training data, 40% testing data].\nAppend 1 into the training data as intercept.\nRun training algorithm to build the model.\nClear the default threshold.\nCompute raw scores on the test set.\nGet evaluation metrics.\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/ListTest.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String... args) {\n        junit.textui.TestRunner.run(suite());\n    }",
    "comment": "A sample test case, testing {@link java.util.ArrayList}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/CLIReportingUtils.java",
    "type": "method",
    "name": "showVersion",
    "code": "public static String showVersion() {\n        return showVersion(null, null);\n    }",
    "comment": "Utility class used to report errors, statistics, application version info, etc."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/mute-idiom/src/main/java/com/iluwatar/mute/Mute.java",
    "type": "method",
    "name": "loggedMute",
    "code": "public static void loggedMute(CheckedRunnable runnable) {\n    try {\n      runnable.run();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }",
    "comment": "Executes the <code>runnable</code> and logs the exception occurred on {@link System#err}. This\nmethod should be utilized to mute the operations about which most you can do is log. For\ninstance while closing a connection to database, or cleaning up a resource, all you can do is\nlog the exception occurred.\n\n@param runnable a runnable that may throw an exception on execution."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/running/classes/parent/TestWithClassRule.java",
    "type": "method",
    "name": "apply",
    "code": "public Statement apply(final Statement base, final Description description) {\n            return new Statement() {\n                    base.evaluate();\n                }\n            };",
    "comment": "Test class for validate run tests that was load in own ClassLoader"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/aggregate/Sum.java",
    "type": "method",
    "name": "Sum",
    "code": "public Sum(Expression column, boolean isDistinct) {\n    this.input = column;\n    this.isDistinct = isDistinct;\n  }",
    "comment": "An aggregate function that returns the summation of all the values in a group.\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelBuilder.java",
    "type": "method",
    "name": "results",
    "code": "Stream<DefaultModelBuilderResult> results(DefaultModelBuilderResult r) {\n            return Stream.concat(Stream.of(r), r.getChildren().stream().flatMap(this::results));\n        }",
    "comment": "Generates a stream of DefaultModelBuilderResult objects, starting with the provided\nresult and recursively including all its child results.\n\n@param r The initial DefaultModelBuilderResult object from which to generate the stream.\n@return A Stream of DefaultModelBuilderResult objects, starting with the provided result\nand including all its child results."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/ChildProcAppHandle.java",
    "type": "method",
    "name": "setChildProc",
    "code": "void setChildProc(Process childProc, String loggerName, InputStream logStream) {\n    this.childProc = childProc;\n    if (logStream != null) {\n      this.redirector = new OutputRedirector(logStream, loggerName,\n        SparkLauncher.REDIRECTOR_FACTORY, this);\n    } else {\n      SparkLauncher.REDIRECTOR_FACTORY.newThread(this::monitorChild).start();\n    }\n  }",
    "comment": "If there is no log redirection, spawn a thread that will wait for the child process\nto finish."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/EngineFilter.java",
    "type": "method",
    "name": "excludeEngines",
    "code": "public static EngineFilter excludeEngines(List<String> engineIds) {\n\t\treturn new EngineFilter(engineIds, Type.EXCLUDE);\n\t}",
    "comment": "Create a new <em>exclude</em> {@code EngineFilter} based on the\n<em>excluded</em> from test discovery and execution.\n\n@param engineIds the list of engine IDs to match against; never {@code null}\nor empty; individual IDs must also not be null or blank\n@see #includeEngines(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/MethodMap.java",
    "type": "method",
    "name": "add",
    "code": "void add(Method method) {\n        String methodName = method.getName();\n\n        List<Method> l = get(methodName);\n\n        if (l == null) {\n            l = new ArrayList<>();\n            methodByNameMap.put(methodName, l);\n        }\n\n        l.add(method);\n    }",
    "comment": "Add a method to a list of methods by name.\nFor a particular class we are keeping track\nof all the methods with the same name.\n\n@param method The method"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/LimitedInputStream.java",
    "type": "method",
    "name": "LimitedInputStream",
    "code": "public LimitedInputStream(InputStream in, long limit, boolean closeWrappedStream) {\n    super(in);\n    this.closeWrappedStream = closeWrappedStream;\n    Preconditions.checkNotNull(in);\n    Preconditions.checkArgument(limit >= 0, \"limit must be non-negative\");\n    left = limit;\n  }",
    "comment": "Create a LimitedInputStream that will read {@code limit} bytes from {@code in}.\n<p>\nIf {@code closeWrappedStream} is true, this will close {@code in} when it is closed.\nOtherwise, the stream is left open for reading its remaining content.\n\n@param in a {@link InputStream} to read from\n@param limit the number of bytes to read\n@param closeWrappedStream whether to close {@code in} when {@link #close} is called"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/plugin/testing/stubs/ArtifactStub.java",
    "type": "method",
    "name": "ArtifactStub",
    "code": "public ArtifactStub() {\n        groupId = \"\";\n        artifactId = \"\";\n        version = \"\";\n        classifier = \"\";\n        extension = \"\";\n    }",
    "comment": "A stub implementation of {@link Artifact} for testing purposes.\nProvides basic artifact information without actual artifact resolution.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "binarySort",
    "code": "private void binarySort(Buffer a, int lo, int hi, int start, Comparator<? super K> c) {\n    assert lo <= start && start <= hi;\n    if (start == lo)\n      start++;\n\n    K key0 = s.newKey();\n    K key1 = s.newKey();\n\n    Buffer pivotStore = s.allocate(1);\n    for ( ; start < hi; start++) {\n      s.copyElement(a, start, pivotStore, 0);\n      K pivot = s.getKey(pivotStore, 0, key0);\n\n      // Set left (and right) to the index where a[start] (pivot) belongs\n      int left = lo;\n      int right = start;\n      assert left <= right;\n      /*\n       * Invariants:\n       *   pivot >= all in [lo, left).\n       *   pivot <  all in [right, start).\n       */\n      while (left < right) {\n        int mid = (left + right) >>> 1;\n        if (c.compare(pivot, s.getKey(a, mid, key1)) < 0)\n          right = mid;\n        else\n          left = mid + 1;\n      }\n      assert left == right;\n\n      /*\n       * The invariants still hold: pivot >= all in [lo, left) and\n       * pivot < all in [left, start), so pivot belongs at left.  Note\n       * that if there are elements equal to pivot, left points to the\n       * first slot after them -- that's why this sort is stable.\n       * Slide elements over to make room for pivot.\n       */\n      int n = start - left;  // The number of elements to move\n      // Switch is just an optimization for arraycopy in default case\n      switch (n) {\n        case 2:  s.copyElement(a, left + 1, a, left + 2);\n        case 1:  s.copyElement(a, left, a, left + 1);\n          break;\n        default: s.copyRange(a, left, a, left + 1, n);\n      }\n      s.copyElement(pivotStore, 0, a, left);\n    }\n  }",
    "comment": "Sorts the specified portion of the specified array using a binary\ninsertion sort.  This is the best method for sorting small numbers\nof elements.  It requires O(n log n) compares, but O(n^2) data\nmovement (worst case).\n\nIf the initial part of the specified range is already sorted,\nthis method can take advantage of it: the method assumes that the\nelements from index {@code lo}, inclusive, to {@code start},\nexclusive are already sorted.\n\n@param a the array in which a range is to be sorted\n@param lo the index of the first element in the range to be sorted\n@param hi the index after the last element in the range to be sorted\n@param start the index of the first element in the range that is\nnot already known to be sorted ({@code lo <= start <= hi})\n@param c comparator to used for the sort"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Double unexpected, double actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Double) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, double actual, double delta) {\n        assertEquals(null, expected, actual, delta);\n    }",
    "comment": "Asserts that two doubles are equal to within a positive delta.\nIf they are not, an {@link AssertionError} is thrown. If the expected\nvalue is infinity then the delta value is ignored.NaNs are considered\nequal: <code>assertEquals(Double.NaN, Double.NaN, *)</code> passes\n\n@param expected expected value\n@param actual the value to check against <code>expected</code>\n@param delta the maximum delta between <code>expected</code> and\n<code>actual</code> for which both numbers are still\nconsidered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/test/java/org/tensorflow/TestUtil.java",
    "type": "method",
    "name": "byte2bool",
    "code": "public static boolean[] byte2bool(byte[] array) {\n    boolean[] out = new boolean[array.length];\n    for (int i = 0; i < array.length; i++) {\n      out[i] = array[i] != 0;\n    }\n    return out;\n  }",
    "comment": "Converts a {@code byte[]} to a {@code boolean[]}.\n\n<p>Suitable for reading tensors of type {@link DataType#BOOL} using {@link\njava.nio.ByteBuffer}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ExtensibleEnumRegistry.java",
    "type": "method",
    "name": "require",
    "code": "default T require(@Nonnull String id) {\n        return lookup(id).orElseThrow(() -> new IllegalArgumentException(\"Unknown extensible enum value '\" + id + \"'\"));\n    }",
    "comment": "Registry for extensible enum values that allows looking up enum instances by their identifiers.\n<p>\nThis service provides access to all registered instances of a specific extensible enum type.\nIt's used internally by Maven and can also be used by plugins and extensions to access\ncustom enum values that have been registered through SPI providers.\n\n@param <T> the specific type of extensible enum managed by this registry\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-builder-support/src/main/java/org/apache/maven/building/UrlSource.java",
    "type": "method",
    "name": "UrlSource",
    "code": "public UrlSource(URL url) {\n        this.url = Objects.requireNonNull(url, \"url cannot be null\");\n        this.hashCode = Objects.hashCode(url);\n    }",
    "comment": "Creates a new source backed by the specified URL.\n\n@param url The file, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/EngineDiscoveryRequest.java",
    "type": "method",
    "name": "getOutputDirectoryProvider",
    "code": "default OutputDirectoryProvider getOutputDirectoryProvider() {\n\t\tthrow new JUnitException(\n\t\t\t\"OutputDirectoryProvider not available; probably due to unaligned versions of the junit-platform-engine and junit-platform-launcher jars on the classpath/module path.\");\n\t}",
    "comment": "Get the {@link OutputDirectoryProvider} for this request.\n\n@return the output directory provider; never {@code null}\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/FarthestConflictResolverTest.java",
    "type": "method",
    "name": "testDepth",
    "code": "void testDepth() {\n        ResolutionNode a1n = createResolutionNode(a1);\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n\n        assertResolveConflict(a2n, a1n, a2n);\n    }",
    "comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\na:1.0\nb:1.0 -&gt; a:2.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/unsafe/map/AbstractBytesToBytesMapSuite.java",
    "type": "method",
    "name": "randomizedStressTest",
    "code": "public void randomizedStressTest() {\n    final int size = 32768;\n    final Map<ByteBuffer, byte[]> expected = new HashMap<>();\n    final BytesToBytesMap map = new BytesToBytesMap(taskMemoryManager, size, PAGE_SIZE_BYTES);\n    try {\n      for (int i = 0; i < size * 0.9; i++) {\n        final byte[] key = getRandomByteArray(rand.nextInt(256) + 1);\n        final byte[] value = getRandomByteArray(rand.nextInt(256) + 1);\n        if (!expected.containsKey(ByteBuffer.wrap(key))) {\n          expected.put(ByteBuffer.wrap(key), value);\n          final BytesToBytesMap.Location loc = map.lookup(\n            key,\n            Platform.BYTE_ARRAY_OFFSET,\n            key.length\n          );\n          Assertions.assertFalse(loc.isDefined());\n          Assertions.assertTrue(loc.append(\n            key,\n            Platform.BYTE_ARRAY_OFFSET,\n            key.length,\n            value,\n            Platform.BYTE_ARRAY_OFFSET,\n            value.length\n          ));\n          Assertions.assertTrue(loc.isDefined());\n          Assertions.assertEquals(key.length, loc.getKeyLength());\n          Assertions.assertEquals(value.length, loc.getValueLength());\n          Assertions.assertTrue(arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), key.length));\n          Assertions.assertTrue(\n            arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), value.length));\n        }\n      }\n\n      for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) {\n        final byte[] key = JavaUtils.bufferToArray(entry.getKey());\n        final byte[] value = entry.getValue();\n        final BytesToBytesMap.Location loc =\n          map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length);\n        Assertions.assertTrue(loc.isDefined());\n        Assertions.assertTrue(\n          arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), loc.getKeyLength()));\n        Assertions.assertTrue(\n          arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), loc.getValueLength()));\n      }\n    } finally {\n      map.free();\n    }\n  }",
    "comment": "Java arrays' hashCodes() aren't based on the arrays' contents, so we need to wrap arrays\ninto ByteBuffers in order to use them as keys here.\nFill the map to 90% full so that we can trigger probing\nAfter calling putNewKey, the following should be true, even before calling\nlookup():"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/acyclic-visitor/src/main/java/com/iluwatar/acyclicvisitor/ConfigureForUnixVisitor.java",
    "type": "method",
    "name": "visit",
    "code": "public void visit(Zoom zoom) {\n    LOGGER.info(zoom + \" used with Unix configurator.\");\n  }",
    "comment": "ConfigureForUnixVisitor class implements zoom's visit method for Unix manufacturer, unlike\ntraditional visitor pattern, this class may selectively implement visit for other modems."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/AlbumPage.java",
    "type": "method",
    "name": "cancelChanges",
    "code": "public AlbumListPage cancelChanges() {\n    var cancelButton = (HtmlSubmitInput) page.getElementById(\"cancelButton\");\n    try {\n      cancelButton.click();\n    } catch (IOException e) {\n      LOGGER.error(\"An error occurred on cancelChanges.\", e);\n    }\n    return new AlbumListPage(webClient);\n  }",
    "comment": "Cancel changes made by clicking the cancel button.\n\n@return {@link AlbumListPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/HikariConfig.java",
    "type": "method",
    "name": "setKeepaliveTime",
    "code": "public void setKeepaliveTime(long keepaliveTimeMs) {\n      this.keepaliveTime = keepaliveTimeMs;\n   }",
    "comment": "This property controls the keepalive interval for a connection in the pool. An in-use connection will never be\ntested by the keepalive thread, only when it is idle will it be tested.\n\n@param keepaliveTimeMs the interval in which connections will be tested for aliveness, thus keeping them alive by the act of checking. Value is in milliseconds, default is 0 (disabled)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/LegacyCameraConnectionFragment.java",
    "type": "method",
    "name": "startBackgroundThread",
    "code": "private void startBackgroundThread() {\n    backgroundThread = new HandlerThread(\"CameraBackground\");\n    backgroundThread.start();\n  }",
    "comment": "Starts a background thread and its {@link Handler}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "childlessCopy",
    "code": "public Description childlessCopy() {\n        return new Description(fTestClass, fDisplayName, fAnnotations);\n    }",
    "comment": "@return a copy of this description, with no children (on the assumption that some of the\nchildren will be added back)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/manager/DefaultWagonManager.java",
    "type": "method",
    "name": "getMirrorRepository",
    "code": "public ArtifactRepository getMirrorRepository(ArtifactRepository repository) {\n\n        Mirror mirror = mirrorSelector.getMirror(\n                repository, legacySupport.getSession().getSettings().getMirrors());\n\n        if (mirror != null) {\n            String id = mirror.getId();\n            if (id == null) {\n                id = repository.getId();\n            }\n\n            log.debug(\"Using mirror: \" + mirror.getUrl() + \" (id: \" + id + \")\");\n\n            repository = artifactRepositoryFactory.createArtifactRepository(\n                    id, mirror.getUrl(), repository.getLayout(), repository.getSnapshots(), repository.getReleases());\n        }\n        return repository;\n    }",
    "comment": "TODO this should be illegal in settings.xml"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassNamePatternFilterUtils.java",
    "type": "method",
    "name": "replaceRegExElements",
    "code": "private static String replaceRegExElements(String pattern) {\n\t\treturn Matcher.quoteReplacement(pattern)\n\t\t\t\t.replace(\".\", \"[.$]\")\n\t\t\t\t.replace(\"*\", \".+\");\n\t}",
    "comment": "Match \".\" against \".\" and \"$\" since users may declare a \".\" instead of a\n\"$\" as the separator between classes and nested classes.\nConvert our \"*\" wildcard into a proper RegEx pattern."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/MyDoubleAvg.java",
    "type": "method",
    "name": "update",
    "code": "@Override public void update(MutableAggregationBuffer buffer, Row input) {\n    if (!input.isNullAt(0)) {\n      if (buffer.isNullAt(0)) {\n        buffer.update(0, input.getDouble(0));\n        buffer.update(1, 1L);\n      } else {\n        Double newValue = input.getDouble(0) + buffer.getDouble(0);\n        buffer.update(0, newValue);\n        buffer.update(1, buffer.getLong(1) + 1L);\n      }\n    }\n  }",
    "comment": "This input Row only has a single column storing the input value in Double.\nWe only update the buffer when the input value is not null.\nIf the buffer value (the intermediate result of the sum) is still null,\nwe set the input value to the buffer and set the bufferCount to 1.\nOtherwise, update the bufferSum and increment bufferCount."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/flex/java/src/main/java/org/tensorflow/lite/flex/FlexDelegate.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n    if (delegateHandle != INVALID_DELEGATE_HANDLE) {\n      nativeDeleteDelegate(delegateHandle);\n      delegateHandle = INVALID_DELEGATE_HANDLE;\n    }\n  }",
    "comment": "Releases native resources held by the delegate.\n\n<p>User is expected to call this method explicitly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "deepCopy",
    "code": "private void deepCopy(MavenProject project) {\n\n        file = project.file;\n        basedir = project.basedir;\n\n        if (project.getDependencyArtifacts() != null) {\n            setDependencyArtifacts(Collections.unmodifiableSet(project.getDependencyArtifacts()));\n        }\n\n        if (project.getArtifacts() != null) {\n            setArtifacts(Collections.unmodifiableSet(project.getArtifacts()));\n        }\n\n        if (project.getParentFile() != null) {\n            parentFile = new File(project.getParentFile().getAbsolutePath());\n        }\n\n        if (project.getPluginArtifacts() != null) {\n            setPluginArtifacts(Collections.unmodifiableSet(project.getPluginArtifacts()));\n        }\n\n        if (project.getReportArtifacts() != null) {\n            setReportArtifacts(Collections.unmodifiableSet(project.getReportArtifacts()));\n        }\n\n        if (project.getExtensionArtifacts() != null) {\n            setExtensionArtifacts(Collections.unmodifiableSet(project.getExtensionArtifacts()));\n        }\n\n        setParentArtifact((project.getParentArtifact()));\n\n        if (project.getRemoteArtifactRepositories() != null) {\n            setRemoteArtifactRepositories(Collections.unmodifiableList(project.getRemoteArtifactRepositories()));\n        }\n\n        if (project.getPluginArtifactRepositories() != null) {\n            setPluginArtifactRepositories(Collections.unmodifiableList(project.getPluginArtifactRepositories()));\n        }\n\n        if (project.getActiveProfiles() != null) {\n            setActiveProfiles((Collections.unmodifiableList(project.getActiveProfiles())));\n        }\n\n        if (project.getAttachedArtifacts() != null) {\n            setAttachedArtifacts(new ArrayList<>(project.getAttachedArtifacts()));\n        }\n\n        sources = new LinkedHashSet<>(project.sources);\n\n        if (project.getModel() != null) {\n            setModel(project.getModel().clone());\n        }\n\n        if (project.getOriginalModel() != null) {\n            setOriginalModel(project.getOriginalModel());\n        }\n\n        setExecutionRoot(project.isExecutionRoot());\n\n        if (project.getArtifact() != null) {\n            setArtifact(ArtifactUtils.copyArtifact(project.getArtifact()));\n        }\n\n        if (project.getManagedVersionMap() != null) {\n            setManagedVersionMap(project.getManagedVersionMap());\n        }\n\n        lifecyclePhases.addAll(project.lifecyclePhases);\n    }",
    "comment": "disown the parent\ncopy fields\ndon't need a deep copy, they don't get modified or added/removed to/from - but make them unmodifiable to be\nsure!\nclone properties modifiable by plugins in a forked lifecycle\nThis property is not handled like others as we don't use public API.\nThe whole implementation of this `deepCopy` method may need revision,\nbut it would be the topic for a separated commit."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/templateview/src/test/java/com/iluwatar/templateview/ContactPageViewTest.java",
    "type": "method",
    "name": "testRenderDynamicContent",
    "code": "void testRenderDynamicContent() {\n    ContactPageView contactPage = spy(ContactPageView.class);\n\n    contactPage.renderDynamicContent();\n\n    verify(contactPage).renderDynamicContent();\n  }",
    "comment": "Create a spy for ContactPageView\nRender dynamic content for ContactPageView\nVerify that the correct message is logged"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/layered-architecture/src/main/java/com/iluwatar/layers/app/LayersApp.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SpringApplication.run(LayersApp.class, args);\n  }",
    "comment": "The Layers pattern is a structural design pattern that organizes system architecture into\ndistinct layers, each with a specific responsibility and abstraction level. This separation\nallows for increased modularity, facilitating independent development, maintenance, and reuse of\neach layer. Commonly, layers interact with each other through well-defined interfaces, with\nhigher layers (more abstract) depending on lower layers (more concrete), but not vice versa,\npromoting a clear hierarchy and separation of concerns."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/CWD.java",
    "type": "method",
    "name": "create",
    "code": "public static CWD create(Path path) {\n        return new CWD(CliUtils.getCanonicalPath(path));\n    }",
    "comment": "Creates instance out of {@link Path}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "addPyFile",
    "code": "public T addPyFile(String file) {\n    checkNotNull(file, \"file\");\n    builder.pyFiles.add(file);\n    return self();\n  }",
    "comment": "Adds a python file / zip / egg to be submitted with the application.\n\n@param file Path to the file.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java",
    "type": "method",
    "name": "isAnnotated",
    "code": "public static boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn findAnnotation(element, annotationType).isPresent();\n\t}",
    "comment": "Determine if an annotation of {@code annotationType} is either\n<em>present</em> or <em>meta-present</em> on the supplied\n{@code element}.\n\n@param element the element on which to search for the annotation; may be\n{@code null}\n@param annotationType the annotation type to search for; never {@code null}\n@return {@code true} if the annotation is present or meta-present\n@see #findAnnotation(AnnotatedElement, Class)\n@see org.junit.platform.commons.support.AnnotationSupport#isAnnotated(AnnotatedElement, Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-class-loader/maven-it-plugin-class-loader/src/main/java/org/apache/maven/plugin/coreit/ExpressionUtil.java",
    "type": "method",
    "name": "evaluate",
    "code": "public static Map evaluate(String expression, Object context) {\n        Map values = Collections.EMPTY_MAP;\n\n        if (expression != null && expression.length() > 0) {\n            List segments = Arrays.asList(expression.split(\"/\", 0));\n            values = evaluate(\"\", segments, context);\n        }\n\n        return values;\n    }",
    "comment": "Evaluates the specified expression. Expressions are composed of segments which are separated by a forward slash\n('/'). Each segment specifies a (public) bean property of the current object and drives the evaluation further\ndown the object graph. For lists, arrays and maps segments can additionally specify the index/key of an element.\nThe initial segment denotes the root object and the parameter <code>contexts</code> is used to specify which root\nobjects are available. For instance, if <code>contexts</code> maps the token \"project\" to a Maven project\ninstance, the expression \"project/build/resources/0/directory\" specifies the first resource directory of the\nproject.\n\n@param expression The expression to evaluate, may be <code>null</code>.\n@param context    The object to start expression evaluation at, must not be <code>null</code>.\n@return The values of the evaluation, indexed by expression, or an empty map if the segments could not be\nevaluated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaGeneralizedLinearRegressionExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaGeneralizedLinearRegressionExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Load training data\n    Dataset<Row> dataset = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_linear_regression_data.txt\");\n\n    GeneralizedLinearRegression glr = new GeneralizedLinearRegression()\n      .setFamily(\"gaussian\")\n      .setLink(\"identity\")\n      .setMaxIter(10)\n      .setRegParam(0.3);\n\n    // Fit the model\n    GeneralizedLinearRegressionModel model = glr.fit(dataset);\n\n    // Print the coefficients and intercept for generalized linear regression model\n    System.out.println(\"Coefficients: \" + model.coefficients());\n    System.out.println(\"Intercept: \" + model.intercept());\n\n    // Summarize the model over the training set and print out some metrics\n    GeneralizedLinearRegressionTrainingSummary summary = model.summary();\n    System.out.println(\"Coefficient Standard Errors: \"\n      + Arrays.toString(summary.coefficientStandardErrors()));\n    System.out.println(\"T Values: \" + Arrays.toString(summary.tValues()));\n    System.out.println(\"P Values: \" + Arrays.toString(summary.pValues()));\n    System.out.println(\"Dispersion: \" + summary.dispersion());\n    System.out.println(\"Null Deviance: \" + summary.nullDeviance());\n    System.out.println(\"Residual Degree Of Freedom Null: \" + summary.residualDegreeOfFreedomNull());\n    System.out.println(\"Deviance: \" + summary.deviance());\n    System.out.println(\"Residual Degree Of Freedom: \" + summary.residualDegreeOfFreedom());\n    System.out.println(\"AIC: \" + summary.aic());\n    System.out.println(\"Deviance Residuals: \");\n    summary.residuals().show();\n    // $example off$\n\n    spark.stop();\n  }",
    "comment": "An example demonstrating generalized linear regression.\nRun with\n<pre>\nbin/run-example ml.JavaGeneralizedLinearRegressionExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/ByteArray.java",
    "type": "method",
    "name": "writeToMemory",
    "code": "public static void writeToMemory(byte[] src, Object target, long targetOffset) {\n    Platform.copyMemory(src, Platform.BYTE_ARRAY_OFFSET, target, targetOffset, src.length);\n  }",
    "comment": "Writes the content of a byte array into a memory address, identified by an object and an\noffset. The target memory address must already been allocated, and have enough space to\nhold all the bytes in this string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/resolver/conflict/FarthestConflictResolver.java",
    "type": "method",
    "name": "resolveConflict",
    "code": "public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2) {\n        return node1.getDepth() >= node2.getDepth() ? node1 : node2;\n    }",
    "comment": "Resolves conflicting artifacts by always selecting the <em>farthest</em> declaration. Farthest is defined as the\ndeclaration that has the most transitive steps away from the project being built.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/MavenSessionBuilderSupplier.java",
    "type": "method",
    "name": "MavenSessionBuilderSupplier",
    "code": "public MavenSessionBuilderSupplier(RepositorySystem repositorySystem) {\n        this.repositorySystem = requireNonNull(repositorySystem);\n        this.scopeManager = new ScopeManagerImpl(Maven4ScopeManagerConfiguration.INSTANCE);\n    }",
    "comment": "A simple {@link Supplier} of {@link SessionBuilder} instances, that on each call supplies newly\nconstructed instance. To create session out of builder, use {@link SessionBuilder#build()}. For proper closing\nof sessions, use {@link CloseableSession#close()} method on built instance(s).\n<p>\nExtend this class and override methods to customize, if needed.\n\n@since 4.0.0\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/graph/FilteredProjectDependencyGraph.java",
    "type": "method",
    "name": "getDownstreamProjects",
    "code": "public List<MavenProject> getDownstreamProjects(MavenProject project, boolean transitive) {\n        Key key = new Key(project, transitive, false);\n        List<MavenProject> list = cache.get(key);\n        if (list == null) {\n            list = applyFilter(projectDependencyGraph.getDownstreamProjects(project, transitive), transitive, false);\n            cache.put(key, list);\n        }\n        return list;\n    }",
    "comment": "Do not use computeIfAbsent here, as the computation is recursive\nand this is not supported by computeIfAbsent."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/model-view-presenter/src/main/java/com/iluwatar/model/view/presenter/FileLoader.java",
    "type": "method",
    "name": "fileExists",
    "code": "public boolean fileExists() {\n    return new File(this.fileName).exists();\n  }",
    "comment": "Returns true if the given file exists.\n\n@return True, if the file given exists, false otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "onDisconnected",
    "code": "new CameraDevice.StateCallback() {\n\n        @Override\n        public void onDisconnected(final CameraDevice cd) {\n          cameraOpenCloseLock.release();\n          cd.close();\n          cameraDevice = null;\n        }\n\n        @Override\n        public void onError(final CameraDevice cd, final int error) {\n          cameraOpenCloseLock.release();\n          cd.close();\n          cameraDevice = null;\n          final Activity activity = getActivity();\n          if (null != activity) {\n            activity.finish();\n          }\n        }\n      };",
    "comment": "{@link android.hardware.camera2.CameraDevice.StateCallback}\nis called when {@link CameraDevice} changes its state."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/LookupInvoker.java",
    "type": "method",
    "name": "invoke",
    "code": "public final int invoke(InvokerRequest invokerRequest) {\n        requireNonNull(invokerRequest);\n\n        Properties oldProps = new Properties();\n        oldProps.putAll(System.getProperties());\n        ClassLoader oldCL = Thread.currentThread().getContextClassLoader();\n        try (C context = createContext(invokerRequest)) {\n            if (contextConsumer != null) {\n                contextConsumer.accept(context);\n            }\n            try {\n                if (context.containerCapsule != null\n                        && context.containerCapsule.currentThreadClassLoader().isPresent()) {\n                    Thread.currentThread()\n                            .setContextClassLoader(context.containerCapsule\n                                    .currentThreadClassLoader()\n                                    .get());\n                }\n                return doInvoke(context);\n            } catch (InvokerException.ExitException e) {\n                throw e;\n            } catch (Exception e) {\n                throw handleException(context, e);\n            }\n        } finally {\n            Thread.currentThread().setContextClassLoader(oldCL);\n            System.setProperties(oldProps);\n        }\n    }",
    "comment": "contract of ExitException is that nothing needed by us\nother exceptions (including InvokerException but sans Exit, see above): we need to inform user"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactScopeEnum.java",
    "type": "method",
    "name": "checkScope",
    "code": "public static ArtifactScopeEnum checkScope(ArtifactScopeEnum scope) {\n        return scope == null ? DEFAULT_SCOPE : scope;\n    }",
    "comment": "Helper method to simplify null processing\n\n@param scope a scope or {@code null}\n@return the provided scope or DEFAULT_SCOPE"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(NestedClassSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link NestedClassSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/singleton/src/main/java/com/iluwatar/singleton/ThreadSafeLazyLoadedIvoryTower.java",
    "type": "method",
    "name": "getInstance",
    "code": "public static synchronized ThreadSafeLazyLoadedIvoryTower getInstance() {\n    if (instance == null) {\n      instance = new ThreadSafeLazyLoadedIvoryTower();\n    }\n    return instance;\n  }",
    "comment": "The instance doesn't get created until the method is called for the first time.\n\n@return an instance of the class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/MethodMap.java",
    "type": "method",
    "name": "isStrictMethodInvocationConvertible",
    "code": "private static boolean isStrictMethodInvocationConvertible(Class<?> formal, Class<?> actual) {\n        // we shouldn't get a null into, but if so\n        if (actual == null && !formal.isPrimitive()) {\n            return true;\n        }\n\n        // Check for identity or widening reference conversion\n        if (formal.isAssignableFrom(actual)) {\n            return true;\n        }\n\n        // Check for widening primitive conversion.\n        if (formal.isPrimitive()) {\n            if (formal == Short.TYPE && (actual == Byte.TYPE)) {\n                return true;\n            }\n            if (formal == Integer.TYPE && (actual == Short.TYPE || actual == Byte.TYPE)) {\n                return true;\n            }\n            if (formal == Long.TYPE && (actual == Integer.TYPE || actual == Short.TYPE || actual == Byte.TYPE)) {\n                return true;\n            }\n            if (formal == Float.TYPE\n                    && (actual == Long.TYPE || actual == Integer.TYPE || actual == Short.TYPE || actual == Byte.TYPE)) {\n                return true;\n            }\n            if (formal == Double.TYPE\n                    && (actual == Float.TYPE\n                            || actual == Long.TYPE\n                            || actual == Integer.TYPE\n                            || actual == Short.TYPE\n                            || actual == Byte.TYPE)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "comment": "Determines whether a type represented by a class object is\nconvertible to another type represented by a class object using a\nmethod invocation conversion, without matching object and primitive\ntypes. This method is used to determine the more specific type when\ncomparing signatures of methods.\n\n@param formal the formal parameter type to which the actual\nparameter type should be convertible\n@param actual the actual parameter type.\n@return true if either formal type is assignable from actual type,\nor formal and actual are both primitive types and actual can be\nsubject to widening conversion to formal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "appendLowercaseCodePoint",
    "code": "private static void appendLowercaseCodePoint(final int codePoint, final StringBuilder sb) {\n    int lowercaseCodePoint = getLowercaseCodePoint(codePoint);\n    if (lowercaseCodePoint == COMBINED_ASCII_SMALL_I_COMBINING_DOT) {\n      // Latin capital letter I with dot above is mapped to 2 lowercase characters.\n      sb.appendCodePoint(SpecialCodePointConstants.ASCII_SMALL_I);\n      sb.appendCodePoint(SpecialCodePointConstants.COMBINING_DOT);\n    } else {\n      // All other characters should follow context-unaware ICU single-code point case mapping.\n      sb.appendCodePoint(lowercaseCodePoint);\n    }\n  }",
    "comment": "Converts a single code point to lowercase using ICU rules, with special handling for\none-to-many case mappings (i.e. characters that map to multiple characters in lowercase) and\ncontext-insensitive case mappings (i.e. characters that map to different characters based on\nstring context - e.g. the position in the string relative to other characters).\n\n@param codePoint The code point to convert to lowercase.\n@param sb The StringBuilder to append the lowercase character to."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/master-worker/src/main/java/com/iluwatar/masterworker/system/systemmaster/Master.java",
    "type": "method",
    "name": "divideWork",
    "code": "private void divideWork(Input<?> input) {\n    var dividedInput = input.divideData(numOfWorkers);\n    if (dividedInput != null) {\n      this.expectedNumResults = dividedInput.size();\n      for (var i = 0; i < this.expectedNumResults; i++) {\n        this.workers.get(i).setReceivedData(this, dividedInput.get(i));\n        this.workers.get(i).start();\n      }\n      for (var i = 0; i < this.expectedNumResults; i++) {\n        try {\n          this.workers.get(i).join();\n        } catch (InterruptedException e) {\n          System.err.println(\"Error while executing thread\");\n        }\n      }\n    }\n  }",
    "comment": "ith division given to ith worker in this.workers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "trimAll",
    "code": "public UTF8String trimAll() {\n    int s = 0;\n    // skip all of the whitespaces in the left side\n    while (s < this.numBytes && isWhitespaceOrISOControl(getByte(s))) s++;\n    if (s == this.numBytes) {\n      // Everything trimmed\n      return EMPTY_UTF8;\n    }\n    // skip all of the whitespaces in the right side\n    int e = this.numBytes - 1;\n    while (e > s && isWhitespaceOrISOControl(getByte(e))) e--;\n    if (s == 0 && e == numBytes - 1) {\n      // Nothing trimmed\n      return this;\n    }\n    return copyUTF8String(s, e);\n  }",
    "comment": "Trims whitespace ASCII characters from both ends of this string.\n\nNote that, this method is different from {@link UTF8String#trim()} which removes\nonly spaces(= ASCII 32) from both ends.\n\n@return A UTF8String whose value is this UTF8String, with any leading and trailing white\nspace removed, or this UTF8String if it has no leading or trailing whitespace."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/client/TransportResponseHandler.java",
    "type": "method",
    "name": "failOutstandingRequests",
    "code": "private void failOutstandingRequests(Throwable cause) {\n    for (Map.Entry<StreamChunkId, ChunkReceivedCallback> entry : outstandingFetches.entrySet()) {\n      try {\n        entry.getValue().onFailure(entry.getKey().chunkIndex(), cause);\n      } catch (Exception e) {\n        logger.warn(\"ChunkReceivedCallback.onFailure throws exception\", e);\n      }\n    }\n    for (BaseResponseCallback callback : outstandingRpcs.values()) {\n      try {\n        callback.onFailure(cause);\n      } catch (Exception e) {\n        logger.warn(\"RpcResponseCallback.onFailure throws exception\", e);\n      }\n    }\n    for (Pair<String, StreamCallback> entry : streamCallbacks) {\n      try {\n        entry.getValue().onFailure(entry.getKey(), cause);\n      } catch (Exception e) {\n        logger.warn(\"StreamCallback.onFailure throws exception\", e);\n      }\n    }\n\n    // It's OK if new fetches appear, as they will fail immediately.\n    outstandingFetches.clear();\n    outstandingRpcs.clear();\n    streamCallbacks.clear();\n  }",
    "comment": "Fire the failure callback for all outstanding requests. This is called when we have an\nuncaught exception or pre-mature connection termination."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Character unexpected, char actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Character) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "MavenProject",
    "code": "public MavenProject() {\n        Model model = new Model();\n\n        model.setGroupId(EMPTY_PROJECT_GROUP_ID);\n        model.setArtifactId(EMPTY_PROJECT_ARTIFACT_ID);\n        model.setVersion(EMPTY_PROJECT_VERSION);\n\n        setModel(model);\n    }",
    "comment": "All sources of this project, in the order they were added."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/DefaultParallelExecutionConfigurationStrategy.java",
    "type": "method",
    "name": "getStrategy",
    "code": "static ParallelExecutionConfigurationStrategy getStrategy(ConfigurationParameters configurationParameters) {\n\t\treturn valueOf(\n\t\t\tconfigurationParameters.get(CONFIG_STRATEGY_PROPERTY_NAME).orElse(\"dynamic\").toUpperCase(Locale.ROOT));\n\t}",
    "comment": "Property name used to specify the fully qualified class name of the\n{@link ParallelExecutionConfigurationStrategy} to be used by the\n{@link #CUSTOM} configuration strategy.\n\n@see #CUSTOM"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestPlan.java",
    "type": "method",
    "name": "addInternal",
    "code": "public void addInternal(TestIdentifier testIdentifier) {\n\t\tPreconditions.notNull(testIdentifier, \"testIdentifier must not be null\");\n\t\tallIdentifiers.put(testIdentifier.getUniqueIdObject(), testIdentifier);\n\n\t\tif (!testIdentifier.getParentIdObject().isPresent()) {\n\t\t\troots.add(testIdentifier);\n\t\t\treturn;\n\t\t}\n\n\t\tUniqueId parentId = testIdentifier.getParentIdObject().get();\n\t\tif (!allIdentifiers.containsKey(parentId)) {\n\t\t\troots.add(testIdentifier);\n\t\t\treturn;\n\t\t}\n\n\t\tSet<TestIdentifier> directChildren = children.computeIfAbsent(parentId,\n\t\t\tkey -> synchronizedSet(new LinkedHashSet<>(16)));\n\t\tdirectChildren.add(testIdentifier);\n\t}",
    "comment": "Root identifiers. Typically, a test engine.\nIdentifiers without a parent in this test plan. Could be a test\nengine that is used in a suite."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/Trigger.java",
    "type": "method",
    "name": "ProcessingTime",
    "code": "public static Trigger ProcessingTime(Duration interval) {\n      return ProcessingTimeTrigger.apply(interval);\n  }",
    "comment": "(Scala-friendly)\nA trigger policy that runs a query periodically based on an interval in processing time.\nIf `duration` is 0, the query will run as fast as possible.\n\n{{{\nimport scala.concurrent.duration._\ndf.writeStream.trigger(Trigger.ProcessingTime(10.seconds))\n}}}\n@since 2.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/testkit/engine/TestExecutionResultConditionsTests.java",
    "type": "method",
    "name": "rootCauseFailsForNullThrowable",
    "code": "void rootCauseFailsForNullThrowable() {\n\t\tassertThatExceptionOfType(PreconditionViolationException.class)//\n\t\t\t\t.isThrownBy(() -> rootCauseCondition.matches(null))//\n\t\t\t\t.withMessage(\"Throwable must not be null\");\n\t}",
    "comment": "Tests for {@link TestExecutionResultConditions}.\n\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "saslServerAlwaysEncrypt",
    "code": "public boolean saslServerAlwaysEncrypt() {\n    return conf.getBoolean(\"spark.network.sasl.serverAlwaysEncrypt\", false);\n  }",
    "comment": "Whether the server should enforce encryption on SASL-authenticated connections."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaBisectingKMeansExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaBisectingKMeansExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Loads data.\n    Dataset<Row> dataset = spark.read().format(\"libsvm\").load(\"data/mllib/sample_kmeans_data.txt\");\n\n    // Trains a bisecting k-means model.\n    BisectingKMeans bkm = new BisectingKMeans().setK(2).setSeed(1);\n    BisectingKMeansModel model = bkm.fit(dataset);\n\n    // Make predictions\n    Dataset<Row> predictions = model.transform(dataset);\n\n    // Evaluate clustering by computing Silhouette score\n    ClusteringEvaluator evaluator = new ClusteringEvaluator();\n\n    double silhouette = evaluator.evaluate(predictions);\n    System.out.println(\"Silhouette with squared euclidean distance = \" + silhouette);\n\n    // Shows the result.\n    System.out.println(\"Cluster Centers: \");\n    Vector[] centers = model.clusterCenters();\n    for (Vector center : centers) {\n      System.out.println(center);\n    }\n    // $example off$\n\n    spark.stop();\n  }",
    "comment": "An example demonstrating bisecting k-means clustering.\nRun with\n<pre>\nbin/run-example ml.JavaBisectingKMeansExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/TransportContext.java",
    "type": "method",
    "name": "createClientFactory",
    "code": "public TransportClientFactory createClientFactory(List<TransportClientBootstrap> bootstraps) {\n    return new TransportClientFactory(this, bootstraps);\n  }",
    "comment": "Initializes a ClientFactory which runs the given TransportClientBootstraps prior to returning\na new Client. Bootstraps will be executed synchronously, and must run successfully in order\nto create a Client."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClasspathResourceSource.java",
    "type": "method",
    "name": "from",
    "code": "public static ClasspathResourceSource from(URI uri) {\n\t\tPreconditions.notNull(uri, \"URI must not be null\");\n\t\tPreconditions.condition(CLASSPATH_SCHEME.equals(uri.getScheme()),\n\t\t\t() -> \"URI [\" + uri + \"] must have [\" + CLASSPATH_SCHEME + \"] scheme\");\n\n\t\tString classpathResource = ResourceUtils.stripQueryComponent(uri).getPath();\n\t\tFilePosition filePosition = FilePosition.fromQuery(uri.getQuery()).orElse(null);\n\t\treturn ClasspathResourceSource.from(classpathResource, filePosition);\n\t}",
    "comment": "Create a new {@code ClasspathResourceSource} from the supplied {@link URI}.\nthe query) will be used as the classpath resource name. The\n{@linkplain URI#getQuery() query} component of the {@code URI}, if present,\nwill be used to retrieve the {@link FilePosition} via\n{@link FilePosition#fromQuery(String)}.\n\n@param uri the {@code URI} for the classpath resource; never {@code null}\n@return a new {@code ClasspathResourceSource}; never {@code null}\n{@code null} or if the scheme of the supplied {@code URI} is not equal\nto the {@link #CLASSPATH_SCHEME}\n@since 1.3\n@see #CLASSPATH_SCHEME"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(DirectorySelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link DirectorySelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/sqlite/java/com/example/android/persistence/migrations/User.java",
    "type": "method",
    "name": "User",
    "code": "public User(String userName) {\n        // DO NOT USE Integer Random values for primary keys.\n        // This is using an Integer to showcase a WRONG implementation that has to be fixed\n        // afterwards by updating the schema.\n        // The ID is updated to a UUID String in the room3 flavor.\n        mId = new Random(Integer.MAX_VALUE).nextInt();\n        mUserName = userName;\n    }",
    "comment": "Model for a user that is saved in the SQLite database and used in the UI."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedDeltaByteArrayReader.java",
    "type": "method",
    "name": "readValues",
    "code": "private void readValues(int total, WritableColumnVector c, int rowId) {\n    for (int i = 0; i < total; i++) {\n      int prefixLength = prefixLengthVector.getInt(currentRow);\n      ByteBuffer suffix = suffixReader.getBytes(currentRow);\n      byte[] suffixArray = suffix.array();\n      int suffixLength = suffix.limit() - suffix.position();\n      int length = prefixLength + suffixLength;\n\n      WritableColumnVector arrayData = c.arrayData();\n      int offset = arrayData.getElementsAppended();\n      if (prefixLength != 0) {\n        arrayData.appendBytes(prefixLength, previous.array(), previous.position());\n      }\n      arrayData.appendBytes(suffixLength, suffixArray, suffix.position());\n      c.putArray(rowId + i, offset, length);\n      previous = arrayData.getByteBuffer(offset, length);\n      currentRow++;\n    }\n  }",
    "comment": "NOTE: due to PARQUET-246, it is important that we\nrespect prefixLength which was read from prefixLengthReader,\neven for the *first* value of a page. Even though the first\nvalue of the page should have an empty prefix, it may not\nbecause of PARQUET-246.\nWe have to do this to materialize the output"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassUtils.java",
    "type": "method",
    "name": "nullSafeToString",
    "code": "public static String nullSafeToString(Class<?> clazz) {\n\t\treturn clazz == null ? \"null\" : clazz.getName();\n\t}",
    "comment": "Get the fully qualified name of the supplied class.\n\n<p>This is a null-safe variant of {@link Class#getName()}.\n\n@param clazz the class whose name should be retrieved, potentially\n{@code null}\n@return the fully qualified class name or {@code \"null\"} if the supplied\nclass reference is {@code null}\n@since 1.3\n@see #nullSafeToString(Class...)\n@see StringUtils#nullSafeToString(Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/CyclicDependencyException.java",
    "type": "method",
    "name": "CyclicDependencyException",
    "code": "public CyclicDependencyException(String message, Artifact artifact) {\n        super(message, artifact);\n        this.artifact = artifact;\n    }",
    "comment": "Indicates a cycle in the dependency graph."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/CaseInsensitiveStringMap.java",
    "type": "method",
    "name": "getInt",
    "code": "public int getInt(String key, int defaultValue) {\n    String value = get(key);\n    return value == null ? defaultValue : Integer.parseInt(value);\n  }",
    "comment": "Returns the integer value to which the specified key is mapped,\nor defaultValue if there is no mapping for the key. The key match is case-insensitive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "getChildren",
    "code": "public ArrayList<Description> getChildren() {\n        return new ArrayList<Description>(fChildren);\n    }",
    "comment": "Gets the copy of the children of this {@code Description}.\nReturns an empty list if there are no children."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java",
    "type": "method",
    "name": "compareTo",
    "code": "public int compareTo(Item item) {\n            if (item == null) {\n                if (size() == 0) {\n                    return 0; // 1-0 = 1- (normalize) = 1\n                }\n                for (Item i : this) {\n                    int result = i.compareTo(null);\n                    if (result != 0) {\n                        return result;\n                    }\n                }\n                return 0;\n            }\n            switch (item.getType()) {\n                case INT_ITEM:\n                case LONG_ITEM:\n                case BIGINTEGER_ITEM:\n                    return -1; // 1-1 < 1.0.x\n\n                case STRING_ITEM:\n                    return 1;\n                case COMBINATION_ITEM:\n                    return 1; // 1-1 > 1-sp\n\n                case LIST_ITEM:\n                    Iterator<Item> left = iterator();\n                    Iterator<Item> right = ((ListItem) item).iterator();\n\n                    while (left.hasNext() || right.hasNext()) {\n                        Item l = left.hasNext() ? left.next() : null;\n                        Item r = right.hasNext() ? right.next() : null;\n\n                        int result = l == null ? (r == null ? 0 : -1 * r.compareTo(l)) : l.compareTo(r);\n\n                        if (result != 0) {\n                            return result;\n                        }\n                    }\n\n                    return 0;\n\n                default:\n                    throw new IllegalStateException(\"invalid item: \" + item.getClass());\n            }\n        }",
    "comment": "Compare the entire list of items with null - not just the first one, MNG-6964\nif this is shorter, then invert the compare and mul with -1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicContainer.java",
    "type": "method",
    "name": "dynamicContainer",
    "code": "public static DynamicContainer dynamicContainer(String displayName, Iterable<? extends DynamicNode> dynamicNodes) {\n\t\treturn dynamicContainer(displayName, null, StreamSupport.stream(dynamicNodes.spliterator(), false));\n\t}",
    "comment": "Factory for creating a new {@code DynamicContainer} for the supplied display\n\n@param displayName the display name for the dynamic container; never\n{@code null} or blank\n@param dynamicNodes collection of dynamic nodes to execute;\nnever {@code null}\n@see #dynamicContainer(String, Stream)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/model/DefaultModelBuilderTest.java",
    "type": "method",
    "name": "getPom",
    "code": "private Path getPom(String name) {\n        return Paths.get(\"src/test/resources/poms/factory/\" + name + \".xml\").toAbsolutePath();\n    }",
    "comment": "this is here only to trigger mainSession creation; unrelated\nbefore merge\nafter merge"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroOptionalPrimitives.java",
    "type": "method",
    "name": "setMaybeBinaryColumn",
    "code": "public void setMaybeBinaryColumn(java.nio.ByteBuffer value) {\n    this.maybe_binary_column = value;\n  }",
    "comment": "Sets the value of the 'maybe_binary_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RetryingBlockTransferor.java",
    "type": "method",
    "name": "handleBlockTransferFailure",
    "code": "private void handleBlockTransferFailure(String blockId, Throwable exception) {\n      boolean shouldForwardFailure = false;\n      synchronized (RetryingBlockTransferor.this) {\n        if (this == currentListener && outstandingBlocksIds.contains(blockId)) {\n          if (shouldRetry(exception)) {\n            if (!initiateRetry(exception)) {\n              outstandingBlocksIds.remove(blockId);\n              shouldForwardFailure = true;\n            }\n          } else {\n            if (errorHandler.shouldLogError(exception)) {\n              logger.error(\"Failed to {} block {}, and will not retry ({} retries)\", exception,\n                MDC.of(LogKeys.TRANSFER_TYPE$.MODULE$, listener.getTransferType()),\n                MDC.of(LogKeys.BLOCK_ID$.MODULE$, blockId),\n                MDC.of(LogKeys.NUM_RETRY$.MODULE$,retryCount));\n            } else {\n              logger.debug(\n                String.format(\"Failed to %s block %s, and will not retry (%s retries)\",\n                  listener.getTransferType(), blockId, retryCount), exception);\n            }\n            outstandingBlocksIds.remove(blockId);\n            shouldForwardFailure = true;\n          }\n        }\n      }\n\n      if (shouldForwardFailure) {\n        listener.onBlockTransferFailure(blockId, exception);\n      }\n    }",
    "comment": "We will only forward this failure to our parent listener if this block request is\noutstanding, we are still the active listener, AND we cannot retry the transfer.\nfailed to initiate a retry, so fail this block\nNow actually invoke the parent listener, outside of the synchronized block."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/SimpleLoggerConfiguration.java",
    "type": "method",
    "name": "getStringProperty",
    "code": "String getStringProperty(String name) {\n        String prop = null;\n        try {\n            prop = System.getProperty(name);\n            if (prop == null && name.startsWith(Constants.MAVEN_LOGGER_PREFIX)) {\n                String legacyName = name.replace(Constants.MAVEN_LOGGER_PREFIX, MavenBaseLogger.LEGACY_PREFIX);\n                prop = System.getProperty(legacyName);\n                if (prop != null) {\n                    Reporter.warn(\"Using deprecated property \" + legacyName + \". Please migrate to \" + name);\n                }\n            }\n        } catch (SecurityException e) {\n        }\n\n        if (prop == null) {\n            prop = properties.getProperty(name);\n            if (prop == null && name.startsWith(Constants.MAVEN_LOGGER_PREFIX)) {\n                String legacyName = name.replace(Constants.MAVEN_LOGGER_PREFIX, MavenBaseLogger.LEGACY_PREFIX);\n                prop = properties.getProperty(legacyName);\n                if (prop != null) {\n                    Reporter.warn(\"Using deprecated property \" + legacyName + \". Please migrate to \" + name);\n                }\n            }\n        }\n        return prop;\n    }",
    "comment": "Try maven property first\nTry legacy property\nIgnore\nTry legacy property from properties file"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/BlockStoreClient.java",
    "type": "method",
    "name": "shuffleMetrics",
    "code": "public MetricSet shuffleMetrics() {\n    // Return an empty MetricSet by default.\n    return () -> Collections.emptyMap();\n  }",
    "comment": "Get the shuffle MetricsSet from BlockStoreClient, this will be used in MetricsSystem to\nget the Shuffle related metrics."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/ClingSupport.java",
    "type": "method",
    "name": "ClingSupport",
    "code": "public ClingSupport() {\n        this(new ClassWorld(CORE_CLASS_REALM_ID, Thread.currentThread().getContextClassLoader()), true);\n    }",
    "comment": "Ctor that creates \"managed\" ClassWorld. This constructor is not used in \"normal\" circumstances."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/repository/DefaultRepositoryRequest.java",
    "type": "method",
    "name": "DefaultRepositoryRequest",
    "code": "public DefaultRepositoryRequest(RepositoryRequest repositoryRequest) {\n        setLocalRepository(repositoryRequest.getLocalRepository());\n        setRemoteRepositories(repositoryRequest.getRemoteRepositories());\n        setOffline(repositoryRequest.isOffline());\n        setForceUpdate(repositoryRequest.isForceUpdate());\n    }",
    "comment": "Creates a shallow copy of the specified repository request.\n\n@param repositoryRequest The repository request to copy from, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Float> create(long[] shape, FloatBuffer data) {\n    Tensor<Float> t = allocateForBuffer(DataType.FLOAT, shape, data.remaining());\n    t.buffer().asFloatBuffer().put(data);\n    return t;\n  }",
    "comment": "Create a {@link Float} Tensor with data from the given buffer.\n\n<p>Creates a Tensor with the given shape by copying elements from the buffer (starting from its\ncurrent position) into the tensor. For example, if {@code shape = {2,3} } (which represents a\n2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/special-case/src/main/java/com/iluwatar/specialcase/Db.java",
    "type": "method",
    "name": "findAccountByUser",
    "code": "public Account findAccountByUser(User user) {\n    if (!user2Account.containsKey(user)) {\n      return null;\n    }\n    return user2Account.get(user);\n  }",
    "comment": "Find an account of the user.\n\n@param user in Db\n@return instance of Account of the user"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/TestClass.java",
    "type": "method",
    "name": "TestClass",
    "code": "public TestClass(Class<?> klass) {\n        this.klass = klass;\n    }",
    "comment": "@deprecated Included for backwards compatibility with JUnit 4.4. Will be\nremoved in the next major release. Please use\n{@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/double-checked-locking/src/test/java/com/iluwatar/doublechecked/locking/InventoryTest.java",
    "type": "method",
    "name": "testAddItem",
    "code": "void testAddItem() {\n    assertTimeout(\n        ofMillis(10000),\n        () -> {\n          // Create a new inventory with a limit of 1000 items and put some load on the add method\n          final var inventory = new Inventory(INVENTORY_SIZE);\n          final var executorService = Executors.newFixedThreadPool(THREAD_COUNT);\n          IntStream.range(0, THREAD_COUNT)\n              .<Runnable>mapToObj(\n                  i ->\n                      () -> {\n                        while (inventory.addItem(new Item()))\n                          ;\n                      })\n              .forEach(executorService::execute);\n\n          // Wait until all threads have finished\n          executorService.shutdown();\n          executorService.awaitTermination(5, TimeUnit.SECONDS);\n\n          // Check the number of items in the inventory. It should not have exceeded the allowed\n          // maximum\n          final var items = inventory.getItems();\n          assertNotNull(items);\n          assertEquals(INVENTORY_SIZE, items.size());\n\n          assertEquals(INVENTORY_SIZE, appender.getLogSize());\n\n          // ... and check if the inventory size is increasing continuously\n          IntStream.range(0, items.size())\n              .mapToObj(\n                  i ->\n                      appender.log.get(i).getFormattedMessage().contains(\"items.size()=\" + (i + 1)))\n              .forEach(Assertions::assertTrue);\n        });\n  }",
    "comment": "Concurrently add multiple items to the inventory, and check if the items were added in order by\nchecking the stdOut for continuous growth of the inventory. When 'items.size()=xx' shows up out\nof order, it means that the locking is not ok, increasing the risk of going over the inventory\nitem limit."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "cursorRight",
    "code": "public Ansi cursorRight(final int x) {\n        return x > 0 ? appendEscapeSequence('C', x) : x < 0 ? cursorLeft(-x) : this;\n    }",
    "comment": "Moves the cursor right. If the parameter x is negative it moves the cursor left.\n\n@param x the number of characters to move right\n@return this Ansi instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/AutoCloseDemo.java",
    "type": "method",
    "name": "getProductList",
    "code": "void getProductList() {\n\t\tassertEquals(200, webClient.get(serverUrl + \"/products\").getResponseStatus());\n\t}",
    "comment": "tag::user_guide_example[]\nend::user_guide_example[]\ntag::user_guide_example[]\nUse WebClient to connect to web server and verify response"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-yarn/src/main/java/org/apache/spark/network/yarn/YarnShuffleService.java",
    "type": "method",
    "name": "setRecoveryPath",
    "code": "public void setRecoveryPath(Path recoveryPath) {\n    _recoveryPath = recoveryPath;\n  }",
    "comment": "Set the recovery path for shuffle service recovery when NM is restarted. This will be call\nby NM if NM recovery is enabled."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/BufferedRowIterator.java",
    "type": "method",
    "name": "durationMs",
    "code": "public long durationMs() {\n    return (System.nanoTime() - startTimeNs) / (1000 * 1000);\n  }",
    "comment": "Returns the elapsed time since this object is created. This object represents a pipeline so\nthis is a measure of how long the pipeline has been running."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelBuilder.java",
    "type": "method",
    "name": "addEdge",
    "code": "private boolean addEdge(Path from, Path p) {\n            try {\n                dag.addEdge(from.toString(), p.toString());\n                return false;\n            } catch (Graph.CycleDetectedException e) {\n                add(Severity.FATAL, Version.BASE, \"Cycle detected between models at \" + from + \" and \" + p, null, e);\n                return true;\n            }\n        }",
    "comment": "Returns false if the edge was added, true if it caused a cycle."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SaslServerBootstrap.java",
    "type": "method",
    "name": "SaslServerBootstrap",
    "code": "public SaslServerBootstrap(TransportConf conf, SecretKeyHolder secretKeyHolder) {\n    this.conf = conf;\n    this.secretKeyHolder = secretKeyHolder;\n  }",
    "comment": "A bootstrap which is executed on a TransportServer's client channel once a client connects\nto the server. This allows customizing the client channel to allow for things such as SASL\nauthentication."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/DefaultMirrorSelector.java",
    "type": "method",
    "name": "isExternalRepo",
    "code": "static boolean isExternalRepo(ArtifactRepository originalRepository) {\n        try {\n            URL url = new URL(originalRepository.getUrl());\n            return !(isLocal(url.getHost()) || url.getProtocol().equals(\"file\"));\n        } catch (MalformedURLException e) {\n            // bad url just skip it here. It should have been validated already, but the wagon lookup will deal with it\n            return false;\n        }\n    }",
    "comment": "Checks the URL to see if this repository refers to an external repository\n\n@param originalRepository\n@return true if external."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<String> create(byte[][] data) {\n    return Tensor.create(data, String.class);\n  }",
    "comment": "Creates a rank-1 tensor of {@code byte} elements.\n\n@param data An array containing the data to put into the new tensor. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethodTests.java",
    "type": "method",
    "name": "publicTestMethod",
    "code": "void publicTestMethod() {\n\t\tMethod method = method(\"publicTestMethod\");\n\t\t// Ensure that somebody doesn't accidentally delete the public modifier again.\n\t\tassertTrue(ModifierSupport.isPublic(method));\n\t\tassertThat(isTestMethod).accepts(method);\n\t}",
    "comment": "Unit tests for {@link IsTestMethod}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, double actual, double delta) {\n        Assert.assertEquals(expected, actual, delta);\n    }",
    "comment": "Asserts that two doubles are equal concerning a delta. If the expected\nvalue is infinity then the delta value is ignored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/toolchain/RequirementMatcherFactoryTest.java",
    "type": "method",
    "name": "testCreateExactMatcher",
    "code": "void testCreateExactMatcher() {\n        RequirementMatcher matcher;\n        matcher = RequirementMatcherFactory.createExactMatcher(\"foo\");\n        assertFalse(matcher.matches(\"bar\"));\n        assertFalse(matcher.matches(\"foobar\"));\n        assertFalse(matcher.matches(\"foob\"));\n        assertTrue(matcher.matches(\"foo\"));\n    }",
    "comment": "Test of createExactMatcher method, of class RequirementMatcherFactory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/ClassicTableTypeMapping.java",
    "type": "method",
    "name": "ClassicTableTypeMapping",
    "code": "public ClassicTableTypeMapping() {\n    hiveToClientMap.put(TableType.MANAGED_TABLE.name(), ClassicTableTypes.TABLE.name());\n    hiveToClientMap.put(TableType.EXTERNAL_TABLE.name(), ClassicTableTypes.TABLE.name());\n    hiveToClientMap.put(TableType.VIRTUAL_VIEW.name(), ClassicTableTypes.VIEW.name());\n    hiveToClientMap.put(TableType.MATERIALIZED_VIEW.toString(),\n            ClassicTableTypes.MATERIALIZED_VIEW.toString());\n\n    clientToHiveMap.putAll(ClassicTableTypes.TABLE.name(), Arrays.asList(\n        TableType.MANAGED_TABLE.name(), TableType.EXTERNAL_TABLE.name()));\n    clientToHiveMap.put(ClassicTableTypes.VIEW.name(), TableType.VIRTUAL_VIEW.name());\n    clientToHiveMap.put(ClassicTableTypes.MATERIALIZED_VIEW.toString(),\n            TableType.MATERIALIZED_VIEW.toString());\n  }",
    "comment": "ClassicTableTypeMapping.\nClassic table type mapping :\nManaged Table to Table\nExternal Table to Table\nVirtual View to View"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-class-loader/maven-it-plugin-class-loader/src/main/java/org/apache/maven/plugin/coreit/ExpressionUtil.java",
    "type": "method",
    "name": "evaluate",
    "code": "private static Map evaluate(String prefix, List segments, Object context) {\n        Map values = Collections.EMPTY_MAP;\n\n        if (segments.isEmpty()) {\n            values = Collections.singletonMap(prefix, context);\n        } else if (context != null) {\n            Map targets = Collections.EMPTY_MAP;\n            String segment = (String) segments.get(0);\n            if (context.getClass().isArray() && Character.isDigit(segment.charAt(0))) {\n                try {\n                    int index = Integer.parseInt(segment);\n                    targets = Collections.singletonMap(segment, Array.get(context, index));\n                } catch (RuntimeException e) {\n                    // invalid index, just ignore\n                }\n            } else if ((context instanceof List) && Character.isDigit(segment.charAt(0))) {\n                try {\n                    int index = Integer.parseInt(segment);\n                    targets = Collections.singletonMap(segment, ((List) context).get(index));\n                } catch (RuntimeException e) {\n                    // invalid index, just ignore\n                }\n            } else if ((context instanceof Collection) && \"*\".equals(segment)) {\n                targets = new LinkedHashMap();\n                int index = 0;\n                for (Iterator it = ((Collection) context).iterator(); it.hasNext(); index++) {\n                    targets.put(Integer.toString(index), it.next());\n                }\n            } else if (context.getClass().isArray() && \"*\".equals(segment)) {\n                targets = new LinkedHashMap();\n                for (int index = 0, n = Array.getLength(context); index < n; index++) {\n                    targets.put(Integer.toString(index), Array.get(context, index));\n                }\n            } else {\n                targets = Collections.singletonMap(segment, getProperty(context, segment));\n            }\n\n            values = new LinkedHashMap();\n            for (Object key : targets.keySet()) {\n                Object target = targets.get(key);\n                values.putAll(\n                        evaluate(concat(prefix, String.valueOf(key)), segments.subList(1, segments.size()), target));\n            }\n        }\n\n        return values;\n    }",
    "comment": "Evaluates the given expression segments against the specified object.\n\n@param prefix   The expression prefix that led to the current context, must not be <code>null</code>.\n@param segments The expression segments to evaluate, must not be <code>null</code>.\n@param context  The object to evaluate the segments against, may be <code>null</code>.\n@return The values of the evaluation, indexed by expression, or an empty map if the segments could not be\nevaluated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/AnnotatedElementContext.java",
    "type": "method",
    "name": "isAnnotated",
    "code": "default boolean isAnnotated(Class<? extends Annotation> annotationType) {\n\t\treturn AnnotationSupport.isAnnotated(getAnnotatedElement(), annotationType);\n\t}",
    "comment": "Determine if an annotation of {@code annotationType} is either\n<em>present</em> or <em>meta-present</em> on the {@link AnnotatedElement} for\nthis context.\n\n<p><strong>Note:</strong> This method does not find repeatable annotations.\nTo check for repeatable annotations, use {@link #findRepeatableAnnotations(Class)}\nand verify that the returned list is not empty.\n\n<h4>WARNING</h4>\n<p>Favor the use of this method over directly invoking\n{@link AnnotatedElement#isAnnotationPresent(Class)} due to a bug in {@code javac}\non JDK versions prior to JDK 9.\n\n@param annotationType the annotation type to search for; never {@code null}\n@return {@code true} if the annotation is present or meta-present\n@see #findAnnotation(Class)\n@see #findRepeatableAnnotations(Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/special-case/src/main/java/com/iluwatar/specialcase/Db.java",
    "type": "method",
    "name": "seedItem",
    "code": "public void seedItem(String itemName, Double price) {\n    Product item = new Product(price);\n    itemName2Product.put(itemName, item);\n  }",
    "comment": "Seed an item into Db.\n\n@param itemName of the item\n@param price of the item"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/VehicleDatabase.java",
    "type": "method",
    "name": "saveVehicle",
    "code": "public void saveVehicle(Vehicle vehicle) {\n    vehicleTable.put(vehicle.getId(), vehicle);\n    if (vehicle instanceof Car) {\n      carTable.put(vehicle.getId(), (Car) vehicle);\n    } else if (vehicle instanceof Truck) {\n      truckTable.put(vehicle.getId(), (Truck) vehicle);\n    }\n  }",
    "comment": "Saves a vehicle to the database. If the vehicle is a Car or Truck, it is added to the\nrespective table.\n\n@param vehicle the vehicle to save"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/CommandBuilderUtils.java",
    "type": "method",
    "name": "javaMajorVersion",
    "code": "static int javaMajorVersion(String javaVersion) {\n    String[] version = javaVersion.split(\"[+.\\\\-]+\");\n    int major = Integer.parseInt(version[0]);\n    // if major > 1, we're using the JEP-223 version string, e.g., 9-ea, 9+120\n    // otherwise the second number is the major version\n    if (major > 1) {\n      return major;\n    } else {\n      return Integer.parseInt(version[1]);\n    }\n  }",
    "comment": "Get the major version of the java version string supplied. This method\naccepts any JEP-223-compliant strings (9-ea, 9+100), as well as legacy\nversion strings such as 1.7.0_79"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "setMaxNumberOfDelegatedPartitions",
    "code": "public Options setMaxNumberOfDelegatedPartitions(int limit) {\n      this.maxDelegatedPartitions = limit;\n      return this;\n    }",
    "comment": "Sets the maximum number of graph partitions that the delegate will try to delegate. If more\npartitions could be delegated than the limit, the ones with the larger number of nodes will\nbe chosen. If unset it will use the NNAPI default limit."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Character unexpected, char actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Character) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/main/java/com/example/android/persistence/migrations/UserActivity.java",
    "type": "method",
    "name": "onCreate",
    "code": "protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_user);\n\n        mUserName = findViewById(R.id.user_name);\n        mUserNameInput = findViewById(R.id.user_name_input);\n        mUpdateButton = findViewById(R.id.update_user);\n\n        mUpdateButton.setOnClickListener(v -> {\n            String userName = mUserNameInput.getText().toString();\n            mPresenter.updateUserName(userName);\n        });\n\n        // Creating the repository here for simplicity.\n        // In an real app, this would be a singleton injected\n        UserRepository userRepository = new UserRepository(new AppExecutors(),\n                LocalUserDataSource.getInstance(getApplicationContext()));\n\n        mPresenter = new UserPresenter(userRepository, this);\n    }",
    "comment": "Main screen of the app. Displays a user name and allows the option to update the user name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ThrowableCollector.java",
    "type": "method",
    "name": "add",
    "code": "private void add(Throwable t) {\n\t\tPreconditions.notNull(t, \"Throwable must not be null\");\n\n\t\tif (this.throwable == null) {\n\t\t\tthis.throwable = t;\n\t\t}\n\t\telse if (hasAbortedExecution(this.throwable) && !hasAbortedExecution(t)) {\n\t\t\tt.addSuppressed(this.throwable);\n\t\t\tthis.throwable = t;\n\t\t}\n\t\telse if (throwable != t) {\n\t\t\t// Jupiter does not throw the same Throwable from Node.after() anymore but other engines might\n\t\t\tthis.throwable.addSuppressed(t);\n\t\t}\n\t}",
    "comment": "Add the supplied {@link Throwable} to this {@code ThrowableCollector}.\n\n@param t the {@code Throwable} to add\n@see #execute(Executable)\n@see #assertEmpty()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/session-facade/src/main/java/com/iluwatar/sessionfacade/ProductCatalogService.java",
    "type": "method",
    "name": "getProductById",
    "code": "public Product getProductById(int id) {\n    return products.get(id);\n  }",
    "comment": "Retrieves a product by its ID.\n\n@param id the product ID\n@return the product corresponding to the ID"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/Operation.java",
    "type": "method",
    "name": "cleanupOperationLog",
    "code": "protected void cleanupOperationLog() {\n    if (isOperationLogEnabled) {\n      if (operationLog == null) {\n        LOG.error(\"Operation [ {} ] logging is enabled, \" +\n          \"but its OperationLog object cannot be found.\",\n          MDC.of(LogKeys.OPERATION_HANDLE_ID$.MODULE$, opHandle.getHandleIdentifier()));\n      } else {\n        operationLog.close();\n      }\n    }\n  }",
    "comment": "Implemented by subclass of Operation class to execute specific behaviors.\n@throws HiveSQLException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/JavaModuleOptions.java",
    "type": "method",
    "name": "defaultModuleOptionArray",
    "code": "public static String[] defaultModuleOptionArray() {\n      return DEFAULT_MODULE_OPTIONS;\n    }",
    "comment": "Returns the default JVM runtime option array used by Spark."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/ColumnValue.java",
    "type": "method",
    "name": "toTColumnValue",
    "code": "public static TColumnValue toTColumnValue(TypeDescriptor typeDescriptor, Object value) {\n    Type type = typeDescriptor.getType();\n\n    switch (type) {\n    case BOOLEAN_TYPE:\n      return booleanValue((Boolean)value);\n    case TINYINT_TYPE:\n      return byteValue((Byte)value);\n    case SMALLINT_TYPE:\n      return shortValue((Short)value);\n    case INT_TYPE:\n      return intValue((Integer)value);\n    case BIGINT_TYPE:\n      return longValue((Long)value);\n    case FLOAT_TYPE:\n      return floatValue((Float)value);\n    case DOUBLE_TYPE:\n      return doubleValue((Double)value);\n    case STRING_TYPE:\n      return stringValue((String)value);\n    case CHAR_TYPE:\n      return stringValue((HiveChar)value);\n    case VARCHAR_TYPE:\n      return stringValue((HiveVarchar)value);\n    case DATE_TYPE:\n    case TIMESTAMP_TYPE:\n      return stringValue((String)value);\n    case DECIMAL_TYPE:\n      String plainStr = value == null ? null : ((BigDecimal)value).toPlainString();\n      return stringValue(plainStr);\n    case BINARY_TYPE:\n      String strVal = value == null ? null : UTF8String.fromBytes((byte[])value).toString();\n      return stringValue(strVal);\n    case ARRAY_TYPE:\n    case MAP_TYPE:\n    case STRUCT_TYPE:\n    case UNION_TYPE:\n    case USER_DEFINED_TYPE:\n    case INTERVAL_YEAR_MONTH_TYPE:\n    case INTERVAL_DAY_TIME_TYPE:\n      return stringValue((String)value);\n    case NULL_TYPE:\n      return stringValue((String)value);\n    default:\n      return null;\n    }\n  }",
    "comment": "SPARK-31859, SPARK-31861: converted to string already in SparkExecuteStatementOperation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestFailure.java",
    "type": "method",
    "name": "TestFailure",
    "code": "public TestFailure(Test failedTest, Throwable thrownException) {\n        fFailedTest = failedTest;\n        fThrownException = thrownException;\n    }",
    "comment": "Constructs a TestFailure with the given test and exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ForkJoinPoolHierarchicalTestExecutorService.java",
    "type": "method",
    "name": "exec",
    "code": "public boolean exec() {\n\t\t\tResourceLock resourceLock = testTask.getResourceLock();\n\t\t\tThreadLock threadLock = threadLocks.get();\n\t\t\tif (!threadLock.areAllHeldLocksCompatibleWith(resourceLock)) {\n\t\t\t\tthreadLock.addDeferredTask(this);\n\t\t\t\ttaskEventListener.deferred(testTask);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttry ( //\n\t\t\t\t\tResourceLock lock = resourceLock.acquire(); //\n\t\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\t\tThreadLock.NestedResourceLock nested = threadLock.withNesting(lock) //\n\t\t\t) {\n\t\t\t\ttestTask.execute();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (InterruptedException e) {\n\t\t\t\tthrow ExceptionUtils.throwAsUncheckedException(e);\n\t\t\t}\n\t\t}",
    "comment": "Check if this task is compatible with the current resource lock, if there is any.\nIf not, we put this task in the thread local as a deferred task\nand let the worker thread fork it once it is done with the current task.\nReturn false to indicate that this task is not done yet\nthis means that .join() will wait."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Integer unexpected, Integer actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolver.java",
    "type": "method",
    "name": "addSelectorResolver",
    "code": "public Builder<T> addSelectorResolver(SelectorResolver resolver) {\n\t\t\tPreconditions.notNull(resolver, \"resolver must not be null\");\n\t\t\treturn addSelectorResolver(context -> resolver);\n\t\t}",
    "comment": "Add a context insensitive {@link SelectorResolver} to this builder.\n\n@param resolver the resolver to add; never {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/callbacks/AbstractDatabaseTests.java",
    "type": "method",
    "name": "createDatabase",
    "code": "static void createDatabase() {\n\t\tbeforeAllMethod(AbstractDatabaseTests.class.getSimpleName() + \".createDatabase()\");\n\t}",
    "comment": "Abstract base class for tests that use the database."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/RuleContainer.java",
    "type": "method",
    "name": "getSortedRules",
    "code": "List<Object> getSortedRules() {\n        List<Object> result = new ArrayList<Object>();\n        for (RuleEntry entry : getSortedEntries()) {\n            result.add(entry.rule);\n        }\n        return result;\n    }",
    "comment": "Returns rule instances in the order how they should be applied, i.e. inner-to-outer.\nVisibleForTesting"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "After",
    "code": "private After(String column) {\n      assert column != null;\n      this.column = column;\n    }",
    "comment": "Column position AFTER means the specified column should be put after the given `column`.\nNote that, the specified column may be a nested field, and then the given `column` refers to\na field in the same struct."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/ProjectDependencyGraphStub.java",
    "type": "method",
    "name": "createTaskSegment",
    "code": "private static TaskSegment createTaskSegment() {\n        TaskSegment result = new TaskSegment(false);\n        result.getTasks().add(new GoalTask(\"t1\"));\n        result.getTasks().add(new GoalTask(\"t2\"));\n        return result;\n    }",
    "comment": "A stub dependency graph that is custom-made for testing concurrent build graph evaluations.\n<p>\nImplements a graph as follows:\nA has no dependencies\nB depends on A\nC depends on A\nX depends on B &amp; C\nY depends on B\nZ depends on C\n</p>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tooling-support-tests/src/archUnit/java/platform/tooling/support/tests/ArchUnitTests.java",
    "type": "method",
    "name": "avoidJavaUtilLogging",
    "code": "void avoidJavaUtilLogging(JavaClasses classes) {\n\t\tvar subset = classes.that(are(not(name(\"org.junit.platform.commons.logging.LoggerFactory$DelegatingLogger\"))));\n\t\tGeneralCodingRules.NO_CLASSES_SHOULD_USE_JAVA_UTIL_LOGGING.check(subset);\n\t}",
    "comment": "LoggerFactory.java:80 -> sets field LoggerFactory$DelegatingLogger.julLogger"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "getSslProvider",
    "code": "private SslProvider getSslProvider(Builder b) {\n    if (b.openSslEnabled) {\n      if (OpenSsl.isAvailable()) {\n        return SslProvider.OPENSSL;\n      } else {\n        logger.warn(\"OpenSSL Provider requested but it is not available, using JDK SSL Provider\");\n      }\n    }\n    return SslProvider.JDK;\n  }",
    "comment": "If OpenSSL is requested, this will check if an implementation is available on the local host.\nIf an implementation is not available it will fall back to the JDK {@link SslProvider}.\n\n@param b\n@return"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectMethod",
    "code": "public static MethodSelector selectMethod(Class<?> javaClass, String methodName, String parameterTypeNames) {\n\t\tPreconditions.notNull(javaClass, \"Class must not be null\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\t\tPreconditions.notNull(parameterTypeNames, \"Parameter type names must not be null\");\n\t\treturn new MethodSelector(javaClass, methodName, parameterTypeNames.trim());\n\t}",
    "comment": "Create a {@code MethodSelector} for the supplied {@link Class}, method name,\nand parameter type names.\n\n<p>The parameter type names {@code String} is typically a comma-separated\nlist of atomic types, fully qualified class names, or array types; however,\nthe exact syntax depends on the underlying test engine.\n\n@param javaClass the class in which the method is declared, or a subclass thereof;\nnever {@code null}\n@param methodName the name of the method to select; never {@code null} or blank\n@param parameterTypeNames the parameter type names as a single string; never\n{@code null} though potentially an empty string if the method does not declare\nany parameters\n@see MethodSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "started",
    "code": "public static Condition<Event> started() {\n\t\treturn type(STARTED);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link EventType#STARTED}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "getShorts",
    "code": "public short[] getShorts(int rowId, int count) {\n    short[] res = new short[count];\n    for (int i = 0; i < count; i++) {\n      res[i] = getShort(rowId + i);\n    }\n    return res;\n  }",
    "comment": "Gets short type values from {@code [rowId, rowId + count)}. The return values for the null\nslots are undefined and can be anything."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "build",
    "code": "public GangliaReporter build(GMetric gmetric) {\n            return new GangliaReporter(registry, gmetric, null, prefix, tMax, dMax, rateUnit, durationUnit, filter,\n                    executor, shutdownExecutorOnStop, disabledMetricAttributes);\n        }",
    "comment": "Builds a {@link GangliaReporter} with the given properties, announcing metrics to the\ngiven {@link GMetric} client.\n\n@param gmetric the client to use for announcing metrics\n@return a {@link GangliaReporter}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventStatistics.java",
    "type": "method",
    "name": "succeeded",
    "code": "public EventStatistics succeeded(long expected) {\n\t\tthis.executables.add(() -> assertEquals(expected, this.events.succeeded().count(), \"succeeded\"));\n\t\treturn this;\n\t}",
    "comment": "Specify the number of expected <em>succeeded</em> events.\n\n@param expected the expected number of events\n@return this {@code EventStatistics} for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/ByteArray.java",
    "type": "method",
    "name": "subStringSQL",
    "code": "public static byte[] subStringSQL(byte[] bytes, int pos, int len) {\n    if (pos > bytes.length) {\n      return EMPTY_BYTE;\n    }\n    int start = 0;\n    int end;\n    if (pos > 0) {\n      start = pos - 1;\n    } else if (pos < 0) {\n      start = bytes.length + pos;\n    }\n    if ((bytes.length - start) < len) {\n      end = bytes.length;\n    } else {\n      end = start + len;\n    }\n    start = Math.max(start, 0); // underflow\n    if (start >= end) {\n      return EMPTY_BYTE;\n    }\n    return Arrays.copyOfRange(bytes, start, end);\n  }",
    "comment": "This pos calculation is according to UTF8String#subStringSQL"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroOptionalPrimitives.java",
    "type": "method",
    "name": "setMaybeDoubleColumn",
    "code": "public void setMaybeDoubleColumn(java.lang.Double value) {\n    this.maybe_double_column = value;\n  }",
    "comment": "Sets the value of the 'maybe_double_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java",
    "type": "method",
    "name": "twoMethodResolutionsByUniqueId",
    "code": "void twoMethodResolutionsByUniqueId() {\n\t\tUniqueIdSelector selector1 = selectUniqueId(uniqueIdForMethod(MyTestClass.class, \"test1()\").toString());\n\t\tUniqueIdSelector selector2 = selectUniqueId(uniqueIdForMethod(MyTestClass.class, \"test2()\").toString());\n\n\t\tresolve(request().selectors(selector1, selector2, selector2));\n\n\t\tassertEquals(3, engineDescriptor.getDescendants().size());\n\t\tList<UniqueId> uniqueIds = uniqueIds();\n\t\tassertThat(uniqueIds).contains(uniqueIdForClass(MyTestClass.class));\n\t\tassertThat(uniqueIds).contains(uniqueIdForMethod(MyTestClass.class, \"test1()\"));\n\t\tassertThat(uniqueIds).contains(uniqueIdForMethod(MyTestClass.class, \"test2()\"));\n\n\t\tTestDescriptor classFromMethod1 = descriptorByUniqueId(\n\t\t\tuniqueIdForMethod(MyTestClass.class, \"test1()\")).getParent().orElseThrow();\n\t\tTestDescriptor classFromMethod2 = descriptorByUniqueId(\n\t\t\tuniqueIdForMethod(MyTestClass.class, \"test2()\")).getParent().orElseThrow();\n\n\t\tassertEquals(classFromMethod1, classFromMethod2);\n\t\tassertSame(classFromMethod1, classFromMethod2);\n\t}",
    "comment": "adding same selector twice should have no effect"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/FarthestConflictResolverTest.java",
    "type": "method",
    "name": "testDepthReversed",
    "code": "void testDepthReversed() {\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a2n, a2n, a1n);\n    }",
    "comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\nb:1.0 -&gt; a:2.0\na:1.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeMapData.java",
    "type": "method",
    "name": "getBaseObject",
    "code": "public Object getBaseObject() { return baseObject; }\n  public long getBaseOffset() { return baseOffset; }",
    "comment": "An Unsafe implementation of Map which is backed by raw memory instead of Java objects.\n\nCurrently we just use 2 UnsafeArrayData to represent UnsafeMapData, with extra 8 bytes at head\nto indicate the number of bytes of the unsafe key array.\n[unsafe key array numBytes] [unsafe key array] [unsafe value array]\n\nNote that, user is responsible to guarantee that the key array does not have duplicated\nelements, otherwise the behavior is undefined."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/Throwables.java",
    "type": "method",
    "name": "getStacktrace",
    "code": "public static String getStacktrace(Throwable exception) {\n        StringWriter stringWriter = new StringWriter();\n        PrintWriter writer = new PrintWriter(stringWriter);\n        exception.printStackTrace(writer);\n        return stringWriter.toString();\n    }",
    "comment": "Returns the stacktrace of the given Throwable as a String.\n\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/model-view-viewmodel/src/main/java/com/iluwatar/model/view/viewmodel/BookServiceImpl.java",
    "type": "method",
    "name": "BookServiceImpl",
    "code": "public BookServiceImpl() {\n    designPatternBooks.add(\n        new Book(\n            \"Head First Design Patterns: A Brain-Friendly Guide\",\n            \"Eric Freeman, Bert Bates, Kathy Sierra, Elisabeth Robson\",\n            \"Head First Design Patterns Description\"));\n    designPatternBooks.add(\n        new Book(\n            \"Design Patterns: Elements of Reusable Object-Oriented Software\",\n            \"Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides\",\n            \"Design Patterns Description\"));\n    designPatternBooks.add(\n        new Book(\n            \"Patterns of Enterprise Application Architecture\",\n            \"Martin Fowler\",\n            \"Patterns of Enterprise Application Architecture Description\"));\n    designPatternBooks.add(\n        new Book(\n            \"Design Patterns Explained\",\n            \"Alan Shalloway, James Trott\",\n            \"Design Patterns Explained Description\"));\n    designPatternBooks.add(\n        new Book(\n            \"Applying UML and Patterns: An Introduction to \"\n                + \"Object-Oriented Analysis and Design and Iterative Development\",\n            \"Craig Larman\",\n            \"Applying UML and Patterns Description\"));\n  }",
    "comment": "Initializes Book Data. To be used and passed along in load method In this case, list design\npattern books are initialized to be loaded."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "setOptions",
    "code": "public Runner setOptions(byte[] options) {\n      this.runOptions = options;\n      return this;\n    }",
    "comment": "(Experimental method): set options (typically for debugging) for this run.\n\n<p>The options are presented as a serialized <a\nhref=\"https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto\">RunOptions\nprotocol buffer</a>.\n\n<p>The org.tensorflow package is free of any protocol buffer dependencies in order to remain\nfriendly to resource constrained systems (where something like <a\nhref=\"https://github.com/google/protobuf/tree/master/javanano#nano-version\">nanoproto</a> may\nbe more appropriate). A cost of that is this lack of type-safety in this API function. This\nchoice is under review and this function may be replaced by more type-safe equivalents at any\ntime."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, long expected, long actual) {\n        assertEquals(message, Long.valueOf(expected), Long.valueOf(actual));\n    }",
    "comment": "Asserts that two longs are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "public void resolve(EngineDiscoveryRequest request, T engineDescriptor) {\n\t\tPreconditions.notNull(request, \"request must not be null\");\n\t\tPreconditions.notNull(engineDescriptor, \"engineDescriptor must not be null\");\n\t\tDiscoveryIssueReporter issueReporter = DiscoveryIssueReporter.forwarding(request.getDiscoveryListener(),\n\t\t\tengineDescriptor.getUniqueId());\n\t\tresolve(request, engineDescriptor, issueReporter);\n\t}",
    "comment": "Resolve the supplied {@link EngineDiscoveryRequest} and collect the\nresults into the supplied {@link TestDescriptor} while forwarding\nencountered discovery issues to the {@link EngineDiscoveryRequest}'s\n{@link org.junit.platform.engine.EngineDiscoveryListener}.\n\n<p>The algorithm works as follows:\n\n<ol>\n<li>Enqueue all selectors in the supplied\n{@linkplain EngineDiscoveryRequest request} to be resolved.\n</li>\n<li>\nWhile there are selectors to be resolved, get the next one.\nOtherwise, the resolution is finished.\n<ol>\n<li>\nIterate over all registered {@linkplain SelectorResolver\nresolvers} in the order they were registered in and find the\nfirst one that returns a {@linkplain Resolution resolution}\nother than {@link Resolution#unresolved() unresolved()}.\n</li>\n<li>\nIf such a {@linkplain Resolution resolution} exists, enqueue\nits {@linkplain Resolution#getSelectors() selectors}.\n</li>\n<li>\nFor each exact {@linkplain Match match} in the {@linkplain\nResolution resolution}, {@linkplain Match#expand() expand}\nits children and enqueue them as well.\n</li>\n</ol>\n</li>\n<li>\nIterate over all registered {@linkplain TestDescriptor.Visitor\nvisitors} and let the engine test descriptor {@linkplain\nTestDescriptor#accept(TestDescriptor.Visitor) accept} them.\n</li>\n</ol>\n\n@param request the request to be resolved; never {@code null}\n@param engineDescriptor the engine's {@code TestDescriptor} to be used\nfor adding direct children\n@see SelectorResolver\n@see TestDescriptor.Visitor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/extensions/RandomNumberExtension.java",
    "type": "method",
    "name": "postProcessTestInstance",
    "code": "public void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tClass<?> testClass = context.getRequiredTestClass();\n\t\tinjectFields(testClass, testInstance, ModifierSupport::isNotStatic);\n\t}",
    "comment": "Inject a random integer into non-static fields that are annotated with\n{@code @Random} and can be assigned an integer value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTimeout",
    "code": "public static void assertTimeout(Duration timeout, Executable executable, String message) {\n\t\tAssertTimeout.assertTimeout(timeout, executable, message);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code executable}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>Note: the {@code executable} will be executed in the same thread as that\nof the calling code. Consequently, execution of the {@code executable} will\nnot be preemptively aborted if the timeout is exceeded.\n\n<p>Fails with the supplied failure {@code message}.\n\n@see #assertTimeout(Duration, Executable)\n@see #assertTimeout(Duration, Executable, Supplier)\n@see #assertTimeout(Duration, ThrowingSupplier)\n@see #assertTimeout(Duration, ThrowingSupplier, String)\n@see #assertTimeout(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeoutPreemptively(Duration, Executable, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/Sources.java",
    "type": "method",
    "name": "buildSource",
    "code": "public static ModelSource buildSource(@Nonnull Path path) {\n        return new BuildPathSource(requireNonNull(path, \"path\"));\n    }",
    "comment": "Creates a new build source for the specified path.\nBuild sources are used for POM files of projects being built by Maven\nin the filesystem and support resolving related POMs.\n\n@param path the path to the POM file or project directory\n@return a new ModelSource instance configured as a build source\n@throws NullPointerException if path is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/manipulation/Filter.java",
    "type": "method",
    "name": "Filter",
    "code": "public static final Filter ALL = new Filter() {\n\n        @Override\n        public String describe() {\n            return \"all tests\";\n        }\n\n        @Override\n        public void apply(Object child) throws NoTestsRemainException {\n            // do nothing\n        }\n\n        @Override\n        public Filter intersect(Filter second) {\n            return second;\n        }\n    };",
    "comment": "A null <code>Filter</code> that passes all tests through."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/manipulation/Sorter.java",
    "type": "method",
    "name": "Sorter",
    "code": "public static final Sorter NULL = new Sorter(new Comparator<Description>() {\n    });",
    "comment": "NULL is a <code>Sorter</code> that leaves elements in an undefined order"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Assertions.java",
    "type": "method",
    "name": "assertAll",
    "code": "static void assertAll(String heading, Stream<Executable> executables) {\n\t\tPreconditions.notNull(executables, \"executables stream must not be null\");\n\n\t\tList<Throwable> failures = executables //\n\t\t\t\t.map(executable -> {\n\t\t\t\t\tPreconditions.notNull(executable, \"individual executables must not be null\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\texecutable.execute();\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(t);\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t}\n\t\t\t\t}) //\n\t\t\t\t.filter(Objects::nonNull) //\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tif (!failures.isEmpty()) {\n\t\t\tMultipleFailuresError multipleFailuresError = new MultipleFailuresError(heading, failures);\n\t\t\tfailures.forEach(multipleFailuresError::addSuppressed);\n\t\t\tthrow multipleFailuresError;\n\t\t}\n\t}",
    "comment": "{@code Assertions} is a collection of selected assertion utility methods\nfrom JUnit Jupiter for use within the JUnit Platform Test Kit.\n\n@since 1.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/DefaultProblemCollectorTest.java",
    "type": "method",
    "name": "severityFatalDetection",
    "code": "void severityFatalDetection() {\n        ProblemCollector<BuilderProblem> collector = ProblemCollector.create(5);\n\n        assertFalse(collector.hasProblemsFor(BuilderProblem.Severity.WARNING));\n        assertFalse(collector.hasErrorProblems());\n        assertFalse(collector.hasFatalProblems());\n\n        collector.reportProblem(\n                new DefaultBuilderProblem(\"source\", 0, 0, null, \"message\", BuilderProblem.Severity.FATAL));\n\n        // fatal triggers all\n        assertTrue(collector.hasProblemsFor(BuilderProblem.Severity.WARNING));\n        assertTrue(collector.hasErrorProblems());\n        assertTrue(collector.hasFatalProblems());\n    }",
    "comment": "This UT is for {@link ProblemCollector} but here we have implementations for problems."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-repository-metadata/src/test/java/org/apache/maven/artifact/repository/metadata/MetadataTest.java",
    "type": "method",
    "name": "mergeLegacyWithSnapshot",
    "code": "void mergeLegacyWithSnapshot() {\n        Metadata source = createMetadataFromArtifact(artifact);\n        Date before = new Date(System.currentTimeMillis() - 5000);\n        Date after = new Date(System.currentTimeMillis());\n        addSnapshotVersionLegacy(target.getVersioning(), before, 1);\n        addSnapshotVersion(source.getVersioning(), after, artifact);\n        assertTrue(target.merge(source));\n        assertEquals(0, target.getVersioning().getSnapshotVersions().size());\n        assertEquals(formatDate(after, false), target.getVersioning().getLastUpdated());\n        assertEquals(\n                formatDate(after, true), target.getVersioning().getSnapshot().getTimestamp());\n    }",
    "comment": "legacy metadata did not have \"versioning.snapshotVersions\"\nalthough nothing has changed merge returns true, as the last modified date is equal\nTODO: improve merge here?\nnever convert from legacy format to v1.1 format"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/streaming/JavaRecoverableNetworkWordCount.java",
    "type": "method",
    "name": "getInstance",
    "code": "public static Broadcast<List<String>> getInstance(JavaSparkContext jsc) {\n    if (instance == null) {\n      synchronized (JavaWordExcludeList.class) {\n        if (instance == null) {\n          List<String> wordExcludeList = Arrays.asList(\"a\", \"b\", \"c\");\n          instance = jsc.broadcast(wordExcludeList);\n        }\n      }\n    }\n    return instance;\n  }",
    "comment": "Use this singleton to get or register a Broadcast variable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/ShuffleExternalSorter.java",
    "type": "method",
    "name": "getMemoryUsage",
    "code": "private long getMemoryUsage() {\n    long totalPageSize = 0;\n    for (MemoryBlock page : allocatedPages) {\n      totalPageSize += page.size();\n    }\n    return ((inMemSorter == null) ? 0 : inMemSorter.getMemoryUsage()) + totalPageSize;\n  }",
    "comment": "Reset the in-memory sorter's pointer array only after freeing up the memory pages holding the\nrecords. Otherwise, if the task is over allocated memory, then without freeing the memory\npages, we might not be able to get memory for the pointer array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Float> create(float[][][] data) {\n    return Tensor.create(data, Float.class);\n  }",
    "comment": "Creates a rank-3 tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Long> create(Scope scope, long[][] data) {\n    return create(scope, data, Long.class);\n  }",
    "comment": "Creates a rank-2 constant of {@code long} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuilder.java",
    "type": "method",
    "name": "getProfileActivationContext",
    "code": "private DefaultProfileActivationContext getProfileActivationContext(ModelBuildingRequest request, Model rawModel) {\n        DefaultProfileActivationContext context = new DefaultProfileActivationContext();\n\n        context.setActiveProfileIds(request.getActiveProfileIds());\n        context.setInactiveProfileIds(request.getInactiveProfileIds());\n        context.setSystemProperties(request.getSystemProperties());\n        Properties userProperties = request.getUserProperties();\n        userProperties.computeIfAbsent(\n                (Object) ProfileActivationContext.PROPERTY_NAME_PACKAGING, (p) -> (Object) rawModel.getPackaging());\n        context.setUserProperties(userProperties);\n        context.setProjectDirectory(\n                (request.getPomFile() != null) ? request.getPomFile().getParentFile() : null);\n\n        return context;\n    }",
    "comment": "enrich user properties with project packaging"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/exception/DefaultExceptionHandler.java",
    "type": "method",
    "name": "handleException",
    "code": "public ExceptionSummary handleException(Throwable exception) {\n        return handle(\"\", exception);\n    }",
    "comment": "Transform an exception into useful end-user message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Float> create(Scope scope, float[] data) {\n    return create(scope, data, Float.class);\n  }",
    "comment": "Creates a rank-1 constant of {@code float} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-repository-metadata/src/test/java/org/apache/maven/artifact/repository/metadata/MetadataTest.java",
    "type": "method",
    "name": "mergeWithSameSnapshotWithDifferentVersionsAndNewerLastUpdated",
    "code": "void mergeWithSameSnapshotWithDifferentVersionsAndNewerLastUpdated() {\n        Metadata source = createMetadataFromArtifact(artifact);\n        Date before = new Date(System.currentTimeMillis() - 5000);\n        Date after = new Date(System.currentTimeMillis());\n        addSnapshotVersion(target.getVersioning(), \"jar\", before, \"1\", 1);\n        SnapshotVersion sv2 =\n                addSnapshotVersion(source.getVersioning(), \"jar\", after, \"1.0-\" + formatDate(after, true) + \"-2\", 2);\n        SnapshotVersion sv3 =\n                addSnapshotVersion(source.getVersioning(), \"pom\", after, \"1.0-\" + formatDate(after, true) + \"-2\", 2);\n        assertTrue(target.merge(source));\n        Versioning actualVersioning = target.getVersioning();\n        assertEquals(2, actualVersioning.getSnapshotVersions().size());\n        assertEquals(sv2, actualVersioning.getSnapshotVersions().get(0));\n        assertEquals(sv3, actualVersioning.getSnapshotVersions().get(1));\n        assertEquals(formatDate(after, false), actualVersioning.getLastUpdated());\n        assertEquals(formatDate(after, true), actualVersioning.getSnapshot().getTimestamp());\n        assertEquals(2, actualVersioning.getSnapshot().getBuildNumber());\n    }",
    "comment": "merge implicitly assumes that merge is only called on the same GAV and does not perform any validation here!\nnothing should be actually changed, but still merge returns true\nNOTE! Merge updates last updated to source"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java",
    "type": "method",
    "name": "getResult",
    "code": "private Throwable getResult(FutureTask<Throwable> task, Thread thread) {\n        try {\n            if (timeout > 0) {\n                return task.get(timeout, timeUnit);\n            } else {\n                return task.get();\n            }\n        } catch (InterruptedException e) {\n            return e; // caller will re-throw; no need to call Thread.interrupt()\n        } catch (ExecutionException e) {\n            // test failed; have caller re-throw the exception thrown by the test\n            return e.getCause();\n        } catch (TimeoutException e) {\n            return createTimeoutException(thread);\n        }\n    }",
    "comment": "Wait for the test task, returning the exception thrown by the test if the\ntest failed, an exception indicating a timeout if the test timed out, or\n{@code null} if the test passed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/DelegatingLocalArtifactRepository.java",
    "type": "method",
    "name": "DelegatingLocalArtifactRepository",
    "code": "public DelegatingLocalArtifactRepository(ArtifactRepository artifactRepository) {\n        this.userLocalArtifactRepository = artifactRepository;\n    }",
    "comment": "Delegating local artifact repository chains the reactor, IDE workspace\nand user local repository."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaPrefixSpanExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaPrefixSpanExample\")\n      .getOrCreate();\n\n    // $example on$\n    List<Row> data = Arrays.asList(\n      RowFactory.create(Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3))),\n      RowFactory.create(Arrays.asList(Arrays.asList(1), Arrays.asList(3, 2), Arrays.asList(1,2))),\n      RowFactory.create(Arrays.asList(Arrays.asList(1, 2), Arrays.asList(5))),\n      RowFactory.create(Arrays.asList(Arrays.asList(6)))\n    );\n    StructType schema = new StructType(new StructField[]{ new StructField(\n    Dataset<Row> sequenceDF = spark.createDataFrame(data, schema);\n\n    PrefixSpan prefixSpan = new PrefixSpan().setMinSupport(0.5).setMaxPatternLength(5);\n\n    // Finding frequent sequential patterns\n    prefixSpan.findFrequentSequentialPatterns(sequenceDF).show();\n    // $example off$\n\n    spark.stop();\n  }\n}",
    "comment": "An example demonstrating PrefixSpan.\nRun with\n<pre>\nbin/run-example ml.JavaPrefixSpanExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/main/java/com/iluwatar/circuitbreaker/MonitoringService.java",
    "type": "method",
    "name": "MonitoringService",
    "code": "public MonitoringService(CircuitBreaker delayedService, CircuitBreaker quickService) {\n    this.delayedService = delayedService;\n    this.quickService = quickService;\n  }",
    "comment": "The service class which makes local and remote calls Uses {@link DefaultCircuitBreaker} object to\nensure remote calls don't use up resources."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Timeout.java",
    "type": "method",
    "name": "withTimeout",
    "code": "public Builder withTimeout(long timeout, TimeUnit unit) {\n            this.timeout = timeout;\n            this.timeUnit = unit;\n            return this;\n        }",
    "comment": "Specifies the time to wait before timing out the test.\n\n<p>If this is not called, or is called with a\n{@code timeout} of {@code 0}, the returned {@code Timeout}\nrule instance will cause the tests to wait forever to\ncomplete, however the tests will still launch from a\nseparate thread. This can be useful for disabling timeouts\nin environments where they are dynamically set based on\nsome property.\n\n@param timeout the maximum time to wait\n@param unit the time unit of the {@code timeout} argument\n@return {@code this} for method chaining."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "getChar",
    "code": "public int getChar(int charIndex) {\n    if (charIndex < 0 || charIndex >= numChars()) {\n      throw new IndexOutOfBoundsException();\n    }\n    int charCount = 0, byteCount = 0;\n    while (charCount < charIndex) {\n      byteCount += numBytesForFirstByte(getByte(byteCount));\n      charCount += 1;\n    }\n    return codePointFrom(byteCount);\n  }",
    "comment": "Returns the code point at (char) position `charIndex`. If char index is invalid, throws\nexception. Note that this method is not efficient as it needs to traverse the UTF-8 string.\nIf `byteIndex` of the first byte in the code point is known, use `codePointFrom` instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/AbstractTestSourceTests.java",
    "type": "method",
    "name": "assertToString",
    "code": "private void assertToString(Object instance) {\n\t\tassertNotNull(instance);\n\t\tassertTrue(instance.toString().startsWith(instance.getClass().getSimpleName()));\n\t}",
    "comment": "Abstract base class for unit tests involving {@link TestSource TestSources}\nand {@link FilePosition FilePositions}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/manipulation/Sorter.java",
    "type": "method",
    "name": "apply",
    "code": "public void apply(Object target) {\n        /*\n         * Note that all runners that are Orderable are also Sortable (because\n         * Orderable extends Sortable). Sorting is more efficient than ordering,\n         * so we override the parent behavior so we sort instead.\n         */\n        if (target instanceof Sortable) {\n            Sortable sortable = (Sortable) target;\n            sortable.sort(this);\n        }\n    }",
    "comment": "Sorts the tests in <code>target</code> using <code>comparator</code>.\n\n@since 4.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "getInputTensor",
    "code": "TensorImpl getInputTensor(int index) {\n    if (index < 0 || index >= inputTensors.length) {\n      throw new IllegalArgumentException(\"Invalid input Tensor index: \" + index);\n    }\n    TensorImpl inputTensor = inputTensors[index];\n    if (inputTensor == null) {\n      inputTensor =\n          inputTensors[index] =\n              TensorImpl.fromIndex(\n                  interpreterHandle, getInputTensorIndex(interpreterHandle, index));\n    }\n    return inputTensor;\n  }",
    "comment": "Gets the input {@link TensorImpl} for the provided input index.\n\n@throws IllegalArgumentException if the input index is invalid."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "toLowerCaseSlow",
    "code": "private static UTF8String toLowerCaseSlow(final UTF8String target, final int collationId) {\n    ULocale locale = CollationFactory.fetchCollation(collationId)\n      .getCollator().getLocale(ULocale.ACTUAL_LOCALE);\n    return UTF8String.fromString(UCharacter.toLowerCase(locale, target.toValidString()));\n  }",
    "comment": "Note: In order to achieve the desired behavior, we use the ICU UCharacter class to\nconvert the string to lowercase, which only accepts a Java strings as input."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "scheduleOn",
    "code": "public Builder scheduleOn(ScheduledExecutorService executor) {\n            this.executor = executor;\n            return this;\n        }",
    "comment": "Specifies the executor to use while scheduling reporting of metrics.\nDefault value is null.\nNull value leads to executor will be auto created on start.\n\n@param executor the executor to use while scheduling reporting of metrics.\n@return {@code this}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-spi/src/main/java/org/apache/maven/api/spi/PropertyContributor.java",
    "type": "method",
    "name": "contribute",
    "code": "default Map<String, String> contribute(ProtoSession protoSession) {\n        HashMap<String, String> userProperties = new HashMap<>(protoSession.getUserProperties());\n        contribute(userProperties);\n        return userProperties;\n    }",
    "comment": "Invoked just before session is created with proto session instance. The proto session contains user and\nsystem properties collected so far, along with other information. This method should return altered\n(contributions applied) user properties, not only the \"new\" or \"added\" properties!\n\n@param protoSession The proto session, never {@code null}.\n@return The user properties with contributions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/object-mother/src/main/java/com/iluwatar/objectmother/Queen.java",
    "type": "method",
    "name": "getFlirted",
    "code": "public boolean getFlirted(King king) {\n    return this.isFlirty && king.isHappy && !king.isDrunk;\n  }",
    "comment": "Method which is called when the king is flirting to a queen.\n\n@param king King who initialized the flirt.\n@return A value which describes if the flirt was successful or not."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/InvokerException.java",
    "type": "method",
    "name": "ExitException",
    "code": "public ExitException(int exitCode) {\n            super(\"EXIT\");\n            this.exitCode = exitCode;\n        }",
    "comment": "Exception for intentional exit: No message or anything will be displayed, just the\ncarried exit code will be returned from invoker {@link Invoker#invoke(InvokerRequest)} method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/UTF8StringBuilder.java",
    "type": "method",
    "name": "UTF8StringBuilder",
    "code": "public UTF8StringBuilder() {\n    // Since initial buffer size is 16 in `StringBuilder`, we set the same size here\n    this(16);\n  }",
    "comment": "A helper class to write {@link UTF8String}s to an internal buffer and build the concatenated\n{@link UTF8String} at the end."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-di/src/main/java/org/apache/maven/di/Key.java",
    "type": "method",
    "name": "getQualifier",
    "code": "public @Nullable Object getQualifier() {\n        return qualifier;\n    }",
    "comment": "Returns the qualifier associated with this key, if any.\n\n@return the qualifier object or null if none exists"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/map-reduce/src/main/java/com/iluwatar/Shuffler.java",
    "type": "method",
    "name": "shuffleAndSort",
    "code": "public static Map<String, List<Integer>> shuffleAndSort(List<Map<String, Integer>> mapped) {\n    Map<String, List<Integer>> grouped = new HashMap<>();\n    for (Map<String, Integer> map : mapped) {\n      for (Map.Entry<String, Integer> entry : map.entrySet()) {\n        grouped.putIfAbsent(entry.getKey(), new ArrayList<>());\n        grouped.get(entry.getKey()).add(entry.getValue());\n      }\n    }\n    return grouped;\n  }",
    "comment": "Merges multiple word count maps into a single grouped map.\n\n@param mapped List of maps containing word counts from the mapping phase.\n@return A map where keys are words and values are lists of their occurrences across inputs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Short unexpected, short actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Short) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertNotNull",
    "code": "public static void assertNotNull(Object object) {\n        assertNotNull(null, object);\n    }",
    "comment": "Asserts that an object isn't null. If it is an {@link AssertionError} is\nthrown.\n\n@param object Object to check or <code>null</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/client-session/src/main/java/com/iluwatar/client/session/Server.java",
    "type": "method",
    "name": "getSession",
    "code": "public Session getSession(String name) {\n    return new Session(UUID.randomUUID().toString(), name);\n  }",
    "comment": "Creates a new session.\n\n@param name name of the client\n@return Session Object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "countRunAndMakeAscending",
    "code": "private int countRunAndMakeAscending(Buffer a, int lo, int hi, Comparator<? super K> c) {\n    assert lo < hi;\n    int runHi = lo + 1;\n    if (runHi == hi)\n      return 1;\n\n    K key0 = s.newKey();\n    K key1 = s.newKey();\n\n    // Find end of run, and reverse range if descending\n    if (c.compare(s.getKey(a, runHi++, key0), s.getKey(a, lo, key1)) < 0) { // Descending\n      while (runHi < hi && c.compare(s.getKey(a, runHi, key0), s.getKey(a, runHi - 1, key1)) < 0)\n        runHi++;\n      reverseRange(a, lo, runHi);\n    } else {                              // Ascending\n      while (runHi < hi && c.compare(s.getKey(a, runHi, key0), s.getKey(a, runHi - 1, key1)) >= 0)\n        runHi++;\n    }\n\n    return runHi - lo;\n  }",
    "comment": "Returns the length of the run beginning at the specified position in\nthe specified array and reverses the run if it is descending (ensuring\nthat the run will always be ascending when the method returns).\n\nA run is the longest ascending sequence with:\n\na[lo] <= a[lo + 1] <= a[lo + 2] <= ...\n\nor the longest descending sequence with:\n\na[lo] >  a[lo + 1] >  a[lo + 2] >  ...\n\nFor its intended use in a stable mergesort, the strictness of the\ndefinition of \"descending\" is needed so that the call can safely\nreverse a descending sequence without violating stability.\n\n@param a the array in which a run is to be counted and possibly reversed\n@param lo index of the first element in the run\n@param hi index after the last element that may be contained in the run.\nIt is required that {@code lo < hi}.\n@param c the comparator to used for the sort\n@return  the length of the run beginning at the specified position in\nthe specified array"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaUserDefinedTypedAggregation.java",
    "type": "method",
    "name": "zero",
    "code": "public Average zero() {\n      return new Average(0L, 0L);\n    }",
    "comment": "$example on:typed_custom_aggregation$\nA zero value for this aggregation. Should satisfy the property that any b + zero = b"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "debug",
    "code": "public Executions debug(OutputStream out) {\n\t\tPreconditions.notNull(out, \"OutputStream must not be null\");\n\t\tdebug(new PrintWriter(out, true));\n\t\treturn this;\n\t}",
    "comment": "Print all executions to the supplied {@link OutputStream}.\n\n@param out the {@code OutputStream} to print to; never {@code null}\n@return this {@code Executions} object for method chaining; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Double> create(Scope scope, double[][][][][][] data) {\n    return create(scope, data, Double.class);\n  }",
    "comment": "Creates a rank-6 constant of {@code double} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-yarn/src/main/java/org/apache/spark/network/yarn/YarnShuffleService.java",
    "type": "method",
    "name": "getRecoveryPath",
    "code": "protected Path getRecoveryPath(String fileName) {\n    return _recoveryPath;\n  }",
    "comment": "Get the path specific to this auxiliary service to use for recovery."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java",
    "type": "method",
    "name": "generateDisplayNameForNestedClass",
    "code": "default String generateDisplayNameForNestedClass(Class<?> nestedClass) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"Implement generateDisplayNameForNestedClass(List<Class<?>>, Class<?>) instead\");\n\t}",
    "comment": "Generate a display name for the given {@link Nested @Nested} inner test\nclass.\n\n<p>If this method returns {@code null}, the default display name\ngenerator will be used instead.\n\n@param nestedClass the class to generate a name for; never {@code null}\n@return the display name for the nested class; never blank\n@deprecated in favor of {@link #generateDisplayNameForNestedClass(List, Class)}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/ModuleSelectorTests.java",
    "type": "method",
    "name": "equalsAndHashCode",
    "code": "void equalsAndHashCode() {\n\t\tvar selector1 = new ModuleSelector(\"foo-api\");\n\t\tvar selector2 = new ModuleSelector(\"foo-api\");\n\t\tvar selector3 = new ModuleSelector(\"bar-impl\");\n\n\t\tassertEqualsAndHashCode(selector1, selector2, selector3);\n\t}",
    "comment": "Unit tests for {@link ModuleSelector}.\n\n@since 1.3\n@see DiscoverySelectorsTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "newInstance",
    "code": "static XmlNode newInstance(String name, List<XmlNode> children) {\n        return newBuilder().name(name).children(children).build();\n    }",
    "comment": "Creates a new XmlNode instance with the specified name and children.\n\n@param name the name for the new node\n@param children the list of child nodes\n@return a new XmlNode instance\n@throws NullPointerException if name is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Double expected, Double actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/launcher/core/LauncherConfigurationParametersTests.java",
    "type": "method",
    "name": "some",
    "code": "void some() {\n\t\t\tassertEquals(\"Someone else!\", \"Some\" + thing);\n\t\t}",
    "comment": "`public` is needed for simple \"Class#getField(String)\" to work"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom_Common/java/com/example/android/persistence/migrations/SqliteTestDbOpenHelper.java",
    "type": "method",
    "name": "onUpgrade",
    "code": "public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n    }",
    "comment": "Not required as at version 1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Double unexpected, Double actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/internal/StackTracesTest.java",
    "type": "method",
    "name": "StackTraceLineMatcher",
    "code": "public StackTraceLineMatcher(String method) {\n            this.method = method;\n        }",
    "comment": "A matcher that matches the \"at ...\" line in a stack trace."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, byte expected, byte actual) {\n        assertEquals(message, Byte.valueOf(expected), Byte.valueOf(actual));\n    }",
    "comment": "Asserts that two bytes are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/Trigger.java",
    "type": "method",
    "name": "ProcessingTime",
    "code": "public static Trigger ProcessingTime(long interval, TimeUnit timeUnit) {\n      return ProcessingTimeTrigger.create(interval, timeUnit);\n  }",
    "comment": "(Java-friendly)\nA trigger policy that runs a query periodically based on an interval in processing time.\nIf `interval` is 0, the query will run as fast as possible.\n\n{{{\nimport java.util.concurrent.TimeUnit\ndf.writeStream().trigger(Trigger.ProcessingTime(10, TimeUnit.SECONDS))\n}}}\n\n@since 2.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/FileSource.java",
    "type": "method",
    "name": "getUri",
    "code": "public final URI getUri() {\n\t\treturn getFile().toURI();\n\t}",
    "comment": "Get the {@link URI} for the source {@linkplain #getFile file}.\n\n@return the source {@code URI}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "readFileAttributes",
    "code": "private static BasicFileAttributes readFileAttributes(File file) {\n    try {\n      return Files.readAttributes(\n        file.toPath(), BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n    } catch (IOException e) {\n      return null;\n    }\n  }",
    "comment": "Reads basic attributes of a given file, of return null if an I/O error occurs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/game-loop/src/main/java/com/iluwatar/gameloop/GameLoop.java",
    "type": "method",
    "name": "processInput",
    "code": "protected void processInput() {\n    try {\n      var lag = new SecureRandom().nextInt(200) + 50;\n      Thread.sleep(lag);\n    } catch (InterruptedException e) {\n      logger.error(e.getMessage());\n      /* Clean up whatever needs to be handled before interrupting  */\n      Thread.currentThread().interrupt();\n    }\n  }",
    "comment": "Handle any user input that has happened since the last call. In order to simulate the situation\nin real-life game, here we add a random time lag. The time lag ranges from 50 ms to 250 ms."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/InMemoryOrderRepository.java",
    "type": "method",
    "name": "saveOrder",
    "code": "public void saveOrder(final Order order) {\n    orders.add(order);\n  }",
    "comment": "Saves an order to the in-memory repository.\n\n@param order The order to be saved."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/WasRun.java",
    "type": "method",
    "name": "runTest",
    "code": "protected void runTest() {\n        fWasRun = true;\n    }",
    "comment": "A helper test case for testing whether the testing method\nis run."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/Write.java",
    "type": "method",
    "name": "toStreaming",
    "code": "default StreamingWrite toStreaming() {\n    throw new SparkUnsupportedOperationException(\n      \"_LEGACY_ERROR_TEMP_3138\", Map.of(\"description\", description()));\n  }",
    "comment": "Returns a {@link StreamingWrite} to write data to streaming source. By default this method\nthrows exception, data sources must overwrite this method to provide an implementation, if the\n{@link Table} that creates this write returns {@link TableCapability#STREAMING_WRITE} support\nin its {@link Table#capabilities()}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaChiSqSelectorExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaChiSqSelectorExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    JavaRDD<LabeledPoint> points = MLUtils.loadLibSVMFile(jsc.sc(),\n      \"data/mllib/sample_libsvm_data.txt\").toJavaRDD().cache();\n\n    JavaRDD<LabeledPoint> discretizedData = points.map(lp -> {\n      double[] discretizedFeatures = new double[lp.features().size()];\n      for (int i = 0; i < lp.features().size(); ++i) {\n        discretizedFeatures[i] = Math.floor(lp.features().apply(i) / 16);\n      }\n      return new LabeledPoint(lp.label(), Vectors.dense(discretizedFeatures));\n    });\n\n    ChiSqSelector selector = new ChiSqSelector(50);\n    ChiSqSelectorModel transformer = selector.fit(discretizedData.rdd());\n    JavaRDD<LabeledPoint> filteredData = discretizedData.map(lp ->\n      new LabeledPoint(lp.label(), transformer.transform(lp.features())));\n\n    System.out.println(\"filtered data: \");\n    filteredData.foreach(System.out::println);\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nDiscretize data in 16 equal bins since ChiSqSelector requires categorical features\nAlthough features are doubles, the ChiSqSelector treats each unique value as a category\nCreate ChiSqSelector that will select top 50 of 692 features\nCreate ChiSqSelector model (selecting features)\nFilter the top 50 features from each feature vector\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/test/java/org/apache/maven/artifact/versioning/ComparableVersionTest.java",
    "type": "method",
    "name": "testCompareLowerCaseToUpperCaseASCII",
    "code": "void testCompareLowerCaseToUpperCaseASCII() {\n        ComparableVersion lower = new ComparableVersion(\"1.a\");\n        ComparableVersion upper = new ComparableVersion(\"1.A\");\n        assertTrue(upper.compareTo(lower) == 0, \"expected 1.A == 1.a\");\n        assertTrue(lower.compareTo(upper) == 0, \"expected 1.a == 1.A\");\n    }",
    "comment": "Lower case is equal to upper case"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ArtifactDeployerRequest.java",
    "type": "method",
    "name": "builder",
    "code": "static ArtifactDeployerRequestBuilder builder() {\n        return new ArtifactDeployerRequestBuilder();\n    }",
    "comment": "A request for deploying one or more artifacts to a remote repository.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3716AggregatorForkingTest.java",
    "type": "method",
    "name": "MavenITmng3716AggregatorForkingTest",
    "code": "public MavenITmng3716AggregatorForkingTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3716\">MNG-3716</a>.\n\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/main/java/com/iluwatar/async/method/invocation/App.java",
    "type": "method",
    "name": "lazyval",
    "code": "private static <T> Callable<T> lazyval(T value, long delayMillis) {\n    return () -> {\n      Thread.sleep(delayMillis);\n      log(String.format(ROCKET_LAUNCH_LOG_PATTERN, value));\n      return value;\n    };\n  }",
    "comment": "Creates a callable that lazily evaluates to given value with artificial delay.\n\n@param value value to evaluate\n@param delayMillis artificial delay in milliseconds\n@return new callable for lazy evaluation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/builder/multithreaded/ConcurrencyDependencyGraph.java",
    "type": "method",
    "name": "getDependencies",
    "code": "protected List<MavenProject> getDependencies(MavenProject p) {\n        return projectDependencyGraph.getUpstreamProjects(p, false);\n    }",
    "comment": "For the given {@link MavenProject} {@code p}, return all of {@code p}'s dependencies.\n\n@param p\n@return List of prerequisite projects"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Object expected, Object actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Fails with the supplied failure {@code message}.\n\n@see Object#equals(Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-toolchain-builder/src/main/java/org/apache/maven/toolchain/building/ToolchainsBuildingException.java",
    "type": "method",
    "name": "ToolchainsBuildingException",
    "code": "public ToolchainsBuildingException(List<Problem> problems) {\n        super(toMessage(problems));\n\n        this.problems = new ArrayList<>();\n        if (problems != null) {\n            this.problems.addAll(problems);\n        }\n    }",
    "comment": "Creates a new exception with the specified problems.\n\n@param problems The problems that cause this exception, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerSession.java",
    "type": "method",
    "name": "resourceCleanupStrategy",
    "code": "public Options resourceCleanupStrategy(ResourceCleanupStrategy value) {\n      resourceCleanupStrategy = value;\n      return this;\n    }",
    "comment": "Controls how TensorFlow resources are cleaned up when no longer needed.\n\n<p>{@link ResourceCleanupStrategy#IN_BACKGROUND} is used by default.\n\n@param value strategy to use\n@see ResourceCleanupStrategy"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/PrefixComparators.java",
    "type": "method",
    "name": "computePrefix",
    "code": "public static long computePrefix(double value) {\n      // normalize -0.0 to 0.0, as they should be equal\n      value = value == -0.0 ? 0.0 : value;\n      // Java's doubleToLongBits already canonicalizes all NaN values to the smallest possible\n      // positive NaN, so there's nothing special we need to do for NaNs.\n      long bits = Double.doubleToLongBits(value);\n      // Negative floats compare backwards due to their sign-magnitude representation, so flip\n      // all the bits in this case.\n      long mask = -(bits >>> 63) | 0x8000000000000000L;\n      return bits ^ mask;\n    }",
    "comment": "Converts the double into a value that compares correctly as an unsigned long. For more\ndetails see http://stereopsis.com/radix.html."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/AbstractNioChannel.java",
    "type": "method",
    "name": "AbstractNioChannel",
    "code": "public AbstractNioChannel(ChannelHandler handler, SelectableChannel channel) {\n    this.handler = handler;\n    this.channel = channel;\n    this.channelToPendingWrites = new ConcurrentHashMap<>();\n  }",
    "comment": "Creates a new channel.\n\n@param handler which will handle events occurring on this channel.\n@param channel a NIO channel to be wrapped."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "putBooleans",
    "code": "public void putBooleans(int rowId, int count, byte src, int srcIndex) {\n    assert ((srcIndex + count) <= 8);\n    byte8[0] = (byte)(src & 1);\n    byte8[1] = (byte)(src >>> 1 & 1);\n    byte8[2] = (byte)(src >>> 2 & 1);\n    byte8[3] = (byte)(src >>> 3 & 1);\n    byte8[4] = (byte)(src >>> 4 & 1);\n    byte8[5] = (byte)(src >>> 5 & 1);\n    byte8[6] = (byte)(src >>> 6 & 1);\n    byte8[7] = (byte)(src >>> 7 & 1);\n    putBytes(rowId, count, byte8, srcIndex);\n  }",
    "comment": "Sets bits from [src[srcIndex], src[srcIndex + count]) to [rowId, rowId + count)\nsrc must contain bit-packed 8 booleans in the byte."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "partial",
    "code": "public static Match partial(TestDescriptor testDescriptor) {\n\t\t\treturn partial(testDescriptor, Collections::emptySet);\n\t\t}",
    "comment": "Factory for creating a partial match without any children.\n\n@param testDescriptor the resolved {@code TestDescriptor}; never\n{@code null}\n@return a match that contains the supplied {@code TestDescriptor};\nnever {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/Arguments.java",
    "type": "method",
    "name": "ArgumentSet",
    "code": "private ArgumentSet(String name, Object[] arguments) {\n\t\t\tPreconditions.notBlank(name, \"name must not be null or blank\");\n\t\t\tPreconditions.notNull(arguments, \"arguments array must not be null\");\n\t\t\tthis.name = name;\n\t\t\tthis.arguments = arguments;\n\t\t}",
    "comment": "Specialization of {@link Arguments} that associates a {@link #getName() name}\nwith a set of {@link #get() arguments}.\n\n@since 5.11\n@see Arguments#argumentSet(String, Object...)\n@see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_PLACEHOLDER\n@see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java9/org/junit/platform/commons/util/ModuleUtils.java",
    "type": "method",
    "name": "findAllNonSystemBootModuleNames",
    "code": "public static Set<String> findAllNonSystemBootModuleNames() {\n\t\t// @formatter:off\n\t\tSet<String> systemModules = ModuleFinder.ofSystem().findAll().stream()\n\t\t\t\t.map(reference -> reference.descriptor().name())\n\t\t\t\t.collect(toSet());\n\t\treturn streamResolvedModules(name -> !systemModules.contains(name))\n\t\t\t\t.map(ResolvedModule::name)\n\t\t\t\t.collect(toCollection(LinkedHashSet::new));\n\t\t// @formatter:on\n\t}",
    "comment": "Find all non-system boot modules names.\n\n@return a set of all such module names; never {@code null} but\npotentially empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/test/java/com/iluwatar/identitymap/PersonFinderTest.java",
    "type": "method",
    "name": "personNotFoundInDB",
    "code": "void personNotFoundInDB() {\n    PersonFinder personFinder = new PersonFinder();\n    PersonDbSimulatorImplementation db = new PersonDbSimulatorImplementation();\n    personFinder.setDb(db);\n    Assertions.assertThrows(IdNotFoundException.class, () -> personFinder.getPerson(1));\n    Person person1 = new Person(1, \"John\", 27304159);\n    Person person2 = new Person(2, \"Thomas\", 42273631);\n    Person person3 = new Person(3, \"Arthur\", 27489171);\n    Person person4 = new Person(4, \"Finn\", 20499078);\n    Person person5 = new Person(5, \"Michael\", 40599078);\n    db.insert(person1);\n    db.insert(person2);\n    db.insert(person3);\n    db.insert(person4);\n    db.insert(person5);\n    personFinder.setDb(db);\n    Assertions.assertEquals(person4, personFinder.getPerson(4), \"Find returns incorrect record\");\n    Assertions.assertDoesNotThrow(() -> personFinder.getPerson(1));\n    Assertions.assertThrows(IdNotFoundException.class, () -> personFinder.getPerson(6));\n  }",
    "comment": "init database for our personFinder\nDummy persons\nAssure that the database has been updated.\nAssure key is in DB now.\nAssure key not in DB."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ScopeArtifactFilter.java",
    "type": "method",
    "name": "ScopeArtifactFilter",
    "code": "public ScopeArtifactFilter(String scope) {\n        this.scope = scope;\n\n        addScopeInternal(scope);\n    }",
    "comment": "Filter to only retain objects in the given artifactScope or better."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/ambassador/src/test/java/com/iluwatar/ambassador/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Shape.java",
    "type": "method",
    "name": "numDimensions",
    "code": "public int numDimensions() {\n    return shape == null ? -1 : shape.length;\n  }",
    "comment": "Number of dimensions represented by this shape.\n\n@return -1 if the number of dimensions is unknown, 0 if the shape represents a scalar, 1 for a\nvector, 2 for a matrix etc."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng5608ProfileActivationWarningTest.java",
    "type": "method",
    "name": "MavenITmng5608ProfileActivationWarningTest",
    "code": "public MavenITmng5608ProfileActivationWarningTest() {\n        // changed in https://issues.apache.org/jira/browse/MNG-7895\n        // TODO - consider a separate test\n        super(\"(3.2.1,3.9.4]\");\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-5608\">MNG-5608</a>:\nProfile activation warning test when file specification contains <code>${project.basedir}</code>\ninstead of <code>${basedir}</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/function/Try.java",
    "type": "method",
    "name": "ifSuccess",
    "code": "public Try<V> ifSuccess(Consumer<V> valueConsumer) {\n\t\t\treturn this;\n\t\t}",
    "comment": "don't call valueConsumer because this Try is a failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/double-dispatch/src/test/java/com/iluwatar/doubledispatch/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "lower",
    "code": "public Object lower(List<Object> args) {\n        if (args.size() != 1) {\n            throw new IllegalArgumentException(\"lower function requires exactly one argument\");\n        }\n        String s = ConditionParser.toString(args.get(0));\n        return s.toLowerCase();\n    }",
    "comment": "Converts the given string to lowercase.\n\n@param args A list containing a single string argument\n@return The lowercase version of the input string\n@throws IllegalArgumentException if the number of arguments is not exactly one"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<String> create(String data) {\n    return Tensor.create(data.getBytes(UTF_8), String.class);\n  }",
    "comment": "Creates a scalar String tensor using the default, UTF-8 encoding.\n\n@param data The string to put into the new scalar tensor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/function/Try.java",
    "type": "method",
    "name": "failure",
    "code": "public static <V> Try<V> failure(Exception cause) {\n\t\treturn new Failure<>(checkNotNull(cause, \"cause\"));\n\t}",
    "comment": "Convert the supplied exception into a failed {@code Try}.\n\n@param cause the exception to wrap; must not be {@code null}\n@return a failed {@code Try} that contains the supplied value; never\n{@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/TensorFlowLite.java",
    "type": "method",
    "name": "init",
    "code": "public static void init() {\n    if (isInit) {\n      return;\n    }\n\n    try {\n      // Try to invoke a native method (which itself does nothing) to ensure that native libs are\n      // available.\n      nativeDoNothing();\n      isInit = true;\n    } catch (UnsatisfiedLinkError e) {\n      // Prefer logging the original library loading exception if native methods are unavailable.\n      Throwable exceptionToLog = LOAD_LIBRARY_EXCEPTION != null ? LOAD_LIBRARY_EXCEPTION : e;\n      UnsatisfiedLinkError exceptionToThrow =\n          new UnsatisfiedLinkError(\n              \"Failed to load native TensorFlow Lite methods. Check that the correct native\"\n                  + \" libraries are present, and, if using a custom native library, have been\"\n                  + \" properly loaded via System.loadLibrary():\\n\"\n                  + \"  \"\n                  + exceptionToLog);\n      exceptionToThrow.initCause(e);\n      throw exceptionToThrow;\n    }\n  }",
    "comment": "Ensure the TensorFlowLite native library has been loaded.\n\n<p>If unsuccessful, throws an UnsatisfiedLinkError with the appropriate error message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "getArtifactMetadataPath",
    "code": "public String getArtifactMetadataPath(String gid, String aid) {\n        return getArtifactMetadataPath(gid, aid, null);\n    }",
    "comment": "Gets the path to the local artifact metadata. Note that the method does not check whether the returned path\nactually points to existing metadata.\n\n@param gid The group id, must not be <code>null</code>.\n@param aid The artifact id, must not be <code>null</code>.\n@return The (absolute) path to the local artifact metadata, never <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/FrameworkMethod.java",
    "type": "method",
    "name": "validatePublicVoidNoArg",
    "code": "public void validatePublicVoidNoArg(boolean isStatic, List<Throwable> errors) {\n        validatePublicVoid(isStatic, errors);\n        if (method.getParameterTypes().length != 0) {\n            errors.add(new Exception(\"Method \" + method.getName() + \" should have no parameters\"));\n        }\n    }",
    "comment": "Adds to {@code errors} if this method:\n<ul>\n<li>is not public, or\n<li>takes parameters, or\n<li>returns something other than void, or\n<li>is static (given {@code isStatic is false}), or\n<li>is not static (given {@code isStatic is true}).\n</ul>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/simple/SimpleFluentIterable.java",
    "type": "method",
    "name": "map",
    "code": "public final <T> FluentIterable<T> map(Function<? super E, T> function) {\n    var temporaryList = new ArrayList<T>();\n    this.forEach(e -> temporaryList.add(function.apply(e)));\n    return from(temporaryList);\n  }",
    "comment": "Transforms this FluentIterable into a new one containing objects of the type T.\n\n@param function a function that transforms an instance of E into an instance of T\n@param <T> the target type of the transformation\n@return a new FluentIterable of the new type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginResolutionException.java",
    "type": "method",
    "name": "PluginResolutionException",
    "code": "public PluginResolutionException(Plugin plugin, Throwable cause) {\n        super(\n                \"Plugin \" + plugin.getId() + \" or one of its dependencies could not be resolved: \" + cause.getMessage(),\n                cause);\n        this.plugin = plugin;\n    }",
    "comment": "Exception occurring trying to resolve a plugin."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "applyTrimmingPolicy",
    "code": "protected static UTF8String applyTrimmingPolicy(UTF8String s, SpaceTrimming spaceTrimming) {\n        if(spaceTrimming == SpaceTrimming.RTRIM){\n          return s.trimRight();\n        }\n        return s; // No trimming.\n      }",
    "comment": "Utility function to trim spaces when collation uses space trimming."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getRuntimeArtifacts",
    "code": "public List<Artifact> getRuntimeArtifacts() {\n        List<Artifact> list = new ArrayList<>(getArtifacts().size());\n\n        for (Artifact a : getArtifacts()) {\n            if (a.getArtifactHandler().isAddedToClasspath() && isRuntimePathElement(a.getScope())) {\n                list.add(a);\n            }\n        }\n        return list;\n    }",
    "comment": "TODO classpath check doesn't belong here - that's the other method"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/inference_interface/java/org/tensorflow/contrib/android/RunStats.java",
    "type": "method",
    "name": "runOptions",
    "code": "public static byte[] runOptions() {\n    return fullTraceRunOptions;\n  }",
    "comment": "Options to be provided to a {@link org.tensorflow.Session.Runner} to enable stats accumulation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/extensions/RepeatedTest.java",
    "type": "method",
    "name": "RepeatedTest",
    "code": "public RepeatedTest(Test test, int repeat) {\n        super(test);\n        if (repeat < 0) {\n            throw new IllegalArgumentException(\"Repetition count must be >= 0\");\n        }\n        fTimesRepeat = repeat;\n    }",
    "comment": "A Decorator that runs a test repeatedly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/factory-method/src/test/java/com/iluwatar/factory/method/FactoryMethodTest.java",
    "type": "method",
    "name": "testOrcBlacksmithWithAxe",
    "code": "void testOrcBlacksmithWithAxe() {\n    var blacksmith = new OrcBlacksmith();\n    var weapon = blacksmith.manufactureWeapon(WeaponType.AXE);\n    verifyWeapon(weapon, WeaponType.AXE, OrcWeapon.class);\n  }",
    "comment": "Testing {@link OrcBlacksmith} to produce an AXE asserting that the Weapon is an instance of\n{@link OrcWeapon}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/MojoFailureException.java",
    "type": "method",
    "name": "MojoFailureException",
    "code": "public MojoFailureException(String message, Throwable cause) {\n        super(message, cause);\n    }",
    "comment": "Construct a new <code>MojoFailureException</code> exception wrapping an underlying <code>Throwable</code>\nand providing a <code>message</code>.\n\n@param message\n@param cause\n@since 2.0.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/org/apache/spark/sql/execution/streaming/state/POJOTestClass.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n    return \"POJOTestClass{\" +\n      \"name='\" + name + '\\'' +\n      \", age=\" + id +\n      '}';\n  }",
    "comment": "Override toString for better representation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenBaseLogger.java",
    "type": "method",
    "name": "isLevelEnabled",
    "code": "protected boolean isLevelEnabled(int logLevel) {\n        // log level are numerically ordered so can use simple numeric\n        // comparison\n        return (logLevel >= currentLogLevel);\n    }",
    "comment": "Is the given log level currently enabled?\n\n@param logLevel is this level enabled?\n@return whether the logger is enabled for the given level"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "createSuiteDescription",
    "code": "public static Description createSuiteDescription(String name, Annotation... annotations) {\n        return new Description(null, name, annotations);\n    }",
    "comment": "Create a <code>Description</code> named <code>name</code>.\nGenerally, you will add children to this <code>Description</code>.\n\n@param name the name of the <code>Description</code>\n@param annotations meta-data about the test, for downstream interpreters\n@return a <code>Description</code> named <code>name</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isPrivate",
    "code": "public static boolean isPrivate(Member member) {\n\t\treturn ReflectionUtils.isPrivate(member);\n\t}",
    "comment": "Determine if the supplied member is {@code private}.\n\n@param member the member to check; never {@code null}\n@return {@code true} if the member is {@code private}\n@see java.lang.reflect.Modifier#isPrivate(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "getPeakMemoryUsedBytes",
    "code": "public long getPeakMemoryUsedBytes() {\n    updatePeakMemoryUsed();\n    return peakMemoryUsedBytes;\n  }",
    "comment": "Return the peak memory used so far, in bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/notification/RunNotifier.java",
    "type": "method",
    "name": "addFirstListener",
    "code": "public void addFirstListener(RunListener listener) {\n        if (listener == null) {\n            throw new NullPointerException(\"Cannot add a null listener\");\n        }\n        listeners.add(0, wrapIfNotThreadSafe(listener));\n    }",
    "comment": "Internal use only. The Result's listener must be first."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetColumnVector.java",
    "type": "method",
    "name": "assemble",
    "code": "void assemble() {\n    if (variantSchema != null) {\n      children.get(0).assemble();\n      WritableColumnVector fileContent = children.get(0).getValueVector();\n      if (fieldsToExtract == null) {\n        SparkShreddingUtils.assembleVariantBatch(fileContent, vector, variantSchema);\n      } else {\n        SparkShreddingUtils.assembleVariantStructBatch(fileContent, vector, variantSchema,\n            fieldsToExtract);\n      }\n      return;\n    }\n    // nothing to do if the column itself is missing\n    if (vector.isAllNull()) return;\n\n    DataType type = column.sparkType();\n    if (type instanceof ArrayType || type instanceof MapType) {\n      for (ParquetColumnVector child : children) {\n        child.assemble();\n      }\n      assembleCollection();\n    } else if (type instanceof StructType || type instanceof VariantType) {\n      for (ParquetColumnVector child : children) {\n        child.assemble();\n      }\n      assembleStruct();\n    }\n  }",
    "comment": "Assembles this column and calculate collection offsets recursively.\nThis is a no-op for primitive columns."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/plugin/testing/MojoExtension.java",
    "type": "method",
    "name": "createSession",
    "code": "Reader reader = new BufferedReader(new XmlStreamReader(is))) {\n        context.getStore(ExtensionContext.Namespace.GLOBAL).put(PluginDescriptor.class, pluginDescriptor);\n\n        @SuppressWarnings({\"unused\", \"MagicNumber\"})\n        class Foo {\n\n            @Provides\n            @Singleton\n            @Priority(-10)\n            private InternalSession createSession() {\n                return SessionMock.getMockSession(getBasedir());\n            }\n\n            @Provides\n            @Singleton\n            @Priority(-10)\n            private Project createProject(InternalSession s) {\n                ProjectStub stub = new ProjectStub();\n                if (!\"pom\".equals(model.getPackaging())) {\n                    ProducedArtifactStub artifact = new ProducedArtifactStub(\n                            model.getGroupId(), model.getArtifactId(), \"\", model.getVersion(), model.getPackaging());\n                    stub.setMainArtifact(artifact);\n                }\n                stub.setModel(model);\n                stub.setBasedir(Paths.get(MojoExtension.getBasedir()));\n                stub.setPomPath(modelPath[0]);\n                s.getService(ArtifactManager.class).setPath(stub.getPomArtifact(), modelPath[0]);\n                return stub;\n            }\n\n            @Provides\n            @Singleton\n            @Priority(-10)\n            private MojoExecution createMojoExecution() {\n                MojoExecutionStub mes = new MojoExecutionStub(\"executionId\", null);\n                if (mojo != null) {\n                    String goal = mojo.goal();\n                    int idx = goal.lastIndexOf(':');\n                    if (idx >= 0) {\n                        goal = goal.substring(idx + 1);\n                    }\n                    mes.setGoal(goal);\n                    for (MojoDescriptor md : pluginDescriptor.getMojos()) {\n                        if (goal.equals(md.getGoal())) {\n                            mes.setDescriptor(md);\n                        }\n                    }\n                    requireNonNull(mes.getDescriptor());\n                }\n                PluginStub plugin = new PluginStub();\n                plugin.setDescriptor(pluginDescriptor);\n                mes.setPlugin(plugin);\n                return mes;\n            }\n\n            @Provides\n            @Singleton\n            @Priority(-10)\n            private Log createLog() {\n                return new DefaultLog(LoggerFactory.getLogger(\"anonymous\"));\n            }\n\n            @Provides\n            static RepositorySystemSupplier newRepositorySystemSupplier() {\n                return new RepositorySystemSupplier();\n            }\n\n            @Provides\n            static RepositorySystem newRepositorySystem(RepositorySystemSupplier repositorySystemSupplier) {\n                return repositorySystemSupplier.getRepositorySystem();\n            }\n\n            @Provides\n            @Priority(10)\n            static RepositoryFactory newRepositoryFactory(Session session) {\n                return session.getService(RepositoryFactory.class);\n            }\n\n            @Provides\n            @Priority(10)\n            static VersionParser newVersionParser(Session session) {\n                return session.getService(VersionParser.class);\n            }\n\n            @Provides\n            @Priority(10)\n            static LocalRepositoryManager newLocalRepositoryManager(Session session) {\n                return session.getService(LocalRepositoryManager.class);\n            }\n\n            @Provides\n            @Priority(10)\n            static ArtifactInstaller newArtifactInstaller(Session session) {\n                return session.getService(ArtifactInstaller.class);\n            }\n\n            @Provides\n            @Priority(10)\n            static ArtifactDeployer newArtifactDeployer(Session session) {\n                return session.getService(ArtifactDeployer.class);\n            }\n\n            @Provides\n            @Priority(10)\n            static ArtifactManager newArtifactManager(Session session) {\n                return session.getService(ArtifactManager.class);\n            }\n\n            @Provides\n            @Priority(10)\n            static ProjectManager newProjectManager(Session session) {\n                return session.getService(ProjectManager.class);\n            }\n\n            @Provides\n            @Priority(10)\n            static ArtifactFactory newArtifactFactory(Session session) {\n                return session.getService(ArtifactFactory.class);\n            }\n\n            @Provides\n            @Priority(10)\n            static ProjectBuilder newProjectBuilder(Session session) {\n                return session.getService(ProjectBuilder.class);\n            }\n\n            @Provides\n            @Priority(10)\n            static ModelXmlFactory newModelXmlFactory(Session session) {\n                return session.getService(ModelXmlFactory.class);\n            }\n        }\n\n        getInjector().bindInstance(Foo.class, new Foo());\n\n        getInjector().injectInstance(context.getRequiredTestInstance());\n\n\n    }",
    "comment": "mojo execution\nMap<Object, Object> map = getInjector().getContext().getContextData();\nnew InterpolationFilterReader(reader, map, \"${\", \"}\");\nfor (ComponentDescriptor<?> desc : pluginDescriptor.getComponents()) {\ngetContainer().addComponentDescriptor(desc);\n}\nSessionScope sessionScope = getInjector().getInstance(SessionScope.class);\nsessionScope.enter();\nsessionScope.seed(Session.class, s);\nsessionScope.seed(InternalSession.class, s);\nMojoExecutionScope mojoExecutionScope = getInjector().getInstance(MojoExecutionScope.class);\nmojoExecutionScope.enter();\nmojoExecutionScope.seed(Project.class, p);\nmojoExecutionScope.seed(MojoExecution.class, me);"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(double[] expected, double[] actual, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} double arrays are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "setResolvedArtifacts",
    "code": "public void setResolvedArtifacts(Set<Artifact> artifacts) {\n        this.resolvedArtifacts = (artifacts != null) ? artifacts : Collections.emptySet();\n        this.artifacts = null;\n        this.artifactMap = null;\n    }",
    "comment": "Sets the transitive dependency artifacts that have been resolved/collected for this project.\n<strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not\npart of the public API. In particular, this method can be changed or deleted without prior notice and must not be\nused by plugins.\n\n@param artifacts The set of artifacts, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java9/org/junit/platform/commons/util/ModuleUtils.java",
    "type": "method",
    "name": "streamResolvedModules",
    "code": "private static Stream<ResolvedModule> streamResolvedModules(Predicate<String> moduleNamePredicate) {\n\t\tModule module = ModuleUtils.class.getModule();\n\t\tModuleLayer layer = module.getLayer();\n\t\tif (layer == null) {\n\t\t\tlogger.config(() -> ModuleUtils.class + \" is a member of \" + module\n\t\t\t\t\t+ \" - using boot layer returned by ModuleLayer.boot() as fall-back.\");\n\t\t\tlayer = ModuleLayer.boot();\n\t\t}\n\t\treturn streamResolvedModules(moduleNamePredicate, layer);\n\t}",
    "comment": "Stream resolved modules from current (or boot) module layer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/registration/WebServerDemo.java",
    "type": "method",
    "name": "getProductList",
    "code": "void getProductList() {\n\t\t@SuppressWarnings(\"resource\")\n\t\tWebClient webClient = new WebClient();\n\t\tString serverUrl = server.getServerUrl();\n\t\tassertEquals(200, webClient.get(serverUrl + \"/products\").getResponseStatus());\n\t}",
    "comment": "tag::user_guide[]\nend::user_guide[]\n@formatter:off\ntag::user_guide[]\nend::user_guide[]\n@formatter:on\ntag::user_guide[]\nend::user_guide[]\ntag::user_guide[]\nUse WebClient to connect to web server using serverUrl and verify response"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/test/java/org/apache/maven/repository/internal/RepositorySystemTest.java",
    "type": "method",
    "name": "checkArtifactResult",
    "code": "private void checkArtifactResult(ArtifactResult result, String filename) {\n        assertFalse(result.isMissing());\n        assertTrue(result.isResolved());\n        Artifact artifact = result.getArtifact();\n        assertNotNull(artifact.getFile());\n        assertEquals(filename, artifact.getFile().getName());\n    }",
    "comment": "notice: extension and classifier not really used in this test..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "minChunkSizeInMergedShuffleFile",
    "code": "public int minChunkSizeInMergedShuffleFile() {\n    return Ints.checkedCast(JavaUtils.byteStringAsBytes(\n      conf.get(\"spark.shuffle.push.server.minChunkSizeInMergedShuffleFile\", \"2m\")));\n  }",
    "comment": "The minimum size of a chunk when dividing a merged shuffle file into multiple chunks during\npush-based shuffle.\nA merged shuffle file consists of multiple small shuffle blocks. Fetching the complete\nmerged shuffle file in a single disk I/O increases the memory requirements for both the\nclients and the external shuffle service. Instead, the external shuffle service serves\nthe merged file in MB-sized chunks. This configuration controls how big a chunk can get.\nA corresponding index file for each merged shuffle file will be generated indicating chunk\nboundaries.\n\nSetting this too high would increase the memory requirements on both the clients and the\nexternal shuffle service.\n\nSetting this too low would increase the overall number of RPC requests to external shuffle\nservice unnecessarily."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaLogisticRegressionWithElasticNetExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaLogisticRegressionWithElasticNetExample\")\n      .getOrCreate();\n\n    Dataset<Row> training = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_libsvm_data.txt\");\n\n    LogisticRegression lr = new LogisticRegression()\n      .setMaxIter(10)\n      .setRegParam(0.3)\n      .setElasticNetParam(0.8);\n\n    LogisticRegressionModel lrModel = lr.fit(training);\n\n    System.out.println(\"Coefficients: \"\n      + lrModel.coefficients() + \" Intercept: \" + lrModel.intercept());\n\n    LogisticRegression mlr = new LogisticRegression()\n            .setMaxIter(10)\n            .setRegParam(0.3)\n            .setElasticNetParam(0.8)\n            .setFamily(\"multinomial\");\n\n    LogisticRegressionModel mlrModel = mlr.fit(training);\n\n    System.out.println(\"Multinomial coefficients: \" + lrModel.coefficientMatrix()\n      + \"\\nMultinomial intercepts: \" + mlrModel.interceptVector());\n\n    spark.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nLoad training data\nFit the model\nPrint the coefficients and intercept for logistic regression\nWe can also use the multinomial family for binary classification\nFit the model\nPrint the coefficients and intercepts for logistic regression with multinomial family\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/AbstractSession.java",
    "type": "method",
    "name": "installArtifacts",
    "code": "public void installArtifacts(Collection<ProducedArtifact> artifacts) {\n        getService(ArtifactInstaller.class).install(this, artifacts);\n    }",
    "comment": "Shortcut for {@code getService(ArtifactInstaller.class).install(...)}\n\n@throws ArtifactInstallerException if the artifacts installation failed\n@see ArtifactInstaller#install(Session, Collection)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroPrimitives.java",
    "type": "method",
    "name": "setDoubleColumn",
    "code": "public void setDoubleColumn(java.lang.Double value) {\n    this.double_column = value;\n  }",
    "comment": "Sets the value of the 'double_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3991ValidDependencyScopeTest.java",
    "type": "method",
    "name": "MavenITmng3991ValidDependencyScopeTest",
    "code": "public MavenITmng3991ValidDependencyScopeTest() {\n        // TODO: One day, we should be able to error out but this requires to consider extensions and their use cases\n        super(\"[4.0,)\");\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3991\">MNG-3991</a>.\n\n@author Benjamin Bentmann"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "sort",
    "code": "public void sort(Buffer a, int lo, int hi, Comparator<? super K> c) {\n    assert c != null;\n\n    int nRemaining  = hi - lo;\n    if (nRemaining < 2)\n      return;  // Arrays of size 0 and 1 are always sorted\n\n    // If array is small, do a \"mini-TimSort\" with no merges\n    if (nRemaining < MIN_MERGE) {\n      int initRunLen = countRunAndMakeAscending(a, lo, hi, c);\n      binarySort(a, lo, hi, lo + initRunLen, c);\n      return;\n    }\n\n    SortState sortState = new SortState(a, c, hi - lo);\n    int minRun = minRunLength(nRemaining);\n    do {\n      // Identify next run\n      int runLen = countRunAndMakeAscending(a, lo, hi, c);\n\n      // If run is short, extend to min(minRun, nRemaining)\n      if (runLen < minRun) {\n        int force = nRemaining <= minRun ? nRemaining : minRun;\n        binarySort(a, lo, lo + force, lo + runLen, c);\n        runLen = force;\n      }\n\n      // Push run onto pending-run stack, and maybe merge\n      sortState.pushRun(lo, runLen);\n      sortState.mergeCollapse();\n\n      // Advance to find next run\n      lo += runLen;\n      nRemaining -= runLen;\n    } while (nRemaining != 0);\n\n    // Merge all remaining runs to complete sort\n    assert lo == hi;\n    sortState.mergeForceCollapse();\n    assert sortState.stackSize == 1;\n  }",
    "comment": "March over the array once, left to right, finding natural runs,\nextending short natural runs to minRun elements, and merging runs\nto maintain stack invariant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "isCompilePathElement",
    "code": "private static boolean isCompilePathElement(final String scope) {\n        return Artifact.SCOPE_COMPILE.equals(scope)\n                || Artifact.SCOPE_PROVIDED.equals(scope)\n                || Artifact.SCOPE_SYSTEM.equals(scope);\n    }",
    "comment": "TODO let the scope handler deal with this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/reporting/open/xml/OpenTestReportGeneratingListenerTests.java",
    "type": "method",
    "name": "wrapSystemPrintStreams",
    "code": "void wrapSystemPrintStreams() {\n\t\t// Work around nesting check in org.junit.platform.launcher.core.StreamInterceptor\n\t\toriginalOut = System.out;\n\t\tSystem.setOut(new PrintStream(System.out));\n\t\toriginalErr = System.err;\n\t\tSystem.setErr(new PrintStream(System.err));\n\t}",
    "comment": "Tests for {@link OpenTestReportGeneratingListener}.\n\n@since 1.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "fail",
    "code": "public static <V> V fail(String message) {\n\t\tAssertionUtils.fail(message);\n\t\treturn null; // appeasing the compiler: this line will never be executed.\n\t}",
    "comment": "<em>Fail</em> the test with the given failure {@code message}.\n\n<p>The generic return type {@code V} allows this method to be used\ndirectly as a single-statement lambda expression, thereby avoiding the\nneed to implement a code block with an explicit return value. Since this\nmethod throws an {@link org.opentest4j.AssertionFailedError} before its\nreturn statement, this method never actually returns a value to its caller.\nThe following example demonstrates how this may be used in practice.\n\n<pre>{@code\nStream.of().map(entry -> fail(\"should not be called\"));\n}</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetReadState.java",
    "type": "method",
    "name": "constructRanges",
    "code": "private Iterator<RowRange> constructRanges(PrimitiveIterator.OfLong rowIndexes) {\n    if (rowIndexes == null) {\n      return null;\n    }\n\n    List<RowRange> rowRanges = new ArrayList<>();\n    long currentStart = Long.MIN_VALUE;\n    long previous = Long.MIN_VALUE;\n\n    while (rowIndexes.hasNext()) {\n      long idx = rowIndexes.nextLong();\n      if (currentStart == Long.MIN_VALUE) {\n        currentStart = idx;\n      } else if (previous + 1 != idx) {\n        RowRange range = new RowRange(currentStart, previous);\n        rowRanges.add(range);\n        currentStart = idx;\n      }\n      previous = idx;\n    }\n\n    if (previous != Long.MIN_VALUE) {\n      rowRanges.add(new RowRange(currentStart, previous));\n    }\n\n    return rowRanges.iterator();\n  }",
    "comment": "Construct a list of row ranges from the given `rowIndexes`. For example, suppose the\n`rowIndexes` are `[0, 1, 2, 4, 5, 7, 8, 9]`, it will be converted into 3 row ranges:\n`[0-2], [4-5], [7-9]`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/master-worker/src/main/java/com/iluwatar/masterworker/Result.java",
    "type": "method",
    "name": "Result",
    "code": "public Result(T data) {\n    this.data = data;\n  }",
    "comment": "The abstract Result class, which contains 1 public field containing result data.\n\n@param <T> T will be type of data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/path/ProfileActivationFilePathInterpolator.java",
    "type": "method",
    "name": "setPathTranslator",
    "code": "public ProfileActivationFilePathInterpolator setPathTranslator(PathTranslator pathTranslator) {\n        this.pathTranslator = pathTranslator;\n        return this;\n    }",
    "comment": "Finds an absolute path for {@link ActivationFile#getExists()} or {@link ActivationFile#getMissing()}\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/BeforeAndAfterEachTests.java",
    "type": "method",
    "name": "resetCallSequence",
    "code": "void resetCallSequence() {\n\t\tcallSequence.clear();\n\t\tbeforeEachMethodCallSequence.clear();\n\t\tactualExceptionInAfterEachCallback = null;\n\t}",
    "comment": "Integration tests that verify support for {@link BeforeEach}, {@link AfterEach},\n{@link BeforeEachCallback}, and {@link AfterEachCallback} in the {@link JupiterTestEngine}.\n\n@since 5.0\n@see BeforeAndAfterTestExecutionCallbackTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/DefaultModelVersionProcessor.java",
    "type": "method",
    "name": "isValidProperty",
    "code": "public boolean isValidProperty(String property) {\n        return REVISION_PROPERTY.equals(property)\n                || CHANGELIST_PROPERTY.equals(property)\n                || SHA1_PROPERTY.equals(property);\n    }",
    "comment": "Maven default implementation of the {@link ModelVersionProcessor} to support\n<a href=\"https://maven.apache.org/maven-ci-friendly.html\">CI Friendly Versions</a>\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "startTest",
    "code": "public void startTest(Test test) {\n        final int count = test.countTestCases();\n        synchronized (this) {\n            fRunTests += count;\n        }\n        for (TestListener each : cloneListeners()) {\n            each.startTest(test);\n        }\n    }",
    "comment": "Informs the result that a test will be started."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeMapData.java",
    "type": "method",
    "name": "UnsafeMapData",
    "code": "public UnsafeMapData() {\n    keys = new UnsafeArrayData();\n    values = new UnsafeArrayData();\n  }",
    "comment": "Construct a new UnsafeMapData. The resulting UnsafeMapData won't be usable until\n`pointTo()` has been called, since the value returned by this constructor is equivalent\nto a null pointer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcRequestedCiphers",
    "code": "public String[] sslRpcRequestedCiphers() {\n    String ciphers = conf.get(\"spark.ssl.rpc.enabledAlgorithms\", null);\n    return (ciphers != null ? ciphers.split(\",\") : null);\n  }",
    "comment": "A comma separated list of ciphers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslShuffleChunkSize",
    "code": "public int sslShuffleChunkSize() {\n    return Ints.checkedCast(JavaUtils.byteStringAsBytes(\n      conf.get(\"spark.network.ssl.maxEncryptedBlockSize\", \"64k\")));\n  }",
    "comment": "When Secure (SSL/TLS) Shuffle is enabled, the Chunk size to use for shuffling files."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/RepeatedTestsDemo.java",
    "type": "method",
    "name": "repeatedTestWithFailureThreshold",
    "code": "void repeatedTestWithFailureThreshold(RepetitionInfo repetitionInfo) {\n\t\tif (repetitionInfo.getCurrentRepetition() % 2 == 0) {\n\t\t\tfail(\"Boom!\");\n\t\t}\n\t}",
    "comment": "end::user_guide[]\nUse fully qualified name to avoid having it show up in the imports.\ntag::user_guide[]\nSimulate unexpected failure every second repetition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SparkSaslServer.java",
    "type": "method",
    "name": "isComplete",
    "code": "public synchronized boolean isComplete() {\n    return saslServer != null && saslServer.isComplete();\n  }",
    "comment": "Determines whether the authentication exchange has completed successfully."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/spatial-partition/src/main/java/com/iluwatar/spatialpartition/Bubble.java",
    "type": "method",
    "name": "move",
    "code": "void move() {\n    this.coordinateX += RANDOM.nextInt(3) - 1;\n    this.coordinateY += RANDOM.nextInt(3) - 1;\n  }",
    "comment": "moves by 1 unit in either direction"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionProfileActivator.java",
    "type": "method",
    "name": "ConditionProfileActivator",
    "code": "public ConditionProfileActivator(VersionParser versionParser, Interpolator interpolator) {\n        this.versionParser = versionParser;\n        this.interpolator = interpolator;\n    }",
    "comment": "Constructs a new ConditionProfileActivator with the necessary dependencies.\n\n@param versionParser The parser for handling version comparisons\n@param interpolator  The interpolator for interpolating the values in the given map using the provided callback function"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedRleValuesReader.java",
    "type": "method",
    "name": "readIntegers",
    "code": "public void readIntegers(int total, WritableColumnVector c, int rowId) {\n    int left = total;\n    while (left > 0) {\n      if (currentCount == 0 && !readNextGroup()) break;\n      int n = Math.min(left, this.currentCount);\n      switch (mode) {\n        case RLE -> c.putInts(rowId, n, currentValue);\n        case PACKED -> {\n          c.putInts(rowId, n, currentBuffer, currentBufferIdx);\n          currentBufferIdx += n;\n        }\n      }\n      rowId += n;\n      left -= n;\n      currentCount -= n;\n    }\n  }",
    "comment": "The RLE reader implements the vectorized decoding interface when used to decode dictionary\nIDs. This is different than the above APIs that decodes definitions levels along with values.\nSince this is only used to decode dictionary IDs, only decoding integers is supported."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedParquetRecordReader.java",
    "type": "method",
    "name": "containsPath",
    "code": "private boolean containsPath(Type parquetType, String[] path) {\n    return containsPath(parquetType, path, 0);\n  }",
    "comment": "Checks whether the given 'path' exists in 'parquetType'. The difference between this and\n{@link MessageType#containsPath(String[])} is that the latter only support paths to leaf\nnodes, while this support paths both to leaf and non-leaf nodes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/Promise.java",
    "type": "method",
    "name": "thenAccept",
    "code": "public Promise<Void> thenAccept(Consumer<? super T> action) {\n    var dest = new Promise<Void>();\n    fulfillmentAction = new ConsumeAction(this, dest, action);\n    return dest;\n  }",
    "comment": "Returns a new promise that, when this promise is fulfilled normally, is fulfilled with result\nof this promise as argument to the action provided.\n\n@param action action to be executed.\n@return a new promise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/config/CachingJupiterConfigurationTests.java",
    "type": "method",
    "name": "cachesDefaultTempDirFactorySupplier",
    "code": "void cachesDefaultTempDirFactorySupplier() {\n\t\tSupplier<TempDirFactory> supplier = mock();\n\t\twhen(delegate.getDefaultTempDirFactorySupplier()).thenReturn(supplier);\n\n\t\tassertThat(cache.getDefaultTempDirFactorySupplier()).isSameAs(supplier);\n\t\tassertThat(cache.getDefaultTempDirFactorySupplier()).isSameAs(supplier);\n\n\t\tverify(delegate, only()).getDefaultTempDirFactorySupplier();\n\t}",
    "comment": "call `cache.getDefaultTempDirFactorySupplier()` twice to verify the delegate method is called only once."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/AbstractTestDescriptorTests.java",
    "type": "method",
    "name": "initTree",
    "code": "void initTree() {\n\t\tengineDescriptor = new EngineDescriptor(UniqueId.forEngine(\"testEngine\"), \"testEngine\");\n\t\tgroup1 = new GroupDescriptor(UniqueId.root(\"group\", \"group1\"));\n\t\tengineDescriptor.addChild(group1);\n\t\tvar group2 = new GroupDescriptor(UniqueId.root(\"group\", \"group2\"));\n\t\tengineDescriptor.addChild(group2);\n\t\tgroup11 = new GroupDescriptor(UniqueId.root(\"group\", \"group1-1\"));\n\t\tgroup1.addChild(group11);\n\n\t\tgroup1.addChild(new LeafDescriptor(UniqueId.root(\"leaf\", \"leaf1-1\")));\n\t\tgroup1.addChild(new LeafDescriptor(UniqueId.root(\"leaf\", \"leaf1-2\")));\n\n\t\tgroup2.addChild(new LeafDescriptor(UniqueId.root(\"leaf\", \"leaf2-1\")));\n\n\t\tleaf111 = new LeafDescriptor(UniqueId.root(\"leaf\", \"leaf11-1\"));\n\t\tgroup11.addChild(leaf111);\n\t}",
    "comment": "Unit tests for {@link AbstractTestDescriptor} and {@link EngineDescriptor}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "container",
    "code": "public static Condition<Event> container(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\treturn container(clazz.getName());\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\na {@linkplain TestDescriptor#isContainer() container} and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the\nfully qualified name of the supplied {@link Class}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(int expected, Integer actual, String message) {\n\t\tAssertEquals.assertEquals((Integer) expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(boolean condition, Supplier<String> messageSupplier) {\n\t\tAssertFalse.assertFalse(condition, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that the supplied {@code condition} is {@code false}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/PartitionReader.java",
    "type": "method",
    "name": "currentMetricsValues",
    "code": "default CustomTaskMetric[] currentMetricsValues() {\n    CustomTaskMetric[] NO_METRICS = {};\n    return NO_METRICS;\n  }",
    "comment": "Returns an array of custom task metrics. By default it returns empty array. Note that it is\nnot recommended to put heavy logic in this method as it may affect reading performance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "trimLeft",
    "code": "public UTF8String trimLeft(UTF8String trimString) {\n    if (trimString == null) return null;\n    // the searching byte position in the source string\n    int searchIdx = 0;\n    // the first beginning byte position of a non-matching character\n    int trimIdx = 0;\n\n    while (searchIdx < numBytes) {\n      UTF8String searchChar = copyUTF8String(\n          searchIdx, searchIdx + numBytesForFirstByte(this.getByte(searchIdx)) - 1);\n      int searchCharBytes = searchChar.numBytes;\n      // try to find the matching for the searchChar in the trimString set\n      if (trimString.find(searchChar, 0) >= 0) {\n        trimIdx += searchCharBytes;\n      } else {\n        // no matching, exit the search\n        break;\n      }\n      searchIdx += searchCharBytes;\n    }\n    if (searchIdx == 0) {\n      // Nothing trimmed\n      return this;\n    }\n    if (trimIdx >= numBytes) {\n      // Everything trimmed\n      return EMPTY_UTF8;\n    }\n    return copyUTF8String(trimIdx, numBytes - 1);\n  }",
    "comment": "Trims instances of the given trim string from the start of this string.\n\n@param trimString the trim character string\n@return this string with no occurrences of the trim string at the start, or `null`\nif `trimString` is `null`"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/migrationsupport/rules/ExternalResourceSupportForMixedMethodAndFieldRulesTests.java",
    "type": "method",
    "name": "constructorsAndBeforeEachMethodsOfAllRulesWereExecuted",
    "code": "void constructorsAndBeforeEachMethodsOfAllRulesWereExecuted() {\n\t\tassertThat(initEvents).hasSize(4);\n\t\tassertThat(initEvents.subList(0, 2)).allMatch(item -> item.startsWith(\"fieldRule\"));\n\t\tassertThat(initEvents.subList(2, 4)).allMatch(item -> item.startsWith(\"methodRule\"));\n\t\tassertEquals(asList(initEvents.get(1), initEvents.get(0), initEvents.get(3), initEvents.get(2)), beforeEvents);\n\t}",
    "comment": "the order of fields and methods is not stable, but fields are initialized before methods are called\nbeforeEach methods of rules from fields are run before those from methods but in reverse order of instantiation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/ConfigurationParameters.java",
    "type": "method",
    "name": "get",
    "code": "default <T> Optional<T> get(String key, Function<String, T> transformer) {\n\t\tPreconditions.notNull(transformer, \"transformer must not be null\");\n\t\treturn get(key).map(input -> {\n\t\t\ttry {\n\t\t\t\treturn transformer.apply(input);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tString message = String.format(\n\t\t\t\t\t\"Failed to transform configuration parameter with key '%s' and initial value '%s'\", key, input);\n\t\t\t\tthrow new JUnitException(message, ex);\n\t\t\t}\n\t\t});\n\t}",
    "comment": "Get and transform the configuration parameter stored under the specified\n{@code key} using the specified {@code transformer}.\n\n<p>If no such key is present in this {@code ConfigurationParameters},\nan attempt will be made to look up the value as a JVM system property.\nIf no such system property exists, an attempt will be made to look up\nthe value in the {@linkplain #CONFIG_FILE_NAME JUnit Platform properties\nfile}.\n\n<p>In case the transformer throws an exception, it will be wrapped in a\n{@link JUnitException} with a helpful message.\n\n@param key the key to look up; never {@code null} or blank\n@param transformer the transformer to apply in case a value is found;\nnever {@code null}\n@return an {@code Optional} containing the value; never {@code null}\nbut potentially empty\n\n@since 1.3\n@see #getBoolean(String)\n@see System#getProperty(String)\n@see #CONFIG_FILE_NAME"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/injection/sample/NumberParameterResolver.java",
    "type": "method",
    "name": "supportsParameter",
    "code": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn Number.class.isAssignableFrom(parameterContext.getParameter().getType());\n\t}",
    "comment": "This is a non-realistic {@link ParameterResolver} that claims to\nresolve any {@link Number}, when in fact it always resolves an {@link Integer}.\n\n<p>This may appear nonsensical; however, there are use cases for which a\nresolver may think that it can support a particular parameter only to\ndiscover later that the actual resolved value is not assignment compatible.\n\n<p>For example, consider the case with Spring: the {@code SpringExtension} can\ntheoretically resolve any type of {@code ApplicationContext}, but if the\nrequired parameter type is {@code WebApplicationContext} and the user\nneglects to annotate the test class with {@code @WebAppConfiguration} then\nthe {@code ApplicationContext} loaded by Spring's testing support will in\nfact be an {@code ApplicationContext} but not a {@code WebApplicationContext}.\nSince Spring does not determine this in advance, such a scenario would lead to\nan {@link IllegalArgumentException} with the message \"argument type mismatch\"\nwhen JUnit attempts to invoke the test method.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/serialized-entity/src/test/java/com/iluwatar/serializedentity/AppTest.java",
    "type": "method",
    "name": "shouldExecuteSerializedEntityWithoutException",
    "code": "void shouldExecuteSerializedEntityWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "selectors",
    "code": "public Builder selectors(DiscoverySelector... selectors) {\n\t\t\tthis.requestBuilder.selectors(selectors);\n\t\t\treturn this;\n\t\t}",
    "comment": "Add all of the supplied {@linkplain DiscoverySelector discovery selectors}.\n\n<p>Built-in discovery selectors can be created via the static factory\nmethods in {@link org.junit.platform.engine.discovery.DiscoverySelectors}.\n\n@param selectors the discovery selectors to add; never {@code null}\n@return this builder for method chaining\n@see #filters(Filter...)\n@see #configurationParameter(String, String)\n@see #configurationParameters(Map)\n@see #execute()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static <T> Constant<T> create(Scope scope, Object object, Class<T> type) {\n    try (Tensor<T> value = Tensor.create(object, type)) {\n      return createWithTensor(scope, value);\n    }\n  }",
    "comment": "Create a constant from a Java object.\n\n<p>The argument {@code object} is first converted into a Tensor using {@link\norg.tensorflow.Tensor#create(Object)}, so only Objects supported by this method must be\nprovided. For example:\n\n<pre>{@code\nConstant.create(scope, new int[]{{1, 2}, {3, 4}}, Integer.class); // returns a 2x2 integer matrix\n\n@param scope is a scope used to add the underlying operation.\n@param object a Java object representing the constant.\n@return a constant of type `type`\n@see org.tensorflow.Tensor#create(Object) Tensor.create"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/cache/SoftIdentityMap.java",
    "type": "method",
    "name": "computeIfAbsent",
    "code": "public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n        Objects.requireNonNull(key);\n        Objects.requireNonNull(mappingFunction);\n\n        while (true) {\n            expungeStaleEntries();\n\n            SoftIdentityReference<K> softKey = new SoftIdentityReference<>(key, keyQueue);\n\n            ComputeReference<V> valueRef = map.get(softKey);\n            if (valueRef != null && !valueRef.computing) {\n                V value = valueRef.get();\n                if (value != null) {\n                    return value;\n                }\n                map.remove(softKey, valueRef);\n            }\n\n            ComputeReference<V> computingRef = ComputeReference.computing(valueQueue);\n            valueRef = map.putIfAbsent(softKey, computingRef);\n\n            if (valueRef == null) {\n                try {\n                    V newValue = mappingFunction.apply(key);\n                    if (newValue == null) {\n                        map.remove(softKey, computingRef);\n                        return null;\n                    }\n\n                    ComputeReference<V> newValueRef = new ComputeReference<>(newValue, valueQueue);\n                    map.replace(softKey, computingRef, newValueRef);\n                    return newValue;\n                } catch (Throwable t) {\n                    map.remove(softKey, computingRef);\n                    throw t;\n                }\n            } else if (!valueRef.computing) {\n                V value = valueRef.get();\n                if (value != null) {\n                    return value;\n                }\n                if (map.remove(softKey, valueRef)) {\n                    continue;\n                }\n            }\n        }\n    }",
    "comment": "Try to get existing value\nValue was GC'd, remove it\nTry to claim computation\nWe claimed the computation\nAnother thread has a value\nValue was GC'd\nAnother thread is computing or the reference changed, try again"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnenc/goals/Diag.java",
    "type": "method",
    "name": "Diag",
    "code": "public Diag(MessageBuilderFactory messageBuilderFactory, SecDispatcher secDispatcher) {\n        super(messageBuilderFactory, secDispatcher);\n    }",
    "comment": "The \"diag\" goal. It should always run, despite it overrides configured goal support."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "parseAll",
    "code": "public static Stream<? extends DiscoverySelector> parseAll(String... identifiers) {\n\t\treturn DiscoverySelectorIdentifierParsers.parseAll(identifiers);\n\t}",
    "comment": "Parse the supplied string representations of\n{@link DiscoverySelectorIdentifier DiscoverySelectorIdentifiers}.\n\n@param identifiers the string representations of\n{@code DiscoverySelectorIdentifiers} to parse; never {@code null}\n@return a stream of the corresponding {@link DiscoverySelector DiscoverySelectors};\nnever {@code null} but potentially empty\n@since 1.11\n@see DiscoverySelectorIdentifierParser"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expressions.java",
    "type": "method",
    "name": "literal",
    "code": "public static <T> Literal<T> literal(T value) {\n    return LogicalExpressions.literal(value);\n  }",
    "comment": "Create a literal from a value.\n<p>\nThe JVM type of the value held by a literal must be the type used by Spark's InternalRow API\nfor the literal's {@link DataType SQL data type}.\n\n@param value a value\n@param <T> the JVM type of the value\n@return a literal expression for the value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceContentProviderSample/app/src/main/java/com/example/android/contentprovidersample/data/SampleDatabase.java",
    "type": "method",
    "name": "populateInitialData",
    "code": "private void populateInitialData() {\n        if (cheese().count() == 0) {\n            runInTransaction(new Runnable() {\n                }\n            });\n        }",
    "comment": "Inserts the dummy data into the database if it is currently empty."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "writeToMemory",
    "code": "public void writeToMemory(Object target, long targetOffset) {\n    Platform.copyMemory(base, offset, target, targetOffset, numBytes);\n  }",
    "comment": "Writes the content of this string into a memory address, identified by an object and an offset.\nThe target memory address must already been allocated, and have enough space to hold all the\nbytes in this string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/layered-architecture/src/test/java/com/iluwatar/layers/exception/CakeBakingExceptionTest.java",
    "type": "method",
    "name": "testConstructorWithMessage",
    "code": "void testConstructorWithMessage() {\n    final var expectedMessage = \"message\";\n    final var exception = new CakeBakingException(expectedMessage);\n    assertEquals(\n        expectedMessage,\n        exception.getMessage(),\n        \"The stored message should match the expected message.\");\n    assertNull(\n        exception.getCause(),\n        \"The cause should be null when an exception is created with only a message.\");\n  }",
    "comment": "Tests the constructor of {@link CakeBakingException} that accepts a message. Ensures that an\nexception created with this constructor correctly stores the provided message and has {@code\nnull} as its cause."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionProfileActivator.java",
    "type": "method",
    "name": "doGetProperty",
    "code": "static String doGetProperty(ProfileActivationContext context, String name) {\n        if (\"project.basedir\".equals(name)) {\n            return context.getModelBaseDirectory();\n        }\n        if (\"project.rootDirectory\".equals(name)) {\n            return context.getModelRootDirectory();\n        }\n        if (\"project.artifactId\".equals(name)) {\n            return context.getModelArtifactId();\n        }\n        if (\"project.packaging\".equals(name)) {\n            return context.getModelPackaging();\n        }\n\n        String v = context.getUserProperty(name);\n        if (v == null) {\n            v = context.getModelProperty(name);\n        }\n        if (v == null) {\n            v = context.getSystemProperty(name);\n        }\n        return v;\n    }",
    "comment": "Handle special project-related properties\nCheck user properties\nCheck project properties\nTODO: this may leads to instability between file model activation and effective model activation\nas the effective model properties may be different from the file model\nCheck system properties"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/scope/internal/MojoExecutionScope.java",
    "type": "method",
    "name": "getProvidedListeners",
    "code": "private Collection<WeakMojoExecutionListener> getProvidedListeners() {\n        IdentityHashMap<WeakMojoExecutionListener, Object> listeners = new IdentityHashMap<>();\n        for (Object provided : getScopeState().provided()) {\n            if (provided instanceof WeakMojoExecutionListener weakMojoExecutionListener) {\n                listeners.put(weakMojoExecutionListener, null);\n            }\n        }\n        return listeners.keySet();\n    }",
    "comment": "the same instance can be provided multiple times under different Key's\ndeduplicate instances to avoid redundant beforeXXX/afterXXX callbacks"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/DefaultLifecycles.java",
    "type": "method",
    "name": "getPhaseToLifecycleMap",
    "code": "public Map<String, Lifecycle> getPhaseToLifecycleMap() {\n        if (logger.isDebugEnabled() && !lifecyclesPrinted) {\n            for (Lifecycle lifecycle : getLifeCycles()) {\n                logger.debug(\"Lifecycle {}\", lifecycle);\n            }\n            lifecyclesPrinted = true;\n        }\n\n        // If people are going to make their own lifecycles then we need to tell people how to namespace them correctly\n        // so that they don't interfere with internally defined lifecycles.\n\n        Map<String, Lifecycle> phaseToLifecycleMap = new HashMap<>();\n\n        for (Lifecycle lifecycle : getLifeCycles()) {\n            for (String phase : lifecycle.getPhases()) {\n                // The first definition wins.\n                Lifecycle original = phaseToLifecycleMap.put(phase, lifecycle);\n                if (original != null && logger.isWarnEnabled()) {\n                    logger.warn(\n                            \"Duplicated lifecycle phase {}. Defined in {} but also in {}\",\n                            phase,\n                            original.getId(),\n                            lifecycle.getId());\n                }\n            }\n            if (lifecycle.getDelegate() != null) {\n                for (org.apache.maven.api.Lifecycle.Alias alias :\n                        lifecycle.getDelegate().aliases()) {\n                    Lifecycle original = phaseToLifecycleMap.put(alias.v3Phase(), lifecycle);\n                    if (original != null && logger.isWarnEnabled()) {\n                        logger.warn(\n                                \"Duplicated lifecycle phase {}. Defined in {} but also in {}\",\n                                alias.v3Phase(),\n                                original.getId(),\n                                lifecycle.getId());\n                    }\n                }\n            }\n        }\n\n        return phaseToLifecycleMap;\n    }",
    "comment": "We use this to map all phases to the lifecycle that contains it. This is used so that a user can specify the\nphase they want to execute, and we can easily determine what lifecycle we need to run.\n\n@return A map of lifecycles, indexed on id"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dependency-injection/src/test/java/com/iluwatar/dependency/injection/AdvancedWizardTest.java",
    "type": "method",
    "name": "testSmokeEveryThing",
    "code": "void testSmokeEveryThing() {\n\n    List<Tobacco> tobaccos =\n        List.of(new OldTobyTobacco(), new RivendellTobacco(), new SecondBreakfastTobacco());\n\n    // Verify if the wizard is smoking the correct tobacco ...\n    tobaccos.forEach(\n        tobacco -> {\n          final AdvancedWizard advancedWizard = new AdvancedWizard(tobacco);\n          advancedWizard.smoke();\n          String lastMessage = appender.getLastMessage();\n          assertEquals(\"AdvancedWizard smoking \" + tobacco.getClass().getSimpleName(), lastMessage);\n        });\n\n    // ... and nothing else is happening.\n    assertEquals(tobaccos.size(), appender.getLogSize());\n  }",
    "comment": "Test if the {@link AdvancedWizard} smokes whatever instance of {@link Tobacco} is passed to him\nthrough the constructor parameter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/Scan.java",
    "type": "method",
    "name": "toMicroBatchStream",
    "code": "default MicroBatchStream toMicroBatchStream(String checkpointLocation) {\n    throw new SparkUnsupportedOperationException(\n      \"_LEGACY_ERROR_TEMP_3148\", Map.of(\"description\", description()));\n  }",
    "comment": "Returns the physical representation of this scan for streaming query with micro-batch mode. By\ndefault this method throws exception, data sources must overwrite this method to provide an\nimplementation, if the {@link Table} that creates this scan returns\n{@link TableCapability#MICRO_BATCH_READ} support in its {@link Table#capabilities()}.\n\n@param checkpointLocation a path to Hadoop FS scratch space that can be used for failure\nrecovery. Data streams for the same logical source in the same query\nwill be given the same checkpointLocation.\n\n@throws UnsupportedOperationException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n    graphRef.close();\n    synchronized (nativeHandleLock) {\n      if (nativeHandle == 0) {\n        return;\n      }\n      while (numActiveRuns > 0) {\n        try {\n          nativeHandleLock.wait();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          // Possible leak of the Session and Graph in this case?\n          return;\n        }\n      }\n      delete(nativeHandle);\n      nativeHandle = 0;\n    }\n  }",
    "comment": "Release resources associated with the Session.\n\n<p>Blocks until there are no active executions ({@link Session.Runner#run()} calls). A Session\nis not usable after close returns."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testBagMultiply",
    "code": "public void testBagMultiply() {\n        IMoney expected = MoneyBag.create(new Money(24, \"CHF\"), new Money(14, \"USD\"));\n        assertEquals(expected, fMB1.multiply(2));\n        assertEquals(fMB1, fMB1.multiply(1));\n        assertTrue(fMB1.multiply(0).isZero());\n    }",
    "comment": "{[12 CHF][7 USD]} *2 == {[24 CHF][14 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/MethodSourceTests.java",
    "type": "method",
    "name": "instantiatingWithNullNamesShouldThrowPreconditionViolationException",
    "code": "void instantiatingWithNullNamesShouldThrowPreconditionViolationException() {\n\t\tassertThrows(PreconditionViolationException.class, () -> MethodSource.from(\"foo\", null));\n\t\tassertThrows(PreconditionViolationException.class, () -> MethodSource.from(null, \"foo\"));\n\t}",
    "comment": "Unit tests for {@link MethodSource}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/Truck.java",
    "type": "method",
    "name": "setLoadCapacity",
    "code": "public void setLoadCapacity(double capacity) {\n    if (capacity <= 0) {\n      throw new IllegalArgumentException(\"Load capacity must be positive.\");\n    }\n    this.loadCapacity = capacity;\n  }",
    "comment": "Sets the load capacity of the truck.\n\n@param capacity the new load capacity"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ModuleUtils.java",
    "type": "method",
    "name": "findAllNonSystemBootModuleNames",
    "code": "public static Set<String> findAllNonSystemBootModuleNames() {\n\t\tlogger.config(() -> \"Basic version of findAllNonSystemBootModuleNames() always returns an empty set!\");\n\t\treturn emptySet();\n\t}",
    "comment": "Find all non-system boot modules names.\n\n@return a set of all such module names; never {@code null} but\npotentially empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/connector/catalog/functions/JavaRandomAdd.java",
    "type": "method",
    "name": "JavaRandomAdd",
    "code": "public JavaRandomAdd(BoundFunction fn) {\n    this.fn = fn;\n  }",
    "comment": "Test V2 function which add a random number to the input integer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/extensions/TestDecorator.java",
    "type": "method",
    "name": "TestDecorator",
    "code": "public TestDecorator(Test test) {\n        fTest = test;\n    }",
    "comment": "A Decorator for Tests. Use TestDecorator as the base class for defining new\ntest decorators. Test decorator subclasses can be introduced to add behaviour\nbefore or after a test is run."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/logging/LoggerFactory.java",
    "type": "method",
    "name": "addListener",
    "code": "public static void addListener(LogRecordListener listener) {\n\t\tlisteners.add(listener);\n\t}",
    "comment": "Add the supplied {@link LogRecordListener} to the set of registered\nlisteners."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Boolean> create(Scope scope, boolean data) {\n    return create(scope, data, Boolean.class);\n  }",
    "comment": "Creates a constant containing a single {@code boolean} element.\n\n@param scope is a scope used to add the underlying operation.\n@param data The value to put into the new constant.\n@return a boolean constant"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/Lifecycle.java",
    "type": "method",
    "name": "getId",
    "code": "public String getId() {\n        return this.id;\n    } // -- String getId()",
    "comment": "Get the ID of this lifecycle, for identification in the mojo\ndescriptor.\n\n@return String"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProjectActivation.java",
    "type": "method",
    "name": "activateOptionalProjectNonRecursive",
    "code": "public void activateOptionalProjectNonRecursive(String selector) {\n        this.activations.add(new ProjectActivationSettings(selector, ActivationSettings.of(true, true, false)));\n    }",
    "comment": "Mark a project as optional and activated.\n@param selector The selector of the project."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "cursorDown",
    "code": "public Ansi cursorDown(final int y) {\n        return y > 0 ? appendEscapeSequence('B', y) : y < 0 ? cursorUp(-y) : this;\n    }",
    "comment": "Moves the cursor down. If the parameter y is negative it moves the cursor up.\n\n@param y the number of lines to move down\n@return this Ansi instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassNameFilter.java",
    "type": "method",
    "name": "includeClassNamePatterns",
    "code": "static ClassNameFilter includeClassNamePatterns(String... patterns) {\n\t\treturn new IncludeClassNameFilter(patterns);\n\t}",
    "comment": "Create a new <em>include</em> {@link ClassNameFilter} based on the\n@see Class#getName()\n@see #excludeClassNamePatterns(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/ComparisonFailure.java",
    "type": "method",
    "name": "getMessage",
    "code": "public String getMessage() {\n        return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n    }",
    "comment": "Returns \"...\" in place of common prefix and \"...\" in\nplace of common suffix between expected and actual.\n\n@see Throwable#getMessage()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Long unexpected, long actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Long) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/ServiceOperations.java",
    "type": "method",
    "name": "deploy",
    "code": "public static void deploy(Service service, HiveConf configuration) {\n    init(service, configuration);\n    start(service);\n  }",
    "comment": "Initialize then start a service.\n\nThe service state is checked <i>before</i> the operation begins.\nThis process is <i>not</i> thread safe.\n@param service a service that must be in the state\n{@link Service.STATE#NOTINITED}\n@param configuration the configuration to initialize the service with\n@throws RuntimeException on a state change failure\n@throws IllegalStateException if the service is in the wrong state"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/sub/AlwaysDisabledCondition.java",
    "type": "method",
    "name": "evaluateExecutionCondition",
    "code": "public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {\n\t\treturn ConditionEvaluationResult.disabled(\"Always Disabled\");\n\t}",
    "comment": "Intentionally in a subpackage in order to properly test deactivation\nof conditions based on patterns. In other words, we do not want this\ncondition declared in the same package as the\n{@link org.junit.jupiter.engine.extension.DisabledCondition}\n\nExecutionCondition always returns disabled, since we want to test the\ndeactivation of the condition itself.\n\n@since 5.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getFloat",
    "code": "public float getFloat() {\n    return VariantUtil.getFloat(value, pos);\n  }",
    "comment": "Get a float value from the variant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/subclass-sandbox/src/main/java/com/iluwatar/subclasssandbox/Superpower.java",
    "type": "method",
    "name": "move",
    "code": "protected void move(double x, double y, double z) {\n    logger.info(\"Move to ( {}, {}, {} )\", x, y, z);\n  }",
    "comment": "Move to (x, y, z).\n\n@param x X coordinate.\n@param y Y coordinate.\n@param z Z coordinate."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/SupportsCatalogOptions.java",
    "type": "method",
    "name": "extractTimeTravelVersion",
    "code": "default Optional<String> extractTimeTravelVersion(CaseInsensitiveStringMap options) {\n    return Optional.empty();\n  }",
    "comment": "Extracts the version string for time travel from the given options."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/io/ReadAheadInputStream.java",
    "type": "method",
    "name": "swapBuffers",
    "code": "private void swapBuffers() {\n    ByteBuffer temp = activeBuffer;\n    activeBuffer = readAheadBuffer;\n    readAheadBuffer = temp;\n  }",
    "comment": "flip the active and read ahead buffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/NumericHistogram.java",
    "type": "method",
    "name": "compareTo",
    "code": "public int compareTo(Coord other) {\n      return Double.compare(x, other.x);\n    }",
    "comment": "The Coord class defines a histogram bin, which is just an (x,y) pair.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expressions.java",
    "type": "method",
    "name": "hours",
    "code": "public static Transform hours(String column) {\n    return LogicalExpressions.hours(Expressions.column(column));\n  }",
    "comment": "Create an hourly transform for a timestamp column.\n<p>\nThis transform represents a logical mapping from a timestamp to a date and hour, such as\n2018-05-13, hour 19.\n<p>\nThe name reported by transforms created with this method is \"hours\".\n\n@param column an input timestamp column\n@return a logical hourly transform with name \"hours\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/TransportContext.java",
    "type": "method",
    "name": "createChannelHandler",
    "code": "private TransportChannelHandler createChannelHandler(Channel channel, RpcHandler rpcHandler) {\n    TransportResponseHandler responseHandler = new TransportResponseHandler(channel);\n    TransportClient client = new TransportClient(channel, responseHandler);\n    boolean separateChunkFetchRequest = conf.separateChunkFetchRequest();\n    ChunkFetchRequestHandler chunkFetchRequestHandler = null;\n    if (!separateChunkFetchRequest) {\n      chunkFetchRequestHandler = new ChunkFetchRequestHandler(\n        client, rpcHandler.getStreamManager(),\n        conf.maxChunksBeingTransferred(), false /* syncModeEnabled */);\n    }\n    TransportRequestHandler requestHandler = new TransportRequestHandler(channel, client,\n      rpcHandler, conf.maxChunksBeingTransferred(), chunkFetchRequestHandler);\n    return new TransportChannelHandler(client, responseHandler, requestHandler,\n      conf.connectionTimeoutMs(), separateChunkFetchRequest, closeIdleConnections, this);\n  }",
    "comment": "Creates the server- and client-side handler which is used to handle both RequestMessages and\nResponseMessages. The channel is expected to have been successfully created, though certain\nproperties (such as the remoteAddress()) may not be available yet."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/Interpolator.java",
    "type": "method",
    "name": "interpolate",
    "code": "default String interpolate(@Nullable String val, @Nullable UnaryOperator<String> callback) {\n        return interpolate(val, callback, false);\n    }",
    "comment": "Interpolates a single string value using the provided callback function.\nThis method defaults to not replacing unresolved placeholders.\n\n@param val The string to be interpolated.\n@param callback The function to resolve variable values.\n@return The interpolated string, or null if the input was null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/launcher/SparkLauncherSuite.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n      assertNotEquals(0, args.length);\n      assertEquals(\"hello\", args[0]);\n      throw DUMMY_EXCEPTION;\n    }",
    "comment": "Similar to {@link InProcessTestApp} except it throws an exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "withAfterClasses",
    "code": "protected Statement withAfterClasses(Statement statement) {\n        List<FrameworkMethod> afters = testClass\n                .getAnnotatedMethods(AfterClass.class);\n        return afters.isEmpty() ? statement :\n                new RunAfters(statement, afters, null);\n    }",
    "comment": "Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\nand superclasses after executing {@code statement}; all AfterClass methods are\nalways executed: exceptions thrown by previous steps are combined, if\nnecessary, with exceptions from AfterClass methods into a\n{@link org.junit.runners.model.MultipleFailureException}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java",
    "type": "method",
    "name": "publishReportEntry",
    "code": "default void publishReportEntry(String key, String value) {\n\t\tthis.publishReportEntry(Collections.singletonMap(key, value));\n\t}",
    "comment": "Publish the specified key-value pair to be consumed by an\n{@code org.junit.platform.engine.EngineExecutionListener} in order to\nsupply additional information to the reporting infrastructure.\n\n@param key the key of the published pair; never {@code null} or blank\n@param value the value of the published pair; never {@code null} or blank\n@see #publishReportEntry(Map)\n@see #publishReportEntry(String)\n@see org.junit.platform.engine.EngineExecutionListener#reportingEntryPublished"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/hive/JavaSparkHiveExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    String warehouseLocation = new File(\"spark-warehouse\").getAbsolutePath();\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"Java Spark Hive Example\")\n      .config(\"spark.sql.warehouse.dir\", warehouseLocation)\n      .enableHiveSupport()\n      .getOrCreate();\n\n    spark.sql(\"CREATE TABLE IF NOT EXISTS src (key INT, value STRING) USING hive\");\n    spark.sql(\"LOAD DATA LOCAL INPATH 'examples/src/main/resources/kv1.txt' INTO TABLE src\");\n\n    spark.sql(\"SELECT * FROM src\").show();\n\n    spark.sql(\"SELECT COUNT(*) FROM src\").show();\n\n    Dataset<Row> sqlDF = spark.sql(\"SELECT key, value FROM src WHERE key < 10 ORDER BY key\");\n\n    Dataset<String> stringsDS = sqlDF.map(\n        (MapFunction<Row, String>) row -> \"Key: \" + row.get(0) + \", Value: \" + row.get(1),\n        Encoders.STRING());\n    stringsDS.show();\n\n    List<Record> records = new ArrayList<>();\n    for (int key = 1; key < 100; key++) {\n      Record record = new Record();\n      record.setKey(key);\n      record.setValue(\"val_\" + key);\n      records.add(record);\n    }\n    Dataset<Row> recordsDF = spark.createDataFrame(records, Record.class);\n    recordsDF.createOrReplaceTempView(\"records\");\n\n    spark.sql(\"SELECT * FROM records r JOIN src s ON r.key = s.key\").show();\n\n    spark.stop();\n  }",
    "comment": "$example off:spark_hive$\n$example on:spark_hive$\nwarehouseLocation points to the default location for managed databases and tables\nQueries are expressed in HiveQL\n+---+-------+\n|key|  value|\n+---+-------+\n|238|val_238|\n| 86| val_86|\n|311|val_311|\n...\nAggregation queries are also supported.\n+--------+\n|count(1)|\n+--------+\n|    500 |\n+--------+\nThe results of SQL queries are themselves DataFrames and support all normal functions.\nThe items in DataFrames are of type Row, which lets you to access each column by ordinal.\n+--------------------+\n|               value|\n+--------------------+\n|Key: 0, Value: val_0|\n|Key: 0, Value: val_0|\n|Key: 0, Value: val_0|\n...\nYou can also use DataFrames to create temporary views within a SparkSession.\nQueries can then join DataFrames data with data stored in Hive.\n+---+------+---+------+\n|key| value|key| value|\n+---+------+---+------+\n|  2| val_2|  2| val_2|\n|  2| val_2|  2| val_2|\n|  4| val_4|  4| val_4|\n...\n$example off:spark_hive$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/runner/TextRunnerSingleMethodTest.java",
    "type": "method",
    "name": "testWasInvoked",
    "code": "public void testWasInvoked() {\n            TextRunnerSingleMethodTest.fgWasInvoked = true;\n        }",
    "comment": "Test invoking a single test method of a TestCase."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuilder.java",
    "type": "method",
    "name": "interpolateModel",
    "code": "private Model interpolateModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\n        List<Profile> originalProfiles = getProfiles(model);\n\n        Model interpolatedModel =\n                modelInterpolator.interpolateModel(model, model.getProjectDirectory(), request, problems);\n        if (interpolatedModel.getParent() != null) {\n            StringSearchInterpolator ssi = new StringSearchInterpolator();\n            ssi.addValueSource(new MapBasedValueSource(request.getUserProperties()));\n\n            ssi.addValueSource(new MapBasedValueSource(model.getProperties()));\n\n            ssi.addValueSource(new MapBasedValueSource(request.getSystemProperties()));\n\n            try {\n                String interpolated =\n                        ssi.interpolate(interpolatedModel.getParent().getVersion());\n                interpolatedModel.getParent().setVersion(interpolated);\n            } catch (Exception e) {\n                ModelProblemCollectorRequest mpcr = new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE)\n                        .setMessage(\"Failed to interpolate field: \"\n                                + interpolatedModel.getParent().getVersion()\n                                + \" on class: \")\n                        .setException(e);\n                problems.add(mpcr);\n            }\n        }\n        interpolatedModel.setPomFile(model.getPomFile());\n\n        List<Profile> interpolatedProfiles = model.getProfiles();\n        IntStream.range(0, interpolatedProfiles.size()).forEach(i -> interpolatedProfiles\n                .get(i)\n                .setActivation(originalProfiles.get(i).getActivation()));\n\n        return interpolatedModel;\n    }",
    "comment": "save profile activations before interpolation, since they are evaluated with limited scope\nrestore profiles with any activation to their value before full interpolation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "engine",
    "code": "public static Condition<Event> engine() {\n\t\treturn new Condition<>(byTestDescriptor(EngineDescriptor.class::isInstance), \"is an engine\");\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\nan instance of {@link EngineDescriptor}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Short unexpected, Short actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Request.java",
    "type": "method",
    "name": "orderWith",
    "code": "public Request orderWith(Ordering ordering) {\n        return new OrderingRequest(this, ordering);\n    }",
    "comment": "Returns a Request whose Tests can be run in a certain order, defined by\n<code>ordering</code>\n<p>\nFor example, here is code to run a test suite in reverse order:\n<pre>\nprivate static Ordering reverse() {\nreturn new Ordering() {\n}\n}\n\npublic static main() {\nnew JUnitCore().run(Request.aClass(AllTests.class).orderWith(reverse()));\n}\n</pre>\n\n@return a Request with ordered Tests\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "byteStringAsKb",
    "code": "public static long byteStringAsKb(String str) {\n    return byteStringAs(str, ByteUnit.KiB);\n  }",
    "comment": "Convert a passed byte string (e.g. 50b, 100k, or 250m) to kibibytes for\ninternal use.\n\nIf no suffix is provided, the passed number is assumed to be in kibibytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/feature/Features.java",
    "type": "method",
    "name": "consumerPom",
    "code": "public static boolean consumerPom(@Nullable Properties userProperties) {\n        return doGet(userProperties, Constants.MAVEN_CONSUMER_POM, true);\n    }",
    "comment": "Check if the consumer POM feature is active."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNull",
    "code": "public static void assertNull(Object actual, String message) {\n\t\tAssertNull.assertNull(actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code actual} is {@code null}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/graph/FilteredProjectDependencyGraph.java",
    "type": "method",
    "name": "if",
    "code": "Collection<? extends MavenProject> projects, boolean transitive, boolean upstream) {\n        List<MavenProject> filtered = new ArrayList<>(projects.size());\n        for (MavenProject project : projects) {\n            if (whiteList.containsKey(project)) {\n                filtered.add(project);\n            } else if (!transitive) {\n                filtered.addAll(upstream ? getUpstreamProjects(project, false) : getDownstreamProjects(project, false));\n            }\n        }\n        return filtered;\n    }",
    "comment": "Filter out whitelisted projects with a big twist:\nAssume we have all projects {@code a, b, c} while active are {@code a, c} and relation among all projects\nis {@code a -> b -> c}. This method handles well the case for transitive list. But, for non-transitive we need\nto \"pull in\" transitive dependencies of eliminated projects, as for case above, the properly filtered list would\nbe {@code a -> c}.\n<p>\nOriginal code would falsely report {@code a} project as \"without dependencies\", basically would lose link due\nfiltering. This causes build ordering issues in concurrent builders."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng5222MojoDeprecatedTest.java",
    "type": "method",
    "name": "findDeprecationWarning",
    "code": "private List<String> findDeprecationWarning(List<String> logLines) {\n        Pattern pattern = Pattern.compile(\".* (Parameter|Goal) .* is deprecated:.*\");\n        List<String> result = new ArrayList<>();\n        for (String line : logLines) {\n            if (pattern.matcher(line).matches()) {\n                result.add(line);\n            }\n        }\n        return result;\n    }",
    "comment": "Test that ensures that deprecation is printed for deprecated parameter set by plugin configuration.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/AppManager.java",
    "type": "method",
    "name": "findAside",
    "code": "private UserAccount findAside(final String userId) {\n    return Optional.ofNullable(cacheStore.get(userId))\n        .or(\n            () -> {\n              Optional<UserAccount> userAccount = Optional.ofNullable(dbManager.readFromDb(userId));\n              userAccount.ifPresent(account -> cacheStore.set(userId, account));\n              return userAccount;\n            })\n        .orElse(null);\n  }",
    "comment": "Cache-Aside find user account helper.\n\n@param userId String\n@return {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(short unexpected, short actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ExecutionConditionTests.java",
    "type": "method",
    "name": "overrideConditionsUsingStar",
    "code": "void overrideConditionsUsingStar() {\n\t\tString deactivatePattern = \"*\";\n\t\tassertExecutionConditionOverride(deactivatePattern, 2, 2);\n\t\tassertExecutionConditionOverride(deactivatePattern, 5, 2, 3);\n\t}",
    "comment": "\"*\" should deactivate DisabledCondition and SystemPropertyCondition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java",
    "type": "method",
    "name": "evaluateExecutionCondition",
    "code": "public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {\n\t\treturn null;\n\t}",
    "comment": "--- Conditional Test Execution ------------------------------------------"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "getPayload",
    "code": "public <T> Optional<T> getPayload(Class<T> payloadType) {\n\t\tPreconditions.notNull(payloadType, \"Payload type must not be null\");\n\t\treturn getPayload().filter(payloadType::isInstance).map(payloadType::cast);\n\t}",
    "comment": "Get the payload of the expected type, if available.\n\n<p>This is a convenience method that automatically casts the payload to\nthe expected type. If the payload is not present or is not of the expected\ntype, this method will return {@link Optional#empty()}.\n\n@param payloadType the expected payload type; never {@code null}\n@return an {@code Optional} containing the payload; never {@code null}\nbut potentially empty\n@see #getPayload()\n@see #getRequiredPayload(Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java",
    "type": "method",
    "name": "alignToBaseDirectory",
    "code": "public String alignToBaseDirectory(String path, File basedir) {\n        if (basedir == null) {\n            return path;\n        }\n\n        if (path == null) {\n            return null;\n        }\n\n        String s = stripBasedirToken(path);\n\n        File file = new File(s);\n        if (file.isAbsolute()) {\n            s = file.getPath();\n        } else if (file.getPath().startsWith(File.separator)) {\n            s = file.getAbsolutePath();\n        } else {\n            s = new File(new File(basedir, s).toURI().normalize()).getAbsolutePath();\n        }\n\n        return s;\n    }",
    "comment": "path was already absolute, just normalize file separator and we're done\ndrive-relative Windows path, don't align with project directory but with drive root\nan ordinary relative path, align with project directory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/ArtifactDescriptorUtils.java",
    "type": "method",
    "name": "toPomArtifactUnconditionally",
    "code": "public static Artifact toPomArtifactUnconditionally(Artifact artifact) {\n        return new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), \"pom\", artifact.getVersion());\n    }",
    "comment": "Creates POM artifact out of passed in artifact by dropping classifier (if exists) and rewriting extension to\n\"pom\". Unconditionally, unlike {@link #toPomArtifact(Artifact)} that does this only for artifacts without\nclassifiers.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/internal/runners/statements/ExpectExceptionTest.java",
    "type": "method",
    "name": "whenExpectingAssumptionViolatedExceptionStatementsThrowingSubclassShouldPass",
    "code": "public void whenExpectingAssumptionViolatedExceptionStatementsThrowingSubclassShouldPass() {\n        Statement delegate = new Fail(new AssumptionViolatedExceptionSubclass(\"expected\"));\n        ExpectException expectException = new ExpectException(delegate, AssumptionViolatedException.class);\n\n        try {\n            expectException.evaluate();\n        } catch (Throwable e) {\n            fail(\"should not throw anything, but was thrown: \" + e);\n        }\n    }",
    "comment": "then no exception should be thrown"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExecutableInvoker.java",
    "type": "method",
    "name": "invoke",
    "code": "default Object invoke(Method method) {\n\t\treturn invoke(method, null);\n\t}",
    "comment": "Invoke the supplied {@code static} method with dynamic parameter resolution.\n\n@param method the method to invoke and resolve parameters for\n@see #invoke(Method, Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-api-gateway/api-gateway-service/src/main/java/com/iluwatar/api/gateway/ImageClientImpl.java",
    "type": "method",
    "name": "getImagePath",
    "code": "public String getImagePath() {\n\n    var httpClient = HttpClient.newHttpClient();\n    var httpGet =\n        HttpRequest.newBuilder().GET().uri(URI.create(\"http://localhost:50005/image-path\")).build();\n\n    try {\n      LOGGER.info(\"Sending request to fetch image path\");\n      var httpResponse = httpClient.send(httpGet, BodyHandlers.ofString());\n      logResponse(httpResponse);\n      return httpResponse.body();\n    } catch (IOException ioe) {\n      LOGGER.error(\"Failure occurred while getting image path\", ioe);\n    } catch (InterruptedException ie) {\n      LOGGER.error(\"Failure occurred while getting image path\", ie);\n      Thread.currentThread().interrupt();\n    }\n\n    return null;\n  }",
    "comment": "Makes a simple HTTP Get request to the Image microservice.\n\n@return The path to the image"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sharedByteBufAllocators",
    "code": "public boolean sharedByteBufAllocators() {\n    return conf.getBoolean(\"spark.network.sharedByteBufAllocators.enabled\", true);\n  }",
    "comment": "Flag indicating whether to share the pooled ByteBuf allocators between the different Netty\nchannels. If enabled then only two pooled ByteBuf allocators are created: one where caching\nis allowed (for transport servers) and one where not (for transport clients).\nWhen disabled a new allocator is created for each transport servers and clients."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "event",
    "code": "public static Condition<Event> event(Condition<? super Event>... conditions) {\n\t\treturn allOf(conditions);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/bitset/BitSetMethods.java",
    "type": "method",
    "name": "set",
    "code": "public static void set(Object baseObject, long baseOffset, int index) {\n    assert index >= 0 : \"index (\" + index + \") should >= 0\";\n    final long mask = 1L << (index & 0x3f);  // mod 64 and shift\n    final long wordOffset = baseOffset + (index >> 6) * WORD_SIZE;\n    final long word = Platform.getLong(baseObject, wordOffset);\n    Platform.putLong(baseObject, wordOffset, word | mask);\n  }",
    "comment": "Sets the bit at the specified index to {@code true}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/testFixtures/java/org/junit/platform/commons/test/TestClassLoader.java",
    "type": "method",
    "name": "TestClassLoader",
    "code": "private TestClassLoader(URL codeSourceUrl, Predicate<String> classNameFilter) {\n\t\tsuper(new URL[] { codeSourceUrl }, ClassLoaderUtils.getDefaultClassLoader());\n\n\t@Override\n\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\tsynchronized (getClassLoadingLock(name)) {\n\t\t\tClass<?> clazz = findLoadedClass(name);\n\t\t\tif (clazz != null) {\n\t\t\t\treturn clazz;\n\t\t\t}\n\t\t\treturn this.classNameFilter.test(name) ? findClass(name) : super.loadClass(name);\n\t\t}\n\t}\n\n\tprivate static URL getCodeSourceUrl(Class<?> clazz) {\n\t\treturn clazz.getProtectionDomain().getCodeSource().getLocation();\n\t}\n\n}",
    "comment": "Get the {@link CodeSource} {@link URL} of the supplied class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/project/interpolation/AbstractStringBasedModelInterpolator.java",
    "type": "method",
    "name": "AbstractStringBasedModelInterpolator",
    "code": "protected AbstractStringBasedModelInterpolator(PathTranslator pathTranslator) {\n        this.pathTranslator = pathTranslator;\n    }",
    "comment": "Use a regular expression search to find and resolve expressions within the POM.\n\nTODO Consolidate this logic with the PluginParameterExpressionEvaluator, minus deprecations/bans."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/type-object/src/main/java/com/iluwatar/typeobject/Cell.java",
    "type": "method",
    "name": "crush",
    "code": "void crush(CellPool pool, Cell[][] cellMatrix) {\n    // take out from this position and put back in pool\n    pool.addNewCell(this);\n    this.fillThisSpace(pool, cellMatrix);\n  }",
    "comment": "The Cell object is what the game matrix is made of and contains the candy which is to be crushed\nor collected as reward."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "normalizedCollationName",
    "code": "protected String normalizedCollationName() {\n        StringBuilder builder = new StringBuilder();\n        if(caseSensitivity == CaseSensitivity.UNSPECIFIED){\n          builder.append(CollationNames.UTF8_BINARY);\n        } else{\n          builder.append(CollationNames.UTF8_LCASE);\n        }\n        if (spaceTrimming != SpaceTrimming.NONE) {\n          builder.append('_');\n          builder.append(spaceTrimming.toString());\n        }\n        return builder.toString();\n      }",
    "comment": "Compute normalized collation name. Components of collation name are given in order:\n- Base collation name (UTF8_BINARY or UTF8_LCASE)\n- Optional space trimming when non-default preceded by underscore\nExamples: UTF8_BINARY, UTF8_BINARY_LCASE_LTRIM, UTF8_BINARY_TRIM."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultLifecyclePluginAnalyzer.java",
    "type": "method",
    "name": "getPluginsBoundByDefaultToAllLifecycles",
    "code": "public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles(String packaging) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Looking up lifecycle mappings for packaging \" + packaging + \" from \"\n                    + Thread.currentThread().getContextClassLoader());\n        }\n\n        LifecycleMapping lifecycleMappingForPackaging = lookupLifecycleMapping(packaging);\n\n        if (lifecycleMappingForPackaging == null) {\n            return null;\n        }\n\n        Map<Plugin, Plugin> plugins = new LinkedHashMap<>();\n\n        for (Lifecycle lifecycle : defaultLifeCycles.getLifeCycles()) {\n            org.apache.maven.lifecycle.mapping.Lifecycle lifecycleConfiguration =\n                    lifecycleMappingForPackaging.getLifecycles().get(lifecycle.getId());\n\n            Map<String, LifecyclePhase> phaseToGoalMapping = null;\n\n            if (lifecycleConfiguration != null) {\n                phaseToGoalMapping = lifecycleConfiguration.getLifecyclePhases();\n            } else if (lifecycle.getDefaultLifecyclePhases() != null) {\n                phaseToGoalMapping = lifecycle.getDefaultLifecyclePhases();\n            }\n\n            if (phaseToGoalMapping != null) {\n                for (Map.Entry<String, LifecyclePhase> goalsForLifecyclePhase : phaseToGoalMapping.entrySet()) {\n                    String phase = goalsForLifecyclePhase.getKey();\n                    LifecyclePhase goals = goalsForLifecyclePhase.getValue();\n                    if (goals != null) {\n                        parseLifecyclePhaseDefinitions(plugins, phase, goals);\n                    }\n                }\n            }\n        }\n\n        return plugins.keySet();\n    }",
    "comment": "These methods deal with construction intact Plugin object that look like they come from a standard\n<plugin/> block in a Maven POM. We have to do some wiggling to pull the sources of information\ntogether and this really shows the problem of constructing a sensible default configuration, but\nit's all encapsulated here so it appears normalized to the POM builder.\nWe are going to take the project packaging and find all plugins in the default lifecycle and create\nfully populated Plugin objects, including executions with goals and default configuration taken\nfrom the plugin.xml inside a plugin."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/Operation.java",
    "type": "method",
    "name": "isTimedOut",
    "code": "public boolean isTimedOut(long current) {\n    if (operationTimeout == 0) {\n      return false;\n    }\n    if (operationTimeout > 0) {\n      return state.isTerminal() && lastAccessTime + operationTimeout <= current;\n    }\n    return lastAccessTime + -operationTimeout <= current;\n  }",
    "comment": "check only when it's in terminal state"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaEstimatorTransformerParamExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaEstimatorTransformerParamExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Prepare training data.\n    List<Row> dataTraining = Arrays.asList(\n        RowFactory.create(1.0, Vectors.dense(0.0, 1.1, 0.1)),\n        RowFactory.create(0.0, Vectors.dense(2.0, 1.0, -1.0)),\n        RowFactory.create(0.0, Vectors.dense(2.0, 1.3, 1.0)),\n        RowFactory.create(1.0, Vectors.dense(0.0, 1.2, -0.5))\n    );\n    StructType schema = new StructType(new StructField[]{\n    Dataset<Row> training = spark.createDataFrame(dataTraining, schema);\n\n    // Create a LogisticRegression instance. This instance is an Estimator.\n    LogisticRegression lr = new LogisticRegression();\n    // Print out the parameters, documentation, and any default values.\n    System.out.println(\"LogisticRegression parameters:\\n\" + lr.explainParams() + \"\\n\");\n\n    // We may set parameters using setter methods.\n    lr.setMaxIter(10).setRegParam(0.01);\n\n    // Learn a LogisticRegression model. This uses the parameters stored in lr.\n    LogisticRegressionModel model1 = lr.fit(training);\n    // Since model1 is a Model (i.e., a Transformer produced by an Estimator),\n    // we can view the parameters it used during fit().\n    // This prints the parameter (name: value) pairs, where names are unique IDs for this\n    // LogisticRegression instance.\n    System.out.println(\"Model 1 was fit using parameters: \" + model1.parent().extractParamMap());\n\n    // We may alternatively specify parameters using a ParamMap.\n    ParamMap paramMap = new ParamMap()\n      .put(lr.maxIter().w(20))  // Specify 1 Param.\n      .put(lr.maxIter(), 30)  // This overwrites the original maxIter.\n      .put(lr.regParam().w(0.1), lr.threshold().w(0.55));  // Specify multiple Params.\n\n    // One can also combine ParamMaps.\n    ParamMap paramMap2 = new ParamMap()\n      .put(lr.probabilityCol().w(\"myProbability\"));  // Change output column name\n    ParamMap paramMapCombined = paramMap.$plus$plus(paramMap2);\n\n    // Now learn a new model using the paramMapCombined parameters.\n    // paramMapCombined overrides all parameters set earlier via lr.set* methods.\n    LogisticRegressionModel model2 = lr.fit(training, paramMapCombined);\n    System.out.println(\"Model 2 was fit using parameters: \" + model2.parent().extractParamMap());\n\n    // Prepare test documents.\n    List<Row> dataTest = Arrays.asList(\n        RowFactory.create(1.0, Vectors.dense(-1.0, 1.5, 1.3)),\n        RowFactory.create(0.0, Vectors.dense(3.0, 2.0, -0.1)),\n        RowFactory.create(1.0, Vectors.dense(0.0, 2.2, -1.5))\n    );\n    Dataset<Row> test = spark.createDataFrame(dataTest, schema);\n\n    // Make predictions on test documents using the Transformer.transform() method.\n    // LogisticRegression.transform will only use the 'features' column.\n    // Note that model2.transform() outputs a 'myProbability' column instead of the usual\n    // 'probability' column since we renamed the lr.probabilityCol parameter previously.\n    Dataset<Row> results = model2.transform(test);\n    Dataset<Row> rows = results.select(\"features\", \"label\", \"myProbability\", \"prediction\");\n    for (Row r: rows.collectAsList()) {\n      System.out.println(\"(\" + r.get(0) + \", \" + r.get(1) + \") -> prob=\" + r.get(2)\n        + \", prediction=\" + r.get(3));\n    }\n    // $example off$\n\n    spark.stop();\n  }\n}",
    "comment": "Java example for Estimator, Transformer, and Param."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isAbstract",
    "code": "public static boolean isAbstract(Member member) {\n\t\treturn ReflectionUtils.isAbstract(member);\n\t}",
    "comment": "Determine if the supplied member is {@code abstract}.\n\n@param member the class to check; never {@code null}\n@return {@code true} if the member is {@code abstract}\n@see java.lang.reflect.Modifier#isAbstract(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-configuration/src/main/java/org/apache/maven/plugin/coreit/AppendConfigMojo.java",
    "type": "method",
    "name": "dumpConfiguration",
    "code": "private void dumpConfiguration(Properties props) {\n        /*\n         * NOTE: This intentionally does not dump the absolute path of a file to check the actual value that was\n         * injected by Maven.\n         */\n        PropertiesUtil.serialize(props, \"propertiesFile\", outputFile);\n        PropertiesUtil.serialize(props, \"defaultParam\", defaultParam);\n        PropertiesUtil.serialize(props, \"stringParam\", stringParam);\n        PropertiesUtil.serialize(props, \"fileParam\", fileParam);\n        PropertiesUtil.serialize(props, \"stringParams\", stringParams);\n        PropertiesUtil.serialize(props, \"fileParams\", fileParams);\n        PropertiesUtil.serialize(props, \"listParam\", listParam);\n        PropertiesUtil.serialize(props, \"setParam\", setParam);\n        PropertiesUtil.serialize(props, \"mapParam\", mapParam);\n        PropertiesUtil.serialize(props, \"propertiesParam\", propertiesParam);\n    }",
    "comment": "Dumps the mojo configuration into the specified properties.\n\n@param props The properties to dump the configuration into, must not be <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java",
    "type": "method",
    "name": "nodeSkipped",
    "code": "public void nodeSkipped(JupiterEngineExecutionContext context, TestDescriptor descriptor, SkipResult result) {\n\t\tif (context != null) {\n\t\t\tinvokeTestWatchers(context, false,\n\t\t\t\twatcher -> watcher.testDisabled(context.getExtensionContext(), result.getReason()));\n\t\t}\n\t}",
    "comment": "Invoke {@link TestWatcher#testDisabled(ExtensionContext, Optional)} on each\nregistered {@link TestWatcher}, in registration order.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isAbstract",
    "code": "public static boolean isAbstract(Class<?> clazz) {\n\t\treturn ReflectionUtils.isAbstract(clazz);\n\t}",
    "comment": "Determine if the supplied class is {@code abstract}.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is {@code abstract}\n@see java.lang.reflect.Modifier#isAbstract(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/FailAssertionsTests.java",
    "type": "method",
    "name": "failWithoutArgument",
    "code": "void failWithoutArgument() {\n\t\ttry {\n\t\t\tfail();\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertEmptyMessage(ex);\n\t\t}\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultInterpolator.java",
    "type": "method",
    "name": "substVars",
    "code": "public String substVars(String val, String currentKey, Set<String> cycleMap, Map<String, String> configProps) {\n        return substVars(val, currentKey, cycleMap, configProps, null);\n    }",
    "comment": "<p>\nThis method performs property variable substitution on the\nspecified value. If the specified value contains the syntax\n{@code ${&lt;prop-name&gt;}}, where {@code &lt;prop-name&gt;}\nrefers to either a configuration property or a system property,\nthen the corresponding property value is substituted for the variable\nplaceholder. Multiple variable placeholders may exist in the\nspecified value as well as nested variable placeholders, which\nare substituted from innermost to outermost. Configuration\nproperties override system properties.\n</p>\n\n@param val The string on which to perform property substitution.\n@param currentKey The key of the property being evaluated used to\ndetect cycles.\n@param cycleMap Map of variable references used to detect nested cycles.\n@param configProps Set of configuration properties.\n@return The value of the specified string after system property substitution.\n@throws InterpolatorException If there was a syntax error in the\nproperty placeholder syntax or a recursive variable reference."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/MyDoubleAvg.java",
    "type": "method",
    "name": "evaluate",
    "code": "@Override public Object evaluate(Row buffer) {\n    if (buffer.isNullAt(0)) {\n      return null;\n    } else {\n      return buffer.getDouble(0) / buffer.getLong(1) + 100.0;\n    }\n  }",
    "comment": "If the bufferSum is still null, we return null because this function has not got\nany input row.\nOtherwise, we calculate the special average value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/support/scanning/DefaultClasspathScannerTests.java",
    "type": "method",
    "name": "inDefaultPackage",
    "code": "private boolean inDefaultPackage(Class<?> clazz) {\n\t\tvar pkg = clazz.getPackage();\n\t\treturn pkg == null || \"\".equals(clazz.getPackage().getName());\n\t}",
    "comment": "Abort if running on Microsoft Windows since we are testing symbolic links\nOpenJDK returns NULL for the default package."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarArray.java",
    "type": "method",
    "name": "setNullBits",
    "code": "private UnsafeArrayData setNullBits(UnsafeArrayData arrayData) {\n    if (data.hasNull()) {\n      for (int i = 0; i < length; i++) {\n        if (data.isNullAt(offset + i)) {\n          arrayData.setNullAt(i);\n        }\n      }\n    }\n    return arrayData;\n  }",
    "comment": "Sets all the appropriate null bits in the input UnsafeArrayData.\n\n@param arrayData The UnsafeArrayData to set the null bits for\n@return The UnsafeArrayData with the null bits set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "init",
    "code": "private void init(long errorHandle, long modelHandle, InterpreterImpl.Options options) {\n    if (options == null) {\n      options = new InterpreterImpl.Options();\n    }\n    if (options.getAccelerationConfig() != null) {\n      options.getAccelerationConfig().apply(options);\n    }\n    this.errorHandle = errorHandle;\n    this.modelHandle = modelHandle;\n    ArrayList<Long> delegateHandles = new ArrayList<>();\n    this.interpreterHandle =\n        createInterpreter(\n            modelHandle,\n            errorHandle,\n            options.getNumThreads(),\n            options.getUseXNNPACK(),\n            delegateHandles);\n    this.originalGraphHasUnresolvedFlexOp = hasUnresolvedFlexOp(interpreterHandle);\n    addDelegates(options);\n    initDelegatesWithInterpreterFactory();\n    delegateHandles.ensureCapacity(delegates.size());\n    for (Delegate delegate : delegates) {\n      delegateHandles.add(delegate.getNativeHandle());\n    }\n    if (!delegateHandles.isEmpty()) {\n      delete(/* errorHandle= */ 0, /* modelHandle= */ 0, this.interpreterHandle);\n      this.interpreterHandle =\n          createInterpreter(\n              modelHandle,\n              errorHandle,\n              options.getNumThreads(),\n              options.getUseXNNPACK(),\n              delegateHandles);\n    }\n    if (options.allowFp16PrecisionForFp32 != null) {\n      allowFp16PrecisionForFp32(interpreterHandle, options.allowFp16PrecisionForFp32);\n    }\n    if (options.allowBufferHandleOutput != null) {\n      allowBufferHandleOutput(interpreterHandle, options.allowBufferHandleOutput);\n    }\n    if (options.isCancellable()) {\n      this.cancellationFlagHandle = createCancellationFlag(interpreterHandle);\n    }\n    this.inputTensors = new TensorImpl[getInputCount(interpreterHandle)];\n    this.outputTensors = new TensorImpl[getOutputCount(interpreterHandle)];\n    if (options.allowFp16PrecisionForFp32 != null) {\n      allowFp16PrecisionForFp32(interpreterHandle, options.allowFp16PrecisionForFp32);\n    }\n    if (options.allowBufferHandleOutput != null) {\n      allowBufferHandleOutput(interpreterHandle, options.allowBufferHandleOutput);\n    }\n    allocateTensors(interpreterHandle, errorHandle);\n    this.isMemoryAllocated = true;\n  }",
    "comment": "Apply the validated acceleration config\nFirst create the interpreter without delegates.  We need an interpreter in order to figure\nout whether the model contains any unresolved flex ops, and creating the interpreter with\ndelegates might fail if there are any unresolved flex ops.\n(Alternatively, we could determine this without needing to recreate the interpreter\nby passing the tflite::Model in to here, and then traversing that?)\nIf there are any delegates enabled, recreate the interpreter with those delegates."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/poison-pill/src/main/java/com/iluwatar/poison/pill/Message.java",
    "type": "method",
    "name": "Message",
    "code": "new Message() {\n\n        @Override\n        public String getHeader(Headers header) {\n          throw poison();\n        }\n\n        @Override\n        public Map<Headers, String> getHeaders() {\n          throw poison();\n        }\n\n        @Override\n        public void setBody(String body) {\n          throw poison();\n        }\n\n        @Override\n        public String getBody() {\n          throw poison();\n        }\n\n        private RuntimeException poison() {\n          return new UnsupportedOperationException(\"Poison\");\n        }\n      };",
    "comment": "Interface that implements the Message pattern and represents an inbound or outbound message as\npart of an {@link Producer}-{@link Consumer} exchange."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "withClassRules",
    "code": "private Statement withClassRules(Statement statement) {\n        List<TestRule> classRules = classRules();\n        return classRules.isEmpty() ? statement :\n                new RunRules(statement, classRules, getDescription());\n    }",
    "comment": "Returns a {@link Statement}: apply all\nstatic fields assignable to {@link TestRule}\nannotated with {@link ClassRule}.\n\n@param statement the base statement\n@return a RunRules statement if any class-level {@link Rule}s are\nfound, or the base statement"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestReporter.java",
    "type": "method",
    "name": "publishDirectory",
    "code": "default void publishDirectory(String name, ThrowingConsumer<Path> action) {\n\t\tthrow new UnsupportedOperationException();\n\t}",
    "comment": "Publish a directory with the supplied name written by the supplied action\nand attach it to the current test or container.\n\n<p>The {@link Path} passed to the supplied action will be relative to the\nreport output directory and point to an existing directory, but it's up\nto the action to write files to it.\n\n@param name the name of the directory to be attached; never {@code null}\nor blank and must not contain any path separators\n@param action the action to be executed to write the file; never {@code null}\n@since 5.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/GroupStateTimeout.java",
    "type": "method",
    "name": "ProcessingTimeTimeout",
    "code": "public static GroupStateTimeout ProcessingTimeTimeout() {\n    return ProcessingTimeTimeout$.MODULE$;\n  }",
    "comment": "Timeout based on processing time.\n<p>\nThe duration of timeout can be set for each group in\n{@code map/flatMapGroupsWithState} by calling {@code GroupState.setTimeoutDuration()}.\n<p>\nSee documentation on {@code GroupState} for more details."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3746POMPropertyOverrideTest.java",
    "type": "method",
    "name": "MavenITmng3746POMPropertyOverrideTest",
    "code": "public MavenITmng3746POMPropertyOverrideTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3746\">MNG-3746</a>.\n\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/test/java/com/iluwatar/async/method/invocation/ThreadAsyncExecutorTest.java",
    "type": "method",
    "name": "testLongRunningTaskWithoutCallback",
    "code": "void testLongRunningTaskWithoutCallback() {\n    assertTimeout(\n        ofMillis(5000),\n        () -> {\n          // Instantiate a new executor and start a new 'null' task ...\n          final var executor = new ThreadAsyncExecutor();\n\n          final var result = new Object();\n          when(task.call())\n              .thenAnswer(\n                  i -> {\n                    Thread.sleep(1500);\n                    return result;\n                  });\n\n          final var asyncResult = executor.startProcess(task);\n          assertNotNull(asyncResult);\n          assertFalse(asyncResult.isCompleted());\n\n          try {\n            asyncResult.getValue();\n            fail(\n                \"Expected IllegalStateException when calling AsyncResult#getValue on a non-completed task\");\n          } catch (IllegalStateException e) {\n            assertNotNull(e.getMessage());\n          }\n\n          // Our task should only execute once, but it can take a while ...\n          verify(task, timeout(3000).times(1)).call();\n\n          // Prevent timing issues, and wait until the result is available\n          asyncResult.await();\n          assertTrue(asyncResult.isCompleted());\n          verifyNoMoreInteractions(task);\n\n          // ... and the result should be exactly the same object\n          assertSame(result, asyncResult.getValue());\n        });\n  }",
    "comment": "Test used to verify the happy path of {@link ThreadAsyncExecutor#startProcess(Callable)} when a\ntask takes a while to execute"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "uniqueId",
    "code": "public static Condition<Event> uniqueId(String uniqueId) {\n\t\treturn uniqueId(UniqueId.parse(uniqueId));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if the\n{@linkplain Event#getTestDescriptor() test descriptor} is equal to the\n{@link UniqueId} parsed from the supplied {@link String}.\n\n@since 1.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(char expected, char actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "if",
    "code": "if (filePath.contains(\"!/\")) {\n            Path basedir = Paths.get(getBasedir()).toAbsolutePath();\n            String urlString = \"jar:\" + basedir.toUri().toASCIIString() + \"/\" + filePath;\n\n            InputStream is = null;\n            try {\n                URL url = new URL(urlString);\n\n                is = url.openStream();\n\n                if (is == null) {\n                    if (wanted) {\n                        throw new VerificationException(\"Expected JAR resource was not found: \" + filePath);\n                    }\n                } else {\n                    if (!wanted) {\n                        throw new VerificationException(\"Unwanted JAR resource was found: \" + filePath);\n                    }\n                }\n            } catch (MalformedURLException e) {\n                throw new VerificationException(\"Error looking for JAR resource\", e);\n            } catch (IOException e) {\n                if (wanted) {\n                    throw new VerificationException(\"Error looking for JAR resource: \" + filePath);\n                }\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        } else {\n            File expectedFile = new File(filePath);\n\n            // NOTE: On Windows, a path with a leading (back-)slash is relative to the current drive\n            if (!expectedFile.isAbsolute() && !expectedFile.getPath().startsWith(File.separator)) {\n                expectedFile = new File(getBasedir(), filePath);\n            }\n\n            if (filePath.indexOf('*') > -1) {\n                File parent = expectedFile.getParentFile();\n\n                if (!parent.exists()) {\n                    if (wanted) {\n                        throw new VerificationException(\n                                \"Expected file pattern was not found: \" + expectedFile.getPath());\n                    }\n                } else {\n                    String shortNamePattern = expectedFile.getName().replaceAll(\"\\\\*\", \".*\");\n\n                    String[] candidates = parent.list();\n\n                    boolean found = false;\n\n                    if (candidates != null) {\n                        for (String candidate : candidates) {\n                            if (candidate.matches(shortNamePattern)) {\n                                found = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!found && wanted) {\n                        throw new VerificationException(\n                                \"Expected file pattern was not found: \" + expectedFile.getPath());\n                    } else if (found && !wanted) {\n                        throw new VerificationException(\"Unwanted file pattern was found: \" + expectedFile.getPath());\n                    }\n                }\n            } else {\n                if (!expectedFile.exists()) {\n                    if (wanted) {\n                        throw new VerificationException(\"Expected file was not found: \" + expectedFile.getPath());\n                    }\n                } else {\n                    if (!wanted) {\n                        throw new VerificationException(\"Unwanted file was found: \" + expectedFile.getPath());\n                    }\n                }\n            }\n        }",
    "comment": "Verifies that the artifact given through its Maven coordinates does not exist.\n\n@param groupId the groupId of the artifact (must not be null)\n@param artifactId the artifactId of the artifact (must not be null)\n@param version the version of the artifact (must not be null)\n@param ext the extension of the artifact (must not be null)\n@throws VerificationException if the given artifact exists"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/LevelDBTypeInfo.java",
    "type": "method",
    "name": "start",
    "code": "byte[] start(byte[] prefix, Object value) {\n      checkParent(prefix);\n      return (parent != null) ? buildKey(false, prefix, name, toKey(value))\n        : buildKey(name, toKey(value));\n    }",
    "comment": "The key where to start ascending iteration for entities whose value for the indexed field\nmatch the given value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Request.java",
    "type": "method",
    "name": "errorReport",
    "code": "public static Request errorReport(Class<?> klass, Throwable cause) {\n        return runner(new ErrorReportingRunner(klass, cause));\n    }",
    "comment": "Creates a {@link Request} that, when processed, will report an error for the given\ntest class with the given cause."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/SupportsMetadataColumns.java",
    "type": "method",
    "name": "canRenameConflictingMetadataColumns",
    "code": "default boolean canRenameConflictingMetadataColumns() { return false; }\n}",
    "comment": "Determines how this data source handles name conflicts between metadata and data columns.\n<p>\nIf true, spark will automatically rename the metadata column to resolve the conflict. End users\ncan reliably select metadata columns (renamed or not) with {@code Dataset.metadataColumn}, and\ninternal code can use {@code MetadataAttributeWithLogicalName} to extract the logical name from\na metadata attribute.\n<p>\nIf false, the data column will hide the metadata column. It is recommended that Table\nimplementations which do not support renaming should reject data column names that conflict\nwith metadata column names."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlService.java",
    "type": "method",
    "name": "getService",
    "code": "private static XmlService getService() {\n        return Holder.INSTANCE;\n    }",
    "comment": "Gets the singleton instance of the XmlService.\n\n@return the XmlService instance\n@throws IllegalStateException if no implementation is found"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/io/LocalDiskShuffleDataIO.java",
    "type": "method",
    "name": "LocalDiskShuffleDataIO",
    "code": "public LocalDiskShuffleDataIO(SparkConf sparkConf) {\n    this.sparkConf = sparkConf;\n  }",
    "comment": "Implementation of the {@link ShuffleDataIO} plugin system that replicates the local shuffle\nstorage and index file functionality that has historically been used from Spark 2.4 and earlier."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestDescriptor.java",
    "type": "method",
    "name": "orderChildren",
    "code": "default void orderChildren(UnaryOperator<List<TestDescriptor>> orderer) {\n\t\tPreconditions.notNull(orderer, \"orderer must not be null\");\n\t\tSet<? extends TestDescriptor> originalChildren = getChildren();\n\t\tList<TestDescriptor> suggestedOrder = orderer.apply(new ArrayList<>(originalChildren));\n\t\tPreconditions.notNull(suggestedOrder, \"orderer may not return null\");\n\n\t\tSet<? extends TestDescriptor> orderedChildren = new LinkedHashSet<>(suggestedOrder);\n\t\tboolean unmodified = originalChildren.equals(orderedChildren);\n\t\tPreconditions.condition(unmodified && originalChildren.size() == suggestedOrder.size(),\n\t\t\t\"orderer may not add or remove test descriptors\");\n\n\t\tsuggestedOrder.stream() //\n\t\t\t\t.distinct() //\n\t\t\t\t.filter(originalChildren::contains)//\n\t\t\t\t.forEach(testDescriptor -> {\n\t\t\t\t\tremoveChild(testDescriptor);\n\t\t\t\t\taddChild(testDescriptor);\n\t\t\t\t});\n\t}",
    "comment": "Order the children of this descriptor.\n\n<p>The {@code orderer} is provided a modifiable list of child test\ndescriptors of this test descriptor; never {@code null}. The\n{@code orderer} must return a list containing the same descriptors in any\norder; potentially the same list, but never {@code null}. If descriptors\nare added or removed, an exception is thrown.\n\n@param orderer a unary operator to order the children of this test descriptor\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/FilterResult.java",
    "type": "method",
    "name": "included",
    "code": "public static FilterResult included(String reason) {\n\t\treturn new FilterResult(true, reason);\n\t}",
    "comment": "Factory for creating <em>included</em> results.\n\n@param reason the reason why the filtered object was included\n@return an included {@code FilterResult} with the given reason"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "uniqueIdSubstrings",
    "code": "public static Condition<Event> uniqueIdSubstrings(List<String> uniqueIdSubstrings) {\n\t\t// The following worked with AssertJ 3.13.2\n\t\t// return allOf(uniqueIdSubstrings.stream().map(EventConditions::uniqueIdSubstring).collect(toList()));\n\n\t\t// Workaround for a regression in AssertJ 3.14.0 that loses the individual descriptions\n\t\t// when multiple conditions are supplied as an Iterable instead of as an array.\n\t\t// The underlying cause is that org.assertj.core.condition.Join.Join(Condition<? super T>...)\n\t\t// tracks all descriptions; whereas,\n\t\t// org.assertj.core.condition.Join.Join(Iterable<? extends Condition<? super T>>)\n\t\t// does not track all descriptions.\n\t\tList<Condition<Event>> conditions = uniqueIdSubstrings.stream()//\n\t\t\t\t.map(EventConditions::uniqueIdSubstring)//\n\t\t\t\t.collect(toList());\n\t\tList<Description> descriptions = conditions.stream().map(Condition::description).collect(toList());\n\t\treturn allOf(conditions).describedAs(new JoinDescription(\"all of :[\", \"]\", descriptions));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if the\n{@link Event}'s {@linkplain Event#getTestDescriptor() test descriptor}\ncontains all of the supplied strings.\n\n@since 1.6"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java",
    "type": "method",
    "name": "parseClasspathResources",
    "code": "void parseClasspathResources() {\n\t\t\tvar selector = parseIdentifier(selectClasspathResource(\"/foo/bar/spec.xml\"));\n\t\t\tassertThat(selector) //\n\t\t\t\t\t.asInstanceOf(type(ClasspathResourceSelector.class)) //\n\t\t\t\t\t.extracting(ClasspathResourceSelector::getClasspathResourceName,\n\t\t\t\t\t\tClasspathResourceSelector::getPosition) //\n\t\t\t\t\t.containsExactly(\"foo/bar/spec.xml\", Optional.empty());\n\n\t\t\tselector = parseIdentifier(selectClasspathResource(\"A/B/C/spec.json\"));\n\t\t\tassertThat(selector) //\n\t\t\t\t\t.asInstanceOf(type(ClasspathResourceSelector.class)) //\n\t\t\t\t\t.extracting(ClasspathResourceSelector::getClasspathResourceName,\n\t\t\t\t\t\tClasspathResourceSelector::getPosition) //\n\t\t\t\t\t.containsExactly(\"A/B/C/spec.json\", Optional.empty());\n\t\t}",
    "comment": "with unnecessary \"/\" prefix\nstandard use case"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-settings-builder/src/main/java/org/apache/maven/settings/crypto/DefaultSettingsDecryptionRequest.java",
    "type": "method",
    "name": "DefaultSettingsDecryptionRequest",
    "code": "public DefaultSettingsDecryptionRequest(Proxy proxy) {\n        this.proxies = new ArrayList<>(Arrays.asList(proxy));\n    }",
    "comment": "Creates a new request to decrypt the specified proxy.\n\n@param proxy The proxy to decrypt, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/RocksDB.java",
    "type": "method",
    "name": "notifyIteratorClosed",
    "code": "void notifyIteratorClosed(RocksIterator rocksIterator) {\n    iteratorTracker.removeIf(ref -> {\n      RocksDBIterator<?> rocksDBIterator = ref.get();\n      return rocksDBIterator != null && rocksIterator.equals(rocksDBIterator.internalIterator());\n    });\n  }",
    "comment": "Remove iterator from iterator tracker. `RocksDBIterator` calls it to notify\niterator is closed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/PropertyElf.java",
    "type": "method",
    "name": "PropertyElf",
    "code": "private PropertyElf() {\n      // cannot be constructed\n   }",
    "comment": "A class that reflectively sets bean properties on a target object.\n\n@author Brett Wooldridge"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethod.java",
    "type": "method",
    "name": "IsTestMethod",
    "code": "public IsTestMethod(DiscoveryIssueReporter issueReporter) {\n\t\tsuper(Test.class, IsTestableMethod::hasVoidReturnType, issueReporter);\n\t}",
    "comment": "Test if a method is a JUnit Jupiter {@link Test @Test} method.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotSame",
    "code": "public static void assertNotSame(Object unexpected, Object actual, Supplier<String> messageSupplier) {\n\t\tAssertNotSame.assertNotSame(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that the {@code unexpected} object and the {@code actual}\nobject are not the same object.\n<p>This method should only be used to compare the <em>identity</em> of two\nobjects. To assert that two objects or two primitive values are not\n<em>equal</em>, use one of the {@code assertNotEquals(...)} methods instead.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/thrift/ThriftCLIService.java",
    "type": "method",
    "name": "getIpAddress",
    "code": "private String getIpAddress() {\n    String clientIpAddress;\n    if (cliService.getHiveConf().getVar(\n        ConfVars.HIVE_SERVER2_TRANSPORT_MODE).equalsIgnoreCase(\"http\")) {\n      clientIpAddress = SessionManager.getIpAddress();\n    }\n    else {\n      if (isKerberosAuthMode()) {\n        clientIpAddress = hiveAuthFactory.getIpAddress();\n      }\n      else {\n        clientIpAddress = TSetIpAddressProcessor.getUserIpAddress();\n      }\n    }\n    LOG.debug(\"Client's IP Address: \" + clientIpAddress);\n    return clientIpAddress;\n  }",
    "comment": "Http transport mode.\nWe set the thread local ip address, in ThriftHttpServlet.\nKerberos\nExcept kerberos, NOSASL"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(long unexpected, Long actual) {\n\t\tAssertNotEquals.assertNotEquals((Long) unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertionFailureBuilder.java",
    "type": "method",
    "name": "build",
    "code": "public AssertionFailedError build() {\n\t\tString reason = nullSafeGet(this.reason);\n\t\tif (mismatch && includeValuesInMessage) {\n\t\t\treason = (reason == null ? \"\" : reason + \", \") + formatValues(expected, actual);\n\t\t}\n\t\tString message = nullSafeGet(this.message);\n\t\tif (reason != null) {\n\t\t\tmessage = buildPrefix(message) + reason;\n\t\t}\n\t\treturn mismatch //\n\t\t\t\t? new AssertionFailedError(message, expected, actual, cause) //\n\t\t\t\t: new AssertionFailedError(message, cause);\n\t}",
    "comment": "Build the {@link AssertionFailedError AssertionFailedError} without\nthrowing it.\n\n@return the built assertion failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/lazy/LazyFluentIterable.java",
    "type": "method",
    "name": "first",
    "code": "public FluentIterable<E> first(int count) {\n    return new LazyFluentIterable<>() {\n        return new DecoratingIterator<>(iterable.iterator()) {\n            return null;\n          }\n        };\n      }",
    "comment": "Can be used to collect objects from the iteration.\n\n@param count defines the number of objects to return\n@return the same FluentIterable with a collection decimated to a maximum of 'count' first\nobjects."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/AsynchronousHealthCheckerTest.java",
    "type": "method",
    "name": "whenShutdown_thenRejectsNewTasks",
    "code": "void whenShutdown_thenRejectsNewTasks() {\n    // Given\n    healthChecker.shutdown();\n\n    // When/Then\n    assertThrows(\n        RejectedExecutionException.class,\n        () -> healthChecker.performCheck(() -> Health.up().build(), 2),\n        \"Expected to throw RejectedExecutionException but did not\");\n  }",
    "comment": "Tests that the {@link performCheck()} method rejects new tasks after the {@link shutdown()}\nthe {@link performCheck()} method throws a {@link RejectedExecutionException} when attempting\nto submit a new health check task."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/ServiceOperations.java",
    "type": "method",
    "name": "init",
    "code": "public static void init(Service service, HiveConf configuration) {\n    Service.STATE state = service.getServiceState();\n    ensureCurrentState(state, Service.STATE.NOTINITED);\n    service.init(configuration);\n  }",
    "comment": "Initialize a service.\n\nThe service state is checked <i>before</i> the operation begins.\nThis process is <i>not</i> thread safe.\n@param service a service that must be in the state\n{@link Service.STATE#NOTINITED}\n@param configuration the configuration to initialize the service with\n@throws RuntimeException on a state change failure\n@throws IllegalStateException if the service is in the wrong state"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/Interpreter.java",
    "type": "method",
    "name": "Interpreter",
    "code": "public Interpreter(@NonNull File modelFile, Options options) {\n    this(new NativeInterpreterWrapperExperimental(modelFile.getAbsolutePath(), options));\n  }",
    "comment": "Initializes an {@code Interpreter} and specifies options for customizing interpreter behavior.\n\n@param modelFile a file of a pre-trained TF Lite model\n@param options a set of options for customizing interpreter behavior\n@throws IllegalArgumentException if {@code modelFile} does not encode a valid TensorFlow Lite\nmodel."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/extension/internal/CoreExtensionEntry.java",
    "type": "method",
    "name": "discoverFrom",
    "code": "public static CoreExtensionEntry discoverFrom(ClassRealm loader) {\n        Set<String> artifacts = new LinkedHashSet<>();\n        Set<String> packages = new LinkedHashSet<>();\n\n        try {\n            Enumeration<URL> urls = loader.getResources(BUILDER.getExtensionDescriptorLocation());\n            while (urls.hasMoreElements()) {\n\n                try (InputStream is = urls.nextElement().openStream()) {\n                    ExtensionDescriptor descriptor = BUILDER.build(is);\n                    artifacts.addAll(descriptor.getExportedArtifacts());\n                    packages.addAll(descriptor.getExportedPackages());\n                }\n            }\n        } catch (IOException ignored) {\n        }\n\n        return new CoreExtensionEntry(loader, artifacts, packages, null, null);\n    }",
    "comment": "exports descriptors are entirely optional"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/server/OneForOneStreamManagerSuite.java",
    "type": "method",
    "name": "testMissingChunk",
    "code": "public void testMissingChunk() {\n    OneForOneStreamManager manager = new OneForOneStreamManager();\n    List<ManagedBuffer> buffers = new ArrayList<>();\n    TestManagedBuffer buffer1 = Mockito.spy(new TestManagedBuffer(10));\n    TestManagedBuffer buffer2 = Mockito.spy(new TestManagedBuffer(20));\n    TestManagedBuffer buffer3 = Mockito.spy(new TestManagedBuffer(20));\n\n    buffers.add(buffer1);\n    buffers.add(null);\n    buffers.add(buffer2);\n    buffers.add(null);\n    buffers.add(buffer3);\n\n    Channel dummyChannel = Mockito.mock(Channel.class, Mockito.RETURNS_SMART_NULLS);\n    long streamId = manager.registerStream(\"appId\", buffers.iterator(), dummyChannel);\n    Assertions.assertEquals(1, manager.numStreamStates());\n    Assertions.assertNotNull(getChunk(manager, streamId, 0));\n    Assertions.assertNull(getChunk(manager, streamId, 1));\n    Assertions.assertNotNull(getChunk(manager, streamId, 2));\n    manager.connectionTerminated(dummyChannel);\n\n    Mockito.verify(buffer1, Mockito.never()).release();\n    Mockito.verify(buffer2, Mockito.never()).release();\n    Mockito.verify(buffer3, Mockito.times(1)).release();\n  }",
    "comment": "the nulls here are to simulate a file which goes missing before being read,\njust as a defensive measure\nloaded buffers are not released yet as in production a ManagedBuffer returned by getChunk()\nwould only be released by Netty after it is written to the network"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "allocateByteBuffer",
    "code": "public static ByteBuffer allocateByteBuffer(int numElements) {\n    return ByteBuffer.allocateDirect(numElements).order(ByteOrder.nativeOrder());\n  }",
    "comment": "Allocates a new direct {@link java.nio.ByteBuffer} with native byte order with specified\nTensor#fromBlobUnsigned(ByteBuffer, long[])}.\n\n@param numElements capacity (number of elements) of result buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/DefaultMaven.java",
    "type": "method",
    "name": "newRepositorySession",
    "code": "public RepositorySystemSession newRepositorySession(MavenExecutionRequest request) {\n        return newCloseableSession(request, new MavenChainedWorkspaceReader());\n    }",
    "comment": "Nobody should ever use this method.\n\n@deprecated If you use this method and your code is not in Maven Core, stop doing this."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(byte unexpected, Byte actual) {\n\t\tAssertNotEquals.assertNotEquals((Byte) unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/EngineExecutionListener.java",
    "type": "method",
    "name": "EngineExecutionListener",
    "code": "EngineExecutionListener NOOP = new EngineExecutionListener() {\n\n\tdefault void dynamicTestRegistered(TestDescriptor testDescriptor) {\n\t}\n\n\tdefault void executionSkipped(TestDescriptor testDescriptor, String reason) {\n\t}\n\n\tdefault void executionStarted(TestDescriptor testDescriptor) {\n\t}\n\n\tdefault void executionFinished(TestDescriptor testDescriptor, TestExecutionResult testExecutionResult) {\n\t}\n\n\tdefault void reportingEntryPublished(TestDescriptor testDescriptor, ReportEntry entry) {\n\t}\n\n\t@API(status = EXPERIMENTAL, since = \"1.12\")\n\tdefault void fileEntryPublished(TestDescriptor testDescriptor, FileEntry file) {\n\t}\n}",
    "comment": "Can be called for any {@link TestDescriptor} in order to attach a file to\na test or container &mdash; for example:\n\n<ul>\n<li>Screenshots</li>\n<li>Logs</li>\n<li>Output files written by the code under test</li>\n</ul>\n\n<p>The current lifecycle state of the supplied {@code TestDescriptor} is\nnot relevant: file events can occur at any time.\n\n@param testDescriptor the descriptor of the test or container to which\nthe file entry belongs\n@param file a {@code FileEntry} instance to be attached"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/OperationType.java",
    "type": "method",
    "name": "getOperationType",
    "code": "public static OperationType getOperationType(TOperationType tOperationType) {\n    for (OperationType opType : values()) {\n      if (tOperationType.equals(opType.tOperationType)) {\n        return opType;\n      }\n    }\n    return OperationType.UNKNOWN_OPERATION;\n  }",
    "comment": "TODO: replace this with a Map?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/demo/app/src/main/java/com/example/android/tflitecamerademo/Camera2BasicFragment.java",
    "type": "method",
    "name": "onSurfaceTextureSizeChanged",
    "code": "new TextureView.SurfaceTextureListener() {\n\n        @Override\n        public void onSurfaceTextureSizeChanged(SurfaceTexture texture, int width, int height) {\n          configureTransform(width, height);\n        }\n\n        @Override\n        public boolean onSurfaceTextureDestroyed(SurfaceTexture texture) {\n          return true;\n        }\n\n        @Override\n        public void onSurfaceTextureUpdated(SurfaceTexture texture) {}\n      };",
    "comment": "{@link TextureView.SurfaceTextureListener} handles several lifecycle events on a {@link\nTextureView}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/test/java/org/tensorflow/SessionTest.java",
    "type": "method",
    "name": "runMultipleOutputs",
    "code": "public void runMultipleOutputs() {\n    try (Graph g = new Graph();\n        Session s = new Session(g)) {\n  }\n\n  @Test\n  public void failOnUseAfterClose() {\n    try (Graph g = new Graph()) {\n        // expected exception\n      }\n    }\n  }",
    "comment": "@RunWith(JUnit4.class)\npublic class SessionTest {\n\n@Test\npublic void runUsingOperationNames() {\ntry (Graph g = new Graph();\nSession s = new Session(g)) {\nTestUtil.transpose_A_times_X(g, new int[][] {{2}, {3}});\ntry (Tensor<Integer> x = Tensors.create(new int[][] {{5}, {7}});\nnew TestUtil.AutoCloseableList<Tensor<?>>(s.runner().feed(\"X\", x).fetch(\"Y\").run())) {\nassertArrayEquals(expected, outputs.get(0).copyTo(new int[1][1]));\n}\n}\n}\n\n@Test\npublic void runUsingOperationHandles() {\ntry (Graph g = new Graph();\nSession s = new Session(g)) {\nTestUtil.transpose_A_times_X(g, new int[][] {{2}, {3}});\ntry (Tensor<Integer> x = Tensors.create(new int[][] {{5}, {7}});\nnew TestUtil.AutoCloseableList<Tensor<?>>(s.runner().feed(feed, x).fetch(fetch).run())) {\nassertArrayEquals(expected, outputs.get(0).copyTo(new int[1][1]));\n}\n}\n}\n\n@Test\npublic void runUsingColonSeparatedNames() {\ntry (Graph g = new Graph();\nSession s = new Session(g)) {\n.addInput(TestUtil.constant(g, \"value\", new int[] {1, 2, 3, 4}))\nassertArrayEquals(expected, fetched.copyTo(new int[2]));\n}\n// Feed using colon separated names.\ntry (Tensor<Integer> fed = Tensors.create(new int[] {4, 3, 2, 1});\nassertArrayEquals(expected, fetched.copyTo(new int[4]));\n}\n}\n}\n\n@Test\npublic void runWithMetadata() {\ntry (Graph g = new Graph();\nSession s = new Session(g)) {\nTestUtil.transpose_A_times_X(g, new int[][] {{2}, {3}});\ntry (Tensor<Integer> x = Tensors.create(new int[][] {{5}, {7}})) {\nassertArrayEquals(expected, outputs.get(0).copyTo(new int[1][1]));\n// Sanity check on metadata\n// See comments in fullTraceRunOptions() for an explanation about\n// why this check is really silly. Ideally, this would be:\n/*\nRunMetadata md = RunMetadata.parseFrom(result.metadata);\nassertTrue(md.toString(), md.hasStepStats());"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(int unexpected, int actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(byte unexpected, byte actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "unresolved",
    "code": "public static Resolution unresolved() {\n\t\t\treturn UNRESOLVED;\n\t\t}",
    "comment": "Factory for creating <em>unresolved</em> resolutions.\n\n@return an <em>unresolved</em> resolution; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkSubmitOptionParser.java",
    "type": "method",
    "name": "handle",
    "code": "protected boolean handle(String opt, String value) {\n    throw new UnsupportedOperationException();\n  }",
    "comment": "Callback for when an option with an argument is parsed.\n\n@param opt The long name of the cli option (might differ from actual command line).\n@param value The value. This will be <i>null</i> if the option does not take a value.\n@return Whether to continue parsing the argument list."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/AtypicalJvmMethodNameTests.java",
    "type": "method",
    "name": "kotlinTestWithMethodNameContainingSpecialCharacters",
    "code": "void kotlinTestWithMethodNameContainingSpecialCharacters() {\n\t\tEngineExecutionResults executionResults = executeTestsForClass(ArbitraryNamingKotlinTestCase.class);\n\t\tassertThat(executionResults.testEvents().started().count()).isEqualTo(2);\n\n\t\tTestDescriptor testDescriptor1 = executionResults.testEvents().succeeded().list().get(0).getTestDescriptor();\n\t\tassertAll(//\n\t\t\t() -> assertEquals(METHOD_NAME + \"()\", testDescriptor1.getDisplayName()), //\n\t\t\t() -> assertEquals(METHOD_NAME + \"()\", testDescriptor1.getLegacyReportingName()));\n\n\t\tTestDescriptor testDescriptor2 = executionResults.testEvents().succeeded().list().get(1).getTestDescriptor();\n\t\tassertAll(//\n\t\t\t() -> assertEquals(\"test name ends with parentheses()()\", testDescriptor2.getDisplayName()), //\n\t\t\t() -> assertEquals(\"test name ends with parentheses()()\", testDescriptor2.getLegacyReportingName()));\n\t}",
    "comment": "Integration tests for JVM languages that allow special characters\nin method names (e.g., Kotlin, Groovy, etc.) which are forbidden in\nJava source code.\n\n@since 5.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/test/java/org/apache/maven/cling/transfer/FileSizeFormatTest.java",
    "type": "method",
    "name": "testFormatRate",
    "code": "void testFormatRate() {\n        FileSizeFormat format = new FileSizeFormat();\n\n        MessageBuilder builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 5.0);\n        assertEquals(\"5.0 B/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 5500.0);\n        assertEquals(\"5.5 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 5500000.0);\n        assertEquals(\"5.5 MB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 5500000000.0);\n        assertEquals(\"5.5 GB/s\", builder.build());\n    }",
    "comment": "Test bytes per second\nTest kilobytes per second\nTest megabytes per second\nTest gigabytes per second"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/max/MaxCore.java",
    "type": "method",
    "name": "storedLocally",
    "code": "public static MaxCore storedLocally(File storedResults) {\n        return new MaxCore(storedResults);\n    }",
    "comment": "Create a new MaxCore from a serialized file stored at storedResults"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Graph.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n    synchronized (nativeHandleLock) {\n      if (nativeHandle == 0) {\n        return;\n      }\n      while (refcount > 0) {\n        try {\n          nativeHandleLock.wait();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          // Possible leak of the graph in this case?\n          return;\n        }\n      }\n      delete(nativeHandle);\n      nativeHandle = 0;\n    }\n  }",
    "comment": "Release resources associated with the Graph.\n\n<p>Blocks until there are no active {@link Session} instances referring to this Graph. A Graph\nis not usable after close returns."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultInterpolator.java",
    "type": "method",
    "name": "resolveVariable",
    "code": "boolean defaultsToEmptyString) {\n\n        int startIdx = 0;\n        String substValue = null;\n\n        while (startIdx < variable.length()) {\n            int idx1 = variable.indexOf(\":-\", startIdx);\n            int idx2 = variable.indexOf(\":+\", startIdx);\n            int idx = idx1 >= 0 ? idx2 >= 0 ? Math.min(idx1, idx2) : idx1 : idx2;\n\n            if (idx < 0) {\n                if (substValue == null) {\n                    String currentVar = variable.substring(startIdx);\n                    substValue = resolveVariable(\n                            currentVar, cycleMap, configProps, callback, postprocessor, defaultsToEmptyString);\n                }\n                break;\n            }\n\n            String varPart = variable.substring(startIdx, idx);\n            if (substValue == null) {\n                substValue =\n                        resolveVariable(varPart, cycleMap, configProps, callback, postprocessor, defaultsToEmptyString);\n            }\n\n            int nextIdx1 = variable.indexOf(\":-\", idx + 2);\n            int nextIdx2 = variable.indexOf(\":+\", idx + 2);\n            int nextIdx = nextIdx1 >= 0 ? nextIdx2 >= 0 ? Math.min(nextIdx1, nextIdx2) : nextIdx1 : nextIdx2;\n\n            String op = variable.substring(idx, idx + 2);\n            String opValue = variable.substring(idx + 2, nextIdx >= 0 ? nextIdx : variable.length());\n\n            String processedOpValue =\n                    doSubstVars(opValue, org, cycleMap, configProps, callback, postprocessor, defaultsToEmptyString);\n\n            if (\":+\".equals(op)) {\n                if (substValue != null && !substValue.isEmpty()) {\n                    substValue = processedOpValue;\n                    break;\n                }\n            } else if (\":-\".equals(op)) {\n                if (substValue == null || substValue.isEmpty()) {\n                    substValue = processedOpValue;\n                    break;\n                }\n            } else {\n                throw new InterpolatorException(\"Bad substitution operator in: ${\" + org + \"}\");\n\n            startIdx = nextIdx >= 0 ? nextIdx : variable.length();\n        }\n\n        if (substValue == null) {\n            if (defaultsToEmptyString) {\n                substValue = \"\";\n            } else {\n                substValue = MARKER + \"{\" + variable + \"}\";\n            }\n        }\n\n        return substValue;\n    }\n\n    private static String resolveVariable(\n            String variable,\n            Set<String> cycleMap,\n            Map<String, String> configProps,\n            UnaryOperator<String> callback,\n            BinaryOperator<String> postprocessor,\n            boolean defaultsToEmptyString) {\n\n        if (!cycleMap.add(variable)) {\n            throw new InterpolatorException(\"recursive variable reference: \" + variable);\n        }\n\n        String substValue = null;\n        if (configProps != null) {\n            substValue = configProps.get(variable);\n        }\n        if (substValue == null && !variable.isEmpty() && callback != null) {\n            String s1 = callback.apply(variable);\n            String s2 =\n                    doSubstVars(s1, variable, cycleMap, configProps, callback, postprocessor, defaultsToEmptyString);\n            substValue = postprocessor != null ? postprocessor.apply(variable, s2) : s2;\n        }\n\n        cycleMap.remove(variable);\n        return substValue;\n    }\n\n    @Nullable\n    public static String escape(@Nullable String val) {\n        if (val == null || val.isEmpty()) {\n            return val;\n        }\n        return val.replace(\"$\", MARKER);\n    }\n\n    @Nullable\n    public static String unescape(@Nullable String val) {\n        if (val == null || val.isEmpty()) {\n            return val;\n        }\n        val = val.replace(MARKER, \"$\");\n        int escape = val.indexOf(ESCAPE_CHAR);\n        while (escape >= 0 && escape < val.length() - 1) {\n            char c = val.charAt(escape + 1);\n            if (c == '{' || c == '}') {\n                val = val.substring(0, escape) + val.substring(escape + 1);\n            }\n            escape = val.indexOf(ESCAPE_CHAR, escape + 1);\n        }\n        return val;\n    }\n}",
    "comment": "Unescapes previously escaped characters in the given string.\n\n@param val The string to be unescaped.\n@return The unescaped string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/MultilineMessageHelper.java",
    "type": "method",
    "name": "separatorLine",
    "code": "public static String separatorLine() {\n        StringBuilder sb = new StringBuilder(DEFAULT_MAX_SIZE);\n        repeat(sb, '*', DEFAULT_MAX_SIZE);\n        return sb.toString();\n    }",
    "comment": "Helper class to format multiline messages to the console"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "errorCount",
    "code": "public synchronized int errorCount() {\n        return fErrors.size();\n    }",
    "comment": "Gets the number of detected errors."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestPlan.java",
    "type": "method",
    "name": "getChildren",
    "code": "public Set<TestIdentifier> getChildren(UniqueId parentId) {\n\t\treturn children.containsKey(parentId) ? unmodifiableSet(children.get(parentId)) : emptySet();\n\t}",
    "comment": "Get the children of the supplied unique ID.\n\n@param parentId the unique ID to look up the children for; never\n{@code null}\n@return an unmodifiable set of the parent's children, potentially empty\n@see #getChildren(TestIdentifier)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java",
    "type": "method",
    "name": "tryToLoadClassFailsWithinReasonableTimeForInsanelyLargeAndInvalidMultidimensionalPrimitiveArrayName",
    "code": "void tryToLoadClassFailsWithinReasonableTimeForInsanelyLargeAndInvalidMultidimensionalPrimitiveArrayName() {\n\t\t\tString className = IntStream.rangeClosed(1, 20_000)//\n\t\t\t\t\t.mapToObj(i -> \"[]\")//\n\t\t\t\t\t.collect(joining(\"\", \"int\", \"X\"));\n\n\t\t\tassertTimeoutPreemptively(ofMillis(500), () -> assertThrows(ClassNotFoundException.class,\n\t\t\t\t() -> ReflectionUtils.tryToLoadClass(className).get()));\n\t\t}",
    "comment": "Create a class name of the form int[][][]...[][][]X\nThe following should ideally fail in less than 50ms. So we just make\nsure it fails in less than 500ms in order to (hopefully) allow the\ntest to pass on CI servers with limited resources."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/bitset/BitSetMethods.java",
    "type": "method",
    "name": "unset",
    "code": "public static void unset(Object baseObject, long baseOffset, int index) {\n    assert index >= 0 : \"index (\" + index + \") should >= 0\";\n    final long mask = 1L << (index & 0x3f);  // mod 64 and shift\n    final long wordOffset = baseOffset + (index >> 6) * WORD_SIZE;\n    final long word = Platform.getLong(baseObject, wordOffset);\n    Platform.putLong(baseObject, wordOffset, word & ~mask);\n  }",
    "comment": "Sets the bit at the specified index to {@code false}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createDayTimeIntervalType",
    "code": "public static DayTimeIntervalType createDayTimeIntervalType(byte startField, byte endField) {\n    return DayTimeIntervalType$.MODULE$.apply(startField, endField);\n  }",
    "comment": "Creates a DayTimeIntervalType by specifying the start and end fields."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(char expected, char actual) {\n        assertEquals(null, expected, actual);\n    }",
    "comment": "Asserts that two chars are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/SupportsDelete.java",
    "type": "method",
    "name": "canDeleteWhere",
    "code": "default boolean canDeleteWhere(Predicate[] predicates) {\n    Filter[] v1Filters = PredicateUtils.toV1(predicates);\n    if (v1Filters.length < predicates.length) return false;\n    return this.canDeleteWhere(v1Filters);\n  }",
    "comment": "Delete data from a data source table that matches filter expressions. Note that this method\nwill be invoked only if {@link #canDeleteWhere(Filter[])} returns true.\n<p>\nRows are deleted from the data source iff all of the filter expressions match. That is, the\nexpressions must be interpreted as a set of filters that are ANDed together.\n<p>\nImplementations may reject a delete operation if the delete isn't possible without significant\neffort. For example, partitioned data sources may reject deletes that do not filter by\npartition columns because the filter may require rewriting files without deleted records.\nTo reject a delete implementations should throw {@link IllegalArgumentException} with a clear\nerror message that identifies which expression was rejected.\n\n@param filters filter expressions, used to select rows to delete when all expressions match\n@throws IllegalArgumentException If the delete is rejected due to required effort"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/BeforeAndAfterTestExecutionCallbackTests.java",
    "type": "method",
    "name": "beforeEachMethodThrowsAnException",
    "code": "void beforeEachMethodThrowsAnException() {\n\t\tEngineExecutionResults executionResults = executeTestsForClass(ExceptionInBeforeEachMethodTestCase.class);\n\n\t\tassertEquals(1, executionResults.testEvents().started().count(), \"# tests started\");\n\t\tassertEquals(0, executionResults.testEvents().succeeded().count(), \"# tests succeeded\");\n\t\tassertEquals(0, executionResults.testEvents().skipped().count(), \"# tests skipped\");\n\t\tassertEquals(0, executionResults.testEvents().aborted().count(), \"# tests aborted\");\n\t\tassertEquals(1, executionResults.testEvents().failed().count(), \"# tests failed\");\n\n\t\tassertEquals(asList(\n\t\t\t\"beforeEachMethod\", // throws an exception.\n\t\t\t\"afterEachMethod\"\n\t\t), callSequence, \"wrong call sequence\");\n\n\t\tassertNull(actualExceptionInAfterTestExecution,\n\t\t\t\"test exception (fooAfterTestExecutionCallback should not have been called)\");\n\t}",
    "comment": "@formatter:off\nfooBeforeTestExecutionCallback should not get invoked.\ntest should not get invoked.\nfooAfterTestExecutionCallback should not get invoked.\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/extensions/BootstrapCoreExtensionManager.java",
    "type": "method",
    "name": "if",
    "code": "if (clazz == ArtifactCoordinatesFactory.class) {\n                return (T) new DefaultArtifactCoordinatesFactory();\n            } else if (clazz == VersionParser.class) {\n                return (T) new DefaultVersionParser(new DefaultModelVersionParser(new GenericVersionScheme()));\n            } else if (clazz == VersionRangeResolver.class) {\n                return (T) new DefaultVersionRangeResolver(repositorySystem);\n            } else if (clazz == ArtifactResolver.class) {\n                return (T) new DefaultArtifactResolver();\n            } else if (clazz == ArtifactManager.class) {\n                return (T) new DefaultArtifactManager(this);\n            } else if (clazz == RepositoryFactory.class) {\n                return (T) new DefaultRepositoryFactory(new DefaultRemoteRepositoryManager(\n                        new DefaultUpdatePolicyAnalyzer(), new DefaultChecksumPolicyProvider()));\n            } else if (clazz == Interpolator.class) {\n                return (T) new DefaultInterpolator();\n            }",
    "comment": "} else if (clazz == ModelResolver.class) {\nreturn (T) new DefaultModelResolver();"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/notification/RunNotifier.java",
    "type": "method",
    "name": "fireTestSuiteStarted",
    "code": "public void fireTestSuiteStarted(final Description description) {\n        new SafeNotifier() {\n        }.run();\n    }",
    "comment": "Invoke to tell listeners that a test suite is about to start. Runners are strongly\nencouraged--but not required--to call this method. If this method is called for\na given {@link Description} then {@link #fireTestSuiteFinished(Description)} MUST\nbe called for the same {@code Description}.\n\n@param description the description of the suite test (generally a class name)\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/FixedLengthRowBasedKeyValueBatch.java",
    "type": "method",
    "name": "getValueFromKey",
    "code": "protected UnsafeRow getValueFromKey(int rowId) {\n    if (keyRowId != rowId) {\n      getKeyRow(rowId);\n    }\n    assert(rowId >= 0);\n    valueRow.pointTo(base, keyRow.getBaseOffset() + klen, vlen);\n    return valueRow;\n  }",
    "comment": "Returns the value row by two steps:\n1) looking up the key row with the same id (skipped if the key row is cached)\n2) retrieve the value row by reusing the metadata from step 1)\nIn most times, 1) is skipped because `getKeyRow(id)` is often called before `getValueRow(id)`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/testkit/engine/ExecutionsIntegrationTests.java",
    "type": "method",
    "name": "executionsFromSkippedTestEvents",
    "code": "void executionsFromSkippedTestEvents() {\n\t\tvar testEvents = getTestEvents();\n\n\t\t// We expect 1 for both of the following cases, since an Execution can\n\t\t// be created for a \"skipped event even if \"started\" and \"finished\" events\n\t\t// are filtered out.\n\t\tassertThat(testEvents.executions().skipped().count()).isEqualTo(1);\n\t\tassertThat(testEvents.skipped().executions().count()).isEqualTo(1);\n\t}",
    "comment": "Integration tests for {@link Executions}.\n\n@since 1.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ModelBuilderException.java",
    "type": "method",
    "name": "getModelId",
    "code": "public String getModelId() {\n        if (result == null) {\n            return \"\";\n        } else if (result.getEffectiveModel() != null) {\n            return result.getEffectiveModel().getId();\n        } else if (result.getRawModel() != null) {\n            return result.getRawModel().getId();\n        } else if (result.getFileModel() != null) {\n            return result.getFileModel().getId();\n        } else {\n            return \"\";\n        }\n    }",
    "comment": "Gets the identifier of the POM whose effective model could not be built. The general format of the identifier is\n{@code <groupId>:<artifactId>:<version>} but some of these coordinates may still be unknown at the point the\nexception is thrown so this information is merely meant to assist the user.\n\n@return The identifier of the POM or an empty string if not known, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/server/ThreadWithGarbageCleanup.java",
    "type": "method",
    "name": "cleanRawStore",
    "code": "private void cleanRawStore() {\n    Long threadId = this.getId();\n    RawStore threadLocalRawStore = threadRawStoreMap.get(threadId);\n    if (threadLocalRawStore != null) {\n      LOG.debug(\"RawStore: \" + threadLocalRawStore + \", for the thread: \" +\n          this.getName()  +  \" will be closed now.\");\n      threadLocalRawStore.shutdown();\n      threadRawStoreMap.remove(threadId);\n    }\n  }",
    "comment": "Add any Thread specific garbage cleanup code here.\nCurrently, it shuts down the RawStore object for this thread if it is not null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "compareLowerCaseSlow",
    "code": "private static int compareLowerCaseSlow(final UTF8String left, final UTF8String right) {\n    return lowerCaseCodePoints(left).binaryCompare(lowerCaseCodePoints(right));\n  }",
    "comment": "Slow version of the `compareLowerCase` method, used when both arguments are non-ASCII strings.\n\n@param left The first non-ASCII UTF8String to compare.\n@param right The second non-ASCII UTF8String to compare.\n@return An integer representing the comparison result."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-executor/src/main/java/org/apache/maven/cling/executor/embedded/EmbeddedMavenExecutor.java",
    "type": "method",
    "name": "doCreate",
    "code": "protected Context doCreate(Path mavenHome, ExecutorRequest executorRequest) {\n        if (!Files.isDirectory(mavenHome)) {\n            throw new IllegalArgumentException(\"Installation directory must point to existing directory: \" + mavenHome);\n        }\n        if (!MVN4_MAIN_CLASSES.containsKey(executorRequest.command())) {\n            throw new IllegalArgumentException(\n                    getClass().getSimpleName() + \" does not support command \" + executorRequest.command());\n        }\n        if (executorRequest.environmentVariables().isPresent()) {\n            throw new IllegalArgumentException(getClass().getSimpleName() + \" does not support environment variables\");\n        }\n        if (executorRequest.jvmArguments().isPresent()) {\n            throw new IllegalArgumentException(getClass().getSimpleName() + \" does not support jvmArguments\");\n        }\n        Path boot = mavenHome.resolve(\"boot\");\n        Path m2conf = mavenHome.resolve(\"bin/m2.conf\");\n        if (!Files.isDirectory(boot) || !Files.isRegularFile(m2conf)) {\n            throw new IllegalArgumentException(\n                    \"Installation directory does not point to Maven installation: \" + mavenHome);\n        }\n\n        ArrayList<String> mavenArgs = new ArrayList<>();\n        String mavenArgsEnv = System.getenv(\"MAVEN_ARGS\");\n        if (useMavenArgsEnv && mavenArgsEnv != null && !mavenArgsEnv.isEmpty()) {\n            Arrays.stream(mavenArgsEnv.split(\" \"))\n                    .filter(s -> !s.trim().isEmpty())\n                    .forEach(s -> mavenArgs.add(0, s));\n        }\n\n        Properties properties = prepareProperties(executorRequest);\n        properties.setProperty(\n                \"maven.mainClass\", requireNonNull(MVN4_MAIN_CLASSES.get(ExecutorRequest.MVN), \"mainClass\"));\n        System.setProperties(properties);\n        URLClassLoader bootClassLoader = createMavenBootClassLoader(boot, Collections.emptyList());\n        Thread.currentThread().setContextClassLoader(bootClassLoader);\n        try {\n            Class<?> launcherClass = bootClassLoader.loadClass(\"org.codehaus.plexus.classworlds.launcher.Launcher\");\n            Object launcher = launcherClass.getDeclaredConstructor().newInstance();\n            Method configure = launcherClass.getMethod(\"configure\", InputStream.class);\n            try (InputStream inputStream = Files.newInputStream(m2conf)) {\n                configure.invoke(launcher, inputStream);\n            }\n            Object classWorld = launcherClass.getMethod(\"getWorld\").invoke(launcher);\n            Set<String> originalClassRealmIds = new HashSet<>();\n\n            Method getRealms = classWorld.getClass().getMethod(\"getRealms\");\n            List<Object> realms = (List<Object>) getRealms.invoke(classWorld);\n            for (Object realm : realms) {\n                Method realmGetId = realm.getClass().getMethod(\"getId\");\n                originalClassRealmIds.add((String) realmGetId.invoke(realm));\n            }\n\n            Class<?> cliClass =\n                    (Class<?>) launcherClass.getMethod(\"getMainClass\").invoke(launcher);\n            String version = getMavenVersion(cliClass);\n            Map<String, Function<ExecutorRequest, Integer>> commands = new HashMap<>();\n            ArrayList<Object> keepAlive = new ArrayList<>();\n\n            if (version.startsWith(\"3.\")) {\n                if (!ExecutorRequest.MVN.equals(executorRequest.command())) {\n                    throw new IllegalArgumentException(getClass().getSimpleName() + \" w/ mvn3 does not support command \"\n                            + executorRequest.command());\n                }\n                keepAlive.add(cliClass.getClassLoader().loadClass(\"org.fusesource.jansi.internal.JansiLoader\"));\n                Constructor<?> newMavenCli = cliClass.getConstructor(classWorld.getClass());\n                Object mavenCli = newMavenCli.newInstance(classWorld);\n                Class<?>[] parameterTypes = {String[].class, String.class, PrintStream.class, PrintStream.class};\n                Method doMain = cliClass.getMethod(\"doMain\", parameterTypes);\n                commands.put(ExecutorRequest.MVN, r -> {\n                    System.setProperties(prepareProperties(r));\n                    try {\n                        ArrayList<String> args = new ArrayList<>(mavenArgs);\n                        args.addAll(r.arguments());\n                        PrintStream stdout = r.stdOut().isEmpty()\n                                ? null\n                                : new PrintStream(r.stdOut().orElseThrow(), true);\n                        PrintStream stderr = r.stdErr().isEmpty()\n                                ? null\n                                : new PrintStream(r.stdErr().orElseThrow(), true);\n                        return (int) doMain.invoke(mavenCli, new Object[] {\n                    } catch (Exception e) {\n                        throw new ExecutorException(\"Failed to execute\", e);\n                    }\n                });\n            } else {\n                keepAlive.add(cliClass.getClassLoader().loadClass(\"org.jline.nativ.JLineNativeLoader\"));\n                for (Map.Entry<String, String> cmdEntry : MVN4_MAIN_CLASSES.entrySet()) {\n                    Class<?> cmdClass = cliClass.getClassLoader().loadClass(cmdEntry.getValue());\n                    Method mainMethod = cmdClass.getMethod(\n                            \"main\",\n                            String[].class,\n                            classWorld.getClass(),\n                            InputStream.class,\n                            OutputStream.class,\n                            OutputStream.class);\n                    commands.put(cmdEntry.getKey(), r -> {\n                        System.setProperties(prepareProperties(r));\n                        try {\n                            ArrayList<String> args = new ArrayList<>(mavenArgs);\n                            args.addAll(r.arguments());\n                            return (int) mainMethod.invoke(\n                                    null,\n                                    args.toArray(new String[0]),\n                                    classWorld,\n                                    r.stdIn().orElse(null),\n                                    r.stdOut().orElse(null),\n                                    r.stdErr().orElse(null));\n                        } catch (Exception e) {\n                            throw new ExecutorException(\"Failed to execute\", e);\n                        }\n                    });\n                }\n            }\n\n            return new Context(\n                    bootClassLoader,\n                    version,\n                    classWorld,\n                    originalClassRealmIds,\n                    cliClass.getClassLoader(),\n                    commands,\n                    keepAlive);\n        } catch (Exception e) {\n            throw new ExecutorException(\"Failed to create executor\", e);\n        } finally {\n            Thread.currentThread().setContextClassLoader(originalClassLoader);\n            System.setProperties(originalProperties);\n        }\n    }\n\n    protected Properties prepareProperties(ExecutorRequest request) {\n        System.setProperties(null); // this \"inits\" them!\n\n        Properties properties = new Properties();\n        properties.putAll(System.getProperties()); // get mandatory/expected init-ed above\n\n        properties.setProperty(\"user.dir\", request.cwd().toString());\n        properties.setProperty(\"user.home\", request.userHomeDirectory().toString());\n\n        Path mavenHome = request.installationDirectory();\n        properties.setProperty(\"maven.home\", mavenHome.toString());\n        properties.setProperty(\n                \"maven.multiModuleProjectDirectory\", request.cwd().toString());\n\n        properties.setProperty(\n                \"library.jansi.path\", mavenHome.resolve(\"lib/jansi-native\").toString());\n\n        properties.setProperty(\n                \"library.jline.path\", mavenHome.resolve(\"lib/jline-native\").toString());\n\n        if (request.jvmSystemProperties().isPresent()) {\n            properties.putAll(request.jvmSystemProperties().get());\n        }\n\n        return properties;\n    }\n\n    @Override\n    public void close() throws ExecutorException {\n        if (closed.compareAndExchange(false, true)) {\n            try {\n                ArrayList<Exception> exceptions = new ArrayList<>();\n                for (Context context : contexts.values()) {\n                    try {\n                        doClose(context);\n                    } catch (Exception e) {\n                        exceptions.add(e);\n                    }\n                }\n                if (!exceptions.isEmpty()) {\n                    ExecutorException e = new ExecutorException(\"Could not close cleanly\");\n                    exceptions.forEach(e::addSuppressed);\n                    throw e;\n                }\n            } finally {\n                System.setProperties(originalProperties);\n            }\n        }\n    }\n\n    protected void doClose(Context context) throws ExecutorException {\n        Thread.currentThread().setContextClassLoader(context.bootClassLoader);\n        try {\n            try {\n                ((Closeable) context.classWorld).close();\n            } finally {\n                context.bootClassLoader.close();\n            }\n        } catch (Exception e) {\n            throw new ExecutorException(\"Failed to close cleanly\", e);\n        } finally {\n            Thread.currentThread().setContextClassLoader(originalClassLoader);\n        }\n    }\n\n    protected void validate(ExecutorRequest executorRequest) throws ExecutorException {}\n\n    protected URLClassLoader createMavenBootClassLoader(Path boot, List<URL> extraClasspath) {\n        ArrayList<URL> urls = new ArrayList<>(extraClasspath);\n        try (Stream<Path> stream = Files.list(boot)) {\n            stream.filter(Files::isRegularFile)\n                    .filter(p -> p.toString().endsWith(\".jar\"))\n                    .forEach(f -> {\n                        try {\n                            urls.add(f.toUri().toURL());\n                        } catch (MalformedURLException e) {\n                            throw new ExecutorException(\"Failed to build classpath: \" + f, e);\n                        }\n                    });\n        } catch (IOException e) {\n            throw new ExecutorException(\"Failed to build classpath: \" + e, e);\n        }\n        if (urls.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid Maven home directory; boot is empty\");\n        }\n        return new URLClassLoader(\n                urls.toArray(new URL[0]), ClassLoader.getSystemClassLoader().getParent());\n    }\n\n    protected String getMavenVersion(Class<?> clazz) throws IOException {\n        Properties props = new Properties();\n        try (InputStream is = clazz.getResourceAsStream(\"/META-INF/maven/org.apache.maven/maven-core/pom.properties\")) {\n            if (is != null) {\n                props.load(is);\n            }\n            String version = props.getProperty(\"version\");\n            if (version != null) {\n                return version;\n            }\n            return UNKNOWN_VERSION;\n        }\n    }\n}",
    "comment": "set ahead of time, if the mavenHome points to Maven4, as ClassWorld Launcher needs this property\ncollect pre-created (in m2.conf) class realms as \"original ones\"; the rest are created at runtime\n3.x\nassume 4.x\nMaven 3.x\nMaven 4.x"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/queue-based-load-leveling/src/main/java/com/iluwatar/queue/load/leveling/MessageQueue.java",
    "type": "method",
    "name": "MessageQueue",
    "code": "public MessageQueue() {\n    this.blkQueue = new ArrayBlockingQueue<>(1024);\n  }",
    "comment": "MessageQueue class. In this class we will create a Blocking Queue and submit/retrieve all the\nmessages from it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/intercepting-filter/src/main/java/com/iluwatar/intercepting/filter/ContactFilter.java",
    "type": "method",
    "name": "execute",
    "code": "public String execute(Order order) {\n    var result = super.execute(order);\n    var contactNumber = order.getContactNumber();\n    if (contactNumber == null\n        || contactNumber.matches(\".*[^\\\\d]+.*\")\n        || contactNumber.length() != 11) {\n      return result + \"Invalid contact number! \";\n    } else {\n      return result;\n    }\n  }",
    "comment": "Concrete implementation of filter This filter checks for the contact field in which it checks if\nthe input consist of numbers and it also checks if the input follows the length constraint (11\ndigits)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/PackagingProfileActivator.java",
    "type": "method",
    "name": "isActive",
    "code": "public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        return getActivationPackaging(profile).map(p -> isPackaging(context, p)).orElse(false);\n    }",
    "comment": "Determines profile activation based on the project's packaging."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng5608ProfileActivationWarningTest.java",
    "type": "method",
    "name": "assertFileExists",
    "code": "private void assertFileExists(File dir, String filename) {\n        File file = new File(dir, filename);\n        assertTrue(file.exists(), \"expected file: \" + file);\n    }",
    "comment": "check expected profiles activated, just for sanity (or build should have failed, given other profiles)\ncheck that the 2 profiles using ${project.basedir} caused warnings"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/kafka-0-10/src/test/java/org/apache/spark/streaming/kafka010/JavaLocationStrategySuite.java",
    "type": "method",
    "name": "testLocationStrategyConstructors",
    "code": "public void testLocationStrategyConstructors() {\n    final String topic1 = \"topic1\";\n    final TopicPartition tp1 = new TopicPartition(topic1, 0);\n    final TopicPartition tp2 = new TopicPartition(topic1, 1);\n    final Map<TopicPartition, String> hosts = new HashMap<>();\n    hosts.put(tp1, \"node1\");\n    hosts.put(tp2, \"node2\");\n    final scala.collection.Map<TopicPartition, String> sHosts = CollectionConverters.asScala(hosts);\n\n    final LocationStrategy c1 = LocationStrategies.PreferConsistent();\n    final LocationStrategy c2 = LocationStrategies.PreferConsistent();\n    Assertions.assertSame(c1, c2);\n\n    final LocationStrategy c3 = LocationStrategies.PreferBrokers();\n    final LocationStrategy c4 = LocationStrategies.PreferBrokers();\n    Assertions.assertSame(c3, c4);\n\n    Assertions.assertNotSame(c1, c3);\n\n    final LocationStrategy c5 = LocationStrategies.PreferFixed(hosts);\n    final LocationStrategy c6 = LocationStrategies.PreferFixed(sHosts);\n    Assertions.assertEquals(c5, c6);\n  }",
    "comment": "make sure constructors can be called from java"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestDescriptor.java",
    "type": "method",
    "name": "prune",
    "code": "default void prune() {\n\t\tif (!isRoot() && !containsTests(this)) {\n\t\t\tremoveFromHierarchy();\n\t\t}\n\t}",
    "comment": "Remove this descriptor from the hierarchy unless it is a root or contains\ntests.\n\n<p>A concrete {@link TestEngine} may override this method in order to\nimplement a different algorithm or to skip pruning altogether.\n\n@see #isRoot()\n@see #containsTests(TestDescriptor)\n@see #removeFromHierarchy()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/bytecode/src/test/java/com/iluwatar/bytecode/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ThrowableCollector.java",
    "type": "method",
    "name": "toTestExecutionResult",
    "code": "public TestExecutionResult toTestExecutionResult() {\n\t\tif (isEmpty()) {\n\t\t\treturn successful();\n\t\t}\n\t\tif (hasAbortedExecution(throwable)) {\n\t\t\treturn aborted(throwable);\n\t\t}\n\t\treturn failed(throwable);\n\t}",
    "comment": "Convert the collected {@link Throwable Throwables} into a {@link TestExecutionResult}.\n\n@return {@linkplain TestExecutionResult#aborted aborted} if the collected\n{@code Throwable} <em>aborted</em> execution;\n{@linkplain TestExecutionResult#failed failed} if it <em>failed</em>\nexecution; and {@linkplain TestExecutionResult#successful successful}\notherwise\n@since 1.6"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/EnumConfigurationParameterConverter.java",
    "type": "method",
    "name": "get",
    "code": "public E get(String key, Function<String, Optional<String>> lookup, E defaultValue) {\n\n\t\tOptional<String> value = lookup.apply(key);\n\n\t\tif (value.isPresent()) {\n\t\t\tString constantName = null;\n\t\t\ttry {\n\t\t\t\tconstantName = value.get().trim().toUpperCase(Locale.ROOT);\n\t\t\t\tE result = Enum.valueOf(enumType, constantName);\n\t\t\t\tlogger.config(() -> String.format(\"Using %s '%s' set via the '%s' configuration parameter.\",\n\t\t\t\t\tenumDisplayName, result, key));\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tString constant = constantName;\n\t\t\t\tlogger.warn(() -> String.format(\n\t\t\t\t\t\"Invalid %s '%s' set via the '%s' configuration parameter. \"\n\t\t\t\t\t\t\t+ \"Falling back to the %s default value.\",\n\t\t\t\t\tenumDisplayName, constant, key, defaultValue.name()));\n\t\t\t}\n\t\t}\n\n\t\treturn defaultValue;\n\t}",
    "comment": "local copy necessary for use in lambda expression"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "getValueOffset",
    "code": "public long getValueOffset() {\n      assert (isDefined);\n      return valueOffset;\n    }",
    "comment": "Returns the offset for value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/SavedModelBundle.java",
    "type": "method",
    "name": "load",
    "code": "public static SavedModelBundle load(String exportDir, String... tags) {\n    return loader(exportDir).withTags(tags).load();\n  }",
    "comment": "Load a saved model from an export directory. The model that is being loaded should be created\nusing the <a href=\"https://www.tensorflow.org/api_docs/python/tf/saved_model\">Saved Model\nAPI</a>.\n\n<p>This method is a shorthand for:\n\n<pre>{@code\nSavedModelBundle.loader().withTags(tags).load();\n}</pre>\n\n@param exportDir the directory path containing a saved model.\n@param tags the tags identifying the specific metagraphdef to load.\n@return a bundle containing the graph and associated session."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-repository-metadata/src/test/java/org/apache/maven/artifact/repository/metadata/MetadataTest.java",
    "type": "method",
    "name": "mergeWithSameSnapshotWithDifferentVersionsAndOlderLastUpdated",
    "code": "void mergeWithSameSnapshotWithDifferentVersionsAndOlderLastUpdated() {\n        Metadata source = createMetadataFromArtifact(artifact);\n        Date before = new Date(System.currentTimeMillis() - 5000);\n        Date after = new Date(System.currentTimeMillis());\n        SnapshotVersion sv1 = addSnapshotVersion(target.getVersioning(), after, artifact);\n        addSnapshotVersion(source.getVersioning(), before, artifact);\n        assertFalse(target.merge(source));\n        assertEquals(1, target.getVersioning().getSnapshotVersions().size());\n        assertEquals(sv1, target.getVersioning().getSnapshotVersions().get(0));\n        assertEquals(formatDate(after, false), target.getVersioning().getLastUpdated());\n        assertEquals(\n                formatDate(after, true), target.getVersioning().getSnapshot().getTimestamp());\n    }",
    "comment": "nothing should be updated, as the target was already updated at a later date than source"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "expect",
    "code": "public <U> Tensor<U> expect(Class<U> type) {\n    DataType dt = DataType.fromClass(type);\n    if (!dt.equals(dtype)) {\n      throw new IllegalArgumentException(\n          \"Cannot cast from tensor of \" + dtype + \" to tensor of \" + dt);\n    }\n    return ((Tensor<U>) this);\n  }",
    "comment": "Returns this Tensor object with the type {@code Tensor<U>}. This method is useful when given a\nvalue of type {@code Tensor<?>}.\n\n@param type any (non-null) array of the correct type.\n@throws IllegalArgumentException if the actual data type of this object does not match the type\n{@code U}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MavenBuilderException.java",
    "type": "method",
    "name": "MavenBuilderException",
    "code": "public MavenBuilderException(String message, ProblemCollector<BuilderProblem> problems) {\n        super(buildMessage(message, problems), null);\n        this.problems = problems;\n    }",
    "comment": "Constructs a new exception with the specified message and problems.\nThe message will be enhanced with details from the problems.\n\n@param message the detail message\n@param problems the collection of problems associated with this exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/bitset/BitSetMethods.java",
    "type": "method",
    "name": "BitSetMethods",
    "code": "private BitSetMethods() {\n    // Make the default constructor private, since this only holds static methods.\n  }",
    "comment": "Methods for working with fixed-size uncompressed bitsets.\n\nWe assume that the bitset data is word-aligned (that is, a multiple of 8 bytes in length).\n\nEach bit occupies exactly one bit of storage."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/AbstractMojo.java",
    "type": "method",
    "name": "getLog",
    "code": "public Log getLog() {\n        if (log == null) {\n            log = new SystemStreamLog();\n        }\n\n        return log;\n    }",
    "comment": "<p>\nReturns the logger that has been injected into this mojo. If no logger has been set up yet, a\n<code>SystemStreamLog</code> logger will be created and returned.\n</p>\n<strong>Note:</strong>\nThe logger returned by this method must not be cached in an instance field during the construction of the mojo.\nThis would cause the mojo to use a wrongly configured default logger when being run by Maven. The proper logger\ngets injected by the Plexus container <em>after</em> the mojo has been constructed. Therefore, simply call this\nmethod directly whenever you need the logger, it is fast enough and needs no caching.\n\n@see org.apache.maven.plugin.Mojo#getLog()\n@deprecated Use SLF4J directly"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/composite-entity/src/main/java/com/iluwatar/compositeentity/CompositeEntity.java",
    "type": "method",
    "name": "setData",
    "code": "public void setData(String message, String signal) {\n    console.setData(message, signal);\n  }",
    "comment": "Composite entity is the coarse-grained entity bean which may be the coarse-grained object, or may\ncontain a reference to the coarse-grained object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/ovic/src/main/java/org/tensorflow/ovic/OvicDetectorBenchmarker.java",
    "type": "method",
    "name": "processBuffer",
    "code": "public boolean processBuffer(ByteBuffer image, int imageId) {\n    if (!readyToTest()) {\n      return false;\n    }\n    try {\n      if (!detector.detectByteBuffer(image, imageId)) {\n        return false;\n      }\n    } catch (RuntimeException e) {\n      Log.e(TAG, e.getMessage());\n      return false;\n    }\n\n    if (!benchmarkStarted) { // Skip the first image to discount warming-up time.\n      benchmarkStarted = true;\n    } else {\n      totalRuntimeNano += ((double) detector.result.latencyNano);\n    }\n    return true;  // Indicating that result is ready.\n  }",
    "comment": "Perform detection on a single ByteBuffer {@link ByteBuffer} image. The image must have the\nsame dimension that the model expects.\n\n@param image: a {@link ByteBuffer} image to process.\n@param imageId: an ID uniquely representing the image."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "isAllNull",
    "code": "public final boolean isAllNull() {\n    return isAllNull;\n  }",
    "comment": "Whether this column only contains null values."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractCommandBuilder.java",
    "type": "method",
    "name": "addToClassPath",
    "code": "private void addToClassPath(Set<String> cp, String entries) {\n    if (isEmpty(entries)) {\n      return;\n    }\n    String[] split = entries.split(Pattern.quote(File.pathSeparator));\n    for (String entry : split) {\n      if (!isEmpty(entry)) {\n        if (new File(entry).isDirectory() && !entry.endsWith(File.separator)) {\n        cp.add(entry);\n      }\n    }\n  }\n\n  private boolean isJarAvailable(String jarsDir, String jarNamePrefix) {\n    if (jarsDir != null) {\n      for (File f : new File(jarsDir).listFiles()) {\n      }\n    }\n    return false;\n  }\n\n  String getScalaVersion() {\n    String scala = getenv(\"SPARK_SCALA_VERSION\");\n    if (scala != null) {\n      return scala;\n    }\n    String sparkHome = getSparkHome();\n    File scala213 = new File(sparkHome, \"launcher/target/scala-2.13\");\n    checkState(scala213.isDirectory(), \"Cannot find any build directories.\");\n    return \"2.13\";\n    // String sparkHome = getSparkHome();\n    // File scala212 = new File(sparkHome, \"launcher/target/scala-2.12\");\n    // File scala213 = new File(sparkHome, \"launcher/target/scala-2.13\");\n    // checkState(!scala212.isDirectory() || !scala213.isDirectory(),\n    //  \"Presence of build for multiple Scala versions detected.\\n\" +\n    //  \"Either clean one of them or set SPARK_SCALA_VERSION in your environment.\");\n    // if (scala213.isDirectory()) {\n    //  return \"2.13\";\n    // } else {\n    //  checkState(scala212.isDirectory(), \"Cannot find any build directories.\");\n    //  return \"2.12\";\n    // }\n  }\n\n  String getSparkHome() {\n    String path = getenv(ENV_SPARK_HOME);\n    if (path == null && \"1\".equals(getenv(\"SPARK_TESTING\"))) {\n      path = System.getProperty(\"spark.test.home\");\n    }\n    checkState(path != null,\n      \"Spark home not found; set it explicitly or use the SPARK_HOME environment variable.\");\n    return path;\n  }\n\n  String getenv(String key) {\n    return firstNonEmpty(childEnv.get(key), System.getenv(key));\n  }\n\n  void setPropertiesFile(String path) {\n    effectiveConfig = null;\n    this.propertiesFile = path;\n  }\n\n  Map<String, String> getEffectiveConfig() throws IOException {\n    if (effectiveConfig == null) {\n      effectiveConfig = new HashMap<>(conf);\n      Properties p = loadPropertiesFile();\n      p.stringPropertyNames().forEach(key ->\n        effectiveConfig.computeIfAbsent(key, p::getProperty));\n      effectiveConfig.putIfAbsent(SparkLauncher.DRIVER_DEFAULT_EXTRA_CLASS_PATH,\n        SparkLauncher.DRIVER_DEFAULT_EXTRA_CLASS_PATH_VALUE);\n    }\n    return effectiveConfig;\n  }\n\n  private Properties loadPropertiesFile() throws IOException {\n    Properties props = new Properties();\n    File propsFile;\n    if (propertiesFile != null) {\n      propsFile = new File(propertiesFile);\n      checkArgument(propsFile.isFile(), \"Invalid properties file '%s'.\", propertiesFile);\n    } else {\n      propsFile = new File(getConfDir(), DEFAULT_PROPERTIES_FILE);\n    }\n\n    if (propsFile.isFile()) {\n      try (InputStreamReader isr = new InputStreamReader(\n          new FileInputStream(propsFile), StandardCharsets.UTF_8)) {\n      }\n    }\n    return props;\n  }\n\n  private String getConfDir() {\n    String confDir = getenv(\"SPARK_CONF_DIR\");\n    return confDir != null ? confDir : join(File.separator, getSparkHome(), \"conf\");\n  }\n\n}",
    "comment": "Loads the configuration file for the application, if it exists. This is either the\nuser-specified properties file, or the spark-defaults.conf file under the Spark configuration\ndirectory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java",
    "type": "method",
    "name": "stripBasedirToken",
    "code": "private String stripBasedirToken(String s) {\n        if (s != null) {\n            String basedirExpr = null;\n            for (String expression : BASEDIR_EXPRESSIONS) {\n                if (s.startsWith(expression)) {\n                    basedirExpr = expression;\n                    break;\n                }\n            }\n\n            if (basedirExpr != null) {\n                if (s.length() > basedirExpr.length()) {\n                    s = chopLeadingFileSeparator(s.substring(basedirExpr.length()));\n                } else {\n                    s = \".\";\n                }\n            }\n        }\n\n        return s;\n    }",
    "comment": "Take out basedir expression and the leading slash"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-client-side-ui-composition/src/main/java/com/iluwatar/clientsideuicomposition/ClientSideIntegrator.java",
    "type": "method",
    "name": "ClientSideIntegrator",
    "code": "public ClientSideIntegrator(ApiGateway apiGateway) {\n    this.apiGateway = apiGateway;\n  }",
    "comment": "Constructor that accepts an instance of ApiGateway to handle dynamic routing.\n\n@param apiGateway the gateway that routes requests to different frontend components"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/src/mdo/java/ImmutableCollections.java",
    "type": "method",
    "name": "ROProperties",
    "code": "private ROProperties(Properties props) {\n            super();\n            if (props != null) {\n                for (Map.Entry<Object, Object> e : props.entrySet()) {\n                    super.put(e.getKey(), e.getValue());\n                }\n            }\n        }",
    "comment": "Do not use super.putAll, as it may delegate to put which throws an UnsupportedOperationException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/CleanupNonShuffleServiceServedFilesSuite.java",
    "type": "method",
    "name": "assertStillThere",
    "code": "private static void assertStillThere(TestShuffleDataContext dataContext) {\n    for (String localDir : dataContext.localDirs) {\n      assertTrue(new File(localDir).exists(), localDir + \" was cleaned up prematurely\");\n    }\n  }",
    "comment": "Executor which only captures whether it's being used, without executing anything.\nMake sure it's not an error to cleanup multiple times"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/main/java/com/iluwatar/health/check/CpuHealthIndicator.java",
    "type": "method",
    "name": "health",
    "code": "public Health health() {\n\n    if (!(osBean instanceof com.sun.management.OperatingSystemMXBean sunOsBean)) {\n      LOGGER.error(\"Unsupported operating system MXBean: {}\", osBean.getClass().getName());\n      return Health.unknown()\n          .withDetail(ERROR_MESSAGE, \"Unsupported operating system MXBean\")\n          .build();\n    }\n\n    double systemCpuLoad = sunOsBean.getCpuLoad() * 100;\n    double processCpuLoad = sunOsBean.getProcessCpuLoad() * 100;\n    int availableProcessors = sunOsBean.getAvailableProcessors();\n    double loadAverage = sunOsBean.getSystemLoadAverage();\n\n    Map<String, Object> details = new HashMap<>();\n    details.put(\"timestamp\", Instant.now());\n    details.put(\"systemCpuLoad\", String.format(\"%.2f%%\", systemCpuLoad));\n    details.put(\"processCpuLoad\", String.format(\"%.2f%%\", processCpuLoad));\n    details.put(\"availableProcessors\", availableProcessors);\n    details.put(\"loadAverage\", loadAverage);\n\n    if (systemCpuLoad > systemCpuLoadThreshold) {\n      LOGGER.error(HIGH_SYSTEM_CPU_LOAD_MESSAGE, systemCpuLoad);\n      return Health.down()\n          .withDetails(details)\n          .withDetail(ERROR_MESSAGE, HIGH_SYSTEM_CPU_LOAD_MESSAGE_WITHOUT_PARAM)\n          .build();\n    } else if (processCpuLoad > processCpuLoadThreshold) {\n      LOGGER.error(HIGH_PROCESS_CPU_LOAD_MESSAGE, processCpuLoad);\n      return Health.down()\n          .withDetails(details)\n          .withDetail(ERROR_MESSAGE, HIGH_PROCESS_CPU_LOAD_MESSAGE_WITHOUT_PARAM)\n          .build();\n    } else if (loadAverage > (availableProcessors * loadAverageThreshold)) {\n      LOGGER.error(HIGH_LOAD_AVERAGE_MESSAGE, loadAverage);\n      return Health.up()\n          .withDetails(details)\n          .withDetail(ERROR_MESSAGE, HIGH_LOAD_AVERAGE_MESSAGE_WITHOUT_PARAM)\n          .build();\n    } else {\n      return Health.up().withDetails(details).build();\n    }\n  }",
    "comment": "Checks the health of the system's CPU and returns a health indicator object.\n\n@return a health indicator object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/Scope.java",
    "type": "method",
    "name": "withSubScope",
    "code": "public Scope withSubScope(String childScopeName) {\n    return new Scope(env, nameScope.withSubScope(childScopeName), controlDependencies);\n  }",
    "comment": "Returns a new scope where added operations will have the provided name prefix.\n\n<p>Ops created with this scope will have {@code name/childScopeName/} as the prefix. The actual\nname will be unique in the returned scope. All other properties are inherited from the current\nscope.\n\n<p>The child scope name must match the regular expression {@code [A-Za-z0-9.][A-Za-z0-9_.\\-]*}\n\n@param childScopeName name for the new child scope\n@return a new subscope\n@throws IllegalArgumentException if the name is invalid"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertInstanceOfAssertionsTests.java",
    "type": "method",
    "name": "assertInstanceOfFailsNullValue",
    "code": "void assertInstanceOfFailsNullValue() {\n\t\tassertInstanceOfFails(String.class, null, \"null value\");\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions#assertInstanceOf(Class, Object)}.\n\n@since 5.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/saga/src/main/java/com/iluwatar/saga/choreography/Saga.java",
    "type": "method",
    "name": "Chapter",
    "code": "public Chapter(String name) {\n      this.name = name;\n      this.result = ChapterResult.INIT;\n    }",
    "comment": "Class presents a chapter status and incoming parameters(incoming parameter transforms to\noutcoming parameter)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "numChars",
    "code": "public int numChars() {\n    if (numChars == -1) numChars = getNumChars();\n    return numChars;\n  }",
    "comment": "Returns the number of code points in it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/MethodMap.java",
    "type": "method",
    "name": "moreSpecific",
    "code": "private static int moreSpecific(Class<?>[] c1, Class<?>[] c2) {\n        boolean c1MoreSpecific = false;\n        boolean c2MoreSpecific = false;\n\n        for (int i = 0; i < c1.length; ++i) {\n            if (c1[i] != c2[i]) {\n                c1MoreSpecific = c1MoreSpecific || isStrictMethodInvocationConvertible(c2[i], c1[i]);\n                c2MoreSpecific = c2MoreSpecific || isStrictMethodInvocationConvertible(c1[i], c2[i]);\n            }\n        }\n\n        if (c1MoreSpecific) {\n            if (c2MoreSpecific) {\n                // Incomparable due to cross-assignable arguments (i.e.\n                // foo(String, Object) vs. foo(Object, String))\n                return INCOMPARABLE;\n            }\n\n            return MORE_SPECIFIC;\n        }\n\n        if (c2MoreSpecific) {\n            return LESS_SPECIFIC;\n        }\n\n        // Incomparable due to non-related arguments (i.e.\n        // foo(Runnable) vs. foo(Serializable))\n        return INCOMPARABLE;\n    }",
    "comment": "Determines which method signature (represented by a class array) is more\nspecific. This defines a partial ordering on the method signatures.\n\n@param c1 first signature to compare\n@param c2 second signature to compare\n@return MORE_SPECIFIC if c1 is more specific than c2, LESS_SPECIFIC if\nc1 is less specific than c2, INCOMPARABLE if they are incomparable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "cursorLeft",
    "code": "public Ansi cursorLeft(final int x) {\n        return x > 0 ? appendEscapeSequence('D', x) : x < 0 ? cursorRight(-x) : this;\n    }",
    "comment": "Moves the cursor left. If the parameter x is negative it moves the cursor right.\n\n@param x the number of characters to move left\n@return this Ansi instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Short expected, short actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Short) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "match",
    "code": "public static Resolution match(Match match) {\n\t\t\treturn new Resolution(singleton(match), emptySet());\n\t\t}",
    "comment": "Factory for creating a resolution that contains the supplied\n{@link Match Match}.\n\n@param match the resolved {@code Match}; never {@code null}\n@return an resolution that contains the supplied {@code Match}; never\n{@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/Vehicle.java",
    "type": "method",
    "name": "Vehicle",
    "code": "public Vehicle(int year, String make, String model, int id) {\n    this.make = make;\n    this.model = model;\n    this.year = year;\n    this.id = id;\n  }",
    "comment": "Constructs a Vehicle object with the given parameters.\n\n@param year the year of manufacture\n@param make the make of the vehicle\n@param model the model of the vehicle\n@param id the unique ID of the vehicle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/ReflectionValueExtractor.java",
    "type": "method",
    "name": "nextPropertyName",
    "code": "public String nextPropertyName() {\n            final int start = idx;\n\n            while (idx < expression.length() && Character.isJavaIdentifierPart(expression.charAt(idx))) {\n                idx++;\n            }\n\n            if (idx <= start || idx > expression.length()) {\n                return null;\n            }\n\n            return expression.substring(start, idx);\n        }",
    "comment": "property name does not require delimiter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/AllTests.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n        junit.textui.TestRunner.run(suite());\n    }",
    "comment": "TestSuite that runs all the sample tests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvn/CommonsCliMavenOptions.java",
    "type": "method",
    "name": "interpolate",
    "code": "private static CommonsCliMavenOptions interpolate(CommonsCliMavenOptions options, UnaryOperator<String> callback) {\n        try {\n            Interpolator interpolator = createInterpolator();\n            CommandLine.Builder commandLineBuilder = new CommandLine.Builder();\n            commandLineBuilder.setDeprecatedHandler(o -> {});\n            for (Option option : options.commandLine.getOptions()) {\n                if (!CLIManager.USER_PROPERTY.equals(option.getOpt())) {\n                    List<String> values = option.getValuesList();\n                    for (ListIterator<String> it = values.listIterator(); it.hasNext(); ) {\n                        it.set(interpolator.interpolate(it.next(), callback));\n                    }\n                }\n                commandLineBuilder.addOption(option);\n            }\n            for (String arg : options.commandLine.getArgList()) {\n                commandLineBuilder.addArg(interpolator.interpolate(arg, callback));\n            }\n            return new CommonsCliMavenOptions(\n                    options.source, (CLIManager) options.cliManager, commandLineBuilder.build());\n        } catch (InterpolatorException e) {\n            throw new IllegalArgumentException(\"Could not interpolate CommonsCliOptions\", e);\n        }\n    }",
    "comment": "now that we have properties, interpolate all arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java",
    "type": "method",
    "name": "removeNullValueWithTypeSafety",
    "code": "void removeNullValueWithTypeSafety() {\n\t\t\tInteger key = 42;\n\t\t\tstore.put(namespace, key, null);\n\n\t\t\tString removedValue = store.remove(namespace, key, String.class);\n\t\t\tassertNull(removedValue);\n\t\t\tassertNull(store.get(namespace, key));\n\t\t}",
    "comment": "The fact that we can declare this as a String suffices for testing the required type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/app/App.java",
    "type": "method",
    "name": "App",
    "code": "public App(Dispatcher dispatcher) {\n    this.dispatcher = dispatcher;\n  }",
    "comment": "Creates an instance of App which will use provided dispatcher for dispatching events on\nreactor.\n\n@param dispatcher the dispatcher that will be used to dispatch events."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assume.java",
    "type": "method",
    "name": "assumeThat",
    "code": "public static <T> void assumeThat(T actual, Matcher<T> matcher) {\n        if (!matcher.matches(actual)) {\n            throw new AssumptionViolatedException(actual, matcher);\n        }\n    }",
    "comment": "Call to assume that <code>actual</code> satisfies the condition specified by <code>matcher</code>.\nIf not, the test halts and is ignored.\nExample:\n<pre>:\nassumeThat(1, is(1)); // passes\nfoo(); // will execute\nassumeThat(0, is(1)); // assumption failure! test halts\nint x = 1 / 0; // will never execute\n</pre>\n\n@param <T> the static type accepted by the matcher (this can flag obvious compile-time problems such as {@code assumeThat(1, is(\"a\"))}\n@param actual the computed value being compared\n@param matcher an expression, built of {@link Matcher}s, specifying allowed values\n@see org.hamcrest.CoreMatchers\n@see org.junit.matchers.JUnitMatchers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "reportEntry",
    "code": "public static Condition<Event> reportEntry(Map<String, String> keyValuePairs) {\n\t\treturn new Condition<>(byPayload(ReportEntry.class, it -> it.getKeyValuePairs().equals(keyValuePairs)),\n\t\t\t\"event for report entry with key-value pairs %s\", keyValuePairs);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link ReportEntry} that contains the supplied key-value pairs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaColumnExpressionSuite.java",
    "type": "method",
    "name": "isInCollectionWorksCorrectlyOnJava",
    "code": "public void isInCollectionWorksCorrectlyOnJava() {\n    List<Row> rows = Arrays.asList(\n      RowFactory.create(1, \"x\"),\n      RowFactory.create(2, \"y\"),\n      RowFactory.create(3, \"z\"));\n    StructType schema = createStructType(Arrays.asList(\n      createStructField(\"a\", IntegerType, false),\n      createStructField(\"b\", StringType, false)));\n    Dataset<Row> df = spark.createDataFrame(rows, schema);\n    Assertions.assertArrayEquals(\n      (Row[]) df.filter(df.col(\"a\").isInCollection(Arrays.asList(1, 2))).collect(),\n      (Row[]) df.filter((FilterFunction<Row>) r -> r.getInt(0) == 1 || r.getInt(0) == 2).collect());\n    Assertions.assertArrayEquals(\n      (Row[]) df.filter(df.col(\"a\").isInCollection(new HashSet<>(Arrays.asList(1, 2)))).collect(),\n      (Row[]) df.filter((FilterFunction<Row>) r -> r.getInt(0) == 1 || r.getInt(0) == 2).collect());\n    Assertions.assertArrayEquals(\n      (Row[]) df.filter(df.col(\"a\").isInCollection(new ArrayList<>(Arrays.asList(3, 1)))).collect(),\n      (Row[]) df.filter((FilterFunction<Row>) r -> r.getInt(0) == 3 || r.getInt(0) == 1).collect());\n  }",
    "comment": "Test with different types of collections"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaMinMaxScalerExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaMinMaxScalerExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n        RowFactory.create(0, Vectors.dense(1.0, 0.1, -1.0)),\n        RowFactory.create(1, Vectors.dense(2.0, 1.1, 1.0)),\n        RowFactory.create(2, Vectors.dense(3.0, 10.1, 3.0))\n    );\n    StructType schema = new StructType(new StructField[]{\n    Dataset<Row> dataFrame = spark.createDataFrame(data, schema);\n\n    MinMaxScaler scaler = new MinMaxScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\");\n\n    MinMaxScalerModel scalerModel = scaler.fit(dataFrame);\n\n    Dataset<Row> scaledData = scalerModel.transform(dataFrame);\n    System.out.println(\"Features scaled to range: [\" + scaler.getMin() + \", \"\n        + scaler.getMax() + \"]\");\n    scaledData.select(\"features\", \"scaledFeatures\").show();\n\n    spark.stop();\n  }\n}",
    "comment": "$example on$\n$example off$\n$example on$\nCompute summary statistics and generate MinMaxScalerModel\nrescale each feature to range [min, max].\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertNotSame",
    "code": "public static void assertNotSame(String message, Object expected, Object actual) {\n        Assert.assertNotSame(message, expected, actual);\n    }",
    "comment": "Asserts that two objects do not refer to the same object. If they do\nrefer to the same object an AssertionFailedError is thrown with the\ngiven message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestReporter.java",
    "type": "method",
    "name": "publishEntry",
    "code": "default void publishEntry(String key, String value) {\n\t\tthis.publishEntry(Collections.singletonMap(key, value));\n\t}",
    "comment": "Publish the supplied key-value pair as a <em>report entry</em>.\n\n@param key the key of the entry to publish; never {@code null} or blank\n@param value the value of the entry to publish; never {@code null} or blank\n@see #publishEntry(Map)\n@see #publishEntry(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetDictionary.java",
    "type": "method",
    "name": "decodeToBinary",
    "code": "public byte[] decodeToBinary(int id) {\n    if (needTransform) {\n      long signed = dictionary.decodeToLong(id);\n      return new BigInteger(Long.toUnsignedString(signed)).toByteArray();\n    } else {\n      return dictionary.decodeToBinary(id).getBytesUnsafe();\n    }\n  }",
    "comment": "For unsigned int64, it stores as dictionary encoded signed int64 in Parquet\nwhenever dictionary is available.\nHere we lazily decode it to the original signed long value then convert to decimal(20, 0)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/lazy-loading/src/test/java/com/iluwatar/lazy/loading/AbstractHolderTest.java",
    "type": "method",
    "name": "testGetHeavy",
    "code": "void testGetHeavy() {\n    assertTimeout(\n        ofMillis(3000),\n        () -> {\n          assertNull(getInternalHeavyValue());\n          assertNotNull(getHeavy());\n          assertNotNull(getInternalHeavyValue());\n          assertSame(getHeavy(), getInternalHeavyValue());\n        });\n  }",
    "comment": "This test shows that the heavy field is not instantiated until the method getHeavy is called"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "removeLastSegment",
    "code": "public UniqueId removeLastSegment() {\n\t\tPreconditions.condition(this.segments.size() > 1, \"Cannot remove last remaining segment\");\n\t\treturn new UniqueId(uniqueIdFormat, new ArrayList<>(this.segments.subList(0, this.segments.size() - 1)));\n\t}",
    "comment": "Construct a new {@code UniqueId} and removing the last {@link Segment} of\n\n<p>This {@code UniqueId} will not be modified.\n\n@return a new {@code UniqueId}; never {@code null}\n@since 1.5"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "engine",
    "code": "public static Builder engine(TestEngine testEngine) {\n\t\tPreconditions.notNull(testEngine, \"TestEngine must not be null\");\n\t\treturn new Builder(testEngine);\n\t}",
    "comment": "Create an execution {@link Builder} for the supplied {@link TestEngine}.\n\n<h4>Example Usage</h4>\n\n<pre class=\"code\">\nEngineTestKit\n.engine(new MyTestEngine())\n.selectors(selectClass(MyTests.class))\n.execute()\n.testEvents()\n.assertStatistics(stats -&gt; stats.started(2).finished(2));\n</pre>\n\n@param testEngine the {@code TestEngine} to use; must not be {@code null}\n@return the engine execution {@code Builder}\n@throws PreconditionViolationException if the {@code TestEngine} is\n{@code null}\n@see #engine(String)\n@see #execute(String, LauncherDiscoveryRequest)\n@see #execute(TestEngine, LauncherDiscoveryRequest)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/SimpleTest.java",
    "type": "method",
    "name": "testAdd",
    "code": "public void testAdd() {\n        double result = fValue1 + fValue2;\n        assertTrue(result == 6);\n    }",
    "comment": "forced failure result == 5"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/game-loop/src/main/java/com/iluwatar/gameloop/FrameBasedGameLoop.java",
    "type": "method",
    "name": "processGameLoop",
    "code": "protected void processGameLoop() {\n    while (isGameRunning()) {\n      processInput();\n      update();\n      render();\n    }\n  }",
    "comment": "Frame-based game loop is the easiest implementation. The loop always keeps spinning for the\nfollowing three processes: processInput, update and render. The problem with it is you have no\ncontrol over how fast the game runs. On a fast machine, that loop will spin so fast users wont\nbe able to see whats going on. On a slow machine, the game will crawl. If you have a part of the\ngame thats content-heavy or does more AI or physics, the game will actually play slower there."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/artifact/DefaultProjectArtifactsCache.java",
    "type": "method",
    "name": "register",
    "code": "public void register(MavenProject project, Key cacheKey, CacheRecord record) {\n    }",
    "comment": "default cache does not track record usage"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/OutputRedirector.java",
    "type": "method",
    "name": "containsIgnoreCase",
    "code": "private static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n      return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n      if (str.regionMatches(true, i, searchStr, 0, len)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "Copied from Apache Commons Lang {@code StringUtils#containsIgnoreCase(String, String)}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "handleFailedDelete",
    "code": "private void handleFailedDelete() {\n      if (spillWriters.size() > 0) {\n        File file = spillWriters.removeFirst().getFile();\n        if (file != null && file.exists() && !file.delete()) {\n          logger.error(\"Was unable to delete spill file {}\",\n            MDC.of(LogKeys.PATH$.MODULE$, file.getAbsolutePath()));\n        }\n      }\n    }",
    "comment": "remove the spill file from disk"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/SslMessageEncoder.java",
    "type": "method",
    "name": "if",
    "code": "if (body != null && bodyLength > 0) {\n      if (body instanceof ByteBuf byteBuf) {\n        out.add(Unpooled.wrappedBuffer(header, byteBuf));\n      } else if (body instanceof InputStream || body instanceof ChunkedStream) {\n        out.add(new EncryptedMessageWithHeader(in.body(), header, body, bodyLength));\n      } else {\n        throw new IllegalArgumentException(\n          \"Body must be a ByteBuf, ChunkedStream or an InputStream\");\n      }\n    } else {\n      out.add(header);\n    }",
    "comment": "All messages have the frame length, message type, and message itself. The frame length\nmay optionally include the length of the body data, depending on what message is being\nsent.\nFor now, assume the InputStream is doing proper chunking."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeSortDataFormat.java",
    "type": "method",
    "name": "getKey",
    "code": "public RecordPointerAndKeyPrefix getKey(LongArray data, int pos) {\n    throw new UnsupportedOperationException();\n  }",
    "comment": "Since we re-use keys, this method shouldn't be called."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/resolver/DefaultModelResolverTest.java",
    "type": "method",
    "name": "setup",
    "code": "void setup() {\n        Path basedir = Paths.get(System.getProperty(\"basedir\", \"\"));\n        Path localRepoPath = basedir.resolve(\"target/local-repo\");\n        Path remoteRepoPath = basedir.resolve(\"src/test/remote-repo\");\n        Session s = ApiRunner.createSession(\n                injector -> {\n                    injector.bindInstance(DefaultModelResolverTest.class, this);\n                },\n                localRepoPath);\n        RemoteRepository remoteRepository = s.createRemoteRepository(\n                RemoteRepository.CENTRAL_ID, remoteRepoPath.toUri().toString());\n        session = s.withRemoteRepositories(List.of(remoteRepository));\n    }",
    "comment": "Test cases for the project {@code ModelResolver} implementation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/settings/SettingsUtils.java",
    "type": "method",
    "name": "SettingsUtils",
    "code": "private SettingsUtils() {\n        // don't allow construction.\n    }",
    "comment": "Several convenience methods to handle settings"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/metric/CustomSumMetric.java",
    "type": "method",
    "name": "aggregateTaskMetrics",
    "code": "public String aggregateTaskMetrics(long[] taskMetrics) {\n    long sum = 0L;\n    for (long taskMetric : taskMetrics) {\n      sum += taskMetric;\n    }\n    return String.valueOf(sum);\n  }",
    "comment": "Built-in `CustomMetric` that sums up metric values. Note that please extend this class\nand override `name` and `description` to create your custom metric for real usage.\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java17/org/junit/platform/console/options/ConsoleUtils.java",
    "type": "method",
    "name": "charset",
    "code": "public static Charset charset() {\n\t\tConsole console = System.console();\n\t\treturn console != null ? console.charset() : Charset.defaultCharset();\n\t}",
    "comment": "{@return the charset of the console}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "filters",
    "code": "public LauncherDiscoveryRequestBuilder filters(Filter<?>... filters) {\n\t\tPreconditions.notNull(filters, \"filters array must not be null\");\n\t\tPreconditions.containsNoNullElements(filters, \"individual filters must not be null\");\n\t\tArrays.stream(filters).forEach(this::storeFilter);\n\t\treturn this;\n\t}",
    "comment": "Add all supplied {@code filters} to the request.\n\n<p>The {@code filters} are combined using AND semantics, i.e. all of them\nhave to include a resource for it to end up in the test plan.\n\n<p><strong>Warning</strong>: be cautious when registering multiple competing\n{@link EngineFilter#includeEngines include} {@code EngineFilters} or multiple\ncompeting {@link EngineFilter#excludeEngines exclude} {@code EngineFilters}\nfor the same discovery request since doing so will likely lead to\nundesirable results (i.e., zero engines being active).\n\n@param filters the {@code Filter}s to add; never {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/DiscoveryIssueReporter.java",
    "type": "method",
    "name": "and",
    "code": "default Condition<T> and(Condition<? super T> that) {\n\t\t\tPreconditions.notNull(that, \"condition must not be null\");\n\t\t\treturn value -> this.check(value) & that.check(value);\n\t\t}",
    "comment": "Return a composed condition that represents a logical AND of this\nand the supplied condition.\n\n<p>The default implementation avoids short-circuiting so\n<em>both</em> conditions will be evaluated even if this condition\nreturns {@code false} to ensure that all issues are reported.\n\n@return the composed condition; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/PathModularizationCache.java",
    "type": "method",
    "name": "if",
    "code": "for (PathType type : types) {\n            if (filter.test(type)) {\n                if (JavaPathType.CLASSES.equals(type)) {\n                    classes = true;\n                } else if (JavaPathType.MODULES.equals(type)) {\n                    modules = true;\n                } else if (JavaPathType.PROCESSOR_CLASSES.equals(type)) {\n                    processorClasses = true;\n                } else if (JavaPathType.PROCESSOR_MODULES.equals(type)) {\n                    processorModules = true;\n                } else {\n                    unknown = true;\n                }\n                if (selected == null) {\n                    selected = type;\n                } else if (unknown) {\n                    // More than one filtered value, and we don't know how to handle at least one of them.\n                    // TODO: add a plugin mechanism for allowing plugin to specify their selection algorithm.\n                    return Optional.empty();\n                }\n            }\n        }",
    "comment": "Selects the type of path where to place the given dependency.\nThis method returns one of the values specified in the given collection.\nThis method does not handle the patch-module paths, because the patches\ndepend on which modules have been previously added on the module-paths.\n\n<p>If the dependency can be a constituent of both the class-path and the module-path,\nthen the path type is determined by checking if the dependency is modular.</p>\n\n@param types types of path where a dependency can be placed\n@param filter filter the paths accepted by the tool which will consume the path\n@param path path to the JAR file or output directory of the dependency\n@return where to place the dependency, or an empty value if the placement cannot be determined\n@throws IOException if an error occurred while reading module information"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/retry/src/test/java/com/iluwatar/retry/RetryExponentialBackoffTest.java",
    "type": "method",
    "name": "ignore",
    "code": "void ignore() {\n    final var e = new CustomerNotFoundException(\"customer not found\");\n    final var retry =\n        new RetryExponentialBackoff<String>(\n            () -> {\n              throw e;\n            },\n            2,\n            0,\n            ex -> CustomerNotFoundException.class.isAssignableFrom(ex.getClass()));\n    try {\n      retry.perform();\n    } catch (BusinessException ex) {\n      // ignore\n    }\n\n    assertThat(retry.attempts(), is(2));\n  }",
    "comment": "Final number of attempts should be equal to the number of attempts asked because we are asking\nit to ignore the exception that will be thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/ProtocolSuite.java",
    "type": "method",
    "name": "responses",
    "code": "public void responses() {\n    testServerToClient(new ChunkFetchSuccess(new StreamChunkId(1, 2), new TestManagedBuffer(10)));\n    testServerToClient(new ChunkFetchSuccess(new StreamChunkId(1, 2), new TestManagedBuffer(0)));\n    testServerToClient(new ChunkFetchFailure(new StreamChunkId(1, 2), \"this is an error\"));\n    testServerToClient(new ChunkFetchFailure(new StreamChunkId(1, 2), \"\"));\n    testServerToClient(new RpcResponse(12345, new TestManagedBuffer(0)));\n    testServerToClient(new RpcResponse(12345, new TestManagedBuffer(100)));\n    testServerToClient(new RpcFailure(0, \"this is an error\"));\n    testServerToClient(new RpcFailure(0, \"\"));\n    testServerToClient(new StreamResponse(\"anId\", 12345L, new TestManagedBuffer(0)));\n    testServerToClient(new StreamFailure(\"anId\", \"this is an error\"));\n  }",
    "comment": "Note: buffer size must be \"0\" since StreamResponse's buffer is written differently to the\nchannel and cannot be tested like this."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/TestSystem.java",
    "type": "method",
    "name": "exit",
    "code": "public void exit(int code) {\n        fCode = code;\n    }",
    "comment": "Will be removed in the next major release"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/CacheStore.java",
    "type": "method",
    "name": "readThrough",
    "code": "public UserAccount readThrough(final String userId) {\n    if (cache.contains(userId)) {\n      LOGGER.info(\"# Found in Cache!\");\n      return cache.get(userId);\n    }\n    LOGGER.info(\"# Not found in cache! Go to DB!!\");\n    UserAccount userAccount = dbManager.readFromDb(userId);\n    cache.set(userId, userAccount);\n    return userAccount;\n  }",
    "comment": "Get user account using read-through cache.\n\n@param userId {@link String}\n@return {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/OperatingSystemProfileActivator.java",
    "type": "method",
    "name": "isActive",
    "code": "public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        Activation activation = profile.getActivation();\n\n        if (activation == null) {\n            return false;\n        }\n\n        ActivationOS os = activation.getOs();\n\n        if (os == null) {\n            return false;\n        }\n\n        boolean active = ensureAtLeastOneNonNull(os);\n\n        String actualOsName = getSystemProperty(context, \"os.name\", Os.OS_NAME).toLowerCase(Locale.ENGLISH);\n        String actualOsArch = getSystemProperty(context, \"os.arch\", Os.OS_ARCH).toLowerCase(Locale.ENGLISH);\n        String actualOsVersion =\n                getSystemProperty(context, \"os.version\", Os.OS_VERSION).toLowerCase(Locale.ENGLISH);\n\n        if (active && os.getFamily() != null) {\n            active = determineFamilyMatch(os.getFamily(), actualOsName);\n        }\n        if (active && os.getName() != null) {\n            active = determineNameMatch(os.getName(), actualOsName);\n        }\n        if (active && os.getArch() != null) {\n            active = determineArchMatch(os.getArch(), actualOsArch);\n        }\n        if (active && os.getVersion() != null) {\n            active = determineVersionMatch(os.getVersion(), actualOsVersion);\n        }\n\n        return active;\n    }",
    "comment": "Determines profile activation based on the operating system of the current runtime platform.\n\n@see ActivationOS"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/EnabledIfSystemPropertyIntegrationTests.java",
    "type": "method",
    "name": "setSystemProperties",
    "code": "static void setSystemProperties() {\n\t\tSystem.setProperty(KEY1, ENIGMA);\n\t\tSystem.setProperty(KEY2, ENIGMA);\n\t}",
    "comment": "Integration tests for {@link EnabledIfSystemProperty}.\n\n@since 5.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcCertChain",
    "code": "public File sslRpcCertChain() {\n    String certChain = conf.get(\"spark.ssl.rpc.certChain\", null);\n    if (certChain != null) {\n      return new File(certChain);\n    } else {\n      return null;\n    }\n  }",
    "comment": "A X.509 certificate chain file in PEM format; can be relative to the current directory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectFile",
    "code": "public static FileSelector selectFile(String path, FilePosition position) {\n\t\tPreconditions.notBlank(path, \"File path must not be null or blank\");\n\t\treturn new FileSelector(path, position);\n\t}",
    "comment": "Create a {@code FileSelector} for the supplied file path.\n\n<p>This method selects the file using the supplied path <em>as is</em>,\nwithout verifying if the file exists.\n\n@param path the path to the file to select; never {@code null} or blank\n@param position the position inside the file; may be {@code null}\n@see FileSelector\n@see #selectFile(String)\n@see #selectFile(File)\n@see #selectFile(File, FilePosition)\n@see #selectDirectory(String)\n@see #selectDirectory(File)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java",
    "type": "method",
    "name": "from",
    "code": "public static MethodSource from(String className, String methodName) {\n\t\treturn new MethodSource(className, methodName);\n\t}",
    "comment": "Create a new {@code MethodSource} using the supplied class name and\n@param methodName the method name; must not be {@code null} or blank"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultSettingsBuilder.java",
    "type": "method",
    "name": "getSecuritySettings",
    "code": "ProblemCollector<BuilderProblem> problems) {\n        if (dispatchers.isEmpty()) {\n            return settings;\n        }\n        SecDispatcher secDispatcher = new DefaultSecDispatcher(dispatchers, getSecuritySettings(request.getSession()));\n        final AtomicInteger preMaven4Passwords = new AtomicInteger(0);\n        UnaryOperator<String> decryptFunction = str -> {\n            if (str != null && !str.isEmpty() && !str.contains(\"${\") && secDispatcher.isAnyEncryptedString(str)) {\n                if (secDispatcher.isLegacyEncryptedString(str)) {\n                    preMaven4Passwords.incrementAndGet();\n                }\n                try {\n                    return secDispatcher.decrypt(str);\n                } catch (Exception e) {\n                    problems.reportProblem(new DefaultBuilderProblem(\n                            settingsSource.getLocation(),\n                            -1,\n                            -1,\n                            e,\n                            \"Could not decrypt password (fix the corrupted password or remove it, if unused) \" + str,\n                            BuilderProblem.Severity.FATAL));\n                }\n            }\n            return str;\n        };\n        Settings result = new SettingsTransformer(decryptFunction).visit(settings);\n        if (preMaven4Passwords.get() > 0) {\n            problems.reportProblem(new DefaultBuilderProblem(\n                    settingsSource.getLocation(),\n                    -1,\n                    -1,\n                    null,\n                    \"Detected \" + preMaven4Passwords.get() + \" pre-Maven 4 legacy encrypted password(s) \"\n                            + \"- configure password encryption with the help of mvnenc for increased security.\",\n                    BuilderProblem.Severity.WARNING));\n        }\n        return result;\n    }\n\n    private Path getSecuritySettings(ProtoSession session) {\n        Map<String, String> properties = session.getUserProperties();\n        String settingsSecurity = properties.get(Constants.MAVEN_SETTINGS_SECURITY);\n        if (settingsSecurity != null) {\n            return Paths.get(settingsSecurity);\n        }\n        String mavenUserConf = properties.get(Constants.MAVEN_USER_CONF);\n        if (mavenUserConf != null) {\n            return Paths.get(mavenUserConf, Constants.MAVEN_SETTINGS_SECURITY_FILE_NAME);\n        }\n        return Paths.get(properties.get(\"user.home\"), \".m2\", Constants.MAVEN_SETTINGS_SECURITY_FILE_NAME);\n    }\n\n    @Override\n    public ProblemCollector<BuilderProblem> validate(Settings settings, boolean isProjectSettings) {\n        ProblemCollector<BuilderProblem> problems = ProblemCollector.create(null);\n        settingsValidator.validate(settings, isProjectSettings, problems);\n        return problems;\n    }\n\n    @Override\n    public Profile convert(org.apache.maven.api.model.Profile profile) {\n        return SettingsUtilsV4.convertToSettingsProfile(profile);\n    }\n\n    @Override\n    public org.apache.maven.api.model.Profile convert(Profile profile) {\n        return SettingsUtilsV4.convertFromSettingsProfile(profile);\n    }\n\n    static class DefaultSettingsBuilderResult implements SettingsBuilderResult {\n\n        private final SettingsBuilderRequest request;\n\n        private final Settings effectiveSettings;\n\n        private final ProblemCollector<BuilderProblem> problems;\n\n        DefaultSettingsBuilderResult(\n                SettingsBuilderRequest request, Settings effectiveSettings, ProblemCollector<BuilderProblem> problems) {\n            this.request = request;\n            this.effectiveSettings = effectiveSettings;\n            this.problems = (problems != null) ? problems : ProblemCollector.empty();\n        }\n\n        @Override\n        public SettingsBuilderRequest getRequest() {\n            return request;\n        }\n\n        @Override\n        public Settings getEffectiveSettings() {\n            return effectiveSettings;\n        }\n\n        @Override\n        public ProblemCollector<BuilderProblem> getProblems() {\n            return problems;\n        }\n    }\n}",
    "comment": "Collects the output of the settings builder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/BloomFilter.java",
    "type": "method",
    "name": "create",
    "code": "public static BloomFilter create(long expectedNumItems) {\n    return create(expectedNumItems, DEFAULT_FPP);\n  }",
    "comment": "Creates a {@link BloomFilter} with the expected number of insertions and a default expected\nfalse positive probability of 3%.\n\nNote that overflowing a {@code BloomFilter} with significantly more elements than specified,\nwill result in its saturation, and a sharp deterioration of its false positive probability."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/ClassMap.java",
    "type": "method",
    "name": "getAccessibleMethods",
    "code": "private static Method[] getAccessibleMethods(Class<?> clazz) {\n        Method[] methods = clazz.getMethods();\n\n        // Short circuit for the (hopefully) majority of cases where the\n        // clazz is public\n        if (Modifier.isPublic(clazz.getModifiers())) {\n            return methods;\n        }\n\n        // No luck - the class is not public, so we're going the longer way.\n        MethodInfo[] methodInfos = new MethodInfo[methods.length];\n        for (int i = methods.length; i-- > 0; ) {\n            methodInfos[i] = new MethodInfo(methods[i]);\n        }\n\n        int upcastCount = getAccessibleMethods(clazz, methodInfos, 0);\n\n        // Reallocate array in case some method had no accessible counterpart.\n        if (upcastCount < methods.length) {\n            methods = new Method[upcastCount];\n        }\n\n        int j = 0;\n        for (MethodInfo methodInfo : methodInfos) {\n            if (methodInfo.upcast) {\n                methods[j++] = methodInfo.method;\n            }\n        }\n        return methods;\n    }",
    "comment": "Retrieves public methods for a class. In case the class is not\npublic, retrieves methods with same signature as its public methods\nfrom public superclasses and interfaces (if they exist). Basically\nupcasts every method to the nearest acccessible method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/map-reduce/src/main/java/com/iluwatar/Main.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    List<String> inputs =\n        Arrays.asList(\n            \"Hello world hello\", \"MapReduce is fun\", \"Hello from the other side\", \"Hello world\");\n    List<Map.Entry<String, Integer>> result = MapReduce.mapReduce(inputs);\n    for (Map.Entry<String, Integer> entry : result) {\n      logger.info(entry.getKey() + \": \" + entry.getValue());\n    }\n  }",
    "comment": "The main method initiates the MapReduce process and displays the word count results.\n\n@param args Command-line arguments (not used)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/TimeMode.java",
    "type": "method",
    "name": "ProcessingTime",
    "code": "public static final TimeMode ProcessingTime() { return ProcessingTime$.MODULE$; }",
    "comment": "Stateful processor that uses query processing time to register timers and\ncalculate ttl expiration."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/results/PrintableResult.java",
    "type": "method",
    "name": "testResult",
    "code": "public static PrintableResult testResult(Class<?> type) {\n        return testResult(Request.aClass(type));\n    }",
    "comment": "The result of running JUnit on {@code type}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertIterableEquals",
    "code": "public static void assertIterableEquals(Iterable<?> expected, Iterable<?> actual, String message) {\n\t\tAssertIterableEquals.assertIterableEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} iterables are deeply equal.\n<p>Similarly to the check for deep equality in\n{@link #assertArrayEquals(Object[], Object[], String)}, if two iterables are encountered\n(including {@code expected} and {@code actual}) then their iterators must return equal\nelements in the same order as each other. <strong>Note:</strong> this means that the iterables\n<em>do not</em> need to be of the same type. Example: <pre>{@code\nimport static java.util.Arrays.asList;\n...\nIterable<Integer> i0 = new ArrayList<>(asList(1, 2, 3));\nIterable<Integer> i1 = new LinkedList<>(asList(1, 2, 3));\nassertIterableEquals(i0, i1); // Passes\n}</pre>\n<p>If both {@code expected} and {@code actual} are {@code null}, they are considered equal.\n<p>Fails with the supplied failure {@code message}.\n\n@see Objects#equals(Object, Object)\n@see Arrays#deepEquals(Object[], Object[])\n@see #assertArrayEquals(Object[], Object[], String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/iterator/src/main/java/com/iluwatar/iterator/bst/TreeNode.java",
    "type": "method",
    "name": "TreeNode",
    "code": "public TreeNode(T val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }",
    "comment": "Creates a TreeNode with a given value, and null children.\n\n@param val The value of the given node"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/di/testing/MavenDIExtension.java",
    "type": "method",
    "name": "setupContainer",
    "code": "protected void setupContainer() {\n        try {\n            injector = Injector.create();\n            injector.bindInstance(ExtensionContext.class, context);\n            injector.discover(context.getRequiredTestClass().getClassLoader());\n            injector.bindInstance(Injector.class, injector);\n            injector.bindInstance((Class) context.getRequiredTestClass(), context.getRequiredTestInstance());\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Failed to create DI injector.\", e);\n        }\n    }",
    "comment": "Creates and configures the DI container for test execution.\nPerforms component discovery and sets up basic bindings.\n\n@throws IllegalArgumentException if container setup fails"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toInt",
    "code": "public boolean toInt(IntWrapper intWrapper) {\n    return toInt(intWrapper, true);\n  }",
    "comment": "Parses this UTF8String(trimmed if needed) to int.\n\nNote that, in this method we accumulate the result in negative format, and convert it to\npositive format at the end, if this string is not started with '-'. This is because min value\nis bigger than max value in digits, e.g. Integer.MAX_VALUE is '2147483647' and\nInteger.MIN_VALUE is '-2147483648'.\n\nThis code is mostly copied from LazyInt.parseInt in Hive.\n\nNote that, this method is almost same as `toLong`, but we leave it duplicated for performance\nreasons, like Hive does.\n\n@param intWrapper If a valid `int` was parsed from this UTF8String, then its value would\nbe set in `intWrapper`\n@return true if the parsing was successful else false"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/LookupInvoker.java",
    "type": "method",
    "name": "doCreateTerminal",
    "code": "protected void doCreateTerminal(C context, TerminalBuilder builder) {\n        if (context.invokerRequest.embedded()) {\n            InputStream in = context.invokerRequest.stdIn().orElse(InputStream.nullInputStream());\n            OutputStream out = context.invokerRequest.stdOut().orElse(OutputStream.nullOutputStream());\n            builder.streams(in, out);\n            builder.provider(TerminalBuilder.PROP_PROVIDER_EXEC);\n            context.coloredOutput = context.coloredOutput != null ? context.coloredOutput : false;\n            context.closeables.add(out::flush);\n        } else {\n            builder.systemOutput(TerminalBuilder.SystemOutput.ForcedSysOut);\n        }\n        if (context.coloredOutput != null) {\n            builder.color(context.coloredOutput);\n        }\n    }",
    "comment": "Override this method to create Terminal as you want.\n\n@see #createTerminal(LookupContext)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "cloneListeners",
    "code": "private synchronized List<TestListener> cloneListeners() {\n        List<TestListener> result = new ArrayList<TestListener>();\n        result.addAll(fListeners);\n        return result;\n    }",
    "comment": "Returns a copy of the listeners."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/rootlocator/PomXmlRootDetector.java",
    "type": "method",
    "name": "isRootDirectory",
    "code": "public boolean isRootDirectory(Path dir) {\n        Path pom = dir.resolve(\"pom.xml\");\n        try (InputStream is = Files.newInputStream(pom)) {\n            XMLStreamReader parser = XMLInputFactory.newFactory().createXMLStreamReader(is);\n            if (parser.nextTag() == XMLStreamReader.START_ELEMENT\n                    && parser.getLocalName().equals(\"project\")) {\n                for (int i = 0; i < parser.getAttributeCount(); i++) {\n                    if (\"root\".equals(parser.getAttributeLocalName(i))) {\n                        return Boolean.parseBoolean(parser.getAttributeValue(i));\n                    }\n                }\n            }\n        } catch (IOException | XMLStreamException e) {\n        }\n        return false;\n    }",
    "comment": "we're too early to use the modelProcessor ...\nThe root locator can be used very early during the setup of Maven,\neven before the arguments from the command line are parsed.  Any exception\nthat would happen here should cause the build to fail at a later stage\n(when actually parsing the POM) and will lead to a better exception being\ndisplayed to the user, so just bail out and return false."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/manager/DefaultWagonManager.java",
    "type": "method",
    "name": "getAuthenticationInfo",
    "code": "public AuthenticationInfo getAuthenticationInfo(String id) {\n        MavenSession session = legacySupport.getSession();\n\n        if (session != null && id != null) {\n            MavenExecutionRequest request = session.getRequest();\n\n            if (request != null) {\n                List<Server> servers = request.getServers();\n\n                if (servers != null) {\n                    for (Server server : servers) {\n                        if (id.equalsIgnoreCase(server.getId())) {\n                            SettingsDecryptionResult result =\n                                    settingsDecrypter.decrypt(new DefaultSettingsDecryptionRequest(server));\n                            server = result.getServer();\n\n                            AuthenticationInfo authInfo = new AuthenticationInfo();\n                            authInfo.setUserName(server.getUsername());\n                            authInfo.setPassword(server.getPassword());\n                            authInfo.setPrivateKey(server.getPrivateKey());\n                            authInfo.setPassphrase(server.getPassphrase());\n\n                            return authInfo;\n                        }\n                    }\n                }\n            }\n        }\n\n        // empty one to prevent NPE\n        return new AuthenticationInfo();\n    }",
    "comment": "Manages <a href=\"https://maven.apache.org/wagon\">Wagon</a> related operations in Maven."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "receiveBuf",
    "code": "public int receiveBuf() { return conf.getInt(SPARK_NETWORK_IO_RECEIVEBUFFER_KEY, -1); }",
    "comment": "Receive buffer size (SO_RCVBUF).\nNote: the optimal size for receive buffer and send buffer should be\nlatency * network_bandwidth.\nAssuming latency = 1ms, network_bandwidth = 10Gbps\nbuffer size should be ~ 1.25MB"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnsh/CommonsCliShellOptions.java",
    "type": "method",
    "name": "interpolate",
    "code": "private static CommonsCliShellOptions interpolate(CommonsCliShellOptions options, UnaryOperator<String> callback) {\n        try {\n            Interpolator interpolator = createInterpolator();\n            CommandLine.Builder commandLineBuilder = new CommandLine.Builder();\n            commandLineBuilder.setDeprecatedHandler(o -> {});\n            for (Option option : options.commandLine.getOptions()) {\n                if (!CLIManager.USER_PROPERTY.equals(option.getOpt())) {\n                    List<String> values = option.getValuesList();\n                    for (ListIterator<String> it = values.listIterator(); it.hasNext(); ) {\n                        it.set(interpolator.interpolate(it.next(), callback));\n                    }\n                }\n                commandLineBuilder.addOption(option);\n            }\n            for (String arg : options.commandLine.getArgList()) {\n                commandLineBuilder.addArg(interpolator.interpolate(arg, callback));\n            }\n            return new CommonsCliShellOptions(\n                    options.source, (CLIManager) options.cliManager, commandLineBuilder.build());\n        } catch (InterpolatorException e) {\n            throw new IllegalArgumentException(\"Could not interpolate CommonsCliOptions\", e);\n        }\n    }",
    "comment": "now that we have properties, interpolate all arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/TestRun.java",
    "type": "method",
    "name": "getUnambiguously",
    "code": "Optional<VintageTestDescriptor> getUnambiguously(Description description) {\n\t\t\tif (descriptors.isEmpty()) {\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t\tif (descriptors.size() == 1) {\n\t\t\t\treturn Optional.of(descriptors.get(0));\n\t\t\t}\n\t\t\t// @formatter:off\n\t\t\treturn descriptors.stream()\n\t\t\t\t\t.filter(testDescriptor -> description == testDescriptor.getDescription())\n\t\t\t\t\t.findFirst();\n\t\t\t// @formatter:on\n\t\t}",
    "comment": "Returns the {@link TestDescriptor} that represents the specified\n{@link Description}.\n\n<p>There are edge cases where multiple {@link Description Descriptions}\nwith the same {@code uniqueId} exist, e.g. when using overloaded methods\nto define {@linkplain org.junit.experimental.theories.Theory theories}.\nIn this case, we try to find the correct {@link TestDescriptor} by\nchecking for object identity on the {@link Description} it represents.\n\n@param description the {@code Description} to look up"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/JupiterEngineExecutionContextTests.java",
    "type": "method",
    "name": "executionListenerIsHandedOnWhenContextIsExtended",
    "code": "void executionListenerIsHandedOnWhenContextIsExtended() {\n\t\tassertSame(engineExecutionListener, originalContext.getExecutionListener());\n\t\tJupiterEngineExecutionContext newContext = originalContext.extend().build();\n\t\tassertSame(engineExecutionListener, newContext.getExecutionListener());\n\t}",
    "comment": "Unit tests for {@link JupiterEngineExecutionContext}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/test/java/com/example/android/persistence/migrations/UserPresenterTest.java",
    "type": "method",
    "name": "onDataNotAvailable_updatesView",
    "code": "public void onDataNotAvailable_updatesView() {\n        mPresenter.start();\n        verify(mUserRepository).getUser(mLoadUserCallbackArgumentCaptor.capture());\n\n        mLoadUserCallbackArgumentCaptor.getValue().onDataNotAvailable();\n\n        verify(mView).hideUserName();\n    }",
    "comment": "Given that start is called\nCallback is captured\nWhen the data is not available\nThe view is updated"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/OutputMode.java",
    "type": "method",
    "name": "Complete",
    "code": "public static OutputMode Complete() {\n    return InternalOutputModes.Complete$.MODULE$;\n  }",
    "comment": "OutputMode in which all the rows in the streaming DataFrame/Dataset will be written\nto the sink every time there are some updates. This output mode can only be used in queries\nthat contain aggregations.\n\n@since 2.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/master-worker/src/main/java/com/iluwatar/masterworker/system/systemworkers/ArrayTransposeWorker.java",
    "type": "method",
    "name": "executeOperation",
    "code": "ArrayResult executeOperation() {\n    var arrayInput = (ArrayInput) this.getReceivedData();\n    final var rows = arrayInput.data[0].length;\n    final var cols = arrayInput.data.length;\n    var resultData = new int[rows][cols];\n    for (var i = 0; i < cols; i++) {\n      for (var j = 0; j < rows; j++) {\n        resultData[j][i] = arrayInput.data[i][j];\n      }\n    }\n    return new ArrayResult(resultData);\n  }",
    "comment": "number of rows in result matrix is equal to number of columns in input matrix and vice versa\nflipping element positions along diagonal"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/test/java/org/apache/spark/launcher/InProcessLauncherSuite.java",
    "type": "method",
    "name": "runTest",
    "code": "public static void runTest(String[] args) {\n    try {\n      assertTrue(args.length != 0);\n\n      final AtomicReference<String> port = new AtomicReference<>();\n      final AtomicReference<String> secret = new AtomicReference<>();\n      SparkSubmitOptionParser parser = new SparkSubmitOptionParser() {\n            }\n          }\n\n          return true;\n        }",
    "comment": "Because the test doesn't implement the launcher protocol, the final state here will be\nLOST instead of FINISHED.\nMake sure at least the launcher-provided config options are in the args array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/DeltaWrite.java",
    "type": "method",
    "name": "toBatch",
    "code": "default DeltaBatchWrite toBatch() {\n    throw new SparkUnsupportedOperationException(\n      \"_LEGACY_ERROR_TEMP_3139\", Map.of(\"description\", description()));\n  }",
    "comment": "A logical representation of a data source write that handles a delta of rows.\n\n@since 3.4.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/main/java/com/iluwatar/circuitbreaker/MonitoringService.java",
    "type": "method",
    "name": "quickServiceResponse",
    "code": "public String quickServiceResponse() {\n    try {\n      return this.quickService.attemptRequest();\n    } catch (RemoteServiceException e) {\n      return e.getMessage();\n    }\n  }",
    "comment": "Fetches response from a healthy service without any failure.\n\n@return response string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "lowercaseStartsWith",
    "code": "public static boolean lowercaseStartsWith(final UTF8String target, final UTF8String pattern) {\n    // Fast path for ASCII-only strings.\n    if (target.isFullAscii() && pattern.isFullAscii()) {\n      return target.toLowerCase().startsWith(pattern.toLowerCase());\n    }\n    // Slow path for non-ASCII strings.\n    return CollationAwareUTF8String.lowercaseMatchFrom(target, lowerCaseCodePointsSlow(pattern), 0);\n  }",
    "comment": "Checks whether the target string starts with the pattern string, with respect to the UTF8_LCASE\ncollation. This method generally works with respect to code-point based comparison logic.\n\n@param target the string to be searched in\n@param pattern the string to be searched for\n@return whether the target string starts with the pattern string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "ColumnVector",
    "code": "protected ColumnVector(DataType type) {\n    if (type instanceof UserDefinedType) {\n      this.type = ((UserDefinedType) type).sqlType();\n    } else {\n      this.type = type;\n    }\n  }",
    "comment": "Sets up the data type of this column vector."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertNotNullAssertionsTests.java",
    "type": "method",
    "name": "assertNotNullWithNonNullObject",
    "code": "void assertNotNullWithNonNullObject() {\n\t\tassertNotNull(\"foo\");\n\t\tassertNotNull(\"foo\", \"message\");\n\t\tassertNotNull(\"foo\", () -> \"message\");\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/MavenExecutionPlan.java",
    "type": "method",
    "name": "getNonThreadSafeMojos",
    "code": "public Set<MojoDescriptor> getNonThreadSafeMojos() {\n        Set<MojoDescriptor> mojos = new HashSet<>();\n        for (ExecutionPlanItem executionPlanItem : planItem) {\n            final MojoExecution mojoExecution = executionPlanItem.getMojoExecution();\n            if (!mojoExecution.getMojoDescriptor().isThreadSafe()) {\n                mojos.add(mojoExecution.getMojoDescriptor());\n            }\n        }\n        return mojos;\n    }",
    "comment": "Get set of mojos used but not marked @threadSafe\n\n@return the set of mojo descriptors"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultLifecycleBindingsInjector.java",
    "type": "method",
    "name": "merge",
    "code": "public Model merge(Model target, Model source) {\n            Build targetBuild = target.getBuild();\n            if (targetBuild == null) {\n                targetBuild = Build.newInstance();\n            }\n\n            Map<Object, Object> context =\n                    Collections.singletonMap(PLUGIN_MANAGEMENT, targetBuild.getPluginManagement());\n\n            Build.Builder builder = Build.newBuilder(targetBuild);\n            mergePluginContainer_Plugins(builder, targetBuild, source.getBuild(), false, context);\n\n            return target.withBuild(builder.build());\n        }",
    "comment": "The domain-specific model merger for lifecycle bindings"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/BeforeAndAfterAllTests.java",
    "type": "method",
    "name": "beforeAllMethodThrowsAnException",
    "code": "void beforeAllMethodThrowsAnException() {\n\t\tassertBeforeAllAndAfterAllCallbacks(ExceptionInBeforeAllMethodTestCase.class, 0, 0,\n\t\t\t\"fooBeforeAllCallback\",\n\t\t\t\t\"beforeAllMethod\", // throws an exception.\n\t\t\t\t\"afterAllMethod\",\n\t\t\t\"fooAfterAllCallback\"\n\t\t);\n\n\t\tassertThat(actualExceptionInAfterAllCallback).containsInstanceOf(EnigmaException.class);\n\t}",
    "comment": "@formatter:off\ntest should not get invoked.\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestPlan.java",
    "type": "method",
    "name": "getChildren",
    "code": "public Set<TestIdentifier> getChildren(String parentId) {\n\t\tPreconditions.notBlank(parentId, \"parent ID must not be null or blank\");\n\t\treturn getChildren(UniqueId.parse(parentId));\n\t}",
    "comment": "Get the children of the supplied unique ID.\n\n@param parentId the unique ID to look up the children for; never\n{@code null} or blank\n@return an unmodifiable set of the parent's children, potentially empty\n@see #getChildren(TestIdentifier)\n@deprecated Use {@link #getChildren(UniqueId)}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "matches",
    "code": "public Object matches(List<Object> args) {\n        if (args.size() != 2) {\n            throw new IllegalArgumentException(\"matches function requires exactly two arguments\");\n        }\n        String s = ConditionParser.toString(args.get(0));\n        String regex = ConditionParser.toString(args.get(1));\n        return s.matches(regex);\n    }",
    "comment": "Checks if a string matches a given regular expression.\n\n@param args A list containing two strings: the string to check and the regex pattern\n@return true if the string matches the regex, false otherwise\n@throws IllegalArgumentException if the number of arguments is not exactly two"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutExtension.java",
    "type": "method",
    "name": "isTimeoutDisabled",
    "code": "private boolean isTimeoutDisabled(String mode) {\n\t\tswitch (mode) {\n\t\t\tcase ENABLED_MODE_VALUE:\n\t\t\t\treturn false;\n\t\t\tcase DISABLED_MODE_VALUE:\n\t\t\t\treturn true;\n\t\t\tcase DISABLED_ON_DEBUG_MODE_VALUE:\n\t\t\t\treturn RuntimeUtils.isDebugMode();\n\t\t\tdefault:\n\t\t\t\tthrow new ExtensionConfigurationException(\"Unsupported timeout mode: \" + mode);\n\t\t}\n\t}",
    "comment": "Determine if timeouts are disabled for the supplied mode."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createCharType",
    "code": "public static CharType createCharType(int length) {\n    return new CharType(length);\n  }",
    "comment": "Creates a CharType with the given length.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "getMaxNumberOfDelegatedPartitions",
    "code": "public int getMaxNumberOfDelegatedPartitions() {\n      return this.maxDelegatedPartitions == null ? -1 : this.maxDelegatedPartitions;\n    }",
    "comment": "Returns the maximum number of graph partitions that the delegate will try to delegate. Or -1\nif no maximum has neen set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/command/src/test/java/com/iluwatar/command/CommandTest.java",
    "type": "method",
    "name": "testCommand",
    "code": "void testCommand() {\n\n    var wizard = new Wizard();\n    var goblin = new Goblin();\n\n    wizard.castSpell(goblin::changeSize);\n    verifyGoblin(goblin, GOBLIN, Size.SMALL, Visibility.VISIBLE);\n\n    wizard.castSpell(goblin::changeVisibility);\n    verifyGoblin(goblin, GOBLIN, Size.SMALL, Visibility.INVISIBLE);\n\n    wizard.undoLastSpell();\n    verifyGoblin(goblin, GOBLIN, Size.SMALL, Visibility.VISIBLE);\n\n    wizard.undoLastSpell();\n    verifyGoblin(goblin, GOBLIN, Size.NORMAL, Visibility.VISIBLE);\n\n    wizard.redoLastSpell();\n    verifyGoblin(goblin, GOBLIN, Size.SMALL, Visibility.VISIBLE);\n\n    wizard.redoLastSpell();\n    verifyGoblin(goblin, GOBLIN, Size.SMALL, Visibility.INVISIBLE);\n  }",
    "comment": "This test verifies that when the wizard casts spells on the goblin. The wizard keeps track of\nthe previous spells cast, so it is easy to undo them. In addition, it also verifies that the\nwizard keeps track of the spells undone, so they can be redone."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/metadata/MetadataGraphVertex.java",
    "type": "method",
    "name": "MetadataGraphVertex",
    "code": "public MetadataGraphVertex(ArtifactMetadata md) {\n        super();\n        this.md = md;\n    }",
    "comment": "metadata graph vertice - just a wrapper around artifact's metadata"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/chain-of-responsibility/src/main/java/com/iluwatar/chain/Request.java",
    "type": "method",
    "name": "Request",
    "code": "public Request(final RequestType requestType, final String requestDescription) {\n    this.requestType = Objects.requireNonNull(requestType);\n    this.requestDescription = Objects.requireNonNull(requestDescription);\n  }",
    "comment": "Create a new request of the given type and accompanied description.\n\n@param requestType The type of request\n@param requestDescription The description of the request"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/RuleChain.java",
    "type": "method",
    "name": "emptyRuleChain",
    "code": "public static RuleChain emptyRuleChain() {\n        return EMPTY_CHAIN;\n    }",
    "comment": "Returns a {@code RuleChain} without a {@link TestRule}. This method may\nbe the starting point of a {@code RuleChain}.\n\n@return a {@code RuleChain} without a {@link TestRule}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/MavenSession.java",
    "type": "method",
    "name": "getPluginContext",
    "code": "public Map<String, Object> getPluginContext(PluginDescriptor plugin, MavenProject project) {\n        String projectKey = project.getId();\n\n        ConcurrentMap<String, ConcurrentMap<String, Object>> pluginContextsByKey =\n                pluginContextsByProjectAndPluginKey.computeIfAbsent(projectKey, k -> new ConcurrentHashMap<>());\n\n        String pluginKey = plugin.getPluginLookupKey();\n\n        return pluginContextsByKey.computeIfAbsent(pluginKey, k -> new ConcurrentHashMap<>());\n    }",
    "comment": "Returns the plugin context for given key ({@link PluginDescriptor#getPluginLookupKey()} and\n{@link MavenProject}, never returns {@code null} as if context not present, creates it.\n\n<strong>Implementation note:</strong> while this method return type is {@link Map}, the returned map instance\nimplements {@link ConcurrentMap} as well."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-aggregator/src/test/java/com/iluwatar/event/aggregator/EventEmitterTest.java",
    "type": "method",
    "name": "testAllDays",
    "code": "void testAllDays() {\n    testAllDaysWithoutDefaultObserver(specialDay, event);\n    testAllDaysWithDefaultObserver(specialDay, event);\n  }",
    "comment": "Go over every day of the month, and check if the event is emitted on the given day. This test\nis executed twice, once without a default emitter and once with"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ArtifactResolverResult.java",
    "type": "method",
    "name": "getResult",
    "code": "default ResultItem getResult(ArtifactCoordinates coordinates) {\n        return getResults().get(coordinates);\n    }",
    "comment": "Retrieves the resolution result for a specific set of artifact coordinates.\n\n@param coordinates The {@link ArtifactCoordinates} identifying the artifact.\n@return The corresponding {@link ResultItem}, or {@code null} if no result exists."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/retry/src/test/java/com/iluwatar/retry/RetryTest.java",
    "type": "method",
    "name": "attempts",
    "code": "void attempts() {\n    final var e = new BusinessException(\"unhandled\");\n    final var retry =\n        new Retry<String>(\n            () -> {\n              throw e;\n            },\n            2,\n            0);\n    try {\n      retry.perform();\n    } catch (BusinessException ex) {\n      // ignore\n    }\n\n    assertThat(retry.attempts(), is(1));\n  }",
    "comment": "No exceptions will be ignored, hence final number of attempts should be 1 even if we're asking\nit to attempt twice."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java",
    "type": "method",
    "name": "runProgrammaticSchemaExample",
    "code": "private static void runProgrammaticSchemaExample(SparkSession spark) {\n    JavaRDD<String> peopleRDD = spark.sparkContext()\n      .textFile(\"examples/src/main/resources/people.txt\", 1)\n      .toJavaRDD();\n\n    String schemaString = \"name age\";\n\n    List<StructField> fields = new ArrayList<>();\n    for (String fieldName : schemaString.split(\" \")) {\n      StructField field = DataTypes.createStructField(fieldName, DataTypes.StringType, true);\n      fields.add(field);\n    }\n    StructType schema = DataTypes.createStructType(fields);\n\n    JavaRDD<Row> rowRDD = peopleRDD.map((Function<String, Row>) record -> {\n      String[] attributes = record.split(\",\");\n      return RowFactory.create(attributes[0], attributes[1].trim());\n    });\n\n    Dataset<Row> peopleDataFrame = spark.createDataFrame(rowRDD, schema);\n\n    peopleDataFrame.createOrReplaceTempView(\"people\");\n\n    Dataset<Row> results = spark.sql(\"SELECT name FROM people\");\n\n    Dataset<String> namesDS = results.map(\n        (MapFunction<Row, String>) row -> \"Name: \" + row.getString(0),\n        Encoders.STRING());\n    namesDS.show();\n  }",
    "comment": "$example on:programmatic_schema$\nCreate an RDD\nThe schema is encoded in a string\nGenerate the schema based on the string of schema\nConvert records of the RDD (people) to Rows\nApply the schema to the RDD\nCreates a temporary view using the DataFrame\nSQL can be run over a temporary view created using DataFrames\nThe results of SQL queries are DataFrames and support all the normal RDD operations\nThe columns of a row in the result can be accessed by field index or by field name\n+-------------+\n|        value|\n+-------------+\n|Name: Michael|\n|   Name: Andy|\n| Name: Justin|\n+-------------+\n$example off:programmatic_schema$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "finishedWithFailure",
    "code": "public static Condition<Event> finishedWithFailure() {\n\t\treturn finished(TestExecutionResultConditions.status(FAILED));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link EventType#FINISHED} and its\n{@linkplain Event#getPayload() result} has a\n{@linkplain TestExecutionResult#getStatus() status} of\n{@link TestExecutionResult.Status#FAILED FAILED}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/Scan.java",
    "type": "method",
    "name": "toContinuousStream",
    "code": "default ContinuousStream toContinuousStream(String checkpointLocation) {\n    throw new SparkUnsupportedOperationException(\n      \"_LEGACY_ERROR_TEMP_3149\", Map.of(\"description\", description()));\n  }",
    "comment": "Returns the physical representation of this scan for streaming query with continuous mode. By\ndefault this method throws exception, data sources must overwrite this method to provide an\nimplementation, if the {@link Table} that creates this scan returns\n{@link TableCapability#CONTINUOUS_READ} support in its {@link Table#capabilities()}.\n\n@param checkpointLocation a path to Hadoop FS scratch space that can be used for failure\nrecovery. Data streams for the same logical source in the same query\nwill be given the same checkpointLocation.\n\n@throws UnsupportedOperationException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenIT0108SnapshotUpdateTest.java",
    "type": "method",
    "name": "getMetadataFile",
    "code": "private File getMetadataFile(String groupId, String artifactId, String version) {\n        return new File(verifier.getArtifactMetadataPath(groupId, artifactId, version, \"maven-metadata-local.xml\"));\n    }",
    "comment": "create artifact in repository (TODO: into verifier)\nset in the past to ensure it is downloaded\nupdate the remote file, but we shouldn't be looking"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroOptionalPrimitives.java",
    "type": "method",
    "name": "setMaybeIntColumn",
    "code": "public void setMaybeIntColumn(java.lang.Integer value) {\n    this.maybe_int_column = value;\n  }",
    "comment": "Sets the value of the 'maybe_int_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/DelegatePerformanceBenchmark.java",
    "type": "method",
    "name": "getModelName",
    "code": "public static String getModelName(String filename) {\n    checkNotNull(filename);\n    checkArgument(filename.endsWith(MODEL_EXT));\n    return filename.substring(0, filename.length() - MODEL_EXT.length());\n  }",
    "comment": "Extracts the model name from the model file name.\n\n<p>Strips out the \".tflite\" extension from the input. Returns \"model\" if the input filename is\n\"model.tflite\"."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/xml/XmlWriterRequest.java",
    "type": "method",
    "name": "builder",
    "code": "static <T> XmlWriterRequestBuilder<T> builder() {\n        return new XmlWriterRequestBuilder<>();\n    }",
    "comment": "An XML writer request.\n\n@since 4.0.0\n@param <T> the object type to read"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/injection/sample/NullIntegerParameterResolver.java",
    "type": "method",
    "name": "supportsParameter",
    "code": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn Integer.class == parameterContext.getParameter().getType()\n\t\t\t\t|| int.class == parameterContext.getParameter().getType();\n\t}",
    "comment": "Example {@link ParameterResolver} that always resolves an\n{@link Integer} or {@code int} parameter to a {@code null} value.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/di/testing/MavenDIExtension.java",
    "type": "method",
    "name": "getBasedir",
    "code": "public static String getBasedir() {\n        if (basedir != null) {\n            return basedir;\n        }\n\n        basedir = System.getProperty(\"basedir\");\n\n        if (basedir == null) {\n            basedir = new File(\"\").getAbsolutePath();\n        }\n\n        return basedir;\n    }",
    "comment": "Returns the base directory for test execution.\nUses the \"basedir\" system property if set, otherwise uses the current directory.\n\n@return The base directory path"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/resolution/UnresolvableModelException.java",
    "type": "method",
    "name": "UnresolvableModelException",
    "code": "public UnresolvableModelException(String message, String groupId, String artifactId, String version) {\n        super(message);\n        this.groupId = (groupId != null) ? groupId : \"\";\n        this.artifactId = (artifactId != null) ? artifactId : \"\";\n        this.version = (version != null) ? version : \"\";\n    }",
    "comment": "Creates a new exception with specified detail message.\n\n@param message The detail message, may be {@code null}.\n@param groupId The group id of the unresolvable model, may be {@code null}.\n@param artifactId The artifact id of the unresolvable model, may be {@code null}.\n@param version The version of the unresolvable model, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/TensorImpl.java",
    "type": "method",
    "name": "setTo",
    "code": "private void setTo(Buffer src) {\n    if (src instanceof ByteBuffer) {\n      ByteBuffer srcBuffer = (ByteBuffer) src;\n      if (srcBuffer.isDirect() && srcBuffer.order() == ByteOrder.nativeOrder()) {\n        writeDirectBuffer(nativeHandle, src);\n      } else {\n        buffer().put(srcBuffer);\n      }\n    } else if (src instanceof LongBuffer) {\n      LongBuffer srcBuffer = (LongBuffer) src;\n      if (srcBuffer.isDirect() && srcBuffer.order() == ByteOrder.nativeOrder()) {\n        writeDirectBuffer(nativeHandle, src);\n      } else {\n        buffer().asLongBuffer().put(srcBuffer);\n      }\n    } else if (src instanceof FloatBuffer) {\n      FloatBuffer srcBuffer = (FloatBuffer) src;\n      if (srcBuffer.isDirect() && srcBuffer.order() == ByteOrder.nativeOrder()) {\n        writeDirectBuffer(nativeHandle, src);\n      } else {\n        buffer().asFloatBuffer().put(srcBuffer);\n      }\n    } else if (src instanceof IntBuffer) {\n      IntBuffer srcBuffer = (IntBuffer) src;\n      if (srcBuffer.isDirect() && srcBuffer.order() == ByteOrder.nativeOrder()) {\n        writeDirectBuffer(nativeHandle, src);\n      } else {\n        buffer().asIntBuffer().put(srcBuffer);\n      }\n    } else if (src instanceof ShortBuffer) {\n      ShortBuffer srcBuffer = (ShortBuffer) src;\n      if (srcBuffer.isDirect() && srcBuffer.order() == ByteOrder.nativeOrder()) {\n        writeDirectBuffer(nativeHandle, src);\n      } else {\n        buffer().asShortBuffer().put(srcBuffer);\n      }\n    } else {\n      throw new IllegalArgumentException(\"Unexpected input buffer type: \" + src);\n    }\n  }",
    "comment": "Note that we attempt to use a direct memcpy optimization for direct, native-ordered buffers.\nThere are no base Buffer#order() or Buffer#put() methods, so again we have to ugly cast."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom3/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "insertAndGetUser",
    "code": "public void insertAndGetUser() {\n        // When inserting a new user in the data source\n        mDataSource.insertOrUpdateUser(USER);\n\n        //The user can be retrieved\n        User dbUser = mDataSource.getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), USER.getUserName());\n        assertEquals(dbUser.getDate(), USER.getDate());\n    }",
    "comment": "Integration tests for the {@link LocalUserDataSource} implementation with Room."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/repository/Authentication.java",
    "type": "method",
    "name": "setPassphrase",
    "code": "public void setPassphrase(final String passphrase) {\n        this.passphrase = passphrase;\n    }",
    "comment": "Set the passphrase of the private key file.\n\n@param passphrase passphrase of the private key file"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/VehicleDatabase.java",
    "type": "method",
    "name": "getTruck",
    "code": "public Truck getTruck(int id) {\n    return truckTable.get(id);\n  }",
    "comment": "Retrieves a truck by its ID.\n\n@param id the ID of the truck\n@return the truck with the given ID, or null if not found"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-expression/src/main/java/org/apache/maven/plugin/coreit/ExpressionUtil.java",
    "type": "method",
    "name": "evaluate",
    "code": "private static Map evaluate(String prefix, List segments, Object context) {\n        Map values = Collections.EMPTY_MAP;\n\n        if (segments.isEmpty()) {\n            values = Collections.singletonMap(prefix, context);\n        } else if (context != null) {\n            Map targets = Collections.EMPTY_MAP;\n            String segment = (String) segments.get(0);\n            if (context.getClass().isArray() && Character.isDigit(segment.charAt(0))) {\n                try {\n                    int index = Integer.parseInt(segment);\n                    targets = Collections.singletonMap(segment, Array.get(context, index));\n                } catch (RuntimeException e) {\n                    // invalid index, just ignore\n                }\n            } else if ((context instanceof List) && Character.isDigit(segment.charAt(0))) {\n                try {\n                    int index = Integer.parseInt(segment);\n                    targets = Collections.singletonMap(segment, ((List) context).get(index));\n                } catch (RuntimeException e) {\n                    // invalid index, just ignore\n                }\n            } else if ((context instanceof Collection) && \"*\".equals(segment)) {\n                targets = new LinkedHashMap();\n                int index = 0;\n                for (Iterator it = ((Collection) context).iterator(); it.hasNext(); index++) {\n                    targets.put(Integer.toString(index), it.next());\n                }\n            } else if (context.getClass().isArray() && \"*\".equals(segment)) {\n                targets = new LinkedHashMap();\n                for (int index = 0, n = Array.getLength(context); index < n; index++) {\n                    targets.put(Integer.toString(index), Array.get(context, index));\n                }\n            } else {\n                targets = Collections.singletonMap(segment, getProperty(context, segment));\n            }\n\n            values = new LinkedHashMap();\n            for (Object key : targets.keySet()) {\n                Object target = targets.get(key);\n                values.putAll(\n                        evaluate(concat(prefix, String.valueOf(key)), segments.subList(1, segments.size()), target));\n            }\n        }\n\n        return values;\n    }",
    "comment": "Evaluates the given expression segments against the specified object.\n\n@param prefix   The expression prefix that led to the current context, must not be <code>null</code>.\n@param segments The expression segments to evaluate, must not be <code>null</code>.\n@param context  The object to evaluate the segments against, may be <code>null</code>.\n@return The values of the evaluation, indexed by expression, or an empty map if the segments could not be\nevaluated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcTrustStoreReloadingEnabled",
    "code": "public boolean sslRpcTrustStoreReloadingEnabled() {\n    return conf.getBoolean(\"spark.ssl.rpc.trustStoreReloadingEnabled\", false);\n  }",
    "comment": "If using a trust-store that that reloads its configuration is enabled.\nIf true, when the trust-store file on disk changes, it will be reloaded"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java",
    "type": "method",
    "name": "advance",
    "code": "private void advance() {\n\t\t\ttry {\n\t\t\t\tString[] csvRecord = this.csvParser.parseNext();\n\t\t\t\tif (csvRecord != null) {\n\t\t\t\t\tif (this.useHeadersInDisplayName && this.headers == null) {\n\t\t\t\t\t\tthis.headers = getHeaders(this.csvParser);\n\t\t\t\t\t}\n\t\t\t\t\tthis.nextArguments = processCsvRecord(csvRecord, this.nullValues, this.useHeadersInDisplayName,\n\t\t\t\t\t\tthis.headers);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.nextArguments = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable throwable) {\n\t\t\t\tthrow handleCsvException(throwable, this.csvFileSource);\n\t\t\t}\n\t\t}",
    "comment": "Lazily retrieve headers if necessary."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/Java8APISuite.java",
    "type": "method",
    "name": "testMap",
    "code": "public void testMap() {\n    List<List<String>> inputData = Arrays.asList(\n      Arrays.asList(\"hello\", \"world\"),\n      Arrays.asList(\"goodnight\", \"moon\"));\n\n    List<List<Integer>> expected = Arrays.asList(\n      Arrays.asList(5, 5),\n      Arrays.asList(9, 4));\n\n    JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1);\n    JavaDStream<Integer> letterCount = stream.map(String::length);\n    JavaTestUtils.attachTestOutputStream(letterCount);\n    List<List<Integer>> result = JavaTestUtils.runStreams(ssc, 2, 2);\n\n    assertOrderInvariantEquals(expected, result);\n  }",
    "comment": "Most of these tests replicate org.apache.spark.streaming.JavaAPISuite using java 8\nlambda syntax."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/SupportsPartitionManagement.java",
    "type": "method",
    "name": "partitionExists",
    "code": "default boolean partitionExists(InternalRow ident) {\n      String[] partitionNames = partitionSchema().names();\n      if (ident.numFields() == partitionNames.length) {\n        return listPartitionIdentifiers(partitionNames, ident).length > 0;\n      } else {\n        throw QueryExecutionErrors.partitionNumMismatchError(\n          ident.numFields(), partitionNames.length);\n      }\n    }",
    "comment": "Test whether a partition exists using an {@link InternalRow ident} from the table.\n\n@param ident a partition identifier which must contain all partition fields in order\n@return true if the partition exists, false otherwise"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(MethodSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link MethodSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java",
    "type": "method",
    "name": "throwable",
    "code": "public static Condition<TestExecutionResult> throwable(Condition<Throwable>... conditions) {\n\t\tList<Condition<TestExecutionResult>> list = Arrays.stream(conditions)//\n\t\t\t\t.map(TestExecutionResultConditions::throwable)//\n\t\t\t\t.collect(toList());\n\n\t\treturn Assertions.allOf(list);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if a\n{@linkplain TestExecutionResult#getThrowable() throwable} matches all\nsupplied conditions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/EngineFilter.java",
    "type": "method",
    "name": "includeEngines",
    "code": "public static EngineFilter includeEngines(String... engineIds) {\n\t\treturn includeEngines(Arrays.asList(engineIds));\n\t}",
    "comment": "Create a new <em>include</em> {@code EngineFilter} based on the\n<em>included</em> within the test discovery and execution.\n\n@param engineIds the list of engine IDs to match against; never {@code null}\nor empty; individual IDs must also not be null or blank\n@see #includeEngines(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/OneForOneBlockPusher.java",
    "type": "method",
    "name": "checkAndFailRemainingBlocks",
    "code": "private void checkAndFailRemainingBlocks(int index, Throwable e) {\n    if (PUSH_ERROR_HANDLER.shouldRetryError(e)) {\n      String[] targetBlockId = Arrays.copyOfRange(blockIds, index, index + 1);\n      failRemainingBlocks(targetBlockId, e);\n    } else {\n      String[] targetBlockId = Arrays.copyOfRange(blockIds, index, blockIds.length);\n      failRemainingBlocks(targetBlockId, e);\n    }\n  }",
    "comment": "Since block push is best effort, i.e., if we encounter a block push failure that's still\nretriable according to ErrorHandler (not a connection exception and the block is not too\nlate), we should not fail all remaining block pushes even though\nRetryingBlockTransferor might consider this failure not retriable (exceeding max retry\ncount etc). The best effort nature makes block push tolerable of a partial completion.\nThus, we only fail the block that's actually failed in this case. Note that, on the\nRetryingBlockTransferor side, if retry is initiated, it would still invalidate the\nprevious active retry listener, and retry pushing all outstanding blocks. However, since\nthe blocks to be pushed are preloaded into memory and the first attempt of pushing these\nblocks might have already succeeded, retry pushing all the outstanding blocks should be\nvery cheap (on the client side, the block data is in memory; on the server side, the block\nwill be recognized as a duplicate which triggers noop handling). Here, by failing only the\none block that's actually failed, we are essentially preventing forwarding unnecessary\nblock push failures to the parent listener of the retry listener.\n\nTake the following as an example. For the common exception during block push handling,\ni.e. block collision, it is considered as retriable by ErrorHandler but not retriable\nby RetryingBlockTransferor. When we encounter a failure of this type, we only fail the\none block encountering this issue not the remaining blocks in the same batch. On the\nRetryingBlockTransferor side, since this exception is considered as not retriable, it\nwould immediately invoke parent listener's onBlockTransferFailure. However, the remaining\nblocks in the same batch would remain current and active and they won't be impacted by\nthis exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/double-dispatch/src/test/java/com/iluwatar/doubledispatch/RectangleTest.java",
    "type": "method",
    "name": "testConstructor",
    "code": "void testConstructor() {\n    final var rectangle = new Rectangle(1, 2, 3, 4);\n    assertEquals(1, rectangle.getLeft());\n    assertEquals(2, rectangle.getTop());\n    assertEquals(3, rectangle.getRight());\n    assertEquals(4, rectangle.getBottom());\n  }",
    "comment": "Test if the values passed through the constructor matches the values fetched from the getters"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-builder-support/src/main/java/org/apache/maven/building/FileSource.java",
    "type": "method",
    "name": "FileSource",
    "code": "public FileSource(File file) {\n        this(Objects.requireNonNull(file, \"file cannot be null\").toPath());\n    }",
    "comment": "Creates a new source backed by the specified file.\n\n@param file The file, must not be {@code null}.\n@deprecated Use {@link #FileSource(Path)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/ParserRequest.java",
    "type": "method",
    "name": "mvnsh",
    "code": "static Builder mvnsh(@Nonnull List<String> args, @Nonnull MessageBuilderFactory messageBuilderFactory) {\n        return builder(Tools.MVNSHELL_CMD, Tools.MVNSHELL_NAME, args, messageBuilderFactory);\n    }",
    "comment": "Creates a new Builder instance for constructing a Maven Shell Tool ParserRequest.\n\n@param args the command-line arguments\n@param messageBuilderFactory the factory for creating message builders\n@return a new Builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelValidator.java",
    "type": "method",
    "name": "validateFileModel",
    "code": "public void validateFileModel(Model m, int validationLevel, ModelProblemCollector problems) {\n\n        Parent parent = m.getParent();\n        if (parent != null) {\n            validateStringNotEmpty(\n                    \"parent.groupId\", problems, Severity.FATAL, Version.BASE, parent.getGroupId(), parent);\n\n            validateStringNotEmpty(\n                    \"parent.artifactId\", problems, Severity.FATAL, Version.BASE, parent.getArtifactId(), parent);\n\n            if (equals(parent.getGroupId(), m.getGroupId()) && equals(parent.getArtifactId(), m.getArtifactId())) {\n                addViolation(\n                        problems,\n                        Severity.FATAL,\n                        Version.BASE,\n                        \"parent.artifactId\",\n                        null,\n                        \"must be changed\"\n                                + \", the parent element cannot have the same groupId:artifactId as the project.\",\n                        parent);\n            }\n\n            if (equals(\"LATEST\", parent.getVersion()) || equals(\"RELEASE\", parent.getVersion())) {\n                addViolation(\n                        problems,\n                        Severity.WARNING,\n                        Version.BASE,\n                        \"parent.version\",\n                        null,\n                        \"is either LATEST or RELEASE (both of them are being deprecated)\",\n                        parent);\n            }\n\n            if (parent.getRelativePath() != null\n                    && !parent.getRelativePath().isEmpty()\n                    && (parent.getGroupId() != null && !parent.getGroupId().isEmpty()\n                            || parent.getArtifactId() != null\n                                    && !parent.getArtifactId().isEmpty())\n                    && validationLevel >= ModelValidator.VALIDATION_LEVEL_MAVEN_4_0\n                    && VALID_MODEL_VERSIONS.contains(m.getModelVersion())\n                    && !Objects.equals(m.getModelVersion(), ModelBuilder.MODEL_VERSION_4_0_0)) {\n                addViolation(\n                        problems,\n                        Severity.WARNING,\n                        Version.BASE,\n                        \"parent.relativePath\",\n                        null,\n                        \"only specify relativePath or groupId/artifactId in modelVersion 4.1.0\",\n                        parent);\n            }\n        }\n\n        if (validationLevel == ModelValidator.VALIDATION_LEVEL_MINIMAL) {\n            HashSet<String> minProfileIds = new HashSet<>();\n            for (Profile profile : m.getProfiles()) {\n                if (!minProfileIds.add(profile.getId())) {\n                    addViolation(\n                            problems,\n                            Severity.WARNING,\n                            Version.BASE,\n                            \"profiles.profile.id\",\n                            null,\n                            \"Duplicate activation for profile \" + profile.getId(),\n                            profile);\n                }\n            }\n        } else if (validationLevel >= ModelValidator.VALIDATION_LEVEL_MAVEN_2_0) {\n            validateStringNotEmpty(\"modelVersion\", problems, Severity.ERROR, Version.V20, m.getModelVersion(), m);\n\n            validateModelVersion(problems, m.getModelVersion(), m, VALID_MODEL_VERSIONS);\n\n            Set<String> modules = new HashSet<>();\n            for (int i = 0, n = m.getModules().size(); i < n; i++) {\n                String module = m.getModules().get(i);\n                if (!modules.add(module)) {\n                    addViolation(\n                            problems,\n                            Severity.ERROR,\n                            Version.V20,\n                            \"modules.module[\" + i + \"]\",\n                            null,\n                            \"specifies duplicate child module \" + module,\n                            m.getLocation(\"modules\"));\n                }\n            }\n            String modelVersion = m.getModelVersion();\n            if (Objects.equals(modelVersion, ModelBuilder.MODEL_VERSION_4_0_0)) {\n                if (!m.getSubprojects().isEmpty()) {\n                    addViolation(\n                            problems,\n                            Severity.ERROR,\n                            Version.V40,\n                            \"subprojects\",\n                            null,\n                            \"unexpected subprojects element\",\n                            m.getLocation(\"subprojects\"));\n                }\n            } else {\n                Set<String> subprojects = new HashSet<>();\n                for (int i = 0, n = m.getSubprojects().size(); i < n; i++) {\n                    String subproject = m.getSubprojects().get(i);\n                    if (!subprojects.add(subproject)) {\n                        addViolation(\n                                problems,\n                                Severity.ERROR,\n                                Version.V41,\n                                \"subprojects.subproject[\" + i + \"]\",\n                                null,\n                                \"specifies duplicate subproject \" + subproject,\n                                m.getLocation(\"subprojects\"));\n                    }\n                }\n                if (!modules.isEmpty()) {\n                    if (subprojects.isEmpty()) {\n                        addViolation(\n                                problems,\n                                Severity.WARNING,\n                                Version.V41,\n                                \"modules\",\n                                null,\n                                \"deprecated modules element, use subprojects instead\",\n                                m.getLocation(\"modules\"));\n                    } else {\n                        addViolation(\n                                problems,\n                                Severity.ERROR,\n                                Version.V41,\n                                \"modules\",\n                                null,\n                                \"cannot use both modules and subprojects element\",\n                                m.getLocation(\"modules\"));\n                    }\n                }\n            }\n\n            Severity errOn30 = getSeverity(validationLevel, ModelValidator.VALIDATION_LEVEL_MAVEN_3_0);\n\n            boolean isModelVersion41OrMore = !Objects.equals(ModelBuilder.MODEL_VERSION_4_0_0, m.getModelVersion());\n            if (isModelVersion41OrMore) {\n                validateStringNoExpression(\"groupId\", problems, Severity.FATAL, Version.V41, m.getGroupId(), m);\n\n                validateStringNotEmpty(\"artifactId\", problems, Severity.FATAL, Version.V20, m.getArtifactId(), m);\n                validateStringNoExpression(\"artifactId\", problems, Severity.FATAL, Version.V20, m.getArtifactId(), m);\n\n                validateVersionNoExpression(\"version\", problems, Severity.FATAL, Version.V41, m.getVersion(), m);\n\n                if (parent != null) {\n                    validateStringNoExpression(\n                            \"groupId\", problems, Severity.FATAL, Version.V41, parent.getGroupId(), m);\n                    validateStringNoExpression(\n                            \"artifactId\", problems, Severity.FATAL, Version.V41, parent.getArtifactId(), m);\n                    validateVersionNoExpression(\n                            \"version\", problems, Severity.FATAL, Version.V41, parent.getVersion(), m);\n                }\n            } else {\n                validateStringNoExpression(\"groupId\", problems, Severity.WARNING, Version.V20, m.getGroupId(), m);\n                if (parent == null) {\n                    validateStringNotEmpty(\"groupId\", problems, Severity.FATAL, Version.V20, m.getGroupId(), m);\n                }\n\n                validateStringNoExpression(\"artifactId\", problems, Severity.WARNING, Version.V20, m.getArtifactId(), m);\n                validateStringNotEmpty(\"artifactId\", problems, Severity.FATAL, Version.V20, m.getArtifactId(), m);\n\n                validateVersionNoExpression(\"version\", problems, Severity.WARNING, Version.V20, m.getVersion(), m);\n                if (parent == null) {\n                    validateStringNotEmpty(\"version\", problems, Severity.FATAL, Version.V20, m.getVersion(), m);\n                }\n            }\n\n            validateStringNoExpression(\"packaging\", problems, Severity.WARNING, Version.V20, m.getPackaging(), m);\n\n            validate20RawDependencies(\n                    problems,\n                    m.getDependencies(),\n                    \"dependencies.dependency.\",\n                    EMPTY,\n                    isModelVersion41OrMore,\n                    validationLevel);\n\n            validate20RawDependenciesSelfReferencing(problems, m, m.getDependencies(), \"dependencies.dependency\");\n\n            if (m.getDependencyManagement() != null) {\n                validate20RawDependencies(\n                        problems,\n                        m.getDependencyManagement().getDependencies(),\n                        \"dependencyManagement.dependencies.dependency.\",\n                        EMPTY,\n                        isModelVersion41OrMore,\n                        validationLevel);\n            }\n\n            validateRawRepositories(problems, m.getRepositories(), \"repositories.repository.\", EMPTY, validationLevel);\n\n            validateRawRepositories(\n                    problems,\n                    m.getPluginRepositories(),\n                    \"pluginRepositories.pluginRepository.\",\n                    EMPTY,\n                    validationLevel);\n\n            Build build = m.getBuild();\n            if (build != null) {\n                validate20RawPlugins(problems, build.getPlugins(), \"build.plugins.plugin.\", EMPTY, validationLevel);\n\n                PluginManagement mgmt = build.getPluginManagement();\n                if (mgmt != null) {\n                    validate20RawPlugins(\n                            problems,\n                            mgmt.getPlugins(),\n                            \"build.pluginManagement.plugins.plugin.\",\n                            EMPTY,\n                            validationLevel);\n                }\n            }\n\n            Set<String> profileIds = new HashSet<>();\n\n            for (Profile profile : m.getProfiles()) {\n                String prefix = \"profiles.profile[\" + profile.getId() + \"].\";\n\n                validateProfileId(prefix, \"id\", problems, Severity.ERROR, Version.V40, profile.getId(), null, m);\n\n                if (!profileIds.add(profile.getId())) {\n                    addViolation(\n                            problems,\n                            errOn30,\n                            Version.V20,\n                            \"profiles.profile.id\",\n                            null,\n                            \"must be unique but found duplicate profile with id \" + profile.getId(),\n                            profile);\n                }\n\n                validate30RawProfileActivation(problems, profile.getActivation(), prefix);\n\n                validate20RawDependencies(\n                        problems,\n                        profile.getDependencies(),\n                        prefix,\n                        \"dependencies.dependency.\",\n                        isModelVersion41OrMore,\n                        validationLevel);\n\n                if (profile.getDependencyManagement() != null) {\n                    validate20RawDependencies(\n                            problems,\n                            profile.getDependencyManagement().getDependencies(),\n                            prefix,\n                            \"dependencyManagement.dependencies.dependency.\",\n                            isModelVersion41OrMore,\n                            validationLevel);\n                }\n\n                validateRawRepositories(\n                        problems, profile.getRepositories(), prefix, \"repositories.repository.\", validationLevel);\n\n                validateRawRepositories(\n                        problems,\n                        profile.getPluginRepositories(),\n                        prefix,\n                        \"pluginRepositories.pluginRepository.\",\n                        validationLevel);\n\n                BuildBase buildBase = profile.getBuild();\n                if (buildBase != null) {\n                    validate20RawPlugins(problems, buildBase.getPlugins(), prefix, \"plugins.plugin.\", validationLevel);\n\n                    PluginManagement mgmt = buildBase.getPluginManagement();\n                    if (mgmt != null) {\n                        validate20RawPlugins(\n                                problems,\n                                mgmt.getPlugins(),\n                                prefix,\n                                \"pluginManagement.plugins.plugin.\",\n                                validationLevel);\n                    }\n                }\n            }\n        }\n    }",
    "comment": "profiles: they are essential for proper model building (may contribute profiles, dependencies...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng6772NestedImportScopeRepositoryOverride.java",
    "type": "method",
    "name": "overrideGlobalSettings",
    "code": "private void overrideGlobalSettings(final File testDir, final Verifier verifier) {\n        final File settingsFile = new File(testDir, \"settings-override.xml\");\n        final String path = settingsFile.getAbsolutePath();\n        verifier.addCliArgument(\"--global-settings\");\n        if (path.indexOf(' ') < 0) {\n            verifier.addCliArgument(path);\n        } else {\n            verifier.addCliArgument('\"' + path + '\"');\n        }\n    }",
    "comment": "This will test the behavior using ProjectModelResolver\nThis will test the behavior using DefaultModelResolver\ncentral must not be defined in any settings.xml or super POM will never be in play."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Long> create(long[][][] data) {\n    return Tensor.create(data, Long.class);\n  }",
    "comment": "Creates a rank-3 tensor of {@code long} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "appendObjects",
    "code": "public Optional<Integer> appendObjects(int length, Object value) {\n    if (value instanceof Boolean) {\n      return Optional.of(appendBooleans(length, (Boolean) value));\n    }\n    if (value instanceof Byte) {\n      return Optional.of(appendBytes(length, (Byte) value));\n    }\n    if (value instanceof Decimal decimal) {\n      long unscaled = decimal.toUnscaledLong();\n      if (decimal.precision() <= Decimal.MAX_INT_DIGITS()) {\n        return Optional.of(appendInts(length, (int) unscaled));\n      } else if (decimal.precision() <= Decimal.MAX_LONG_DIGITS()) {\n        return Optional.of(appendLongs(length, unscaled));\n      } else {\n        BigInteger integer = decimal.toJavaBigDecimal().unscaledValue();\n        byte[] bytes = integer.toByteArray();\n        int result = 0;\n        for (int i = 0; i < length; ++i) {\n          result += appendByteArray(bytes, 0, bytes.length);\n        }\n        return Optional.of(result);\n      }\n    }\n    if (value instanceof Double) {\n      return Optional.of(appendDoubles(length, (Double) value));\n    }\n    if (value instanceof Float) {\n      return Optional.of(appendFloats(length, (Float) value));\n    }\n    if (value instanceof Integer) {\n      return Optional.of(appendInts(length, (Integer) value));\n    }\n    if (value instanceof Long) {\n      return Optional.of(appendLongs(length, (Long) value));\n    }\n    if (value instanceof Short) {\n      return Optional.of(appendShorts(length, (Short) value));\n    }\n    if (value instanceof UTF8String utf8) {\n      byte[] bytes = utf8.getBytes();\n      int result = 0;\n      for (int i = 0; i < length; ++i) {\n        result += appendByteArray(bytes, 0, bytes.length);\n      }\n      return Optional.of(result);\n    }\n    if (value instanceof GenericArrayData arrayData) {\n      int result = 0;\n      for (int i = 0; i < length; ++i) {\n        appendArray(arrayData.numElements());\n        for (Object element : arrayData.array()) {\n          if (arrayData().appendObjects(1, element).isEmpty()) {\n            return Optional.empty();\n          }\n        }\n        result += arrayData.numElements();\n      }\n      return Optional.of(result);\n    }\n    if (value instanceof GenericInternalRow row) {\n      int result = 0;\n      for (int i = 0; i < length; ++i) {\n        appendStruct(false);\n        for (int j = 0; j < row.values().length; ++j) {\n          Object element = row.values()[j];\n          if (childColumns[j].appendObjects(1, element).isEmpty()) {\n            return Optional.empty();\n          }\n        }\n        result += row.values().length;\n      }\n      return Optional.of(result);\n    }\n    if (value instanceof ArrayBasedMapData data) {\n      appendArray(length);\n      int result = 0;\n      for (int i = 0; i < length; ++i) {\n        for (Object key : data.keyArray().array()) {\n          if (childColumns[0].appendObjects(1, key).isEmpty()) {\n            return Optional.empty();\n          }\n        }\n        for (Object val: data.valueArray().array()) {\n          if (childColumns[1].appendObjects(1, val).isEmpty()) {\n            return Optional.empty();\n          }\n        }\n        result += data.keyArray().numElements();\n      }\n      return Optional.of(result);\n    }\n    return Optional.empty();\n  }",
    "comment": "Appends multiple copies of a Java Object to the vector using the corresponding append* method\nabove.\n@param length: The number of instances to append\n@param value value to append to the vector\n@return the number of values appended if the value maps to one of the append* methods above,\nor Optional.empty() otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-repository-metadata/src/test/java/org/apache/maven/artifact/repository/metadata/MetadataTest.java",
    "type": "method",
    "name": "addSnapshotVersionLegacy",
    "code": "private static void addSnapshotVersionLegacy(Versioning versioning, Date timestamp, int buildNumber) {\n        Snapshot snapshot = new Snapshot();\n        snapshot.setBuildNumber(buildNumber);\n        snapshot.setTimestamp(formatDate(timestamp, true));\n\n        versioning.setSnapshot(snapshot);\n        versioning.setLastUpdatedTimestamp(timestamp);\n    }",
    "comment": "the format written by Maven 2\n(https://maven.apache.org/ref/2.2.1/maven-repository-metadata/repository-metadata.html)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "getLowercaseCodePoint",
    "code": "private static int getLowercaseCodePoint(final int codePoint) {\n    if (codePoint == SpecialCodePointConstants.CAPITAL_I_WITH_DOT_ABOVE) {\n      // Latin capital letter I with dot above is mapped to 2 lowercase characters.\n      return COMBINED_ASCII_SMALL_I_COMBINING_DOT;\n    }\n    else if (codePoint == SpecialCodePointConstants.GREEK_FINAL_SIGMA) {\n      // Greek final and non-final letter sigma should be mapped the same. This is achieved by\n      // mapping Greek small final sigma (U+03C2) to Greek small non-final sigma (U+03C3). Capital\n      // letter sigma (U+03A3) is mapped to small non-final sigma (U+03C3) in the `else` branch.\n      return SpecialCodePointConstants.GREEK_SMALL_SIGMA;\n    }\n    else {\n      // All other characters should follow context-unaware ICU single-code point case mapping.\n      return UCharacter.toLowerCase(codePoint);\n    }\n  }",
    "comment": "Returns the lowercase version of the provided code point, with special handling for\none-to-many case mappings (i.e. characters that map to multiple characters in lowercase) and\ncontext-insensitive case mappings (i.e. characters that map to different characters based on\nthe position in the string relative to other characters in lowercase)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "uniqueIdSubstring",
    "code": "public static Condition<Event> uniqueIdSubstring(String uniqueIdSubstring) {\n\t\tPredicate<UniqueId.Segment> predicate = segment -> {\n\t\t\tString text = segment.getType() + \":\" + segment.getValue();\n\t\t\treturn text.contains(uniqueIdSubstring);\n\t\t};\n\t\treturn uniqueId(new Condition<>(uniqueId -> uniqueId.getSegments().stream().anyMatch(predicate),\n\t\t\t\"substring '%s'\", uniqueIdSubstring));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if the\n{@link Event}'s {@linkplain Event#getTestDescriptor() test descriptor}\ncontains the supplied {@link String}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/test/java/org/tensorflow/EagerSessionTest.java",
    "type": "method",
    "name": "cleanupResourceOnSessionClose",
    "code": "public void cleanupResourceOnSessionClose() {\n    TestReference ref;\n    try (EagerSession s =\n        EagerSession.options()\n            .resourceCleanupStrategy(ResourceCleanupStrategy.ON_SESSION_CLOSE)\n            .build()) {\n      ref = new TestReference(s, new Object());\n      assertFalse(ref.isDeleted());\n\n      buildOp(s);\n      assertFalse(ref.isDeleted());\n    }\n    assertTrue(ref.isDeleted());\n  }",
    "comment": "check that reaching safe point did not release resources"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/CompositeTestSourceTests.java",
    "type": "method",
    "name": "createCompositeTestSourceFromClassAndFileSources",
    "code": "void createCompositeTestSourceFromClassAndFileSources() {\n\t\tvar fileSource = FileSource.from(new File(\"example.test\"));\n\t\tvar classSource = ClassSource.from(getClass());\n\t\tvar sources = new ArrayList<>(List.of(fileSource, classSource));\n\t\tvar compositeTestSource = CompositeTestSource.from(sources);\n\n\t\tassertThat(compositeTestSource.getSources()).hasSize(2);\n\t\tassertThat(compositeTestSource.getSources()).contains(fileSource, classSource);\n\n\t\tsources.remove(1);\n\t\tassertThat(compositeTestSource.getSources()).hasSize(2);\n\n\t\tassertThrows(UnsupportedOperationException.class, () -> compositeTestSource.getSources().add(fileSource));\n\t}",
    "comment": "Ensure the supplied sources list was defensively copied.\nEnsure the returned sources list is immutable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Cast.java",
    "type": "method",
    "name": "Cast",
    "code": "public Cast(Expression expression, DataType dataType) {\n    this(expression, null, dataType);\n  }",
    "comment": "Target data type, i.e. data type in which expression will be cast"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectUri",
    "code": "public static UriSelector selectUri(URI uri) {\n\t\tPreconditions.notNull(uri, \"URI must not be null\");\n\t\treturn new UriSelector(uri);\n\t}",
    "comment": "Create a {@code UriSelector} for the supplied {@link URI}.\n\n@param uri the URI to select; never {@code null}\n@see UriSelector\n@see #selectUri(String)\n@see #selectFile(String)\n@see #selectFile(File)\n@see #selectDirectory(String)\n@see #selectDirectory(File)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/procedures/ProcedureParameter.java",
    "type": "method",
    "name": "defaultValue",
    "code": "public Builder defaultValue(DefaultValue defaultValue) {\n      this.defaultValue = defaultValue;\n      return this;\n    }",
    "comment": "Sets the default value of the parameter."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/HiveSQLException.java",
    "type": "method",
    "name": "toTStatus",
    "code": "public TStatus toTStatus() {\n    // TODO: convert sqlState, etc.\n    TStatus tStatus = new TStatus(TStatusCode.ERROR_STATUS);\n    tStatus.setSqlState(getSQLState());\n    tStatus.setErrorCode(getErrorCode());\n    tStatus.setErrorMessage(getMessage());\n    tStatus.setInfoMessages(toString(this));\n    return tStatus;\n  }",
    "comment": "Converts current object to a {@link TStatus} object\n@return a {@link TStatus} object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/ovic/src/main/java/org/tensorflow/ovic/OvicClassifierBenchmarker.java",
    "type": "method",
    "name": "getReadyToTest",
    "code": "public void getReadyToTest(InputStream labelInputStream, MappedByteBuffer model) {\n    try {\n      Log.i(TAG, \"Creating classifier.\");\n      classifier = new OvicClassifier(labelInputStream, model);\n      int [] inputDims = classifier.getInputDims();\n      imgHeight = inputDims[1];\n      imgWidth = inputDims[2];\n      // Only accept QUANTIZED_UINT8 input.\n      imgData = ByteBuffer.allocateDirect(DIM_BATCH_SIZE * imgHeight * imgWidth * DIM_PIXEL_SIZE);\n      imgData.order(ByteOrder.nativeOrder());\n      intValues = new int[imgHeight * imgWidth];\n    } catch (Exception e) {\n        Log.e(TAG, e.getMessage());\n        Log.e(TAG, \"Failed to initialize ImageNet classifier for the benchmarker.\");\n    }\n  }",
    "comment": "Getting the benchmarker ready for classifying images.\n\n@param labelInputStream: an {@link InputStream} specifying where the list of labels should be\nread from.\n@param model: a {@link MappedByteBuffer} model to benchmark."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/parquet/filter2/predicate/SparkFilterApi.java",
    "type": "method",
    "name": "intColumn",
    "code": "public static IntColumn intColumn(String[] path) {\n    return new IntColumn(ColumnPath.get(path));\n  }",
    "comment": "TODO (PARQUET-1809): This is a temporary workaround; it is intended to be moved to Parquet."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeInMemorySorter.java",
    "type": "method",
    "name": "freeMemory",
    "code": "public void freeMemory() {\n    if (consumer != null) {\n      if (array != null) {\n        consumer.freeArray(array);\n      }\n\n      // Set the array to null instead of allocating a new array. Allocating an array could have\n      // triggered another spill and this method already is called from UnsafeExternalSorter when\n      // spilling. Attempting to allocate while spilling is dangerous, as we could be holding onto\n      // a large partially complete allocation, which may prevent other memory from being allocated.\n      // Instead we will allocate the new array when it is necessary.\n      array = null;\n      usableCapacity = 0;\n    }\n    pos = 0;\n    nullBoundaryPos = 0;\n  }",
    "comment": "Free the memory used by pointer array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/metadata/MetadataBridge.java",
    "type": "method",
    "name": "MetadataBridge",
    "code": "public MetadataBridge(ArtifactMetadata metadata) {\n        this.metadata = metadata;\n    }",
    "comment": "<strong>Warning:</strong> This is an internal utility class that is only public for technical reasons, it is not part\nof the public API. In particular, this class can be changed or deleted without prior notice."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(short[] expecteds, short[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }",
    "comment": "Asserts that two short arrays are equal. If they are not, an\n{@link AssertionError} is thrown.\n\n@param expecteds short array with expected values.\n@param actuals short array with actual values"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/resource-managers/yarn/src/main/java/org/apache/spark/deploy/yarn/AmIpFilter.java",
    "type": "method",
    "name": "isValidUrl",
    "code": "public boolean isValidUrl(String url) {\n    boolean isValid = false;\n    try {\n      HttpURLConnection conn = (HttpURLConnection) new URI(url).toURL().openConnection();\n      conn.connect();\n      isValid = conn.getResponseCode() == HttpURLConnection.HTTP_OK;\n      if (!isValid && UserGroupInformation.isSecurityEnabled()) {\n        isValid = (conn.getResponseCode() == HttpURLConnection.HTTP_UNAUTHORIZED)\n            || (conn.getResponseCode() == HttpURLConnection.HTTP_FORBIDDEN);\n        return isValid;\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Failed to connect to \" + url + \": \" + e.toString());\n    }\n    return isValid;\n  }",
    "comment": "If security is enabled, any valid RM which can give 401 Unauthorized is\ngood enough to access. Since AM doesn't have enough credential, auth\ncannot be completed and hence 401 is fine in such case."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/lazy/LazyFluentIterable.java",
    "type": "method",
    "name": "filter",
    "code": "public FluentIterable<E> filter(Predicate<? super E> predicate) {\n    return new LazyFluentIterable<>() {\n        return new DecoratingIterator<>(iterable.iterator()) {\n            }\n\n            return null;\n          }\n        };",
    "comment": "Filters the contents of Iterable using the given predicate, leaving only the ones which satisfy\nthe predicate.\n\n@param predicate the condition to test with for the filtering. If the test is negative, the\ntested object is removed by the iterator.\n@return a new FluentIterable object that decorates the source iterable"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java",
    "type": "method",
    "name": "VersionRange",
    "code": "private VersionRange(ArtifactVersion recommendedVersion, List<Restriction> restrictions) {\n        this.recommendedVersion = recommendedVersion;\n        this.restrictions = restrictions;\n    }",
    "comment": "Construct a version range from a specification."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/FixedLengthRowBasedKeyValueBatch.java",
    "type": "method",
    "name": "rowIterator",
    "code": "public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        //searching for the next non empty page is records is now zero\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        key.pointTo(base, offsetInPage, klen);\n        value.pointTo(base, offsetInPage + klen, vlen);\n\n        offsetInPage += recordLength;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        // do nothing\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };",
    "comment": "Returns an iterator to go through all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistrationViaParametersAndFieldsTests.java",
    "type": "method",
    "name": "test",
    "code": "void test(TestInfo testInfo, String text) {\n\t\t\tassertThat(testInfo).isNotNull();\n\t\t\tassertThat(text).isEqualTo(\"test-1-enigma\");\n\t\t}",
    "comment": "The {@link MagicParameter.Extension} is first registered for the {@code @AfterEach}\nmethod, but that registration occurs before the test method is invoked, which\nallows the test method's parameter to be resolved by the {@link MagicParameter.Extension}\nas well."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/function/Try.java",
    "type": "method",
    "name": "checkNotNull",
    "code": "private static <T> T checkNotNull(T input, String title) {\n\t\tif (input == null) {\n\t\t\tthrow new JUnitException(title + \" must not be null\");\n\t\t}\n\t\treturn input;\n\t}",
    "comment": "Cannot use Preconditions due to package cycle\nCannot use PreconditionViolationException due to package cycle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/DelegatePerformanceBenchmark.java",
    "type": "method",
    "name": "loadTfLiteSettingsList",
    "code": "public static List<TfLiteSettingsListEntry> loadTfLiteSettingsList(String[] jsonFilePaths) {\n    List<TfLiteSettingsListEntry> tfliteSettingsList = new ArrayList<>();\n    // Always add the default delegate to compare.\n    FlatBufferBuilder tfliteSettingsBuilder = new FlatBufferBuilder();\n      TFLiteSettings.startTFLiteSettings(tfliteSettingsBuilder);\n      int tfliteSettingsOffset = TFLiteSettings.endTFLiteSettings(tfliteSettingsBuilder);\n      tfliteSettingsBuilder.finish(tfliteSettingsOffset);\n    tfliteSettingsList.add(\n        TfLiteSettingsListEntry.create(\n            TFLiteSettings.getRootAsTFLiteSettings(tfliteSettingsBuilder.dataBuffer()),\n            \"default_delegate\",\n            /* isTestTarget= */ false));\n    // To avoid system-level initialization negatively impacting benchmark results, the test target\n    // delegate is positioned at the end of the list in reverse order. This ensures initialization\n    // latency is added to the reference delegate that is executed first among the delegates that\n    // share the same delegate type. Otherwise, it could introduce false positive results when\n    // comparing  delegates that share the same initialization. The order of the input settings\n    // files will be reinstated when computing the model-level reports.\n    for (int i = jsonFilePaths.length - 1; i >= 0; i--) {\n      String jsonFilePath = jsonFilePaths[i];\n      byte[] tfliteSettingsByteArray = loadTfLiteSettingsJsonNative(jsonFilePath);\n      if (tfliteSettingsByteArray == null || tfliteSettingsByteArray.length == 0) {\n        Log.e(TAG, \"Failed to load TFLiteSetting from JSON file \" + jsonFilePath);\n        return new ArrayList<>();\n      }\n\n      ByteBuffer byteBuffer = ByteBuffer.wrap(tfliteSettingsByteArray);\n      tfliteSettingsList.add(\n          TfLiteSettingsListEntry.create(\n              TFLiteSettings.getRootAsTFLiteSettings(byteBuffer),\n              jsonFilePath,\n              /* isTestTarget= */ i == 0));\n    }\n    return tfliteSettingsList;\n  }",
    "comment": "Loads the input TFLiteSettings JSON files into TfLiteSettingsListEntry instances.\n\n<p>Adds default entry at the beginning as a reference delegate. The default entry contains a\ndummy TFLiteSettings structure, which lets the interpreter to apply the default acceleration.\nPositions the test target delegate at the end of the entry list."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-driven-architecture/src/main/java/com/iluwatar/eda/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    var dispatcher = new EventDispatcher();\n    dispatcher.registerHandler(UserCreatedEvent.class, new UserCreatedEventHandler());\n    dispatcher.registerHandler(UserUpdatedEvent.class, new UserUpdatedEventHandler());\n\n    var user = new User(\"iluwatar\");\n    dispatcher.dispatch(new UserCreatedEvent(user));\n    dispatcher.dispatch(new UserUpdatedEvent(user));\n  }",
    "comment": "Once the {@link EventDispatcher} is initialised, handlers related to specific events have to be\nmade known to the dispatcher by registering them. In this case the {@link UserCreatedEvent} is\nbound to the UserCreatedEventHandler, whilst the {@link UserUpdatedEvent} is bound to the\n{@link UserUpdatedEventHandler}. The dispatcher can now be called to dispatch specific events.\nWhen a user is saved, the {@link UserCreatedEvent} can be dispatched. On the other hand, when a\nuser is updated, {@link UserUpdatedEvent} can be dispatched."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3415JunkRepositoryMetadataTest.java",
    "type": "method",
    "name": "getUpdateCheckFile",
    "code": "private File getUpdateCheckFile(Verifier verifier) {\n        String gid = \"org.apache.maven.its.mng3415\";\n        String aid = \"missing\";\n        String version = \"1.0-SNAPSHOT\";\n        String name;\n\n        // < 3.0 (including snapshots)\n        if (matchesVersionRange(\"(2.0.8,3.0-alpha-1)\")) {\n            name = \"maven-metadata-testing-repo.xml\";\n        } else {\n            name = \"resolver-status.properties\";\n        }\n\n        return new File(verifier.getArtifactMetadataPath(gid, aid, version, name));\n    }",
    "comment": "If the current maven version is < 3.0, we'll use the metadata file itself (old maven-artifact code)...\notherwise, use the new resolver-status.properties file (new artifact code)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/hash/Murmur3_x86_32Suite.java",
    "type": "method",
    "name": "testKnownBytesInputs",
    "code": "public void testKnownBytesInputs() {\n    byte[] test = \"test\".getBytes(StandardCharsets.UTF_8);\n    Assertions.assertEquals(MurmurHash3$.MODULE$.bytesHash(test, 0),\n      Murmur3_x86_32.hashUnsafeBytes2(test, Platform.BYTE_ARRAY_OFFSET, test.length, 0));\n    byte[] test1 = \"test1\".getBytes(StandardCharsets.UTF_8);\n    Assertions.assertEquals(MurmurHash3$.MODULE$.bytesHash(test1, 0),\n      Murmur3_x86_32.hashUnsafeBytes2(test1, Platform.BYTE_ARRAY_OFFSET, test1.length, 0));\n    byte[] te = \"te\".getBytes(StandardCharsets.UTF_8);\n    Assertions.assertEquals(MurmurHash3$.MODULE$.bytesHash(te, 0),\n      Murmur3_x86_32.hashUnsafeBytes2(te, Platform.BYTE_ARRAY_OFFSET, te.length, 0));\n    byte[] tes = \"tes\".getBytes(StandardCharsets.UTF_8);\n    Assertions.assertEquals(MurmurHash3$.MODULE$.bytesHash(tes, 0),\n      Murmur3_x86_32.hashUnsafeBytes2(tes, Platform.BYTE_ARRAY_OFFSET, tes.length, 0));\n  }",
    "comment": "SPARK-23381 Check whether the hash of the byte array is the same as another implementations"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/JavaAPISuite.java",
    "type": "method",
    "name": "testStreamingContextTransform",
    "code": "public void testStreamingContextTransform(){\n    List<List<Integer>> stream1input = Arrays.asList(\n        Arrays.asList(1),\n        Arrays.asList(2)\n    );\n\n    List<List<Integer>> stream2input = Arrays.asList(\n        Arrays.asList(3),\n        Arrays.asList(4)\n    );\n\n    List<List<Tuple2<Integer, String>>> pairStream1input = Arrays.asList(\n        Arrays.asList(new Tuple2<>(1, \"x\")),\n        Arrays.asList(new Tuple2<>(2, \"y\"))\n    );\n\n    List<List<Tuple2<Integer, Tuple2<Integer, String>>>> expected = Arrays.asList(\n        Arrays.asList(new Tuple2<>(1, new Tuple2<>(1, \"x\"))),\n        Arrays.asList(new Tuple2<>(2, new Tuple2<>(2, \"y\")))\n    );\n\n    JavaDStream<Integer> stream1 = JavaTestUtils.attachTestInputStream(ssc, stream1input, 1);\n    JavaDStream<Integer> stream2 = JavaTestUtils.attachTestInputStream(ssc, stream2input, 1);\n    JavaPairDStream<Integer, String> pairStream1 = JavaPairDStream.fromJavaDStream(\n        JavaTestUtils.attachTestInputStream(ssc, pairStream1input, 1));\n\n    List<JavaDStream<?>> listOfDStreams1 = Arrays.asList(stream1, stream2);\n\n    ssc.transform(\n      listOfDStreams1,\n      (listOfRDDs, time) -> {\n        Assertions.assertEquals(2, listOfRDDs.size());\n        return null;\n      }\n    );\n\n    List<JavaDStream<?>> listOfDStreams2 =\n        Arrays.asList(stream1, stream2, pairStream1.toJavaDStream());\n\n    JavaPairDStream<Integer, Tuple2<Integer, String>> transformed2 = ssc.transformToPair(\n      listOfDStreams2,\n      (listOfRDDs, time) -> {\n        Assertions.assertEquals(3, listOfRDDs.size());\n        JavaRDD<Integer> rdd1 = (JavaRDD<Integer>)listOfRDDs.get(0);\n        JavaRDD<Integer> rdd2 = (JavaRDD<Integer>)listOfRDDs.get(1);\n        JavaRDD<Tuple2<Integer, String>> rdd3 =\n          (JavaRDD<Tuple2<Integer, String>>)listOfRDDs.get(2);\n        JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3);\n        PairFunction<Integer, Integer, Integer> mapToTuple =\n            (PairFunction<Integer, Integer, Integer>) i -> new Tuple2<>(i, i);\n        return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3);\n      }\n    );\n    JavaTestUtils.attachTestOutputStream(transformed2);\n    List<List<Tuple2<Integer, Tuple2<Integer, String>>>> result =\n      JavaTestUtils.runStreams(ssc, 2, 2);\n    Assertions.assertEquals(expected, result);\n  }",
    "comment": "This is just to test whether this transform to JavaStream compiles"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/ListTest.java",
    "type": "method",
    "name": "setUp",
    "code": "protected void setUp() {\n        emptyList = new ArrayList<Integer>();\n        fullList = new ArrayList<Integer>();\n        fullList.add(1);\n        fullList.add(2);\n        fullList.add(3);\n    }",
    "comment": "A sample test case, testing {@link java.util.ArrayList}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java",
    "type": "method",
    "name": "isActive",
    "code": "public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        Activation activation = profile.getActivation();\n\n        if (activation == null) {\n            return false;\n        }\n\n        ActivationProperty property = activation.getProperty();\n\n        if (property == null) {\n            return false;\n        }\n\n        String name = property.getName();\n        boolean reverseName = false;\n\n        if (name != null && name.startsWith(\"!\")) {\n            reverseName = true;\n            name = name.substring(1);\n        }\n\n        if (name == null || name.length() <= 0) {\n            problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE)\n                    .setMessage(\"The property name is required to activate the profile \" + profile.getId())\n                    .setLocation(property.getLocation(\"\")));\n            return false;\n        }\n\n        String sysValue = context.getUserProperties().get(name);\n        if (sysValue == null) {\n            sysValue = context.getSystemProperties().get(name);\n        }\n\n        String propValue = property.getValue();\n        if (StringUtils.isNotEmpty(propValue)) {\n            boolean reverseValue = false;\n            if (propValue.startsWith(\"!\")) {\n                reverseValue = true;\n                propValue = propValue.substring(1);\n            }\n\n            // we have a value, so it has to match the system value...\n            boolean result = propValue.equals(sysValue);\n\n            return reverseValue ? !result : result;\n        } else {\n            boolean result = StringUtils.isNotEmpty(sysValue);\n\n            return reverseName ? !result : result;\n        }\n    }",
    "comment": "Determines profile activation based on the existence or value of some execution property.\n\n@see ActivationProperty\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4555MetaversionResolutionOfflineTest.java",
    "type": "method",
    "name": "AbstractHandler",
    "code": "Handler repoHandler = new AbstractHandler() {\n\n                response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                ((Request) request).setHandled(true);\n            }",
    "comment": "Verify that resolution of the metaversion RELEASE respects offline mode.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/SupportsPushDownAggregates.java",
    "type": "method",
    "name": "supportCompletePushDown",
    "code": "default boolean supportCompletePushDown(Aggregation aggregation) { return false; }",
    "comment": "Whether the datasource support complete aggregation push-down. Spark will do grouping again\nif this method returns false.\n\n@param aggregation Aggregation in SQL statement.\n@return true if the aggregation can be pushed down to datasource completely, false otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/repository/Proxy.java",
    "type": "method",
    "name": "setPassword",
    "code": "public void setPassword(String password) {\n        this.password = password;\n    }",
    "comment": "Set the user's password for the proxy server.\n\n@param password password to use to log in to a proxy server"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/orc/OrcAtomicColumnVector.java",
    "type": "method",
    "name": "if",
    "code": "OrcAtomicColumnVector(DataType type, ColumnVector vector) {\n    super(type, vector);\n\n    if (type instanceof TimestampType) {\n      isTimestamp = true;\n    } else {\n      isTimestamp = false;\n    }\n\n    if (type instanceof DateType) {\n      isDate = true;\n    } else {\n      isDate = false;\n    }\n\n    if (vector instanceof LongColumnVector longColumnVector) {\n      longData = longColumnVector;\n    } else if (vector instanceof DoubleColumnVector doubleColumnVector) {\n      doubleData = doubleColumnVector;\n    } else if (vector instanceof BytesColumnVector bytesColumnVector) {\n      bytesData = bytesColumnVector;\n    } else if (vector instanceof DecimalColumnVector decimalColumnVector) {\n      decimalData = decimalColumnVector;\n    } else if (vector instanceof TimestampColumnVector timestampColumnVector) {\n      timestampData = timestampColumnVector;\n    } else {\n      throw SparkUnsupportedOperationException.apply();\n    }\n  }",
    "comment": "A column vector implementation for Spark's AtomicType."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java",
    "type": "method",
    "name": "getOrDefault",
    "code": "default <V> V getOrDefault(Object key, Class<V> requiredType, V defaultValue) {\n\t\t\tV value = get(key, requiredType);\n\t\t\treturn (value != null ? value : defaultValue);\n\t\t}",
    "comment": "Get the value of the specified required type that is stored under\nthe supplied {@code key}, or the supplied {@code defaultValue} if no\nvalue is found for the supplied {@code key} in this store or in an\nancestor.\n\n<p>If no value is stored in the current {@link ExtensionContext}\nfor the supplied {@code key}, ancestors of the context will be queried\nfor a value with the same {@code key} in the {@code Namespace} used\nto create this store.\n\n@param key the key; never {@code null}\n@param requiredType the required type of the value; never {@code null}\n@param defaultValue the default value\n@param <V> the value type\n@return the value; potentially {@code null}\n@since 5.5\n@see #get(Object, Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/server/TransportRequestHandler.java",
    "type": "method",
    "name": "processStreamUpload",
    "code": "private void processStreamUpload(final UploadStream req) {\n    assert (req.body() == null);\n    try {\n      RpcResponseCallback callback = new RpcResponseCallback() {\n\n        @Override\n        public void onFailure(Throwable e) {\n          respond(new RpcFailure(req.requestId, Throwables.getStackTraceAsString(e)));\n        }\n      };\n      TransportFrameDecoder frameDecoder = (TransportFrameDecoder)\n          channel.pipeline().get(TransportFrameDecoder.HANDLER_NAME);\n      ByteBuffer meta = req.meta.nioByteBuffer();\n      StreamCallbackWithID streamHandler = rpcHandler.receiveStream(reverseClient, meta, callback);\n      if (streamHandler == null) {\n        throw new NullPointerException(\"rpcHandler returned a null streamHandler\");\n      }\n      StreamCallbackWithID wrappedCallback = new StreamCallbackWithID() {\n\n        @Override\n        public void onComplete(String streamId) throws IOException {\n           try {\n             streamHandler.onComplete(streamId);\n             callback.onSuccess(streamHandler.getCompletionResponse());\n           } catch (BlockPushNonFatalFailure ex) {\n             // Respond an RPC message with the error code to client instead of using exceptions\n             // encoded in the RPCFailure. This type of exceptions gets thrown more frequently\n             // than a regular exception on the shuffle server side due to the best-effort nature\n             // of push-based shuffle and requires special handling on the client side. Using a\n             // proper RPCResponse is more efficient.\n             callback.onSuccess(ex.getResponse());\n             streamHandler.onFailure(streamId, ex);\n           } catch (Exception ex) {\n             IOException ioExc = new IOException(\"Failure post-processing complete stream;\" +\n               \" failing this rpc and leaving channel active\", ex);\n             callback.onFailure(ioExc);\n             streamHandler.onFailure(streamId, ioExc);\n           }\n        }\n\n        @Override\n        public void onFailure(String streamId, Throwable cause) throws IOException {\n          callback.onFailure(new IOException(\"Destination failed while reading stream\", cause));\n          streamHandler.onFailure(streamId, cause);\n        }\n\n        @Override\n        public String getID() {\n          return streamHandler.getID();\n        }\n      };\n      if (req.bodyByteCount > 0) {\n        StreamInterceptor<RequestMessage> interceptor = new StreamInterceptor<>(\n          this, wrappedCallback.getID(), req.bodyByteCount, wrappedCallback);\n        frameDecoder.setInterceptor(interceptor);\n      } else {\n        wrappedCallback.onComplete(wrappedCallback.getID());\n      }\n    } catch (Exception e) {\n      if (e instanceof BlockPushNonFatalFailure blockPushNonFatalFailure) {\n        // Thrown by rpcHandler.receiveStream(reverseClient, meta, callback), the same as\n        // onComplete method. Respond an RPC message with the error code to client instead of\n        // using exceptions encoded in the RPCFailure. Using a proper RPCResponse is more\n        // efficient, and now only include the too old attempt case here.\n        respond(new RpcResponse(req.requestId,\n          new NioManagedBuffer(blockPushNonFatalFailure.getResponse())));\n      } else {\n        logger.error(\"Error while invoking RpcHandler#receive() on RPC id {} from {}\", e,\n          MDC.of(LogKeys.REQUEST_ID$.MODULE$, req.requestId),\n          MDC.of(LogKeys.HOST_PORT$.MODULE$, getRemoteAddress(channel)));\n        respond(new RpcFailure(req.requestId, Throwables.getStackTraceAsString(e)));\n      }\n      // We choose to totally fail the channel, rather than trying to recover as we do in other\n      // cases.  We don't know how many bytes of the stream the client has already sent for the\n      // stream, it's not worth trying to recover.\n      channel.pipeline().fireExceptionCaught(e);\n    } finally {\n      req.meta.release();\n    }\n  }",
    "comment": "Handle a request from the client to upload a stream of data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/params/converter/DefaultArgumentConverterTests.java",
    "type": "method",
    "name": "isAwareOfNull",
    "code": "void isAwareOfNull() {\n\t\tassertConverts(null, Object.class, null);\n\t\tassertConverts(null, String.class, null);\n\t\tassertConverts(null, Boolean.class, null);\n\t}",
    "comment": "Unit tests for {@link DefaultArgumentConverter}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "finishedWithFailure",
    "code": "public static Condition<Event> finishedWithFailure(Condition<Throwable>... conditions) {\n\t\treturn finishedWithCause(FAILED, conditions);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link EventType#FINISHED} and its\n{@linkplain Event#getPayload() result} has a\n{@linkplain TestExecutionResult#getStatus() status} of\n{@link TestExecutionResult.Status#FAILED FAILED} as well as a\n{@linkplain TestExecutionResult#getThrowable() cause} that matches all of\nthe supplied {@code Conditions}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/RunListenerAdapter.java",
    "type": "method",
    "name": "determineReasonForIgnoredTest",
    "code": "private Optional<String> determineReasonForIgnoredTest(TestDescriptor testDescriptor, Description description) {\n\t\tOptional<String> reason = getReason(description.getAnnotation(Ignore.class));\n\t\tif (reason.isPresent()) {\n\t\t\treturn reason;\n\t\t}\n\t\treturn testDescriptor.getSource() //\n\t\t\t\t.filter(ClassSource.class::isInstance) //\n\t\t\t\t.map(source -> ((ClassSource) source).getJavaClass()) //\n\t\t\t\t.flatMap(testClass -> getReason(testClass.getAnnotation(Ignore.class)));\n\t}",
    "comment": "Workaround for some runners (e.g. JUnit38ClassRunner) don't include the @Ignore annotation\nin the description, so we read it from the test class directly"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/config/CachingJupiterConfigurationTests.java",
    "type": "method",
    "name": "cachesDefaultDisplayNameGenerator",
    "code": "void cachesDefaultDisplayNameGenerator() {\n\t\tCustomDisplayNameGenerator customDisplayNameGenerator = new CustomDisplayNameGenerator();\n\t\twhen(delegate.getDefaultDisplayNameGenerator()).thenReturn(customDisplayNameGenerator);\n\n\t\tassertThat(cache.getDefaultDisplayNameGenerator()).isSameAs(customDisplayNameGenerator);\n\t\tassertThat(cache.getDefaultDisplayNameGenerator()).isSameAs(customDisplayNameGenerator);\n\n\t\tverify(delegate, only()).getDefaultDisplayNameGenerator();\n\t}",
    "comment": "call `cache.getDefaultDisplayNameGenerator()` twice to verify the delegate method is called only once."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/ClockSource.java",
    "type": "method",
    "name": "elapsedNanos",
    "code": "static long elapsedNanos(long startTime, long endTime) {\n      return CLOCK.elapsedNanos0(startTime, endTime);\n   }",
    "comment": "Get the difference in nanoseconds between two opaque time-stamps returned\nby currentTime().\n\n@param startTime an opaque time-stamp returned by an instance of this class\n@param endTime an opaque time-stamp returned by an instance of this class\n@return the elapsed time between startTime and endTime in nanoseconds"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/conversion/FallbackStringToObjectConverter.java",
    "type": "method",
    "name": "canConvertTo",
    "code": "public boolean canConvertTo(Class<?> targetType) {\n\t\treturn findFactoryExecutable(targetType) != NULL_EXECUTABLE;\n\t}",
    "comment": "Cache for factory methods and factory constructors.\n\n<p>Searches that do not find a factory method or constructor are tracked\nby the presence of a {@link #NULL_EXECUTABLE} object stored in the map.\nThis prevents the framework from repeatedly searching for things which\nare already known not to exist."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(short expected, short actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/results/ResultMatchers.java",
    "type": "method",
    "name": "hasSingleFailureMatching",
    "code": "public static Matcher<PrintableResult> hasSingleFailureMatching(final Matcher<Throwable> matcher) {\n        return new TypeSafeMatcher<PrintableResult>() {\n\n            public void describeTo(Description description) {\n                description.appendText(\"has failure with exception matching \");\n                matcher.describeTo(description);\n            }\n        };\n    }",
    "comment": "Matches if the result has exactly one failure matching the given matcher.\n\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "initDb",
    "code": "public void initDb() {\n        // using an in-memory database because the information stored here disappears when the\n        // process is killed\n        mDatabase = Room.inMemoryDatabaseBuilder(ApplicationProvider.getApplicationContext(),\n                UsersDatabase.class).build();\n        mDataSource = new LocalUserDataSource(mDatabase.userDao());\n    }",
    "comment": "Integration tests for the {@link LocalUserDataSource} implementation with Room."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/sasl/SaslIntegrationSuite.java",
    "type": "method",
    "name": "testNoSaslServer",
    "code": "public void testNoSaslServer() {\n    RpcHandler handler = new TestRpcHandler();\n    try (TransportContext context = new TransportContext(conf, handler)) {\n    }\n  }",
    "comment": "Guessing the right tag byte doesn't magically get you in..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "fetch",
    "code": "public Runner fetch(Operand<?> operand) {\n      return fetch(operand.asOutput());\n    }",
    "comment": "Makes {@link #run()} return the Tensor referred to by the output of {@code operand}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/Throwables.java",
    "type": "method",
    "name": "getTrimmedStackTrace",
    "code": "public static String getTrimmedStackTrace(Throwable exception) {\n        List<String> trimmedStackTraceLines = getTrimmedStackTraceLines(exception);\n        if (trimmedStackTraceLines.isEmpty()) {\n            return getFullStackTrace(exception);\n        }\n\n        StringBuilder result = new StringBuilder(exception.toString());\n        appendStackTraceLines(trimmedStackTraceLines, result);\n        appendStackTraceLines(getCauseStackTraceLines(exception), result);\n        return result.toString();\n    }",
    "comment": "Gets a trimmed version of the stack trace of the given exception. Stack trace\nelements that are below the test method are filtered out.\n\n@return a trimmed stack trace, or the original trace if trimming wasn't possible"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/component/src/main/java/com/iluwatar/component/component/physiccomponent/ObjectPhysicComponent.java",
    "type": "method",
    "name": "update",
    "code": "public void update(GameObject gameObject) {\n    gameObject.updateCoordinate();\n    LOGGER.info(gameObject.getName() + \"'s coordinate has been changed.\");\n  }",
    "comment": "The method update the horizontal (X-axis) coordinate based on the velocity of gameObject.\n\n@param gameObject the gameObject instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/test/java/org/apache/spark/sql/hive/execution/UDFRawMap.java",
    "type": "method",
    "name": "evaluate",
    "code": "public Map evaluate(Object o) {\n    return Collections.singletonMap(\"a\", \"1\");\n  }",
    "comment": "UDF that returns a raw (non-parameterized) java Map."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(long expected, long actual) {\n        Assert.assertEquals(expected, actual);\n    }",
    "comment": "Asserts that two longs are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/NumericHistogram.java",
    "type": "method",
    "name": "reset",
    "code": "public void reset() {\n    bins = null;\n    nbins = nusedbins = 0;\n  }",
    "comment": "Resets a histogram object to its initial state. allocate() or merge() must be\ncalled again before use."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlanExecutor.java",
    "type": "method",
    "name": "if",
    "code": "switch (step.name) {\n                case PLAN:\n                    // Planning steps should be executed out of normal execution\n                    throw new IllegalStateException();\n                case SETUP:\n                    attachToThread(step);\n                    consumerPomArtifactTransformer.injectTransformedArtifacts(\n                            session.getRepositorySession(), step.project);\n                    projectExecutionListener.beforeProjectExecution(new ProjectExecutionEvent(session, step.project));\n                    eventCatapult.fire(ExecutionEvent.Type.ProjectStarted, session, null);\n                    break;\n                case TEARDOWN:\n                    attachToThread(step);\n\n                    // Check if there are any stored exceptions for this project\n                    List<Throwable> failures = null;\n                    boolean allStepsExecuted = true;\n                    for (BuildStep projectStep : plan.steps(step.project).toList()) {\n                        Exception exception = projectStep.exception;\n                        if (exception != null) {\n                            if (failures == null) {\n                                failures = new ArrayList<>();\n                            }\n                            failures.add(exception);\n                        }\n                        allStepsExecuted &= step == projectStep || projectStep.status.get() == EXECUTED;\n                    }\n\n                    if (failures != null) {\n                        // Handle the stored exception\n                        Throwable failure;\n                        if (failures.size() == 1) {\n                            failure = failures.get(\n                                    0); // Single exception, no need to wrap it in a LifecycleExecutionException\n                        } else {\n                            failure = new LifecycleExecutionException(\"Error building project\");\n                            failures.forEach(failure::addSuppressed);\n                        }\n                        handleBuildError(reactorContext, session, step.project, failure);\n                    } else if (allStepsExecuted) {\n                        // If there were no failures, report success\n                        projectExecutionListener.afterProjectExecutionSuccess(\n                                new ProjectExecutionEvent(session, step.project, Collections.emptyList()));\n                        reactorContext\n                                .getResult()\n                                .addBuildSummary(new BuildSuccess(step.project, clock.wallTime(), clock.execTime()));\n                        eventCatapult.fire(ExecutionEvent.Type.ProjectSucceeded, session, null);\n                    } else {\n                        eventCatapult.fire(ExecutionEvent.Type.ProjectSkipped, session, null);\n                    }\n                    break;\n                default:\n                    List<MojoExecution> executions = step.executions().toList();\n                    if (!executions.isEmpty()) {\n                        attachToThread(step);\n                        clock.start();\n                        try {\n                            executions.forEach(mojoExecution -> {\n                                mojoExecutionConfigurator(mojoExecution).configure(step.project, mojoExecution, true);\n                                finalizeMojoConfiguration(mojoExecution);\n                            });\n                            mojoExecutor.execute(session, executions);\n                        } finally {\n                            clock.stop();\n                        }\n                    }\n                    break;\n            }",
    "comment": "Executes a single build step, which can be one of:\n- PLAN: Project build planning\n- SETUP: Project initialization\n- TEARDOWN: Project cleanup\n- Default: Actual mojo/plugin executions\n\n@param step The build step to execute\n@throws IOException If there's an IO error during execution\n@throws LifecycleExecutionException If there's a lifecycle execution error"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(long unexpected, long actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaMultilayerPerceptronClassifierExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaMultilayerPerceptronClassifierExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Load training data\n    String path = \"data/mllib/sample_multiclass_classification_data.txt\";\n    Dataset<Row> dataFrame = spark.read().format(\"libsvm\").load(path);\n\n    // Split the data into train and test\n    Dataset<Row>[] splits = dataFrame.randomSplit(new double[]{0.6, 0.4}, 1234L);\n    int[] layers = new int[] {4, 5, 4, 3};\n}",
    "comment": "An example for Multilayer Perceptron Classification."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/double-buffer/src/main/java/com/iluwatar/doublebuffer/Scene.java",
    "type": "method",
    "name": "draw",
    "code": "public void draw(List<? extends Pair<Integer, Integer>> coordinateList) {\n    LOGGER.info(\"Start drawing next frame\");\n    LOGGER.info(\"Current buffer: \" + current + \" Next buffer: \" + next);\n    frameBuffers[next].clearAll();\n    coordinateList.forEach(\n        coordinate -> {\n          var x = coordinate.getKey();\n          var y = coordinate.getValue();\n          frameBuffers[next].draw(x, y);\n        });\n    LOGGER.info(\"Swap current and next buffer\");\n    swap();\n    LOGGER.info(\"Finish swapping\");\n    LOGGER.info(\"Current buffer: \" + current + \" Next buffer: \" + next);\n  }",
    "comment": "Draw the next frame.\n\n@param coordinateList list of pixels of which the color should be black"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/runner/notification/ConcurrentRunNotifierTest.java",
    "type": "method",
    "name": "Runnable",
    "code": "for (int i = 0; i < numParallelTests; ++i) {\n            pool.submit(new Runnable() {\n            });\n        }",
    "comment": "Testing RunNotifier in concurrent access.\n\n@author Tibor Digana (tibor17)\n@version 4.12\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "if_",
    "code": "public Object if_(List<Object> args) {\n        if (args.size() != 3) {\n            throw new IllegalArgumentException(\"if function requires exactly three arguments\");\n        }\n        boolean condition = ConditionParser.toBoolean(args.get(0));\n        return condition ? args.get(1) : args.get(2);\n    }",
    "comment": "Implements an if-then-else operation.\n\n@param args A list containing three arguments: condition, value if true, value if false\n@return The second argument if the condition is true, the third argument otherwise\n@throws IllegalArgumentException if the number of arguments is not exactly three"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/partitioning/UnknownPartitioning.java",
    "type": "method",
    "name": "UnknownPartitioning",
    "code": "public UnknownPartitioning(int numPartitions) {\n    this.numPartitions = numPartitions;\n  }",
    "comment": "Represents a partitioning where rows are split across partitions in an unknown pattern.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/model-view-viewmodel/src/main/java/com/iluwatar/model/view/viewmodel/BookViewModel.java",
    "type": "method",
    "name": "deleteBook",
    "code": "public void deleteBook() {\n    if (selectedBook != null) {\n      getBookList().remove(selectedBook);\n      selectedBook = null;\n    }\n  }",
    "comment": "Deleting a book. When event is triggered on click of Delete button, this method will be\nnotified with the selected entry that will be referenced and used to delete the selected book\nfrom the list of books."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "onSurfaceTextureSizeChanged",
    "code": "new TextureView.SurfaceTextureListener() {\n\n        @Override\n        public void onSurfaceTextureSizeChanged(\n            final SurfaceTexture texture, final int width, final int height) {\n          configureTransform(width, height);\n        }\n\n        @Override\n        public boolean onSurfaceTextureDestroyed(final SurfaceTexture texture) {\n          return true;\n        }\n\n        @Override\n        public void onSurfaceTextureUpdated(final SurfaceTexture texture) {}\n      };",
    "comment": "{@link android.view.TextureView.SurfaceTextureListener} handles several lifecycle events on a\n{@link TextureView}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-model/src/main/java/org/apache/maven/api/model/InputSource.java",
    "type": "method",
    "name": "InputSource",
    "code": "public InputSource(String modelId, String location) {\n        this(modelId, location, null);\n    }",
    "comment": "Represents the source of a model input, such as a POM file.\n<p>\nThis class tracks the origin of model elements, including their location in source files\nand relationships between imported models. It's used for error reporting and debugging\nto help identify where specific model elements came from.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaUserDefinedUntypedAggregation.java",
    "type": "method",
    "name": "zero",
    "code": "public Average zero() {\n      return new Average(0L, 0L);\n    }",
    "comment": "$example on:typed_custom_aggregation$\nA zero value for this aggregation. Should satisfy the property that any b + zero = b"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Integer expected, int actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Integer) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/CookieSigner.java",
    "type": "method",
    "name": "verifyAndExtract",
    "code": "public String verifyAndExtract(String signedStr) {\n    int index = signedStr.lastIndexOf(SIGNATURE);\n    if (index == -1) {\n      throw new IllegalArgumentException(\"Invalid input sign: \" + signedStr);\n    }\n    String originalSignature = signedStr.substring(index + SIGNATURE.length());\n    String rawValue = signedStr.substring(0, index);\n    String currentSignature = getSignature(rawValue);\n\n    if (!MessageDigest.isEqual(originalSignature.getBytes(), currentSignature.getBytes())) {\n      throw new IllegalArgumentException(\"Invalid sign\");\n    }\n    return rawValue;\n  }",
    "comment": "Verify a signed string and extracts the original string.\n@param signedStr The already signed string\n@return Raw Value of the string without the signature"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeExternalSorter.java",
    "type": "method",
    "name": "clearAndGetAllocatedPagesToFree",
    "code": "private List<MemoryBlock> clearAndGetAllocatedPagesToFree() {\n    updatePeakMemoryUsed();\n    List<MemoryBlock> pagesToFree = new LinkedList<>(allocatedPages);\n    allocatedPages.clear();\n    currentPage = null;\n    pageCursor = 0;\n    return pagesToFree;\n  }",
    "comment": "Clear the allocated pages and return the list of allocated pages to let\nthe caller free the page. This is to prevent the deadlock by nested locks\nif the caller locks the UnsafeExternalSorter and call freePage which locks the\nTaskMemoryManager and cause nested locks.\n\n@return list of allocated pages to free"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/androidTest/java/com/example/android/observability/persistence/UserDaoTest.java",
    "type": "method",
    "name": "updateAndGetUser",
    "code": "public void updateAndGetUser() {\n        mDatabase.userDao().insertUser(USER).blockingAwait();\n\n        User updatedUser = new User(USER.getId(), \"new username\");\n        mDatabase.userDao().insertUser(updatedUser).blockingAwait();\n\n        mDatabase.userDao().getUser()\n                .test()\n                .assertValue(user -> {\n                    return user != null && user.getId().equals(USER.getId()) &&\n                            user.getUserName().equals(\"new username\");\n                });\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are updating the name of the user\nWhen subscribing to the emissions of the user\nassertValue asserts that there was only one emission of the user\nThe emitted user is the expected one"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Boolean> create(boolean[][][][][][] data) {\n    return Tensor.create(data, Boolean.class);\n  }",
    "comment": "Creates a rank-6 tensor of {@code boolean} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/JavaAPISuite.java",
    "type": "method",
    "name": "equalIterator",
    "code": "public static void equalIterator(Iterator<?> a, Iterator<?> b) {\n    while (a.hasNext() && b.hasNext()) {\n      Assertions.assertEquals(a.next(), b.next());\n    }\n    Assertions.assertEquals(a.hasNext(), b.hasNext());\n  }",
    "comment": "The test suite itself is Serializable so that anonymous Function implementations can be\nserialized, as an alternative to converting these anonymous classes to static inner classes;\nsee http://stackoverflow.com/questions/758570/."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isPrivate",
    "code": "public static boolean isPrivate(Class<?> clazz) {\n\t\treturn ReflectionUtils.isPrivate(clazz);\n\t}",
    "comment": "Determine if the supplied class is {@code private}.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is {@code private}\n@see java.lang.reflect.Modifier#isPrivate(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/test/java/com/zaxxer/hikari/util/TomcatConcurrentBagLeakTest.java",
    "type": "method",
    "name": "loadedByThisOrChild",
    "code": "private boolean loadedByThisOrChild(Object o) {\n         if (o == null) {\n            return false;\n         }\n\n         Class<?> clazz;\n         if (o instanceof Class) {\n            clazz = (Class<?>) o;\n         } else {\n            clazz = o.getClass();\n         }\n\n         ClassLoader cl = clazz.getClassLoader();\n         while (cl != null) {\n            if (cl == this.getClass().getClassLoader()) {\n               return true;\n            }\n            cl = cl.getParent();\n         }\n\n         if (o instanceof Collection<?>) {\n            Iterator<?> iter = ((Collection<?>) o).iterator();\n            try {\n               while (iter.hasNext()) {\n                  Object entry = iter.next();\n                  if (loadedByThisOrChild(entry)) {\n                     return true;\n                  }\n               }\n            } catch (ConcurrentModificationException e) {\n               log.warn(\"Failed to check for ThreadLocal references for web application [{}]\", getContextName(), e);\n            }\n         }\n         return false;\n      }",
    "comment": "@param o object to test, may be null\n@return <code>true</code> if o has been loaded by the current classloader\nor one of its descendants."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/sasl/ShuffleSecretManagerSuite.java",
    "type": "method",
    "name": "testMultipleRegisters",
    "code": "public void testMultipleRegisters() {\n    ShuffleSecretManager secretManager = new ShuffleSecretManager();\n    secretManager.registerApp(app1, pw1);\n    assertEquals(pw1, secretManager.getSecretKey(app1));\n    secretManager.registerApp(app2, ByteBuffer.wrap(pw2.getBytes()));\n    assertEquals(pw2, secretManager.getSecretKey(app2));\n\n    secretManager.registerApp(app1, pw1update);\n    assertEquals(pw1update, secretManager.getSecretKey(app1));\n    secretManager.registerApp(app2, ByteBuffer.wrap(pw2update.getBytes()));\n    assertEquals(pw2update, secretManager.getSecretKey(app2));\n\n    secretManager.unregisterApp(app1);\n    assertNull(secretManager.getSecretKey(app1));\n    assertEquals(pw2update, secretManager.getSecretKey(app2));\n\n    secretManager.unregisterApp(app2);\n    assertNull(secretManager.getSecretKey(app2));\n    assertNull(secretManager.getSecretKey(app1));\n  }",
    "comment": "now update the password for the apps and make sure it takes affect"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/crypto/AuthIntegrationSuite.java",
    "type": "method",
    "name": "AuthTestCtx",
    "code": "ctx = new AuthTestCtx(new RpcHandler() {\n\n      @Override\n      public StreamManager getStreamManager() {\n        return null;\n      }\n    });",
    "comment": "This test covers the case where an attacker replays a challenge message sniffed from the\nnetwork, but doesn't know the actual secret. The server should close the connection as\nsoon as a message is sent after authentication is performed. This is emulated by removing\nthe client encryption handler after authentication.\nUse a big length to create a message that cannot be put into the encryption buffer completely"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/CollectionUtils.java",
    "type": "method",
    "name": "getOnlyElement",
    "code": "public static <T> T getOnlyElement(Collection<T> collection) {\n\t\tPreconditions.notNull(collection, \"collection must not be null\");\n\t\tPreconditions.condition(collection.size() == 1,\n\t\t\t() -> \"collection must contain exactly one element: \" + collection);\n\t\treturn firstElement(collection);\n\t}",
    "comment": "Get the only element of a collection of size 1.\n\n@param collection the collection to get the element from\n@return the only element of the collection\n@throws PreconditionViolationException if the collection is {@code null}\nor does not contain exactly one element"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerOperation.java",
    "type": "method",
    "name": "shape",
    "code": "public long[] shape(int outputIndex) {\n    Tensor<?> tensor = outputTensors.get(outputIndex);\n    if (tensor != null) {\n      return tensor.shape();\n    }\n    long outputNativeHandle = getUnsafeNativeHandle(outputIndex);\n    long[] shape = new long[numDims(outputNativeHandle)];\n    for (int i = 0; i < shape.length; ++i) {\n      shape[i] = dim(outputNativeHandle, i);\n    }\n    return shape;\n  }",
    "comment": "If the tensor of this output has already been resolved, return its shape.\nOtherwise, retrieve the tensor shape from the native library."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/BuildFailure.java",
    "type": "method",
    "name": "BuildFailure",
    "code": "public BuildFailure(MavenProject project, Duration time, Throwable cause) {\n        this(project, time, time, cause);\n    }",
    "comment": "Creates a new build summary for the specified project.\n\n@param project The project being summarized, must not be {@code null}.\n@param time The build time of the project in milliseconds.\n@param cause The cause of the build failure, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(double[] expecteds, double[] actuals, double delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }",
    "comment": "Asserts that two double arrays are equal. If they are not, an\n{@link AssertionError} is thrown.\n\n@param expecteds double array with expected values.\n@param actuals double array with actual values\n@param delta the maximum delta between <code>expecteds[i]</code> and\n<code>actuals[i]</code> for which both numbers are still\nconsidered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeInMemorySorter.java",
    "type": "method",
    "name": "loadNext",
    "code": "public void loadNext() {\n      if (taskContext != null) {\n        taskContext.killTaskIfInterrupted();\n      }\n      final long recordPointer = array.get(offset + position);\n      currentPageNumber = TaskMemoryManager.decodePageNumber(recordPointer);\n      int uaoSize = UnsafeAlignedOffset.getUaoSize();\n      baseObject = memoryManager.getPage(recordPointer);\n      baseOffset = memoryManager.getOffsetInPage(recordPointer) + uaoSize;\n      recordLength = UnsafeAlignedOffset.getSize(baseObject, baseOffset - uaoSize);\n      keyPrefix = array.get(offset + position + 1);\n      position += 2;\n    }",
    "comment": "Kill the task in case it has been marked as killed. This logic is from\nInterruptibleIterator, but we inline it here instead of wrapping the iterator in order\nto avoid performance overhead. This check is added here in `loadNext()` instead of in\n`hasNext()` because it's technically possible for the caller to be relying on\n`getNumRecords()` instead of `hasNext()` to know when to stop.\nThis pointer points to a 4-byte record length, followed by the record's bytes\nSkip over record length"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/UnsafeShuffleWriter.java",
    "type": "method",
    "name": "getPeakMemoryUsedBytes",
    "code": "public long getPeakMemoryUsedBytes() {\n    updatePeakMemoryUsed();\n    return peakMemoryUsedBytes;\n  }",
    "comment": "Return the peak memory used so far, in bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageUniqueIdBuilder.java",
    "type": "method",
    "name": "uniqueIdForErrorInClass",
    "code": "public static UniqueId uniqueIdForErrorInClass(Class<?> clazz, Class<?> failingClass) {\n\t\treturn uniqueIdForClasses(clazz).append(VintageTestDescriptor.SEGMENT_TYPE_TEST,\n\t\t\t\"initializationError(\" + failingClass.getName() + \")\");\n\t}",
    "comment": "Test data builder for building unique IDs for the {@link VintageTestEngine}.\n\nUsed to decouple tests from concrete unique ID strings.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/OutputChoice.java",
    "type": "method",
    "name": "if",
    "code": "OutputChoice(OutputChoiceType outputChoiceType) {\n        if (outputChoiceType == OutputChoiceType.FILE) {\n            throw new IllegalArgumentException();\n        }\n        this.outputChoiceType = outputChoiceType;\n        if (outputChoiceType == OutputChoiceType.CACHED_SYS_OUT) {\n            this.targetPrintStream = System.out;\n        } else if (outputChoiceType == OutputChoiceType.CACHED_SYS_ERR) {\n            this.targetPrintStream = System.err;\n        } else {\n            this.targetPrintStream = null;\n        }\n    }",
    "comment": "This class encapsulates the user's choice of output target.\n\n@author Ceki G&uuml;lc&uuml;"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/RelocatedArtifact.java",
    "type": "method",
    "name": "setVersion",
    "code": "public Artifact setVersion(String version) {\n        String current = getVersion();\n        if (current.equals(version) || (version == null && current.isEmpty())) {\n            return this;\n        }\n        return new RelocatedArtifact(artifact, groupId, artifactId, classifier, extension, version, message);\n    }",
    "comment": "Revise these three methods when MRESOLVER-233 is delivered"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/execution/sort/RecordBinaryComparatorSuite.java",
    "type": "method",
    "name": "testCompareLongsAsLittleEndian",
    "code": "public void testCompareLongsAsLittleEndian() {\n    long arrayOffset = Platform.LONG_ARRAY_OFFSET + 4;\n\n    long[] arr1 = new long[2];\n    Platform.putLong(arr1, arrayOffset, 0x0100000000000000L);\n    long[] arr2 = new long[2];\n    Platform.putLong(arr2, arrayOffset + 4, 0x0000000000000001L);\n    int result1 = binaryComparator.compare(arr1, arrayOffset, 8, arr2, arrayOffset + 4, 8);\n\n    long[] arr3 = new long[2];\n    Platform.putLong(arr3, arrayOffset, 0x0100000000000000L);\n    long[] arr4 = new long[2];\n    Platform.putLong(arr4, arrayOffset, 0x0000000000000001L);\n    int result2 = binaryComparator.compare(arr3, arrayOffset, 8, arr4, arrayOffset, 8);\n\n    Assertions.assertEquals(result1, result2);\n  }",
    "comment": "leftBaseOffset is not aligned while rightBaseOffset is aligned,\nit will start by comparing long\nboth left and right offset is not aligned, it will start with byte-by-byte comparison"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/BaseParser.java",
    "type": "method",
    "name": "parseInvocation",
    "code": "public InvokerRequest parseInvocation(ParserRequest parserRequest) {\n        requireNonNull(parserRequest);\n\n        LocalContext context = new LocalContext(parserRequest);\n\n        try {\n            context.cwd = getCwd(context);\n        } catch (Exception e) {\n            context.parsingFailed = true;\n            context.cwd = getCanonicalPath(Paths.get(\".\"));\n            parserRequest.logger().error(\"Error determining working directory\", e);\n        }\n        try {\n            context.installationDirectory = getInstallationDirectory(context);\n        } catch (Exception e) {\n            context.parsingFailed = true;\n            context.installationDirectory = context.cwd;\n            parserRequest.logger().error(\"Error determining installation directory\", e);\n        }\n        try {\n            context.userHomeDirectory = getUserHomeDirectory(context);\n        } catch (Exception e) {\n            context.parsingFailed = true;\n            context.userHomeDirectory = context.cwd;\n            parserRequest.logger().error(\"Error determining user home directory\", e);\n        }\n\n        try {\n            context.topDirectory = getTopDirectory(context);\n        } catch (Exception e) {\n            context.parsingFailed = true;\n            context.topDirectory = context.cwd;\n            parserRequest.logger().error(\"Error determining top directory\", e);\n        }\n        try {\n            context.rootDirectory = getRootDirectory(context);\n        } catch (Exception e) {\n            context.parsingFailed = true;\n            context.rootDirectory = context.cwd;\n            parserRequest.logger().error(\"Error determining root directory\", e);\n        }\n\n        List<Options> parsedOptions;\n        try {\n            parsedOptions = parseCliOptions(context);\n        } catch (Exception e) {\n            context.parsingFailed = true;\n            parsedOptions = List.of(emptyOptions());\n            parserRequest.logger().error(\"Error parsing program arguments\", e);\n        }\n\n        try {\n            context.options = assembleOptions(parsedOptions);\n        } catch (Exception e) {\n            context.parsingFailed = true;\n            context.options = emptyOptions();\n            parserRequest.logger().error(\"Error assembling program arguments\", e);\n        }\n\n        try {\n            context.systemProperties = populateSystemProperties(context);\n        } catch (Exception e) {\n            context.parsingFailed = true;\n            context.systemProperties = new HashMap<>();\n            parserRequest.logger().error(\"Error populating system properties\", e);\n        }\n        try {\n            context.userProperties = populateUserProperties(context);\n        } catch (Exception e) {\n            context.parsingFailed = true;\n            context.userProperties = new HashMap<>();\n            parserRequest.logger().error(\"Error populating user properties\", e);\n        }\n\n        context.options = context.options.interpolate(Interpolator.chain(\n                context.extraInterpolationSource()::get, context.userProperties::get, context.systemProperties::get));\n\n        try {\n            context.extensions = readCoreExtensionsDescriptor(context);\n        } catch (Exception e) {\n            context.parsingFailed = true;\n            parserRequest.logger().error(\"Error reading core extensions descriptor\", e);\n        }\n\n        context.ciInfo = detectCI(context);\n\n        if (!context.parsingFailed) {\n            validate(context);\n        }\n\n        return getInvokerRequest(context);\n    }",
    "comment": "the basics\ntop/root\noptions\nassemble options if needed\nsystem and user properties\noptions: interpolate\ncore extensions\nCI detection\nonly if not failed so far; otherwise we may have no options to validate"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectUniqueId",
    "code": "public static UniqueIdSelector selectUniqueId(String uniqueId) {\n\t\tPreconditions.notBlank(uniqueId, \"Unique ID must not be null or blank\");\n\t\treturn new UniqueIdSelector(UniqueId.parse(uniqueId));\n\t}",
    "comment": "Create a {@code UniqueIdSelector} for the supplied unique ID.\n\n@param uniqueId the unique ID to select; never {@code null} or blank\n@see UniqueIdSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java",
    "type": "method",
    "name": "underscoreGenerator",
    "code": "void underscoreGenerator() {\n\t\tvar expectedDisplayNames = new String[] { //\n\n\t\texpectedDisplayNames[0] = \"CONTAINER: DisplayNameGenerationTests$UnderscoreStyleTestCase\";\n\t\tcheck(UnderscoreStyleTestCase.class, expectedDisplayNames);\n\n\t\texpectedDisplayNames[0] = \"CONTAINER: DisplayNameGenerationTests$UnderscoreStyleInheritedFromSuperClassTestCase\";\n\t\tcheck(UnderscoreStyleInheritedFromSuperClassTestCase.class, expectedDisplayNames);\n\t}\n\n\t@Test\n\tvoid indicativeSentencesGeneratorOnStaticNestedClass() {\n\t\tcheck(IndicativeStyleTestCase.class, //\n\t\t\t\"CONTAINER: DisplayNameGenerationTests$IndicativeStyleTestCase\", //\n\t\t\t\"TEST: @DisplayName prevails\", //\n\t\t\t\"TEST: DisplayNameGenerationTests$IndicativeStyleTestCase -> test\", //\n\t\t\t\"TEST: DisplayNameGenerationTests$IndicativeStyleTestCase -> test (TestInfo)\", //\n\t\t\t\"TEST: DisplayNameGenerationTests$IndicativeStyleTestCase -> test with underscores\", //\n\t\t\t\"TEST: DisplayNameGenerationTests$IndicativeStyleTestCase -> testUsingCamelCase and also UnderScores\", //\n\t\t\t\"TEST: DisplayNameGenerationTests$IndicativeStyleTestCase -> testUsingCamelCase and also UnderScores keepingParameterTypeNamesIntact (TestInfo)\", //\n\t\t\t\"TEST: DisplayNameGenerationTests$IndicativeStyleTestCase -> testUsingCamelCaseStyle\" //\n\t\t);\n\t}\n\n\t@Test\n\tvoid indicativeSentencesGeneratorOnTopLevelClass() {\n\t\tcheck(IndicativeSentencesTopLevelTestCase.class, //\n\t\t\t\"CONTAINER: IndicativeSentencesTopLevelTestCase\", //\n\t\t\t\"CONTAINER: IndicativeSentencesTopLevelTestCase -> A year is a leap year\", //\n\t\t\t\"TEST: IndicativeSentencesTopLevelTestCase -> A year is a leap year -> if it is divisible by 4 but not by 100\" //\n\t\t);\n\t}\n\n\t@Test\n\tvoid indicativeSentencesGeneratorOnNestedClass() {\n\t\tcheck(IndicativeSentencesNestedTestCase.class, //\n\t\t\t\"CONTAINER: IndicativeSentencesNestedTestCase\", //\n\t\t\t\"CONTAINER: A year is a leap year\", //\n\t\t\t\"TEST: A year is a leap year -> if it is divisible by 4 but not by 100\" //\n\t\t);\n\t}\n\n\t@Test\n\tvoid noNameGenerator() {\n\t\tcheck(NoNameStyleTestCase.class, //\n\t\t\t\"CONTAINER: nn\", //\n\t\t\t\"TEST: @DisplayName prevails\", //\n\t\t\t\"TEST: nn\", //\n\t\t\t\"TEST: nn\", //\n\t\t\t\"TEST: nn\", //\n\t\t\t\"TEST: nn\", //\n\t\t\t\"TEST: nn\", //\n\t\t\t\"TEST: nn\" //\n\t\t);\n\t}\n\n\t@Test\n\tvoid checkDisplayNameGeneratedForTestingAStackDemo() {\n\t\tcheck(StackTestCase.class, //\n\t\t\t\"CONTAINER: A stack\", //\n\t\t\t\"TEST: is instantiated using its noarg constructor\", //\n\t\t\t\"CONTAINER: A new stack\", //\n\t\t\t\"TEST: throws an EmptyStackException when peeked\", //\n\t\t\t\"TEST: throws an EmptyStackException when popped\", //\n\t\t\t\"TEST: is empty\", //\n\t\t\t\"CONTAINER: After pushing an element to an empty stack\", //\n\t\t\t\"TEST: peek returns that element without removing it from the stack\", //\n\t\t\t\"TEST: pop returns that element and leaves an empty stack\", //\n\t\t\t\"TEST: the stack is no longer empty\" //\n\t\t);\n\t}\n\n\t@Test\n\tvoid checkDisplayNameGeneratedForIndicativeGenerator() {\n\t\tcheck(IndicativeGeneratorTestCase.class, //\n\t\t\t\"CONTAINER: A stack\", //\n\t\t\t\"TEST: A stack, is instantiated with its constructor\", //\n\t\t\t\"CONTAINER: A stack, when new\", //\n\t\t\t\"TEST: A stack, when new, throws EmptyStackException when peeked\", //\n\t\t\t\"CONTAINER: A stack, when new, after pushing an element to an empty stack\", //\n\t\t\t\"TEST: A stack, when new, after pushing an element to an empty stack, is no longer empty\" //\n\t\t);\n\t}\n\n\t@Test\n\tvoid checkDisplayNameGeneratedForIndicativeGeneratorWithCustomSeparator() {\n\t\tcheck(IndicativeGeneratorWithCustomSeparatorTestCase.class, //\n\t\t\t\"CONTAINER: A stack\", //\n\t\t\t\"TEST: A stack >> is instantiated with its constructor\", //\n\t\t\t\"CONTAINER: A stack >> when new\", //\n\t\t\t\"TEST: A stack >> when new >> throws EmptyStackException when peeked\", //\n\t\t\t\"CONTAINER: A stack >> when new >> after pushing an element to an empty stack\", //\n\t\t\t\"TEST: A stack >> when new >> after pushing an element to an empty stack >> is no longer empty\" //\n\t\t);\n\t}\n\n\t@Test\n\tvoid checkDisplayNameGeneratedForIndicativeGeneratorWithCustomSentenceFragments() {\n\t\tcheck(IndicativeGeneratorWithCustomSentenceFragmentsTestCase.class, //\n\t\t\t\"CONTAINER: A stack\", //\n\t\t\t\"TEST: A stack, is instantiated with its constructor\", //\n\t\t\t\"CONTAINER: A stack, when new\", //\n\t\t\t\"TEST: A stack, when new, throws EmptyStackException when peeked\", //\n\t\t\t\"CONTAINER: A stack, when new, after pushing an element to an empty stack\", //\n\t\t\t\"TEST: A stack, when new, after pushing an element to an empty stack, is no longer empty\" //\n\t\t);\n\t}\n\n\t@Test\n\tvoid blankSentenceFragmentOnClassYieldsError() {\n\t\tvar results = discoverTests(selectClass(BlankSentenceFragmentOnClassTestCase.class));\n\n\t\tvar discoveryIssues = results.getDiscoveryIssues();\n\t\tassertThat(discoveryIssues).hasSize(1);\n\t\tassertThat(discoveryIssues.getFirst().severity()).isEqualTo(Severity.ERROR);\n\t\tassertThat(discoveryIssues.getFirst().cause().orElseThrow()) //\n\t\t\t\t.hasMessage(\"@SentenceFragment on [%s] must be declared with a non-blank value.\",\n\t\t\t\t\tBlankSentenceFragmentOnClassTestCase.class);\n\t}\n\n\t@Test\n\tvoid blankSentenceFragmentOnMethodYieldsError() throws Exception {\n\t\tvar results = discoverTests(selectMethod(BlankSentenceFragmentOnMethodTestCase.class, \"test\"));\n\n\t\tvar discoveryIssues = results.getDiscoveryIssues();\n\t\tassertThat(discoveryIssues).hasSize(1);\n\t\tassertThat(discoveryIssues.getFirst().severity()).isEqualTo(Severity.ERROR);\n\t\tassertThat(discoveryIssues.getFirst().cause().orElseThrow()) //\n\t\t\t\t.hasMessage(\"@SentenceFragment on [%s] must be declared with a non-blank value.\",\n\t\t\t\t\tBlankSentenceFragmentOnMethodTestCase.class.getDeclaredMethod(\"test\"));\n\t}\n\n\t@Test\n\tvoid displayNameGenerationInheritance() {\n\t\tcheck(DisplayNameGenerationInheritanceTestCase.InnerNestedTestCase.class, //\n\t\t\t\"CONTAINER: DisplayNameGenerationInheritanceTestCase\", //\n\t\t\t\"CONTAINER: InnerNestedTestCase\", //\n\t\t\t\"TEST: this is a test\"//\n\t\t);\n\n\t\tcheck(DisplayNameGenerationInheritanceTestCase.StaticNestedTestCase.class, //\n\t\t\t\"CONTAINER: DisplayNameGenerationInheritanceTestCase$StaticNestedTestCase\", //\n\t\t\t\"TEST: this_is_a_test()\"//\n\t\t);\n\t}\n\n\t@Test\n\tvoid indicativeSentencesGenerationInheritance() {\n\t\tcheck(IndicativeSentencesGenerationInheritanceTestCase.InnerNestedTestCase.class, //\n\t\t\t\"CONTAINER: IndicativeSentencesGenerationInheritanceTestCase\", //\n\t\t\t\"CONTAINER: IndicativeSentencesGenerationInheritanceTestCase -> InnerNestedTestCase\", //\n\t\t\t\"TEST: IndicativeSentencesGenerationInheritanceTestCase -> InnerNestedTestCase -> this is a test\"//\n\t\t);\n\n\t\tcheck(IndicativeSentencesGenerationInheritanceTestCase.StaticNestedTestCase.class, //\n\t\t\t\"CONTAINER: IndicativeSentencesGenerationInheritanceTestCase$StaticNestedTestCase\", //\n\t\t\t\"TEST: this_is_a_test()\"//\n\t\t);\n\t}\n\n\t@Test\n\tvoid indicativeSentencesRuntimeEnclosingType() {\n\t\tcheck(IndicativeSentencesRuntimeEnclosingTypeScenarioOneTestCase.class, //\n\t\t\t\"CONTAINER: Scenario 1\", //\n\t\t\t\"CONTAINER: Scenario 1 -> Level 1\", //\n\t\t\t\"CONTAINER: Scenario 1 -> Level 1 -> Level 2\", //\n\t\t\t\"TEST: Scenario 1 -> Level 1 -> Level 2 -> this is a test\"//\n\t\t);\n\n\t\tcheck(IndicativeSentencesRuntimeEnclosingTypeScenarioTwoTestCase.class, //\n\t\t\t\"CONTAINER: Scenario 2\", //\n\t\t\t\"CONTAINER: Scenario 2 -> Level 1\", //\n\t\t\t\"CONTAINER: Scenario 2 -> Level 1 -> Level 2\", //\n\t\t\t\"TEST: Scenario 2 -> Level 1 -> Level 2 -> this is a test\"//\n\t\t);\n\t}\n\n\t@Test\n\tvoid indicativeSentencesOnSubClass() {\n\t\tcheck(IndicativeSentencesOnSubClassScenarioOneTestCase.class, //\n\t\t\t\"CONTAINER: IndicativeSentencesOnSubClassScenarioOneTestCase\", //\n\t\t\t\"CONTAINER: IndicativeSentencesOnSubClassScenarioOneTestCase -> Level 1\", //\n\t\t\t\"CONTAINER: IndicativeSentencesOnSubClassScenarioOneTestCase -> Level 1 -> Level 2\", //\n\t\t\t\"TEST: IndicativeSentencesOnSubClassScenarioOneTestCase -> Level 1 -> Level 2 -> this is a test\"//\n\t\t);\n\t}\n\n\t@Test\n\tvoid indicativeSentencesOnClassTemplate() {\n\t\tcheck(ClassTemplateTestCase.class, //\n\t\t\t\"CONTAINER: Class template\", //\n\t\t\t\"CONTAINER: [1] Class template\", //\n\t\t\t\"TEST: Class template, some test\", //\n\t\t\t\"CONTAINER: Class template, Regular Nested Test Case\", //\n\t\t\t\"TEST: Class template, Regular Nested Test Case, some nested test\", //\n\t\t\t\"CONTAINER: Class template, Nested Class Template\", //\n\t\t\t\"CONTAINER: [1] Class template, Nested Class Template\", //\n\t\t\t\"TEST: Class template, Nested Class Template, some nested test\" //\n\t\t);\n\n\t\tassertThat(executeTestsForClass(ClassTemplateTestCase.class).allEvents().started().stream()) //\n\t\t\t\t.map(event -> event.getTestDescriptor().getDisplayName()) //\n\t\t\t\t.containsExactly( //\n\t\t\t\t\t\"JUnit Jupiter\", //\n\t\t\t\t\t\"Class template\", //\n\t\t\t\t\t\"[1] Class template\", //\n\t\t\t\t\t\"Class template, some test\", //\n\t\t\t\t\t\"Class template, Regular Nested Test Case\", //\n\t\t\t\t\t\"Class template, Regular Nested Test Case, some nested test\", //\n\t\t\t\t\t\"Class template, Nested Class Template\", //\n\t\t\t\t\t\"[1] Class template, Nested Class Template\", //\n\t\t\t\t\t\"Class template, Nested Class Template, some nested test\" //\n\t\t\t\t);\n\t}\n\n\tprivate void check(Class<?> testClass, String... expectedDisplayNames) {\n\t\tvar results = executeTestsForClass(testClass);\n\t\tcheck(results, expectedDisplayNames);\n\t}\n\n\tprivate void check(EngineExecutionResults results, String[] expectedDisplayNames) {\n\t\tvar descriptors = results.allEvents().started().stream() //\n\t\t\t\t.map(Event::getTestDescriptor) //\n\t\t\t\t.skip(1); // Skip engine descriptor\n\t\tassertThat(descriptors) //\n\t\t\t\t.map(it -> it.getType() + \": \" + it.getDisplayName()) //\n\t\t\t\t.containsExactlyInAnyOrder(expectedDisplayNames);\n\t}\n\n\n\tstatic class NoNameGenerator implements DisplayNameGenerator {\n\n\t\t@Override\n\t\tpublic String generateDisplayNameForClass(Class<?> testClass) {\n\t\t\treturn \"nn\";\n\t\t}\n\n\t\t@Override\n\t\tpublic String generateDisplayNameForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> nestedClass) {\n\t\t\treturn \"nn\";\n\t\t}\n\n\t\t@Override\n\t\tpublic String generateDisplayNameForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass,\n\t\t\t\tMethod testMethod) {\n\t\t\treturn \"nn\";\n\t\t}\n\t}\n\n\t@DisplayNameGeneration(NoNameGenerator.class)\n\tstatic abstract class AbstractTestCase {\n\t\t@Test\n\t\tvoid test() {\n\t\t}\n\n\t\t@Test\n\t\tvoid test(TestInfo testInfo) {\n\t\t\ttestInfo.getDisplayName();\n\t\t}\n\n\t\t@Test\n\t\tvoid testUsingCamelCaseStyle() {\n\t\t}\n\n\t\t@Test\n\t\tvoid testUsingCamelCase_and_also_UnderScores() {\n\t\t}\n\n\t\t@Test\n\t\tvoid testUsingCamelCase_and_also_UnderScores_keepingParameterTypeNamesIntact(TestInfo testInfo) {\n\t\t\ttestInfo.getDisplayName();\n\t\t}\n\n\t\t@Test\n\t\tvoid test_with_underscores() {\n\t\t}\n\n\t\t@DisplayName(\"@DisplayName prevails\")\n\t\t@Test\n\t\tvoid testDisplayNamePrevails() {\n\t\t}\n\t}\n\n\t@DisplayNameGeneration(DisplayNameGenerator.Standard.class)\n\tstatic class DefaultStyleTestCase extends AbstractTestCase {\n\t}\n\n\t@DisplayNameGeneration(DisplayNameGenerator.Simple.class)\n\tstatic class SimpleStyleTestCase extends AbstractTestCase {\n\t}\n\n\t@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)\n\tstatic class UnderscoreStyleTestCase extends AbstractTestCase {\n\t}\n\n\t@IndicativeSentencesGeneration(separator = \" -> \", generator = DisplayNameGenerator.ReplaceUnderscores.class)\n\tstatic class IndicativeStyleTestCase extends AbstractTestCase {\n\t}\n\n\t@DisplayNameGeneration(NoNameGenerator.class)\n\tstatic class NoNameStyleTestCase extends AbstractTestCase {\n\t}\n\n\tstatic class UnderscoreStyleInheritedFromSuperClassTestCase extends UnderscoreStyleTestCase {\n\t}\n\n\n\t@SuppressWarnings(\"JUnitMalformedDeclaration\")\n\t@DisplayName(\"A stack\")\n\t@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)\n\tstatic class StackTestCase {\n\n\t\tStack<Object> stack;\n\n\t\t@Test\n\t\tvoid is_instantiated_using_its_noarg_constructor() {\n\t\t\tnew Stack<>();\n\t\t}\n\n\t\t@Nested\n\t\tclass A_new_stack {\n\n\t\t\t@BeforeEach\n\t\t\tvoid createNewStack() {\n\t\t\t\tstack = new Stack<>();\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid is_empty() {\n\t\t\t\tassertTrue(stack.isEmpty());\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid throws_an_EmptyStackException_when_popped() {\n\t\t\t\tassertThrows(EmptyStackException.class, () -> stack.pop());\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid throws_an_EmptyStackException_when_peeked() {\n\t\t\t\tassertThrows(EmptyStackException.class, () -> stack.peek());\n\t\t\t}\n\n\t\t\t@Nested\n\t\t\tclass After_pushing_an_element_to_an_empty_stack {\n\n\t\t\t\tString anElement = \"an element\";\n\n\t\t\t\t@BeforeEach\n\t\t\t\tvoid pushAnElement() {\n\t\t\t\t\tstack.push(anElement);\n\t\t\t\t}\n\n\t\t\t\t@Test\n\t\t\t\tvoid the_stack_is_no_longer_empty() {\n\t\t\t\t\tassertFalse(stack.isEmpty());\n\t\t\t\t}\n\n\t\t\t\t@Test\n\t\t\t\tvoid pop_returns_that_element_and_leaves_an_empty_stack() {\n\t\t\t\t\tassertEquals(anElement, stack.pop());\n\t\t\t\t\tassertTrue(stack.isEmpty());\n\t\t\t\t}\n\n\t\t\t\t@Test\n\t\t\t\tvoid peek_returns_that_element_without_removing_it_from_the_stack() {\n\t\t\t\t\tassertEquals(anElement, stack.peek());\n\t\t\t\t\tassertFalse(stack.isEmpty());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"JUnitMalformedDeclaration\")\n\t@DisplayName(\"A stack\")\n\t@IndicativeSentencesGeneration(generator = DisplayNameGenerator.ReplaceUnderscores.class)\n\tstatic class IndicativeGeneratorTestCase {\n\n\t\tStack<Object> stack;\n\n\t\t@Test\n\t\tvoid is_instantiated_with_its_constructor() {\n\t\t\tnew Stack<>();\n\t\t}\n\n\t\t@Nested\n\t\tclass when_new {\n\n\t\t\t@Test\n\t\t\tvoid throws_EmptyStackException_when_peeked() {\n\t\t\t\tassertThrows(EmptyStackException.class, () -> stack.peek());\n\t\t\t}\n\n\t\t\t@Nested\n\t\t\tclass after_pushing_an_element_to_an_empty_stack {\n\n\t\t\t\tString anElement = \"an element\";\n\n\t\t\t\t@BeforeEach\n\t\t\t\tvoid push_an_element() {\n\t\t\t\t\tstack.push(anElement);\n\t\t\t\t}\n\n\t\t\t\t@Test\n\t\t\t\tvoid is_no_longer_empty() {\n\t\t\t\t\tassertFalse(stack.isEmpty());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"JUnitMalformedDeclaration\")\n\t@DisplayName(\"A stack\")\n\t@IndicativeSentencesGeneration(separator = \" >> \", generator = DisplayNameGenerator.ReplaceUnderscores.class)\n\tstatic class IndicativeGeneratorWithCustomSeparatorTestCase {\n\n\t\tStack<Object> stack;\n\n\t\t@Test\n\t\tvoid is_instantiated_with_its_constructor() {\n\t\t\tnew Stack<>();\n\t\t}\n\n\t\t@Nested\n\t\tclass when_new {\n\n\t\t\t@Test\n\t\t\tvoid throws_EmptyStackException_when_peeked() {\n\t\t\t\tassertThrows(EmptyStackException.class, () -> stack.peek());\n\t\t\t}\n\n\t\t\t@Nested\n\t\t\tclass after_pushing_an_element_to_an_empty_stack {\n\n\t\t\t\tString anElement = \"an element\";\n\n\t\t\t\t@BeforeEach\n\t\t\t\tvoid push_an_element() {\n\t\t\t\t\tstack.push(anElement);\n\t\t\t\t}\n\n\t\t\t\t@Test\n\t\t\t\tvoid is_no_longer_empty() {\n\t\t\t\t\tassertFalse(stack.isEmpty());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"JUnitMalformedDeclaration\")\n\t@SentenceFragment(\"A stack\")\n\t@IndicativeSentencesGeneration\n\tstatic class IndicativeGeneratorWithCustomSentenceFragmentsTestCase {\n\n\t\tStack<Object> stack;\n\n\t\t@SentenceFragment(\"is instantiated with its constructor\")\n\t\t@Test\n\t\tvoid instantiateViaConstructor() {\n\t\t\tnew Stack<>();\n\t\t}\n\n\t\t@SentenceFragment(\"when new\")\n\t\t@Nested\n\t\tclass NewStackTestCase {\n\n\t\t\t@BeforeEach\n\t\t\tvoid createNewStack() {\n\t\t\t\tstack = new Stack<>();\n\t\t\t}\n\n\t\t\t@SentenceFragment(\"throws EmptyStackException when peeked\")\n\t\t\t@Test\n\t\t\tvoid throwsExceptionWhenPeeked() {\n\t\t\t\tassertThrows(EmptyStackException.class, () -> stack.peek());\n\t\t\t}\n\n\t\t\t@SentenceFragment(\"after pushing an element to an empty stack\")\n\t\t\t@Nested\n\t\t\tclass ElementPushedOntoStackTestCase {\n\n\t\t\t\tString anElement = \"an element\";\n\n\t\t\t\t@BeforeEach\n\t\t\t\tvoid pushElementOntoStack() {\n\t\t\t\t\tstack.push(anElement);\n\t\t\t\t}\n\n\t\t\t\t@SentenceFragment(\"is no longer empty\")\n\t\t\t\t@Test\n\t\t\t\tvoid nonEmptyStack() {\n\t\t\t\t\tassertFalse(stack.isEmpty());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"JUnitMalformedDeclaration\")\n\t@ClassTemplate\n\t@ExtendWith(ClassTemplateTestCase.Once.class)\n\t@DisplayName(\"Class template\")\n\t@IndicativeSentencesGeneration(generator = DisplayNameGenerator.ReplaceUnderscores.class)\n\t@TestClassOrder(ClassOrderer.OrderAnnotation.class)\n\tstatic class ClassTemplateTestCase {\n\n\t\t@Test\n\t\tvoid some_test() {\n\t\t}\n\n\t\t@Nested\n\t\t@Order(1)\n\t\tclass Regular_Nested_Test_Case {\n\t\t\t@Test\n\t\t\tvoid some_nested_test() {\n\t\t\t}\n\t\t}\n\n\t\t@Nested\n\t\t@Order(2)\n\t\t@ClassTemplate\n\t\tclass Nested_Class_Template {\n\t\t\t@Test\n\t\t\tvoid some_nested_test() {\n\t\t\t}\n\t\t}\n\n\t\tprivate static class Once implements ClassTemplateInvocationContextProvider {\n\n\t\t\t@Override\n\t\t\tpublic boolean supportsClassTemplate(ExtensionContext context) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Stream<ClassTemplateInvocationContext> provideClassTemplateInvocationContexts(\n\t\t\t\t\tExtensionContext context) {\n\t\t\t\treturn Stream.of(new ClassTemplateInvocationContext() {\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"JUnitMalformedDeclaration\")\n\t@IndicativeSentencesGeneration\n\t@SentenceFragment(\"\")\n\tstatic class BlankSentenceFragmentOnClassTestCase {\n\t\t@Test\n\t\tvoid test() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"JUnitMalformedDeclaration\")\n\t@IndicativeSentencesGeneration\n\tstatic class BlankSentenceFragmentOnMethodTestCase {\n\t\t@SentenceFragment(\"\\t\")\n\t\t@Test\n\t\tvoid test() {\n\t\t}\n\t}\n\n}",
    "comment": "-------------------------------------------------------------------------\nNo annotation here! @DisplayNameGeneration is inherited from super class\n-------------------------------------------------------------------------\n-------------------------------------------------------------------------\n-------------------------------------------------------------------------\n-------------------------------------------------------------------------\n-------------------------------------------------------------------------"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-jfr/src/main/java/org/junit/platform/jfr/FlightRecordingExecutionListener.java",
    "type": "method",
    "name": "testPlanExecutionStarted",
    "code": "public void testPlanExecutionStarted(TestPlan plan) {\n\t\tTestPlanExecutionEvent event = new TestPlanExecutionEvent();\n\t\tevent.containsTests = plan.containsTests();\n\t\tevent.engineNames = plan.getRoots().stream().map(TestIdentifier::getDisplayName).collect(\n\t\t\tCollectors.joining(\", \"));\n\t\ttestPlanExecutionEvent.set(event);\n\t\tevent.begin();\n\t}",
    "comment": "A {@link TestExecutionListener} that generates Java Flight Recorder\nevents.\n\n@since 1.8\n@see <a href=\"https://openjdk.java.net/jeps/328\">JEP 328: Flight Recorder</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeArrayWriter.java",
    "type": "method",
    "name": "assertIndexIsValid",
    "code": "private void assertIndexIsValid(int index) {\n    assert index >= 0 : \"index (\" + index + \") should >= 0\";\n    assert index < numElements : \"index (\" + index + \") should < \" + numElements;\n  }",
    "comment": "A helper class to write data into global row buffer using `UnsafeArrayData` format,\nused by {@link org.apache.spark.sql.catalyst.expressions.codegen.GenerateUnsafeProjection}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/sub/SystemPropertyCondition.java",
    "type": "method",
    "name": "evaluateExecutionCondition",
    "code": "public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {\n\t\tOptional<SystemProperty> optional = findAnnotation(context.getElement(), SystemProperty.class);\n\n\t\tif (optional.isPresent()) {\n\t\t\tSystemProperty systemProperty = optional.get();\n\t\t\tString key = systemProperty.key();\n\t\t\tString expected = systemProperty.value();\n\t\t\tString actual = System.getProperty(key);\n\n\t\t\tif (!Objects.equals(expected, actual)) {\n\t\t\t\treturn ConditionEvaluationResult.disabled(\n\t\t\t\t\tString.format(\"System property [%s] has a value of [%s] instead of [%s]\", key, actual, expected));\n\t\t\t}\n\t\t}\n\n\t\treturn ConditionEvaluationResult.enabled(\"@SystemProperty is not present\");\n\t}",
    "comment": "Intentionally in a subpackage in order to properly test deactivation\nof conditions based on patterns. In other words, we do not want this\ncondition declared in the same package as the\n{@link org.junit.jupiter.engine.extension.DisabledCondition}\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaHypothesisTestingExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaHypothesisTestingExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    Vector vec = Vectors.dense(0.1, 0.15, 0.2, 0.3, 0.25);\n\n    ChiSqTestResult goodnessOfFitTestResult = Statistics.chiSqTest(vec);\n    System.out.println(goodnessOfFitTestResult + \"\\n\");\n\n    Matrix mat = Matrices.dense(3, 2, new double[]{1.0, 3.0, 5.0, 2.0, 4.0, 6.0});\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\na vector composed of the frequencies of events\ncompute the goodness of fit. If a second vector to test against is not supplied\nas a parameter, the test runs against a uniform distribution.\nsummary of the test including the p-value, degrees of freedom, test statistic,\nthe method used, and the null hypothesis.\nCreate a contingency matrix ((1.0, 2.0), (3.0, 4.0), (5.0, 6.0))\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-aggregator/src/test/java/com/iluwatar/event/aggregator/KingsHandTest.java",
    "type": "method",
    "name": "testPassThrough",
    "code": "void testPassThrough() {\n    final var observer = mock(EventObserver.class);\n    final var kingsHand = new KingsHand();\n    kingsHand.registerObserver(observer, Event.STARK_SIGHTED);\n    kingsHand.registerObserver(observer, Event.WARSHIPS_APPROACHING);\n    kingsHand.registerObserver(observer, Event.TRAITOR_DETECTED);\n    kingsHand.registerObserver(observer, Event.WHITE_WALKERS_SIGHTED);\n\n    // The kings hand should not pass any events before he received one\n    verifyNoMoreInteractions(observer);\n\n    // Verify if each event is passed on to the observer, nothing less, nothing more.\n    Arrays.stream(Event.values())\n        .forEach(\n            event -> {\n              kingsHand.onEvent(event);\n              verify(observer, times(1)).onEvent(eq(event));\n              verifyNoMoreInteractions(observer);\n            });\n  }",
    "comment": "The {@link KingsHand} is both an {@link EventEmitter} as an {@link EventObserver} so verify if\nevery event received is passed up to its superior, in most cases {@link KingJoffrey} but now\njust a mocked observer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultDependencyManagementInjector.java",
    "type": "method",
    "name": "injectManagement",
    "code": "public void injectManagement(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\n        merger.mergeManagedDependencies(model);\n    }",
    "comment": "Handles injection of dependency management into the model.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/kinesis-asl/src/test/java/org/apache/spark/streaming/kinesis/JavaKinesisInputDStreamBuilderSuite.java",
    "type": "method",
    "name": "testJavaKinesisDStreamBuilder",
    "code": "public void testJavaKinesisDStreamBuilder() {\n    String streamName = \"a-very-nice-stream-name\";\n    String endpointUrl = \"https://kinesis.us-west-2.amazonaws.com\";\n    String region = \"us-west-2\";\n    KinesisInitialPosition initialPosition = new TrimHorizon();\n    String appName = \"a-very-nice-kinesis-app\";\n    Duration checkpointInterval = Seconds.apply(30);\n    StorageLevel storageLevel = StorageLevel.MEMORY_ONLY();\n\n    KinesisInputDStream<byte[]> kinesisDStream = KinesisInputDStream.builder()\n      .streamingContext(ssc)\n      .streamName(streamName)\n      .endpointUrl(endpointUrl)\n      .regionName(region)\n      .initialPosition(initialPosition)\n      .checkpointAppName(appName)\n      .checkpointInterval(checkpointInterval)\n      .storageLevel(storageLevel)\n      .build();\n    Assertions.assertEquals(streamName, kinesisDStream.streamName());\n    Assertions.assertEquals(endpointUrl, kinesisDStream.endpointUrl());\n    Assertions.assertEquals(region, kinesisDStream.regionName());\n    Assertions.assertEquals(initialPosition.getPosition(),\n        kinesisDStream.initialPosition().getPosition());\n    Assertions.assertEquals(appName, kinesisDStream.checkpointAppName());\n    Assertions.assertEquals(checkpointInterval, kinesisDStream.checkpointInterval());\n    Assertions.assertEquals(storageLevel, kinesisDStream._storageLevel());\n    ssc.stop();\n  }",
    "comment": "Basic test to ensure that the KinesisDStream.Builder interface is accessible from Java."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaPowerIterationClusteringExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf sparkConf = new SparkConf().setAppName(\"JavaPowerIterationClusteringExample\");\n    JavaSparkContext sc = new JavaSparkContext(sparkConf);\n\n    // $example on$\n    JavaRDD<Tuple3<Long, Long, Double>> similarities = sc.parallelize(Arrays.asList(\n      new Tuple3<>(0L, 1L, 0.9),\n      new Tuple3<>(1L, 2L, 0.9),\n      new Tuple3<>(2L, 3L, 0.9),\n      new Tuple3<>(3L, 4L, 0.1),\n      new Tuple3<>(4L, 5L, 0.9)));\n\n    PowerIterationClustering pic = new PowerIterationClustering()\n      .setK(2)\n      .setMaxIterations(10);\n    PowerIterationClusteringModel model = pic.run(similarities);\n\n    for (PowerIterationClustering.Assignment a: model.assignments().toJavaRDD().collect()) {\n      System.out.println(a.id() + \" -> \" + a.cluster());\n    }\n    // $example off$\n\n    sc.stop();\n  }",
    "comment": "Java example for graph clustering using power iteration clustering (PIC)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(ClassSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link ClassSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcKeyStorePassword",
    "code": "public String sslRpcKeyStorePassword() {\n    return conf.get(\"spark.ssl.rpc.keyStorePassword\", null);\n  }",
    "comment": "The password to the key-store file"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/Interpolator.java",
    "type": "method",
    "name": "chain",
    "code": "static UnaryOperator<String> chain(Collection<? extends UnaryOperator<String>> functions) {\n        return s -> {\n            for (UnaryOperator<String> function : functions) {\n                String v = function.apply(s);\n                if (v != null) {\n                    return v;\n                }\n            }\n            return null;\n        };\n    }",
    "comment": "Creates a composite function from a collection of functions.\n\n@param functions A collection of functions, each taking a String as input and returning a String.\n@return A function that applies each function in the collection in order until a non-null result is found.\nIf all functions return null, the composite function returns null.\n\n@throws NullPointerException if the input collection is null or contains null elements."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertSame",
    "code": "public static void assertSame(String message, Object expected, Object actual) {\n        if (expected == actual) {\n            return;\n        }\n        failNotSame(message, expected, actual);\n    }",
    "comment": "Asserts that two objects refer to the same object. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "setProperty",
    "code": "public Object setProperty(String key, String value) {\n        return this.put(key, value);\n    }",
    "comment": "Calls the map method put. Provided for parallelism with the getProperty method.\nEnforces use of strings for property keys and values. The value returned is the result of the map call to put.\n\n@param key the key to be placed into this property list.\n@param value the value corresponding to the key.\n@return the previous value of the specified key in this property list, or null if it did not have one."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/InvocationInterceptor.java",
    "type": "method",
    "name": "skip",
    "code": "default void skip() {\n\t\t\t// do nothing\n\t\t}",
    "comment": "Explicitly skip this invocation.\n\n<p>This allows to bypass the check that {@link #proceed()} must be\ncalled at least once. The default implementation does nothing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/model/DefaultModelInterpolatorTest.java",
    "type": "method",
    "name": "testDefaultBuildTimestampFormatShouldFormatTimeIn24HourFormat",
    "code": "public void testDefaultBuildTimestampFormatShouldFormatTimeIn24HourFormat() {\n        Calendar cal = Calendar.getInstance();\n        cal.setTimeZone(TimeZone.getTimeZone(\"Etc/UTC\"));\n        cal.set(Calendar.HOUR, 12);\n        cal.set(Calendar.AM_PM, Calendar.AM);\n\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 16);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.YEAR, 1976);\n        cal.set(Calendar.MONTH, Calendar.NOVEMBER);\n        cal.set(Calendar.DATE, 11);\n\n        Instant firstTestDate = Instant.ofEpochMilli(cal.getTime().getTime());\n\n        cal.set(Calendar.HOUR, 11);\n        cal.set(Calendar.AM_PM, Calendar.PM);\n\n        cal.set(Calendar.HOUR_OF_DAY, 23);\n\n        Instant secondTestDate = Instant.ofEpochMilli(cal.getTime().getTime());\n\n        DateTimeFormatter format = DateTimeFormatter.ofPattern(MavenBuildTimestamp.DEFAULT_BUILD_TIMESTAMP_FORMAT)\n                .withZone(ZoneId.of(\"UTC\"));\n\n        assertEquals(\"1976-11-11T00:16:00Z\", format.format(firstTestDate));\n        assertEquals(\"1976-11-11T23:16:00Z\", format.format(secondTestDate));\n    }",
    "comment": "just to make sure all the bases are covered...\njust to make sure all the bases are covered..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ColumnVectorUtils.java",
    "type": "method",
    "name": "toJavaIntArray",
    "code": "public static int[] toJavaIntArray(ColumnarArray array) {\n    for (int i = 0; i < array.numElements(); i++) {\n      if (array.isNullAt(i)) {\n        throw new RuntimeException(\"Cannot handle NULL values.\");\n      }\n    }\n    return array.toIntArray();\n  }",
    "comment": "Returns the array data as the java primitive array.\nFor example, an array of IntegerType will return an int[].\nThrows exceptions for unhandled schemas."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(double unexpected, Double actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Double) unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/client/TransportClient.java",
    "type": "method",
    "name": "send",
    "code": "public void send(ByteBuffer message) {\n    channel.writeAndFlush(new OneWayMessage(new NioManagedBuffer(message)));\n  }",
    "comment": "Sends an opaque message to the RpcHandler on the server-side. No reply is expected for the\nmessage, and no delivery guarantees are made.\n\n@param message The message to send."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterApi.java",
    "type": "method",
    "name": "create",
    "code": "static InterpreterApi create(@NonNull File modelFile, InterpreterApi.Options options) {\n    TfLiteRuntime runtime = (options == null ? null : options.getRuntime());\n    InterpreterFactoryApi factory = TensorFlowLite.getFactory(runtime);\n    return factory.create(modelFile, options);\n  }",
    "comment": "Constructs an {@link InterpreterApi} instance, using the specified model and options. The model\nwill be loaded from a file.\n\n@param modelFile A file containing a pre-trained TF Lite model.\n@param options A set of options for customizing interpreter behavior.\n@throws IllegalArgumentException if {@code modelFile} does not encode a valid TensorFlow Lite\nmodel."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Request.java",
    "type": "method",
    "name": "filterWith",
    "code": "public Request filterWith(Description desiredDescription) {\n        return filterWith(Filter.matchMethodDescription(desiredDescription));\n    }",
    "comment": "Returns a Request that only runs tests whose {@link Description}\nmatches the given description.\n\n<p>Returns an empty {@code Request} if {@code desiredDescription} is not a single test and filters all but the single\ntest if {@code desiredDescription} is a single test.</p>\n\n@param desiredDescription {@code Description} of those tests that should be run\n@return the filtered Request"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProjectBuilderRequest.java",
    "type": "method",
    "name": "build",
    "code": "static ProjectBuilderRequest build(@Nonnull Session session, @Nonnull Source source) {\n        return builder()\n                .session(requireNonNull(session, \"session cannot be null\"))\n                .source(requireNonNull(source, \"source cannot be null\"))\n                .build();\n    }",
    "comment": "Creates a new ProjectBuilderRequest with the specified session and source.\n\n@param session the Maven session\n@param source the source of the project to build\n@return a new ProjectBuilderRequest\n@throws NullPointerException if session or source is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertTimeoutPreemptivelyAssertionsTests.java",
    "type": "method",
    "name": "assertStackTraceContains",
    "code": "private static void assertStackTraceContains(StackTraceElement[] stackTrace, String className, String methodName) {\n\t\tassertThat(stackTrace).anySatisfy(element -> {\n\t\t\tassertThat(element.getClassName()).endsWith(className);\n\t\t\tassertThat(element.getMethodName()).isEqualTo(methodName);\n\t\t});\n\t}",
    "comment": "Assert the given stack trace elements contain an element with the given class name and method name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/Nested.java",
    "type": "method",
    "name": "setNestedStringColumn",
    "code": "public void setNestedStringColumn(java.lang.String value) {\n    this.nested_string_column = value;\n  }",
    "comment": "Sets the value of the 'nested_string_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClassSource.java",
    "type": "method",
    "name": "from",
    "code": "public static ClassSource from(Class<?> javaClass, FilePosition filePosition) {\n\t\treturn new ClassSource(javaClass, filePosition);\n\t}",
    "comment": "Create a new {@code ClassSource} using the supplied {@linkplain Class class}\n\n@param javaClass the Java class; must not be {@code null}\n@param filePosition the position in the Java source file; may be {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assumptions.java",
    "type": "method",
    "name": "assumingThat",
    "code": "public static void assumingThat(BooleanSupplier assumptionSupplier, Executable executable) {\n\t\tassumingThat(assumptionSupplier.getAsBoolean(), executable);\n\t}",
    "comment": "Execute the supplied {@link Executable}, but only if the supplied\nassumption is valid.\n\n<p>Unlike the other assumption methods, this method will not abort the test.\nIf the assumption is invalid, this method does nothing. If the assumption is\nvalid and the {@code executable} throws an exception, it will be treated like\na regular test <em>failure</em>. That exception will be rethrown <em>as is</em>\nbut {@link ExceptionUtils#throwAsUncheckedException masked} as an unchecked\nexception.\n\n@param assumptionSupplier the supplier of the assumption to validate\n@param executable the block of code to execute if the assumption is valid\n@see #assumingThat(boolean, Executable)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/spi/PropertyContributorsHolder.java",
    "type": "method",
    "name": "PropertyContributorsHolder",
    "code": "public PropertyContributorsHolder(Map<String, PropertyContributor> propertyContributors) {\n        this.propertyContributors = propertyContributors;\n    }",
    "comment": "Hack: to circumvent sisu/plexus/di stuff."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/throttling/src/main/java/com/iluwatar/throttling/Bartender.java",
    "type": "method",
    "name": "Bartender",
    "code": "public Bartender(Throttler timer, CallsCount callsCount) {\n    this.callsCount = callsCount;\n    timer.start();\n  }",
    "comment": "Bartender is a service which accepts a BarCustomer (tenant) and throttles the resource based on\nthe time given to the tenant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/repository/DefaultRepositoryRequest.java",
    "type": "method",
    "name": "DefaultRepositoryRequest",
    "code": "public DefaultRepositoryRequest() {\n        // enables no-arg constructor\n    }",
    "comment": "Creates an empty repository request."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertThrowsExactly",
    "code": "public static <T extends Throwable> T assertThrowsExactly(Class<T> expectedType, Executable executable) {\n\t\treturn AssertThrowsExactly.assertThrowsExactly(expectedType, executable);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code executable} throws\nan exception of exactly the {@code expectedType} and return the exception.\n\n<p>If no exception is thrown, or if an exception of a different type is\nthrown, this method will fail.\n\n<p>If you do not want to perform additional checks on the exception instance,\nignore the return value.\n\n@since 5.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcTrustStorePassword",
    "code": "public String sslRpcTrustStorePassword() {\n    return conf.get(\"spark.ssl.rpc.trustStorePassword\", null);\n  }",
    "comment": "The password to the trust-store file"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/MethodSorters.java",
    "type": "method",
    "name": "MethodSorters",
    "code": "private MethodSorters(Comparator<Method> comparator) {\n        this.comparator = comparator;\n    }",
    "comment": "Sorts the test methods in a deterministic, but not predictable, order"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/lockable-object/src/main/java/com/iluwatar/lockableobject/domain/Feind.java",
    "type": "method",
    "name": "fightForTheSword",
    "code": "private void fightForTheSword(Creature reacher, @NonNull Creature holder, Lockable sword) {\n    LOGGER.info(\"A duel between {} and {} has been started!\", reacher.getName(), holder.getName());\n    boolean randBool;\n    while (this.target.isLocked() && reacher.isAlive() && holder.isAlive()) {\n      randBool = random.nextBoolean();\n      if (randBool) {\n        reacher.attack(holder);\n      } else {\n        holder.attack(reacher);\n      }\n    }\n    if (reacher.isAlive()) {\n      if (!reacher.acquire(sword)) {\n        fightForTheSword(reacher, sword.getLocker(), sword);\n      } else {\n        LOGGER.info(\"{} has acquired the sword!\", reacher.getName());\n      }\n    }\n  }",
    "comment": "Keeps on fighting until the Lockable is possessed.\n\n@param reacher as the source creature.\n@param holder as the foe.\n@param sword as the Lockable to possess."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionProfileActivator.java",
    "type": "method",
    "name": "property",
    "code": "String property(ProfileActivationContext context, String name) {\n        String value = doGetProperty(context, name);\n        return interpolator.interpolate(value, s -> doGetProperty(context, s));\n    }",
    "comment": "Retrieves the value of a property from the project context.\nSpecial function used to support the <code>${property}</code> syntax.\n\nThe profile activation is done twice: once on the file model (so the model\nwhich has just been read from the file) and once while computing the effective\nmodel (so the model which will be used to build the project). We do need\nthose two activations to be consistent, so we need to restrict access to\nproperties that cannot change between file and effective model.\n\n@param name The property name\n@return The value of the property, or null if not found\n@throws IllegalArgumentException if the number of arguments is not exactly one"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "setSparkHome",
    "code": "public SparkLauncher setSparkHome(String sparkHome) {\n    checkNotNull(sparkHome, \"sparkHome\");\n    builder.childEnv.put(ENV_SPARK_HOME, sparkHome);\n    return this;\n  }",
    "comment": "Set a custom Spark installation location for the application.\n\n@param sparkHome Path to the Spark installation to use.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/runner/BaseTestRunner.java",
    "type": "method",
    "name": "elapsedTimeAsString",
    "code": "public String elapsedTimeAsString(long runTime) {\n        return NumberFormat.getInstance().format((double) runTime / 1000);\n    }",
    "comment": "Returns the formatted string of the elapsed time."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(UniqueIdSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link UniqueIdSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/Trigger.java",
    "type": "method",
    "name": "ProcessingTime",
    "code": "public static Trigger ProcessingTime(String interval) {\n      return ProcessingTimeTrigger.apply(interval);\n  }",
    "comment": "A trigger policy that runs a query periodically based on an interval in processing time.\nIf `interval` is effectively 0, the query will run as fast as possible.\n\n{{{\ndf.writeStream.trigger(Trigger.ProcessingTime(\"10 seconds\"))\n}}}\n@since 2.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "getSupportArtifactPath",
    "code": "public String getSupportArtifactPath(String gid, String aid, String version, String ext, String classifier) {\n        if (classifier != null && classifier.isEmpty()) {\n            classifier = null;\n        }\n        if (\"maven-plugin\".equals(ext)) {\n            ext = \"jar\";\n        } else if (\"coreit-artifact\".equals(ext)) {\n            ext = \"jar\";\n            classifier = \"it\";\n        } else if (\"test-jar\".equals(ext)) {\n            ext = \"jar\";\n            classifier = \"tests\";\n        }\n\n        String gav;\n        if (classifier != null) {\n            gav = gid + \":\" + aid + \":\" + ext + \":\" + classifier + \":\" + version;\n        } else {\n            gav = gid + \":\" + aid + \":\" + ext + \":\" + version;\n        }\n        return outerLocalRepository\n                .resolve(executorTool.artifactPath(\n                        executorHelper.executorRequest().argument(\"-Dmaven.repo.local=\" + outerLocalRepository),\n                        gav,\n                        null))\n                .toString();\n    }",
    "comment": "Returns the absolute path to the artifact denoted by groupId, artifactId, version, extension and classifier.\n\n@param gid        The groupId, must not be null.\n@param aid        The artifactId, must not be null.\n@param version    The version, must not be null.\n@param ext        The extension, must not be null.\n@param classifier The classifier, may be null to be omitted.\n@return the absolute path to the artifact denoted by groupId, artifactId, version, extension and classifier,\nnever null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Request.java",
    "type": "method",
    "name": "sortWith",
    "code": "public Request sortWith(Comparator<Description> comparator) {\n        return new SortingRequest(this, comparator);\n    }",
    "comment": "Returns a Request whose Tests can be run in a certain order, defined by\n<code>comparator</code>\n<p>\nFor example, here is code to run a test suite in alphabetical order:\n<pre>\nprivate static Comparator&lt;Description&gt; forward() {\nreturn new Comparator&lt;Description&gt;() {\n};\n}\n\npublic static main() {\nnew JUnitCore().run(Request.aClass(AllTests.class).sortWith(forward()));\n}\n</pre>\n\n@param comparator definition of the order of the tests in this Request\n@return a Request with ordered Tests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/SuiteTest.java",
    "type": "method",
    "name": "testNotPublicTestCase",
    "code": "public void testNotPublicTestCase() {\n        TestSuite suite = new TestSuite(NotPublicTestCase.class);\n        assertEquals(2, suite.countTestCases());\n    }",
    "comment": "1 public test case + 1 warning for the non-public test case"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3642DynamicResourcesTest.java",
    "type": "method",
    "name": "MavenITmng3642DynamicResourcesTest",
    "code": "public MavenITmng3642DynamicResourcesTest() {\n        super(\"(2.0.9,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3642\">MNG-3642</a>.\n\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/AnnotationSupport.java",
    "type": "method",
    "name": "isAnnotated",
    "code": "public static boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn AnnotationUtils.isAnnotated(element, annotationType);\n\t}",
    "comment": "Determine if an annotation of {@code annotationType} is either\n<em>present</em> or <em>meta-present</em> on the supplied\n{@code element}.\n\n<p><strong>Note:</strong> This method does not find repeatable annotations.\nTo check for repeatable annotations, use {@link #findRepeatableAnnotations(AnnotatedElement, Class)}\nand verify that the returned list is not empty.\n\n@param element the element on which to search for the annotation; may be\n{@code null}\n@param annotationType the annotation type to search for; never {@code null}\n@return {@code true} if the annotation is present or meta-present\n@see #isAnnotated(Optional, Class)\n@see #findAnnotation(AnnotatedElement, Class)\n@see #findRepeatableAnnotations(AnnotatedElement, Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/manipulation/ReverseAlphanumericSorter.java",
    "type": "method",
    "name": "create",
    "code": "public Ordering create(Ordering.Context context) {\n        return new Sorter(reverseOrder(Comparators.alphanumeric()));\n    }",
    "comment": "A sorter that orders tests reverse alphanumerically by test name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/bully/BullyMessageManager.java",
    "type": "method",
    "name": "sendHeartbeatMessage",
    "code": "public boolean sendHeartbeatMessage(int leaderId) {\n    var leaderInstance = instanceMap.get(leaderId);\n    return leaderInstance.isAlive();\n  }",
    "comment": "Send heartbeat message to current leader instance to check the health.\n\n@param leaderId leaderID\n@return {@code true} if the leader is alive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/SpeechActivity.java",
    "type": "method",
    "name": "onCreate",
    "code": "protected void onCreate(Bundle savedInstanceState) {\n    // Set up the UI.\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_speech);\n    quitButton = (Button) findViewById(R.id.quit);\n    quitButton.setOnClickListener(\n        new View.OnClickListener() {\n        });\n    labelsListView = (ListView) findViewById(R.id.list_view);\n\n    // Load the labels for the model, but only display those that don't start\n    // with an underscore.\n    String actualFilename = LABEL_FILENAME.split(\"file:///android_asset/\")[1];\n    Log.i(LOG_TAG, \"Reading labels from: \" + actualFilename);\n    BufferedReader br = null;\n    try {\n      br = new BufferedReader(new InputStreamReader(getAssets().open(actualFilename)));\n      String line;\n      while ((line = br.readLine()) != null) {\n        labels.add(line);\n        if (line.charAt(0) != '_') {\n          displayedLabels.add(line.substring(0, 1).toUpperCase() + line.substring(1));\n        }\n      }\n      br.close();\n    } catch (IOException e) {\n      throw new RuntimeException(\"Problem reading label file!\", e);\n    }\n\n    // Build a list view based on these labels.\n    ArrayAdapter<String> arrayAdapter =\n        new ArrayAdapter<String>(this, R.layout.list_text_item, displayedLabels);\n    labelsListView.setAdapter(arrayAdapter);\n\n    // Set up an object to smooth recognition results to increase accuracy.\n    recognizeCommands =\n        new RecognizeCommands(\n            labels,\n            AVERAGE_WINDOW_DURATION_MS,\n            DETECTION_THRESHOLD,\n            SUPPRESSION_MS,\n            MINIMUM_COUNT,\n            MINIMUM_TIME_BETWEEN_SAMPLES_MS);\n\n    // Load the TensorFlow model.\n    inferenceInterface = new TensorFlowInferenceInterface(getAssets(), MODEL_FILENAME);\n\n    // Start the recording and recognition threads.\n    requestMicrophonePermission();\n    startRecording();\n    startRecognition();\n  }",
    "comment": "An activity that listens for audio and then uses a TensorFlow model to detect particular classes,\nby default a small set of action words."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/plugin/MojoException.java",
    "type": "method",
    "name": "MojoException",
    "code": "public MojoException(String message, Throwable cause) {\n        super(message, cause);\n    }",
    "comment": "Constructs a new {@code MojoException} wrapping an underlying {@code Throwable}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "appendQuoted",
    "code": "static void appendQuoted(StringBuilder sb, String str) {\n    sb.append('\"');\n    sb.append(str);\n    sb.append('\"');\n  }",
    "comment": "A simplified and more performant version of `sb.append(escapeJson(str))`. It is used when we\nknow `str` doesn't contain any special character that needs escaping."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/TestExecutionSummary.java",
    "type": "method",
    "name": "printFailuresTo",
    "code": "default void printFailuresTo(PrintWriter writer, int maxStackTraceLines) {\n\t\tprintFailuresTo(writer);\n\t}",
    "comment": "Print failed containers and tests, including sources and exception\nmessages, to the supplied {@link PrintWriter}.\n\n<p>The maximum number of lines to print for exception stack traces (if any)\ncan be specified via the {@code maxStackTraceLines} argument.\n\n<p>By default, this method delegates to {@link #printFailuresTo(PrintWriter)},\neffectively ignoring the {@code maxStackTraceLines} argument. Concrete\nimplementations of this interface should therefore override this default\nmethod in order to honor the {@code maxStackTraceLines} argument.\n\n@param writer the {@code PrintWriter} to which to print; never {@code null}\n@param maxStackTraceLines the maximum number of lines to print for exception\nstack traces; must be a positive value\n@since 1.6\n@see #printTo(PrintWriter)\n@see #printFailuresTo(PrintWriter)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(long unexpected, long actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "discover",
    "code": "public EngineDiscoveryResults discover() {\n\t\t\tLauncherDiscoveryRequest request = this.requestBuilder.build();\n\t\t\treturn EngineTestKit.discover(this.testEngine, request);\n\t\t}",
    "comment": "Discover tests for the configured {@link TestEngine},\n{@linkplain DiscoverySelector discovery selectors},\n{@linkplain DiscoveryFilter discovery filters}, and\n<em>configuration parameters</em>.\n\n@return the recorded {@code EngineDiscoveryResults}\n@since 1.13\n@see #selectors(DiscoverySelector...)\n@see #filters(Filter...)\n@see #configurationParameter(String, String)\n@see #configurationParameters(Map)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/PrecedenceCoreExtensionSelector.java",
    "type": "method",
    "name": "selectCoreExtensions",
    "code": "protected List<CoreExtension> selectCoreExtensions(C context, List<CoreExtensions> configuredCoreExtensions) {\n        context.logger.debug(\"Configured core extensions (in precedence order):\");\n        for (CoreExtensions source : configuredCoreExtensions) {\n            context.logger.debug(\"* Source file: \" + source.source());\n            for (CoreExtension extension : source.coreExtensions()) {\n                context.logger.debug(\"  - \" + extension.getId() + \" -> \" + formatLocation(extension.getLocation(\"\")));\n            }\n        }\n\n        LinkedHashMap<String, CoreExtension> selectedExtensions = new LinkedHashMap<>();\n        List<String> conflicts = new ArrayList<>();\n        for (CoreExtensions coreExtensions : configuredCoreExtensions) {\n            for (CoreExtension coreExtension : coreExtensions.coreExtensions()) {\n                String key = coreExtension.getGroupId() + \":\" + coreExtension.getArtifactId();\n                CoreExtension conflict = selectedExtensions.putIfAbsent(key, coreExtension);\n                if (conflict != null) {\n                    conflicts.add(String.format(\n                            \"Conflicting extension %s: %s vs %s\",\n                            key,\n                            formatLocation(conflict.getLocation(\"\")),\n                            formatLocation(coreExtension.getLocation(\"\"))));\n                }\n            }\n        }\n        if (!conflicts.isEmpty()) {\n            context.logger.warn(\"Found \" + conflicts.size() + \" extension conflict(s):\");\n            for (String conflict : conflicts) {\n                context.logger.warn(\"* \" + conflict);\n            }\n            context.logger.warn(\"\");\n            context.logger.warn(\n                    \"Order of core extensions precedence is project > user > installation. Selected extensions are:\");\n            for (CoreExtension extension : selectedExtensions.values()) {\n                context.logger.warn(\n                        \"* \" + extension.getId() + \" configured in \" + formatLocation(extension.getLocation(\"\")));\n            }\n        }\n\n        context.logger.debug(\"Selected core extensions (in loading order):\");\n        for (CoreExtension source : selectedExtensions.values()) {\n            context.logger.debug(\"* \" + source.getId() + \": \" + formatLocation(source.getLocation(\"\")));\n        }\n        return List.copyOf(selectedExtensions.values());\n    }",
    "comment": "Selects extensions to load discovered from various sources by precedence (\"first wins\"), as\n{@link InvokerRequest#coreExtensions()} is in precedence order. Also reports conflicts, if any.\nFinally, at DEBUG level reports configured vs selected extensions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/properties/internal/SystemProperties.java",
    "type": "method",
    "name": "getSystemProperties",
    "code": "public static Properties getSystemProperties() {\n        return copyProperties(System.getProperties());\n    }",
    "comment": "Returns a copy of {@link System#getProperties()} in a thread-safe manner.\n\n@return {@link System#getProperties()} obtained in a thread-safe manner."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/utils/CLIReportingUtils.java",
    "type": "method",
    "name": "showVersion",
    "code": "public static String showVersion(String commandLine, String terminal) {\n        final String ls = System.lineSeparator();\n        Properties properties = getBuildProperties();\n        StringBuilder version = new StringBuilder(256);\n        version.append(MessageUtils.builder().strong(createMavenVersionString(properties)))\n                .append(ls);\n        version.append(reduce(properties.getProperty(\"distributionShortName\") + \" home: \"\n                        + System.getProperty(\"maven.home\", \"<unknown Maven \" + \"home>\")))\n                .append(ls);\n        version.append(\"Java version: \")\n                .append(System.getProperty(\"java.version\", \"<unknown Java version>\"))\n                .append(\", vendor: \")\n                .append(System.getProperty(\"java.vendor\", \"<unknown vendor>\"))\n                .append(\", runtime: \")\n                .append(System.getProperty(\"java.home\", \"<unknown runtime>\"))\n                .append(ls);\n        version.append(\"Default locale: \")\n                .append(Locale.getDefault())\n                .append(\", platform encoding: \")\n                .append(System.getProperty(\"file.encoding\", \"<unknown encoding>\"))\n                .append(ls);\n        version.append(\"OS name: \\\"\")\n                .append(Os.OS_NAME)\n                .append(\"\\\", version: \\\"\")\n                .append(Os.OS_VERSION)\n                .append(\"\\\", arch: \\\"\")\n                .append(Os.OS_ARCH)\n                .append(\"\\\", family: \\\"\")\n                .append(Os.OS_FAMILY)\n                .append('\\\"');\n        if (commandLine != null) {\n            version.append(ls).append(\"Command line: \").append(commandLine);\n        }\n        if (terminal != null) {\n            version.append(ls).append(\"Terminal: \").append(terminal);\n        }\n        return version.toString();\n    }",
    "comment": "Add process information using modern Java API"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ModelBuilderException.java",
    "type": "method",
    "name": "getProblemCollector",
    "code": "public ProblemCollector<ModelProblem> getProblemCollector() {\n        if (result == null) {\n            return ProblemCollector.empty();\n        }\n        return result.getProblemCollector();\n    }",
    "comment": "Gets the problems that caused this exception.\n\n@return The problems that caused this exception, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/curiously-recurring-template-pattern/src/test/java/crtp/FightTest.java",
    "type": "method",
    "name": "testFighterCanFightOnlyAgainstSameWeightOpponents",
    "code": "void testFighterCanFightOnlyAgainstSameWeightOpponents() {\n    MmaBantamweightFighter fighter =\n        new MmaBantamweightFighter(\"Joe\", \"Johnson\", \"The Geek\", \"Muay Thai\");\n    List<MmaFighter<?>> opponents = getOpponents();\n    List<MmaFighter<?>> challenged = new ArrayList<>();\n\n    opponents.forEach(\n        challenger -> {\n          try {\n            ((MmaBantamweightFighter) challenger).fight(fighter);\n            challenged.add(challenger);\n          } catch (ClassCastException e) {\n            LOGGER.error(e.getMessage());\n          }\n        });\n\n    assertFalse(challenged.isEmpty());\n    assertTrue(challenged.stream().allMatch(c -> c instanceof MmaBantamweightFighter));\n  }",
    "comment": "A fighter has signed a contract with a promotion, and he will face some other fighters. A list\nof opponents is ready but for some reason not all of them belong to the same weight class.\nLet's ensure that the fighter will only face opponents in the same weight class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/test/java/org/apache/maven/model/pom/PomMemoryAnalyzer.java",
    "type": "method",
    "name": "printAnalysis",
    "code": "public void printAnalysis() {\n        System.out.printf(\"Analyzed %d POMs%n%n\", totalPoms);\n\n        List<PathAnalysis> allPaths = getPathAnalysisSorted();\n\n        Map<String, List<PathAnalysis>> groupedPaths = new HashMap<>();\n        Map<String, Map<String, Long>> groupValueFrequencies = new HashMap<>();\n\n        for (PathAnalysis path : allPaths) {\n            String finalComponent = path.path.substring(path.path.lastIndexOf('/') + 1);\n\n            groupedPaths.computeIfAbsent(finalComponent, k -> new ArrayList<>()).add(path);\n\n            Map<String, Long> groupFreqs = groupValueFrequencies.computeIfAbsent(finalComponent, k -> new HashMap<>());\n            for (ValueFrequency vf : path.mostFrequentValues) {\n                groupFreqs.merge(vf.value, vf.frequency, Long::sum);\n            }\n        }\n\n        List<GroupAnalysis> sortedGroups = groupedPaths.entrySet().stream()\n                .map(entry -> {\n                    String groupName = entry.getKey();\n                    List<PathAnalysis> paths = entry.getValue();\n                    Map<String, Long> valueFreqs = groupValueFrequencies.get(groupName);\n\n                    long totalSavings =\n                            paths.stream().mapToLong(p -> p.potentialSavings).sum();\n                    long totalMemory =\n                            paths.stream().mapToLong(p -> p.totalMemory).sum();\n                    long totalUnique = valueFreqs.size();\n                    long totalOccurrences =\n                            valueFreqs.values().stream().mapToLong(l -> l).sum();\n\n                    List<ValueFrequency> topValues = valueFreqs.entrySet().stream()\n                            .map(e -> new ValueFrequency(e.getKey(), e.getValue()))\n                            .sorted((a, b) -> Long.compare(b.frequency, a.frequency))\n                            .limit(5)\n                            .collect(Collectors.toList());\n\n                    return new GroupAnalysis(\n                            groupName, paths, totalUnique, totalOccurrences, totalMemory, totalSavings, topValues);\n                })\n                .sorted((a, b) -> Long.compare(b.totalSavings, a.totalSavings))\n                .toList();\n\n        for (GroupAnalysis group : sortedGroups) {\n            System.out.printf(\"%nPaths ending with '%s':%n\", group.name);\n            System.out.printf(\"Total potential savings: %dKB%n\", group.totalSavings / 1024);\n            System.out.printf(\"Total memory: %dKB%n\", group.totalMemory / 1024);\n            System.out.printf(\"Total unique values: %d%n\", group.totalUnique);\n            System.out.printf(\"Total occurrences: %d%n\", group.totalOccurrences);\n            System.out.printf(\"Duplication ratio: %.2f%n\", (double) group.totalOccurrences / group.totalUnique);\n\n            System.out.println(\"\\nMost frequent values across all paths:\");\n            for (ValueFrequency v : group.mostFrequentValues) {\n                System.out.printf(\"  %-70s %d times%n\", v.value, v.frequency);\n            }\n\n            System.out.println(\"\\nIndividual paths:\");\n            System.out.println(\"----------------------------------------\");\n            for (PathAnalysis path : group.paths.stream()\n                    .sorted((a, b) -> Long.compare(b.potentialSavings, a.potentialSavings))\n                    .toList()) {\n                System.out.printf(\n                        \"%-90s %6dKB %6dKB%n\", path.path, path.totalMemory / 1024, path.potentialSavings / 1024);\n            }\n            System.out.println();\n        }\n    }",
    "comment": "First, get all paths\nCreate groups based on the final path component\nAdd path to its group\nAggregate value frequencies for the group\nCreate final group analyses and sort them by total savings\nPrint each group"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/DisableOnDebug.java",
    "type": "method",
    "name": "isDebugging",
    "code": "private static boolean isDebugging(List<String> arguments) {\n        for (final String argument : arguments) {\n            if (\"-Xdebug\".equals(argument) || argument.startsWith(\"-agentlib:jdwp\")) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "comment": "Parses arguments passed to the runtime environment for debug flags\n<p>\nOptions specified in:\n<ul>\n<li>\n<a href=\"http://docs.oracle.com/javase/6/docs/technotes/guides/jpda/conninv.html#Invocation\"\n>javase-6</a></li>\n<li><a href=\"http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html#Invocation\"\n>javase-7</a></li>\n<li><a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/jpda/conninv.html#Invocation\"\n>javase-8</a></li>\n\n\n@param arguments\nthe arguments passed to the runtime environment, usually this\nwill be {@link RuntimeMXBean#getInputArguments()}\n@return true if the current JVM was started in debug mode, false\notherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(float[] expected, float[] actual) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} float arrays are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/testkit/engine/ExecutionsIntegrationTests.java",
    "type": "method",
    "name": "executionsFromFailedTestEvents",
    "code": "void executionsFromFailedTestEvents() {\n\t\tvar testEvents = getTestEvents();\n\n\t\tassertThat(testEvents.executions().failed().count()).isEqualTo(1);\n\t\tassertThat(testEvents.failed().executions().count()).isEqualTo(0);\n\t}",
    "comment": "We expect 1 if the executions are created BEFORE filtering out \"started\" events.\nWe expect 0 if the executions are created AFTER filtering out \"started\" events."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ResourceLock.java",
    "type": "method",
    "name": "isCompatible",
    "code": "default boolean isCompatible(ResourceLock other) {\n\n\t\tList<ExclusiveResource> ownResources = this.getResources();\n\t\tList<ExclusiveResource> otherResources = other.getResources();\n\n\t\tif (ownResources.isEmpty() || otherResources.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Whenever there's a READ_WRITE lock, it's incompatible with any other lock\n\t\t// because we guarantee that all children will have exclusive access to the\n\t\t// resource in question. In practice, whenever a READ_WRITE lock is present,\n\t\t// NodeTreeWalker will force all children to run in the same thread so that\n\t\t// it should never attempt to steal work from another thread, and we shouldn't\n\t\t// actually reach this point.\n\t\t// The global read lock (which is always on direct children of the engine node)\n\t\t// needs special treatment so that it is compatible with the first write lock\n\t\t// (which may be on a test method).\n\t\tboolean isGlobalReadLock = ownResources.size() == 1\n\t\t\t\t&& ExclusiveResource.GLOBAL_READ.equals(ownResources.get(0));\n\t\tif ((!isGlobalReadLock && other.isExclusive()) || this.isExclusive()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tOptional<ExclusiveResource> potentiallyDeadlockCausingAdditionalResource = otherResources.stream() //\n\t\t\t\t.filter(resource -> !ownResources.contains(resource)) //\n\t\t\t\t.findFirst() //\n\t\t\t\t.filter(resource -> ExclusiveResource.COMPARATOR.compare(resource,\n\t\t\t\t\townResources.get(ownResources.size() - 1)) < 0);\n\n\t\treturn !(potentiallyDeadlockCausingAdditionalResource.isPresent());\n\t}",
    "comment": "{@return whether the given lock is compatible with this lock}\n@param other the other lock to check for compatibility"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setChild",
    "code": "public void setChild(int ordinal, ConstantColumnVector value) {\n    childData[ordinal] = value;\n  }",
    "comment": "Sets the child `ConstantColumnVector` `value` at the given ordinal for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(expecteds, actuals);\n    }",
    "comment": "Asserts that two object arrays are equal. If they are not, an\n{@link AssertionError} is thrown. If <code>expected</code> and\n<code>actual</code> are <code>null</code>, they are considered\nequal.\n\n@param expecteds Object array or array of arrays (multi-dimensional array) with\nexpected values\n@param actuals Object array or array of arrays (multi-dimensional array) with\nactual values\n@deprecated use assertArrayEquals"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestTemplateMethod.java",
    "type": "method",
    "name": "IsTestTemplateMethod",
    "code": "public IsTestTemplateMethod(DiscoveryIssueReporter issueReporter) {\n\t\tsuper(TestTemplate.class, IsTestableMethod::hasVoidReturnType, issueReporter);\n\t}",
    "comment": "Test if a method is a JUnit Jupiter {@link TestTemplate @TestTemplate} method.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(int[] expected, int[] actual, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} int arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertSameAssertionsTests.java",
    "type": "method",
    "name": "assertSameWithTwoNulls",
    "code": "void assertSameWithTwoNulls() {\n\t\tassertSame(null, null);\n\t\tassertSame(null, null, () -> \"should not fail\");\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "prefix",
    "code": "public Builder prefix(String prefix) {\n            this.prefix = prefix;\n            return this;\n        }",
    "comment": "Sets the namespace prefix of the XML node.\n\n@param prefix the namespace prefix of the XML node\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "forRegistry",
    "code": "public static Builder forRegistry(MetricRegistry registry) {\n        return new Builder(registry);\n    }",
    "comment": "Returns a new {@link Builder} for {@link GangliaReporter}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExternalShuffleBlockResolver.java",
    "type": "method",
    "name": "deleteExecutorDirs",
    "code": "private void deleteExecutorDirs(String[] dirs) {\n    for (String localDir : dirs) {\n      try {\n        JavaUtils.deleteRecursively(new File(localDir));\n        logger.debug(\"Successfully cleaned up directory: {}\", localDir);\n      } catch (Exception e) {\n        logger.error(\"Failed to delete directory: {}\", e,\n          MDC.of(LogKeys.PATH$.MODULE$, localDir));\n      }\n    }\n  }",
    "comment": "Synchronously deletes each directory one at a time.\nShould be executed in its own thread, as this may take a long time."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/MyDoubleSum.java",
    "type": "method",
    "name": "initialize",
    "code": "@Override public void initialize(MutableAggregationBuffer buffer) {\n    buffer.update(0, null);\n  }",
    "comment": "The initial value of the sum is null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(short expected, Short actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals((Short) expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/ImageUtils.java",
    "type": "method",
    "name": "saveBitmap",
    "code": "public static void saveBitmap(final Bitmap bitmap) {\n    saveBitmap(bitmap, \"preview.png\");\n  }",
    "comment": "Saves a Bitmap object to disk for analysis.\n\n@param bitmap The bitmap to save."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setNotNull",
    "code": "public void setNotNull() {\n    nullData = (byte) 0;\n  }",
    "comment": "Sets all rows as not `null`"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/Promise.java",
    "type": "method",
    "name": "fulfill",
    "code": "public void fulfill(T value) {\n    super.fulfill(value);\n    postFulfillment();\n  }",
    "comment": "Fulfills the promise with the provided value.\n\n@param value the fulfilled value that can be accessed using {@link #get()}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueIdFormat.java",
    "type": "method",
    "name": "format",
    "code": "String format(UniqueId uniqueId) {\n\t\t// @formatter:off\n\t\treturn uniqueId.getSegments().stream()\n\t\t\t.map(this::describe)\n\t\t\t.collect(joining(String.valueOf(this.segmentDelimiter)));\n\t\t// @formatter:on\n\t}",
    "comment": "Format and return the string representation of the supplied {@code UniqueId}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerSession.java",
    "type": "method",
    "name": "async",
    "code": "public Options async(boolean value) {\n      async = value;\n      return this;\n    }",
    "comment": "Controls how operations dispatched are actually executed.\n\n<p>When set to true, each operation are executed asynchronously (in which case some\noperations might return \"non-ready\" outputs). When set to false, all operations are executed\nsynchronously.\n\n<p>Synchronous execution is used by default.\n\n@param value true for asynchronous execution, false for synchronous."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assume.java",
    "type": "method",
    "name": "assumeNotNull",
    "code": "public static void assumeNotNull(Object... objects) {\n        assumeThat(objects, notNullValue());\n        assumeThat(asList(objects), everyItem(notNullValue()));\n    }",
    "comment": "If called with a {@code null} array or one or more {@code null} elements in {@code objects},\nthe test will halt and be ignored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassLoaderUtils.java",
    "type": "method",
    "name": "getClassLoader",
    "code": "public static ClassLoader getClassLoader(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tClassLoader classLoader = clazz.getClassLoader();\n\t\treturn (classLoader != null) ? classLoader : getDefaultClassLoader();\n\t}",
    "comment": "Get the {@link ClassLoader} for the supplied {@link Class}, falling back\nto the {@link #getDefaultClassLoader() default class loader} if the class\nloader for the supplied class is {@code null}.\n@param clazz the class for which to retrieve the class loader; never {@code null}\n@since 1.10"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/facade/src/test/java/com/iluwatar/facade/DwarvenGoldmineFacadeTest.java",
    "type": "method",
    "name": "testFullWorkDay",
    "code": "void testFullWorkDay() {\n    final var goldMine = new DwarvenGoldmineFacade();\n    goldMine.startNewDay();\n\n    // On the start of a day, all workers should wake up ...\n    assertTrue(appender.logContains(\"Dwarf gold digger wakes up.\"));\n    assertTrue(appender.logContains(\"Dwarf cart operator wakes up.\"));\n    assertTrue(appender.logContains(\"Dwarven tunnel digger wakes up.\"));\n\n    // ... and go to the mine\n    assertTrue(appender.logContains(\"Dwarf gold digger goes to the mine.\"));\n    assertTrue(appender.logContains(\"Dwarf cart operator goes to the mine.\"));\n    assertTrue(appender.logContains(\"Dwarven tunnel digger goes to the mine.\"));\n\n    // No other actions were invoked, so the workers shouldn't have done (printed) anything else\n    assertEquals(6, appender.getLogSize());\n\n    // Now do some actual work, start digging gold!\n    goldMine.digOutGold();\n\n    // Since we gave the dig command, every worker should be doing its job ...\n    assertTrue(appender.logContains(\"Dwarf gold digger digs for gold.\"));\n    assertTrue(appender.logContains(\"Dwarf cart operator moves gold chunks out of the mine.\"));\n    assertTrue(appender.logContains(\"Dwarven tunnel digger creates another promising tunnel.\"));\n\n    // Again, they shouldn't be doing anything else.\n    assertEquals(9, appender.getLogSize());\n\n    // Enough gold, lets end the day.\n    goldMine.endDay();\n\n    // Check if the workers go home ...\n    assertTrue(appender.logContains(\"Dwarf gold digger goes home.\"));\n    assertTrue(appender.logContains(\"Dwarf cart operator goes home.\"));\n    assertTrue(appender.logContains(\"Dwarven tunnel digger goes home.\"));\n\n    // ... and go to sleep. We need well rested workers the next day :)\n    assertTrue(appender.logContains(\"Dwarf gold digger goes to sleep.\"));\n    assertTrue(appender.logContains(\"Dwarf cart operator goes to sleep.\"));\n    assertTrue(appender.logContains(\"Dwarven tunnel digger goes to sleep.\"));\n\n    // Every worker should be sleeping now, no other actions allowed\n    assertEquals(15, appender.getLogSize());\n  }",
    "comment": "Test a complete day cycle in the gold mine by executing all three different steps: {@link\nDwarvenGoldmineFacade#startNewDay()}, {@link DwarvenGoldmineFacade#digOutGold()} and {@link\nDwarvenGoldmineFacade#endDay()}.\n\n<p>See if the workers are doing what's expected from them on each step."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/model-view-intent/src/main/java/com/iluwatar/model/view/intent/CalculatorView.java",
    "type": "method",
    "name": "setVariable",
    "code": "void setVariable(final Double value) {\n    viewModel.handleAction(new SetVariableCalculatorAction(value));\n  }",
    "comment": "Handle setting new variable action.\n\n@param value -> new calculator variable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/bloc/src/main/java/com/iluwatar/bloc/Bloc.java",
    "type": "method",
    "name": "addListener",
    "code": "public void addListener(StateListener<State> listener) {\n    listeners.add(listener);\n    listener.onStateChange(currentState);\n  }",
    "comment": "Adds a listener to receive state change notifications.\n\n@param listener the listener to add"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java",
    "type": "method",
    "name": "looksLikeAFullyQualifiedMethodName",
    "code": "private static boolean looksLikeAFullyQualifiedMethodName(String factoryMethodName) {\n\t\tif (factoryMethodName.contains(\"#\")) {\n\t\t\treturn true;\n\t\t}\n\t\tint indexOfFirstDot = factoryMethodName.indexOf('.');\n\t\tif (indexOfFirstDot == -1) {\n\t\t\treturn false;\n\t\t}\n\t\tint indexOfLastOpeningParenthesis = factoryMethodName.lastIndexOf('(');\n\t\tif (indexOfLastOpeningParenthesis > 0) {\n\t\t\treturn indexOfFirstDot < indexOfLastOpeningParenthesis;\n\t\t}\n\t\treturn true;\n\t}",
    "comment": "Exclude simple/local method names with parameters\nIf we get this far, we conclude the supplied factory method name \"looks\"\nlike it was intended to be a fully qualified method name, even if the\nsyntax is invalid. We do this in order to provide better diagnostics for\nthe user when a fully qualified method name is in fact invalid."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/RepeatedTestTests.java",
    "type": "method",
    "name": "failureThresholdWithConcurrentExecution",
    "code": "void failureThresholdWithConcurrentExecution() {\n\t\t\tClass<TestCase> testClass = TestCase.class;\n\t\t\tString methodName = \"failureThresholdWithConcurrentExecution\";\n\t\t\tMethod method = ReflectionSupport.findMethod(testClass, methodName).get();\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(testClass, method))//\n\t\t\t\t\t.configurationParameter(PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME, \"true\")//\n\t\t\t\t\t.configurationParameter(DEFAULT_PARALLEL_EXECUTION_MODE, \"concurrent\")//\n\t\t\t\t\t.configurationParameter(PARALLEL_CONFIG_STRATEGY_PROPERTY_NAME, \"fixed\")//\n\t\t\t\t\t.configurationParameter(PARALLEL_CONFIG_FIXED_PARALLELISM_PROPERTY_NAME, \"4\")//\n\t\t\t\t\t.build();\n\n\t\t\tEvents tests = executeTests(request).testEvents();\n\n\t\t\tassertThat(tests.dynamicallyRegistered().count()).as(\"registered\").isEqualTo(20);\n\t\t\tassertThat(tests.started().count() + tests.skipped().count()).as(\"started or skipped\").isEqualTo(20);\n\t\t\tassertThat(tests.succeeded().count()).as(\"succeeded\").isBetween(3L, 10L);\n\t\t\tassertThat(tests.failed().count()).as(\"failed\").isGreaterThanOrEqualTo(3);\n\t\t\tassertThat(tests.skipped().count()).as(\"skipped\").isGreaterThan(0);\n\t\t}",
    "comment": "There are 20 repetitions/tests in total.\nWould be 3 successful tests without parallel execution, but with race conditions\nand multiple threads we may encounter more; and yet we still should not\nencounter too many.\nWould be 3 failed tests without parallel execution, but with race conditions\nand multiple threads we may encounter more.\nWould be 14 skipped tests without parallel execution, but with race conditions\nand multiple threads we may not encounter many."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/repository/MavenArtifactRepository.java",
    "type": "method",
    "name": "protocol",
    "code": "private static String protocol(final String url) {\n        final int pos = url.indexOf(':');\n\n        if (pos == -1) {\n            return \"\";\n        }\n        return url.substring(0, pos).trim();\n    }",
    "comment": "Return the protocol name.\n<br>\nE.g: for input\n<code>http://www.codehaus.org</code> this method will return <code>http</code>\n\n@param url the url\n@return the host name"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/JUnitCommandLineParseResult.java",
    "type": "method",
    "name": "parseOptions",
    "code": "String[] parseOptions(String... args) {\n        for (int i = 0; i != args.length; ++i) {\n            String arg = args[i];\n\n            if (arg.equals(\"--\")) {\n                return copyArray(args, i + 1, args.length);\n            } else if (arg.startsWith(\"--\")) {\n                if (arg.startsWith(\"--filter=\") || arg.equals(\"--filter\")) {\n                    String filterSpec;\n                    if (arg.equals(\"--filter\")) {\n                        ++i;\n\n                        if (i < args.length) {\n                            filterSpec = args[i];\n                        } else {\n                            parserErrors.add(new CommandLineParserError(arg + \" value not specified\"));\n                            break;\n                        }\n                    } else {\n                        filterSpec = arg.substring(arg.indexOf('=') + 1);\n                    }\n\n                    filterSpecs.add(filterSpec);\n                } else {\n                    parserErrors.add(new CommandLineParserError(\"JUnit knows nothing about the \" + arg + \" option\"));\n                }\n            } else {\n                return copyArray(args, i, args.length);\n            }\n        }\n\n        return new String[]{};\n\n    private String[] copyArray(String[] args, int from, int to) {\n        String[] result = new String[to - from];\n        for (int j = from; j != to; ++j) {\n            result[j - from] = args[j];\n        }\n        return result;\n    }\n\n    void parseParameters(String[] args) {\n        for (String arg : args) {\n            try {\n                classes.add(Classes.getClass(arg));\n            } catch (ClassNotFoundException e) {\n                parserErrors.add(new IllegalArgumentException(\"Could not find class [\" + arg + \"]\", e));\n            }\n        }\n    }\n\n    private Request errorReport(Throwable cause) {\n        return Request.errorReport(JUnitCommandLineParseResult.class, cause);\n    }\n\n    public Request createRequest(Computer computer) {\n        if (parserErrors.isEmpty()) {\n            Request request = Request.classes(\n                    computer, classes.toArray(new Class<?>[classes.size()]));\n            return applyFilterSpecs(request);\n        } else {\n            return errorReport(new InitializationError(parserErrors));\n        }\n    }\n\n    private Request applyFilterSpecs(Request request) {\n        try {\n            for (String filterSpec : filterSpecs) {\n                Filter filter = FilterFactories.createFilterFromFilterSpec(\n                        request, filterSpec);\n                request = request.filterWith(filter);\n            }\n            return request;\n        } catch (FilterNotCreatedException e) {\n            return errorReport(e);\n        }\n    }\n\n    public static class CommandLineParserError extends Exception {\n        private static final long serialVersionUID= 1L;\n\n        public CommandLineParserError(String message) {\n            super(message);\n        }\n    }\n}",
    "comment": "Exception used if there's a problem parsing the command line."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/options/Theme.java",
    "type": "method",
    "name": "toString",
    "code": "public final String toString() {\n\t\treturn name().toLowerCase();\n\t}",
    "comment": "Return lower case {@link #name()} for easier usage in help text for\navailable options."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/theories/internal/AllMembersSupplier.java",
    "type": "method",
    "name": "MethodParameterValue",
    "code": "private MethodParameterValue(FrameworkMethod dataPointMethod) {\n            method = dataPointMethod;\n        }",
    "comment": "Supplies Theory parameters based on all public members of the target class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "fail",
    "code": "public static void fail(String message) {\n        Assert.fail(message);\n    }",
    "comment": "Fails a test with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/MojoDescriptor.java",
    "type": "method",
    "name": "getParameters",
    "code": "public List<Parameter> getParameters() {\n        return new ArrayList<>(parameters);\n    }",
    "comment": "@return the list of parameters copy. Any change to returned list is NOT reflected on this instance. To add\nparameters, use {@link #addParameter(Parameter)} method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestInstanceLifecycleUtilsTests.java",
    "type": "method",
    "name": "getTestInstanceLifecyclePreconditions",
    "code": "void getTestInstanceLifecyclePreconditions() {\n\t\tPreconditionViolationException exception = assertThrows(PreconditionViolationException.class,\n\t\t\t() -> getTestInstanceLifecycle(null,\n\t\t\t\tnew DefaultJupiterConfiguration(mock(), dummyOutputDirectoryProvider())));\n\t\tassertThat(exception).hasMessage(\"testClass must not be null\");\n\n\t\texception = assertThrows(PreconditionViolationException.class,\n\t\t\t() -> getTestInstanceLifecycle(getClass(), null));\n\t\tassertThat(exception).hasMessage(\"configuration must not be null\");\n\t}",
    "comment": "Unit tests for {@link TestInstanceLifecycleUtils}.\n\n<p>NOTE: it doesn't make sense to unit test the JVM system property fallback\nsupport in this test class since that feature is a concrete implementation\ndetail of {@code LauncherConfigurationParameters} which necessitates an\nintegration test via the {@code Launcher} API.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectClass",
    "code": "public static ClassSelector selectClass(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\treturn new ClassSelector(clazz);\n\t}",
    "comment": "Create a {@code ClassSelector} for the supplied {@link Class}.\n\n@param clazz the class to select; never {@code null}\n@see ClassSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaLinearRegressionWithElasticNetExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaLinearRegressionWithElasticNetExample\")\n      .getOrCreate();\n\n    Dataset<Row> training = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_linear_regression_data.txt\");\n\n    LinearRegression lr = new LinearRegression()\n      .setMaxIter(10)\n      .setRegParam(0.3)\n      .setElasticNetParam(0.8);\n\n    LinearRegressionModel lrModel = lr.fit(training);\n\n    System.out.println(\"Coefficients: \"\n      + lrModel.coefficients() + \" Intercept: \" + lrModel.intercept());\n\n    LinearRegressionTrainingSummary trainingSummary = lrModel.summary();\n    System.out.println(\"numIterations: \" + trainingSummary.totalIterations());\n    System.out.println(\"objectiveHistory: \" + Vectors.dense(trainingSummary.objectiveHistory()));\n    trainingSummary.residuals().show();\n    System.out.println(\"RMSE: \" + trainingSummary.rootMeanSquaredError());\n    System.out.println(\"r2: \" + trainingSummary.r2());\n\n    spark.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nLoad training data.\nFit the model.\nPrint the coefficients and intercept for linear regression.\nSummarize the model over the training set and print out some metrics.\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/validator/AnnotationValidatorFactory.java",
    "type": "method",
    "name": "createAnnotationValidator",
    "code": "public AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        AnnotationValidator validator = VALIDATORS_FOR_ANNOTATION_TYPES.get(validateWithAnnotation);\n        if (validator != null) {\n            return validator;\n        }\n\n        Class<? extends AnnotationValidator> clazz = validateWithAnnotation.value();\n        try {\n            AnnotationValidator annotationValidator = clazz.newInstance();\n            VALIDATORS_FOR_ANNOTATION_TYPES.putIfAbsent(validateWithAnnotation, annotationValidator);\n            return VALIDATORS_FOR_ANNOTATION_TYPES.get(validateWithAnnotation);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Exception received when creating AnnotationValidator class \" + clazz.getName(), e);\n        }\n    }",
    "comment": "Creates the AnnotationValidator specified by the value in\n{@link org.junit.validator.ValidateWith}. Instances are\ncached.\n\n@return An instance of the AnnotationValidator.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventStatistics.java",
    "type": "method",
    "name": "failed",
    "code": "public EventStatistics failed(long expected) {\n\t\tthis.executables.add(() -> assertEquals(expected, this.events.failed().count(), \"failed\"));\n\t\treturn this;\n\t}",
    "comment": "Specify the number of expected <em>failed</em> events.\n\n@param expected the expected number of events\n@return this {@code EventStatistics} for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicDescendantFilter.java",
    "type": "method",
    "name": "allowUniqueIdPrefix",
    "code": "public void allowUniqueIdPrefix(UniqueId uniqueId) {\n\t\tif (this.mode == Mode.EXPLICIT) {\n\t\t\tthis.allowedUniqueIds.add(uniqueId);\n\t\t}\n\t}",
    "comment": "Filter for dynamic descendants of {@link TestDescriptor TestDescriptors} that\nimplement {@link Filterable}.\n\n@since 5.1\n@see Filterable"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-api-gateway/api-gateway-service/src/main/java/com/iluwatar/api/gateway/ApiGateway.java",
    "type": "method",
    "name": "getProductMobile",
    "code": "public MobileProduct getProductMobile() {\n    var mobileProduct = new MobileProduct();\n    mobileProduct.setPrice(priceClient.getPrice());\n    return mobileProduct;\n  }",
    "comment": "Retrieves product information that mobile clients need.\n\n@return Product information for clients on a mobile device"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/distributions/Distributions.java",
    "type": "method",
    "name": "ordered",
    "code": "public static OrderedDistribution ordered(SortOrder[] ordering) {\n    return LogicalDistributions.ordered(ordering);\n  }",
    "comment": "Creates a distribution where tuples have been ordered across partitions according\nto ordering expressions, but not necessarily within a given partition."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(BooleanSupplier booleanSupplier, Supplier<String> messageSupplier) {\n\t\tAssertFalse.assertFalse(booleanSupplier, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that the boolean condition supplied by {@code booleanSupplier} is {@code false}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/Sources.java",
    "type": "method",
    "name": "fromPath",
    "code": "public static Source fromPath(@Nonnull Path path) {\n        return new PathSource(requireNonNull(path, \"path\"));\n    }",
    "comment": "Creates a new source for the specified path.\n\n@param path the path to the file\n@return a new Source instance\n@throws NullPointerException if path is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "debug",
    "code": "public Events debug(OutputStream out) {\n\t\tPreconditions.notNull(out, \"OutputStream must not be null\");\n\t\tdebug(new PrintWriter(out, true));\n\t\treturn this;\n\t}",
    "comment": "Print all events to the supplied {@link OutputStream}.\n\n@param out the {@code OutputStream} to print to; never {@code null}\n@return this {@code Events} object for method chaining; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-dependency-collection/src/main/java/org/apache/maven/plugin/coreit/AbstractDependencyMojo.java",
    "type": "method",
    "name": "resolveFile",
    "code": "private File resolveFile(String pathname) {\n        File file = null;\n\n        if (pathname != null) {\n            file = new File(pathname);\n\n            if (!file.isAbsolute()) {\n                file = new File(project.getBasedir(), pathname);\n            }\n        }\n\n        return file;\n    }",
    "comment": "NOTE: We don't want to test path translation here so resolve relative path manually for robustness"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-executor/src/test/java/org/apache/maven/cling/executor/impl/ToolboxToolTest.java",
    "type": "method",
    "name": "artifactPath4",
    "code": "void artifactPath4(ExecutorHelper.Mode mode) {\n        ExecutorHelper helper = new HelperImpl(\n                mode,\n                mvn4ExecutorRequestBuilder().build().installationDirectory(),\n                userHome,\n                MavenExecutorTestSupport.EMBEDDED_MAVEN_EXECUTOR,\n                MavenExecutorTestSupport.FORKED_MAVEN_EXECUTOR);\n        String path = new ToolboxTool(helper)\n                .artifactPath(helper.executorRequest(), \"aopalliance:aopalliance:1.0\", \"central\");\n        assertTrue(\n                path.endsWith(\"aopalliance\" + File.separator + \"aopalliance\" + File.separator + \"1.0\" + File.separator\n                        + \"aopalliance-1.0.jar\"),\n                \"path=\" + path);\n    }",
    "comment": "split repository: assert \"ends with\" as split may introduce prefixes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Object unexpected, Object actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails if both are {@code null}.\n\n@see Object#equals(Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/test/java/org/apache/maven/artifact/versioning/ComparableVersionTest.java",
    "type": "method",
    "name": "testLexicographicASCIISortOrder",
    "code": "void testLexicographicASCIISortOrder() { // Required by Semver 1.0\n        ComparableVersion lower = new ComparableVersion(\"1.0.0-alpha1\");\n        ComparableVersion upper = new ComparableVersion(\"1.0.0-ALPHA1\");\n        assertTrue(upper.compareTo(lower) == 0, \"expected 1.0.0-ALPHA1 == 1.0.0-alpha1\");\n        assertTrue(lower.compareTo(upper) == 0, \"expected 1.0.0-alpha1 == 1.0.0-ALPHA1\");\n    }",
    "comment": "Lower case is equal to upper case. This is *NOT* what Semver 1.0\nspecifies. Here we are explicitly deviating from Semver 1.0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Integer> create(Scope scope, int[][][] data) {\n    return create(scope, data, Integer.class);\n  }",
    "comment": "Creates a rank-3 constant of {@code int} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(int unexpected, Integer actual) {\n\t\tAssertNotEquals.assertNotEquals((Integer) unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/spatial-partition/src/main/java/com/iluwatar/spatialpartition/SpatialPartitionBubbles.java",
    "type": "method",
    "name": "handleCollisionsUsingQt",
    "code": "void handleCollisionsUsingQt(Bubble b) {\n    var rect = new Rect(b.coordinateX, b.coordinateY, 2D * b.radius, 2D * b.radius);\n    var quadTreeQueryResult = new ArrayList<Point>();\n    this.bubblesQuadTree.query(rect, quadTreeQueryResult);\n    b.handleCollision(quadTreeQueryResult, this.bubbles);\n  }",
    "comment": "finding points within area of a square drawn with centre same as\ncentre of bubble and length = radius of bubble\nhandling these collisions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/test/org/apache/spark/JavaTaskContextCompileCheck.java",
    "type": "method",
    "name": "onTaskFailure",
    "code": "public void onTaskFailure(TaskContext context, Throwable error) {\n    }",
    "comment": "A simple implementation of TaskCompletionListener that makes sure TaskCompletionListener and\nTaskContext is Java friendly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/plugin/testing/stubs/SessionMock.java",
    "type": "method",
    "name": "getMockSession",
    "code": "public static InternalSession getMockSession(String localRepo) {\n        LocalRepository localRepository = mock(LocalRepository.class);\n        when(localRepository.getId()).thenReturn(\"local\");\n        when(localRepository.getPath()).thenReturn(Paths.get(localRepo));\n        return getMockSession(localRepository);\n    }",
    "comment": "A mock implementation of {@link InternalSession} for testing Maven plugins.\nThis class provides a comprehensive mock session that simulates the behavior\nof a real Maven session, including repository management, artifact handling,\nand project building capabilities.\n\n<p>The mock session includes pre-configured behaviors for:</p>\n<ul>\n<li>Repository management (local and remote repositories)</li>\n<li>Artifact installation and deployment</li>\n<li>Project building and management</li>\n<li>Version parsing and handling</li>\n<li>Model XML processing</li>\n<li>Session data storage</li>\n</ul>\n\n<p>Example usage in a test:</p>\n<pre>\n{@code\n@Test\nvoid testMojo() {\n// Create a mock session with a specific local repository\nInternalSession session = SessionMock.getMockSession(\"/path/to/local/repo\");\n\n// Use the session for testing\nMyMojo mojo = new MyMojo();\nmojo.setSession(session);\nmojo.execute();\n}\n}\n</pre>\n\n<p>The mock session maintains internal state for:</p>\n<ul>\n<li>Attached artifacts (via {@link ProjectManager})</li>\n<li>Artifact paths (via {@link ArtifactManager})</li>\n<li>System and user properties</li>\n<li>Session-scoped data (via {@link TestSessionData})</li>\n</ul>\n\n<p>Most service implementations are mocked using Mockito, with pre-configured\nbehaviors that simulate typical Maven operations. Some services, like\n{@link ModelXmlFactory} and {@link VersionParser}, use real implementations\nto ensure correct handling of Maven models and versions.</p>\n\n@see InternalSession\n@see LocalRepository\n@see ProjectManager\n@see ArtifactManager\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TemporaryFolder.java",
    "type": "method",
    "name": "TemporaryFolder",
    "code": "public TemporaryFolder(File parentFolder) {\n        this.parentFolder = parentFolder;\n        this.assureDeletion = false;\n    }",
    "comment": "Create a temporary folder which uses the specified directory to create\ntemporary resources.\n\n@param parentFolder folder where temporary resources will be created.\nIf {@code null} then system default temporary-file directory is used."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java",
    "type": "method",
    "name": "createPluginArtifact",
    "code": "public Artifact createPluginArtifact(Plugin plugin) {\n        String version = plugin.getVersion();\n        if (version == null || version.isEmpty()) {\n            version = \"RELEASE\";\n        }\n\n        VersionRange versionRange;\n        try {\n            versionRange = VersionRange.createFromVersionSpec(version);\n        } catch (InvalidVersionSpecificationException e) {\n            this.logger.error(\n                    String.format(\"Invalid version specification '%s' creating plugin artifact '%s'.\", version, plugin),\n                    e);\n\n            return null;\n        }\n\n        return artifactFactory.createPluginArtifact(plugin.getGroupId(), plugin.getArtifactId(), versionRange);\n    }",
    "comment": "MNG-5368: Log a message instead of returning 'null' silently."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/thrift/ThriftBinaryCLIService.java",
    "type": "method",
    "name": "initializeServer",
    "code": "protected void initializeServer() {\n    try {\n      String threadPoolName = \"HiveServer2-Handler-Pool\";\n      ExecutorService executorService = new ThreadPoolExecutor(minWorkerThreads, maxWorkerThreads,\n          workerKeepAliveTime, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n          new ThreadFactoryWithGarbageCleanup(threadPoolName));\n\n      hiveAuthFactory = new HiveAuthFactory(hiveConf);\n      TTransportFactory transportFactory = hiveAuthFactory.getAuthTransFactory();\n      TProcessorFactory processorFactory = hiveAuthFactory.getAuthProcFactory(this);\n      TServerSocket serverSocket = null;\n      List<String> sslVersionBlacklist = new ArrayList<String>();\n      for (String sslVersion : hiveConf.getVar(ConfVars.HIVE_SSL_PROTOCOL_BLACKLIST).split(\",\")) {\n        sslVersionBlacklist.add(sslVersion);\n      }\n      if (!hiveConf.getBoolVar(ConfVars.HIVE_SERVER2_USE_SSL)) {\n        serverSocket = HiveAuthUtils.getServerSocket(hiveHost, portNum);\n      } else {\n        String keyStorePath = hiveConf.getVar(ConfVars.HIVE_SERVER2_SSL_KEYSTORE_PATH).trim();\n        if (keyStorePath.isEmpty()) {\n          throw new IllegalArgumentException(ConfVars.HIVE_SERVER2_SSL_KEYSTORE_PATH.varname\n              + \" Not configured for SSL connection\");\n        }\n        String keyStorePassword = ShimLoader.getHadoopShims().getPassword(hiveConf,\n            HiveConf.ConfVars.HIVE_SERVER2_SSL_KEYSTORE_PASSWORD.varname);\n        serverSocket = HiveAuthUtils.getServerSSLSocket(hiveHost, portNum, keyStorePath,\n            keyStorePassword, sslVersionBlacklist);\n      }\n\n      portNum = serverSocket.getServerSocket().getLocalPort();\n\n      int maxMessageSize = hiveConf.getIntVar(HiveConf.ConfVars.HIVE_SERVER2_THRIFT_MAX_MESSAGE_SIZE);\n      TThreadPoolServer.Args sargs = new TThreadPoolServer.Args(serverSocket)\n          .processorFactory(processorFactory).transportFactory(transportFactory)\n          .protocolFactory(new TBinaryProtocol.Factory())\n          .inputProtocolFactory(new TBinaryProtocol.Factory(true, true, maxMessageSize, maxMessageSize))\n          .executorService(executorService);\n\n      server = new TThreadPoolServer(sargs);\n      server.setServerEventHandler(serverEventHandler);\n      String msg = \"Starting \" + ThriftBinaryCLIService.class.getSimpleName() + \" on port \"\n          + portNum + \" with \" + minWorkerThreads + \"...\" + maxWorkerThreads + \" worker threads\";\n      LOG.info(msg);\n    } catch (Exception t) {\n      throw new ServiceException(\"Error initializing \" + getName(), t);\n    }\n  }",
    "comment": "Server thread pool\nThrift configs\nIn case HIVE_SERVER2_THRIFT_PORT or hive.server2.thrift.port is configured with 0 which\nrepresents any free port, we should set it to the actual one\nServer args\nTCP Server"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "shouldNotReorder",
    "code": "private boolean shouldNotReorder() {\n        return getDescription().getAnnotation(FixMethodOrder.class) != null;\n    }",
    "comment": "Private implementation\n\nIf the test specifies a specific order, do not reorder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/main/java/org/apache/hadoop/hive/ql/exec/SparkDefaultUDAFEvaluatorResolver.java",
    "type": "method",
    "name": "SparkDefaultUDAFEvaluatorResolver",
    "code": "public SparkDefaultUDAFEvaluatorResolver(DefaultUDAFEvaluatorResolver wrapped) {\n    try {\n      Field udfClassField = wrapped.getClass().getDeclaredField(\"udafClass\");\n      udfClassField.setAccessible(true);\n      this.udafClass = (Class<? extends UDAF>) udfClassField.get(wrapped);\n    } catch (ReflectiveOperationException rethrow) {\n      throw new RuntimeException(rethrow);\n    }\n  }",
    "comment": "Constructor. This constructor extract udafClass from {@link DefaultUDAFEvaluatorResolver}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(int[] expecteds, int[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }",
    "comment": "Asserts that two int arrays are equal. If they are not, an\n{@link AssertionError} is thrown.\n\n@param expecteds int array with expected values.\n@param actuals int array with actual values"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "setUserProperties",
    "code": "public DefaultProfileActivationContext setUserProperties(Properties userProperties) {\n        if (userProperties != null) {\n            this.userProperties = Collections.unmodifiableMap((Map) userProperties);\n        } else {\n            this.userProperties = Collections.emptyMap();\n        }\n\n        return this;\n    }",
    "comment": "Sets the user properties to use for interpolation and profile activation. The user properties have been\nconfigured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command\nline.\n\n@param userProperties The user properties, may be {@code null}.\n@return This context, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/RunnerTestDescriptorPostProcessorTests.java",
    "type": "method",
    "name": "doesNotLogAnythingForFilterableRunner",
    "code": "void doesNotLogAnythingForFilterableRunner(LogRecordListener listener) {\n\t\tresolve(selectMethod(PlainJUnit4TestCaseWithFiveTestMethods.class, \"successfulTest\"));\n\n\t\tassertThat(listener.stream(RunnerTestDescriptor.class)).isEmpty();\n\t}",
    "comment": "Tests for {@link RunnerTestDescriptorPostProcessor}.\n\n@since 5.5"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/gen/java/org/tensorflow/processor/OperatorProcessor.java",
    "type": "method",
    "name": "writeApi",
    "code": "private void writeApi(Multimap<String, MethodSpec> groupedMethods) {\n    Map<String, ClassName> groups = new HashMap<>();\n\n    for (Map.Entry<String, Collection<MethodSpec>> entry : groupedMethods.asMap().entrySet()) {\n      if (!entry.getKey().isEmpty()) {\n        TypeSpec groupClass = buildGroupClass(entry.getKey(), entry.getValue());\n        write(groupClass);\n        groups.put(entry.getKey(), ClassName.get(\"org.tensorflow.op\", groupClass.name));\n      }\n    }\n    TypeSpec topClass = buildTopClass(groups, groupedMethods.get(\"\"));\n    write(topClass);\n  }",
    "comment": "Generate a API class for each group collected other than the default one (= empty string)\nGenerate the top API class, adding any methods added to the default group"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/serialized-lob/src/main/java/com/iluwatar/slob/lob/Forest.java",
    "type": "method",
    "name": "createObjectFromXml",
    "code": "public void createObjectFromXml(Document document) {\n    name = document.getDocumentElement().getAttribute(\"name\");\n    NodeList nodeList = document.getElementsByTagName(\"*\");\n    iterateXmlForAnimalAndPlants(nodeList, animals, plants);\n  }",
    "comment": "Parses the Forest Object from the input XML Document.\n\n@param document the XML document from which the Forest is to be parsed"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java",
    "type": "method",
    "name": "from",
    "code": "public static MethodSource from(Class<?> testClass, Method testMethod) {\n\t\treturn new MethodSource(testClass, testMethod);\n\t}",
    "comment": "Create a new {@code MethodSource} using the supplied\n\n<p>This method should be used in favor of {@link #from(Method)} if the\ntest method is inherited from a superclass or present as an interface\n{@code default} method.\n\n@param testClass the Java class; must not be {@code null}\n@param testMethod the Java method; must not be {@code null}\n@since 1.3"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<String> create(Scope scope, byte[][] data) {\n    return create(scope, data, String.class);\n  }",
    "comment": "Creates a rank-1 constant of {@code String} elements, each represented as an array of {@code byte}s.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Float> create(float[][][][][] data) {\n    return Tensor.create(data, Float.class);\n  }",
    "comment": "Creates a rank-5 tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java",
    "type": "method",
    "name": "isActive",
    "code": "public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        Activation activation = profile.getActivation();\n\n        if (activation == null) {\n            return false;\n        }\n\n        String jdk = activation.getJdk();\n\n        if (jdk == null) {\n            return false;\n        }\n\n        String version = context.getSystemProperties().get(\"java.version\");\n\n        if (version == null || version.length() <= 0) {\n            problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE)\n                    .setMessage(\"Failed to determine Java version for profile \" + profile.getId())\n                    .setLocation(activation.getLocation(\"jdk\")));\n            return false;\n        }\n\n        if (jdk.startsWith(\"!\")) {\n            return !version.startsWith(jdk.substring(1));\n        } else if (isRange(jdk)) {\n            try {\n                return isInRange(version, getRange(jdk));\n            } catch (NumberFormatException e) {\n                problems.add(new ModelProblemCollectorRequest(Severity.WARNING, Version.BASE)\n                        .setMessage(\"Failed to determine JDK activation for profile \" + profile.getId()\n                                + \" due invalid JDK version: '\" + version + \"'\")\n                        .setLocation(profile.getLocation(\"\"))\n                        .setException(e));\n                return false;\n            }\n        } else {\n            return version.startsWith(jdk);\n        }\n    }",
    "comment": "Determines profile activation based on the version of the current Java runtime.\n\n@see Activation#getJdk()\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(BooleanSupplier booleanSupplier) {\n\t\tAssertTrue.assertTrue(booleanSupplier);\n\t}",
    "comment": "<em>Assert</em> that the boolean condition supplied by {@code booleanSupplier} is {@code true}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionArtifactFilter.java",
    "type": "method",
    "name": "ExclusionArtifactFilter",
    "code": "public ExclusionArtifactFilter(List<Exclusion> exclusions) {\n        this.exclusions = exclusions;\n        this.predicates =\n                exclusions.stream().map(ExclusionArtifactFilter::toPredicate).collect(Collectors.toList());\n    }",
    "comment": "Filter to exclude from a list of artifact patterns."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-xml/src/main/java/org/apache/maven/internal/xml/DefaultXmlService.java",
    "type": "method",
    "name": "doMerge",
    "code": "public XmlNode doMerge(XmlNode dominant, XmlNode recessive, Boolean childMergeOverride) {\n        // TODO: share this as some sort of assembler, implement a walk interface?\n        if (recessive == null) {\n            return dominant;\n        }\n        if (dominant == null) {\n            return recessive;\n        }\n\n        boolean mergeSelf = true;\n\n        String selfMergeMode = getSelfCombinationMode(dominant);\n\n        if (SELF_COMBINATION_OVERRIDE.equals(selfMergeMode)) {\n            mergeSelf = false;\n        }\n\n        if (mergeSelf) {\n\n            String value = dominant.value();\n            Object location = dominant.inputLocation();\n            Map<String, String> attrs = dominant.attributes();\n            List<XmlNode> children = null;\n\n            for (Map.Entry<String, String> attr : recessive.attributes().entrySet()) {\n                String key = attr.getKey();\n                if (isEmpty(attrs.get(key))) {\n                    if (attrs == dominant.attributes()) {\n                        attrs = new HashMap<>(attrs);\n                    }\n                    attrs.put(key, attr.getValue());\n                }\n            }\n\n            if (!recessive.children().isEmpty()) {\n                boolean mergeChildren = true;\n                if (childMergeOverride != null) {\n                    mergeChildren = childMergeOverride;\n                } else {\n                    String childCombinationMode = getChildCombinationMode(attrs);\n                    if (CHILDREN_COMBINATION_APPEND.equals(childCombinationMode)) {\n                        mergeChildren = false;\n                    }\n                }\n\n                Map<String, Iterator<XmlNode>> commonChildren = new HashMap<>();\n                Set<String> names =\n                        recessive.children().stream().map(XmlNode::name).collect(Collectors.toSet());\n                for (String name : names) {\n                    List<XmlNode> dominantChildren = dominant.children().stream()\n                            .filter(n -> n.name().equals(name))\n                            .toList();\n                    if (!dominantChildren.isEmpty()) {\n                        commonChildren.put(name, dominantChildren.iterator());\n                    }\n                }\n\n                String keysValue = recessive.attribute(KEYS_COMBINATION_MODE_ATTRIBUTE);\n\n                int recessiveChildIndex = 0;\n                for (XmlNode recessiveChild : recessive.children()) {\n                    String idValue = recessiveChild.attribute(ID_COMBINATION_MODE_ATTRIBUTE);\n\n                    XmlNode childDom = null;\n                    if (!isEmpty(idValue)) {\n                        for (XmlNode dominantChild : dominant.children()) {\n                            if (idValue.equals(dominantChild.attribute(ID_COMBINATION_MODE_ATTRIBUTE))) {\n                                childDom = dominantChild;\n                                // we have a match, so don't append but merge\n                                mergeChildren = true;\n                            }\n                        }\n                    } else if (!isEmpty(keysValue)) {\n                        String[] keys = keysValue.split(\",\");\n                        Map<String, Optional<String>> recessiveKeyValues = Stream.of(keys)\n                                .collect(Collectors.toMap(\n                                        k -> k, k -> Optional.ofNullable(recessiveChild.attribute(k))));\n\n                        for (XmlNode dominantChild : dominant.children()) {\n                            Map<String, Optional<String>> dominantKeyValues = Stream.of(keys)\n                                    .collect(Collectors.toMap(\n                                            k -> k, k -> Optional.ofNullable(dominantChild.attribute(k))));\n\n                            if (recessiveKeyValues.equals(dominantKeyValues)) {\n                                childDom = dominantChild;\n                                // we have a match, so don't append but merge\n                                mergeChildren = true;\n                            }\n                        }\n                    } else {\n                        childDom = dominant.child(recessiveChild.name());\n                    }\n\n                    if (mergeChildren && childDom != null) {\n                        String name = recessiveChild.name();\n                        Iterator<XmlNode> it =\n                                commonChildren.computeIfAbsent(name, n1 -> Stream.of(dominant.children().stream()\n                                                .filter(n2 -> n2.name().equals(n1))\n                                                .collect(Collectors.toList()))\n                                        .filter(l -> !l.isEmpty())\n                                        .map(List::iterator)\n                                        .findFirst()\n                                        .orElse(null));\n                        if (it == null) {\n                            if (children == null) {\n                                children = new ArrayList<>(dominant.children());\n                            }\n                            children.add(recessiveChild);\n                        } else if (it.hasNext()) {\n                            XmlNode dominantChild = it.next();\n\n                            String dominantChildCombinationMode = getSelfCombinationMode(dominantChild);\n                            if (SELF_COMBINATION_REMOVE.equals(dominantChildCombinationMode)) {\n                                if (children == null) {\n                                    children = new ArrayList<>(dominant.children());\n                                }\n                                children.remove(dominantChild);\n                            } else {\n                                int idx = dominant.children().indexOf(dominantChild);\n                                XmlNode merged = merge(dominantChild, recessiveChild, childMergeOverride);\n                                if (merged != dominantChild) {\n                                    if (children == null) {\n                                        children = new ArrayList<>(dominant.children());\n                                    }\n                                    children.set(idx, merged);\n                                }\n                            }\n                        }\n                    } else {\n                        if (children == null) {\n                            children = new ArrayList<>(dominant.children());\n                        }\n                        int idx = mergeChildren ? children.size() : recessiveChildIndex;\n                        children.add(idx, recessiveChild);\n                    }\n                    recessiveChildIndex++;\n                }\n            }\n\n            if (value != null || attrs != dominant.attributes() || children != null) {\n                if (children == null) {\n                    children = dominant.children();\n                }\n                if (!Objects.equals(value, dominant.value())\n                        || !Objects.equals(attrs, dominant.attributes())\n                        || !Objects.equals(children, dominant.children())\n                        || !Objects.equals(location, dominant.inputLocation())) {\n                    return XmlNode.newBuilder()\n                            .prefix(dominant.prefix())\n                            .namespaceUri(dominant.namespaceUri())\n                            .name(dominant.name())\n                            .value(value != null ? value : dominant.value())\n                            .attributes(attrs)\n                            .children(children)\n                            .inputLocation(location)\n                            .build();\n                } else {\n                    return dominant;\n                }\n            }\n        }\n        return dominant;\n    }",
    "comment": "Merges one DOM into another, given a specific algorithm and possible override points for that algorithm.<p>\nThe algorithm is as follows:\n<ol>\n<li> if the recessive DOM is null, there is nothing to do... return.</li>\n<li> Determine whether the dominant node will suppress the recessive one (flag=mergeSelf).\n<ol type=\"A\">\n<li> retrieve the 'combine.self' attribute on the dominant node, and try to match against 'override'...\nif it matches 'override', then set mergeSelf == false...the dominant node suppresses the recessive one\ncompletely.</li>\n<li> otherwise, use the default value for mergeSelf, which is true...this is the same as specifying\n'combine.self' == 'merge' as an attribute of the dominant root node.</li>\n</ol></li>\n<li> If mergeSelf == true\n<ol type=\"A\">\n<li> Determine whether children from the recessive DOM will be merged or appended to the dominant DOM as\nsiblings (flag=mergeChildren).\n<ol type=\"i\">\n<li> if childMergeOverride is set (non-null), use that value (true/false)</li>\n<li> retrieve the 'combine.children' attribute on the dominant node, and try to match against\n'append'...</li>\n<li> if it matches 'append', then set mergeChildren == false...the recessive children will be appended as\nsiblings of the dominant children.</li>\n<li> otherwise, use the default value for mergeChildren, which is true...this is the same as specifying\n'combine.children' == 'merge' as an attribute on the dominant root node.</li>\n</ol></li>\n<li> Iterate through the recessive children, and:\n<ol type=\"i\">\n<li> if mergeChildren == true and there is a corresponding dominant child (matched by element name),\nmerge the two.</li>\n<li> otherwise, add the recessive child as a new child on the dominant root node.</li>\n</ol></li>\n</ol></li>\n</ol>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/FilePosition.java",
    "type": "method",
    "name": "from",
    "code": "public static FilePosition from(int line) {\n\t\treturn new FilePosition(line);\n\t}",
    "comment": "Create a new {@code FilePosition} using the supplied {@code line} number"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/impl/DefaultTypeRegistry.java",
    "type": "method",
    "name": "require",
    "code": "public Type require(String id) {\n        requireNonNull(id, \"id cannot be null\");\n        return usedTypes.computeIfAbsent(id, i -> {\n            Type type = types.get(id);\n            if (type == null) {\n                ArtifactHandler handler = manager.getArtifactHandler(id);\n                type = new DefaultType(\n                        id,\n                        languageRegistry.lookup(handler.getLanguage()).orElseGet(() -> handler::getLanguage),\n                        handler.getExtension(),\n                        handler.getClassifier(),\n                        handler.isIncludesDependencies(),\n                        handler.isAddedToClasspath()\n                                ? new JavaPathType[] {JavaPathType.CLASSES, JavaPathType.MODULES}\n                                : new JavaPathType[] {});\n            return type;\n        });\n    }\n}",
    "comment": "Copy data as the ArtifactHandler is not immutable, but Type should be."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Timeout.java",
    "type": "method",
    "name": "seconds",
    "code": "public static Timeout seconds(long seconds) {\n        return new Timeout(seconds, TimeUnit.SECONDS);\n    }",
    "comment": "Creates a {@link Timeout} that will timeout a test after the\ngiven duration, in seconds.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/CpuHealthIndicatorTest.java",
    "type": "method",
    "name": "whenProcessCpuLoadIsHigh_thenHealthIsDown",
    "code": "void whenProcessCpuLoadIsHigh_thenHealthIsDown() {\n    // Set thresholds for testing within the test method to avoid issues with Spring's @Value\n    cpuHealthIndicator.setSystemCpuLoadThreshold(80.0);\n    cpuHealthIndicator.setProcessCpuLoadThreshold(50.0);\n    cpuHealthIndicator.setLoadAverageThreshold(0.75);\n\n    // Mock the getters to return your desired values\n    when(mockOsBean.getCpuLoad()).thenReturn(0.5); // Simulate 50% system CPU load\n    when(mockOsBean.getProcessCpuLoad()).thenReturn(0.8); // Simulate 80% process CPU load\n    when(mockOsBean.getAvailableProcessors()).thenReturn(8);\n    when(mockOsBean.getSystemLoadAverage()).thenReturn(5.0);\n\n    // Execute the health check\n    Health health = cpuHealthIndicator.health();\n\n    // Assertions\n    assertEquals(\n        Status.DOWN,\n        health.getStatus(),\n        \"Health status should be DOWN when process CPU load is high\");\n    assertEquals(\n        \"High process CPU load\",\n        health.getDetails().get(\"error\"),\n        \"Error message should indicate high process CPU load\");\n  }",
    "comment": "Tests that the health status is DOWN when the process CPU load is high.\n\n<p>Sets the process CPU load to 80% and mocks the other getters to return appropriate values.\nExecutes the health check and asserts that the health status is DOWN and the error message\nindicates high process CPU load."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java",
    "type": "method",
    "name": "getWithTypeSafetyAndPrimitiveValueType",
    "code": "void getWithTypeSafetyAndPrimitiveValueType() {\n\t\t\tString key = \"enigma\";\n\t\t\tint value = 42;\n\t\t\tstore.put(namespace, key, value);\n\n\t\t\tint requiredInt = store.get(namespace, key, int.class);\n\t\t\tInteger requiredInteger = store.get(namespace, key, Integer.class);\n\t\t\tassertEquals(value, requiredInt);\n\t\t\tassertEquals(value, requiredInteger.intValue());\n\t\t}",
    "comment": "The fact that we can declare this as an int/Integer suffices for testing the required type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "configurationParametersResources",
    "code": "public LauncherDiscoveryRequestBuilder configurationParametersResources(String... paths) {\n\t\tPreconditions.notNull(paths, \"property file paths must not be null\");\n\t\tCollections.addAll(configurationParametersResources, paths);\n\t\treturn this;\n\t}",
    "comment": "Add all of the supplied configuration parameters resource files to the request.\n@param paths the classpath locations of the properties files\nnever {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/Parameter.java",
    "type": "method",
    "name": "clone",
    "code": "public Parameter clone() {\n        try {\n            return (Parameter) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e);\n        }\n    }",
    "comment": "Creates a shallow copy of this parameter."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/service/VehicleService.java",
    "type": "method",
    "name": "getVehicle",
    "code": "public Vehicle getVehicle(int vehicleId) {\n    return vehicleRepository.findById(vehicleId).orElse(null);\n  }",
    "comment": "A method to get a specific vehicle from vehicle id.\n\n@param vehicleId Vehicle Id\n@see Vehicle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng0828PluginConfigValuesInDebugTest.java",
    "type": "method",
    "name": "checkLog",
    "code": "private void checkLog(String log, String expected) {\n        assertTrue(\n                log.contains(expected),\n                NL + \">>>\" + NL + log + \"<<<\" + NL + NL + \"does not contains: \" + NL + expected + NL);\n    }",
    "comment": "Verify that plain plugin configuration values are listed correctly in debug mode.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/front-controller/src/main/java/com/iluwatar/front/controller/Dispatcher.java",
    "type": "method",
    "name": "dispatch",
    "code": "public void dispatch(String request) {\n    var command = getCommand(request);\n    command.process();\n  }",
    "comment": "Dispatches the request to the appropriate command.\n\n@param request the request to be handled"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertNull",
    "code": "public static void assertNull(Object object) {\n        if (object != null) {\n            assertNull(\"Expected: <null> but was: \" + object.toString(), object);\n        }\n    }",
    "comment": "Asserts that an object is null. If it isn't an {@link AssertionError} is\nthrown.\nMessage contains: Expected: <null> but was: object\n\n@param object Object to check or <code>null</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/support/ParameterInfo.java",
    "type": "method",
    "name": "get",
    "code": "static ParameterInfo get(ExtensionContext context) {\n\t\treturn context.getStore(NAMESPACE).get(KEY, ParameterInfo.class);\n\t}",
    "comment": "{@return the closest {@code ParameterInfo} instance for the supplied\n{@code ExtensionContext}; potentially {@code null}}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/main/java/com/iluwatar/health/check/HealthCheckRepository.java",
    "type": "method",
    "name": "checkHealth",
    "code": "public Integer checkHealth() {\n    try {\n      return (Integer) entityManager.createNativeQuery(\"SELECT 1\").getSingleResult();\n    } catch (Exception e) {\n      LOGGER.error(\"Health check query failed\", e);\n      throw e;\n    }\n  }",
    "comment": "Checks the health of the database connection by executing a simple query that should always\nreturn 1 if the connection is healthy.\n\n@return 1 if the database connection is healthy, or null otherwise"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "toLowerCase",
    "code": "public static UTF8String toLowerCase(final UTF8String target) {\n    if (target.isFullAscii()) return target.toLowerCaseAscii();\n    return toLowerCaseSlow(target);\n  }",
    "comment": "Convert the input string to lowercase using the ICU root locale rules.\n\n@param target the input string\n@return the lowercase string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaFMClassifierExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n        .builder()\n        .appName(\"JavaFMClassifierExample\")\n        .getOrCreate();\n\n    Dataset<Row> data = spark\n        .read()\n        .format(\"libsvm\")\n        .load(\"data/mllib/sample_libsvm_data.txt\");\n\n    StringIndexerModel labelIndexer = new StringIndexer()\n        .setInputCol(\"label\")\n        .setOutputCol(\"indexedLabel\")\n        .fit(data);\n    MinMaxScalerModel featureScaler = new MinMaxScaler()\n        .setInputCol(\"features\")\n        .setOutputCol(\"scaledFeatures\")\n        .fit(data);\n\n    Dataset<Row>[] splits = data.randomSplit(new double[] {0.7, 0.3});\n        .setStages(new PipelineStage[] {labelIndexer, featureScaler, fm, labelConverter});\n}",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file, converting it to a DataFrame.\nIndex labels, adding metadata to the label column.\nFit on whole dataset to include all labels in index.\nScale features.\nSplit the data into training and test sets (30% held out for testing)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/test/java/org/apache/maven/artifact/versioning/VersionRangeTest.java",
    "type": "method",
    "name": "checkInvalidRange",
    "code": "private void checkInvalidRange(String version) {\n        assertThrows(\n                InvalidVersionSpecificationException.class,\n                () -> VersionRange.createFromVersionSpec(version),\n                \"Version \" + version + \" should have failed to construct\");\n    }",
    "comment": "TODO current policy is to retain the original version - is this correct, do we need strategies or is that\nhandled elsewhere?\nassertEquals( \"1.1\", mergedRange.getRecommendedVersion().toString(), CHECK_VERSION_RECOMMENDATION );\nTODO test reversed restrictions on all below\ntest restricting empty sets"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/DefaultParallelExecutionConfigurationStrategy.java",
    "type": "method",
    "name": "createConfiguration",
    "code": "public ParallelExecutionConfiguration createConfiguration(ConfigurationParameters configurationParameters) {\n\t\t\tString className = configurationParameters.get(CONFIG_CUSTOM_CLASS_PROPERTY_NAME).orElseThrow(\n\t\t\t\t() -> new JUnitException(CONFIG_CUSTOM_CLASS_PROPERTY_NAME + \" must be set\"));\n\t\t\treturn ReflectionSupport.tryToLoadClass(className) //\n\t\t\t\t\t.andThenTry(strategyClass -> {\n\t\t\t\t\t\tPreconditions.condition(\n\t\t\t\t\t\t\tParallelExecutionConfigurationStrategy.class.isAssignableFrom(strategyClass),\n\t\t\t\t\t\t\tCONFIG_CUSTOM_CLASS_PROPERTY_NAME + \" does not implement \"\n\t\t\t\t\t\t\t\t\t+ ParallelExecutionConfigurationStrategy.class);\n\t\t\t\t\t\treturn (ParallelExecutionConfigurationStrategy) ReflectionSupport.newInstance(strategyClass);\n\t\t\t\t\t}) //\n\t\t\t\t\t.andThenTry(strategy -> strategy.createConfiguration(configurationParameters)) //\n\t\t\t\t\t.getOrThrow(cause -> new JUnitException(\n\t\t\t\t\t\t\"Could not create configuration for strategy class: \" + className, cause));\n\t\t}",
    "comment": "Allows the specification of a custom {@link ParallelExecutionConfigurationStrategy}\nimplementation via the mandatory {@value #CONFIG_CUSTOM_CLASS_PROPERTY_NAME}\nconfiguration parameter to determine the desired configuration."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/hash/Murmur3_x86_32.java",
    "type": "method",
    "name": "fmix",
    "code": "private static int fmix(int h1, int length) {\n    h1 ^= length;\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n    return h1;\n  }",
    "comment": "Finalization mix - force all bits of a hash block to avalanche"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "executions",
    "code": "public Executions executions() {\n\t\treturn new Executions(this.events, this.category);\n\t}",
    "comment": "Get the {@link Executions} for the current set of {@linkplain Event events}.\n\n@return an instance of {@code Executions} for the current set of events;\nnever {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleConfigurationTests.java",
    "type": "method",
    "name": "instancePerClassConfiguredViaSystemProperty",
    "code": "void instancePerClassConfiguredViaSystemProperty() {\n\t\tClass<?> testClass = AssumedInstancePerClassTestCase.class;\n\n\t\tperformAssertions(testClass, 1, 1, 0);\n\n\t\tSystem.setProperty(KEY, PER_CLASS.name());\n\t\tperformAssertions(testClass, 2, 0, 1, \"beforeAll\", \"test\", \"afterAll\");\n\t}",
    "comment": "Should fail by default...\nShould pass with the system property set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "saslFallback",
    "code": "public boolean saslFallback() {\n    return conf.getBoolean(\"spark.network.crypto.saslFallback\", true);\n  }",
    "comment": "Whether to fall back to SASL if the new auth protocol fails. Enabled by default for\nbackwards compatibility."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/ArtifactDescriptorUtils.java",
    "type": "method",
    "name": "toPomArtifact",
    "code": "public static Artifact toPomArtifact(Artifact artifact) {\n        Artifact pomArtifact = artifact;\n\n        if (!pomArtifact.getClassifier().isEmpty() || !\"pom\".equals(pomArtifact.getExtension())) {\n            pomArtifact =\n                    new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), \"pom\", artifact.getVersion());\n        }\n\n        return pomArtifact;\n    }",
    "comment": "<strong>Warning:</strong> This is an internal utility class that is only public for technical reasons, it is not part\nof the public API. In particular, this class can be changed or deleted without prior notice.\n\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/pool/ProxyLeakTask.java",
    "type": "method",
    "name": "ProxyLeakTask",
    "code": "NO_LEAK = new ProxyLeakTask() {\n\n         @Override\n         public void run() {}\n\n         @Override\n         public void cancel() {}\n      };",
    "comment": "A Runnable that is scheduled in the future to report leaks.  The ScheduledFuture is\ncancelled if the connection is closed before the leak time expires.\n\n@author Brett Wooldridge"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/logging/LogRecordListener.java",
    "type": "method",
    "name": "stream",
    "code": "public Stream<LogRecord> stream(Level level) {\n\t\t// NOTE: we cannot use org.junit.platform.commons.util.Preconditions here\n\t\t// since that would introduce a package cycle.\n\t\tif (level == null) {\n\t\t\tthrow new JUnitException(\"Level must not be null\");\n\t\t}\n\n\t\treturn stream().filter(logRecord -> logRecord.getLevel() == level);\n\t}",
    "comment": "Get a stream of {@link LogRecord log records} that have been\n{@linkplain #logRecordSubmitted submitted} to this listener by the current\nthread at the given log level.\n\n<p>As stated in the Javadoc for {@code LogRecord}, a submitted\n{@code LogRecord} should not be updated by the client application. Thus,\nthe {@code LogRecords} in the returned stream should only be inspected for\ntesting purposes and not modified in any way.\n\n@param level the log level for which to get the log records; never {@code null}\n@since 1.4\n@see #stream()\n@see #stream(Class)\n@see #stream(Class, Level)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerSession.java",
    "type": "method",
    "name": "config",
    "code": "public Options config(byte[] value) {\n      config = value;\n      return this;\n    }",
    "comment": "Configures the session based on the data found in the provided buffer, which is serialized\nTensorFlow config proto.\n\n<p>Warning: the support of this feature is subject to changes since TensorFlow protos might\nnot be supported on public endpoints in the future.\n\n<p>See also: <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/protobuf/config.proto\">config.proto</a>\n\n@param value a serialized config proto"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-driven-architecture/src/test/java/com/iluwatar/eda/framework/EventDispatcherTest.java",
    "type": "method",
    "name": "testEventDriverPattern",
    "code": "void testEventDriverPattern() {\n\n    var dispatcher = spy(new EventDispatcher());\n    var userCreatedEventHandler = spy(new UserCreatedEventHandler());\n    var userUpdatedEventHandler = spy(new UserUpdatedEventHandler());\n    dispatcher.registerHandler(UserCreatedEvent.class, userCreatedEventHandler);\n    dispatcher.registerHandler(UserUpdatedEvent.class, userUpdatedEventHandler);\n\n    var user = new User(\"iluwatar\");\n\n    var userCreatedEvent = new UserCreatedEvent(user);\n    var userUpdatedEvent = new UserUpdatedEvent(user);\n\n    // fire a userCreatedEvent and verify that userCreatedEventHandler has been invoked.\n    dispatcher.dispatch(userCreatedEvent);\n    verify(userCreatedEventHandler).onEvent(userCreatedEvent);\n    verify(dispatcher).dispatch(userCreatedEvent);\n\n    // fire a userCreatedEvent and verify that userUpdatedEventHandler has been invoked.\n    dispatcher.dispatch(userUpdatedEvent);\n    verify(userUpdatedEventHandler).onEvent(userUpdatedEvent);\n    verify(dispatcher).dispatch(userUpdatedEvent);\n  }",
    "comment": "This unit test should register events and event handlers correctly with the event dispatcher\nand events should be dispatched accordingly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getName",
    "code": "public String getName() {\n        if (getModel().getName() != null) {\n            return getModel().getName();\n        } else {\n            return getArtifactId();\n        }\n    }",
    "comment": "TODO this should not be allowed to be null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/CLIService.java",
    "type": "method",
    "name": "init",
    "code": "public synchronized void init(HiveConf hiveConf) {\n    this.hiveConf = hiveConf;\n    sessionManager = new SessionManager(hiveServer2);\n    addService(sessionManager);\n    if (UserGroupInformation.isSecurityEnabled()) {\n      try {\n        HiveAuthFactory.loginFromKeytab(hiveConf);\n        this.serviceUGI = Utils.getUGI();\n      } catch (IOException e) {\n        throw new ServiceException(\"Unable to login to kerberos with given principal/keytab\", e);\n      } catch (LoginException e) {\n        throw new ServiceException(\"Unable to login to kerberos with given principal/keytab\", e);\n      }\n\n      String principal = hiveConf.getVar(ConfVars.HIVE_SERVER2_SPNEGO_PRINCIPAL);\n      String keyTabFile = hiveConf.getVar(ConfVars.HIVE_SERVER2_SPNEGO_KEYTAB);\n      if (principal.isEmpty() || keyTabFile.isEmpty()) {\n        LOG.info(\"SPNego httpUGI not created, spNegoPrincipal: {}, keytabFile: {}\",\n          MDC.of(LogKeys.PRINCIPAL$.MODULE$, principal),\n          MDC.of(LogKeys.KEYTAB_FILE$.MODULE$, keyTabFile));\n      } else {\n        try {\n          this.httpUGI = HiveAuthFactory.loginFromSpnegoKeytabAndReturnUGI(hiveConf);\n          LOG.info(\"SPNego httpUGI successfully created.\");\n        } catch (IOException e) {\n          LOG.warn(\"SPNego httpUGI creation failed: \", e);\n        }\n      }\n    }\n    try {\n      applyAuthorizationConfigPolicy(hiveConf);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Error applying authorization policy on hive configuration: \"\n          + e.getMessage(), e);\n    }\n    setupBlockedUdfs();\n    super.init(hiveConf);\n  }",
    "comment": "If the hadoop cluster is secure, do a kerberos login for the service from the keytab\nAlso try creating a UGI object for the SPNego principal\ncreates connection to HMS and thus *must* occur after kerberos login above"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertIterableEqualsAssertionsTests.java",
    "type": "method",
    "name": "assertIterableEqualsEqualToSelf",
    "code": "void assertIterableEqualsEqualToSelf() {\n\t\tList<Object> list = listOf(\"a\", 'b', 1, 2);\n\t\tassertIterableEquals(list, list);\n\t\tassertIterableEquals(list, list, \"message\");\n\t\tassertIterableEquals(list, list, () -> \"message\");\n\n\t\tSet<Object> set = setOf(\"a\", 'b', 1, 2);\n\t\tassertIterableEquals(set, set);\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/Scan.java",
    "type": "method",
    "name": "toBatch",
    "code": "default Batch toBatch() {\n    throw new SparkUnsupportedOperationException(\n      \"_LEGACY_ERROR_TEMP_3147\", Map.of(\"description\", description()));\n  }",
    "comment": "Returns the physical representation of this scan for batch query. By default this method throws\nexception, data sources must overwrite this method to provide an implementation, if the\n{@link Table} that creates this scan returns {@link TableCapability#BATCH_READ} support in its\n{@link Table#capabilities()}.\n<p>\nIf the scan supports runtime filtering and implements {@link SupportsRuntimeFiltering},\nthis method may be called multiple times. Therefore, implementations can cache some state\nto avoid planning the job twice.\n\n@throws UnsupportedOperationException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/PathModularization.java",
    "type": "method",
    "name": "addIfFilenameBasedAutomodules",
    "code": "public void addIfFilenameBasedAutomodules(Collection<String> automodulesDetected) {\n        if (descriptors.isEmpty()) {\n            automodulesDetected.add(filename);\n        }\n    }",
    "comment": "If the module has no name, adds the filename of the JAR file in the given collection.\nThis method should be invoked for dependencies placed on {@link JavaPathType#MODULES}\nfor preparing a warning asking to not deploy the build artifact on a public repository.\nIf the module has an explicit name either with a {@code module-info.class} file or with\nan {@code \"Automatic-Module-Name\"} attribute in the {@code META-INF/MANIFEST.MF} file,\nthen this method does nothing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/ClassMap.java",
    "type": "method",
    "name": "populateMethodCache",
    "code": "private void populateMethodCache() {\n        // get all publicly accessible methods\n        Method[] methods = getAccessibleMethods(clazz);\n\n        // map and cache them\n        for (Method method : methods) {\n            // now get the 'public method', the method declared by a\n            // public interface or class (because the actual implementing\n            // class may be a facade...)\n\n            Method publicMethod = getPublicMethod(method);\n\n            // it is entirely possible that there is no public method for\n            // the methods of this class; i.e. in the facade, a method\n            // that isn't on any of the interfaces or superclass\n            // in which case, ignore it. Otherwise, map and cache.\n            if (publicMethod != null) {\n                methodMap.add(publicMethod);\n                methodCache.put(makeMethodKey(publicMethod), publicMethod);\n            }\n        }\n    }",
    "comment": "Populate the Map of direct hits. These\nare taken from all the public methods\nthat our class provides."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3724ExecutionProjectSyncTest.java",
    "type": "method",
    "name": "MavenITmng3724ExecutionProjectSyncTest",
    "code": "public MavenITmng3724ExecutionProjectSyncTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3724\">MNG-3724</a>.\n\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/params/aggregator/DefaultArgumentsAccessorTests.java",
    "type": "method",
    "name": "argumentsMustNotBeNull",
    "code": "void argumentsMustNotBeNull() {\n\t\tassertThrows(PreconditionViolationException.class, () -> defaultArgumentsAccessor(1, (Object[]) null));\n\t}",
    "comment": "Unit tests for {@link DefaultArgumentsAccessor}.\n\n@since 5.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuilder.java",
    "type": "method",
    "name": "hasModelErrors",
    "code": "protected boolean hasModelErrors(ModelProblemCollectorExt problems) {\n        if (problems instanceof DefaultModelProblemCollector collector) {\n            return collector.hasErrors();\n        } else {\n            throw new IllegalStateException();\n        }\n    }",
    "comment": "the default execution path only knows the DefaultModelProblemCollector,\nonly reason it's not in signature is because it's package private"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testBagSumAdd",
    "code": "public void testBagSumAdd() {\n        IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(28, \"USD\"));\n        assertEquals(expected, fMB1.add(fMB2));\n    }",
    "comment": "{[12 CHF][7 USD]} + {[14 CHF][21 USD]} == {[26 CHF][28 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/NativeLibrary.java",
    "type": "method",
    "name": "getMajorVersionNumber",
    "code": "private static String getMajorVersionNumber() {\n    InputStream resourceStream =\n        NativeLibrary.class.getClassLoader().getResourceAsStream(\"tensorflow-version-info\");\n    if (resourceStream == null) {\n      return null;\n    }\n\n    try {\n      Properties props = new Properties();\n      props.load(resourceStream);\n      String version = props.getProperty(\"version\");\n      // expecting a string like 1.14.0, we want to get the first '1'.\n      int dotIndex;\n      if (version == null || (dotIndex = version.indexOf('.')) == -1) {\n        return null;\n      }\n      String majorVersion = version.substring(0, dotIndex);\n      try {\n        Integer.parseInt(majorVersion);\n        return majorVersion;\n      } catch (NumberFormatException unused) {\n        return null;\n      }\n    } catch (IOException e) {\n      log(\"failed to load tensorflow version info.\");\n      return null;\n    }\n  }",
    "comment": "Returns the major version number of this TensorFlow Java API, or {@code null} if it cannot be\ndetermined."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/MethodRulesTest.java",
    "type": "method",
    "name": "runsMethodRuleThatIsReturnedByMethod",
    "code": "public void runsMethodRuleThatIsReturnedByMethod() {\n        ruleWasEvaluated = false;\n        assertThat(testResult(HasMethodReturningMethodRule.class), isSuccessful());\n        assertTrue(ruleWasEvaluated);\n    }",
    "comment": "If there are any public methods annotated with @Rule returning a {@link MethodRule}\nthen it should also be run.\n\n<p>This case has been added with\n<a href=\"https://github.com/junit-team/junit4/issues/589\">Issue #589</a> -\nSupport @Rule for methods works only for TestRule but not for MethodRule"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestWatcher.java",
    "type": "method",
    "name": "testAborted",
    "code": "default void testAborted(ExtensionContext context, Throwable cause) {\n\t\t/* no-op */\n\t}",
    "comment": "Invoked after a test has been aborted.\n\n<p>The default implementation does nothing. Concrete implementations can\noverride this method as appropriate.\n\n@param context the current extension context; never {@code null}\n@param cause the throwable responsible for the test being aborted; may be {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/project/harness/Xpp3DomAttributePointer.java",
    "type": "method",
    "name": "compareChildNodePointers",
    "code": "public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) {\n        return 0;\n    }",
    "comment": "should never happen because attributes have no children"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerOperationBuilder.java",
    "type": "method",
    "name": "setAttr",
    "code": "public EagerOperationBuilder setAttr(String name, Shape[] values) {\n    int[] numDimensions = new int[values.length];\n    int totalNumDimensions = 0;\n    for (int idx = 0; idx < values.length; ++idx) {\n      int n = values[idx].numDimensions();\n      numDimensions[idx] = n;\n      if (n > 0) {\n        totalNumDimensions += n;\n      }\n    }\n    long[] shapes = new long[totalNumDimensions];\n    int shapeIdx = 0;\n    for (Shape shape : values) {\n      if (shape.numDimensions() > 0) {\n        for (long dim : shape.asArray()) {\n          shapes[shapeIdx++] = dim;\n        }\n      }\n    }\n    setAttrShapeList(nativeRef.opHandle, name, shapes, numDimensions);\n    return this;\n  }",
    "comment": "Flatten the shapes into a single array to avoid too much overhead in the\nnative part"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/memory/MemoryLocation.java",
    "type": "method",
    "name": "MemoryLocation",
    "code": "public MemoryLocation(@Nullable Object obj, long offset) {\n    this.obj = obj;\n    this.offset = offset;\n  }",
    "comment": "A memory location. Tracked either by a memory address (with off-heap allocation),\nor by an offset from a JVM object (on-heap allocation)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/entity/Truck.java",
    "type": "method",
    "name": "Truck",
    "code": "public Truck(String manufacturer, String model, int loadCapacity, int towingCapacity) {\n    super(manufacturer, model, loadCapacity);\n    this.towingCapacity = towingCapacity;\n  }",
    "comment": "A class that extends the PassengerVehicle class and provides the concrete inheritance\nimplementation of the Car.\n\n@see TransportVehicle TransportVehicle\n@see Vehicle Vehicle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "allocateLongBuffer",
    "code": "public static LongBuffer allocateLongBuffer(int numElements) {\n    return ByteBuffer.allocateDirect(numElements * LONG_SIZE_BYTES)\n        .order(ByteOrder.nativeOrder())\n        .asLongBuffer();\n  }",
    "comment": "Allocates a new direct {@link java.nio.LongBuffer} with native byte order with specified\n\n@param numElements capacity (number of elements) of result buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java",
    "type": "method",
    "name": "doSomething",
    "code": "public void doSomething() {\n\t\t\tcallSequence.add(getClass().getSimpleName() + \" :: doSomething()\");\n\t\t}",
    "comment": "This interface intentionally does not implement a supported {@link Extension} API."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Byte unexpected, byte actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Byte) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/InMemoryCartRepository.java",
    "type": "method",
    "name": "addItemToCart",
    "code": "public void addItemToCart(final String userId, final Product product, final int quantity) {\n    List<Cart> cart = userCarts.getOrDefault(userId, new ArrayList<>());\n    cart.add(new Cart(product, quantity));\n    userCarts.put(userId, cart);\n  }",
    "comment": "Adds an item to the user's cart.\n\n@param userId The ID of the user.\n@param product The product to be added.\n@param quantity The quantity of the product."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/FixedLengthRowBasedKeyValueBatch.java",
    "type": "method",
    "name": "getKeyOffsetForFixedLengthRecords",
    "code": "private long getKeyOffsetForFixedLengthRecords(int rowId) {\n    return recordStartOffset + rowId * (long) recordLength;\n  }",
    "comment": "An implementation of `RowBasedKeyValueBatch` in which all key-value records have same length.\n\nThe format for each record looks like this:\n[UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n[8 bytes pointer to next]\nThus, record length = klen + vlen + 8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/AbstractMavenIntegrationTestCase.java",
    "type": "method",
    "name": "getJavaVersion",
    "code": "protected static ArtifactVersion getJavaVersion() {\n        if (javaVersion == null) {\n            String version = System.getProperty(\"java.version\");\n            version = version.replaceAll(\"[_-]\", \".\");\n            Matcher matcher =\n                    Pattern.compile(\"(?s).*?(([0-9]+\\\\.[0-9]+)(\\\\.[0-9]+)?).*\").matcher(version);\n            if (matcher.matches()) {\n                version = matcher.group(1);\n            }\n            javaVersion = new DefaultArtifactVersion(version);\n        }\n        return javaVersion;\n    }",
    "comment": "Gets the Java version used to run this test.\n\n@return The Java version, never <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeCustomDefaultField",
    "code": "void cleanupModeCustomDefaultField() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.configurationParameter(TempDir.DEFAULT_CLEANUP_MODE_PROPERTY_NAME, \"never\")//\n\t\t\t\t\t.selectors(selectMethod(DefaultFieldCase.class, \"testDefaultField\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(defaultFieldDir).exists();\n\t\t}",
    "comment": "Ensure that a custom, global cleanup mode is used for fields.\n<p/>\nExpect the TempDir NOT to be cleaned up if set to NEVER."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-queue/src/main/java/com/iluwatar/event/queue/Audio.java",
    "type": "method",
    "name": "isServiceRunning",
    "code": "public synchronized boolean isServiceRunning() {\n    return updateThread != null && updateThread.isAlive();\n  }",
    "comment": "This method check the Update Method's thread is started.\n\n@return boolean"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "copyTo",
    "code": "public <U> U copyTo(U dst) {\n    throwExceptionIfTypeIsIncompatible(dst);\n    readNDArray(getNativeHandle(), dst);\n    return dst;\n  }",
    "comment": "Copies the contents of the tensor to {@code dst} and returns {@code dst}.\n\n<p>For non-scalar tensors, this method copies the contents of the underlying tensor to a Java\narray. For scalar tensors, use one of {@link #bytesValue()}, {@link #floatValue()}, {@link\n#doubleValue()}, {@link #intValue()}, {@link #longValue()} or {@link #booleanValue()} instead.\nThe type and shape of {@code dst} must be compatible with the tensor. For example:\n\n<pre>{@code\nint matrix[2][2] = {{1,2},{3,4}};\ntry(Tensor t = Tensor.create(matrix)) {\n// Succeeds and prints \"3\"\nint[][] copy = new int[2][2];\nSystem.out.println(t.copyTo(copy)[1][0]);\n\n// Throws IllegalArgumentException since the shape of dst does not match the shape of t.\nint[][] dst = new int[4][1];\nt.copyTo(dst);\n}\n}</pre>\n\n@throws IllegalArgumentException if the tensor is a scalar or if {@code dst} is not compatible\nwith the tensor (for example, mismatched data types or shapes)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/config/PrefixedConfigurationParametersTests.java",
    "type": "method",
    "name": "preconditions",
    "code": "void preconditions() {\n\t\tassertThrows(PreconditionViolationException.class, () -> new PrefixedConfigurationParameters(null, \"example.\"));\n\t\tassertThrows(PreconditionViolationException.class, () -> new PrefixedConfigurationParameters(delegate, null));\n\t\tassertThrows(PreconditionViolationException.class, () -> new PrefixedConfigurationParameters(delegate, \"\"));\n\t\tassertThrows(PreconditionViolationException.class, () -> new PrefixedConfigurationParameters(delegate, \"    \"));\n\t}",
    "comment": "Unit tests for {@link PrefixedConfigurationParameters}.\n\n@since 1.3"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/entity/Train.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n    return \"Train{\" + super.toString() + '}';\n  }",
    "comment": "Overridden the toString method to specify the Vehicle object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/InterceptingExecutableInvokerTests.java",
    "type": "method",
    "name": "invokeMethod",
    "code": "void invokeMethod() {\n\t\tnewInvoker().invoke(this.method, this.instance, this.extensionContext, this.extensionRegistry,\n\t\t\tpassthroughInterceptor());\n\t}",
    "comment": "Unit tests for {@link InterceptingExecutableInvoker}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/function/Try.java",
    "type": "method",
    "name": "orElseTry",
    "code": "public Try<V> orElseTry(Callable<V> action) {\n\t\t\treturn this;\n\t\t}",
    "comment": "don't call action because this Try is a success"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "appendBooleans",
    "code": "public final int appendBooleans(int count, byte src, int offset) {\n    reserve(elementsAppended + count);\n    int result = elementsAppended;\n    putBooleans(elementsAppended, count, src, offset);\n    elementsAppended += count;\n    return result;\n  }",
    "comment": "Append bits from [src[offset], src[offset + count])\nsrc must contain bit-packed 8 booleans in the byte."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/observer/src/main/java/com/iluwatar/observer/Weather.java",
    "type": "method",
    "name": "Weather",
    "code": "public Weather() {\n    observers = new ArrayList<>();\n    currentWeather = WeatherType.SUNNY;\n  }",
    "comment": "Weather can be observed by implementing {@link WeatherObserver} interface and registering as\nlistener."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeArrayData.java",
    "type": "method",
    "name": "calculateHeaderPortionInBytes",
    "code": "public static int calculateHeaderPortionInBytes(int numFields) {\n    return (int)calculateHeaderPortionInBytes((long)numFields);\n  }",
    "comment": "An Unsafe implementation of Array which is backed by raw memory instead of Java objects.\n\nEach array has four parts:\n[numElements][null bits][values or offset&length][variable length portion]\n\nThe `numElements` is 8 bytes storing the number of elements of this array.\n\nIn the `null bits` region, we store 1 bit per element, represents whether an element is null\nIts total size is ceil(numElements / 8) bytes, and it is aligned to 8-byte boundaries.\n\nIn the `values or offset&length` region, we store the content of elements. For fields that hold\nfixed-length primitive types, such as long, double, or int, we store the value directly\nin the field. The whole fixed-length portion (even for byte) is aligned to 8-byte boundaries.\nFor fields with non-primitive or variable-length values, we store a relative offset\n(w.r.t. the base address of the array) that points to the beginning of the variable-length field\nand length (they are combined into a long). For variable length portion, each is aligned\nto 8-byte boundaries.\n\nInstances of `UnsafeArrayData` act as pointers to row data stored in this format."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-driven-architecture/src/main/java/com/iluwatar/eda/framework/EventDispatcher.java",
    "type": "method",
    "name": "registerHandler",
    "code": "public <E extends Event> void registerHandler(Class<E> eventType, Handler<E> handler) {\n    handlers.put(eventType, handler);\n  }",
    "comment": "Links an {@link Event} to a specific {@link Handler}.\n\n@param eventType The {@link Event} to be registered\n@param handler The {@link Handler} that will be handling the {@link Event}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventStatistics.java",
    "type": "method",
    "name": "skipped",
    "code": "public EventStatistics skipped(long expected) {\n\t\tthis.executables.add(() -> assertEquals(expected, this.events.skipped().count(), \"skipped\"));\n\t\treturn this;\n\t}",
    "comment": "Specify the number of expected <em>skipped</em> events.\n\n@param expected the expected number of events\n@return this {@code EventStatistics} for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertInstanceOf",
    "code": "public static <T> T assertInstanceOf(Class<T> expectedType, Object actualValue, Supplier<String> messageSupplier) {\n\t\treturn AssertInstanceOf.assertInstanceOf(expectedType, actualValue, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that the supplied {@code actualValue} is an instance of the\n{@code expectedType}.\n\n<p>Like the {@code instanceof} operator a {@code null} value is not\nconsidered to be of the {@code expectedType} and does not pass the assertion.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/templateview/src/test/java/com/iluwatar/templateview/HomePageViewTest.java",
    "type": "method",
    "name": "testRenderDynamicContent",
    "code": "void testRenderDynamicContent() {\n    HomePageView homePage = spy(HomePageView.class);\n\n    homePage.renderDynamicContent();\n\n    verify(homePage).renderDynamicContent();\n  }",
    "comment": "Create a spy for HomePageView\nRender dynamic content for HomePageView\nVerify that the correct message is logged"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/PackageNameUtils.java",
    "type": "method",
    "name": "getPackageName",
    "code": "static String getPackageName(Class<?> clazz) {\n\t\tPackage p = clazz.getPackage();\n\t\tif (p != null) {\n\t\t\treturn p.getName();\n\t\t}\n\t\tString className = clazz.getName();\n\t\tint index = className.lastIndexOf('.');\n\t\treturn index == -1 ? DEFAULT_PACKAGE_NAME : className.substring(0, index);\n\t}",
    "comment": "Collection of utilities for working with package names.\n\n<h2>DISCLAIMER</h2>\n\n<p>These utilities are intended solely for usage within the JUnit framework\nitself. <strong>Any usage by external parties is not supported.</strong>\nUse at your own risk!\n\n@since 1.11.3"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "clusterBy",
    "code": "static TableChange clusterBy(NamedReference[] clusteringColumns) {\n    return new ClusterBy(clusteringColumns);\n  }",
    "comment": "Create a TableChange for changing clustering columns for a table.\n\n@param clusteringColumns clustering columns to change to. Each clustering column represents\nfield names.\n@return a TableChange for this assignment"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assume.java",
    "type": "method",
    "name": "assumeNoException",
    "code": "public static void assumeNoException(Throwable e) {\n        assumeThat(e, nullValue());\n    }",
    "comment": "Use to assume that an operation completes normally.  If {@code e} is non-null, the test will halt and be ignored.\n\nFor example:\n<pre>\n\\@Test public void parseDataFile() {\nDataFile file;\ntry {\nfile = DataFile.open(\"sampledata.txt\");\n} catch (IOException e) {\n// stop test and ignore if data can't be opened\nassumeNoException(e);\n}\n// ...\n}\n</pre>\n\n@param e if non-null, the offending exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "setAppName",
    "code": "public T setAppName(String appName) {\n    checkNotNull(appName, \"appName\");\n    builder.appName = appName;\n    return self();\n  }",
    "comment": "Set the application name.\n\n@param appName Application name.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java",
    "type": "method",
    "name": "nestedTestsAreCorrectlyDiscovered",
    "code": "void nestedTestsAreCorrectlyDiscovered() {\n\t\tLauncherDiscoveryRequest request = request().selectors(selectClass(TestCaseWithNesting.class)).build();\n\t\tTestDescriptor engineDescriptor = discoverTests(request).getEngineDescriptor();\n\t\tassertEquals(5, engineDescriptor.getDescendants().size(), \"# resolved test descriptors\");\n\t}",
    "comment": "Integration tests that verify support for {@linkplain Nested nested contexts}\nin the {@link JupiterTestEngine}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/monad/src/main/java/com/iluwatar/monad/Validator.java",
    "type": "method",
    "name": "of",
    "code": "public static <T> Validator<T> of(T t) {\n    return new Validator<>(Objects.requireNonNull(t));\n  }",
    "comment": "Creates validator against given object.\n\n@param t object to be validated\n@param <T> object's type\n@return new instance of a validator"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assume.java",
    "type": "method",
    "name": "assumeFalse",
    "code": "public static void assumeFalse(boolean b) {\n        assumeThat(b, is(false));\n    }",
    "comment": "The inverse of {@link #assumeTrue(boolean)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "fetchCollation",
    "code": "private static Collation fetchCollation(int collationId) {\n        // User-defined collations cannot produce a `Collation` instance.\n        assert collationId == INDETERMINATE_COLLATION_ID ||\n          getDefinitionOrigin(collationId) == DefinitionOrigin.PREDEFINED;\n        if (collationId == UTF8_BINARY_COLLATION_ID) {\n          // Skip cache.\n          return CollationSpecUTF8.UTF8_BINARY_COLLATION;\n        } else if (collationMap.containsKey(collationId)) {\n          // Already in cache.\n          return collationMap.get(collationId);\n        } else if (collationId == INDETERMINATE_COLLATION_ID) {\n          return INDETERMINATE_COLLATION;\n        } else {\n          // Build `Collation` instance and put into cache.\n          CollationSpec spec;\n          ImplementationProvider implementationProvider = getImplementationProvider(collationId);\n          if (implementationProvider == ImplementationProvider.UTF8_BINARY) {\n            spec = CollationSpecUTF8.fromCollationId(collationId);\n          } else {\n            spec = CollationSpecICU.fromCollationId(collationId);\n          }\n          Collation collation = spec.buildCollation();\n          collationMap.put(collationId, collation);\n          return collation;\n        }\n      }",
    "comment": "Main entry point for retrieving `Collation` instance from collation ID."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventStatistics.java",
    "type": "method",
    "name": "started",
    "code": "public EventStatistics started(long expected) {\n\t\tthis.executables.add(() -> assertEquals(expected, this.events.started().count(), \"started\"));\n\t\treturn this;\n\t}",
    "comment": "Specify the number of expected <em>started</em> events.\n\n@param expected the expected number of events\n@return this {@code EventStatistics} for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-to-worker/src/main/java/com/iluwatar/servicetoworker/GiantController.java",
    "type": "method",
    "name": "setCommand",
    "code": "public void setCommand(Command s, int index) {\n    dispatcher.performAction(s, index);\n  }",
    "comment": "Sets command to control the dispatcher.\n\n@param s the s\n@param index the index"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/CustomHealthIndicatorTest.java",
    "type": "method",
    "name": "whenEvictHealthCache_thenCacheIsCleared",
    "code": "void whenEvictHealthCache_thenCacheIsCleared() {\n    doNothing().when(cache).clear();\n\n    customHealthIndicator.evictHealthCache();\n\n    verify(cache, times(1)).clear();\n    verify(cacheManager, times(1)).getCache(\"health-check\");\n  }",
    "comment": "Test case for the `evictHealthCache()` method.\n\n<p>Asserts that when the `evictHealthCache()` method is called, the health cache is cleared."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/test/java/org/apache/maven/artifact/versioning/ComparableVersionTest.java",
    "type": "method",
    "name": "testVersionsEqual",
    "code": "void testVersionsEqual() {\n        newComparable(\"1.0-alpha\");\n        checkVersionsEqual(\"1\", \"1\");\n        checkVersionsEqual(\"1\", \"1.0\");\n        checkVersionsEqual(\"1\", \"1.0.0\");\n        checkVersionsEqual(\"1.0\", \"1.0.0\");\n        checkVersionsEqual(\"1\", \"1-0\");\n        checkVersionsEqual(\"1\", \"1.0-0\");\n        checkVersionsEqual(\"1.0\", \"1.0-0\");\n        checkVersionsEqual(\"1a\", \"1-a\");\n        checkVersionsEqual(\"1a\", \"1.0-a\");\n        checkVersionsEqual(\"1a\", \"1.0.0-a\");\n        checkVersionsEqual(\"1.0a\", \"1-a\");\n        checkVersionsEqual(\"1.0.0a\", \"1-a\");\n        checkVersionsEqual(\"1x\", \"1-x\");\n        checkVersionsEqual(\"1x\", \"1.0-x\");\n        checkVersionsEqual(\"1x\", \"1.0.0-x\");\n        checkVersionsEqual(\"1.0x\", \"1-x\");\n        checkVersionsEqual(\"1.0.0x\", \"1-x\");\n        checkVersionsEqual(\"1cr\", \"1rc\");\n\n        checkVersionsEqual(\"1a1\", \"1-alpha-1\");\n        checkVersionsEqual(\"1b2\", \"1-beta-2\");\n        checkVersionsEqual(\"1m3\", \"1-milestone-3\");\n\n        checkVersionsEqual(\"1X\", \"1x\");\n        checkVersionsEqual(\"1A\", \"1a\");\n        checkVersionsEqual(\"1B\", \"1b\");\n        checkVersionsEqual(\"1M\", \"1m\");\n        checkVersionsEqual(\"1Cr\", \"1Rc\");\n        checkVersionsEqual(\"1cR\", \"1rC\");\n        checkVersionsEqual(\"1m3\", \"1Milestone3\");\n        checkVersionsEqual(\"1m3\", \"1MileStone3\");\n        checkVersionsEqual(\"1m3\", \"1MILESTONE3\");\n    }",
    "comment": "no separator between number and character\nspecial \"aliases\" a, b and m for alpha, beta and milestone\ncase insensitive"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/HealthEndpointIntegrationTest.java",
    "type": "method",
    "name": "livenessEndpointShouldReturnUpStatus",
    "code": "void livenessEndpointShouldReturnUpStatus() {\n    // Make the HTTP request to the liveness endpoint\n    Response response = given(requestSpec).get(getEndpointBasePath() + \"/liveness\").andReturn();\n\n    // Log the response details\n    logResponseDetails(response);\n\n    // Check if the status is 503 (SERVICE_UNAVAILABLE)\n    if (response.getStatusCode() == HttpStatus.SERVICE_UNAVAILABLE.value()) {\n      LOGGER.warn(\n          \"Liveness endpoint returned 503 Service Unavailable. This may be due to CI pipeline \"\n              + \"configuration. Please check the CI pipeline logs.\");\n      // If status is 503, the test passes without further checks\n      response\n          .then()\n          .assertThat()\n          .statusCode(HttpStatus.SERVICE_UNAVAILABLE.value())\n          .log()\n          .all(); // Log the entire response for visibility\n      return;\n    }\n\n    // If status is 200, proceed with additional checks\n    response.then().assertThat().statusCode(HttpStatus.OK.value()).body(\"status\", equalTo(\"UP\"));\n\n    // Check for \"DOWN\" status and high CPU load\n    if (\"DOWN\".equals(response.path(\"status\"))) {\n      LOGGER.error(\"Liveness endpoint response: \" + response.getBody().asString());\n      LOGGER.error(\"Liveness endpoint status: \" + response.path(\"status\"));\n      LOGGER.error(\n          \"High CPU load detected: \" + response.path(\"components.cpu.details.processCpuLoad\"));\n    }\n  }",
    "comment": "Test that the liveness endpoint returns the UP status.\n\n<p>The liveness endpoint is used to indicate whether the application is still running and\nresponsive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3641ProfileActivationWarningTest.java",
    "type": "method",
    "name": "findWarning",
    "code": "private String findWarning(List<String> logLines, String profileId) {\n        Pattern pattern = Pattern.compile(\"(?i).*profile\\\\s.*\\\\Q\" + profileId + \"\\\\E.*\\\\snot\\\\s.*activated.*\");\n\n        for (String logLine : logLines) {\n            if (pattern.matcher(logLine).matches()) {\n                return logLine;\n            }\n        }\n\n        return null;\n    }",
    "comment": "(0) Initialize.\nDelete this artifact. Just in case.\n(1) make sure the profile is found. Must not contain a warning.\n(2) make sure the profile was not found and a warning was printed.\n(3) make sure the first profile is found while the other is not and a warning was printed\naccordingly.\n(4) make sure the warning is only printed when the profile is missing in all projects\n(5) make sure the profile is found in subproject. Must not contain a warning.\n(6) make sure the profile is found from parent in subproject. Must not contain a warning."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/main/java/com/iluwatar/async/method/invocation/ThreadAsyncExecutor.java",
    "type": "method",
    "name": "setException",
    "code": "void setException(Exception exception) {\n      this.exception = exception;\n      this.state = FAILED;\n      if (hasCallback()) {\n        callback.onError(exception);\n      }\n      synchronized (lock) {\n        lock.notifyAll();\n      }\n    }",
    "comment": "Sets the exception from failed execution and executes callback if available. Notifies any\nthread waiting for completion.\n\n@param exception exception of the failed task"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "strong",
    "code": "default MessageBuilder strong(Object message) {\n        return style(\".\" + Constants.MAVEN_STYLE_STRONG_NAME + \":-\" + Constants.MAVEN_STYLE_STRONG_DEFAULT, message);\n    }",
    "comment": "Append message content in strong style.\nBy default, bold\n\n@param message the message to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/test/java/com/iluwatar/identitymap/PersonFinderTest.java",
    "type": "method",
    "name": "personFoundInDB",
    "code": "void personFoundInDB() {\n    PersonFinder personFinder = new PersonFinder();\n    PersonDbSimulatorImplementation db = new PersonDbSimulatorImplementation();\n    Person person1 = new Person(1, \"John\", 27304159);\n    Person person2 = new Person(2, \"Thomas\", 42273631);\n    Person person3 = new Person(3, \"Arthur\", 27489171);\n    Person person4 = new Person(4, \"Finn\", 20499078);\n    Person person5 = new Person(5, \"Michael\", 40599078);\n    db.insert(person1);\n    db.insert(person2);\n    db.insert(person3);\n    db.insert(person4);\n    db.insert(person5);\n    personFinder.setDb(db);\n\n    Assertions.assertEquals(\n        person1, personFinder.getPerson(1), \"Find person returns incorrect record.\");\n    Assertions.assertEquals(\n        person3, personFinder.getPerson(3), \"Find person returns incorrect record.\");\n    Assertions.assertEquals(\n        person2, personFinder.getPerson(2), \"Find person returns incorrect record.\");\n    Assertions.assertEquals(\n        person5, personFinder.getPerson(5), \"Find person returns incorrect record.\");\n    Assertions.assertEquals(\n        person4, personFinder.getPerson(4), \"Find person returns incorrect record.\");\n  }",
    "comment": "personFinderInstance\ninit database for our personFinder\nDummy persons\nAdd data to the database."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/logging/LoggerFactory.java",
    "type": "method",
    "name": "removeListener",
    "code": "public static void removeListener(LogRecordListener listener) {\n\t\tlisteners.remove(listener);\n\t}",
    "comment": "Remove the supplied {@link LogRecordListener} from the set of registered\nlisteners."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "trim",
    "code": "public UTF8String trim(UTF8String trimString) {\n    if (trimString != null) {\n      return trimLeft(trimString).trimRight(trimString);\n    } else {\n      return null;\n    }\n  }",
    "comment": "Trims instances of the given trim string from both ends of this string.\n\n@param trimString the trim character string\n@return this string with no occurrences of the trim string at the start or end, or `null`\nif `trimString` is `null`"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/VehicleDatabase.java",
    "type": "method",
    "name": "getVehicle",
    "code": "public Vehicle getVehicle(int id) {\n    return vehicleTable.get(id);\n  }",
    "comment": "Retrieves a vehicle by its ID.\n\n@param id the ID of the vehicle\n@return the vehicle with the given ID, or null if not found"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/virtual-proxy/src/main/java/com/iluwatar/virtual/proxy/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    ExpensiveObject videoObject = new VideoObjectProxy();\n    videoObject.process(); // The first call creates and plays the video\n    videoObject.process(); // Subsequent call uses the already created object\n  }",
    "comment": "The entry point of the application.\n\n@param args the command line arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/StylizeActivity.java",
    "type": "method",
    "name": "onPreviewSizeChosen",
    "code": "public void onPreviewSizeChosen(final Size size, final int rotation) {\n    final float textSizePx = TypedValue.applyDimension(\n        TypedValue.COMPLEX_UNIT_DIP, TEXT_SIZE_DIP, getResources().getDisplayMetrics());\n    borderedText = new BorderedText(textSizePx);\n    borderedText.setTypeface(Typeface.MONOSPACE);\n\n    inferenceInterface = new TensorFlowInferenceInterface(getAssets(), MODEL_FILE);\n\n    previewWidth = size.getWidth();\n    previewHeight = size.getHeight();\n\n    final Display display = getWindowManager().getDefaultDisplay();\n    final int screenOrientation = display.getRotation();\n\n    LOGGER.i(\"Sensor orientation: %d, Screen orientation: %d\", rotation, screenOrientation);\n\n    sensorOrientation = rotation + screenOrientation;\n\n    addCallback(\n        new DrawCallback() {\n        });\n\n    adapter = new ImageGridAdapter();\n    grid = (GridView) findViewById(R.id.grid_layout);\n    grid.setAdapter(adapter);\n    grid.setOnTouchListener(gridTouchAdapter);\n\n    UiModeManager uiModeManager = (UiModeManager) getSystemService(UI_MODE_SERVICE);\n    if (uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION) {\n      DisplayMetrics displayMetrics = new DisplayMetrics();\n      getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);\n      int styleSelectorHeight = displayMetrics.heightPixels;\n      int styleSelectorWidth = displayMetrics.widthPixels - styleSelectorHeight;\n      RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(styleSelectorWidth, ViewGroup.LayoutParams.MATCH_PARENT);\n\n      int numOfStylePerRow = 3;\n      while (styleSelectorWidth / numOfStylePerRow * Math.ceil((float) (adapter.getCount() - 2) / numOfStylePerRow) > styleSelectorHeight) {\n        numOfStylePerRow++;\n      }\n      grid.setNumColumns(numOfStylePerRow);\n      layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);\n      grid.setLayoutParams(layoutParams);\n      adapter.buttons.clear();\n    }\n\n    setStyle(adapter.items[0], 1.0f);\n  }",
    "comment": "Change UI on Android TV\nCalculate number of style in a row, so all the style can show up without scrolling"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeExternalSorter.java",
    "type": "method",
    "name": "cleanupResources",
    "code": "public void cleanupResources() {\n    // To avoid deadlocks, we can't call methods that lock the TaskMemoryManager\n    // (such as various free() methods) while synchronizing on the UnsafeExternalSorter.\n    // Instead, we will manipulate UnsafeExternalSorter state inside the synchronized\n    // lock and perform the actual free() calls outside it.\n    UnsafeInMemorySorter inMemSorterToFree = null;\n    List<MemoryBlock> pagesToFree = null;\n    try {\n      synchronized (this) {\n        deleteSpillFiles();\n        pagesToFree = clearAndGetAllocatedPagesToFree();\n        if (inMemSorter != null) {\n          inMemSorterToFree = inMemSorter;\n          inMemSorter = null;\n        }\n      }\n    } finally {\n      for (MemoryBlock pageToFree : pagesToFree) {\n        freePage(pageToFree);\n      }\n      if (inMemSorterToFree != null) {\n        inMemSorterToFree.freeMemory();\n      }\n    }\n  }",
    "comment": "Frees this sorter's in-memory data structures and cleans up its spill files."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-configuration/src/main/java/org/apache/maven/plugin/coreit/DeprecatedConfigMojo.java",
    "type": "method",
    "name": "dumpConfiguration",
    "code": "private void dumpConfiguration(Properties props) {\n        PropertiesUtil.serialize(props, \"deprecatedParam\", deprecatedParam);\n        PropertiesUtil.serialize(props, \"deprecatedParam2\", deprecatedParam2);\n        PropertiesUtil.serialize(props, \"deprecatedParamWithDefaultConstant\", deprecatedParamWithDefaultConstant);\n        PropertiesUtil.serialize(props, \"deprecatedParamWithDefaultEvaluate\", deprecatedParamWithDefaultEvaluate);\n        PropertiesUtil.serialize(props, \"deprecatedArray\", deprecatedArray);\n        PropertiesUtil.serialize(props, \"deprecatedArrayWithDefaults\", deprecatedArrayWithDefaults);\n        PropertiesUtil.serialize(props, \"deprecatedProperties\", deprecatedProperties);\n        PropertiesUtil.serialize(props, \"deprecatedList\", deprecatedList);\n        PropertiesUtil.serialize(props, \"deprecatedListWithDefaults\", deprecatedListWithDefaults);\n        PropertiesUtil.serialize(props, \"deprecatedMap\", deprecatedMap);\n    }",
    "comment": "Dumps the mojo configuration into the specified properties.\n\n@param props The properties to dump the configuration into, must not be <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/thrift/ThriftCLIService.java",
    "type": "method",
    "name": "isKerberosAuthMode",
    "code": "private boolean isKerberosAuthMode() {\n    return cliService.getHiveConf().getVar(ConfVars.HIVE_SERVER2_AUTHENTICATION)\n        .equalsIgnoreCase(HiveAuthFactory.AuthTypes.KERBEROS.toString());\n  }",
    "comment": "Verify proxy user privilege of the realUser for the proxyUser"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-executor/src/test/java/org/apache/maven/cling/executor/impl/ToolboxToolTest.java",
    "type": "method",
    "name": "artifactPath3",
    "code": "void artifactPath3(ExecutorHelper.Mode mode) {\n        ExecutorHelper helper = new HelperImpl(\n                mode,\n                mvn3ExecutorRequestBuilder().build().installationDirectory(),\n                userHome,\n                MavenExecutorTestSupport.EMBEDDED_MAVEN_EXECUTOR,\n                MavenExecutorTestSupport.FORKED_MAVEN_EXECUTOR);\n        String path = new ToolboxTool(helper)\n                .artifactPath(helper.executorRequest(), \"aopalliance:aopalliance:1.0\", \"central\");\n        assertTrue(\n                path.endsWith(\"aopalliance\" + File.separator + \"aopalliance\" + File.separator + \"1.0\" + File.separator\n                        + \"aopalliance-1.0.jar\"),\n                \"path=\" + path);\n    }",
    "comment": "split repository: assert \"ends with\" as split may introduce prefixes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/experimental/theories/runner/TheoriesPerformanceTest.java",
    "type": "method",
    "name": "tryCombinationsQuickly",
    "code": "public void tryCombinationsQuickly() {\n        assumeTrue(TESTING_PERFORMANCE);\n        assertThat(testResult(UpToTen.class), isSuccessful());\n    }",
    "comment": "If we do not share the same instance of TestClass, repeatedly parsing the\nclass's annotations looking for @Befores and @Afters gets really costly.\n\nLikewise, the TestClass must be passed into AllMembersSupplier, or the\nannotation parsing is again costly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/manipulation/AlphanumericOrdering.java",
    "type": "method",
    "name": "create",
    "code": "public Ordering create(Ordering.Context context) {\n        return INSTANCE;\n    }",
    "comment": "An ordering that orders tests alphanumerically by test name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/ByteArray.java",
    "type": "method",
    "name": "lpad",
    "code": "public static byte[] lpad(byte[] bytes, int len, byte[] pad) {\n    if (bytes == null || pad == null) return null;\n    if (len == 0) return EMPTY_BYTE;\n    if (pad.length == 0) return padWithEmptyPattern(bytes, len);\n    final byte[] result = new byte[len];\n    final int minLen = Math.min(len, bytes.length);\n    Platform.copyMemory(\n      bytes, Platform.BYTE_ARRAY_OFFSET,\n      result, Platform.BYTE_ARRAY_OFFSET + len - minLen,\n      minLen);\n    if (bytes.length < len) {\n      fillWithPattern(result, 0, len - bytes.length, pad);\n    }\n    return result;\n  }",
    "comment": "Left-pads the input byte sequence using the provided padding pattern.\nIn the special case that the padding pattern is empty, the resulting byte sequence\ncontains the first `len` bytes of the input if they exist, or is a copy of the input\nbyte sequence otherwise.\nFor padding patterns with positive byte length, the resulting byte sequence's byte length is\nequal to `len`. If the input byte sequence is not less than `len` bytes, its first `len` bytes\nare returned. Otherwise, the remaining missing bytes are filled in with the provided pattern.\nIf the input length is 0, return the empty byte sequence.\nThe padding pattern is empty.\nThe general case.\n1. Copy the first `len` bytes of the input byte sequence into the output if they exist.\n2. If the input has less than `len` bytes, fill in the rest using the provided pattern."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProjectBuilderRequest.java",
    "type": "method",
    "name": "repositories",
    "code": "public ProjectBuilderRequestBuilder repositories(List<RemoteRepository> repositories) {\n            this.repositories = repositories;\n            return this;\n        }",
    "comment": "Sets the list of remote repositories to use for resolving dependencies during project building.\nThese repositories will be used in addition to any repositories defined in the project itself.\n\n@param repositories the list of remote repositories\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/ParquetEnum.java",
    "type": "method",
    "name": "getSchema",
    "code": "public org.apache.avro.Schema getSchema() { return SCHEMA$; }\n  public java.lang.Object get(int field$) {\n    switch (field$) {\n    case 0: return suit;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumWriter.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExternalBlockStoreClient.java",
    "type": "method",
    "name": "init",
    "code": "public void init(String appId) {\n    this.appId = appId;\n    TransportContext context = new TransportContext(\n      transportConf, new NoOpRpcHandler(), true, true);\n    List<TransportClientBootstrap> bootstraps = Lists.newArrayList();\n    if (authEnabled) {\n      bootstraps.add(new AuthClientBootstrap(transportConf, appId, secretKeyHolder));\n    }\n    clientFactory = context.createClientFactory(bootstraps);\n  }",
    "comment": "Initializes the BlockStoreClient, specifying this Executor's appId.\nMust be called before any other method on the BlockStoreClient."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "failed",
    "code": "public Events failed() {\n\t\treturn new Events(finishedEventsByStatus(Status.FAILED), this.category + \" Failed\");\n\t}",
    "comment": "Get the failed {@link Events} contained in this {@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertLinesMatch",
    "code": "public static void assertLinesMatch(Stream<String> expectedLines, Stream<String> actualLines, String message) {\n\t\tAssertLinesMatch.assertLinesMatch(expectedLines, actualLines, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} stream of {@linkplain String}s matches {@code actual}\nstream.\n\n<p>Find a detailed description of the matching algorithm in {@link #assertLinesMatch(List, List)}.\n\n<p>Fails with the supplied failure {@code message} and the generated message.\n\n<p>Note: An implementation of this method may consume all lines of both streams eagerly and\ndelegate the evaluation to {@link #assertLinesMatch(List, List)}.\n\n@since 5.7\n@see #assertLinesMatch(List, List)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/component/src/main/java/com/iluwatar/component/component/inputcomponent/PlayerInputComponent.java",
    "type": "method",
    "name": "update",
    "code": "public void update(GameObject gameObject, int e) {\n    switch (e) {\n      case KeyEvent.KEY_LOCATION_LEFT -> {\n        gameObject.updateVelocity(-WALK_ACCELERATION);\n        LOGGER.info(gameObject.getName() + \" has moved left.\");\n      }\n      case KeyEvent.KEY_LOCATION_RIGHT -> {\n        gameObject.updateVelocity(WALK_ACCELERATION);\n        LOGGER.info(gameObject.getName() + \" has moved right.\");\n      }\n      default -> {\n        LOGGER.info(gameObject.getName() + \"'s velocity is unchanged due to the invalid input\");\n        gameObject.updateVelocity(0);\n      } // incorrect input\n    }\n  }",
    "comment": "The update method to change the velocity based on the input key event.\n\n@param gameObject the gameObject instance\n@param e key event instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClasspathResourceSelector.java",
    "type": "method",
    "name": "getClasspathResources",
    "code": "public Set<Resource> getClasspathResources() {\n\t\tif (this.classpathResources == null) {\n\t\t\tTry<Set<Resource>> tryToGetResource = ReflectionUtils.tryToGetResources(this.classpathResourceName);\n\t\t\tSet<Resource> classpathResources = tryToGetResource.getOrThrow( //\n\t\t\t\tcause -> new PreconditionViolationException( //\n\t\t\t\t\t\"Could not load resource(s) with name: \" + this.classpathResourceName, cause));\n\t\t\tif (classpathResources.isEmpty()) {\n\t\t\t\tthrow new PreconditionViolationException(\n\t\t\t\t\t\"Could not find any resource(s) with name: \" + this.classpathResourceName);\n\t\t\t}\n\t\t\tthis.classpathResources = unmodifiableSet(classpathResources);\n\t\t}\n\t\treturn this.classpathResources;\n\t}",
    "comment": "Get the selected {@link Resource resources}.\n\n<p>If the {@link Resource resources} were not provided, but only their name,\nthis method attempts to lazily load the {@link Resource resources} based on\ntheir name and throws a {@link PreconditionViolationException} if the\nresource cannot be loaded.\n\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/LegacyCameraConnectionFragment.java",
    "type": "method",
    "name": "stopBackgroundThread",
    "code": "private void stopBackgroundThread() {\n    backgroundThread.quitSafely();\n    try {\n      backgroundThread.join();\n      backgroundThread = null;\n    } catch (final InterruptedException e) {\n      LOGGER.e(e, \"Exception!\");\n    }\n  }",
    "comment": "Stops the background thread and its {@link Handler}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java",
    "type": "method",
    "name": "wideningConversion",
    "code": "void wideningConversion() {\n\t\t\tassertTrue(isWideningConversion(byte.class, short.class));\n\t\t\tassertTrue(isWideningConversion(byte.class, int.class));\n\t\t\tassertTrue(isWideningConversion(byte.class, long.class));\n\t\t\tassertTrue(isWideningConversion(byte.class, float.class));\n\t\t\tassertTrue(isWideningConversion(byte.class, double.class));\n\t\t\tassertTrue(isWideningConversion(Byte.class, short.class));\n\t\t\tassertTrue(isWideningConversion(Byte.class, int.class));\n\t\t\tassertTrue(isWideningConversion(Byte.class, long.class));\n\t\t\tassertTrue(isWideningConversion(Byte.class, float.class));\n\t\t\tassertTrue(isWideningConversion(Byte.class, double.class));\n\n\t\t\tassertTrue(isWideningConversion(short.class, int.class));\n\t\t\tassertTrue(isWideningConversion(short.class, long.class));\n\t\t\tassertTrue(isWideningConversion(short.class, float.class));\n\t\t\tassertTrue(isWideningConversion(short.class, double.class));\n\t\t\tassertTrue(isWideningConversion(Short.class, int.class));\n\t\t\tassertTrue(isWideningConversion(Short.class, long.class));\n\t\t\tassertTrue(isWideningConversion(Short.class, float.class));\n\t\t\tassertTrue(isWideningConversion(Short.class, double.class));\n\n\t\t\tassertTrue(isWideningConversion(char.class, int.class));\n\t\t\tassertTrue(isWideningConversion(char.class, long.class));\n\t\t\tassertTrue(isWideningConversion(char.class, float.class));\n\t\t\tassertTrue(isWideningConversion(char.class, double.class));\n\t\t\tassertTrue(isWideningConversion(Character.class, int.class));\n\t\t\tassertTrue(isWideningConversion(Character.class, long.class));\n\t\t\tassertTrue(isWideningConversion(Character.class, float.class));\n\t\t\tassertTrue(isWideningConversion(Character.class, double.class));\n\n\t\t\tassertTrue(isWideningConversion(int.class, long.class));\n\t\t\tassertTrue(isWideningConversion(int.class, float.class));\n\t\t\tassertTrue(isWideningConversion(int.class, double.class));\n\t\t\tassertTrue(isWideningConversion(Integer.class, long.class));\n\t\t\tassertTrue(isWideningConversion(Integer.class, float.class));\n\t\t\tassertTrue(isWideningConversion(Integer.class, double.class));\n\n\t\t\tassertTrue(isWideningConversion(long.class, float.class));\n\t\t\tassertTrue(isWideningConversion(long.class, double.class));\n\t\t\tassertTrue(isWideningConversion(Long.class, float.class));\n\t\t\tassertTrue(isWideningConversion(Long.class, double.class));\n\n\t\t\tassertTrue(isWideningConversion(float.class, double.class));\n\t\t\tassertTrue(isWideningConversion(Float.class, double.class));\n\n\n\t\t\tassertFalse(isWideningConversion(int.class, byte.class)); // narrowing\n\t\t\tassertFalse(isWideningConversion(float.class, int.class)); // narrowing\n\t\t\tassertFalse(isWideningConversion(int.class, int.class)); // direct match\n\t\t\tassertFalse(isWideningConversion(String.class, int.class)); // neither a primitive nor a wrapper\n\t\t}",
    "comment": "byte\nByte\nshort\nShort\nchar\nCharacter\nint\nInteger\nlong\nLong\nfloat\nFloat\ndouble and Double --> nothing to test\nUnsupported"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4281PreferLocalSnapshotTest.java",
    "type": "method",
    "name": "assertChecksum",
    "code": "private void assertChecksum(String checksum, Properties checksums) {\n        String actual = checksums.getProperty(\"dependency-0.1-SNAPSHOT.jar\");\n        assertEquals(checksum, actual.toLowerCase(java.util.Locale.ENGLISH));\n    }",
    "comment": "Test that remote snapshots are not preferred over snapshots that have just been locally built.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/test/java/com/iluwatar/circuitbreaker/AppTest.java",
    "type": "method",
    "name": "testRecovery_ClosedStateTransition",
    "code": "void testRecovery_ClosedStateTransition() {\n    assertEquals(\"Delayed service is down\", monitoringService.delayedServiceResponse());\n    assertEquals(\"OPEN\", delayedServiceCircuitBreaker.getState());\n\n    try {\n      LOGGER.info(\"Waiting 4s for delayed service to become responsive\");\n      Thread.sleep(4000);\n    } catch (InterruptedException e) {\n      LOGGER.error(\"An error occurred: \", e);\n    }\n    assertEquals(\"HALF_OPEN\", delayedServiceCircuitBreaker.getState());\n    assertEquals(\"Delayed service is working\", monitoringService.delayedServiceResponse());\n    assertEquals(\"CLOSED\", delayedServiceCircuitBreaker.getState());\n  }",
    "comment": "Calling delayed service, which will be unhealthy till 4 seconds\nAs failure threshold is \"1\", the circuit breaker is changed to OPEN\nWaiting for 4 seconds, which is enough for DelayedService to become healthy and respond\nsuccessfully.\nAs retry period is 2 seconds (<4 seconds of wait), hence the circuit breaker should be back\nin HALF_OPEN state.\nCheck the success response from delayed service.\nAs the response is success, the state should be CLOSED"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/logging/SystemLogger.java",
    "type": "method",
    "name": "SystemLogger",
    "code": "public SystemLogger(@Nullable OutputStream out) {\n        this(out, null);\n    }",
    "comment": "System {@link Logger}. Uses provided {@link PrintStream}s or {@link System#err} ones as fallback.\nThis logger is used in case of \"early failures\" (when no logging may be set up yet)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Request.java",
    "type": "method",
    "name": "method",
    "code": "public static Request method(Class<?> clazz, String methodName) {\n        Description method = Description.createTestDescription(clazz, methodName);\n        return Request.aClass(clazz).filterWith(method);\n    }",
    "comment": "Create a <code>Request</code> that, when processed, will run a single test.\nThis is done by filtering out all other tests. This method is used to support rerunning\nsingle tests.\n\n@param clazz the class of the test\n@param methodName the name of the test\n@return a <code>Request</code> that will cause a single test be run"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/MethodMap.java",
    "type": "method",
    "name": "moreSpecific",
    "code": "private static int moreSpecific(Class<?>[] c1, Class<?>[] c2) {\n        boolean c1MoreSpecific = false;\n        boolean c2MoreSpecific = false;\n\n        for (int i = 0; i < c1.length; ++i) {\n            if (c1[i] != c2[i]) {\n                c1MoreSpecific = c1MoreSpecific || isStrictMethodInvocationConvertible(c2[i], c1[i]);\n                c2MoreSpecific = c2MoreSpecific || isStrictMethodInvocationConvertible(c1[i], c2[i]);\n            }\n        }\n\n        if (c1MoreSpecific) {\n            if (c2MoreSpecific) {\n                // Incomparable due to cross-assignable arguments (i.e.\n                // foo(String, Object) vs. foo(Object, String))\n                return INCOMPARABLE;\n            }\n\n            return MORE_SPECIFIC;\n        }\n\n        if (c2MoreSpecific) {\n            return LESS_SPECIFIC;\n        }\n\n        // Incomparable due to non-related arguments (i.e.\n        // foo(Runnable) vs. foo(Serializable))\n        return INCOMPARABLE;\n    }",
    "comment": "Determines which method signature (represented by a class array) is more\nspecific. This defines a partial ordering on the method signatures.\n\n@param c1 first signature to compare\n@param c2 second signature to compare\n@return MORE_SPECIFIC if c1 is more specific than c2, LESS_SPECIFIC if\nc1 is less specific than c2, INCOMPARABLE if they are incomparable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/currying/src/main/java/com/iluwatar/currying/Book.java",
    "type": "method",
    "name": "builder",
    "code": "public static AddGenre builder() {\n    return genre ->\n        author -> title -> publicationDate -> new Book(genre, author, title, publicationDate);\n  }",
    "comment": "Implements the builder pattern using functional interfaces to create a more readable book\ncreator function. This function is equivalent to the BOOK_CREATOR function."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeRowWriter.java",
    "type": "method",
    "name": "write",
    "code": "public void write(int ordinal, Decimal input, int precision, int scale) {\n    if (precision <= Decimal.MAX_LONG_DIGITS()) {\n      if (input != null && input.changePrecision(precision, scale)) {\n        write(ordinal, input.toUnscaledLong());\n      } else {\n        setNullAt(ordinal);\n      }\n    } else {\n      holder.grow(16);\n\n      Platform.putLong(getBuffer(), cursor(), 0L);\n      Platform.putLong(getBuffer(), cursor() + 8, 0L);\n\n      if (input == null || !input.changePrecision(precision, scale)) {\n        BitSetMethods.set(getBuffer(), startingOffset, ordinal);\n        setOffsetAndSize(ordinal, 0);\n      } else {\n        final byte[] bytes = input.toJavaBigDecimal().unscaledValue().toByteArray();\n        final int numBytes = bytes.length;\n        assert numBytes <= 16;\n\n        Platform.copyMemory(\n          bytes, Platform.BYTE_ARRAY_OFFSET, getBuffer(), cursor(), numBytes);\n        setOffsetAndSize(ordinal, bytes.length);\n      }\n\n      increaseCursor(16);\n    }\n  }",
    "comment": "make sure Decimal object has the same scale as DecimalType\ngrow the global buffer before writing data.\nalways zero-out the 16-byte buffer\nMake sure Decimal object has the same scale as DecimalType.\nNote that we may pass in null Decimal object to set null for it.\nkeep the offset for future update\nWrite the bytes to the variable length portion.\nmove the cursor forward."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/Java8APISuite.java",
    "type": "method",
    "name": "testVariousTransform",
    "code": "public void testVariousTransform() {\n\n    List<List<Integer>> inputData = Arrays.asList(Arrays.asList(1));\n    JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1);\n\n    List<List<Tuple2<String, Integer>>> pairInputData =\n      Arrays.asList(Arrays.asList(new Tuple2<>(\"x\", 1)));\n    JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(\n      JavaTestUtils.attachTestInputStream(ssc, pairInputData, 1));\n\n    JavaDStream<Integer> transformed1 = stream.transform(in -> null);\n    JavaDStream<Integer> transformed2 = stream.transform((x, time) -> null);\n    JavaPairDStream<String, Integer> transformed3 = stream.transformToPair(x -> null);\n    JavaPairDStream<String, Integer> transformed4 = stream.transformToPair((x, time) -> null);\n    JavaDStream<Integer> pairTransformed1 = pairStream.transform(x -> null);\n    JavaDStream<Integer> pairTransformed2 = pairStream.transform((x, time) -> null);\n    JavaPairDStream<String, String> pairTransformed3 = pairStream.transformToPair(x -> null);\n    JavaPairDStream<String, String> pairTransformed4 =\n      pairStream.transformToPair((x, time) -> null);\n\n  }",
    "comment": "tests whether all variations of transform can be called from Java"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "fetch",
    "code": "public Runner fetch(String operation, int index) {\n      Operation op = operationByName(operation);\n      if (op != null) {\n        outputs.add(op.output(index));\n      }\n      return this;\n    }",
    "comment": "Make {@link #run()} return the {@code index}-th output of {@code operation}.\n\n<p>Operations in a {@link Graph} can have multiple outputs, {@code index} identifies which\none to return."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/metadata-mapping/src/test/java/com/iluwatar/metamapping/AppTest.java",
    "type": "method",
    "name": "shouldExecuteMetaMappingWithoutException",
    "code": "void shouldExecuteMetaMappingWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "containsIsoControlCharacter",
    "code": "public static boolean containsIsoControlCharacter(String str) {\n\t\treturn str != null && str.codePoints().anyMatch(Character::isISOControl);\n\t}",
    "comment": "Determine if the supplied {@link String} contains any ISO control characters.\n\n@param str the string to check; may be {@code null}\n@return {@code true} if the string contains an ISO control character\n@see #containsWhitespace(String)\n@see Character#isISOControl(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/MemoryHealthIndicatorTest.java",
    "type": "method",
    "name": "whenMemoryUsageIsAboveThreshold_thenHealthIsDown",
    "code": "void whenMemoryUsageIsAboveThreshold_thenHealthIsDown() {\n    // Arrange\n    CompletableFuture<Health> future =\n        CompletableFuture.completedFuture(\n            Health.down().withDetail(\"memory usage\", \"95% of max\").build());\n    when(asynchronousHealthChecker.performCheck(any(Supplier.class), anyLong())).thenReturn(future);\n\n    // Act\n    Health health = memoryHealthIndicator.health();\n\n    // Assert\n    assertEquals(Status.DOWN, health.getStatus());\n    assertEquals(\"95% of max\", health.getDetails().get(\"memory usage\"));\n  }",
    "comment": "Test case for the `health()` method when memory usage is above the threshold.\n\n<p>Asserts that when the `health()` method is called and memory usage is above the threshold,\nit returns a Health object with Status.DOWN."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "configurationParameter",
    "code": "public LauncherDiscoveryRequestBuilder configurationParameter(String key, String value) {\n\t\tPreconditions.notBlank(key, \"configuration parameter key must not be null or blank\");\n\t\tthis.configurationParameters.put(key, value);\n\t\treturn this;\n\t}",
    "comment": "Add the supplied <em>configuration parameter</em> to the request.\n\n@param key the configuration parameter key under which to store the\nvalue; never {@code null} or blank\n@param value the value to store\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/ClockSource.java",
    "type": "method",
    "name": "elapsedMillis",
    "code": "static long elapsedMillis(long startTime) {\n      return CLOCK.elapsedMillis0(startTime);\n   }",
    "comment": "Convert an opaque time-stamp returned by currentTime() into an\nelapsed time in milliseconds, based on the current instant in time.\n\n@param startTime an opaque time-stamp returned by an instance of this class\n@return the elapsed time between startTime and now in milliseconds"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginArtifactsCache.java",
    "type": "method",
    "name": "register",
    "code": "public void register(MavenProject project, Key cacheKey, CacheRecord record) {\n    }",
    "comment": "default cache does not track record usage"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/test/java/org/tensorflow/op/core/GeneratedOperationsTest.java",
    "type": "method",
    "name": "testControlDependencies",
    "code": "public void testControlDependencies() {\n    try (Graph g = new Graph();\n        Session sess = new Session(g)) {\n    }\n  }",
    "comment": "Test for Ops.withControlDependencies.\n\n<p>Creates an add node with a control dependency to an assign node. In other words, the assign\nnode is a control input to the add node. When the add node is run, the assign node is expected\nto have run beforehand due to the control dependency."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/BuildResumptionData.java",
    "type": "method",
    "name": "BuildResumptionData",
    "code": "public BuildResumptionData(final List<String> remainingProjects) {\n        this.remainingProjects = remainingProjects;\n    }",
    "comment": "The list of projects that remain to be built."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/filter/AlwaysTrue.java",
    "type": "method",
    "name": "AlwaysTrue",
    "code": "public AlwaysTrue() {\n    super(\"ALWAYS_TRUE\", new Predicate[]{});\n\n  @Override\n  public Boolean value() {\n    return true;\n  }\n\n  @Override\n  public DataType dataType() {\n    return DataTypes.BooleanType;\n  }\n\n  @Override\n  public String toString() { return \"TRUE\"; }\n}",
    "comment": "A predicate that always evaluates to {@code true}.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/procedures/ProcedureParameter.java",
    "type": "method",
    "name": "in",
    "code": "static Builder in(String name, DataType dataType) {\n    return new Builder(IN, name, dataType);\n  }",
    "comment": "Creates a builder for an IN procedure parameter.\n\n@param name the name of the parameter\n@param dataType the type of the parameter\n@return the constructed stored procedure parameter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/TensorFlowObjectDetectionAPIModel.java",
    "type": "method",
    "name": "recognizeImage",
    "code": "public List<Recognition> recognizeImage(final Bitmap bitmap) {\n    Trace.beginSection(\"recognizeImage\");\n\n    Trace.beginSection(\"preprocessBitmap\");\n    bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());\n\n    for (int i = 0; i < intValues.length; ++i) {\n      byteValues[i * 3 + 2] = (byte) (intValues[i] & 0xFF);\n      byteValues[i * 3 + 1] = (byte) ((intValues[i] >> 8) & 0xFF);\n      byteValues[i * 3 + 0] = (byte) ((intValues[i] >> 16) & 0xFF);\n    }\n    Trace.endSection(); // preprocessBitmap\n\n    Trace.beginSection(\"feed\");\n    inferenceInterface.feed(inputName, byteValues, 1, inputSize, inputSize, 3);\n    Trace.endSection();\n\n    Trace.beginSection(\"run\");\n    inferenceInterface.run(outputNames, logStats);\n    Trace.endSection();\n\n    Trace.beginSection(\"fetch\");\n    outputLocations = new float[MAX_RESULTS * 4];\n    outputScores = new float[MAX_RESULTS];\n    outputClasses = new float[MAX_RESULTS];\n    outputNumDetections = new float[1];\n    inferenceInterface.fetch(outputNames[0], outputLocations);\n    inferenceInterface.fetch(outputNames[1], outputScores);\n    inferenceInterface.fetch(outputNames[2], outputClasses);\n    inferenceInterface.fetch(outputNames[3], outputNumDetections);\n    Trace.endSection();\n\n    final PriorityQueue<Recognition> pq =\n        new PriorityQueue<Recognition>(\n            1,\n            new Comparator<Recognition>() {\n            });\n\n    for (int i = 0; i < outputScores.length; ++i) {\n      final RectF detection =\n          new RectF(\n              outputLocations[4 * i + 1] * inputSize,\n              outputLocations[4 * i] * inputSize,\n              outputLocations[4 * i + 3] * inputSize,\n              outputLocations[4 * i + 2] * inputSize);\n      pq.add(\n          new Recognition(\"\" + i, labels.get((int) outputClasses[i]), outputScores[i], detection));\n    }\n\n    final ArrayList<Recognition> recognitions = new ArrayList<Recognition>();\n    for (int i = 0; i < Math.min(pq.size(), MAX_RESULTS); ++i) {\n      recognitions.add(pq.poll());\n    }\n    Trace.endSection(); // \"recognizeImage\"\n    return recognitions;\n  }",
    "comment": "Log this method so that it can be analyzed with systrace.\nPreprocess the image data to extract R, G and B bytes from int of form 0x00RRGGBB\non the provided parameters.\nCopy the input data into TensorFlow.\nRun the inference call.\nCopy the output Tensor back into the output array.\nFind the best detections.\nScale them back to the input size."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java",
    "type": "method",
    "name": "publishReportEntry",
    "code": "default void publishReportEntry(String value) {\n\t\tthis.publishReportEntry(\"value\", value);\n\t}",
    "comment": "Publish the specified value to be consumed by an\n{@code org.junit.platform.engine.EngineExecutionListener} in order to\nsupply additional information to the reporting infrastructure.\n\n<p>This method delegates to {@link #publishReportEntry(String, String)},\nsupplying {@code \"value\"} as the key and the supplied {@code value}\nargument as the value.\n\n@param value the value to be published; never {@code null} or blank\n@since 5.3\n@see #publishReportEntry(Map)\n@see #publishReportEntry(String, String)\n@see org.junit.platform.engine.EngineExecutionListener#reportingEntryPublished"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaBucketedRandomProjectionLSHExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaBucketedRandomProjectionLSHExample\")\n      .getOrCreate();\n\n    // $example on$\n    List<Row> dataA = Arrays.asList(\n      RowFactory.create(0, Vectors.dense(1.0, 1.0)),\n      RowFactory.create(1, Vectors.dense(1.0, -1.0)),\n      RowFactory.create(2, Vectors.dense(-1.0, -1.0)),\n      RowFactory.create(3, Vectors.dense(-1.0, 1.0))\n    );\n\n    List<Row> dataB = Arrays.asList(\n        RowFactory.create(4, Vectors.dense(1.0, 0.0)),\n        RowFactory.create(5, Vectors.dense(-1.0, 0.0)),\n        RowFactory.create(6, Vectors.dense(0.0, 1.0)),\n        RowFactory.create(7, Vectors.dense(0.0, -1.0))\n    );\n\n    StructType schema = new StructType(new StructField[]{\n    Dataset<Row> dfA = spark.createDataFrame(dataA, schema);\n    Dataset<Row> dfB = spark.createDataFrame(dataB, schema);\n\n    Vector key = Vectors.dense(1.0, 0.0);\n\n    BucketedRandomProjectionLSH mh = new BucketedRandomProjectionLSH()\n      .setBucketLength(2.0)\n      .setNumHashTables(3)\n      .setInputCol(\"features\")\n      .setOutputCol(\"hashes\");\n\n    BucketedRandomProjectionLSHModel model = mh.fit(dfA);\n\n    // Feature Transformation\n    System.out.println(\"The hashed dataset where hashed values are stored in the column 'hashes':\");\n    model.transform(dfA).show();\n\n    // Compute the locality sensitive hashes for the input rows, then perform approximate\n    // similarity join.\n    // We could avoid computing hashes by passing in the already-transformed dataset, e.g.\n    // `model.approxSimilarityJoin(transformedA, transformedB, 1.5)`\n    System.out.println(\"Approximately joining dfA and dfB on distance smaller than 1.5:\");\n    model.approxSimilarityJoin(dfA, dfB, 1.5, \"EuclideanDistance\")\n      .select(col(\"datasetA.id\").alias(\"idA\"),\n        col(\"datasetB.id\").alias(\"idB\"),\n        col(\"EuclideanDistance\")).show();\n\n    // Compute the locality sensitive hashes for the input rows, then perform approximate nearest\n    // neighbor search.\n    // We could avoid computing hashes by passing in the already-transformed dataset, e.g.\n    // `model.approxNearestNeighbors(transformedA, key, 2)`\n    System.out.println(\"Approximately searching dfA for 2 nearest neighbors of the key:\");\n    model.approxNearestNeighbors(dfA, key, 2).show();\n    // $example off$\n\n    spark.stop();\n  }\n}",
    "comment": "An example demonstrating BucketedRandomProjectionLSH.\nRun with:\nbin/run-example ml.JavaBucketedRandomProjectionLSHExample"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/ErrorCollector.java",
    "type": "method",
    "name": "addError",
    "code": "public void addError(Throwable error) {\n        if (error == null) {\n            throw new NullPointerException(\"Error cannot be null\");\n        }\n        if (error instanceof AssumptionViolatedException) {\n            AssertionError e = new AssertionError(error.getMessage());\n            e.initCause(error);\n            errors.add(e);\n        } else {\n            errors.add(error);\n        }\n    }",
    "comment": "Adds a Throwable to the table.  Execution continues, but the test will fail at the end."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-repository-metadata/src/test/java/org/apache/maven/artifact/repository/metadata/MetadataTest.java",
    "type": "method",
    "name": "formatDate",
    "code": "private static String formatDate(Date date, boolean forSnapshotTimestamp) {\n        TimeZone timezone = TimeZone.getTimeZone(\"UTC\");\n        DateFormat fmt =\n                new SimpleDateFormat(forSnapshotTimestamp ? DEFAULT_SNAPSHOT_TIMESTAMP_FORMAT : DEFAULT_DATE_FORMAT);\n        fmt.setCalendar(new GregorianCalendar());\n        fmt.setTimeZone(timezone);\n        return fmt.format(date);\n    }",
    "comment": "logic from metadata.mdo, class \"Versioning\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java",
    "type": "method",
    "name": "validateInstanceMethods",
    "code": "protected void validateInstanceMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(After.class, false, errors);\n        validatePublicVoidNoArgMethods(Before.class, false, errors);\n        validateTestMethods(errors);\n\n        if (computeTestMethods().isEmpty()) {\n            errors.add(new Exception(\"No runnable methods\"));\n        }\n    }",
    "comment": "Adds to {@code errors} for each method annotated with {@code @Test},\n{@code @Before}, or {@code @After} that is not a public, void instance\nmethod with no arguments.\n@deprecated"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/conversion/FallbackStringToObjectConverter.java",
    "type": "method",
    "name": "test",
    "code": "public boolean test(Constructor<?> constructor) {\n\t\t\tif (!constructor.getDeclaringClass().equals(this.targetType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn isNotPrivateAndAcceptsSingleStringArgument(constructor);\n\t\t}",
    "comment": "Please do not collapse the following into a single statement."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "createSuiteDescription",
    "code": "public static Description createSuiteDescription(String name, Serializable uniqueId, Annotation... annotations) {\n        return new Description(null, name, uniqueId, annotations);\n    }",
    "comment": "Create a <code>Description</code> named <code>name</code>.\nGenerally, you will add children to this <code>Description</code>.\n\n@param name the name of the <code>Description</code>\n@param uniqueId an arbitrary object used to define uniqueness (in {@link #equals(Object)}\n@param annotations meta-data about the test, for downstream interpreters\n@return a <code>Description</code> named <code>name</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/PluginsMetadataGeneratorFactory.java",
    "type": "method",
    "name": "newInstance",
    "code": "public MetadataGenerator newInstance(RepositorySystemSession session, InstallRequest request) {\n        return new PluginsMetadataGenerator(session, request);\n    }",
    "comment": "Maven G level metadata generator factory.\n\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/test/java/com/iluwatar/RegisterWorkerTest.java",
    "type": "method",
    "name": "runWithMissingDOB",
    "code": "void runWithMissingDOB() {\n    RegisterWorkerDto workerDto = createValidWorkerDto();\n    workerDto.setupWorkerDto(\"name\", \"occupation\", null);\n    RegisterWorker registerWorker = new RegisterWorker(workerDto);\n\n    registerWorker.run();\n\n    assertTrue(registerWorker.getNotification().hasErrors());\n    assertTrue(\n        registerWorker.getNotification().getErrors().contains(RegisterWorkerDto.MISSING_DOB));\n    assertEquals(registerWorker.getNotification().getErrors().size(), 2);\n  }",
    "comment": "Run the registration process\nVerify that the notification contains the missing DOB error"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/monad/src/main/java/com/iluwatar/monad/Validator.java",
    "type": "method",
    "name": "validate",
    "code": "public Validator<T> validate(Predicate<? super T> validation, String message) {\n    if (!validation.test(obj)) {\n      exceptions.add(new IllegalStateException(message));\n    }\n    return this;\n  }",
    "comment": "Checks if the validation is successful.\n\n@param validation one argument boolean-valued function that represents one step of validation.\nAdds exception to main validation exception list when single step validation ends with\nfailure.\n@param message error message when object is invalid\n@return this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/DirectorySource.java",
    "type": "method",
    "name": "from",
    "code": "public static DirectorySource from(File directory) {\n\t\treturn new DirectorySource(directory);\n\t}",
    "comment": "Create a new {@code DirectorySource} using the supplied\n\n@param directory the source directory; must not be {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/toolchain/RequirementMatcherFactoryTest.java",
    "type": "method",
    "name": "testCreateVersionMatcher",
    "code": "void testCreateVersionMatcher() {\n        RequirementMatcher matcher;\n        matcher = RequirementMatcherFactory.createVersionMatcher(\"1.5.2\");\n        assertFalse(matcher.matches(\"1.5\"));\n        assertTrue(matcher.matches(\"1.5.2\"));\n        assertFalse(matcher.matches(\"[1.4,1.5)\"));\n        assertFalse(matcher.matches(\"[1.5,1.5.2)\"));\n        assertFalse(matcher.matches(\"(1.5.2,1.6)\"));\n        assertTrue(matcher.matches(\"(1.4,1.5.2]\"));\n        assertTrue(matcher.matches(\"(1.5,)\"));\n        assertEquals(\"1.5.2\", matcher.toString());\n\n        // Ensure it is not printed as 1.5.0\n        matcher = RequirementMatcherFactory.createVersionMatcher(\"1.5\");\n        assertEquals(\"1.5\", matcher.toString());\n    }",
    "comment": "Test of createVersionMatcher method, of class RequirementMatcherFactory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/SplitTimer.java",
    "type": "method",
    "name": "SplitTimer",
    "code": "public SplitTimer(final String name) {\n    logger = new Logger(name);\n    newSplit();\n  }",
    "comment": "A simple utility timer for measuring CPU time and wall-clock splits."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/support/scanning/DefaultClasspathScannerTests.java",
    "type": "method",
    "name": "getTestClasspathResourceRoot",
    "code": "private URI getTestClasspathResourceRoot() {\n\t\tvar defaultPackageResource = \"/default-package.resource\";\n\t\tvar resourceUri = getClass().getResource(defaultPackageResource).toString();\n\t\treturn URI.create(resourceUri.substring(0, resourceUri.length() - defaultPackageResource.length()));\n\t}",
    "comment": "Gradle puts classes and resources in different roots."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/internal/StackTracesTest.java",
    "type": "method",
    "name": "ExceptionMessageMatcher",
    "code": "public ExceptionMessageMatcher(String message) {\n            matcher = CoreMatchers.equalTo(message);\n        }",
    "comment": "A matcher that matches the exception message in a stack trace."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/TestClass.java",
    "type": "method",
    "name": "compare",
    "code": "public int compare(FrameworkMethod left, FrameworkMethod right) {\n            return NAME_ASCENDING.compare(left.getMethod(), right.getMethod());\n        }",
    "comment": "Compares two methods by its name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/WriteBuilder.java",
    "type": "method",
    "name": "build",
    "code": "default Write build() {\n    return new Write() {\n\n      @Override\n      public StreamingWrite toStreaming() {\n        return buildForStreaming();\n      }\n    };\n  }",
    "comment": "Returns a logical {@link Write} shared between batch and streaming.\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/Platform.java",
    "type": "method",
    "name": "throwException",
    "code": "public static void throwException(Throwable t) {\n    _UNSAFE.throwException(t);\n  }",
    "comment": "Raises an exception bypassing compiler checks for checked exceptions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(double unexpected, double actual, double delta, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, delta, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal\nwithin the given {@code delta}.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "getBytes",
    "code": "public byte[] getBytes(int rowId, int count) {\n    byte[] res = new byte[count];\n    for (int i = 0; i < count; i++) {\n      res[i] = getByte(rowId + i);\n    }\n    return res;\n  }",
    "comment": "Gets byte type values from {@code [rowId, rowId + count)}. The return values for the null slots\nare undefined and can be anything."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "getFullyQualifiedMethodName",
    "code": "public static String getFullyQualifiedMethodName(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\n\t\treturn getFullyQualifiedMethodName(clazz.getName(), methodName, ClassUtils.nullSafeToString(parameterTypes));\n\t}",
    "comment": "Build the <em>fully qualified method name</em> for the method described by the\nsupplied class, method name, and parameter types.\n\n<p>Note that the class is not necessarily the class in which the method is\ndeclared.\n\n@param clazz the class from which the method should be referenced; never {@code null}\n@param methodName the name of the method; never {@code null} or blank\n@param parameterTypes the parameter types of the method; may be {@code null} or empty\n@return fully qualified method name; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedColumnReader.java",
    "type": "method",
    "name": "needsDecimalScaleRebase",
    "code": "private boolean needsDecimalScaleRebase(DataType sparkType) {\n      LogicalTypeAnnotation typeAnnotation =\n        descriptor.getPrimitiveType().getLogicalTypeAnnotation();\n      if (!(typeAnnotation instanceof DecimalLogicalTypeAnnotation)) return false;\n      if (!(sparkType instanceof DecimalType)) return false;\n      DecimalLogicalTypeAnnotation parquetDecimal = (DecimalLogicalTypeAnnotation) typeAnnotation;\n      DecimalType sparkDecimal = (DecimalType) sparkType;\n      return parquetDecimal.getScale() != sparkDecimal.scale();\n  }",
    "comment": "Returns whether the Parquet type of this column and the given spark type are two decimal types\nwith different scale."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/flyweight/src/main/java/com/iluwatar/flyweight/AlchemistShop.java",
    "type": "method",
    "name": "getBottomShelf",
    "code": "public final List<Potion> getBottomShelf() {\n    return List.copyOf(this.bottomShelf);\n  }",
    "comment": "Get a read-only list of all the items on the bottom shelf.\n\n@return The bottom shelf potions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/ring/RingMessageManager.java",
    "type": "method",
    "name": "sendElectionMessage",
    "code": "public boolean sendElectionMessage(int currentId, String content) {\n    var nextInstance = this.findNextInstance(currentId);\n    var electionMessage = new Message(MessageType.ELECTION, content);\n    nextInstance.onMessage(electionMessage);\n    return true;\n  }",
    "comment": "Send election message to the next instance.\n\n@param currentId currentID\n@param content list contains all the IDs of instances which have received this election\nmessage.\n@return {@code true} if the election message is accepted by the target instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "createSuiteDescription",
    "code": "public static Description createSuiteDescription(Class<?> testClass, Annotation... annotations) {\n        return new Description(testClass, testClass.getName(), annotations);\n    }",
    "comment": "Create a <code>Description</code> named after <code>testClass</code>\n\n@param testClass A not null {@link Class} containing tests\n@param annotations meta-data about the test, for downstream interpreters\n@return a <code>Description</code> of <code>testClass</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(Object[] expected, Object[] actual, Supplier<String> messageSupplier) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} object arrays are deeply equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Nested float arrays are checked as in {@link #assertEquals(float, float)}.\n<p>Nested double arrays are checked as in {@link #assertEquals(double, double)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@see Objects#equals(Object, Object)\n@see Arrays#deepEquals(Object[], Object[])"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "deleteColumn",
    "code": "static TableChange deleteColumn(String[] fieldNames, Boolean ifExists) {\n    return new DeleteColumn(fieldNames, ifExists);\n  }",
    "comment": "Create a TableChange for deleting a field.\n<p>\nIf the field does not exist, the change will result in an {@link IllegalArgumentException}.\n\n@param fieldNames field names of the column to delete\n@param ifExists   silence the error if column doesn't exist during drop\n@return a TableChange for the delete"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/RandomOrdererUtils.java",
    "type": "method",
    "name": "getSeed",
    "code": "static Long getSeed(Function<String, Optional<String>> configurationParameterLookup, Logger logger) {\n\t\treturn getCustomSeed(configurationParameterLookup, logger).orElse(DEFAULT_SEED);\n\t}",
    "comment": "Shared utility methods for ordering test classes and test methods randomly.\n\n@since 5.11\n@see ClassOrderer.Random\n@see MethodOrderer.Random"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "stop",
    "code": "Record stop(Record previous) {\n        Record record = records.get();\n        records.set(previous);\n        record.usedActiveProfiles.values().removeIf(value -> !value);\n        record.usedInactiveProfiles.values().removeIf(value -> !value);\n        return record;\n    }",
    "comment": "only keep keys for which the value is `true`"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "getLocalRepositoryWithSettings",
    "code": "public String getLocalRepositoryWithSettings(String settingsXml) {\n        String outerHead = System.getProperty(\"maven.repo.local\", \"\").trim();\n        if (!outerHead.isEmpty()) {\n            return outerHead;\n        } else if (settingsXml != null) {\n            Path settingsFile = basedir.resolve(settingsXml).toAbsolutePath().normalize();\n            if (!Files.isRegularFile(settingsFile)) {\n                throw new IllegalArgumentException(\"settings xml does not exist: \" + settingsXml);\n            }\n            return executorTool.localRepository(executorHelper\n                    .executorRequest()\n                    .cwd(tempBasedir)\n                    .userHomeDirectory(userHomeDirectory)\n                    .argument(\"-s\")\n                    .argument(settingsFile.toString()));\n        } else {\n            return executorTool.localRepository(\n                    executorHelper.executorRequest().cwd(tempBasedir).userHomeDirectory(userHomeDirectory));\n        }\n    }",
    "comment": "when invoked with settings.xml, the file must be resolved from basedir (as Maven does)\nbut we should not use basedir, as it may contain extensions.xml or a project, that Maven will eagerly\nload, and may fail, as it would need more (like CI friendly versioning, etc).\nif given, it must exist"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProjectBuilderRequest.java",
    "type": "method",
    "name": "session",
    "code": "public ProjectBuilderRequestBuilder session(Session session) {\n            this.session = session;\n            return this;\n        }",
    "comment": "Sets the Maven session for this request.\n\n@param session the Maven session\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestWatcherTests.java",
    "type": "method",
    "name": "testWatcherIsInvokedForRepeatedTestMethods",
    "code": "void testWatcherIsInvokedForRepeatedTestMethods() {\n\t\tEngineExecutionResults results = executeTestsForClass(TrackingTestWatcherRepeatedTestMethodsTestCase.class);\n\n\t\tresults.containerEvents().assertStatistics(\n\t\t\tstats -> stats.skipped(1).started(5).succeeded(5).aborted(0).failed(0));\n\t\tresults.testEvents().assertStatistics(\n\t\t\tstats -> stats.dynamicallyRegistered(6).skipped(0).started(6).succeeded(2).aborted(2).failed(2));\n\n\t\tassertThat(TrackingTestWatcher.results.keySet()).containsAll(testWatcherMethodNames);\n\t\tTrackingTestWatcher.results.forEach((testWatcherMethod, testMethodNames) -> assertEquals(\n\t\t\t\"testDisabled\".equals(testWatcherMethod) ? 1 : 2, testMethodNames.size()));\n\t}",
    "comment": "Since the @RepeatedTest container is disabled, the individual invocations never occur.\n2 => number of iterations declared in @RepeatedTest(2)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcTrustStore",
    "code": "public File sslRpcTrustStore() {\n    String trustStore = conf.get(\"spark.ssl.rpc.trustStore\", null);\n    if (trustStore != null) {\n      return new File(trustStore);\n    } else {\n      return null;\n    }\n  }",
    "comment": "The trust-store file; can be relative to the current directory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/textui/TestRunner.java",
    "type": "method",
    "name": "run",
    "code": "static public void run(Class<? extends TestCase> testClass) {\n        run(new TestSuite(testClass));\n    }",
    "comment": "Runs a suite extracted from a TestCase subclass."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/test/java/com/iluwatar/RegisterWorkerTest.java",
    "type": "method",
    "name": "runWithUnderageDOB",
    "code": "void runWithUnderageDOB() {\n    RegisterWorkerDto workerDto = createValidWorkerDto();\n    workerDto.setDateOfBirth(LocalDate.now().minusYears(17)); // Under 18\n    workerDto.setupWorkerDto(\"name\", \"occupation\", LocalDate.now().minusYears(17));\n    RegisterWorker registerWorker = new RegisterWorker(workerDto);\n\n    registerWorker.run();\n\n    assertTrue(registerWorker.getNotification().hasErrors());\n    assertTrue(\n        registerWorker.getNotification().getErrors().contains(RegisterWorkerDto.DOB_TOO_SOON));\n    assertEquals(registerWorker.getNotification().getErrors().size(), 1);\n  }",
    "comment": "Run the registration process\nVerify that the notification contains the underage DOB error"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotSame",
    "code": "public static void assertNotSame(Object unexpected, Object actual) {\n\t\tAssertNotSame.assertNotSame(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that the {@code unexpected} object and the {@code actual}\nobject are not the same object.\n<p>This method should only be used to compare the <em>identity</em> of two\nobjects. To assert that two objects or two primitive values are not\n<em>equal</em>, use one of the {@code assertNotEquals(...)} methods instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, float expected, float actual, float delta) {\n        if (Float.compare(expected, actual) == 0) {\n            return;\n        }\n        if (!(Math.abs(expected - actual) <= delta)) {\n            failNotEquals(message, Float.valueOf(expected), Float.valueOf(actual));\n        }\n    }",
    "comment": "Asserts that two floats are equal concerning a positive delta. If they\nare not an AssertionFailedError is thrown with the given message. If the\nexpected value is infinity then the delta value is ignored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/AutoCloseTests.java",
    "type": "method",
    "name": "spyPermitsOnlyASingleAction",
    "code": "void spyPermitsOnlyASingleAction() {\n\t\t@SuppressWarnings(\"resource\")\n\t\tAutoCloseSpy spy = new AutoCloseSpy(\"preconditions\");\n\n\t\tspy.close();\n\n\t\tassertThatIllegalStateException().isThrownBy(spy::run).withMessage(\"Already closed via close()\");\n\t\tassertThatIllegalStateException().isThrownBy(spy::close).withMessage(\"Already closed via close()\");\n\t\tassertThat(recorder).containsExactly(\"AutoCloseTests.preconditions.close()\");\n\t}",
    "comment": "Tests prerequisites for the {@link AutoCloseSpy} implementation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/ProjectSegment.java",
    "type": "method",
    "name": "ProjectSegment",
    "code": "public ProjectSegment(MavenProject project, TaskSegment taskSegment, MavenSession copiedSession) {\n        this.project = project;\n        this.taskSegment = taskSegment;\n        this.session = copiedSession;\n        final ProjectDependencyGraph dependencyGraph = getSession().getProjectDependencyGraph();\n        nonTransitiveUpstreamProjects = dependencyGraph.getUpstreamProjects(getProject(), false);\n        transitiveUpstreamProjects = dependencyGraph.getUpstreamProjects(getProject(), true);\n    }",
    "comment": "A build context that matches a Maven project to a given task segment, and the session to be used.\n<p>\nA note to the reader;\n</p>\n<p>\nThere are several issues/discussions regarding how \"aggregator\" plugins should be handled.\nRead for instance http://docs.codehaus.org/display/MAVEN/Deterministic+Lifecycle+Planning\n</p>\n<p>\nIn their current implementation they are \"bolted\" onto the lifecycle by separating them\ninto TaskSegments. This class represents the execution context of one such task segment.\n</p>\n<p>\nWise voices have suggested that maybe aggregators shouldn't be bound to the ordinary\nlifecycle at all, in which case we wouldn't be needing this class at all ( and\nProjectBuildList.getByTaskSegments). Or maybe they should be introduced in the calculation\nof the execution plan instead, which seems much nicer.\n</p>\n<p>\nAdditionally this class contains a clone of the MavenSession, which is *only* needed\nbecause it has as notion of a \"current\" project.\n</p>\n<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaGradientBoostedTreeRegressorExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaGradientBoostedTreeRegressorExample\")\n      .getOrCreate();\n\n    Dataset<Row> data = spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    VectorIndexerModel featureIndexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexedFeatures\")\n      .setMaxCategories(4)\n      .fit(data);\n\n    Dataset<Row>[] splits = data.randomSplit(new double[] {0.7, 0.3});\n    Pipeline pipeline = new Pipeline().setStages(new PipelineStage[] {featureIndexer, gbt});\n}",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file, converting it to a DataFrame.\nAutomatically identify categorical features, and index them.\nSet maxCategories so features with > 4 distinct values are treated as continuous.\nSplit the data into training and test sets (30% held out for testing)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "applySelectorsAndFiltersFromSuite",
    "code": "public SuiteLauncherDiscoveryRequestBuilder applySelectorsAndFiltersFromSuite(Class<?> suiteClass) {\n\t\tPreconditions.notNull(suiteClass, \"Suite class must not be null\");\n\n\t\taddExcludeFilters(suiteClass);\n\t\t// Process @SelectClasses and @SelectMethod before @IncludeClassNamePatterns, since the names\n\t\t// of selected classes get automatically added to the include filter.\n\t\taddClassAndMethodSelectors(suiteClass);\n\t\taddIncludeFilters(suiteClass);\n\t\taddOtherSelectors(suiteClass);\n\t\treturn this;\n\t}",
    "comment": "Apply a suite's annotation-based discovery selectors and filters to this\nbuilder.\n\n<p>This will apply the configuration from the following annotations.\n<ul>\n<li>{@link ExcludeClassNamePatterns}</li>\n<li>{@link ExcludeEngines}</li>\n<li>{@link ExcludePackages}</li>\n<li>{@link ExcludeTags}</li>\n<li>{@link IncludeClassNamePatterns}</li>\n<li>{@link IncludeEngines}</li>\n<li>{@link IncludePackages}</li>\n<li>{@link IncludeTags}</li>\n<li>{@link SelectClasses}</li>\n<li>{@link SelectClasspathResource}</li>\n<li>{@link SelectDirectories}</li>\n<li>{@link SelectFile}</li>\n<li>{@link SelectMethod}</li>\n<li>{@link SelectModules}</li>\n<li>{@link SelectUris}</li>\n<li>{@link SelectPackages}</li>\n<li>{@link Select}</li>\n</ul>\n\n@param suiteClass the class to apply the discovery selectors and filter\nannotations from; never {@code null}\n@return this builder for method chaining\n@since 1.11\n@see org.junit.platform.suite.api.Suite"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java",
    "type": "method",
    "name": "matchPattern",
    "code": "static boolean matchPattern(ArtifactRepository originalRepository, String pattern) {\n        boolean result = false;\n        String originalId = originalRepository.getId();\n\n        // simple checks first to short circuit processing below.\n        if (WILDCARD.equals(pattern) || pattern.equals(originalId)) {\n            result = true;\n        } else {\n            // process the list\n            String[] repos = pattern.split(\",\");\n            for (String repo : repos) {\n                // see if this is a negative match\n                if (repo.length() > 1 && repo.startsWith(\"!\")) {\n                    if (repo.substring(1).equals(originalId)) {\n                        // explicitly exclude. Set result and stop processing.\n                        result = false;\n                        break;\n                    }\n                }\n                // check for exact match\n                else if (repo.equals(originalId)) {\n                    result = true;\n                    break;\n                }\n                // check for external:*\n                else if (EXTERNAL_WILDCARD.equals(repo) && isExternalRepo(originalRepository)) {\n                    result = true;\n                    // don't stop processing in case a future segment explicitly excludes this repo\n                }\n                // check for external:http:*\n                else if (EXTERNAL_HTTP_WILDCARD.equals(repo) && isExternalHttpRepo(originalRepository)) {\n                    result = true;\n                    // don't stop processing in case a future segment explicitly excludes this repo\n                } else if (WILDCARD.equals(repo)) {\n                    result = true;\n                    // don't stop processing in case a future segment explicitly excludes this repo\n                }\n            }\n        }\n        return result;\n    }",
    "comment": "This method checks if the pattern matches the originalRepository. Valid patterns:\n<ul>\n<li>{@code *} (since 2.0.5)= everything,</li>\n<li>{@code external:*}  (since 2.0.9)= everything not on the localhost and not file based,</li>\n<li>{@code external:http:*} (since 3.8.0)= any repository not on the localhost using HTTP,</li>\n<li>{@code repo,repo1}  (since 2.0.9)= {@code repo} or {@code repo1},</li>\n<li>{@code *,!repo1} (since 2.0.9)= everything except {@code repo1}.</li>\n</ul>\n\n@param originalRepository to compare for a match.\n@param pattern used for match.\n@return true if the repository is a match to this pattern."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultProfileSelector.java",
    "type": "method",
    "name": "DefaultProfileSelector",
    "code": "public DefaultProfileSelector() {\n        this.activators = new ArrayList<>();\n    }",
    "comment": "Calculates the active profiles among a given collection of profiles."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/textui/TestRunner.java",
    "type": "method",
    "name": "run",
    "code": "static public TestResult run(Test test) {\n        TestRunner runner = new TestRunner();\n        return runner.doRun(test);\n    }",
    "comment": "Runs a single test and collects its results.\nThis method can be used to start a test run\nfrom your program.\n<pre>\npublic static void main (String[] args) {\ntest.textui.TestRunner.run(suite());\n}\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/CleanArgument.java",
    "type": "method",
    "name": "doCleanArgs",
    "code": "private static String[] doCleanArgs(String[] args) {\n        List<String> cleaned = new ArrayList<>();\n\n        StringBuilder currentArg = null;\n\n        for (String arg : args) {\n            boolean addedToBuffer = false;\n\n            if (arg.startsWith(\"\\\"\")) {\n                if (currentArg != null) {\n                    cleaned.add(currentArg.toString());\n                }\n\n                currentArg = new StringBuilder(arg.substring(1));\n                addedToBuffer = true;\n            }\n\n            if (addedToBuffer && arg.endsWith(\"\\\"\")) {\n                if (!currentArg.isEmpty()) {\n                    currentArg.setLength(currentArg.length() - 1);\n                }\n\n                cleaned.add(currentArg.toString());\n\n                currentArg = null;\n                continue;\n            }\n\n            if (!addedToBuffer) {\n                if (currentArg != null) {\n                    currentArg.append(' ').append(arg);\n                } else {\n                    cleaned.add(arg);\n                }\n            }\n        }\n\n        if (currentArg != null) {\n            cleaned.add(currentArg.toString());\n        }\n\n        int cleanedSz = cleaned.size();\n\n        String[] cleanArgs;\n\n        if (cleanedSz == 0) {\n            cleanArgs = args;\n        } else {\n            cleanArgs = cleaned.toArray(new String[0]);\n        }\n\n        return cleanArgs;\n    }",
    "comment": "if we're in the process of building up another arg, push it and start over.\nthis is for the case: \"-Dfoo=bar \"-Dfoo2=bar two\" (note the first unterminated quote)\nstart building an argument here.\nthis has to be a separate \"if\" statement, to capture the case of: \"-Dfoo=bar\"\nif we're building an argument, keep doing so.\nif this is the case of \"-Dfoo=bar\", then we need to adjust the buffer.\nif we haven't added this arg to the buffer, and we ARE building an argument\nbuffer, then append it with a preceding space...again, not sure what else to\ndo other than collapse whitespace.\nNOTE: The case of a trailing quote is handled by nullifying the arg buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelPathTranslator.java",
    "type": "method",
    "name": "alignToBaseDirectory",
    "code": "private String alignToBaseDirectory(String path, Path basedir) {\n        String newPath = pathTranslator.alignToBaseDirectory(path, basedir);\n        return Objects.equals(path, newPath) ? path : newPath;\n    }",
    "comment": "Returns a path relocated to the given base directory. If the result of this operation\nis the same path as before, then this method returns the old {@code path} instance.\nIt is okay for the caller to compare the {@link String} instances using the identity\ncomparator for detecting changes.\n\n@param path the path to relocate, or {@code null}\n@param basedir the new base directory\n@return relocated path, or {@code null} if the given path was null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistrationViaParametersAndFieldsTests.java",
    "type": "method",
    "name": "beforeAll",
    "code": "void beforeAll() {\n\t\t\tassertThat(staticField).isEqualTo(\"beforeAll - staticField\");\n\t\t\tassertThat(instanceField).isEqualTo(\"postProcessTestInstance - instanceField\");\n\t\t}",
    "comment": "The {@link MagicField.Extension} is registered via a static field and\nan instance field."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/demo/app/src/main/java/com/example/android/tflitecamerademo/ImageClassifierFloatInception.java",
    "type": "method",
    "name": "getModelPath",
    "code": "protected String getModelPath() {\n    // you can download this file from\n    // https://storage.googleapis.com/download.tensorflow.org/models/tflite/inception_v3_slim_2016_android_2017_11_10.zip\n    return \"inceptionv3_slim_2016.tflite\";\n  }",
    "comment": "Initializes an {@code ImageClassifier}.\n\n@param activity"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/DatabaseTransactionHealthIndicatorTest.java",
    "type": "method",
    "name": "whenHealthCheckTimesOut_thenHealthIsDown",
    "code": "void whenHealthCheckTimesOut_thenHealthIsDown() {\n    CompletableFuture<Health> future = new CompletableFuture<>();\n    when(asynchronousHealthChecker.performCheck(any(Supplier.class), eq(timeoutInSeconds)))\n        .thenReturn(future);\n\n    // Complete the future exceptionally to simulate a timeout\n    future.completeExceptionally(new RuntimeException(\"Simulated timeout\"));\n\n    Health health = healthIndicator.health();\n\n    // Check that the health status is DOWN due to timeout\n    assertEquals(Status.DOWN, health.getStatus());\n  }",
    "comment": "Test case for the `health()` method when the health check times out.\n\n<p>Asserts that when the `health()` method is called and the health check times out, it returns\na Health object with Status.DOWN."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/secdispatcher/SecDispatcherProvider.java",
    "type": "method",
    "name": "legacyDispatcher",
    "code": "public static Dispatcher legacyDispatcher() {\n        return new LegacyDispatcher();\n    }",
    "comment": "Delegate that offers just the minimal surface needed to decrypt settings."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestWatcher.java",
    "type": "method",
    "name": "testSuccessful",
    "code": "default void testSuccessful(ExtensionContext context) {\n\t\t/* no-op */\n\t}",
    "comment": "Invoked after a test has completed successfully.\n\n<p>The default implementation does nothing. Concrete implementations can\noverride this method as appropriate.\n\n@param context the current extension context; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/Logger.java",
    "type": "method",
    "name": "Logger",
    "code": "public Logger(final String tag, final String messagePrefix) {\n    this.tag = tag;\n    final String prefix = messagePrefix == null ? getCallerSimpleName() : messagePrefix;\n    this.messagePrefix = (prefix.length() > 0) ? prefix + \": \" : prefix;\n  }",
    "comment": "Creates a Logger with a custom tag and a custom message prefix. If the message prefix\nis set to <pre>null</pre>, the caller's class name is used as the prefix.\n\n@param tag identifies the source of a log message.\n@param messagePrefix prepended to every message if non-null. If null, the name of the caller is\nbeing used"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/HiveSQLException.java",
    "type": "method",
    "name": "toTStatus",
    "code": "public static TStatus toTStatus(Exception e) {\n    if (e instanceof HiveSQLException) {\n      return ((HiveSQLException)e).toTStatus();\n    }\n    TStatus tStatus = new TStatus(TStatusCode.ERROR_STATUS);\n    tStatus.setErrorMessage(e.getMessage());\n    tStatus.setInfoMessages(toString(e));\n    return tStatus;\n  }",
    "comment": "Converts the specified {@link Exception} object into a {@link TStatus} object\n@param e a {@link Exception} object\n@return a {@link TStatus} object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/util/collection/TestTimSort.java",
    "type": "method",
    "name": "generateJDKWrongElem",
    "code": "private static void generateJDKWrongElem(List<Long> runs, int minRun, long X) {\n    for (long newTotal; X >= 2L * minRun + 1; X = newTotal) {\n      //Default strategy\n      newTotal = X / 2 + 1;\n      //Specialized strategies\n      if (3L * minRun + 3 <= X && X <= 4L * minRun + 1) {\n        // add x_1=MIN+1, x_2=MIN, x_3=X-newTotal  to runs\n        newTotal = 2L * minRun + 1;\n      } else if (5L * minRun + 5 <= X && X <= 6L * minRun + 5) {\n        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=X-newTotal  to runs\n        newTotal = 3L * minRun + 3;\n      } else if (8L * minRun + 9 <= X && X <= 10L * minRun + 9) {\n        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=2MIN+2, x_5=X-newTotal  to runs\n        newTotal = 5L * minRun + 5;\n      } else if (13L * minRun + 15 <= X && X <= 16L * minRun + 17) {\n        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=2MIN+2, x_5=3MIN+4, x_6=X-newTotal to runs\n        newTotal = 8L * minRun + 9;\n      }\n      runs.add(0, X - newTotal);\n    }\n    runs.add(0, X);\n  }",
    "comment": "Adds a sequence x_1, ..., x_n of run lengths to <code>runs</code> such that:<br>\n1. X = x_1 + ... + x_n <br>\n2. x_j >= minRun for all j <br>\n3. x_1 + ... + x_{j-2}  <  x_j  <  x_1 + ... + x_{j-1} for all j <br>\nThese conditions guarantee that TimSort merges all x_j's one by one\n(resulting in X) using only merges on the second-to-last element.\n\n@param X The sum of the sequence that should be added to runs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/RocksDBTypeInfo.java",
    "type": "method",
    "name": "Index",
    "code": "private Index(KVIndex self, KVTypeInfo.Accessor accessor, Index parent) {\n      byte[] name = self.value().getBytes(UTF_8);\n      if (parent != null) {\n        byte[] child = new byte[name.length + 1];\n        child[0] = SECONDARY_IDX_PREFIX;\n        System.arraycopy(name, 0, child, 1, name.length);\n      }\n\n      this.name = name;\n      this.isNatural = self.value().equals(KVIndex.NATURAL_INDEX_NAME);\n      this.copy = isNatural || self.copy();\n      this.accessor = accessor;\n      this.parent = parent;\n    }",
    "comment": "Models a single index in RocksDB. See top-level class's javadoc for a description of how the\nkeys are generated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotNull",
    "code": "public static void assertNotNull(Object actual, Supplier<String> messageSupplier) {\n\t\tAssertNotNull.assertNotNull(actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code actual} is not {@code null}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/model/plugin/DefaultLifecycleBindingsInjector.java",
    "type": "method",
    "name": "DefaultLifecycleBindingsInjector",
    "code": "public DefaultLifecycleBindingsInjector(LifeCyclePluginAnalyzer lifecycle) {\n        this.lifecycle = lifecycle;\n    }",
    "comment": "Handles injection of plugin executions induced by the lifecycle bindings for a packaging."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/AlbumPage.java",
    "type": "method",
    "name": "changeArtist",
    "code": "public AlbumPage changeArtist(String artist) {\n    var artistInputTextField = (HtmlTextInput) page.getElementById(\"albumArtist\");\n    artistInputTextField.setText(artist);\n    return this;\n  }",
    "comment": "Sets the artist input text field.\n\n@param artist the new artist value to set\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/multiton/src/main/java/com/iluwatar/multiton/Nazgul.java",
    "type": "method",
    "name": "Nazgul",
    "code": "private Nazgul(NazgulName name) {\n    this.name = name;\n  }",
    "comment": "Nazgul is a Multiton class. Nazgul instances can be queried using {@link #getInstance} method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "allocate",
    "code": "private void allocate(int capacity) {\n    assert (capacity >= 0);\n    capacity = Math.max((int) Math.min(MAX_CAPACITY, ByteArrayMethods.nextPowerOf2(capacity)), 64);\n    assert (capacity <= MAX_CAPACITY);\n    longArray = allocateArray(capacity * 2L);\n    longArray.zeroOut();\n\n    this.growthThreshold = (int) (capacity * loadFactor);\n    this.mask = capacity - 1;\n  }",
    "comment": "Allocate new data structures for this map. When calling this outside of the constructor,\nmake sure to keep references to the old data structures so that you can free them.\n\n@param capacity the new map capacity"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Integer> create(Scope scope, int[][][][] data) {\n    return create(scope, data, Integer.class);\n  }",
    "comment": "Creates a rank-4 constant of {@code int} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java",
    "type": "method",
    "name": "runGenericFileSourceOptionsExample",
    "code": "private static void runGenericFileSourceOptionsExample(SparkSession spark) {\n    Dataset<Row> testCorruptDF0 = spark.read().option(\"ignoreCorruptFiles\", \"true\").parquet(\n        \"examples/src/main/resources/dir1/\",\n        \"examples/src/main/resources/dir1/dir2/\");\n    testCorruptDF0.show();\n\n    spark.sql(\"set spark.sql.files.ignoreCorruptFiles=true\");\n    Dataset<Row> testCorruptDF1 = spark.read().parquet(\n            \"examples/src/main/resources/dir1/\",\n            \"examples/src/main/resources/dir1/dir2/\");\n    testCorruptDF1.show();\n    Dataset<Row> recursiveLoadedDF = spark.read().format(\"parquet\")\n            .option(\"recursiveFileLookup\", \"true\")\n            .load(\"examples/src/main/resources/dir1\");\n    recursiveLoadedDF.show();\n    spark.sql(\"set spark.sql.files.ignoreCorruptFiles=false\");\n    Dataset<Row> testGlobFilterDF = spark.read().format(\"parquet\")\n            .option(\"pathGlobFilter\", \"*.parquet\") // json file should be filtered out\n            .load(\"examples/src/main/resources/dir1\");\n    testGlobFilterDF.show();\n    Dataset<Row> beforeFilterDF = spark.read().format(\"parquet\")\n            .option(\"modifiedBefore\", \"2020-07-01T05:30:00\")\n            .option(\"modifiedAfter\", \"2020-06-01T05:30:00\")\n            .option(\"timeZone\", \"CST\")\n            .load(\"examples/src/main/resources/dir1\");\n    beforeFilterDF.show();\n  }",
    "comment": "$example on:ignore_corrupt_files$\nenable ignore corrupt files via the data source option\ndir1/file3.json is corrupt from parquet's view\n+-------------+\n|         file|\n+-------------+\n|file1.parquet|\n|file2.parquet|\n+-------------+\nenable ignore corrupt files via the configuration\ndir1/file3.json is corrupt from parquet's view\n+-------------+\n|         file|\n+-------------+\n|file1.parquet|\n|file2.parquet|\n+-------------+\n$example off:ignore_corrupt_files$\n$example on:recursive_file_lookup$\n+-------------+\n|         file|\n+-------------+\n|file1.parquet|\n|file2.parquet|\n+-------------+\n$example off:recursive_file_lookup$\n$example on:load_with_path_glob_filter$\n+-------------+\n|         file|\n+-------------+\n|file1.parquet|\n+-------------+\n$example off:load_with_path_glob_filter$\n$example on:load_with_modified_time_filter$\nOnly load files modified before 7/1/2020 at 05:30\nOnly load files modified after 6/1/2020 at 05:30\nInterpret both times above relative to CST timezone\n+-------------+\n|         file|\n+-------------+\n|file1.parquet|\n+-------------+\n$example off:load_with_modified_time_filter$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistry.java",
    "type": "method",
    "name": "getExtensions",
    "code": "default <E extends Extension> List<E> getExtensions(Class<E> extensionType) {\n\t\treturn stream(extensionType).collect(toCollection(ArrayList::new));\n\t}",
    "comment": "Get all {@code Extensions} of the specified type that are present\nin this registry or one of its ancestors.\n\n@param extensionType the type of {@link Extension} to get\n@see #stream(Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/component/src/main/java/com/iluwatar/component/GameObject.java",
    "type": "method",
    "name": "demoUpdate",
    "code": "public void demoUpdate() {\n    inputComponent.update(this, 0);\n    physicComponent.update(this);\n    graphicComponent.update(this);\n  }",
    "comment": "Updates the three components of the NPC object used in the demo in App.java note that this is\nsimply a duplicate of update() without the key event for demonstration purposes.\n\n<p>This method is usually used in games if the player becomes inactive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/CycleDetectedInPluginGraphException.java",
    "type": "method",
    "name": "CycleDetectedInPluginGraphException",
    "code": "public CycleDetectedInPluginGraphException(Plugin plugin, CycleDetectedInComponentGraphException e) {\n        super(\"A cycle was detected in the component graph of the plugin: \" + plugin.getArtifactId());\n\n        this.plugin = plugin;\n    }",
    "comment": "Exception occurring trying to resolve a plugin."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/subclass-sandbox/src/main/java/com/iluwatar/subclasssandbox/Superpower.java",
    "type": "method",
    "name": "playSound",
    "code": "protected void playSound(String soundName, int volume) {\n    logger.info(\"Play {} with volume {}\", soundName, volume);\n  }",
    "comment": "Play sound effect for the superpower.\n\n@param soundName Sound name.\n@param volume Value of volume."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTimeout",
    "code": "public static void assertTimeout(Duration timeout, Executable executable) {\n\t\tAssertTimeout.assertTimeout(timeout, executable);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code executable}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>Note: the {@code executable} will be executed in the same thread as that\nof the calling code. Consequently, execution of the {@code executable} will\nnot be preemptively aborted if the timeout is exceeded.\n\n@see #assertTimeout(Duration, Executable, String)\n@see #assertTimeout(Duration, Executable, Supplier)\n@see #assertTimeout(Duration, ThrowingSupplier)\n@see #assertTimeout(Duration, ThrowingSupplier, String)\n@see #assertTimeout(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeoutPreemptively(Duration, Executable)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/model/plugin/DefaultLifecycleBindingsInjector.java",
    "type": "method",
    "name": "merge",
    "code": "public void merge(Model target, Model source) {\n            if (target.getBuild() == null) {\n                target.setBuild(new Build());\n            }\n\n            Map<Object, Object> context = Collections.singletonMap(\n                    PLUGIN_MANAGEMENT, target.getBuild().getPluginManagement());\n\n            mergePluginContainer_Plugins(target.getBuild(), source.getBuild(), false, context);\n        }",
    "comment": "The domain-specific model merger for lifecycle bindings"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/OnHeapColumnVector.java",
    "type": "method",
    "name": "allocateColumns",
    "code": "public static OnHeapColumnVector[] allocateColumns(int capacity, StructType schema) {\n    return allocateColumns(capacity, schema.fields());\n  }",
    "comment": "Allocates columns to store elements of each field of the schema on heap.\nCapacity is the initial capacity of the vector and it will grow as necessary. Capacity is\nin number of elements, not number of bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/rules/RuleMemberValidator.java",
    "type": "method",
    "name": "validate",
    "code": "public void validate(FrameworkMember<?> member, Class<? extends Annotation> annotation, List<Throwable> errors) {\n            if (!member.isStatic()) {\n                errors.add(new ValidationError(member, annotation,\n                        \"must be static.\"));\n            }\n        }",
    "comment": "Requires the member to be static"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Double> create(Scope scope, double[][][] data) {\n    return create(scope, data, Double.class);\n  }",
    "comment": "Creates a rank-3 constant of {@code double} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProblemCollector.java",
    "type": "method",
    "name": "empty",
    "code": "static <P extends BuilderProblem> ProblemCollector<P> empty() {\n        return new ProblemCollector<>() {\n\n            @Override\n            public int problemsReportedFor(BuilderProblem.Severity... severities) {\n                return 0;\n            }\n\n            @Override\n            public boolean reportProblem(P problem) {\n                throw new IllegalStateException(\"empty problem collector\");\n            }\n\n            @Override\n            public Stream<P> problems(BuilderProblem.Severity severity) {\n                return Stream.empty();\n            }\n        };\n    }",
    "comment": "Creates an \"empty\" problem collector that doesn't store any problems.\n\n@param <P> the type of problem\n@return an empty problem collector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "Event",
    "code": "private Event(EventType type, TestDescriptor testDescriptor, Object payload) {\n\t\tthis.type = Preconditions.notNull(type, \"EventType must not be null\");\n\t\tthis.testDescriptor = Preconditions.notNull(testDescriptor, \"TestDescriptor must not be null\");\n\t\tthis.payload = payload;\n\t}",
    "comment": "Construct an {@code Event} with the supplied arguments.\n\n@param type the type of the event; never {@code null}\n@param testDescriptor the {@code TestDescriptor} associated with the event;\nnever {@code null}\n@param payload the generic payload associated with the event; may be {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/lockable-object/src/main/java/com/iluwatar/lockableobject/domain/Orc.java",
    "type": "method",
    "name": "Orc",
    "code": "public Orc(String name) {\n    super(name);\n    setType(CreatureType.ORC);\n    setDamage(CreatureStats.ORC_DAMAGE.getValue());\n    setHealth(CreatureStats.ORC_HEALTH.getValue());\n  }",
    "comment": "A constructor that initializes the attributes of an orc.\n\n@param name as the name of the creature."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/BaseParser.java",
    "type": "method",
    "name": "readCoreExtensionsDescriptor",
    "code": "protected List<CoreExtensions> readCoreExtensionsDescriptor(LocalContext context) {\n        ArrayList<CoreExtensions> result = new ArrayList<>();\n        Path file;\n        List<CoreExtension> loaded;\n\n        // project\n        file = context.cwd.resolve(context.userProperties.get(Constants.MAVEN_PROJECT_EXTENSIONS));\n        loaded = readCoreExtensionsDescriptorFromFile(file);\n        if (!loaded.isEmpty()) {\n            result.add(new CoreExtensions(file, loaded));\n        }\n\n        // user\n        file = context.userHomeDirectory.resolve(context.userProperties.get(Constants.MAVEN_USER_EXTENSIONS));\n        loaded = readCoreExtensionsDescriptorFromFile(file);\n        if (!loaded.isEmpty()) {\n            result.add(new CoreExtensions(file, loaded));\n        }\n\n        // installation\n        file = context.installationDirectory.resolve(\n                context.userProperties.get(Constants.MAVEN_INSTALLATION_EXTENSIONS));\n        loaded = readCoreExtensionsDescriptorFromFile(file);\n        if (!loaded.isEmpty()) {\n            result.add(new CoreExtensions(file, loaded));\n        }\n\n        return result.isEmpty() ? null : List.copyOf(result);\n    }",
    "comment": "Important: This method must return list of {@link CoreExtensions} in precedence order."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/queue-based-load-leveling/src/main/java/com/iluwatar/queue/load/leveling/ServiceExecutor.java",
    "type": "method",
    "name": "ServiceExecutor",
    "code": "public ServiceExecutor(MessageQueue msgQueue) {\n    this.msgQueue = msgQueue;\n  }",
    "comment": "ServiceExecuotr class. This class will pick up Messages one by one from the Blocking Queue and\nprocess them."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Float expected, Float actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/transfer/TransferResourceIdentifier.java",
    "type": "method",
    "name": "TransferResourceIdentifier",
    "code": "record TransferResourceIdentifier(String repositoryId, String repositoryUrl, String resourceName, @Nullable Path file) {\n    TransferResourceIdentifier(TransferResource resource) {\n        this(resource.getRepositoryId(), resource.getRepositoryUrl(), resource.getResourceName(), resource.getPath());\n    }\n}",
    "comment": "Immutable identifier of a {@link TransferResource}.\nThe {@link TransferResource} is not immutable and does not implement {@code Objects#equals} and {@code Objects#hashCode} methods,\nmaking it not very suitable for usage in collections."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(boolean[] expected, boolean[] actual, Supplier<String> messageSupplier) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} boolean arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/AbstractService.java",
    "type": "method",
    "name": "changeState",
    "code": "private void changeState(Service.STATE newState) {\n    state = newState;\n    // notify listeners\n    for (ServiceStateChangeListener l : listeners) {\n      l.stateChanged(this);\n    }\n  }",
    "comment": "Change to a new state and notify all listeners.\nThis is a private method that is only invoked from synchronized methods,\nwhich avoid having to clone the listener list. It does imply that\nthe state change listener methods should be short lived, as they\nwill delay the state transition.\n\n@param newState\nnew service state"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/LoginPage.java",
    "type": "method",
    "name": "enterUsername",
    "code": "public LoginPage enterUsername(String username) {\n    var usernameInputTextField = (HtmlTextInput) page.getElementById(\"username\");\n    usernameInputTextField.setText(username);\n    return this;\n  }",
    "comment": "Enters the username into the username input text field\n\n@param username the username to enter\n@return {@link LoginPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/repository/Authentication.java",
    "type": "method",
    "name": "setPrivateKey",
    "code": "public void setPrivateKey(final String privateKey) {\n        this.privateKey = privateKey;\n    }",
    "comment": "Set the absolute path to private key file.\n\n@param privateKey path to private key in local file system"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedRleValuesReader.java",
    "type": "method",
    "name": "readNextGroup",
    "code": "private boolean readNextGroup() {\n    if (in.available() <= 0) {\n      currentCount = 0;\n      return false;\n    }\n\n    try {\n      int header = readUnsignedVarInt();\n      this.mode = (header & 1) == 0 ? MODE.RLE : MODE.PACKED;\n      switch (mode) {\n        case RLE -> {\n          this.currentCount = header >>> 1;\n          this.currentValue = readIntLittleEndianPaddedOnBitWidth();\n        }\n        case PACKED -> {\n          int numGroups = header >>> 1;\n          this.currentCount = numGroups * 8;\n\n          if (this.currentBuffer.length < this.currentCount) {\n            this.currentBuffer = new int[this.currentCount];\n          }\n          currentBufferIdx = 0;\n          int valueIndex = 0;\n          while (valueIndex < this.currentCount) {\n            // values are bit packed 8 at a time, so reading bitWidth will always work\n            ByteBuffer buffer = in.slice(bitWidth);\n            this.packer.unpack8Values(buffer, buffer.position(), this.currentBuffer, valueIndex);\n            valueIndex += 8;\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new ParquetDecodingException(\"Failed to read from input stream\", e);\n    }\n\n    return true;\n  }",
    "comment": "Reads the next group. Returns false if no more group available."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/textui/ResultPrinter.java",
    "type": "method",
    "name": "elapsedTimeAsString",
    "code": "protected String elapsedTimeAsString(long runTime) {\n        return NumberFormat.getInstance().format((double) runTime / 1000);\n    }",
    "comment": "Returns the formatted string of the elapsed time.\nDuplicated from BaseTestRunner. Fix it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/crypto/CtrTransportCipher.java",
    "type": "method",
    "name": "createEncryptedMessage",
    "code": "EncryptedMessage createEncryptedMessage(Object msg) {\n      return new EncryptedMessage(this, cos, msg, byteEncChannel, byteRawChannel);\n    }",
    "comment": "Add handlers to channel.\n\n@param ch the channel for adding handlers\n@throws IOException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroNonNullableArrays.java",
    "type": "method",
    "name": "setMaybeIntsColumn",
    "code": "public void setMaybeIntsColumn(java.util.List<java.lang.Integer> value) {\n    this.maybe_ints_column = value;\n  }",
    "comment": "Sets the value of the 'maybe_ints_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/PackageUtilsTests.java",
    "type": "method",
    "name": "getAttributeWithNullType",
    "code": "void getAttributeWithNullType() {\n\t\tvar exception = assertThrows(PreconditionViolationException.class,\n\t\t\t() -> PackageUtils.getAttribute(null, p -> \"any\"));\n\t\tassertEquals(\"type must not be null\", exception.getMessage());\n\t}",
    "comment": "Unit tests for {@link PackageUtils}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/repository/ArtifactRepositoryPolicy.java",
    "type": "method",
    "name": "checkOutOfDate",
    "code": "public boolean checkOutOfDate(Date lastModified) {\n        boolean checkForUpdates = false;\n\n        if (UPDATE_POLICY_ALWAYS.equals(updatePolicy)) {\n            checkForUpdates = true;\n        } else if (UPDATE_POLICY_DAILY.equals(updatePolicy)) {\n            Calendar cal = Calendar.getInstance();\n\n            cal.set(Calendar.HOUR_OF_DAY, 0);\n            cal.set(Calendar.MINUTE, 0);\n            cal.set(Calendar.SECOND, 0);\n            cal.set(Calendar.MILLISECOND, 0);\n\n            if (cal.getTime().after(lastModified)) {\n                checkForUpdates = true;\n            }\n        } else if (updatePolicy.startsWith(UPDATE_POLICY_INTERVAL)) {\n            String s = updatePolicy.substring(UPDATE_POLICY_INTERVAL.length() + 1);\n            int minutes = Integer.parseInt(s);\n            Calendar cal = Calendar.getInstance();\n            cal.add(Calendar.MINUTE, -minutes);\n            if (cal.getTime().after(lastModified)) {\n                checkForUpdates = true;\n            }\n        }\n        return checkForUpdates;\n    }",
    "comment": "Get local midnight boundary\nelse assume \"never\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dynamic-proxy/src/main/java/com/iluwatar/dynamicproxy/tinyrestclient/JsonUtil.java",
    "type": "method",
    "name": "jsonToList",
    "code": "public static <T> List<T> jsonToList(String json, Class<T> clazz) {\n    try {\n      CollectionType listType =\n          objectMapper.getTypeFactory().constructCollectionType(ArrayList.class, clazz);\n      return objectMapper.reader().forType(listType).readValue(json);\n    } catch (JsonProcessingException e) {\n      LOGGER.error(\"Cannot convert the Json \" + json + \" to List of \" + clazz.getName() + \".\", e);\n      return List.of();\n    }\n  }",
    "comment": "Convert a Json string to a List of objects of a class.\n\n@param json Json string to convert.\n@param clazz Object's class.\n@param <T> Object's generic class.\n@return List of objects."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java",
    "type": "method",
    "name": "merge",
    "code": "public void merge(org.apache.maven.repository.legacy.metadata.ArtifactMetadata metadata) {\n        AbstractRepositoryMetadata repoMetadata = (AbstractRepositoryMetadata) metadata;\n        this.metadata.merge(repoMetadata.getMetadata());\n    }",
    "comment": "TODO not sure that it should assume this, maybe the calls to addMetadata should pre-merge, then artifact\nreplaces?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java",
    "type": "method",
    "name": "isActive",
    "code": "public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        Activation activation = profile.getActivation();\n\n        if (activation == null) {\n            return false;\n        }\n\n        ActivationOS os = activation.getOs();\n\n        if (os == null) {\n            return false;\n        }\n\n        boolean active = ensureAtLeastOneNonNull(os);\n\n        String actualOsName = context.getSystemProperties()\n                .getOrDefault(\"os.name\", Os.OS_NAME)\n                .toLowerCase(Locale.ENGLISH);\n        String actualOsArch = context.getSystemProperties()\n                .getOrDefault(\"os.arch\", Os.OS_ARCH)\n                .toLowerCase(Locale.ENGLISH);\n        String actualOsVersion = context.getSystemProperties()\n                .getOrDefault(\"os.version\", Os.OS_VERSION)\n                .toLowerCase(Locale.ENGLISH);\n\n        if (active && os.getFamily() != null) {\n            active = determineFamilyMatch(os.getFamily(), actualOsName);\n        }\n        if (active && os.getName() != null) {\n            active = determineNameMatch(os.getName(), actualOsName);\n        }\n        if (active && os.getArch() != null) {\n            active = determineArchMatch(os.getArch(), actualOsArch);\n        }\n        if (active && os.getVersion() != null) {\n            active = determineVersionMatch(os.getVersion(), actualOsVersion);\n        }\n\n        return active;\n    }",
    "comment": "Determines profile activation based on the operating system of the current runtime platform.\n\n@see ActivationOS\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/PrefixedObjectValueSource.java",
    "type": "method",
    "name": "PrefixedObjectValueSource",
    "code": "public PrefixedObjectValueSource(String prefix, Object root) {\n        super(new PrefixedValueSourceWrapper(new ObjectBasedValueSource(root), prefix));\n    }",
    "comment": "Wrap the specified root object, allowing the specified expression prefix.\n@param prefix the prefix.\n@param root the root of the graph."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/simple/SimpleFluentIterable.java",
    "type": "method",
    "name": "last",
    "code": "public final Optional<E> last() {\n    var list = last(1).asList();\n    if (list.isEmpty()) {\n      return Optional.empty();\n    }\n    return Optional.of(list.get(0));\n  }",
    "comment": "Can be used to collect objects from the Iterable. Is a terminating operation.\n\n@return an option of the last object of the Iterable"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room2/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "updateUserName",
    "code": "void updateUserName(String userName, UpdateUserCallback callback) {\n        final WeakReference<UpdateUserCallback> updateUserCallback = new WeakReference<>(callback);\n\n        Date date = new Date(System.currentTimeMillis());\n        final User user = mCachedUser == null\n                ? new User(userName)\n                : new User(mCachedUser.getId(), userName, date);\n\n        // update the user on the I/O thread\n        mAppExecutors.diskIO().execute(() -> {\n            mUserDataSource.insertOrUpdateUser(user);\n            mCachedUser = user;\n            // notify on the main thread\n            mAppExecutors.mainThread().execute(() -> {\n                UpdateUserCallback userCallback = updateUserCallback.get();\n                if (userCallback != null) {\n                    userCallback.onUserUpdated(user);\n                }\n            });\n        });\n    }",
    "comment": "Insert an new user or update the name of the user.\n\n@param userName the user name\n@param callback callback that gets triggered when the user was updated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertDoesNotThrow",
    "code": "public static void assertDoesNotThrow(Executable executable, Supplier<String> messageSupplier) {\n\t\tAssertDoesNotThrow.assertDoesNotThrow(executable, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code executable} does\n<em>not</em> throw any kind of {@linkplain Throwable exception}.\n\n<h4>Usage Note</h4>\n<p>Although any exception thrown from a test method will cause the test\nto <em>fail</em>, there are certain use cases where it can be beneficial\nto explicitly assert that an exception is not thrown for a given code\nblock within a test method.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Byte expected, byte actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Byte) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "outputDirectoryProvider",
    "code": "public Builder outputDirectoryProvider(OutputDirectoryProvider outputDirectoryProvider) {\n\t\t\tthis.requestBuilder.outputDirectoryProvider(outputDirectoryProvider);\n\t\t\treturn this;\n\t\t}",
    "comment": "Set the {@link OutputDirectoryProvider} to use.\n\n<p>If not specified, a default provider will be used that throws an\nexception when attempting to create output directories. This is done\nto avoid accidentally writing output files to the file system.\n\n@param outputDirectoryProvider the output directory provider to use;\nnever {@code null}\n@return this builder for method chaining\n@since 1.12\n@see OutputDirectoryProvider"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<String> create(Scope scope, byte[][][][] data) {\n    return create(scope, data, String.class);\n  }",
    "comment": "Creates a rank-3 constant of {@code String} elements, each represented as an array of {@code byte}s.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/domain-model/src/main/java/com/iluwatar/domainmodel/Customer.java",
    "type": "method",
    "name": "returnProduct",
    "code": "public void returnProduct(Product product) {\n    LOGGER.info(\n        String.format(\n            \"%s want to return %s($%.2f)...\",\n            name, product.getName(), product.getSalePrice().getAmount()));\n    if (purchases.contains(product)) {\n      try {\n        customerDao.deleteProduct(product, this);\n        purchases.remove(product);\n        receiveMoney(product.getSalePrice());\n        LOGGER.info(String.format(\"%s returned %s!\", name, product.getName()));\n      } catch (SQLException ex) {\n        LOGGER.error(ex.getMessage());\n      }\n    } else {\n      LOGGER.error(String.format(\"%s didn't buy %s...\", name, product.getName()));\n    }\n  }",
    "comment": "Remove product from purchases, delete from db and return money.\n\n@param product to return."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(byte expected, byte actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n\t\tSoftReference<String> s = this.toString;\n\t\tString value = s == null ? null : s.get();\n\t\tif (value == null) {\n\t\t\tvalue = this.uniqueIdFormat.format(this);\n\t\t\t// this is a benign race like String#hash\n\t\t\t// we potentially read and write values from multiple threads\n\t\t\t// without a happens-before relationship\n\t\t\t// however the JMM guarantees us that we only ever see values\n\t\t\t// that were valid at one point, either null or the toString value\n\t\t\t// so we might end up not seeing a value that a different thread\n\t\t\t// has computed or multiple threads writing the same value\n\t\t\tthis.toString = new SoftReference<>(value);\n\t\t}\n\t\treturn value;\n\t}",
    "comment": "Generate the unique, formatted string representation of this {@code UniqueId}\nusing the configured {@link UniqueIdFormat}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/test/java/com/iluwatar/async/method/invocation/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/discovery/LauncherDiscoveryListeners.java",
    "type": "method",
    "name": "abortOnFailure",
    "code": "public static LauncherDiscoveryListener abortOnFailure() {\n\t\treturn new AbortOnFailureLauncherDiscoveryListener();\n\t}",
    "comment": "Create a {@link LauncherDiscoveryListener} that aborts test discovery on\nfailures.\n\n<p>The following events are considered failures:\n\n<ul>\n<li>\na {@linkplain Status#FAILED failed} resolution result.\n</li>\n<li>\nan {@linkplain Status#FAILED unresolved} resolution result for a\n{@link UniqueIdSelector} that starts with the engine's unique ID.\n</li>\n<li>\nany recoverable {@link Throwable} thrown by\n{@link TestEngine#discover}.\n</li>\n</ul>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/ParquetAvroCompat.java",
    "type": "method",
    "name": "setComplexColumn",
    "code": "public void setComplexColumn(java.util.Map<java.lang.String,java.util.List<org.apache.spark.sql.execution.datasources.parquet.test.avro.Nested>> value) {\n    this.complex_column = value;\n  }",
    "comment": "Sets the value of the 'complex_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/HiveSQLException.java",
    "type": "method",
    "name": "toString",
    "code": "public static List<String> toString(Throwable ex) {\n    return toString(ex, null);\n  }",
    "comment": "Converts a {@link Throwable} object into a flattened list of texts including its stack trace\nand the stack traces of the nested causes.\n@param ex  a {@link Throwable} object\n@return    a flattened list of texts including the {@link Throwable} object's stack trace\nand the stack traces of the nested causes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/AggregateHashMap.java",
    "type": "method",
    "name": "AggregateHashMap",
    "code": "public AggregateHashMap(StructType schema, int capacity, double loadFactor, int maxSteps) {\n\n    // We currently only support single key-value pair that are both longs\n    assert (schema.size() == 2 && schema.fields()[0].dataType() == LongType &&\n        schema.fields()[1].dataType() == LongType);\n\n    // capacity should be a power of 2\n    assert (capacity > 0 && ((capacity & (capacity - 1)) == 0));\n\n    this.maxSteps = maxSteps;\n    numBuckets = (int) (capacity / loadFactor);\n    columnVectors = OnHeapColumnVector.allocateColumns(capacity, schema);\n    aggBufferRow = new MutableColumnarRow(columnVectors);\n    buckets = new int[numBuckets];\n    Arrays.fill(buckets, -1);\n  }",
    "comment": "This is an illustrative implementation of an append-only single-key/single value aggregate hash\nmap that can act as a 'cache' for extremely fast key-value lookups while evaluating aggregates\n(and fall back to the `BytesToBytesMap` if a given key isn't found). This can be potentially\n'codegened' in HashAggregate to speed up aggregates w/ key.\n\nIt is backed by a power-of-2-sized array for index lookups and a columnar batch that stores the\nkey-value pairs. The index lookups in the array rely on linear probing (with a small number of\nmaximum tries) and use an inexpensive hash function which makes it really efficient for a\nmajority of lookups. However, using linear probing and an inexpensive hash function also makes it\nless robust as compared to the `BytesToBytesMap` (especially for a large number of keys or even\nfor certain distribution of keys) and requires us to fall back on the latter for correctness."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethodTests.java",
    "type": "method",
    "name": "publicTestMethodWithArgument",
    "code": "void publicTestMethodWithArgument() {\n\t\tMethod method = method(\"publicTestMethodWithArgument\", TestInfo.class);\n\t\tassertTrue(ModifierSupport.isPublic(method));\n\t\tassertThat(isTestMethod).accepts(method);\n\t}",
    "comment": "Ensure that somebody doesn't accidentally delete the public modifier again."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/categories/Categories.java",
    "type": "method",
    "name": "matchesAllParentCategories",
    "code": "private boolean matchesAllParentCategories(Set<Class<?>> childCategories, Set<Class<?>> parentCategories) {\n            for (Class<?> parentCategory : parentCategories) {\n                if (!hasAssignableTo(childCategories, parentCategory)) {\n                    return false;\n                }\n            }\n            return true;\n        }",
    "comment": "@return <tt>false</tt> if at least one parent category does not match children, otherwise <tt>true</tt>.\nIf empty <tt>parentCategories</tt>, returns <tt>true</tt>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/DependencyResolutionRequiredException.java",
    "type": "method",
    "name": "DependencyResolutionRequiredException",
    "code": "public DependencyResolutionRequiredException(Artifact artifact) {\n        super(\"Attempted to access the artifact \" + artifact + \"; which has not yet been resolved\");\n    }",
    "comment": "Exception that occurs when an artifact file is used, but has not been resolved.\n\nTODO it may be better for artifact.getFile() to throw it - perhaps it is a runtime exception?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java",
    "type": "method",
    "name": "cause",
    "code": "default Builder cause(Optional<Throwable> cause) {\n\t\t\tcause.ifPresent(this::cause);\n\t\t\treturn this;\n\t\t}",
    "comment": "Set the {@link Throwable} that caused the {@code DiscoveryIssue}.\n\n@param cause the {@link Throwable} that caused the\n{@code DiscoveryIssue}; never {@code null} but potentially empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/layered-architecture/src/main/java/com/iluwatar/layers/Runner.java",
    "type": "method",
    "name": "Runner",
    "code": "public Runner(CakeBakingService cakeBakingService) {\n    this.cakeBakingService = cakeBakingService;\n  }",
    "comment": "The Runner class is the entry point of the application. It implements CommandLineRunner, which\nmeans it will execute the run method after the application context is loaded.\n\n<p>The Runner class is responsible for initializing the cake baking service with sample data and\ncreating a view to render the cakes. It uses the CakeBakingService to save new layers and\ntoppings and to bake new cakes. It also handles exceptions that might occur during the cake\nbaking process."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/profiles/activation/FileProfileActivator.java",
    "type": "method",
    "name": "isActive",
    "code": "public boolean isActive(Profile profile) {\n        Activation activation = profile.getActivation();\n\n        ActivationFile actFile = activation.getFile();\n\n        if (actFile != null) {\n            String fileString = actFile.getExists();\n\n            RegexBasedInterpolator interpolator = new RegexBasedInterpolator();\n            try {\n                interpolator.addValueSource(new EnvarBasedValueSource());\n            } catch (IOException e) {\n            }\n            interpolator.addValueSource(new MapBasedValueSource(System.getProperties()));\n\n            try {\n                if (fileString != null && !fileString.isEmpty()) {\n                    fileString = interpolator.interpolate(fileString, \"\").replace(\"\\\\\", \"/\");\n                    File file = new File(fileString);\n                    return file.exists();\n                }\n\n                fileString = actFile.getMissing();\n\n                if (fileString != null && !fileString.isEmpty()) {\n                    fileString = interpolator.interpolate(fileString, \"\").replace(\"\\\\\", \"/\");\n                    File file = new File(fileString);\n                    return !file.exists();\n                }\n            } catch (InterpolationException e) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Failed to interpolate missing file location for profile activator: \" + fileString, e);\n                } else {\n                    logger.warn(\"Failed to interpolate missing file location for profile activator: \" + fileString\n                            + \", enable verbose output (-X) for more details\");\n                }\n            }\n        }\n\n        return false;\n    }",
    "comment": "check if the file exists, if it does then the profile will be active\nignored\ncheck if the file is missing, if it is then the profile will be active"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java",
    "type": "method",
    "name": "getRequiredTestInstances",
    "code": "default TestInstances getRequiredTestInstances() {\n\t\treturn Preconditions.notNull(getTestInstances().orElse(null),\n\t\t\t\"Illegal state: required test instances are not present in the current ExtensionContext\");\n\t}",
    "comment": "Get the <em>required</em> test instances associated with the current test\nor container.\n\n<p>Use this method as an alternative to {@link #getTestInstances()} for use\ncases in which the test instances are required to be present.\n\n@return the test instances; never {@code null}\n@throws PreconditionViolationException if the test instances are not present\nin this {@code ExtensionContext}\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "getUser",
    "code": "void getUser(LoadUserCallback callback) {\n        final WeakReference<LoadUserCallback> loadUserCallback = new WeakReference<>(callback);\n\n        // request the user on the I/O thread\n        mAppExecutors.diskIO().execute(() -> {\n            final User user = mUserDataSource.getUser();\n            // notify on the main thread\n            mAppExecutors.mainThread().execute(() -> {\n                final LoadUserCallback userCallback = loadUserCallback.get();\n                if (userCallback == null) {\n                    return;\n                }\n                if (user == null) {\n                    userCallback.onDataNotAvailable();\n                } else {\n                    mCachedUser = user;\n                    userCallback.onUserLoaded(mCachedUser);\n                }\n            });\n        });\n    }",
    "comment": "Get the user from the data source, cache it and notify via the callback that the user has\nbeen retrieved.\n\n@param callback callback that gets called when the user was retrieved from the data source."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/experimental/AssumptionTest.java",
    "type": "method",
    "name": "runAndGetAssumptionFailures",
    "code": "private static List<Failure> runAndGetAssumptionFailures(Class<?> clazz) {\n        final List<Failure> failures = new ArrayList<Failure>();\n        final JUnitCore core = new JUnitCore();\n        core.addListener(new RunListener() {\n        });\n        core.run(clazz);\n        return failures;\n    }",
    "comment": "Helper method that runs tests on <code>clazz</code> and returns any\n{@link Failure} objects that were {@link AssumptionViolatedException}s."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/BuildSuccess.java",
    "type": "method",
    "name": "BuildSuccess",
    "code": "public BuildSuccess(MavenProject project, Duration wallTime, Duration execTime) {\n        super(project, wallTime, execTime);\n    }",
    "comment": "Creates a new build summary for the specified project.\n\n@param project The project being summarized, must not be {@code null}.\n@param wallTime The wall time of the project in milliseconds.\n@param execTime The exec time of the project in milliseconds."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/Logger.java",
    "type": "method",
    "name": "Logger",
    "code": "public Logger(final int minLogLevel) {\n    this(DEFAULT_TAG, null);\n    this.minLogLevel = minLogLevel;\n  }",
    "comment": "Creates a Logger using the caller's class name as the message prefix."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/testkit/EngineTestKitAllEventsDemo.java",
    "type": "method",
    "name": "verifyAllJupiterEvents",
    "code": "void verifyAllJupiterEvents() {\n\t\tWriter writer = // create a java.io.Writer for debug output\n\t\t\t\tnew StringWriter();\n\n\t\tEngineTestKit.engine(\"junit-jupiter\") // <1>\n\t\t\t.selectors(selectClass(ExampleTestCase.class)) // <2>\n\t\t\t.execute() // <3>\n\t\t\t.allEvents() // <4>\n\t\t\t.debug(writer) // <5>\n\t\t\t.assertEventsMatchExactly( // <6>\n\t\t\t\tevent(engine(), started()),\n\t\t\t\tevent(container(ExampleTestCase.class), started()),\n\t\t\t\tevent(test(\"skippedTest\"), skippedWithReason(\"for demonstration purposes\")),\n\t\t\t\tevent(test(\"succeedingTest\"), started()),\n\t\t\t\tevent(test(\"succeedingTest\"), finishedSuccessfully()),\n\t\t\t\tevent(test(\"abortedTest\"), started()),\n\t\t\t\tevent(test(\"abortedTest\"),\n\t\t\t\t\tabortedWithReason(instanceOf(TestAbortedException.class),\n\t\t\t\t\t\tmessage(m -> m.contains(\"abc does not contain Z\")))),\n\t\t\t\tevent(test(\"failingTest\"), started()),\n\t\t\t\tevent(test(\"failingTest\"), finishedWithFailure(\n\t\t\t\t\tinstanceOf(ArithmeticException.class), message(it -> it.endsWith(\"by zero\")))),\n\t\t\t\tevent(container(ExampleTestCase.class), finishedSuccessfully()),\n\t\t\t\tevent(engine(), finishedSuccessfully()));\n\t}",
    "comment": "@formatter:off\ntag::user_guide[]\nend::user_guide[]\nFor the demo, we are swallowing the debug output.\ntag::user_guide[]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/launcher/TagFilterTests.java",
    "type": "method",
    "name": "includeTagsWithInvalidSyntax",
    "code": "void includeTagsWithInvalidSyntax() {\n\t\t// @formatter:off\n\t\tassertAll(\n\t\t\t() -> assertSyntaxViolationForIncludes(null),\n\t\t\t() -> assertSyntaxViolationForIncludes(\"\"),\n\t\t\t() -> assertSyntaxViolationForIncludes(\"   \"),\n\t\t\t() -> assertSyntaxViolationForIncludes(\"foo bar\")\n\t\t);\n\t\t// @formatter:on\n\t}",
    "comment": "Unit tests for {@link TagFilter}.\n\n<p>NOTE: part of the behavior of these tests regarding tags is\ninfluenced by the implementation of {@link DemoClassTestDescriptor#getTags()}\nrather than any concrete test engine.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertLinesMatch.java",
    "type": "method",
    "name": "assertLinesMatch",
    "code": "static void assertLinesMatch(Stream<String> expectedLines, Stream<String> actualLines, Object messageOrSupplier) {\n\t\tnotNull(expectedLines, \"expectedLines must not be null\");\n\t\tnotNull(actualLines, \"actualLines must not be null\");\n\n\t\tif (expectedLines == actualLines) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<String> expectedListOfStrings = expectedLines.collect(Collectors.toList());\n\t\tList<String> actualListOfStrings = actualLines.collect(Collectors.toList());\n\t\tassertLinesMatch(expectedListOfStrings, actualListOfStrings, messageOrSupplier);\n\t}",
    "comment": "trivial case: same stream instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaRandomForestClassifierExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaRandomForestClassifierExample\")\n      .getOrCreate();\n\n    Dataset<Row> data = spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    StringIndexerModel labelIndexer = new StringIndexer()\n      .setInputCol(\"label\")\n      .setOutputCol(\"indexedLabel\")\n      .fit(data);\n    VectorIndexerModel featureIndexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexedFeatures\")\n      .setMaxCategories(4)\n      .fit(data);\n\n    Dataset<Row>[] splits = data.randomSplit(new double[] {0.7, 0.3});\n      .setStages(new PipelineStage[] {labelIndexer, featureIndexer, rf, labelConverter});\n}",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file, converting it to a DataFrame.\nIndex labels, adding metadata to the label column.\nFit on whole dataset to include all labels in index.\nAutomatically identify categorical features, and index them.\nSet maxCategories so features with > 4 distinct values are treated as continuous.\nSplit the data into training and test sets (30% held out for testing)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "TestResult",
    "code": "public TestResult() {\n        fFailures = new ArrayList<TestFailure>();\n        fErrors = new ArrayList<TestFailure>();\n        fListeners = new ArrayList<TestListener>();\n        fRunTests = 0;\n        fStop = false;\n    }",
    "comment": "A <code>TestResult</code> collects the results of executing\na test case. It is an instance of the Collecting Parameter pattern.\nThe test framework distinguishes between <i>failures</i> and <i>errors</i>.\nA failure is anticipated and checked for with assertions. Errors are\nunanticipated problems like an {@link ArrayIndexOutOfBoundsException}.\n\n@see Test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/max/MaxCore.java",
    "type": "method",
    "name": "run",
    "code": "public Result run(Request request, JUnitCore core) {\n        core.addListener(history.listener());\n        return core.run(sortRequest(request).getRunner());\n    }",
    "comment": "Run all the tests contained in <code>request</code>.\n\nThis variant should be used if {@code core} has attached listeners that this\nrun should notify.\n\n@param request the request describing tests\n@param core a JUnitCore to delegate to.\n@return a {@link Result} describing the details of the test run and the failed tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/di/testing/MavenDIExtension.java",
    "type": "method",
    "name": "getTestPath",
    "code": "public static String getTestPath(String path) {\n        return getTestFile(path).getAbsolutePath();\n    }",
    "comment": "Returns the absolute path for a path relative to the base directory.\n\n@param path The relative path\n@return The absolute path"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/DisabledIfEnvironmentVariableConditionTests.java",
    "type": "method",
    "name": "DisabledIfEnvironmentVariableCondition",
    "code": "private ExecutionCondition condition = new DisabledIfEnvironmentVariableCondition() {\n\t};",
    "comment": "Stubbed subclass of {@link DisabledIfEnvironmentVariableCondition}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(int unexpected, int actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/PreInterruptThreadDumpPrinter.java",
    "type": "method",
    "name": "appendThreadName",
    "code": "private void appendThreadName(StringBuilder sb, Thread th) {\n\t\t// Use same format as java.lang.management.ThreadInfo.toString\n\t\tsb.append(\"\\\"\");\n\t\tsb.append(th.getName());\n\t\tsb.append(\"\\\"\");\n\t\tif (th.isDaemon()) {\n\t\t\tsb.append(\" daemon\");\n\t\t}\n\t\tsb.append(\" prio=\");\n\t\tsb.append(th.getPriority());\n\t\tsb.append(\" Id=\");\n\t\tsb.append(th.getId());\n\t\tsb.append(\" \");\n\t\tsb.append(th.getState());\n\t}",
    "comment": "Appends the {@link Thread} name and ID in a similar fashion as {@code jstack}.\n@param sb the buffer\n@param th the thread to append"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeDefaultField",
    "code": "void cleanupModeDefaultField() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(DefaultFieldCase.class, \"testDefaultField\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(defaultFieldDir).doesNotExist();\n\t\t}",
    "comment": "Ensure the cleanup mode defaults to ALWAYS for fields.\n<p/>\nExpect the TempDir to be cleaned up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertSame",
    "code": "public static void assertSame(Object expected, Object actual) {\n\t\tAssertSame.assertSame(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that the {@code expected} object and the {@code actual} object\nare the same object.\n<p>This method should only be used to assert <em>identity</em> between objects.\nTo assert <em>equality</em> between two objects or two primitive values,\nuse one of the {@code assertEquals(...)} methods instead &mdash; for example,\nuse {@code assertEquals(999, 999)} instead of {@code assertSame(999, 999)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultInterpolator.java",
    "type": "method",
    "name": "performSubstitution",
    "code": "public void performSubstitution(Map<String, String> properties, UnaryOperator<String> callback) {\n        performSubstitution(properties, callback, true);\n    }",
    "comment": "Perform substitution on a property set\n\n@param properties the property set to perform substitution on\n@param callback Callback for substitution"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "fillShape",
    "code": "private static void fillShape(Object o, int dim, long[] shape) {\n    if (shape == null || dim == shape.length) {\n      return;\n    }\n    final int len = Array.getLength(o);\n    if (len == 0) {\n      throw new IllegalArgumentException(\"cannot create Tensors with a 0 dimension\");\n    }\n    if (shape[dim] == 0) {\n      shape[dim] = len;\n    } else if (shape[dim] != len) {\n      throw new IllegalArgumentException(\n          String.format(\"mismatched lengths (%d and %d) in dimension %d\", shape[dim], len, dim));\n    }\n    for (int i = 0; i < len; ++i) {\n      fillShape(Array.get(o, i), dim + 1, shape);\n    }\n  }",
    "comment": "Fills in the remaining entries in the shape array starting from position {@code dim} with the\ndimension sizes of the multidimensional array o. Checks that all arrays reachable from o have\nsizes consistent with the filled-in shape, throwing IllegalArgumentException otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertNotSameAssertionsTests.java",
    "type": "method",
    "name": "assertNotSameWithDifferentObjects",
    "code": "void assertNotSameWithDifferentObjects() {\n\t\tassertNotSame(new Object(), new Object());\n\t\tassertNotSame(new Object(), new Object(), \"message\");\n\t\tassertNotSame(new Object(), new Object(), () -> \"message\");\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/converter/src/main/java/com/iluwatar/converter/Converter.java",
    "type": "method",
    "name": "convertFromDto",
    "code": "public final U convertFromDto(final T dto) {\n    return fromDto.apply(dto);\n  }",
    "comment": "Converts DTO to Entity.\n\n@param dto DTO entity\n@return The domain representation - the result of the converting function application on dto\nentity."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "bufferToArray",
    "code": "public static byte[] bufferToArray(ByteBuffer buffer) {\n    if (buffer.hasArray() && buffer.arrayOffset() == 0 &&\n        buffer.array().length == buffer.remaining()) {\n      return buffer.array();\n    } else {\n      byte[] bytes = new byte[buffer.remaining()];\n      buffer.get(bytes);\n      return bytes;\n    }\n  }",
    "comment": "Returns a byte array with the buffer's contents, trying to avoid copying the data if\npossible."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/DefaultParallelExecutionConfigurationStrategy.java",
    "type": "method",
    "name": "createConfiguration",
    "code": "public ParallelExecutionConfiguration createConfiguration(ConfigurationParameters configurationParameters) {\n\t\t\tint parallelism = configurationParameters.get(CONFIG_FIXED_PARALLELISM_PROPERTY_NAME,\n\t\t\t\tInteger::valueOf).orElseThrow(\n\t\t\t\t\t() -> new JUnitException(String.format(\"Configuration parameter '%s' must be set\",\n\t\t\t\t\t\tCONFIG_FIXED_PARALLELISM_PROPERTY_NAME)));\n\n\t\t\tint maxPoolSize = configurationParameters.get(CONFIG_FIXED_MAX_POOL_SIZE_PROPERTY_NAME,\n\t\t\t\tInteger::valueOf).orElse(parallelism + 256);\n\n\t\t\tboolean saturate = configurationParameters.get(CONFIG_FIXED_SATURATE_PROPERTY_NAME,\n\t\t\t\tBoolean::valueOf).orElse(true);\n\n\t\t\treturn new DefaultParallelExecutionConfiguration(parallelism, parallelism, maxPoolSize, parallelism,\n\t\t\t\tKEEP_ALIVE_SECONDS, __ -> saturate);\n\t\t}",
    "comment": "Uses the mandatory {@value #CONFIG_FIXED_PARALLELISM_PROPERTY_NAME} configuration\nparameter as the desired parallelism."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/aether/LoggingRepositoryListener.java",
    "type": "method",
    "name": "artifactDescriptorInvalid",
    "code": "public void artifactDescriptorInvalid(RepositoryEvent event) {\n        logger.warn(\n                \"The POM for {} is invalid, transitive dependencies (if any) will not be available: {}\",\n                event.getArtifact(),\n                event.getException().getMessage());\n    }",
    "comment": "The exception stack trace is not really interesting here"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/StylizeActivity.java",
    "type": "method",
    "name": "renderDebug",
    "code": "private void renderDebug(final Canvas canvas) {\n    final Bitmap texture = textureCopyBitmap;\n    if (texture != null) {\n      final Matrix matrix = new Matrix();\n      final float scaleFactor =\n          DEBUG_MODEL\n              ? 4.0f\n              : Math.min(\n                  (float) canvas.getWidth() / texture.getWidth(),\n                  (float) canvas.getHeight() / texture.getHeight());\n      matrix.postScale(scaleFactor, scaleFactor);\n      canvas.drawBitmap(texture, matrix, new Paint());\n    }\n\n    if (!isDebug()) {\n      return;\n    }\n\n    final Bitmap copy = cropCopyBitmap;\n    if (copy == null) {\n      return;\n    }\n\n    canvas.drawColor(0x55000000);\n\n    final Matrix matrix = new Matrix();\n    final float scaleFactor = 2;\n    matrix.postScale(scaleFactor, scaleFactor);\n    matrix.postTranslate(\n        canvas.getWidth() - copy.getWidth() * scaleFactor,\n        canvas.getHeight() - copy.getHeight() * scaleFactor);\n    canvas.drawBitmap(copy, matrix, new Paint());\n\n    final Vector<String> lines = new Vector<>();\n\n    final String[] statLines = inferenceInterface.getStatString().split(\"\\n\");\n    Collections.addAll(lines, statLines);\n\n    lines.add(\"\");\n\n    lines.add(\"Frame: \" + previewWidth + \"x\" + previewHeight);\n    lines.add(\"Crop: \" + copy.getWidth() + \"x\" + copy.getHeight());\n    lines.add(\"View: \" + canvas.getWidth() + \"x\" + canvas.getHeight());\n    lines.add(\"Rotation: \" + sensorOrientation);\n    lines.add(\"Inference time: \" + lastProcessingTimeMs + \"ms\");\n    lines.add(\"Desired size: \" + desiredSize);\n    lines.add(\"Initialized size: \" + initializedSize);\n\n    borderedText.drawLines(canvas, 10, canvas.getHeight() - 10, lines);\n  }",
    "comment": "TODO(andrewharp): move result display to its own View instead of using debug overlay."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/model/DefaultModelBuilderResultTest.java",
    "type": "method",
    "name": "testModelLifecycle",
    "code": "void testModelLifecycle() {\n        assertNull(result.getSource());\n        assertNull(result.getFileModel());\n        assertNull(result.getRawModel());\n        assertNull(result.getEffectiveModel());\n        assertEquals(0L, result.getProblemCollector().problems().count());\n\n        result.setSource(source);\n        assertSame(source, result.getSource());\n\n        result.setFileModel(fileModel);\n        assertSame(fileModel, result.getFileModel());\n\n        result.setRawModel(rawModel);\n        assertSame(rawModel, result.getRawModel());\n\n        result.setEffectiveModel(effectiveModel);\n        assertSame(effectiveModel, result.getEffectiveModel());\n    }",
    "comment": "Test initial state\nSet and verify source\nSet and verify file model\nSet and verify raw model\nSet and verify effective model"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Character expected, char actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Character) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-client-side-ui-composition/src/main/java/com/iluwatar/clientsideuicomposition/ApiGateway.java",
    "type": "method",
    "name": "handleRequest",
    "code": "public String handleRequest(String path, Map<String, String> params) {\n    if (routes.containsKey(path)) {\n      // Fetch data dynamically based on the provided parameters\n      return routes.get(path).fetchData(params);\n    } else {\n      // Return a 404 error if the path is not registered\n      return \"404 Not Found\";\n    }\n  }",
    "comment": "Handles a client request by routing it to the appropriate frontend component.\n\n<p>This method dynamically handles parameters passed with the request, which allows the\nfrontend components to respond based on those parameters.\n\n@param path the path for which the request is made (e.g., \"/products\", \"/cart\")\n@param params a map of parameters that might influence the data fetching logic (e.g., filters,\nuserId, categories, etc.)\n@return the data fetched from the appropriate component or \"404 Not Found\" if the path is not\nregistered"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultLifecyclePluginAnalyzer.java",
    "type": "method",
    "name": "DefaultLifecyclePluginAnalyzer",
    "code": "public DefaultLifecyclePluginAnalyzer(Lookup lookup, DefaultLifecycles defaultLifeCycles) {\n        this.lookup = requireNonNull(lookup);\n        this.defaultLifeCycles = requireNonNull(defaultLifeCycles);\n    }",
    "comment": "<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/BeforeAndAfterTestExecutionCallbackTests.java",
    "type": "method",
    "name": "beforeTestExecutionCallbackThrowsAnException",
    "code": "void beforeTestExecutionCallbackThrowsAnException() {\n\t\tEngineExecutionResults executionResults = executeTestsForClass(\n\t\t\tExceptionInBeforeTestExecutionCallbackTestCase.class);\n\n\t\tassertEquals(1, executionResults.testEvents().started().count(), \"# tests started\");\n\t\tassertEquals(0, executionResults.testEvents().succeeded().count(), \"# tests succeeded\");\n\t\tassertEquals(0, executionResults.testEvents().skipped().count(), \"# tests skipped\");\n\t\tassertEquals(0, executionResults.testEvents().aborted().count(), \"# tests aborted\");\n\t\tassertEquals(1, executionResults.testEvents().failed().count(), \"# tests failed\");\n\n\t\tassertEquals(asList(\n\t\t\t\"beforeEachMethod\",\n\t\t\t\t\"fooBeforeTestExecutionCallback\",\n\t\t\t\t\"exceptionThrowingBeforeTestExecutionCallback\", // throws an exception.\n\t\t\t\t\"barAfterTestExecutionCallback\",\n\t\t\t\t\"fooAfterTestExecutionCallback\",\n\t\t\t\"afterEachMethod\"\n\t\t), callSequence, \"wrong call sequence\");\n\n\t\tassertNotNull(actualExceptionInAfterTestExecution, \"test exception\");\n\t\tassertTrue(actualExceptionInAfterTestExecution.isPresent(), \"test exception should be present\");\n\t\tassertEquals(EnigmaException.class, actualExceptionInAfterTestExecution.get().getClass());\n\t}",
    "comment": "@formatter:off\nbarBeforeTestExecutionCallback should not get invoked.\ntest() should not get invoked.\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/event/ExecutionEventLogger.java",
    "type": "method",
    "name": "projectStarted",
    "code": "public void projectStarted(ExecutionEvent event) {\n        if (logger.isInfoEnabled()) {\n            init();\n            MavenProject project = event.getProject();\n\n            logger.info(\"\");\n\n            String projectKey = project.getGroupId() + ':' + project.getArtifactId();\n\n            final String preHeader = \"--< \";\n            final String postHeader = \" >--\";\n\n            final int headerLen = preHeader.length() + projectKey.length() + postHeader.length();\n\n            String prefix = chars('-', Math.max(0, (lineLength - headerLen) / 2)) + preHeader;\n\n            String suffix =\n                    postHeader + chars('-', Math.max(0, lineLength - headerLen - prefix.length() + preHeader.length()));\n\n            logger.info(\n                    builder().strong(prefix).project(projectKey).strong(suffix).toString());\n\n            String building = \"Building \" + event.getProject().getName() + \" \"\n                    + event.getProject().getVersion();\n\n            if (totalProjects <= 1) {\n                infoMain(building);\n            } else {\n                int number;\n                synchronized (this) {\n                    number = ++currentVisitedProjectCount;\n                }\n                String progress = \" [\" + number + '/' + totalProjects + ']';\n\n                int pad = lineLength - building.length() - progress.length();\n\n                infoMain(building + ((pad > 0) ? chars(' ', pad) : \"\") + progress);\n            }\n\n            File currentPom = project.getFile();\n            if (currentPom != null) {\n                MavenSession session = event.getSession();\n                Path current = currentPom.toPath().toAbsolutePath().normalize();\n                Path topDirectory = session.getTopDirectory();\n                if (topDirectory != null && current.startsWith(topDirectory)) {\n                    current = topDirectory.relativize(current);\n                }\n                logger.info(\"  from \" + current);\n            }\n\n            prefix = chars('-', Math.max(0, (lineLength - project.getPackaging().length() - 4) / 2));\n            suffix = chars('-', Math.max(0, lineLength - project.getPackaging().length() - 4 - prefix.length()));\n            infoMain(prefix + \"[ \" + project.getPackaging() + \" ]\" + suffix);\n        }\n    }",
    "comment": "-------< groupId:artifactId >-------\nBuilding Project Name Version    [i/n]\ndisplay progress [i/n]\npath to pom.xml\n----------[ packaging ]----------"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/util/collection/TestTimSort.java",
    "type": "method",
    "name": "getTimSortBugTestSet",
    "code": "public static int[] getTimSortBugTestSet(int length) {\n    int minRun = minRunLength(length);\n    List<Long> runs = runsJDKWorstCase(minRun, length);\n    return createArray(runs, length);\n  }",
    "comment": "Returns an array of integers that demonstrate the bug in TimSort"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/RequestTraceHelper.java",
    "type": "method",
    "name": "toResolver",
    "code": "public static RequestTrace toResolver(org.apache.maven.api.services.RequestTrace trace) {\n        if (trace != null) {\n            return RequestTrace.newChild(toResolver(trace.parent()), trace.data());\n        } else {\n            return null;\n        }\n    }",
    "comment": "Converts a Maven trace to a Resolver trace\n@param trace The Maven trace to convert\n@return A new Resolver trace, or null if the input trace was null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java",
    "type": "method",
    "name": "enable",
    "code": "public void enable() {\n        active = true;\n\n        if (children != null) {\n            for (ResolutionNode node : children) {\n                node.enable();\n            }\n        }\n    }",
    "comment": "TODO if it was null, we really need to go find them now... or is this taken care of by the ordering?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/rules/RuleMemberValidator.java",
    "type": "method",
    "name": "validate",
    "code": "public void validate(FrameworkMember<?> member, Class<? extends Annotation> annotation, List<Throwable> errors) {\n            if (!isRuleType(member)) {\n                errors.add(new ValidationError(member, annotation,\n                        \"must return an implementation of MethodRule or TestRule.\"));\n            }\n        }",
    "comment": "Require the member to return an implementation of {@link org.junit.rules.MethodRule} or\n{@link org.junit.rules.TestRule}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/LoggingListener.java",
    "type": "method",
    "name": "forJavaUtilLogging",
    "code": "public static LoggingListener forJavaUtilLogging() {\n\t\treturn forJavaUtilLogging(Level.FINE);\n\t}",
    "comment": "Create a {@code LoggingListener} which delegates to a\n{@link java.util.logging.Logger} using a log level of\n{@link Level#FINE FINE}.\n\n@see #forJavaUtilLogging(Level)\n@see #forBiConsumer(BiConsumer)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(byte unexpected, byte actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/project/ProjectClasspathTestType.java",
    "type": "method",
    "name": "checkGroupIdScope",
    "code": "private void checkGroupIdScope(MavenProject project, String scopeValue, String groupId) {\n        Artifact artifact;\n        artifact = getArtifact(project, groupId, \"scope-compile\");\n        assertEquals(scopeValue, artifact.getScope(), \"Check scope\");\n        artifact = getArtifact(project, groupId, \"scope-test\");\n        assertNull(artifact, \"Check test dependency is not transitive\");\n        artifact = getArtifact(project, groupId, \"scope-provided\");\n        assertNull(artifact, \"Check provided dependency is not transitive\");\n        artifact = getArtifact(project, groupId, \"scope-default\");\n        assertEquals(scopeValue, artifact.getScope(), \"Check scope\");\n    }",
    "comment": "check all transitive deps of a test dependency are test, except test and provided which is skipped\ncheck all transitive deps of a provided dependency are provided scope, except for test\ncheck all transitive deps of a runtime dependency are runtime scope, except for test\ncheck all transitive deps of a compile dependency are compile scope, except for runtime and test\ncheck all transitive deps of a default dependency are compile scope, except for runtime and test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/composite/src/test/java/com/iluwatar/composite/MessengerTest.java",
    "type": "method",
    "name": "setUp",
    "code": "void setUp() {\n    this.stdOutBuffer = new ByteArrayOutputStream();\n    System.setOut(new PrintStream(stdOutBuffer));\n  }",
    "comment": "Inject the mocked std-out {@link PrintStream} into the {@link System} class before each test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertionFailureBuilder.java",
    "type": "method",
    "name": "message",
    "code": "public AssertionFailureBuilder message(Object message) {\n\t\tthis.message = message;\n\t\treturn this;\n\t}",
    "comment": "Set the user-defined message of the assertion.\n\n<p>The {@code message} may be passed as a {@link Supplier} or plain\n{@link String}. If any other type is passed, it is converted to\n{@code String} as per {@link StringUtils#nullSafeToString(Object)}.\n\n@param message the user-defined failure message; may be {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/iterator/src/main/java/com/iluwatar/iterator/bst/BstIterator.java",
    "type": "method",
    "name": "BstIterator",
    "code": "public BstIterator(TreeNode<T> root) {\n    pathStack = new ArrayDeque<>();\n    pushPathToNextSmallest(root);\n  }",
    "comment": "An in-order implementation of a BST Iterator. For example, given a BST with Integer values,\nexpect to retrieve TreeNodes according to the Integer's natural ordering (1, 2, 3...)\n\n@param <T> This Iterator has been implemented with generic typing to allow for TreeNodes of\ndifferent value types"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/NavigationBasicSample/app/src/uiTest/java/com/example/android/navigationsample/TitleScreenTestJava.java",
    "type": "method",
    "name": "testNavigateToPlay",
    "code": "public void testNavigateToPlay() {\n\n        // Create a TestNavHostController\n        TestNavHostController navController = new TestNavHostController(\n                ApplicationProvider.getApplicationContext());\n\n        // Create a graphical FragmentScenario for the TitleScreen\n        FragmentScenario<TitleScreen> titleScenario =\n                FragmentScenario.launchInContainer(TitleScreen.class);\n\n        // Set the NavController property on the fragment\n        titleScenario.onFragment(fragment -> {\n                navController.setGraph(R.navigation.navigation);\n                Navigation.setViewNavController(fragment.requireView(), navController);\n            }\n        );\n\n        // Verify that performing a click changes the NavController's state\n        onView(withId(R.id.play_btn)).perform(click());\n        List<NavBackStackEntry> backStack = navController.getBackStack();\n        NavBackStackEntry currentDestination = backStack.get(backStack.size() - 1);\n        assertThat(currentDestination.getDestination().getId()).isEqualTo(R.id.register);\n    }",
    "comment": "A simple test class that can be run both on device (or emulator) or on the host (as a JVM test\nusing Robolectric)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerSession.java",
    "type": "method",
    "name": "initDefault",
    "code": "public static EagerSession initDefault(Options options) {\n    synchronized (EagerSession.class) {\n      if (defaultSession != null) {\n        throw new IllegalStateException(\"Default eager session is already initialized\");\n      }\n      defaultSession = options.build();\n    }\n    return defaultSession;\n  }",
    "comment": "Initializes the default eager session, which remains active for the lifetime of the\napplication.\n\n<p>This method is implicitly invoked on the first call to {@link #getDefault()}, but can also\nbe invoked explicitly to override default options.\n\n<p>Note that calling this method more than once will throw an {@code IllegalArgumentException}\nas the default session cannot be modified once it has been created. Therefore, it is important\nto explicitly initialize it before {@link #getDefault()} is invoked for the first time from any\nthread.\n\n<p>Example usage:\n\n<pre>{@code\n// Initializing default session to override default options is valid but\n// is optional\nEagerSession.initDefault(EagerSession.options().async(true));\n\n// Starting to build eager operations using default session, by calling\n// EagerSession.getDefault() implicitly\nOps tf = Ops.create();\n\n// Initializing default session more than once or after using it is not\n// permitted and throws an exception\nEagerSession.initDefault(EagerSession.options().async(true));  // throws\n}</pre>\n\n@param options options to use to build default session\n@return default eager session\n@throws IllegalStateException if the default session is already initialized\n@see #getDefault()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/MediaType.java",
    "type": "method",
    "name": "create",
    "code": "public static MediaType create(String type, String subtype) {\n\t\tPreconditions.notNull(type, \"type must not be null\");\n\t\tPreconditions.notNull(subtype, \"subtype must not be null\");\n\t\treturn new MediaType(type + \"/\" + subtype);\n\t}",
    "comment": "Create a media type with the given type and subtype.\n\n@param type the type; never {@code null}\n@param subtype the subtype; never {@code null}\n@return the media type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectClasspathRoots",
    "code": "public static List<ClasspathRootSelector> selectClasspathRoots(Set<Path> classpathRoots) {\n\t\tPreconditions.notNull(classpathRoots, \"classpathRoots must not be null\");\n\n\t\t// @formatter:off\n\t\treturn classpathRoots.stream()\n\t\t\t\t.filter(Files::exists)\n\t\t\t\t.map(Path::toUri)\n\t\t\t\t.map(ClasspathRootSelector::new)\n\t\t\t\t// unmodifiable since selectClasspathRoots is a public, non-internal method\n\t\t\t\t.collect(toUnmodifiableList());\n\t\t// @formatter:on\n\t}",
    "comment": "Create a list of {@code ClasspathRootSelectors} for the supplied\n<em>classpath roots</em> (directories or JAR files).\n\n<p>Since the supplied paths are converted to {@link URI URIs}, the\n{@link java.nio.file.FileSystem} that created them must be the\n{@linkplain java.nio.file.FileSystems#getDefault() default} or one that\nhas been created by an installed\n{@link java.nio.file.spi.FileSystemProvider}.\n\n<p>Since {@linkplain org.junit.platform.engine.TestEngine engines} are not\nexpected to modify the classpath, the classpath roots represented by the\nresulting selectors must be on the classpath of the\n{@linkplain Thread#getContextClassLoader() context class loader} of the\n{@linkplain Thread thread} that uses these selectors.\n\n@param classpathRoots set of directories and JAR files in the filesystem\nthat represent classpath roots; never {@code null}\n@return a list of selectors for the supplied classpath roots; elements\nwhich do not physically exist in the filesystem will be filtered out\n@see ClasspathRootSelector\n@see Thread#getContextClassLoader()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "addError",
    "code": "public synchronized void addError(Test test, Throwable e) {\n        fErrors.add(new TestFailure(test, e));\n        for (TestListener each : cloneListeners()) {\n            each.addError(test, e);\n        }\n    }",
    "comment": "Adds an error to the list of errors. The passed in exception\ncaused the error."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "requestedProtocol",
    "code": "public Builder requestedProtocol(String requestedProtocol) {\n      this.requestedProtocol = requestedProtocol == null ? \"TLSv1.3\" : requestedProtocol;\n      return this;\n    }",
    "comment": "Sets the requested protocol, i.e., \"TLSv1.2\", \"TLSv1.1\", etc\n\n@param requestedProtocol The requested protocol\n@return The builder object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "missing",
    "code": "public Object missing(List<Object> args) {\n        if (args.size() != 1) {\n            throw new IllegalArgumentException(\"missing function requires exactly one argument\");\n        }\n        String path = ConditionParser.toString(args.get(0));\n        return !context.exists(path, true);\n    }",
    "comment": "Checks if a file or directory is missing at the given path.\n\n@param args A list containing a single string argument representing the path\n@return {@code true} if the file or directory does not exist, {@code false} otherwise\n@throws IllegalArgumentException if the number of arguments is not exactly one\n@throws ModelBuilderException if a problem occurs while walking the file system\n@throws InterpolatorException if an error occurs during interpolation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "convertRatesTo",
    "code": "public Builder convertRatesTo(TimeUnit rateUnit) {\n            this.rateUnit = rateUnit;\n            return this;\n        }",
    "comment": "Convert rates to the given time unit.\n\n@param rateUnit a unit of time\n@return {@code this}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/logging/Slf4jLogger.java",
    "type": "method",
    "name": "Slf4jLogger",
    "code": "public Slf4jLogger(org.slf4j.Logger logger) {\n        this.logger = requireNonNull(logger, \"logger\");\n    }",
    "comment": "Proto {@link Logger} that just passes to functioning {@link org.slf4j.Logger} instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/serialized-lob/src/test/java/com/iluwatar/slob/AppTest.java",
    "type": "method",
    "name": "createForest",
    "code": "private static Forest createForest() {\n    Plant grass = new Plant(\"Grass\", \"Herb\");\n    Plant oak = new Plant(\"Oak\", \"Tree\");\n\n    Animal zebra = new Animal(\"Zebra\", Set.of(grass), Collections.emptySet());\n    Animal buffalo = new Animal(\"Buffalo\", Set.of(grass), Collections.emptySet());\n    Animal lion = new Animal(\"Lion\", Collections.emptySet(), Set.of(zebra, buffalo));\n\n    return new Forest(\"Amazon\", Set.of(lion, buffalo, zebra), Set.of(grass, oak));\n  }",
    "comment": "Creates a Forest with Animals and Plants along with their respective relationships.\n\n<p>The method creates a forest with 2 Plants Grass and Oak of type Herb and tree respectively.\n\n<p>It also creates 3 animals Zebra and Buffalo which eat the plant grass. Lion consumes the\nZebra and the Buffalo.\n\n<p>With the above animals and plants and their relationships a forest object is created which\nrepresents the Object Graph.\n\n@return Forest Object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "uniqueId",
    "code": "public static Condition<Event> uniqueId(UniqueId uniqueId) {\n\t\treturn uniqueId(new Condition<>(isEqual(uniqueId), \"equal to '%s'\", uniqueId));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if the\n{@linkplain Event#getTestDescriptor() test descriptor} is equal to the\nsupplied {@link UniqueId}.\n\n@since 1.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java",
    "type": "method",
    "name": "shouldContinueCreating",
    "code": "private synchronized boolean shouldContinueCreating() {\n         return poolState == POOL_NORMAL && getTotalConnections() < config.getMaximumPoolSize() &&\n            (getIdleConnections() < config.getMinimumIdle() || connectionBag.getWaitingThreadCount() > getIdleConnections());\n      }",
    "comment": "We only create connections if we need another idle connection or have threads still waiting\nfor a new connection.  Otherwise we bail out of the request to create.\n\n@return true if we should create a connection, false if the need has disappeared"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java",
    "type": "method",
    "name": "isLinkWithTargetOutsideTempDir",
    "code": "private boolean isLinkWithTargetOutsideTempDir(Path path) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn !path.toRealPath().startsWith(rootRealPath);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t\tLOGGER.trace(e,\n\t\t\t\t\t\t\t() -> \"Failed to determine real path for \" + path + \"; assuming it is not a link\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}",
    "comment": "While `Files.walkFileTree` does not follow symbolic links, it may follow other links\nsuch as \"junctions\" on Windows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/PreInterruptCallbackTests.java",
    "type": "method",
    "name": "testCaseWithDefaultInterruptCallbackEnabled",
    "code": "void testCaseWithDefaultInterruptCallbackEnabled() {\n\t\tPrintStream orgOutStream = System.out;\n\t\tEngineExecutionResults results;\n\t\tString output;\n\t\ttry {\n\t\t\tByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\t\t\tPrintStream outStream = new PrintStream(buffer, false, StandardCharsets.UTF_8);\n\t\t\tSystem.setOut(outStream);\n\t\t\tvar timeout = WINDOWS.isCurrentOs() ? \"1 s\" : \"100 ms\";\n\t\t\tresults = executeDefaultPreInterruptCallbackTimeoutOnMethodTestCase(timeout, request -> request //\n\t\t\t\t\t.configurationParameter(Constants.EXTENSIONS_TIMEOUT_THREAD_DUMP_ENABLED_PROPERTY_NAME, \"true\"));\n\t\t\toutput = buffer.toString(StandardCharsets.UTF_8);\n\t\t}\n\t\tfinally {\n\t\t\tSystem.setOut(orgOutStream);\n\t\t}\n\n\t\tassertTestHasTimedOut(results.testEvents(), message(it -> it.startsWith(TC + \"() timed out after\")));\n\t\tassertTrue(interruptedTest.get());\n\t\tThread thread = Thread.currentThread();\n\n\t\tassertThat(output) //\n\t\t\t\t.containsSubsequence(\n\t\t\t\t\t\"Thread \\\"%s\\\" prio=%d Id=%d %s will be interrupted.\".formatted(thread.getName(),\n\t\t\t\t\t\tthread.getPriority(), thread.threadId(), Thread.State.TIMED_WAITING), //\n\t\t\t\t\t\"java.lang.Thread.sleep\", //\n\t\t\t\t\t\"%s.test(PreInterruptCallbackTests.java\".formatted(\n\t\t\t\t\t\tDefaultPreInterruptCallbackTimeoutOnMethodTestCase.class.getName()));\n\n\t\tassertThat(output) //\n\t\t\t\t.containsSubsequence( //\n\t\t\t\t\t\"junit-jupiter-timeout-watcher\", //\n\t\t\t\t\t\"%s.beforeThreadInterrupt\".formatted(PreInterruptThreadDumpPrinter.class.getName()));\n\t}",
    "comment": "Use larger timeout to increase likelihood of the test being started when the timeout is reached"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "setUserProperties",
    "code": "public DefaultProfileActivationContext setUserProperties(Map<String, String> userProperties) {\n        this.userProperties = unmodifiable(userProperties);\n        return this;\n    }",
    "comment": "Sets the user properties to use for interpolation and profile activation. The user properties have been\nconfigured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command\nline.\n\n@param userProperties The user properties, may be {@code null}.\n@return This context, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroPrimitives.java",
    "type": "method",
    "name": "setStringColumn",
    "code": "public void setStringColumn(java.lang.String value) {\n    this.string_column = value;\n  }",
    "comment": "Sets the value of the 'string_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationSupport.java",
    "type": "method",
    "name": "if",
    "code": "final int collationId) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType) {\n        return execBinary(srcString, trimString);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(srcString, trimString);\n      } else {\n        return execICU(srcString, trimString, collationId);\n      }\n    }",
    "comment": "Space trimming does not affect the output of this expression as currently only supported\nspace trimming is RTRIM."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3740SelfReferentialReactorProjectsTest.java",
    "type": "method",
    "name": "MavenITmng3740SelfReferentialReactorProjectsTest",
    "code": "public MavenITmng3740SelfReferentialReactorProjectsTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3740\">MNG-3740</a>.\n\nCheck that when a plugin project build uses an earlier version of itself, it\ndoesn't result in a StackOverflowError as a result of trying to calculate\na concrete state for its project references, which includes itself because of\nthis plugin configuration in the POM.\n\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "name",
    "code": "public Builder name(String name) {\n            this.name = name;\n            return this;\n        }",
    "comment": "Sets the name of the XML node.\n<p>\nThis is the only required property that must be set before calling {@link #build()}.\n\n@param name the name of the XML node\n@return this builder instance\n@throws NullPointerException if name is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/expressions/javalang/typed.java",
    "type": "method",
    "name": "sum",
    "code": "public static <T> TypedColumn<T, Double> sum(MapFunction<T, Double> f) {\n    return new TypedSumDouble<T>(f).toColumnJava();\n  }",
    "comment": "Sum aggregate function for floating point (double) type.\n\n@since 2.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/UtilityElf.java",
    "type": "method",
    "name": "safeIsAssignableFrom",
    "code": "public static boolean safeIsAssignableFrom(Object obj, String className) {\n      try {\n         var clazz = Class.forName(className);\n         return clazz.isAssignableFrom(obj.getClass());\n      } catch (ClassNotFoundException ignored) {\n         return false;\n      }\n   }",
    "comment": "Checks whether an object is an instance of given type without throwing exception when the class is not loaded.\n@param obj the object to check\n@param className String class\n@return true if object is assignable from the type, false otherwise or when the class cannot be loaded"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultWagonManagerTest.java",
    "type": "method",
    "name": "getRepo",
    "code": "private ArtifactRepository getRepo(String id, String url) {\n        return artifactRepositoryFactory.createArtifactRepository(id, url, new DefaultRepositoryLayout(), null, null);\n    }",
    "comment": "Build an ArtifactRepository object.\n\n@param id\n@param url\n@return"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/builder/multithreaded/MultiThreadedBuilder.java",
    "type": "method",
    "name": "MultiThreadedBuilder",
    "code": "public MultiThreadedBuilder(LifecycleModuleBuilder lifecycleModuleBuilder) {\n        this.lifecycleModuleBuilder = lifecycleModuleBuilder;\n    }",
    "comment": "Builds the full lifecycle in weave-mode (phase by phase as opposed to project-by-project).\n<p>\nThis builder uses a number of threads equal to the minimum of the degree of concurrency (which is the thread count\nset with <code>-T</code> on the command-line) and the number of projects to build. As such, building a single project\nwill always result in a sequential build, regardless of the thread count.\n</p>\n<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 3.0\nBuilds one or more lifecycles for a full module\nNOTE: This class is not part of any public api and can be changed or deleted without prior notice."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/max/MaxHistory.java",
    "type": "method",
    "name": "compare",
    "code": "public int compare(Description o1, Description o2) {\n            if (isNewTest(o1)) {\n                return -1;\n            }\n            if (isNewTest(o2)) {\n                return 1;\n            }\n            int result = getFailure(o2).compareTo(getFailure(o1));\n            return result != 0 ? result\n                    : getTestDuration(o1).compareTo(getTestDuration(o2));\n        }",
    "comment": "possible time\nAlways prefer new tests\nThen most recently failed first\nThen shorter tests first"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/event/ExecutionEventLogger.java",
    "type": "method",
    "name": "mojoStarted",
    "code": "public void mojoStarted(ExecutionEvent event) {\n        if (logger.isInfoEnabled()) {\n            init();\n            logger.info(\"\");\n\n            MessageBuilder buffer = builder().strong(\"--- \");\n            append(buffer, event.getMojoExecution());\n            append(buffer, event.getProject());\n            buffer.strong(\" ---\");\n\n            logger.info(buffer.toString());\n        }\n    }",
    "comment": "<pre>--- mojo-artifactId:version:goal (mojo-executionId) @ project-artifactId ---</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/OneForOneBlockFetcher.java",
    "type": "method",
    "name": "start",
    "code": "public void start() {\n    client.sendRpc(message.toByteBuffer(), new RpcResponseCallback() {\n\n          // Immediately request all chunks -- we expect that the total size of the request is\n          // reasonable due to higher level chunking in [[ShuffleBlockFetcherIterator]].\n          for (int i = 0; i < streamHandle.numChunks; i++) {\n            if (downloadFileManager != null) {\n              client.stream(OneForOneStreamManager.genStreamChunkId(streamHandle.streamId, i),\n                new DownloadCallback(i));\n            } else {\n              client.fetchChunk(streamHandle.streamId, i, chunkCallback);\n            }\n          }\n        } catch (Exception e) {\n          logger.error(\"Failed while starting block fetches after success\", e);\n          failRemainingBlocks(blockIds, e);\n        }\n      }",
    "comment": "Begins the fetching process, calling the listener with every block fetched.\nThe given message will be serialized with the Java serializer, and the RPC must return a\n{@link StreamHandle}. We will send all fetch requests immediately, without throttling."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/interpreter/src/test/java/com/iluwatar/interpreter/MultiplyExpressionTest.java",
    "type": "method",
    "name": "expressionProvider",
    "code": "public Stream<Arguments> expressionProvider() {\n    return prepareParameters((f, s) -> f * s);\n  }",
    "comment": "Create a new set of test entries with the expected result\n\n@return The list of parameters used during this test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/FrameworkMethod.java",
    "type": "method",
    "name": "getAnnotation",
    "code": "public <T extends Annotation> T getAnnotation(Class<T> annotationType) {\n        return method.getAnnotation(annotationType);\n    }",
    "comment": "Returns the annotation of type {@code annotationType} on this method, if\none exists."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/VariableLengthRowBasedKeyValueBatch.java",
    "type": "method",
    "name": "rowIterator",
    "code": "public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n        initialized = true;\n      }\n\n      @Override\n      public boolean next() {\n        if (!initialized) init();\n        //searching for the next non empty page is records is now zero\n        if (recordsInPage == 0) {\n          freeCurrentPage();\n          return false;\n        }\n\n        int uaoSize = UnsafeAlignedOffset.getUaoSize();\n        totalLength = UnsafeAlignedOffset.getSize(base, offsetInPage) - uaoSize;\n        currentklen = UnsafeAlignedOffset.getSize(base, offsetInPage + uaoSize);\n        currentvlen = totalLength - currentklen;\n\n        key.pointTo(base, offsetInPage + 2L * uaoSize, currentklen);\n        value.pointTo(base, offsetInPage + 2L * uaoSize + currentklen, currentvlen);\n\n        offsetInPage += 2L * uaoSize + totalLength + 8;\n        recordsInPage -= 1;\n        return true;\n      }\n\n      @Override\n      public UnsafeRow getKey() {\n        return key;\n      }\n\n      @Override\n      public UnsafeRow getValue() {\n        return value;\n      }\n\n      @Override\n      public void close() {\n        // do nothing\n      }\n\n      private void freeCurrentPage() {\n        if (page != null) {\n          freePage(page);\n          page = null;\n        }\n      }\n    };",
    "comment": "Returns an iterator to go through all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/DebugResolutionListener.java",
    "type": "method",
    "name": "manageArtifact",
    "code": "public void manageArtifact(Artifact artifact, Artifact replacement) {\n        String msg = indent + artifact;\n        msg += \" (\";\n        if (replacement.getVersion() != null) {\n            msg += \"applying version: \" + replacement.getVersion() + \";\";\n        }\n        if (replacement.getScope() != null) {\n            msg += \"applying artifactScope: \" + replacement.getScope();\n        }\n        msg += \")\";\n        logger.debug(msg);\n    }",
    "comment": "The logic used here used to be a copy of the logic used in the DefaultArtifactCollector, and this method was\ncalled right before the actual version/artifactScope changes were done. However, a different set of conditionals\n(and more information) is needed to be able to determine when and if the version and/or artifactScope changes.\nSee the two added methods, manageArtifactVersion and manageArtifactScope."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "enableTcpKeepAlive",
    "code": "public boolean enableTcpKeepAlive() {\n    return conf.getBoolean(SPARK_NETWORK_IO_ENABLETCPKEEPALIVE_KEY, false);\n  }",
    "comment": "Whether to enable TCP keep-alive. If true, the TCP keep-alives are enabled, which removes\nconnections that are idle for too long."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/Promise.java",
    "type": "method",
    "name": "fulfillExceptionally",
    "code": "public void fulfillExceptionally(Exception exception) {\n    super.fulfillExceptionally(exception);\n    handleException(exception);\n    postFulfillment();\n  }",
    "comment": "Fulfills the promise with exception due to error in execution.\n\n@param exception the exception will be wrapped in {@link ExecutionException} when accessing the\nvalue using {@link #get()}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "hex",
    "code": "protected static String hex(char ch) {\n        return Integer.toHexString(ch).toUpperCase(Locale.ENGLISH);\n    }",
    "comment": "<p>Returns an upper case hexadecimal <code>String</code> for the given\ncharacter.</p>\n\n@param ch The character to convert.\n@return An upper case hexadecimal <code>String</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/ViewCatalog.java",
    "type": "method",
    "name": "if",
    "code": "if (viewExists(viewInfo.ident())) {\n      dropView(viewInfo.ident());\n    } else if (!orCreate) {\n      throw new NoSuchViewException(viewInfo.ident());\n    }",
    "comment": "Replace a view in the catalog.\n<p>\nThe default implementation has a race condition.\nCatalogs are encouraged to implement this operation atomically.\n\n@param viewInfo the info class holding all view information\n@param orCreate create the view if it doesn't exist\n@return the created/replaced view. This can be null if getting the metadata\nfor the view is expensive\n@throws NoSuchViewException If the view doesn't exist or is a table\n@throws NoSuchNamespaceException If the identifier namespace does not exist (optional)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(boolean expected, boolean actual) {\n        assertEquals(null, expected, actual);\n    }",
    "comment": "Asserts that two booleans are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/ExpressionImplUtils.java",
    "type": "method",
    "name": "validateUTF8String",
    "code": "public static UTF8String validateUTF8String(UTF8String utf8String) {\n    if (utf8String.isValid()) return utf8String;\n    else throw QueryExecutionErrors.invalidUTF8StringError(utf8String);\n  }",
    "comment": "Function to validate a given UTF8 string according to Unicode rules.\n\n@param utf8String\nthe input string to validate against possible invalid byte sequences\n@return\nthe original string if the input string is a valid UTF8String, throw exception otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/interpreter/src/test/java/com/iluwatar/interpreter/ExpressionTest.java",
    "type": "method",
    "name": "prepareParameters",
    "code": "static Stream<Arguments> prepareParameters(final IntBinaryOperator resultCalc) {\n    final var testData = new ArrayList<Arguments>();\n    for (var i = -10; i < 10; i++) {\n      for (var j = -10; j < 10; j++) {\n        testData.add(\n            Arguments.of(\n                new NumberExpression(i), new NumberExpression(j), resultCalc.applyAsInt(i, j)));\n      }\n    }\n    return testData.stream();\n  }",
    "comment": "Generate inputs ranging from -10 to 10 for both input params and calculate the expected result\n\n@param resultCalc The function used to calculate the expected result\n@return A stream with test entries"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClasspathResourceSource.java",
    "type": "method",
    "name": "from",
    "code": "public static ClasspathResourceSource from(String classpathResourceName, FilePosition filePosition) {\n\t\treturn new ClasspathResourceSource(classpathResourceName, filePosition);\n\t}",
    "comment": "Create a new {@code ClasspathResourceSource} using the supplied classpath\n\n<p>The name of a <em>classpath resource</em> must follow the semantics\nfor resource paths as defined in {@link ClassLoader#getResource(String)}.\n\n<p>If the supplied classpath resource name is prefixed with a slash\n({@code /}), the slash will be removed.\n\n@param classpathResourceName the name of the classpath resource; never\n{@code null} or blank\n@param filePosition the position in the classpath resource; may be {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3536AppendedAbsolutePathsTest.java",
    "type": "method",
    "name": "MavenITmng3536AppendedAbsolutePathsTest",
    "code": "public MavenITmng3536AppendedAbsolutePathsTest() {\n        super(\"[2.1.0-M1,)\"); // 2.1.0+ only\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3536\">MNG-3536</a>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuildingResult.java",
    "type": "method",
    "name": "setActivePomProfiles",
    "code": "public DefaultModelBuildingResult setActivePomProfiles(String modelId, List<Profile> activeProfiles) {\n        Objects.requireNonNull(modelId, \"modelId cannot null\");\n\n        if (activeProfiles != null) {\n            this.activePomProfiles.put(modelId, new ArrayList<>(activeProfiles));\n        } else {\n            this.activePomProfiles.remove(modelId);\n        }\n\n        return this;\n    }",
    "comment": "Intentionally notNull because Super POM may not contain a modelId"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "type",
    "code": "public static Condition<Event> type(EventType expectedType) {\n\t\treturn new Condition<>(byType(expectedType), \"type is %s\", expectedType);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\nsupplied {@link EventType}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/InMemoryStore.java",
    "type": "method",
    "name": "countingRemoveAllByIndexValues",
    "code": "int countingRemoveAllByIndexValues(String index, Collection<?> indexValues) {\n      int count = 0;\n      if (KVIndex.NATURAL_INDEX_NAME.equals(index)) {\n        for (Object naturalKey : indexValues) {\n          count += delete(asKey(naturalKey)) ? 1 : 0;\n        }\n        return count;\n      } else if (hasNaturalParentIndex && naturalParentIndexName.equals(index)) {\n        for (Object indexValue : indexValues) {\n          Comparable<Object> parentKey = asKey(indexValue);\n          NaturalKeys children = parentToChildrenMap.getOrDefault(parentKey, new NaturalKeys());\n          for (Comparable<Object> naturalKey : children.keySet()) {\n            data.remove(naturalKey);\n            count ++;\n          }\n          parentToChildrenMap.remove(parentKey);\n        }\n        return count;\n      } else {\n        Predicate<? super T> filter = getPredicate(ti.getAccessor(index), indexValues);\n        CountingRemoveIfForEach<T> callback = new CountingRemoveIfForEach<>(this, filter);\n\n        data.forEach(callback);\n        return callback.count();\n      }\n    }",
    "comment": "If there is a parent index for the natural index and `index` happens to be it,\nSpark can use the `parentToChildrenMap` to get the related natural keys, and then\ndelete them from `data`.\nGo through all the values in `data` and delete objects that meets the predicate `filter`.\nThis can be slow when there is a large number of entries in `data`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "minRunLength",
    "code": "private int minRunLength(int n) {\n    assert n >= 0;\n    int r = 0;      // Becomes 1 if any 1 bits are shifted off\n    while (n >= MIN_MERGE) {\n      r |= (n & 1);\n      n >>= 1;\n    }\n    return n + r;\n  }",
    "comment": "Returns the minimum acceptable run length for an array of the specified\nlength. Natural runs shorter than this will be extended with\n{@link #binarySort}.\n\nRoughly speaking, the computation is:\n\nIf n < MIN_MERGE, return n (it's too small to bother with fancy stuff).\nElse if n is an exact power of 2, return MIN_MERGE/2.\nElse return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k\nis close to, but strictly less than, an exact power of 2.\n\nFor the rationale, see listsort.txt.\n\n@param n the length of the array to be sorted\n@return the length of the minimum run to be merged"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/RuleChain.java",
    "type": "method",
    "name": "around",
    "code": "public RuleChain around(TestRule enclosedRule) {\n        if (enclosedRule == null) {\n            throw new NullPointerException(\"The enclosed rule must not be null\");\n        }\n        List<TestRule> rulesOfNewChain = new ArrayList<TestRule>();\n        rulesOfNewChain.add(enclosedRule);\n        rulesOfNewChain.addAll(rulesStartingWithInnerMost);\n        return new RuleChain(rulesOfNewChain);\n    }",
    "comment": "Create a new {@code RuleChain}, which encloses the given {@link TestRule} with\n\n@param enclosedRule the rule to enclose; must not be {@code null}.\n@return a new {@code RuleChain}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/guarded-suspension/src/main/java/com/iluwatar/guarded/suspension/GuardedQueue.java",
    "type": "method",
    "name": "put",
    "code": "public synchronized void put(Integer e) {\n    LOGGER.info(\"putting\");\n    sourceList.add(e);\n    LOGGER.info(\"notifying\");\n    notify();\n  }",
    "comment": "Put a value in the queue.\n\n@param e number which we want to put to our queue"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getRuntimeDependencies",
    "code": "public List<Dependency> getRuntimeDependencies() {\n        Set<Artifact> artifacts = getArtifacts();\n\n        if ((artifacts == null) || artifacts.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Dependency> list = new ArrayList<>(artifacts.size());\n\n        for (Artifact a : getArtifacts()) {\n            if (isRuntimePathElement(a.getScope())) {\n                Dependency dependency = new Dependency();\n\n                dependency.setArtifactId(a.getArtifactId());\n                dependency.setGroupId(a.getGroupId());\n                dependency.setVersion(a.getVersion());\n                dependency.setScope(a.getScope());\n                dependency.setType(a.getType());\n                dependency.setClassifier(a.getClassifier());\n\n                list.add(dependency);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }",
    "comment": "TODO let the scope handler deal with this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3703ExecutionProjectWithRelativePathsTest.java",
    "type": "method",
    "name": "MavenITmng3703ExecutionProjectWithRelativePathsTest",
    "code": "public MavenITmng3703ExecutionProjectWithRelativePathsTest() {\n        super(\"[2.1.0-M1,)\"); // only test in 2.1.0+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3703\">MNG-3703</a>.\n\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "updateAndGetUser",
    "code": "public void updateAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        User updatedUser = new User(USER.getId(), \"new username\");\n        mDataSource.insertOrUpdateUser(updatedUser);\n\n        User dbUser = mDataSource.getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), \"new username\");\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are updating the name of the user\nThe retrieved user has the updated username"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-settings-builder/src/main/java/org/apache/maven/settings/io/SettingsParseException.java",
    "type": "method",
    "name": "SettingsParseException",
    "code": "public SettingsParseException(String message, int lineNumber, int columnNumber) {\n        super(message);\n        this.lineNumber = lineNumber;\n        this.columnNumber = columnNumber;\n    }",
    "comment": "Creates a new parser exception with the specified details.\n\n@param message The error message, may be {@code null}.\n@param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.\n@param columnNumber The one-based index of the column containing the error or {@code -1} if unknown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "getProperty",
    "code": "public String getProperty(String key, String defaultValue) {\n        if (this.get(key) != null) {\n            return this.get(key);\n        }\n        return defaultValue;\n    }",
    "comment": "Searches for the property with the specified key in this property list. If the key is not found in this property\nlist, the default property list, and its defaults, recursively, are then checked. The method returns the default\nvalue argument if the property is not found.\n\n@param key the property key.\n@param defaultValue a default value.\n@return The property value of the default value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-idempotent-consumer/src/main/java/com/iluwatar/idempotentconsumer/RequestStateMachine.java",
    "type": "method",
    "name": "next",
    "code": "public Request next(Request req, Request.Status nextStatus) {\n    String transitionStr = String.format(\"Transition: %s -> %s\", req.getStatus(), nextStatus);\n    switch (nextStatus) {\n      case PENDING -> throw new InvalidNextStateException(transitionStr);\n      case STARTED -> {\n        if (Request.Status.PENDING.equals(req.getStatus())) {\n          return new Request(req.getUuid(), Request.Status.STARTED);\n        }\n        throw new InvalidNextStateException(transitionStr);\n      }\n      case COMPLETED -> {\n        if (Request.Status.STARTED.equals(req.getStatus())) {\n          return new Request(req.getUuid(), Request.Status.COMPLETED);\n        }\n        throw new InvalidNextStateException(transitionStr);\n      }\n      default -> throw new InvalidNextStateException(transitionStr);\n    }\n  }",
    "comment": "Provides the next possible state of the request based on the current and next status.\n\n@param req The actual request object. This object MUST NOT be null and SHOULD have a valid\nstatus.\n@param nextStatus Represents the next status that the request could transition to. MUST NOT be\nnull.\n@return A new Request object with updated status if the transition is valid.\n@throws InvalidNextStateException If an invalid state transition is attempted."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-yarn/src/main/java/org/apache/spark/network/yarn/YarnShuffleService.java",
    "type": "method",
    "name": "isAuthenticationEnabled",
    "code": "private boolean isAuthenticationEnabled() {\n    return secretManager != null;\n  }",
    "comment": "Return whether authentication is enabled as specified by the configuration.\nIf so, fetch requests will fail unless the appropriate authentication secret\nfor the application is provided."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/test/java/org/apache/maven/artifact/versioning/ComparableVersionTest.java",
    "type": "method",
    "name": "testMng5568",
    "code": "void testMng5568() {\n        String a = \"6.1.0\";\n        String b = \"6.1.0rc3\";\n        String c = \"6.1H.5-beta\"; // this is the unusual version string, with 'H' in the middle\n\n        checkVersionsOrder(b, a); // classical\n        checkVersionsOrder(b, c); // now b < c, but before MNG-5568, we had b > c\n        checkVersionsOrder(a, c);\n    }",
    "comment": "Test <a href=\"https://issues.apache.org/jira/browse/MNG-5568\">MNG-5568</a> edge case\nwhich was showing transitive inconsistency: since A &gt; B and B &gt; C then we should have A &gt; C\notherwise sorting a list of ComparableVersions() will in some cases throw runtime exception;\nsee Netbeans issues <a href=\"https://netbeans.org/bugzilla/show_bug.cgi?id=240845\">240845</a> and\n<a href=\"https://netbeans.org/bugzilla/show_bug.cgi?id=226100\">226100</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/spatial-partition/src/main/java/com/iluwatar/spatialpartition/App.java",
    "type": "method",
    "name": "noSpatialPartition",
    "code": "static void noSpatialPartition(int numOfMovements, Map<Integer, Bubble> bubbles) {\n    // all bubbles have to be checked for collision for all bubbles\n    var bubblesToCheck = bubbles.values();\n\n    // will run numOfMovement times or till all bubbles have popped\n    while (numOfMovements > 0 && !bubbles.isEmpty()) {\n      bubbles.forEach(\n          (i, bubble) -> {\n            // bubble moves, new position gets updated\n            // and collisions are checked with all bubbles in bubblesToCheck\n            bubble.move();\n            bubbles.replace(i, bubble);\n            bubble.handleCollision(bubblesToCheck, bubbles);\n          });\n      numOfMovements--;\n    }\n    // bubbles not popped\n    bubbles.keySet().forEach(key -> LOGGER.info(\"Bubble {} not popped\", key));\n  }",
    "comment": "The idea behind the <b>Spatial Partition</b> design pattern is to enable efficient location of\nobjects by storing them in a data structure that is organised by their positions. This is\nespecially useful in the gaming world, where one may need to look up all the objects within a\ncertain boundary, or near a certain other object, repeatedly. The data structure can be used to\nstore moving and static objects, though in order to keep track of the moving objects, their\npositions will have to be reset each time they move. This would mean having to create a new\ninstance of the data structure each frame, which would use up additional memory, and so this\npattern should only be used if one does not mind trading memory for speed and the number of\nobjects to keep track of is large to justify the use of the extra space.\n\n<p>In our example, we use <b>{@link QuadTree} data structure</b> which divides into 4 (quad)\nsub-sections when the number of objects added to it exceeds a certain number (int field\ncapacity). There is also a <b>{@link Rect}</b> class to define the boundary of the quadtree. We\nuse an abstract class <b>{@link Point}</b> with x and y coordinate fields and also an id field so\nthat it can easily be put and looked up in the hashmap. This class has abstract methods to define\nhow the object moves (move()), when to check for collision with any object (touches(obj)) and how\nto handle collision (handleCollision(obj)), and will be extended by any object whose position has\nto be kept track of in the quadtree. The <b>{@link SpatialPartitionGeneric}</b> abstract class\nhas 2 fields - a hashmap containing all objects (we use hashmap for faster lookups, insertion and\ndeletion) and a quadtree, and contains an abstract method which defines how to handle\ninteractions between objects using the quadtree.\n\n<p>Using the quadtree data structure will reduce the time complexity of finding the objects\nwithin a certain range from <b>O(n^2) to O(nlogn)</b>, increasing the speed of computations\nimmensely in case of large number of objects, which will have a positive effect on the rendering\nspeed of the game."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/CLIReportingUtils.java",
    "type": "method",
    "name": "createMavenVersionString",
    "code": "public static String createMavenVersionString(Properties buildProperties) {\n        String timestamp = reduce(buildProperties.getProperty(\"timestamp\"));\n        String version = reduce(buildProperties.getProperty(BUILD_VERSION_PROPERTY));\n        String rev = reduce(buildProperties.getProperty(\"buildNumber\"));\n        String distributionName = reduce(buildProperties.getProperty(\"distributionName\"));\n\n        String msg = distributionName + \" \";\n        msg += (version != null ? version : \"<version unknown>\");\n        if (rev != null || timestamp != null) {\n            msg += \" (\";\n            msg += (rev != null ? rev : \"\");\n            if (timestamp != null && !timestamp.isEmpty()) {\n                String ts = formatTimestamp(Long.parseLong(timestamp));\n                msg += (rev != null ? \"; \" : \"\") + ts;\n            }\n            msg += \")\";\n        }\n        return msg;\n    }",
    "comment": "Create a human-readable string containing the Maven version, buildnumber, and time of build\n\n@param buildProperties The build properties\n@return Readable build info"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/path/DefaultModelUrlNormalizer.java",
    "type": "method",
    "name": "setUrlNormalizer",
    "code": "public DefaultModelUrlNormalizer setUrlNormalizer(UrlNormalizer urlNormalizer) {\n        this.urlNormalizer = urlNormalizer;\n        return this;\n    }",
    "comment": "Normalizes URLs to remove the ugly parent references \"../\" that got potentially inserted by URL adjustment during\nmodel inheritance.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ResolverFacade.java",
    "type": "method",
    "name": "create",
    "code": "private static ResolverFacade create(Executable executable, Annotation annotation, int indexOffset) {\n\t\tNavigableMap<Integer, ExecutableParameterDeclaration> indexedParameters = new TreeMap<>();\n\t\tNavigableMap<Integer, ExecutableParameterDeclaration> aggregatorParameters = new TreeMap<>();\n\t\tjava.lang.reflect.Parameter[] parameters = executable.getParameters();\n\t\tfor (int index = indexOffset; index < parameters.length; index++) {\n\t\t\tExecutableParameterDeclaration declaration = new ExecutableParameterDeclaration(parameters[index], index,\n\t\t\t\tindexOffset);\n\t\t\tif (declaration.isAggregator()) {\n\t\t\t\tPreconditions.condition(\n\t\t\t\t\taggregatorParameters.isEmpty()\n\t\t\t\t\t\t\t|| aggregatorParameters.lastKey() == declaration.getParameterIndex() - 1,\n\t\t\t\t\t() -> String.format(\n\t\t\t\t\t\t\"@%s %s declares formal parameters in an invalid order: \"\n\t\t\t\t\t\t\t\t+ \"argument aggregators must be declared after any indexed arguments \"\n\t\t\t\t\t\t\t\t+ \"and before any arguments resolved by another ParameterResolver.\",\n\t\t\t\t\t\tannotation.annotationType().getSimpleName(),\n\t\t\t\t\t\tDefaultParameterDeclarations.describe(executable)));\n\t\t\t\taggregatorParameters.put(declaration.getParameterIndex(), declaration);\n\t\t\t}\n\t\t\telse if (aggregatorParameters.isEmpty()) {\n\t\t\t\tindexedParameters.put(declaration.getParameterIndex(), declaration);\n\t\t\t}\n\t\t}\n\t\treturn new ResolverFacade(executable, indexedParameters, new LinkedHashSet<>(aggregatorParameters.values()),\n\t\t\tindexOffset);\n\t}",
    "comment": "Create a new {@link ResolverFacade} for the supplied {@link Executable}.\nimplementations come last.</li>\n</ol>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/commander/src/main/java/com/iluwatar/commander/AppAllCases.java",
    "type": "method",
    "name": "employeeDatabaseUnavailableCase",
    "code": "void employeeDatabaseUnavailableCase() {\n    var ps =\n        new PaymentService(\n            new PaymentDatabase(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException());\n    var ss = new ShippingService(new ShippingDatabase());\n    var ms = new MessagingService(new MessagingDatabase());\n    var eh =\n        new EmployeeHandle(\n            new EmployeeDatabase(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException());\n    var qdb =\n        new QueueDatabase(\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(),\n            new DatabaseUnavailableException());\n    var c = new Commander(eh, ps, ss, ms, qdb, retryParams, timeLimits);\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    c.placeOrder(order);\n  }",
    "comment": "The {@code AppAllCases} class tests various scenarios for the microservices involved in the order\nplacement process. This class consolidates previously separated cases into a single class to\nmanage different success and failure scenarios for each service.\n\n<p>The application consists of abstract classes {@link Database} and {@link Service} which are\nextended by all the databases and services. Each service has a corresponding database to be\nupdated and receives requests from an external user through the {@link Commander} class. There\nare 5 microservices:\n\n<ul>\n<li>{@link ShippingService}\n<li>{@link PaymentService}\n<li>{@link MessagingService}\n<li>{@link EmployeeHandle}\n<li>{@link QueueDatabase}\n</ul>\n\n<p>Retries are managed using the {@link Retry} class, ensuring idempotence by performing checks\nbefore making requests to services and updating the {@link Order} class fields upon request\nsuccess or definitive failure.\n\n<p>This class tests the following scenarios:\n\n<ul>\n<li>Employee database availability and unavailability\n<li>Payment service success and failures\n<li>Messaging service database availability and unavailability\n<li>Queue database availability and unavailability\n<li>Shipping service success and failures\n</ul>\n\n<p>Each scenario is encapsulated in a corresponding method that sets up the service conditions\nand tests the order placement process.\n\n<p>The main method executes all success and failure cases to verify the application's behavior\nunder different conditions.\n\n<p><strong>Usage:</strong>\n\n<pre>{@code\npublic static void main(String[] args) {\nAppAllCases app = new AppAllCases();\napp.testAllScenarios();\n}\n}</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/DiscoveryIssueReporter.java",
    "type": "method",
    "name": "deduplicating",
    "code": "static DiscoveryIssueReporter deduplicating(DiscoveryIssueReporter delegate) {\n\t\tPreconditions.notNull(delegate, \"delegate must not be null\");\n\t\tSet<DiscoveryIssue> seen = new HashSet<>();\n\t\treturn issue -> {\n\t\t\tboolean notSeen = seen.add(issue);\n\t\t\tif (notSeen) {\n\t\t\t\tdelegate.reportIssue(issue);\n\t\t\t}\n\t\t};\n\t}",
    "comment": "Create a new {@code DiscoveryIssueReporter} that avoids reporting"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/project/artifact/ActiveProjectArtifact.java",
    "type": "method",
    "name": "ActiveProjectArtifact",
    "code": "public ActiveProjectArtifact(MavenProject project, Artifact artifact) {\n        this.artifact = artifact;\n        this.project = project;\n\n        artifact.setFile(project.getArtifact().getFile());\n        artifact.setResolved(true);\n    }",
    "comment": "Wraps an active project instance to be able to receive updates from its artifact without affecting the original\nattributes of this artifact.\n\nTODO I think this exposes a design flaw in that the immutable and mutable parts of an artifact are in one class and\nshould be split. ie scope, file, etc depend on the context of use, whereas everything else is immutable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProblemCollector.java",
    "type": "method",
    "name": "Impl",
    "code": "private Impl(int maxCountLimit) {\n            if (maxCountLimit < 0) {\n                throw new IllegalArgumentException(\"maxCountLimit must be non-negative\");\n            }\n            this.maxCountLimit = maxCountLimit;\n            this.totalCount = new AtomicInteger();\n            this.counters = new ConcurrentHashMap<>();\n            this.problems = new ConcurrentHashMap<>();\n        }",
    "comment": "Default implementation of the ProblemCollector interface.\n\n@param <P> the type of problem"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "debug",
    "code": "default MessageBuilder debug(Object message) {\n        return style(\".\" + Constants.MAVEN_STYLE_DEBUG_NAME + \":-\" + Constants.MAVEN_STYLE_DEBUG_DEFAULT, message);\n    }",
    "comment": "Append message content in debug style.\nBy default, bold cyan\n\n@param message the message to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "getKeyBase",
    "code": "public Object getKeyBase() {\n      assert (isDefined);\n      return baseObject;\n    }",
    "comment": "Returns the base object for key."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(byte expected, byte actual) {\n        Assert.assertEquals(expected, actual);\n    }",
    "comment": "Asserts that two bytes are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Double> create(Scope scope, double[][][][][] data) {\n    return create(scope, data, Double.class);\n  }",
    "comment": "Creates a rank-5 constant of {@code double} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaIsotonicRegressionExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf sparkConf = new SparkConf().setAppName(\"JavaIsotonicRegressionExample\");\n    JavaSparkContext jsc = new JavaSparkContext(sparkConf);\n    JavaRDD<LabeledPoint> data = MLUtils.loadLibSVMFile(\n      jsc.sc(), \"data/mllib/sample_isotonic_regression_libsvm_data.txt\").toJavaRDD();\n\n    JavaRDD<Tuple3<Double, Double, Double>> parsedData = data.map(point ->\n      new Tuple3<>(point.label(), point.features().apply(0), 1.0));\n\n    JavaRDD<Tuple3<Double, Double, Double>>[] splits =\n      parsedData.randomSplit(new double[]{0.6, 0.4}, 11L);\n    System.out.println(\"Mean Squared Error = \" + meanSquaredError);\n\n    model.save(jsc.sc(), \"target/tmp/myIsotonicRegressionModel\");\n    IsotonicRegressionModel sameModel =\n      IsotonicRegressionModel.load(jsc.sc(), \"target/tmp/myIsotonicRegressionModel\");\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nCreate label, feature, weight tuples from input data with weight set to default value 1.0.\nSplit data into training (60%) and test (40%) sets.\nSave and load model\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultInheritanceAssembler.java",
    "type": "method",
    "name": "getChildPathAdjustment",
    "code": "private String getChildPathAdjustment(Model child, Model parent, String childDirectory) {\n        String adjustment = \"\";\n\n        if (parent != null) {\n            String childName = child.getArtifactId();\n\n            /*\n             * This logic (using filesystem, against wanted independence from the user environment) exists only for the\n             * sake of backward-compat with 2.x (MNG-5000). In general, it is wrong to\n             * base URL inheritance on the module directory names as this information is unavailable for POMs in the\n             * repository. In other words, modules where artifactId != moduleDirName will see different effective URLs\n             * depending on how the model was constructed (from filesystem or from repository).\n             */\n            if (child.getProjectDirectory() != null) {\n                childName = child.getProjectDirectory().getFileName().toString();\n            }\n\n            for (String module : parent.getModules()) {\n                module = module.replace('\\\\', '/');\n\n                if (module.regionMatches(true, module.length() - 4, \".xml\", 0, 4)) {\n                    module = module.substring(0, module.lastIndexOf('/') + 1);\n                }\n\n                String moduleName = module;\n                if (moduleName.endsWith(\"/\")) {\n                    moduleName = moduleName.substring(0, moduleName.length() - 1);\n                }\n\n                int lastSlash = moduleName.lastIndexOf('/');\n\n                moduleName = moduleName.substring(lastSlash + 1);\n\n                if ((moduleName.equals(childName) || (moduleName.equals(childDirectory))) && lastSlash >= 0) {\n                    adjustment = module.substring(0, lastSlash);\n                    break;\n                }\n            }\n        }\n\n        return adjustment;\n    }",
    "comment": "Calculates the relative path from the base directory of the parent to the parent directory of the base directory\nof the child. The general idea is to adjust inherited URLs to match the project layout (in SCM).\n\n<p>This calculation is only a heuristic based on our conventions.\nIn detail, the algo relies on the following assumptions: <ul>\n<li>The parent uses aggregation and refers to the child via the modules section</li>\n<li>The module path to the child is considered to\npoint at the POM rather than its base directory if the path ends with \".xml\" (ignoring case)</li>\n<li>The name of the child's base directory matches the artifact id of the child.</li>\n</ul>\nNote that for the sake of independence from the user\nenvironment, the filesystem is intentionally not used for the calculation.</p>\n\n@param child The child model, must not be <code>null</code>.\n@param parent The parent model, may be <code>null</code>.\n@param childDirectory The directory defined in child model, may be <code>null</code>.\n@return The path adjustment, can be empty but never <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultDependencyManagementInjector.java",
    "type": "method",
    "name": "injectManagement",
    "code": "public Model injectManagement(Model model, ModelBuilderRequest request, ModelProblemCollector problems) {\n        return merger.mergeManagedDependencies(model);\n    }",
    "comment": "Handles injection of dependency management into the model."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantBuilder.java",
    "type": "method",
    "name": "result",
    "code": "public Variant result() {\n    int numKeys = dictionaryKeys.size();\n    // Use long to avoid overflow in accumulating lengths.\n    long dictionaryStringSize = 0;\n    for (byte[] key : dictionaryKeys) {\n      dictionaryStringSize += key.length;\n    }\n    // Determine the number of bytes required per offset entry.\n    // The largest offset is the one-past-the-end value, which is total string size. It's very\n    // unlikely that the number of keys could be larger, but incorporate that into the calcualtion\n    // in case of pathological data.\n    long maxSize = Math.max(dictionaryStringSize, numKeys);\n    if (maxSize > SIZE_LIMIT) {\n      throw new VariantSizeLimitException();\n    }\n    int offsetSize = getIntegerSize((int)maxSize);\n\n    int offsetStart = 1 + offsetSize;\n    int stringStart = offsetStart + (numKeys + 1) * offsetSize;\n    long metadataSize = stringStart + dictionaryStringSize;\n\n    if (metadataSize > SIZE_LIMIT) {\n      throw new VariantSizeLimitException();\n    }\n    byte[] metadata = new byte[(int) metadataSize];\n    int headerByte = VERSION | ((offsetSize - 1) << 6);\n    writeLong(metadata, 0, headerByte, 1);\n    writeLong(metadata, 1, numKeys, offsetSize);\n    int currentOffset = 0;\n    for (int i = 0; i < numKeys; ++i) {\n      writeLong(metadata, offsetStart + i * offsetSize, currentOffset, offsetSize);\n      byte[] key = dictionaryKeys.get(i);\n      System.arraycopy(key, 0, metadata, stringStart + currentOffset, key.length);\n      currentOffset += key.length;\n    }\n    writeLong(metadata, offsetStart + numKeys * offsetSize, currentOffset, offsetSize);\n    return new Variant(Arrays.copyOfRange(writeBuffer, 0, writePos), metadata);\n  }",
    "comment": "Similar {@link #parseJson(String, boolean)}, but takes a JSON parser instead of string input."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(long[] expected, long[] actual, Supplier<String> messageSupplier) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} long arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "aborted",
    "code": "public Events aborted() {\n\t\treturn new Events(finishedEventsByStatus(Status.ABORTED), this.category + \" Aborted\");\n\t}",
    "comment": "Get the aborted {@link Events} contained in this {@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/RelocatedArtifact.java",
    "type": "method",
    "name": "setVersion",
    "code": "public Artifact setVersion(String version) {\n        String current = getVersion();\n        if (current.equals(version) || (version == null && current.isEmpty())) {\n            return this;\n        }\n        return new RelocatedArtifact(artifact, groupId, artifactId, classifier, extension, version, message);\n    }",
    "comment": "Revise these three methods when MRESOLVER-233 is delivered"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistrationViaParametersAndFieldsTests.java",
    "type": "method",
    "name": "test",
    "code": "void test() {\n\t\t\tassertThat(instanceField1).isEqualTo(\"postProcessTestInstance - instanceField1\");\n\t\t\tassertThat(instanceField2).isEqualTo(\"postProcessTestInstance - instanceField2\");\n\t\t}",
    "comment": "The {@link MagicField.Extension} is registered via an instance field."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/ByteArray.java",
    "type": "method",
    "name": "concat",
    "code": "public static byte[] concat(byte[]... inputs) {\n    return concatWS(EMPTY_BYTE, inputs);\n  }",
    "comment": "Concatenate multiple byte arrays into one.\nIf one of the inputs is null then null will be returned.\n\n@param inputs byte arrays to concatenate\n@return the concatenated byte array or null if one of the arguments is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Byte expected, Byte actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/AutoCloseTests.java",
    "type": "method",
    "name": "fieldsAreProperlyClosedWithinTestClassHierarchy",
    "code": "void fieldsAreProperlyClosedWithinTestClassHierarchy() {\n\t\tEvents tests = executeTestsForClass(SuperTestCase.class).testEvents();\n\t\ttests.assertStatistics(stats -> stats.succeeded(1));\n\t\tassertThat(recorder).containsExactly(//\n\t\t\t\"SuperTestCase.superClosable.close()\", //\n\t\t\t\"SuperTestCase.superStaticClosable.close()\" //\n\t\t);\n\n\t\tresetTracking();\n\n\t\ttests = executeTestsForClass(SubTestCase.class).testEvents();\n\t\ttests.assertStatistics(stats -> stats.succeeded(2));\n\t\tassertThat(recorder).containsExactly(//\n\t\t\t\"SubTestCase.subClosable.close()\", //\n\t\t\t\"SuperTestCase.superClosable.close()\", //\n\t\t\t\"SubTestCase.subClosable.close()\", //\n\t\t\t\"SuperTestCase.superClosable.close()\", //\n\t\t\t\"SubTestCase.subStaticClosable.close()\", //\n\t\t\t\"SuperTestCase.superStaticClosable.close()\" //\n\t\t);\n\t}",
    "comment": "superTest()\nClass-level cleanup\nReset tracking\nsuperTest()\nsubTest()\nClass-level cleanup in subclass\nClass-level cleanup in superclass"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkSubmitCommandBuilder.java",
    "type": "method",
    "name": "checkJavaOptions",
    "code": "private void checkJavaOptions(String javaOptions) {\n    if (!isEmpty(javaOptions)) {\n      for (String javaOption: CommandBuilderUtils.parseOptionString(javaOptions)) {\n        if (javaOption.startsWith(\"-Xmx\")) {\n            String msg = String.format(\"Not allowed to specify max heap(Xmx) memory settings \" +\n              \"through java options (was %s). Use the corresponding --driver-memory or \" +\n              \"spark.driver.memory configuration instead.\", javaOptions);\n            throw new IllegalArgumentException(msg);\n        }\n      }\n    }\n  }",
    "comment": "SPARK-36796: Always add some JVM runtime default options to submit command"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectClasspathResource",
    "code": "public static ClasspathResourceSelector selectClasspathResource(String classpathResourceName) {\n\t\treturn selectClasspathResource(classpathResourceName, null);\n\t}",
    "comment": "Create a {@code ClasspathResourceSelector} for the supplied classpath\nresource name.\n\n<p>The name of a <em>classpath resource</em> must follow the semantics\nfor resource paths as defined in {@link ClassLoader#getResource(String)}.\n\n<p>If the supplied classpath resource name is prefixed with a slash\n({@code /}), the slash will be removed.\n\n<p>Since {@linkplain org.junit.platform.engine.TestEngine engines} are not\nexpected to modify the classpath, the supplied classpath resource must be\non the classpath of the\n{@linkplain Thread#getContextClassLoader() context class loader} of the\n{@linkplain Thread thread} that uses the resulting selector.\n\n@param classpathResourceName the name of the classpath resource; never\n{@code null} or blank\n@see #selectClasspathResource(String, FilePosition)\n@see #selectClasspathResource(Set)\n@see ClasspathResourceSelector\n@see ClassLoader#getResource(String)\n@see ClassLoader#getResourceAsStream(String)\n@see ClassLoader#getResources(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Request.java",
    "type": "method",
    "name": "classes",
    "code": "public static Request classes(Class<?>... classes) {\n        return classes(JUnitCore.defaultComputer(), classes);\n    }",
    "comment": "Create a <code>Request</code> that, when processed, will run all the tests\nin a set of classes with the default <code>Computer</code>.\n\n@param classes the classes containing the tests\n@return a <code>Request</code> that will cause all tests in the classes to be run"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "configurationParameters",
    "code": "public SuiteLauncherDiscoveryRequestBuilder configurationParameters(Map<String, String> configurationParameters) {\n\t\tthis.delegate.configurationParameters(configurationParameters);\n\t\treturn this;\n\t}",
    "comment": "Add all supplied configuration parameters to the request.\n\n@param configurationParameters the map of configuration parameters to add;\nnever {@code null}\n@return this builder for method chaining\n@see #configurationParameter(String, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(BooleanSupplier booleanSupplier, String message) {\n\t\tAssertFalse.assertFalse(booleanSupplier, message);\n\t}",
    "comment": "<em>Assert</em> that the boolean condition supplied by {@code booleanSupplier} is {@code false}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/CloseablePathTests.java",
    "type": "method",
    "name": "createTempDirectory",
    "code": "public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext) {\n\t\t\t\treturn path;\n\t\t\t}",
    "comment": "Integration tests for the creation of the {@link TempDirectory} based on the different result\nthat {@link TempDirFactory#createTempDirectory(AnnotatedElementContext, ExtensionContext)} may provide.\n\n@since 5.11\n@see TempDirFactory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotNull",
    "code": "public static void assertNotNull(Object actual, String message) {\n\t\tAssertNotNull.assertNotNull(actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code actual} is not {@code null}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/Preconditions.java",
    "type": "method",
    "name": "checkArgument",
    "code": "public static void checkArgument(boolean expression) {\n    if (!expression) {\n      throw new IllegalArgumentException();\n    }\n  }",
    "comment": "Ensures the truth of an expression involving one or more parameters to the calling method.\n\n@param expression a boolean expression\n@throws IllegalArgumentException if {@code expression} is false"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/aether/DefaultRepositorySystemSessionFactory.java",
    "type": "method",
    "name": "newRepositorySessionBuilder",
    "code": "public SessionBuilder newRepositorySessionBuilder(MavenExecutionRequest request) {\n        requireNonNull(request, \"request\");\n\n        MavenSessionBuilderSupplier supplier = new MavenSessionBuilderSupplier(repoSystem);\n        SessionBuilder sessionBuilder = supplier.get();\n        sessionBuilder.setArtifactTypeRegistry(new TypeRegistryAdapter(typeRegistry)); // dynamic\n        sessionBuilder.setCache(request.getRepositoryCache());\n\n        Map<String, String> mergedProps = createMergedProperties(request);\n\n        Map<String, Object> configProps = new LinkedHashMap<>();\n        configProps.put(ConfigurationProperties.USER_AGENT, getUserAgent());\n        configProps.put(ConfigurationProperties.INTERACTIVE, request.isInteractiveMode());\n        configProps.put(\"maven.startTime\", request.getStartTime());\n        configProps.put(Constants.MAVEN_START_INSTANT, request.getStartInstant());\n\n        sessionBuilder.setOffline(request.isOffline());\n        sessionBuilder.setChecksumPolicy(request.getGlobalChecksumPolicy());\n        sessionBuilder.setUpdatePolicy(\n                request.isNoSnapshotUpdates()\n                        ? RepositoryPolicy.UPDATE_POLICY_NEVER\n                        : request.isUpdateSnapshots() ? RepositoryPolicy.UPDATE_POLICY_ALWAYS : null);\n\n        int errorPolicy = 0;\n        errorPolicy |= request.isCacheNotFound()\n                ? ResolutionErrorPolicy.CACHE_NOT_FOUND\n                : ResolutionErrorPolicy.CACHE_DISABLED;\n        errorPolicy |= request.isCacheTransferError()\n                ? ResolutionErrorPolicy.CACHE_TRANSFER_ERROR\n                : ResolutionErrorPolicy.CACHE_DISABLED;\n        sessionBuilder.setResolutionErrorPolicy(\n                new SimpleResolutionErrorPolicy(errorPolicy, errorPolicy | ResolutionErrorPolicy.CACHE_NOT_FOUND));\n\n        sessionBuilder.setArtifactDescriptorPolicy(new SimpleArtifactDescriptorPolicy(\n                request.isIgnoreMissingArtifactDescriptor(), request.isIgnoreInvalidArtifactDescriptor()));\n\n        VersionFilter versionFilter = buildVersionFilter(mergedProps.get(Constants.MAVEN_VERSION_FILTER));\n        if (versionFilter != null) {\n            sessionBuilder.setVersionFilter(versionFilter);\n        }\n\n        DefaultMirrorSelector mirrorSelector = new DefaultMirrorSelector();\n        for (Mirror mirror : request.getMirrors()) {\n            mirrorSelector.add(\n                    mirror.getId(),\n                    mirror.getUrl(),\n                    mirror.getLayout(),\n                    false,\n                    mirror.isBlocked(),\n                    mirror.getMirrorOf(),\n                    mirror.getMirrorOfLayouts());\n        }\n        sessionBuilder.setMirrorSelector(mirrorSelector);\n\n        DefaultProxySelector proxySelector = new DefaultProxySelector();\n        for (Proxy proxy : request.getProxies()) {\n            AuthenticationBuilder authBuilder = new AuthenticationBuilder();\n            authBuilder.addUsername(proxy.getUsername()).addPassword(proxy.getPassword());\n            proxySelector.add(\n                    new org.eclipse.aether.repository.Proxy(\n                            proxy.getProtocol(), proxy.getHost(), proxy.getPort(), authBuilder.build()),\n                    proxy.getNonProxyHosts());\n        }\n        sessionBuilder.setProxySelector(proxySelector);\n\n        DefaultAuthenticationSelector authSelector = new DefaultAuthenticationSelector();\n        for (Server server : request.getServers()) {\n            AuthenticationBuilder authBuilder = new AuthenticationBuilder();\n            authBuilder.addUsername(server.getUsername()).addPassword(server.getPassword());\n            authBuilder.addPrivateKey(server.getPrivateKey(), server.getPassphrase());\n            authSelector.add(server.getId(), authBuilder.build());\n\n            if (server.getConfiguration() != null) {\n                XmlNode dom = server.getDelegate().getConfiguration();\n                List<XmlNode> children = dom.children().stream()\n                        .filter(c -> !\"wagonProvider\".equals(c.name()))\n                        .collect(Collectors.toList());\n                dom = XmlNode.newInstance(dom.name(), children);\n                PlexusConfiguration config = XmlPlexusConfiguration.toPlexusConfiguration(dom);\n                configProps.put(\"aether.transport.wagon.config.\" + server.getId(), config);\n\n                Map<String, String> headers = null;\n                Integer connectTimeout = null;\n                Integer requestTimeout = null;\n\n                PlexusConfiguration httpHeaders = config.getChild(\"httpHeaders\", false);\n                if (httpHeaders != null) {\n                    PlexusConfiguration[] properties = httpHeaders.getChildren(\"property\");\n                    if (properties != null && properties.length > 0) {\n                        headers = new HashMap<>();\n                        for (PlexusConfiguration property : properties) {\n                            headers.put(\n                                    property.getChild(\"name\").getValue(),\n                                    property.getChild(\"value\").getValue());\n                        }\n                    }\n                }\n\n                PlexusConfiguration connectTimeoutXml = config.getChild(\"connectTimeout\", false);\n                if (connectTimeoutXml != null) {\n                    connectTimeout = Integer.parseInt(connectTimeoutXml.getValue());\n                } else {\n                    PlexusConfiguration httpConfiguration = config.getChild(\"httpConfiguration\", false);\n                    if (httpConfiguration != null) {\n                        PlexusConfiguration httpConfigurationAll = httpConfiguration.getChild(\"all\", false);\n                        if (httpConfigurationAll != null) {\n                            connectTimeoutXml = httpConfigurationAll.getChild(\"connectionTimeout\", false);\n                            if (connectTimeoutXml != null) {\n                                connectTimeout = Integer.parseInt(connectTimeoutXml.getValue());\n                                logger.warn(\"Settings for server {} uses legacy format\", server.getId());\n                            }\n                        }\n                    }\n                }\n\n                PlexusConfiguration requestTimeoutXml = config.getChild(\"requestTimeout\", false);\n                if (requestTimeoutXml != null) {\n                    requestTimeout = Integer.parseInt(requestTimeoutXml.getValue());\n                } else {\n                    PlexusConfiguration httpConfiguration = config.getChild(\"httpConfiguration\", false);\n                    if (httpConfiguration != null) {\n                        PlexusConfiguration httpConfigurationAll = httpConfiguration.getChild(\"all\", false);\n                        if (httpConfigurationAll != null) {\n                            requestTimeoutXml = httpConfigurationAll.getChild(\"readTimeout\", false);\n                            if (requestTimeoutXml != null) {\n                                requestTimeout = Integer.parseInt(requestTimeoutXml.getValue());\n                                logger.warn(\"Settings for server {} uses legacy format\", server.getId());\n                            }\n                        }\n                    }\n                }\n\n                if (headers != null) {\n                    configProps.put(ConfigurationProperties.HTTP_HEADERS + \".\" + server.getId(), headers);\n                }\n                if (connectTimeout != null) {\n                    configProps.put(ConfigurationProperties.CONNECT_TIMEOUT + \".\" + server.getId(), connectTimeout);\n                }\n                if (requestTimeout != null) {\n                    configProps.put(ConfigurationProperties.REQUEST_TIMEOUT + \".\" + server.getId(), requestTimeout);\n                }\n            }\n\n            configProps.put(\"aether.transport.wagon.perms.fileMode.\" + server.getId(), server.getFilePermissions());\n            configProps.put(\"aether.transport.wagon.perms.dirMode.\" + server.getId(), server.getDirectoryPermissions());\n        }\n        sessionBuilder.setAuthenticationSelector(authSelector);\n\n        Object transport =\n                mergedProps.getOrDefault(Constants.MAVEN_RESOLVER_TRANSPORT, MAVEN_RESOLVER_TRANSPORT_DEFAULT);\n        if (MAVEN_RESOLVER_TRANSPORT_DEFAULT.equals(transport)) {\n        } else if (MAVEN_RESOLVER_TRANSPORT_JDK.equals(transport)) {\n            configProps.put(FILE_TRANSPORTER_PRIORITY_KEY, RESOLVER_MAX_PRIORITY);\n            configProps.put(JDK_HTTP_TRANSPORTER_PRIORITY_KEY, RESOLVER_MAX_PRIORITY);\n        } else if (MAVEN_RESOLVER_TRANSPORT_APACHE.equals(transport)\n                || MAVEN_RESOLVER_TRANSPORT_NATIVE.equals(transport)) {\n            if (MAVEN_RESOLVER_TRANSPORT_NATIVE.equals(transport)) {\n                logger.warn(\n                        \"Transport name '{}' is DEPRECATED/RENAMED, use '{}' instead\",\n                        MAVEN_RESOLVER_TRANSPORT_NATIVE,\n                        MAVEN_RESOLVER_TRANSPORT_APACHE);\n            }\n            configProps.put(FILE_TRANSPORTER_PRIORITY_KEY, RESOLVER_MAX_PRIORITY);\n            configProps.put(APACHE_HTTP_TRANSPORTER_PRIORITY_KEY, RESOLVER_MAX_PRIORITY);\n        } else if (MAVEN_RESOLVER_TRANSPORT_WAGON.equals(transport)) {\n            configProps.put(WAGON_TRANSPORTER_PRIORITY_KEY, RESOLVER_MAX_PRIORITY);\n        } else if (!MAVEN_RESOLVER_TRANSPORT_AUTO.equals(transport)) {\n            throw new IllegalArgumentException(\"Unknown resolver transport '\" + transport\n                    + \"'. Supported transports are: \" + MAVEN_RESOLVER_TRANSPORT_WAGON + \", \"\n                    + MAVEN_RESOLVER_TRANSPORT_APACHE + \", \" + MAVEN_RESOLVER_TRANSPORT_JDK + \", \"\n                    + MAVEN_RESOLVER_TRANSPORT_AUTO);\n        }\n\n        sessionBuilder.setIgnoreArtifactDescriptorRepositories(request.isIgnoreTransitiveRepositories());\n\n        sessionBuilder.setTransferListener(request.getTransferListener());\n\n        RepositoryListener repositoryListener = eventSpyDispatcher.chainListener(new LoggingRepositoryListener(logger));\n\n        boolean recordReverseTree = Boolean.parseBoolean(\n                mergedProps.getOrDefault(Constants.MAVEN_REPO_LOCAL_RECORD_REVERSE_TREE, Boolean.FALSE.toString()));\n        if (recordReverseTree) {\n            repositoryListener = new ChainedRepositoryListener(repositoryListener, new ReverseTreeRepositoryListener());\n        }\n        sessionBuilder.setRepositoryListener(repositoryListener);\n\n        String resolverDependencyManagerTransitivity = mergedProps.getOrDefault(\n                Constants.MAVEN_RESOLVER_DEPENDENCY_MANAGER_TRANSITIVITY, Boolean.TRUE.toString());\n        sessionBuilder.setDependencyManager(\n                supplier.getDependencyManager(Boolean.parseBoolean(resolverDependencyManagerTransitivity)));\n\n        ArrayList<Path> paths = new ArrayList<>();\n        String localRepoHead = mergedProps.get(Constants.MAVEN_REPO_LOCAL_HEAD);\n        if (localRepoHead != null) {\n            Arrays.stream(localRepoHead.split(\",\"))\n                    .filter(p -> p != null && !p.trim().isEmpty())\n                    .map(this::resolve)\n                    .forEach(paths::add);\n        }\n        paths.add(Paths.get(request.getLocalRepository().getBasedir()));\n        String localRepoTail = mergedProps.get(Constants.MAVEN_REPO_LOCAL_TAIL);\n        if (localRepoTail != null) {\n            Arrays.stream(localRepoTail.split(\",\"))\n                    .filter(p -> p != null && !p.trim().isEmpty())\n                    .map(this::resolve)\n                    .forEach(paths::add);\n        }\n        sessionBuilder.withLocalRepositoryBaseDirectories(paths);\n        if (mergedProps.containsKey(Constants.MAVEN_REPO_LOCAL_TAIL_IGNORE_AVAILABILITY)) {\n            configProps.put(\n                    ChainedLocalRepositoryManager.CONFIG_PROP_IGNORE_TAIL_AVAILABILITY,\n                    mergedProps.get(Constants.MAVEN_REPO_LOCAL_TAIL_IGNORE_AVAILABILITY));\n        }\n\n        for (RepositorySystemSessionExtender extender : sessionExtenders.values()) {\n            extender.extend(request, configProps, mirrorSelector, proxySelector, authSelector);\n        }\n\n        HashMap<String, Object> finalConfigProperties = new HashMap<>();\n        finalConfigProperties.putAll(mergedProps);\n        finalConfigProperties.putAll(configProps);\n\n        sessionBuilder.setUserProperties(request.getUserProperties());\n        sessionBuilder.setSystemProperties(request.getSystemProperties());\n        sessionBuilder.setConfigProperties(finalConfigProperties);\n\n        return sessionBuilder;\n    }",
    "comment": "this map is read ONLY to get config from (profiles + env + system + user)\nconfigProps map is kept \"pristine\", is written ONLY, the mandatory resolver config\nNote: we do NOT use WagonTransportConfigurationKeys here as Maven Core does NOT depend on Wagon Transport\nand this is okay and \"good thing\".\nTranslate to proper resolver configuration properties as well (as Plexus XML above is Wagon specific\nonly) but support only configuration/httpConfiguration/all, see\nhttps://maven.apache.org/guides/mini/guide-http-settings.html\nfallback configuration name\nfallback configuration name\norg.eclipse.aether.ConfigurationProperties.HTTP_HEADERS => Map<String, String>\norg.eclipse.aether.ConfigurationProperties.CONNECT_TIMEOUT => int\norg.eclipse.aether.ConfigurationProperties.REQUEST_TIMEOUT => int\nThe \"default\" mode (user did not set anything) from now on defaults to AUTO\nMake sure (whatever extra priority is set) that resolver file/jdk is selected\nMake sure (whatever extra priority is set) that resolver file/apache is selected\nMake sure (whatever extra priority is set) that wagon is selected\nmay be overridden\nPass over property supported by Maven 3.9.x\nat this point we have \"config\" with pure MANDATORY resolver config, so resolver final config properties are\nmergedProperties + configProperties"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java",
    "type": "method",
    "name": "isExternalHttpRepo",
    "code": "static boolean isExternalHttpRepo(ArtifactRepository originalRepository) {\n        try {\n            URL url = new URL(originalRepository.getUrl());\n            return (\"http\".equalsIgnoreCase(url.getProtocol())\n                            || \"dav\".equalsIgnoreCase(url.getProtocol())\n                            || \"dav:http\".equalsIgnoreCase(url.getProtocol())\n                            || \"dav+http\".equalsIgnoreCase(url.getProtocol()))\n                    && !isLocal(url.getHost());\n        } catch (MalformedURLException e) {\n            // bad url just skip it here. It should have been validated already, but the wagon lookup will deal with it\n            return false;\n        }\n    }",
    "comment": "Checks the URL to see if this repository refers to a non-localhost repository using HTTP.\n\n@param originalRepository\n@return true if external."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/BloomFilterImpl.java",
    "type": "method",
    "name": "mightContainBinary",
    "code": "public boolean mightContainBinary(byte[] item) {\n    int h1 = Murmur3_x86_32.hashUnsafeBytes(item, Platform.BYTE_ARRAY_OFFSET, item.length, 0);\n    int h2 = Murmur3_x86_32.hashUnsafeBytes(item, Platform.BYTE_ARRAY_OFFSET, item.length, h1);\n\n    long bitSize = bits.bitSize();\n    for (int i = 1; i <= numHashFunctions; i++) {\n      int combinedHash = h1 + (i * h2);\n      if (combinedHash < 0) {\n        combinedHash = ~combinedHash;\n      }\n      if (!bits.get(combinedHash % bitSize)) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": "Flip all the bits if it's negative (guaranteed positive number)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestInstanceFactoryTests.java",
    "type": "method",
    "name": "createTestInstance",
    "code": "public Object createTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext extensionContext) {\n\t\t\treturn null;\n\t\t}",
    "comment": "{@link TestInstanceFactory} that returns null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/BeforeEachAndAfterEachComposedAnnotationTests.java",
    "type": "method",
    "name": "beforeEachAndAfterEachAsMetaAnnotations",
    "code": "void beforeEachAndAfterEachAsMetaAnnotations() {\n\t\texecuteTestsForClass(TestCase.class).testEvents().assertStatistics(stats -> stats.started(1).succeeded(1));\n\n\t\tassertThat(methodsInvoked).containsExactly(\"beforeEach\", \"test\", \"afterEach\");\n\t}",
    "comment": "Integration tests that verify support for {@link BeforeEach} and {@link AfterEach}\nwhen used as meta-annotations in the {@link JupiterTestEngine}.\n\n@since 5.0\n@see BeforeAllAndAfterAllComposedAnnotationTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "subStringIndex",
    "code": "public UTF8String subStringIndex(UTF8String delim, int count) {\n    if (delim.numBytes == 0 || count == 0) {\n      return EMPTY_UTF8;\n    }\n    if (count > 0) {\n      int idx = -1;\n      while (count > 0) {\n        idx = find(delim, idx + 1);\n        if (idx >= 0) {\n          count --;\n        } else {\n          // can not find enough delim\n          return this;\n        }\n      }\n      if (idx == 0) {\n        return EMPTY_UTF8;\n      }\n      byte[] bytes = new byte[idx];\n      copyMemory(base, offset, bytes, BYTE_ARRAY_OFFSET, idx);\n      return fromBytes(bytes);\n\n    } else {\n      int idx = numBytes - delim.numBytes + 1;\n      count = -count;\n      while (count > 0) {\n        idx = rfind(delim, idx - 1);\n        if (idx >= 0) {\n          count --;\n        } else {\n          // can not find enough delim\n          return this;\n        }\n      }\n      if (idx + delim.numBytes == numBytes) {\n        return EMPTY_UTF8;\n      }\n      int size = numBytes - delim.numBytes - idx;\n      byte[] bytes = new byte[size];\n      copyMemory(base, offset + idx + delim.numBytes, bytes, BYTE_ARRAY_OFFSET, size);\n      return fromBytes(bytes);\n    }\n  }",
    "comment": "Returns the substring from string str before count occurrences of the delimiter delim.\nIf count is positive, everything the left of the final delimiter (counting from left) is\nreturned. If count is negative, every to the right of the final delimiter (counting from the\nright) is returned. subStringIndex performs a case-sensitive match when searching for delim."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/StylizeActivity.java",
    "type": "method",
    "name": "setStyle",
    "code": "private void setStyle(final ImageSlider slider, final float value) {\n    slider.setValue(value);\n\n    if (NORMALIZE_SLIDERS) {\n      float otherSum = 0.0f;\n\n      for (int i = 0; i < NUM_STYLES; ++i) {\n        if (adapter.items[i] != slider) {\n          otherSum += adapter.items[i].value;\n        }\n      }\n\n      if (otherSum > 0.0) {\n        float highestOtherVal = 0;\n        final float factor = otherSum > 0.0f ? (1.0f - value) / otherSum : 0.0f;\n        for (int i = 0; i < NUM_STYLES; ++i) {\n          final ImageSlider child = adapter.items[i];\n          if (child == slider) {\n            continue;\n          }\n          final float newVal = child.value * factor;\n          child.setValue(newVal > 0.01f ? newVal : 0.0f);\n\n          if (child.value > highestOtherVal) {\n            lastOtherStyle = i;\n            highestOtherVal = child.value;\n          }\n        }\n      } else {\n        if (adapter.items[lastOtherStyle] == slider) {\n          lastOtherStyle = (lastOtherStyle + 1) % NUM_STYLES;\n        }\n        adapter.items[lastOtherStyle].setValue(1.0f - value);\n      }\n    }\n\n    final boolean lastAllZero = allZero;\n    float sum = 0.0f;\n    for (int i = 0; i < NUM_STYLES; ++i) {\n      sum += adapter.items[i].value;\n    }\n    allZero = sum == 0.0f;\n\n    for (int i = 0; i < NUM_STYLES; ++i) {\n      styleVals[i] = allZero ? 1.0f / NUM_STYLES : adapter.items[i].value / sum;\n\n      if (lastAllZero != allZero) {\n        adapter.items[i].postInvalidate();\n      }\n    }\n  }",
    "comment": "Slider vals correspond directly to the input tensor vals, and normalization is visually\nmaintained by remanipulating non-selected sliders.\nEverything else is 0, so just pick a suitable slider to push up when the\nselected one goes down.\nNow update the values used for the input tensor. If nothing is set, mix in everything\nequally. Otherwise everything is normalized to sum to 1.0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java",
    "type": "method",
    "name": "init",
    "code": "void init() {\n\t\tlifecyclesMap.clear();\n\t\tinstanceMap.clear();\n\t\ttestsInvoked.clear();\n\t\tinstanceCount.clear();\n\t\tbeforeAllCount = 0;\n\t\tafterAllCount = 0;\n\t\tbeforeEachCount = 0;\n\t\tafterEachCount = 0;\n\t}",
    "comment": "Integration tests for {@link TestInstance @TestInstance} lifecycle support.\n\n@since 5.0\n@see TestInstanceLifecycleConfigurationTests\n@see TestInstanceLifecycleKotlinTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/LookupInvoker.java",
    "type": "method",
    "name": "doConfigureWithTerminal",
    "code": "protected final void doConfigureWithTerminal(C context, Terminal terminal) {\n        context.terminal = terminal;\n        Options options = context.invokerRequest.options();\n        // tricky thing: align what JLine3 detected and Maven thinks:\n        // if embedded, we default to context.coloredOutput=false unless overridden (see above)\n        // if not embedded, JLine3 may detect redirection and will create dumb terminal.\n        // To align Maven with outcomes, we set here color enabled based on these premises.\n        // Note: Maven3 suffers from similar thing: if you do `mvn3 foo > log.txt`, the output will\n        // not be not colored (good), but Maven will print out \"Message scheme: color\".\n        MessageUtils.setColorEnabled(\n                context.coloredOutput != null ? context.coloredOutput : !Terminal.TYPE_DUMB.equals(terminal.getType()));\n\n        // handle rawStreams: some would like to act on true, some on false\n        if (options.rawStreams().orElse(false)) {\n            doConfigureWithTerminalWithRawStreamsEnabled(context);\n        } else {\n            doConfigureWithTerminalWithRawStreamsDisabled(context);\n        }\n    }",
    "comment": "Called from {@link #createTerminal(LookupContext)} when Terminal was built."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/extensions/ExtensionResolutionException.java",
    "type": "method",
    "name": "ExtensionResolutionException",
    "code": "public ExtensionResolutionException(CoreExtension extension, Throwable cause) {\n        super(\n                \"Extension \" + extension.getId() + \" or one of its dependencies could not be resolved: \"\n                        + cause.getMessage(),\n                cause);\n        this.extension = extension;\n    }",
    "comment": "Exception occurring trying to resolve a plugin."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/textui/TestRunner.java",
    "type": "method",
    "name": "createTestResult",
    "code": "protected TestResult createTestResult() {\n        return new TestResult();\n    }",
    "comment": "Creates the TestResult to be used for the test run."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(byte[] expected, byte[] actual) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} byte arrays are equal.\n<p>If both are {@code null}, they are considered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(String message, boolean condition) {\n        Assert.assertFalse(message, condition);\n    }",
    "comment": "Asserts that a condition is false. If it isn't it throws\nan AssertionFailedError with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "assertStatistics",
    "code": "public Events assertStatistics(Consumer<EventStatistics> statisticsConsumer) {\n\t\tPreconditions.notNull(statisticsConsumer, \"Consumer must not be null\");\n\t\tEventStatistics eventStatistics = new EventStatistics(this, this.category);\n\t\tstatisticsConsumer.accept(eventStatistics);\n\t\teventStatistics.assertAll();\n\t\treturn this;\n\t}",
    "comment": "Assert statistics for the {@linkplain Event events} contained in this\n{@code Events} object.\n\n<h4>Example</h4>\n\n<p>{@code events.assertStatistics(stats -> stats.started(1).succeeded(1).failed(0));}\n\n@param statisticsConsumer a {@link Consumer} of {@link EventStatistics};\nnever {@code null}\n@return this {@code Events} object for method chaining; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestTemplateInvocationContext.java",
    "type": "method",
    "name": "getDisplayName",
    "code": "default String getDisplayName(int invocationIndex) {\n\t\treturn \"[\" + invocationIndex + \"]\";\n\t}",
    "comment": "Get the display name for this invocation.\n\n<p>The supplied {@code invocationIndex} is incremented by the framework\nwith each test invocation. Thus, in the case of multiple active\n{@linkplain TestTemplateInvocationContextProvider providers}, only the\nfirst active provider receives indices starting with {@code 1}.\n\n<p>The default implementation returns the supplied {@code invocationIndex}\nwrapped in brackets &mdash; for example, {@code [1]}, {@code [42]}, etc.\n\n@param invocationIndex the index of this invocation (1-based).\n@return the display name for this invocation; never {@code null} or blank"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestTag.java",
    "type": "method",
    "name": "TestTag",
    "code": "private TestTag(String name) {\n\t\tPreconditions.condition(TestTag.isValid(name),\n\t\t\t() -> String.format(\"Tag name [%s] must be syntactically valid\", name));\n\t\tthis.name = name.trim();\n\t}",
    "comment": "Create a {@code TestTag} from the supplied {@code name}.\n\n<p>Consider checking whether the syntax of the supplied {@code name}\nis {@linkplain #isValid(String) valid} before attempting to create a\n{@code TestTag} using this factory method.\n\n<p>Note: the supplied {@code name} will be {@linkplain String#trim() trimmed}.\n\n@param name the name of the tag; must be syntactically <em>valid</em>\n@throws PreconditionViolationException if the supplied tag name is not\nsyntactically <em>valid</em>\n@see TestTag#isValid(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "executionFinished",
    "code": "public static Event executionFinished(TestDescriptor testDescriptor, TestExecutionResult result) {\n\t\tPreconditions.notNull(result, \"Event of type FINISHED cannot have a null TestExecutionResult\");\n\t\treturn new Event(EventType.FINISHED, testDescriptor, result);\n\t}",
    "comment": "Create a <em>finished</em> {@code Event} for the supplied\n{@link TestDescriptor} and {@link TestExecutionResult}.\n\n@param testDescriptor the {@code TestDescriptor} associated with the event;\nnever {@code null}\n@param result the {@code TestExecutionResult} for the supplied\n{@code TestDescriptor}; never {@code null}\n@return the newly created {@code Event}\n@see EventType#FINISHED"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestExecutionListener.java",
    "type": "method",
    "name": "executionSkipped",
    "code": "default void executionSkipped(TestIdentifier testIdentifier, String reason) {\n\t}",
    "comment": "Called when the execution of a leaf or subtree of the {@link TestPlan}\nhas been skipped.\n\n<p>The {@link TestIdentifier} may represent a test or a container. In\nthe case of a container, no listener methods will be called for any of\nits descendants.\n\n<p>A skipped test or subtree of tests will never be reported as\n{@linkplain #executionStarted started} or\n{@linkplain #executionFinished finished}.\n\n@param testIdentifier the identifier of the skipped test or container\n@param reason a human-readable message describing why the execution\nhas been skipped"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/UnsafeShuffleWriter.java",
    "type": "method",
    "name": "if",
    "code": "if (spills.length == 0) {\n      final ShuffleMapOutputWriter mapWriter = shuffleExecutorComponents\n          .createMapOutputWriter(shuffleId, mapId, partitioner.numPartitions());\n      return mapWriter.commitAllPartitions(\n        ShuffleChecksumHelper.EMPTY_CHECKSUM_VALUE).getPartitionLengths();\n    } else if (spills.length == 1) {\n      Optional<SingleSpillShuffleMapOutputWriter> maybeSingleFileWriter =\n          shuffleExecutorComponents.createSingleFileMapOutputWriter(shuffleId, mapId);\n      if (maybeSingleFileWriter.isPresent()) {\n        // Here, we don't need to perform any metrics updates because the bytes written to this\n        // output file would have already been counted as shuffle bytes written.\n        partitionLengths = spills[0].partitionLengths;\n        logger.debug(\"Merge shuffle spills for mapId {} with length {}\", mapId,\n            partitionLengths.length);\n        maybeSingleFileWriter.get()\n          .transferMapSpillFile(spills[0].file, partitionLengths, sorter.getChecksums());\n      } else {\n        partitionLengths = mergeSpillsUsingStandardWriter(spills);\n      }\n    } else {\n      partitionLengths = mergeSpillsUsingStandardWriter(spills);\n    }",
    "comment": "Merge zero or more spill files together, choosing the fastest merging strategy based on the\nnumber of spills and the IO compression codec.\n\n@return the partition lengths in the merged file."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Server.java",
    "type": "method",
    "name": "Server",
    "code": "public Server(byte[] serverDef) {\n    nativeHandle = allocate(serverDef);\n  }",
    "comment": "Constructs a new instance of server.\n\n@param serverDef Server definition specified as a serialized <a\nhref=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/protobuf/tensorflow_server.proto\">ServerDef</a>\nprotocol buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/feature/JavaWord2VecSuite.java",
    "type": "method",
    "name": "word2Vec",
    "code": "public void word2Vec() {\n    String sentence = Strings.repeat(\"a b \", 100) + Strings.repeat(\"a c \", 10);\n    List<String> words = Arrays.asList(sentence.split(\" \"));\n    List<List<String>> localDoc = Arrays.asList(words, words);\n    JavaRDD<List<String>> doc = jsc.parallelize(localDoc);\n    Word2Vec word2vec = new Word2Vec()\n      .setVectorSize(10)\n      .setSeed(42L);\n    Word2VecModel model = word2vec.fit(doc);\n    Tuple2<String, Object>[] syms = model.findSynonyms(\"a\", 2);\n    Assertions.assertEquals(2, syms.length);\n    Assertions.assertEquals(\"b\", syms[0]._1());\n    Assertions.assertEquals(\"c\", syms[1]._1());\n  }",
    "comment": "The tests are to check Java compatibility."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaUserDefinedTypedAggregation.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"Java Spark SQL user-defined Datasets aggregation example\")\n      .getOrCreate();\n\n    Encoder<Employee> employeeEncoder = Encoders.bean(Employee.class);\n    String path = \"examples/src/main/resources/employees.json\";\n    Dataset<Employee> ds = spark.read().json(path).as(employeeEncoder);\n    ds.show();\n\n    MyAverage myAverage = new MyAverage();\n    TypedColumn<Employee, Double> averageSalary = myAverage.toColumn().name(\"average_salary\");\n    Dataset<Double> result = ds.select(averageSalary);\n    result.show();\n    spark.stop();\n  }",
    "comment": "$example off:typed_custom_aggregation$\n$example on:typed_custom_aggregation$\n+-------+------+\n|   name|salary|\n+-------+------+\n|Michael|  3000|\n|   Andy|  4500|\n| Justin|  3500|\n|  Berta|  4000|\n+-------+------+\nConvert the function to a `TypedColumn` and give it a name\n+--------------+\n|average_salary|\n+--------------+\n|        3750.0|\n+--------------+\n$example off:typed_custom_aggregation$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/json/JsonExpressionUtils.java",
    "type": "method",
    "name": "jsonObjectKeys",
    "code": "public static GenericArrayData jsonObjectKeys(UTF8String json) {\n    try (JsonParser jsonParser =\n        CreateJacksonParser.utf8String(SharedFactory.jsonFactory(), json)) {\n      if (jsonParser.nextToken() == null || jsonParser.currentToken() != JsonToken.START_OBJECT) {\n        return null;\n      }\n      List<UTF8String> arrayBufferOfKeys = new ArrayList<>();\n\n      while (jsonParser.nextValue() != null && jsonParser.currentName() != null) {\n        arrayBufferOfKeys.add(UTF8String.fromString(jsonParser.currentName()));\n\n        jsonParser.skipChildren();\n      }\n      return new GenericArrayData(arrayBufferOfKeys.toArray());\n    } catch (IOException e) {\n      return null;\n    }\n  }",
    "comment": "return null if an empty string or any other valid JSON string is encountered\nParse the JSON string to get all the keys of outermost JSON object\ntraverse until the end of input and ensure it returns valid key\nadd current fieldName to the ArrayBuffer\nskip all the children of inner object or array"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "copyFrom",
    "code": "public void copyFrom(UnsafeRow row) {\n    // copyFrom is only available for UnsafeRow created from byte array.\n    assert (baseObject instanceof byte[]) && baseOffset == Platform.BYTE_ARRAY_OFFSET;\n    if (row.sizeInBytes > this.sizeInBytes) {\n      // resize the underlying byte[] if it's not large enough.\n      this.baseObject = new byte[row.sizeInBytes];\n    }\n    Platform.copyMemory(\n      row.baseObject, row.baseOffset, this.baseObject, this.baseOffset, row.sizeInBytes);\n    // update the sizeInBytes.\n    this.sizeInBytes = row.sizeInBytes;\n  }",
    "comment": "Copies the input UnsafeRow to this UnsafeRow, and resize the underlying byte[] when the\ninput row is larger than this row."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Graph.java",
    "type": "method",
    "name": "toGraphDef",
    "code": "public byte[] toGraphDef() {\n    synchronized (nativeHandleLock) {\n      return toGraphDef(nativeHandle);\n    }\n  }",
    "comment": "Generate a serialized representation of the Graph.\n\n@see #importGraphDef(byte[])\n@see #importGraphDef(byte[], String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, double actual, double delta, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, delta, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/DefaultArtifactFilterManager.java",
    "type": "method",
    "name": "getCoreArtifactFilter",
    "code": "public ArtifactFilter getCoreArtifactFilter() {\n        return new ExclusionSetFilter(getCoreArtifactExcludes());\n    }",
    "comment": "Returns the artifact filter for the standard core artifacts.\n\n@see org.apache.maven.ArtifactFilterManager#getCoreArtifactFilter()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/SupportsOverwrite.java",
    "type": "method",
    "name": "canOverwrite",
    "code": "default boolean canOverwrite(Filter[] filters) {\n    return true;\n  }",
    "comment": "Checks whether it is possible to overwrite data from a data source table that matches filter\nexpressions.\n<p>\nRows should be overwritten from the data source iff all of the filter expressions match.\nThat is, the expressions must be interpreted as a set of filters that are ANDed together.\n\n@param filters V2 filter expressions, used to match data to overwrite\n@return true if the delete operation can be performed\n\n@since 3.4.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/ObjectBasedValueSource.java",
    "type": "method",
    "name": "ObjectBasedValueSource",
    "code": "public ObjectBasedValueSource(Object root) {\n        super(true);\n        this.root = root;\n    }",
    "comment": "Construct a new value source, using the supplied object as the root from\nwhich to start, and using expressions split at the dot ('.') to navigate\nthe object graph beneath this root.\n@param root the root of the graph."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java",
    "type": "method",
    "name": "merge",
    "code": "public void merge(ArtifactMetadata metadata) {\n        AbstractRepositoryMetadata repoMetadata = (AbstractRepositoryMetadata) metadata;\n        this.metadata.merge(repoMetadata.getMetadata());\n    }",
    "comment": "TODO not sure that it should assume this, maybe the calls to addMetadata should pre-merge, then artifact\nreplaces?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "insertAndGetUser",
    "code": "public void insertAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        User dbUser = mDataSource.getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), USER.getUserName());\n    }",
    "comment": "When inserting a new user in the data source\nThe user can be retrieved"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/max/MaxCore.java",
    "type": "method",
    "name": "sortedLeavesForTest",
    "code": "public List<Description> sortedLeavesForTest(Request request) {\n        return findLeaves(sortRequest(request));\n    }",
    "comment": "@param request a request to run\n@return a list of method-level tests to run, sorted in the order\nspecified in the class comment."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testSimpleSubtract",
    "code": "public void testSimpleSubtract() {\n        Money expected = new Money(2, \"CHF\");\n        assertEquals(expected, f14CHF.subtract(f12CHF));\n    }",
    "comment": "[14 CHF] - [12 CHF] == [2 CHF]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "enableImplicitConfigurationParameters",
    "code": "public LauncherDiscoveryRequestBuilder enableImplicitConfigurationParameters(boolean enabled) {\n\t\tthis.implicitConfigurationParametersEnabled = enabled;\n\t\treturn this;\n\t}",
    "comment": "Configure whether implicit configuration parameters should be considered.\n\n<p>By default, in addition to those parameters that are passed explicitly\nto this builder, configuration parameters are read from system properties\nand from the {@code junit-platform.properties} classpath resource.\nPassing {@code false} to this method, disables the latter two sources so\nthat only explicit configuration parameters are taken into account.\n\n@param enabled {@code true} if implicit configuration parameters should be\nconsidered\n@return this builder for method chaining\n@since 1.7\n@see #configurationParameter(String, String)\n@see #configurationParameters(Map)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/impl/DefaultProjectManager.java",
    "type": "method",
    "name": "getExecutionProject",
    "code": "public Optional<Project> getExecutionProject(@Nonnull Project project) {\n        return Optional.ofNullable(getMavenProject(project).getExecutionProject())\n                .map(p -> new DefaultProject(session, p));\n    }",
    "comment": "Session keep tracks of the Project per project id,\nso we cannot use session.getProject(p) for forked projects\nwhich are temporary clones"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(short[] expected, short[] actual, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} short arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/DefaultMaven.java",
    "type": "method",
    "name": "setupWorkspaceReader",
    "code": "private void setupWorkspaceReader(MavenSession session, MavenChainedWorkspaceReader chainedWorkspaceReader) {\n        Set<WorkspaceReader> workspaceReaders = new LinkedHashSet<>();\n        WorkspaceReader reactorReader = lookup.lookup(WorkspaceReader.class, ReactorReader.HINT);\n        workspaceReaders.add(reactorReader);\n        for (WorkspaceReader repoWorkspaceReader : chainedWorkspaceReader.getReaders()) {\n            if (repoWorkspaceReader != null && repoWorkspaceReader != reactorReader) {\n                workspaceReaders.add(repoWorkspaceReader);\n            }\n        }\n        workspaceReaders.addAll(getProjectScopedExtensionComponents(session.getProjects(), WorkspaceReader.class));\n        chainedWorkspaceReader.setReaders(workspaceReaders);\n    }",
    "comment": "Desired order of precedence for workspace readers before querying the local artifact repositories\n1) Reactor workspace reader\n2) Repository system session-scoped workspace reader (contains ide and exec request reader)\n3) .. n) Project-scoped workspace readers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/support/JupiterThrowableCollectorFactory.java",
    "type": "method",
    "name": "createThrowableCollector",
    "code": "public static ThrowableCollector createThrowableCollector() {\n\t\treturn new OpenTest4JAndJUnit4AwareThrowableCollector();\n\t}",
    "comment": "Create a new {@link ThrowableCollector} that treats instances of the\n{@code org.junit.AssumptionViolatedException} as <em>aborting</em>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Double> create(Scope scope, double data) {\n    return create(scope, data, Double.class);\n  }",
    "comment": "Creates a constant containing a single {@code double} element.\n\n@param scope is a scope used to add the underlying operation.\n@param data The value to put into the new constant.\n@return a double constant"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "failure",
    "code": "default MessageBuilder failure(Object message) {\n        return style(\".\" + Constants.MAVEN_STYLE_FAILURE_NAME + \":-\" + Constants.MAVEN_STYLE_FAILURE_DEFAULT, message);\n    }",
    "comment": "Append message content in failure style.\nBy default, bold red\n\n@param message the message to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/layered-architecture/src/test/java/com/iluwatar/layers/entity/CakeTest.java",
    "type": "method",
    "name": "testSetId",
    "code": "void testSetId() {\n    final var cake = new Cake();\n    assertNull(cake.getId());\n\n    final var expectedId = 1234L;\n    cake.setId(expectedId);\n    assertEquals(expectedId, cake.getId());\n  }",
    "comment": "This class contains unit tests for the Cake class. It tests the functionality of setting and\ngetting the id, topping, and layers of a Cake object. It also tests the functionality of adding a\nlayer to a Cake object and converting a Cake object to a string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "getVariant",
    "code": "public final VariantVal getVariant(int rowId) {\n    if (isNullAt(rowId)) return null;\n    return new VariantVal(getChild(0).getBinary(rowId), getChild(1).getBinary(rowId));\n  }",
    "comment": "Returns the Variant value for {@code rowId}. Similar to {@link #getInterval(int)}, the\nimplementation must implement {@link #getChild(int)} and define 2 child vectors of binary type\nfor the Variant value and metadata."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ThrowableCollector.java",
    "type": "method",
    "name": "execute",
    "code": "public void execute(Executable executable) {\n\t\ttry {\n\t\t\texecutable.execute();\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(t);\n\t\t\tadd(t);\n\t\t}\n\t}",
    "comment": "Execute the supplied {@link Executable} and collect any {@link Throwable}\nthrown during the execution.\n\n<p>If the {@code Executable} throws an <em>unrecoverable</em> exception\n&mdash; for example, an {@link OutOfMemoryError} &mdash; this method will\nrethrow it.\n\n@param executable the {@code Executable} to execute\n@see #assertEmpty()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Double> create(double[][][][][][] data) {\n    return Tensor.create(data, Double.class);\n  }",
    "comment": "Creates a rank-6 tensor of {@code double} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "setProperty",
    "code": "static TableChange setProperty(String property, String value) {\n    return new SetProperty(property, value);\n  }",
    "comment": "Create a TableChange for setting a table property.\n<p>\nIf the property already exists, it will be replaced with the new value.\n\n@param property the property name\n@param value the new property value\n@return a TableChange for the addition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlob",
    "code": "public static Tensor fromBlob(long[] data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_ARRAY_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.length, shape);\n    final LongBuffer longBuffer = allocateLongBuffer((int) numel(shape));\n    longBuffer.put(data);\n    return new Tensor_int64(longBuffer, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.int64 with specified shape and data as array of\nlongs.\n\n@param data Tensor elements\n@param shape Tensor shape"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/App.java",
    "type": "method",
    "name": "App",
    "code": "private App() {\n    throw new UnsupportedOperationException(\"Utility class\");\n  }",
    "comment": "Clean Architecture ensures separation of concerns by organizing code, into layers and making it\nscalable and maintainable.\n\n<p>In the example there are Entities (Core Models)  Product, Cart, Order handle business logic.\nUse Cases (Application Logic)  ShoppingCartService manages operations like adding items and\ncheckout. Interfaces & Adapters  Repositories (CartRepository, OrderRepository) abstract data\nhandling, while controllers (CartController, OrderController) manage interactions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelProcessor.java",
    "type": "method",
    "name": "locateExistingPom",
    "code": "public Path locateExistingPom(Path projectDirectory) {\n        Path pom = modelParsers.stream()\n                .map(m -> m.locate(projectDirectory)\n                        .map(org.apache.maven.api.services.Source::getPath)\n                        .orElse(null))\n                .filter(Objects::nonNull)\n                .findFirst()\n                .orElseGet(() -> doLocateExistingPom(projectDirectory));\n        if (pom != null && !pom.equals(projectDirectory) && !pom.getParent().equals(projectDirectory)) {\n            throw new IllegalArgumentException(\"The POM found does not belong to the given directory: \" + pom);\n        }\n        return pom;\n    }",
    "comment": "Note that the ModelProcessor#locatePom never returns null\nwhile the ModelParser#locatePom needs to return an existing path!"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/lazy/LazyFluentIterable.java",
    "type": "method",
    "name": "first",
    "code": "public Optional<E> first() {\n    var resultIterator = first(1).iterator();\n    return resultIterator.hasNext() ? Optional.of(resultIterator.next()) : Optional.empty();\n  }",
    "comment": "Can be used to collect objects from the iteration. Is a terminating operation.\n\n@return an Optional containing the first object of this Iterable"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedRleValuesReader.java",
    "type": "method",
    "name": "skipValues",
    "code": "private void skipValues(int n) {\n    int left = n;\n    while (left > 0) {\n      if (this.currentCount == 0 && !readNextGroup()) break;\n      int num = Math.min(left, this.currentCount);\n      switch (mode) {\n        case RLE -> {}\n        case PACKED -> currentBufferIdx += num;\n      }\n      currentCount -= num;\n      left -= num;\n    }\n  }",
    "comment": "Skip `n` values from the current reader."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-dependency-resolution/src/main/java/org/apache/maven/plugin/coreit/AbstractDependencyMojo.java",
    "type": "method",
    "name": "stripLeadingDirs",
    "code": "private String stripLeadingDirs(String path, int significantPathLevels) {\n        String result;\n        if (significantPathLevels > 0) {\n            result = \"\";\n            File file = new File(path);\n            for (int i = 0; i < significantPathLevels && file != null; i++) {\n                if (result.length() > 0) {\n                    result = '/' + result;\n                }\n                result = file.getName() + result;\n                file = file.getParentFile();\n            }\n        } else {\n            result = path;\n        }\n        return result;\n    }",
    "comment": "NOTE: Always use forward slash here to ease platform-independent testing"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "handleUnknown",
    "code": "protected boolean handleUnknown(String opt) {\n      return true;\n    }",
    "comment": "Do not fail on unknown arguments, to support future arguments added to SparkSubmit."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/bloc/src/main/java/com/iluwatar/bloc/Bloc.java",
    "type": "method",
    "name": "emitState",
    "code": "private void emitState(State newState) {\n    currentState = newState;\n    for (StateListener<State> listener : listeners) {\n      listener.onStateChange(currentState);\n    }\n  }",
    "comment": "Emits a new state and notifies all registered listeners of the change.\n\n@param newState the new state to emit"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "substringSQL",
    "code": "public UTF8String substringSQL(int pos, int length) {\n    int len = numChars();\n    int start = (pos > 0) ? pos -1 : ((pos < 0) ? len + pos : 0);\n\n    int end;\n    if ((long) start + length > Integer.MAX_VALUE) {\n      end = Integer.MAX_VALUE;\n    } else if ((long) start + length < Integer.MIN_VALUE) {\n      end = Integer.MIN_VALUE;\n    } else {\n      end = start + length;\n    }\n    return substring(start, end);\n  }",
    "comment": "Information regarding the pos calculation:\nHive and SQL use one-based indexing for SUBSTR arguments but also accept zero and\nnegative indices for start positions. If a start index i is greater than 0, it\nrefers to element i-1 in the sequence. If a start index i is less than 0, it refers\nto the -ith element before the end of the sequence. If a start index i is 0, it\nrefers to the first element.\n`len + pos` does not overflow as `len >= 0`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-access-object/src/test/java/com/iluwatar/dao/DbCustomerDaoTest.java",
    "type": "method",
    "name": "addingACustomerFailsWithExceptionAsFeedbackToClient",
    "code": "void addingACustomerFailsWithExceptionAsFeedbackToClient() {\n      assertThrows(Exception.class, () -> dao.add(new Customer(2, \"Bernard\", \"Montgomery\")));\n    }",
    "comment": "setup a connection failure scenario.\n\n@throws SQLException if any error occurs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/NioReactor.java",
    "type": "method",
    "name": "changeOps",
    "code": "public void changeOps(SelectionKey key, int interestedOps) {\n    pendingCommands.add(new ChangeKeyOpsCommand(key, interestedOps));\n    selector.wakeup();\n  }",
    "comment": "Queues the change of operations request of a channel, which will change the interested\noperations of the channel sometime in the future.\n\n<p>This is a non-blocking method and does not guarantee that the operations have changed when\nthis method returns.\n\n@param key the key for which operations have to be changed.\n@param interestedOps the new interest operations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/saga/src/main/java/com/iluwatar/saga/orchestration/SagaOrchestrator.java",
    "type": "method",
    "name": "execute",
    "code": "public <K> Result execute(K value) {\n    state.cleanUp();\n    LOGGER.info(\" The new saga is about to start\");\n    var result = FINISHED;\n    K tempVal = value;\n\n    while (true) {\n      var next = state.current();\n      var ch = saga.get(next);\n      var srvOpt = sd.find(ch.name);\n\n      if (srvOpt.isEmpty()) {\n        state.directionToBack();\n        state.back();\n        continue;\n      }\n\n      var srv = srvOpt.get();\n\n      if (state.isForward()) {\n        var processRes = srv.process(tempVal);\n        if (processRes.isSuccess()) {\n          next = state.forward();\n          tempVal = (K) processRes.getValue();\n        } else {\n          state.directionToBack();\n        }\n      } else {\n        var rlRes = srv.rollback(tempVal);\n        if (rlRes.isSuccess()) {\n          next = state.back();\n          tempVal = (K) rlRes.getValue();\n        } else {\n          result = CRASHED;\n          next = state.back();\n        }\n      }\n\n      if (!saga.isPresent(next)) {\n        return state.isForward() ? FINISHED : result == CRASHED ? CRASHED : ROLLBACK;\n      }\n    }\n  }",
    "comment": "pipeline to execute saga process/story.\n\n@param value incoming value\n@param <K> type for incoming value\n@return result @see {@link Result}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getDictionaryIdAtIndex",
    "code": "public int getDictionaryIdAtIndex(int index) {\n    return handleObject(value, pos, (size, idSize, offsetSize, idStart, offsetStart, dataStart) -> {\n      if (index < 0 || index >= size) {\n        throw malformedVariant();\n      }\n      return readUnsigned(value, idStart + idSize * index, idSize);\n    });\n  }",
    "comment": "Get the dictionary ID for the object field at the `index` slot. Throws malformedVariant if\n`index` is out of the bound of `[0, objectSize())`.\nIt is only legal to call it when `getType()` is `Type.OBJECT`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "getSegments",
    "code": "public final List<Segment> getSegments() {\n\t\treturn unmodifiableList(this.segments);\n\t}",
    "comment": "Get the immutable list of {@linkplain Segment segments} that make up this\n{@code UniqueId}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/internal/StackTracesTest.java",
    "type": "method",
    "name": "FramesRemovedMatcher",
    "code": "public FramesRemovedMatcher(String suffix) {\n            this.suffix = suffix;\n        }",
    "comment": "A matcher that matches the line printed when frames were removed from a stack trace."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "setExtensionDependencyFilter",
    "code": "public void setExtensionDependencyFilter(DependencyFilter extensionDependencyFilter) {\n        this.extensionDependencyFilter = extensionDependencyFilter;\n    }",
    "comment": "Sets the artifact filter used to exclude shared extension artifacts from plugin realms. <strong>Warning:</strong>\nThis is an internal utility method that is only public for technical reasons, it is not part of the public API.\nIn particular, this method can be changed or deleted without prior notice and must not be used by plugins.\n\n@param extensionDependencyFilter The dependency filter to apply to plugins, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultTransport.java",
    "type": "method",
    "name": "getBytes",
    "code": "public Optional<byte[]> getBytes(URI relativeSource) {\n        try {\n            Path tempPath = null;\n            try {\n                tempPath = Files.createTempFile(\"transport-get\", \"tmp\");\n                if (get(relativeSource, tempPath)) {\n                    return Optional.of(Files.readAllBytes(tempPath));\n                }\n                return Optional.empty();\n            } finally {\n                if (tempPath != null) {\n                    Files.deleteIfExists(tempPath);\n                }\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }",
    "comment": "TODO: check file size and prevent OOM?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-settings-builder/src/main/java/org/apache/maven/settings/validation/SettingsValidator.java",
    "type": "method",
    "name": "validate",
    "code": "default void validate(Settings settings, boolean isProjectSettings, SettingsProblemCollector problems) {\n        validate(settings, problems);\n    }",
    "comment": "Validate the specified settings.\n\n@param settings The settings to validate, must not be {@code null}.\n@param isProjectSettings Boolean indicating if the validation is for project settings or user / global settings.\n@param problems The container used to collect problems that were encountered, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4091BadPluginDescriptorTest.java",
    "type": "method",
    "name": "MavenITmng4091BadPluginDescriptorTest",
    "code": "public MavenITmng4091BadPluginDescriptorTest() {\n        super(\"[2.1.0,)\"); // only test in 2.1.0+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-4091\">MNG-4091</a>:\nBad plugin descriptor error handling"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/RequestTrace.java",
    "type": "method",
    "name": "RequestTrace",
    "code": "public record RequestTrace(@Nullable String context, @Nullable RequestTrace parent, @Nullable Object data) {\n\n    public static final String CONTEXT_PLUGIN = \"plugin\";\n    public static final String CONTEXT_PROJECT = \"project\";\n    public static final String CONTEXT_BOOTSTRAP = \"bootstrap\";\n\n    public RequestTrace(RequestTrace parent, Object data) {\n        this(parent != null ? parent.context() : null, parent, data);\n    }\n}",
    "comment": "Represents a hierarchical trace of nested requests within a session, enabling correlation between\nsession events and their originating operations in the application code. The trace structure\nsupports the following key features:\n\n<ul>\n<li>Maintains parent-child relationships between requests to track operation nesting</li>\n<li>Carries contextual data describing the current request or operation</li>\n<li>Supports both internal session operations and client-provided trace information</li>\n</ul>\n\n<p>For internal session operations, the trace typically contains {@code *Request} objects\nthat represent the current processing state. Client code can also create traces with\napplication-specific data to provide context when invoking session methods.</p>\n\n<p>This trace information is particularly useful for:</p>\n<ul>\n<li>Debugging and troubleshooting request flows</li>\n<li>Audit logging of session operations</li>\n<li>Performance monitoring of nested operations</li>\n</ul>\n\n@param context The context identifier for this request trace, helping to identify the scope or purpose\nof the request. May be null if no specific context is needed.\n@param parent The parent request trace that led to this request, establishing the chain of nested\noperations. May be null for top-level requests.\n@param data Additional data associated with this request trace, typically containing the actual request\nobject being processed or any application-specific state information. May be null if no\nadditional data is needed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-followers/src/main/java/com/iluwatar/leaderfollowers/Worker.java",
    "type": "method",
    "name": "run",
    "code": "public void run() {\n    while (!Thread.interrupted()) {\n      try {\n        if (workCenter.getLeader() != null && !workCenter.getLeader().equals(this)) {\n          synchronized (workCenter) {\n            if (workCenter.getLeader() != null && !workCenter.getLeader().equals(this)) {\n              workCenter.wait();\n              continue;\n            }\n          }\n        }\n        final Task task = taskSet.getTask();\n        synchronized (workCenter) {\n          workCenter.removeWorker(this);\n          workCenter.promoteLeader();\n          workCenter.notifyAll();\n        }\n        taskHandler.handleTask(task);\n        LOGGER.info(\"The Worker with the ID \" + id + \" completed the task\");\n        workCenter.addWorker(this);\n      } catch (InterruptedException e) {\n        LOGGER.warn(\"Worker interrupted\");\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }",
    "comment": "The leader thread listens for task. When task arrives, it promotes one of the followers to be\nthe new leader. Then it handles the task and add himself back to work center."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Boolean> create(boolean[][][][][] data) {\n    return Tensor.create(data, Boolean.class);\n  }",
    "comment": "Creates a rank-5 tensor of {@code boolean} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java",
    "type": "method",
    "name": "create",
    "code": "static DiscoveryIssue create(Severity severity, String message) {\n\t\treturn builder(severity, message).build();\n\t}",
    "comment": "Create a new {@code DiscoveryIssue} with the supplied {@link Severity} and\n@param message the message of the issue; never blank\n@see #builder(Severity, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/master-worker/src/main/java/com/iluwatar/masterworker/system/systemworkers/Worker.java",
    "type": "method",
    "name": "setReceivedData",
    "code": "public void setReceivedData(Master m, Input<?> i) {\n    this.receivedData = i;\n  }",
    "comment": "check if we are ready to receive... if yes:"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/UserLocalArtifactRepository.java",
    "type": "method",
    "name": "find",
    "code": "public Artifact find(Artifact artifact) {\n        File artifactFile = new File(localRepository.getBasedir(), pathOf(artifact));\n\n        artifact.setFile(artifactFile);\n\n        return artifact;\n    }",
    "comment": "We need to set the file here or the resolver will fail with an NPE, not fully equipped to deal\nwith multiple local repository implementations yet."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/double-buffer/src/main/java/com/iluwatar/doublebuffer/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    final var scene = new Scene();\n    var drawPixels1 =\n        List.of(new MutablePair<>(1, 1), new MutablePair<>(5, 6), new MutablePair<>(3, 2));\n    scene.draw(drawPixels1);\n    var buffer1 = scene.getBuffer();\n    printBlackPixelCoordinate(buffer1);\n\n    var drawPixels2 = List.of(new MutablePair<>(3, 7), new MutablePair<>(6, 1));\n    scene.draw(drawPixels2);\n    var buffer2 = scene.getBuffer();\n    printBlackPixelCoordinate(buffer2);\n  }",
    "comment": "Program main entry point.\n\n@param args runtime arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/NumericHistogram.java",
    "type": "method",
    "name": "merge",
    "code": "public void merge(NumericHistogram other) {\n    if (other == null) {\n      return;\n    }\n\n    if (nbins == 0 || nusedbins == 0) {\n      // Our aggregation buffer has nothing in it, so just copy over 'other'\n      // by deserializing the ArrayList of (x,y) pairs into an array of Coord objects\n      nbins = other.nbins;\n      nusedbins = other.nusedbins;\n      bins = new ArrayList<>(nusedbins);\n      for (int i = 0; i < other.nusedbins; i += 1) {\n        Coord bin = new Coord();\n        bin.x = other.getBin(i).x;\n        bin.y = other.getBin(i).y;\n        bins.add(bin);\n      }\n    } else {\n      // The aggregation buffer already contains a partial histogram. Therefore, we need\n      // to merge histograms using Algorithm #2 from the Ben-Haim and Tom-Tov paper.\n\n      List<Coord> tmp_bins = new ArrayList<>(nusedbins + other.nusedbins);\n      // Copy all the histogram bins from us and 'other' into an overstuffed histogram\n      for (int i = 0; i < nusedbins; i++) {\n        Coord bin = new Coord();\n        bin.x = bins.get(i).x;\n        bin.y = bins.get(i).y;\n        tmp_bins.add(bin);\n      }\n      for (int j = 0; j < other.nusedbins; j += 1) {\n        Coord bin = new Coord();\n        bin.x = other.getBin(j).x;\n        bin.y = other.getBin(j).y;\n        tmp_bins.add(bin);\n      }\n      Collections.sort(tmp_bins);\n\n      // Now trim the overstuffed histogram down to the correct number of bins\n      bins = tmp_bins;\n      nusedbins += other.nusedbins;\n      trim();\n    }\n  }",
    "comment": "Takes a histogram and merges it with the current histogram object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createArrayType",
    "code": "public static ArrayType createArrayType(DataType elementType, boolean containsNull) {\n    if (elementType == null) {\n      throw new IllegalArgumentException(\"elementType should not be null.\");\n    }\n    return new ArrayType(elementType, containsNull);\n  }",
    "comment": "Creates an ArrayType by specifying the data type of elements ({@code elementType}) and\nwhether the array contains null values ({@code containsNull})."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/BorderedText.java",
    "type": "method",
    "name": "BorderedText",
    "code": "public BorderedText(final float textSize) {\n    this(Color.WHITE, Color.BLACK, textSize);\n  }",
    "comment": "Creates a left-aligned bordered text object with a white interior, and a black exterior with\nthe specified text size.\n\n@param textSize text size in pixels"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/metadata/MetadataGraph.java",
    "type": "method",
    "name": "setScopedVertices",
    "code": "public void setScopedVertices(boolean scopedVertices) {\n        this.scopedVertices = scopedVertices;\n\n        if (scopedVertices) {\n            versionedVertices = true;\n        }\n    }",
    "comment": "scoped graph is versioned by definition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "failed",
    "code": "public Executions failed() {\n\t\treturn new Executions(finishedExecutionsByStatus(Status.FAILED), this.category + \" Failed\");\n\t}",
    "comment": "Get the failed {@link Executions} contained in this {@code Executions} object.\n\n@return the filtered {@code Executions}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/serialized-lob/src/main/java/com/iluwatar/slob/lob/Animal.java",
    "type": "method",
    "name": "toXmlElement",
    "code": "public Element toXmlElement(Document xmlDoc) {\n    Element root = xmlDoc.createElement(Animal.class.getSimpleName());\n    root.setAttribute(\"name\", name);\n    for (Plant plant : plantsEaten) {\n      Element xmlElement = plant.toXmlElement(xmlDoc);\n      if (xmlElement != null) {\n        root.appendChild(xmlElement);\n      }\n    }\n    for (Animal animal : animalsEaten) {\n      Element xmlElement = animal.toXmlElement(xmlDoc);\n      if (xmlElement != null) {\n        root.appendChild(xmlElement);\n      }\n    }\n    xmlDoc.appendChild(root);\n    return (Element) xmlDoc.getFirstChild();\n  }",
    "comment": "Provides XML Representation of the Animal.\n\n@param xmlDoc object to which the XML representation is to be written to\n@return XML Element contain the Animal representation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/MethodSorter.java",
    "type": "method",
    "name": "getDeclaredMethods",
    "code": "public static Method[] getDeclaredMethods(Class<?> clazz) {\n        Comparator<Method> comparator = getSorter(clazz.getAnnotation(FixMethodOrder.class));\n\n        Method[] methods = clazz.getDeclaredMethods();\n        if (comparator != null) {\n            Arrays.sort(methods, comparator);\n        }\n\n        return methods;\n    }",
    "comment": "Gets declared methods of a class in a predictable order, unless @FixMethodOrder(MethodSorters.JVM) is specified.\n\nUsing the JVM order is unwise since the Java platform does not\nspecify any particular order, and in fact JDK 7 returns a more or less\nrandom order; well-written test code would not assume any order, but some\ndoes, and a predictable failure is better than a random failure on\ncertain platforms. By default, uses an unspecified but deterministic order.\n\n@param clazz a class\n@return same as {@link Class#getDeclaredMethods} but sorted\n@see <a href=\"http://bugs.sun.com/view_bug.do?bug_id=7023180\">JDK\n(non-)bug #7023180</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/main/java/com/example/android/observability/ui/UserViewModel.java",
    "type": "method",
    "name": "updateUserName",
    "code": "public Completable updateUserName(final String userName) {\n        // if there's no user, create a new user.\n        // if we already have a user, then, since the user object is immutable,\n        // create a new user, with the id of the previous user and the updated user name.\n        mUser = mUser == null\n                ? new User(userName)\n                : new User(mUser.getId(), userName);\n        return mDataSource.insertOrUpdateUser(mUser);\n    }",
    "comment": "Update the user name.\n\n@param userName the new user name\n@return a {@link Completable} that completes when the user name is updated"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/fpm/JavaPrefixSpanSuite.java",
    "type": "method",
    "name": "runPrefixSpanSaveLoad",
    "code": "public void runPrefixSpanSaveLoad() {\n    JavaRDD<List<List<Integer>>> sequences = jsc.parallelize(Arrays.asList(\n      Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3)),\n      Arrays.asList(Arrays.asList(1), Arrays.asList(3, 2), Arrays.asList(1, 2)),\n      Arrays.asList(Arrays.asList(1, 2), Arrays.asList(5)),\n      Arrays.asList(Arrays.asList(6))\n    ), 2);\n    PrefixSpan prefixSpan = new PrefixSpan()\n      .setMinSupport(0.5)\n      .setMaxPatternLength(5);\n    PrefixSpanModel<Integer> model = prefixSpan.run(sequences);\n\n    File tempDir = Utils.createTempDir(\n      System.getProperty(\"java.io.tmpdir\"), \"JavaPrefixSpanSuite\");\n    String outputPath = tempDir.getPath();\n\n    try {\n      model.save(spark.sparkContext(), outputPath);\n      @SuppressWarnings(\"unchecked\")\n      PrefixSpanModel<Integer> newModel =\n          (PrefixSpanModel<Integer>) PrefixSpanModel.load(spark.sparkContext(), outputPath);\n      JavaRDD<FreqSequence<Integer>> freqSeqs = newModel.freqSequences().toJavaRDD();\n      List<FreqSequence<Integer>> localFreqSeqs = freqSeqs.collect();\n      Assertions.assertEquals(5, localFreqSeqs.size());\n      for (PrefixSpan.FreqSequence<Integer> freqSeq : localFreqSeqs) {\n        List<List<Integer>> seq = freqSeq.javaSequence();\n        long freq = freqSeq.freq();\n      }\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n\n\n  }",
    "comment": "Check that each frequent sequence could be materialized."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "classRules",
    "code": "protected List<TestRule> classRules() {\n        ClassRuleCollector collector = new ClassRuleCollector();\n        testClass.collectAnnotatedMethodValues(null, ClassRule.class, TestRule.class, collector);\n        testClass.collectAnnotatedFieldValues(null, ClassRule.class, TestRule.class, collector);\n        return collector.getOrderedRules();\n    }",
    "comment": "@return the {@code ClassRule}s that can transform the block that runs\neach method in the tested class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/simple/SimpleFluentIterable.java",
    "type": "method",
    "name": "first",
    "code": "public final FluentIterable<E> first(int count) {\n    var iterator = iterator();\n    var currentCount = 0;\n    while (iterator.hasNext()) {\n      iterator.next();\n      if (currentCount >= count) {\n        iterator.remove();\n      }\n      currentCount++;\n    }\n    return this;\n  }",
    "comment": "Can be used to collect objects from the Iterable. Is a terminating operation.\n\n@param count defines the number of objects to return\n@return the same FluentIterable with a collection decimated to a maximum of 'count' first\nobjects."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Result.java",
    "type": "method",
    "name": "getAssumptionFailureCount",
    "code": "public int getAssumptionFailureCount() {\n        if (assumptionFailureCount == null) {\n            throw new UnsupportedOperationException(\n                    \"Result was serialized from a version of JUnit that doesn't support this method\");\n        }\n        return assumptionFailureCount.get();\n    }",
    "comment": "Returns the number of tests skipped because of an assumption failure\n\n@throws UnsupportedOperationException if the result was serialized in a version before JUnit 4.13\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/factory-kit/src/test/java/com/iluwatar/factorykit/factorykit/FactoryKitTest.java",
    "type": "method",
    "name": "testSpearWeapon",
    "code": "void testSpearWeapon() {\n    var weapon = factory.create(WeaponType.SPEAR);\n    verifyWeapon(weapon, Spear.class);\n  }",
    "comment": "Testing {@link WeaponFactory} to produce a SPEAR asserting that the Weapon is an instance of\n{@link Spear}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/simple/SimpleFluentIterable.java",
    "type": "method",
    "name": "first",
    "code": "public final Optional<E> first() {\n    var resultIterator = first(1).iterator();\n    return resultIterator.hasNext() ? Optional.of(resultIterator.next()) : Optional.empty();\n  }",
    "comment": "Can be used to collect objects from the Iterable. Is a terminating operation.\n\n@return an option of the first object of the Iterable"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/collection-pipeline/src/main/java/com/iluwatar/collectionpipeline/ImperativeProgramming.java",
    "type": "method",
    "name": "getSedanCarsOwnedSortedByDate",
    "code": "public static List<Car> getSedanCarsOwnedSortedByDate(List<Person> persons) {\n    List<Car> cars = new ArrayList<>();\n    for (Person person : persons) {\n      cars.addAll(person.cars());\n    }\n\n    List<Car> sedanCars = new ArrayList<>();\n    for (Car car : cars) {\n      if (Category.SEDAN.equals(car.category())) {\n        sedanCars.add(car);\n      }\n    }\n\n    sedanCars.sort(\n        new Comparator<Car>() {\n        });\n\n    return sedanCars;\n  }",
    "comment": "Method to get all Sedan cars belonging to a group of persons sorted by year of manufacture\nusing for loops.\n\n@param persons {@link List} of {@link Person} to be used\n@return {@link List} of {@link Car} to belonging to the group"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/main/java/com/iluwatar/health/check/DatabaseTransactionHealthIndicator.java",
    "type": "method",
    "name": "health",
    "code": "public Health health() {\n    LOGGER.info(\"Calling performCheck with timeout {}\", timeoutInSeconds);\n    Supplier<Health> dbTransactionCheck =\n        () -> {\n          try {\n            healthCheckRepository.performTestTransaction();\n            return Health.up().build();\n          } catch (Exception e) {\n            LOGGER.error(\"Database transaction health check failed\", e);\n            return Health.down(e).build();\n          }\n        };\n    try {\n      return asynchronousHealthChecker.performCheck(dbTransactionCheck, timeoutInSeconds).get();\n    } catch (InterruptedException | ExecutionException e) {\n      LOGGER.error(\"Database transaction health check timed out or was interrupted\", e);\n      Thread.currentThread().interrupt();\n      return Health.down(e).build();\n    }\n  }",
    "comment": "Performs a health check by attempting to perform a test transaction with retry support.\n\n@return the health status of the database transactions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoverySelectorIdentifier.java",
    "type": "method",
    "name": "parse",
    "code": "public static DiscoverySelectorIdentifier parse(String string) {\n\t\treturn StringUtils.splitIntoTwo(':', string).mapTwo( //\n\t\t\t() -> new PreconditionViolationException(\"Identifier string must be 'prefix:value', but was \" + string),\n\t\t\tDiscoverySelectorIdentifier::new //\n\t\t);\n\t}",
    "comment": "Parse the supplied string representation of a\n{@link DiscoverySelectorIdentifier} in the format {@code prefix:value}.\n\n@param string the string representation of a {@code DiscoverySelectorIdentifier}\n@return the parsed {@code DiscoverySelectorIdentifier}\n@throws PreconditionViolationException if the supplied string does not\nconform to the expected format"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java",
    "type": "method",
    "name": "streamsReturnedByProvidersAreClosedWhenCallingProvide",
    "code": "void streamsReturnedByProvidersAreClosedWhenCallingProvide() {\n\t\tvar extensionContext = getExtensionContextReturningSingleMethod(\n\t\t\tnew ArgumentsProviderWithCloseHandlerTestCase());\n\t\tthis.parameterizedTestExtension.supportsTestTemplate(extensionContext);\n\n\t\tvar stream = this.parameterizedTestExtension.provideTestTemplateInvocationContexts(extensionContext);\n\n\t\tassertFalse(streamWasClosed);\n\t\tstream.count();\n\t\tassertTrue(streamWasClosed);\n\t}",
    "comment": "we need to call supportsTestTemplate() first, because it creates and\nputs the ParameterizedTestMethodContext into the Store\ncause the stream to be evaluated"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelBuilder.java",
    "type": "method",
    "name": "derive",
    "code": "ModelBuilderSessionState derive(ModelBuilderRequest request) {\n            return derive(request, new DefaultModelBuilderResult(request, ProblemCollector.create(session)));\n        }",
    "comment": "Creates a new session, sharing cached datas and propagating errors."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/SessionData.java",
    "type": "method",
    "name": "Key",
    "code": "private Key(Class<T> type, Object id) {\n            this.type = type;\n            this.id = id;\n        }",
    "comment": "Key used to query the session data\n@param <T> the type of the object associated to this key"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/NumericHistogram.java",
    "type": "method",
    "name": "setUsedBins",
    "code": "public void setUsedBins(int nusedBins) {\n    this.nusedbins = nusedBins;\n  }",
    "comment": "Set the number of bins currently being used by the histogram."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/AbstractService.java",
    "type": "method",
    "name": "stop",
    "code": "public synchronized void stop() {\n    if (state == STATE.STOPPED ||\n        state == STATE.INITED ||\n        state == STATE.NOTINITED) {\n      // already stopped, or else it was never\n      // started (eg another service failing canceled startup)\n      return;\n    }\n    ensureCurrentState(STATE.STARTED);\n    changeState(STATE.STOPPED);\n    LOG.info(\"Service:{} is stopped.\", MDC.of(LogKeys.SERVICE_NAME$.MODULE$, getName()));\n  }",
    "comment": "{@inheritDoc}\n\n@throws IllegalStateException\nif the current service state does not permit\nthis action"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "getArtifactPath",
    "code": "public String getArtifactPath(String gid, String aid, String version, String ext, String classifier) {\n        if (classifier != null && classifier.isEmpty()) {\n            classifier = null;\n        }\n        if (\"maven-plugin\".equals(ext)) {\n            ext = \"jar\";\n        } else if (\"coreit-artifact\".equals(ext)) {\n            ext = \"jar\";\n            classifier = \"it\";\n        } else if (\"test-jar\".equals(ext)) {\n            ext = \"jar\";\n            classifier = \"tests\";\n        }\n\n        String gav;\n        if (classifier != null) {\n            gav = gid + \":\" + aid + \":\" + ext + \":\" + classifier + \":\" + version;\n        } else {\n            gav = gid + \":\" + aid + \":\" + ext + \":\" + version;\n        }\n        return getLocalRepository()\n                + File.separator\n                + executorTool.artifactPath(executorHelper.executorRequest(), gav, null);\n    }",
    "comment": "Returns the absolute path to the artifact denoted by groupId, artifactId, version, extension and classifier.\n\n@param gid        The groupId, must not be null.\n@param aid        The artifactId, must not be null.\n@param version    The version, must not be null.\n@param ext        The extension, must not be null.\n@param classifier The classifier, may be null to be omitted.\n@return the absolute path to the artifact denoted by groupId, artifactId, version, extension and classifier,\nnever null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Extract.java",
    "type": "method",
    "name": "Extract",
    "code": "public Extract(String field, Expression source) {\n    this.field = field;\n    this.source = source;\n  }",
    "comment": "Represent an extract function, which extracts and returns the value of a\nspecified datetime field from a datetime or interval value expression.\n<p>\nThe currently supported fields names following the ISO standard:\n<ol>\n<li> <code>SECOND</code> Since 3.4.0 </li>\n<li> <code>MINUTE</code> Since 3.4.0 </li>\n<li> <code>HOUR</code> Since 3.4.0 </li>\n<li> <code>MONTH</code> Since 3.4.0 </li>\n<li> <code>QUARTER</code> Since 3.4.0 </li>\n<li> <code>YEAR</code> Since 3.4.0 </li>\n<li> <code>DAY_OF_WEEK</code> Since 3.4.0 </li>\n<li> <code>DAY</code> Since 3.4.0 </li>\n<li> <code>DAY_OF_YEAR</code> Since 3.4.0 </li>\n<li> <code>WEEK</code> Since 3.4.0 </li>\n<li> <code>YEAR_OF_WEEK</code> Since 3.4.0 </li>\n</ol>\n\n@since 3.4.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegateImpl.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n    if (delegateHandle != INVALID_DELEGATE_HANDLE) {\n      deleteDelegate(delegateHandle);\n      delegateHandle = INVALID_DELEGATE_HANDLE;\n    }\n  }",
    "comment": "Frees TFLite resources in C runtime.\n\n<p>User is expected to call this method explicitly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/inference_interface/java/org/tensorflow/contrib/android/TensorFlowInferenceInterface.java",
    "type": "method",
    "name": "run",
    "code": "public void run(String[] outputNames, boolean enableStats) {\n    run(outputNames, enableStats, new String[] {});\n\n  public void close() {\n    closeFeeds();\n    closeFetches();\n    sess.close();\n    g.close();\n    if (runStats != null) {\n      runStats.close();\n    }\n    runStats = null;\n  }\n\n  @Override\n  protected void finalize() throws Throwable {\n    try {\n      close();\n    } finally {\n      super.finalize();\n    }\n  }\n\n  // Methods for taking a native Tensor and filling it with values from Java arrays.\n\n  public void feed(String inputName, boolean[] src, long... dims) {\n    byte[] b = new byte[src.length];\n\n    for (int i = 0; i < src.length; i++) {\n      b[i] = src[i] ? (byte) 1 : (byte) 0;\n    }\n\n    addFeed(inputName, Tensor.create(Boolean.class, dims, ByteBuffer.wrap(b)));\n  }\n\n  public void feed(String inputName, float[] src, long... dims) {\n    addFeed(inputName, Tensor.create(dims, FloatBuffer.wrap(src)));\n  }\n\n  public void feed(String inputName, int[] src, long... dims) {\n    addFeed(inputName, Tensor.create(dims, IntBuffer.wrap(src)));\n  }\n\n  public void feed(String inputName, long[] src, long... dims) {\n    addFeed(inputName, Tensor.create(dims, LongBuffer.wrap(src)));\n  }\n\n  public void feed(String inputName, double[] src, long... dims) {\n    addFeed(inputName, Tensor.create(dims, DoubleBuffer.wrap(src)));\n  }\n\n  public void feed(String inputName, byte[] src, long... dims) {\n    addFeed(inputName, Tensor.create(UInt8.class, dims, ByteBuffer.wrap(src)));\n  }\n\n  public void feedString(String inputName, byte[] src) {\n    addFeed(inputName, Tensors.create(src));\n  }\n\n  public void feedString(String inputName, byte[][] src) {\n    addFeed(inputName, Tensors.create(src));\n  }\n\n  // Methods for taking a native Tensor and filling it with src from Java native IO buffers.\n\n  public void feed(String inputName, FloatBuffer src, long... dims) {\n    addFeed(inputName, Tensor.create(dims, src));\n  }\n\n  public void feed(String inputName, IntBuffer src, long... dims) {\n    addFeed(inputName, Tensor.create(dims, src));\n  }\n\n  public void feed(String inputName, LongBuffer src, long... dims) {\n    addFeed(inputName, Tensor.create(dims, src));\n  }\n\n  public void feed(String inputName, DoubleBuffer src, long... dims) {\n    addFeed(inputName, Tensor.create(dims, src));\n  }\n\n  public void feed(String inputName, ByteBuffer src, long... dims) {\n    addFeed(inputName, Tensor.create(UInt8.class, dims, src));\n  }\n\n  public void fetch(String outputName, float[] dst) {\n    fetch(outputName, FloatBuffer.wrap(dst));\n  }\n\n  public void fetch(String outputName, int[] dst) {\n    fetch(outputName, IntBuffer.wrap(dst));\n  }\n\n  public void fetch(String outputName, long[] dst) {\n    fetch(outputName, LongBuffer.wrap(dst));\n  }\n\n  public void fetch(String outputName, double[] dst) {\n    fetch(outputName, DoubleBuffer.wrap(dst));\n  }\n\n  public void fetch(String outputName, byte[] dst) {\n    fetch(outputName, ByteBuffer.wrap(dst));\n  }\n\n  public void fetch(String outputName, FloatBuffer dst) {\n    getTensor(outputName).writeTo(dst);\n  }\n\n  public void fetch(String outputName, IntBuffer dst) {\n    getTensor(outputName).writeTo(dst);\n  }\n\n  public void fetch(String outputName, LongBuffer dst) {\n    getTensor(outputName).writeTo(dst);\n  }\n\n  public void fetch(String outputName, DoubleBuffer dst) {\n    getTensor(outputName).writeTo(dst);\n  }\n\n  public void fetch(String outputName, ByteBuffer dst) {\n    getTensor(outputName).writeTo(dst);\n  }\n\n  private void prepareNativeRuntime() {\n    Log.i(TAG, \"Checking to see if TensorFlow native methods are already loaded\");\n    try {\n      // Hack to see if the native libraries have been loaded.\n      new RunStats();\n      Log.i(TAG, \"TensorFlow native methods already loaded\");\n    } catch (UnsatisfiedLinkError e1) {\n      Log.i(\n          TAG, \"TensorFlow native methods not found, attempting to load via tensorflow_inference\");\n      try {\n        System.loadLibrary(\"tensorflow_inference\");\n        Log.i(TAG, \"Successfully loaded TensorFlow native methods (RunStats error may be ignored)\");\n      } catch (UnsatisfiedLinkError e2) {\n        throw new RuntimeException(\n            \"Native TF methods not found; check that the correct native\"\n                + \" libraries are present in the APK: \"\n                + e2);\n      }\n    }\n  }\n\n  private void loadGraph(byte[] graphDef, Graph g) throws IOException {\n    final long startMs = System.currentTimeMillis();\n\n    if (VERSION.SDK_INT >= 18) {\n      Trace.beginSection(\"importGraphDef\");\n    }\n\n    try {\n      g.importGraphDef(graphDef);\n    } catch (IllegalArgumentException e) {\n      throw new IOException(\"Not a valid TensorFlow Graph serialization: \" + e.getMessage());\n    }\n\n    if (VERSION.SDK_INT >= 18) {\n      Trace.endSection(); // importGraphDef.\n    }\n\n    final long endMs = System.currentTimeMillis();\n    Log.i(\n        TAG,\n        \"Model load took \" + (endMs - startMs) + \"ms, TensorFlow version: \" + TensorFlow.version());\n  }\n\n  private void addFeed(String inputName, Tensor<?> t) {\n    // The string format accepted by TensorFlowInferenceInterface is node_name[:output_index].\n    TensorId tid = TensorId.parse(inputName);\n    runner.feed(tid.name, tid.outputIndex, t);\n    feedNames.add(inputName);\n    feedTensors.add(t);\n  }\n\n  private static class TensorId {\n    String name;\n    int outputIndex;\n\n    // Parse output names into a TensorId.\n    //\n    // E.g., \"foo\" --> (\"foo\", 0), while \"foo:1\" --> (\"foo\", 1)\n    public static TensorId parse(String name) {\n      TensorId tid = new TensorId();\n      int colonIndex = name.lastIndexOf(':');\n      if (colonIndex < 0) {\n        tid.outputIndex = 0;\n        tid.name = name;\n        return tid;\n      }\n      try {\n        tid.outputIndex = Integer.parseInt(name.substring(colonIndex + 1));\n        tid.name = name.substring(0, colonIndex);\n      } catch (NumberFormatException e) {\n        tid.outputIndex = 0;\n        tid.name = name;\n      }\n      return tid;\n    }\n  }\n\n  private Tensor<?> getTensor(String outputName) {\n    int i = 0;\n    for (String n : fetchNames) {\n      if (n.equals(outputName)) {\n        return fetchTensors.get(i);\n      }\n      ++i;\n    }\n    throw new RuntimeException(\n        \"Node '\" + outputName + \"' was not provided to run(), so it cannot be read\");\n  }\n\n  private void closeFeeds() {\n    for (Tensor<?> t : feedTensors) {\n      t.close();\n    }\n    feedTensors.clear();\n    feedNames.clear();\n  }\n\n  private void closeFetches() {\n    for (Tensor<?> t : fetchTensors) {\n      t.close();\n    }\n    fetchTensors.clear();\n    fetchNames.clear();\n  }\n\n  // Immutable state.\n  private final String modelName;\n  private final Graph g;\n  private final Session sess;\n\n  // State reset on every call to run.\n  private Session.Runner runner;\n  private List<String> feedNames = new ArrayList<String>();\n  private List<Tensor<?>> feedTensors = new ArrayList<Tensor<?>>();\n  private List<String> fetchNames = new ArrayList<String>();\n  private List<Tensor<?>> fetchTensors = new ArrayList<Tensor<?>>();\n\n  // Mutable state.\n  private RunStats runStats;\n}",
    "comment": "Read from a Tensor named {@link outputName} and copy the contents into the <b>direct</b> and\n<b>native ordered</b> java.nio buffer {@link dst}. {@link dst} must have capacity greater than\nor equal to that of the source Tensor. This operation will not affect dst's content past the\nsource Tensor's size."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/PathModularization.java",
    "type": "method",
    "name": "PathModularization",
    "code": "private PathModularization() {\n        filename = \"(none)\";\n        descriptors = Collections.emptyMap();\n        isModuleHierarchy = false;\n    }",
    "comment": "Constructs an empty instance for non-modular dependencies.\n\n@see #NONE"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/bitset/BitSetMethods.java",
    "type": "method",
    "name": "isSet",
    "code": "public static boolean isSet(Object baseObject, long baseOffset, int index) {\n    assert index >= 0 : \"index (\" + index + \") should >= 0\";\n    final long mask = 1L << (index & 0x3f);  // mod 64 and shift\n    final long wordOffset = baseOffset + (index >> 6) * WORD_SIZE;\n    final long word = Platform.getLong(baseObject, wordOffset);\n    return (word & mask) != 0;\n  }",
    "comment": "Returns {@code true} if the bit is set at the specified index."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertNull",
    "code": "public static void assertNull(String message, Object object) {\n        Assert.assertNull(message, object);\n    }",
    "comment": "Asserts that an object is null.  If it is not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/master-worker/src/main/java/com/iluwatar/masterworker/ArrayUtilityMethods.java",
    "type": "method",
    "name": "createRandomIntMatrix",
    "code": "public static int[][] createRandomIntMatrix(int rows, int columns) {\n    var matrix = new int[rows][columns];\n    for (var i = 0; i < rows; i++) {\n      for (var j = 0; j < columns; j++) {\n        // filling cells in matrix\n        matrix[i][j] = RANDOM.nextInt(10);\n      }\n    }\n    return matrix;\n  }",
    "comment": "Method createRandomIntMatrix creates a random matrix of size @param rows and @param columns.\n\n@return it (int[][])."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/master-worker/src/main/java/com/iluwatar/masterworker/system/systemmaster/Master.java",
    "type": "method",
    "name": "receiveData",
    "code": "public void receiveData(Result<?> data, Worker w) {\n    collectResult(data, w.getWorkerId());\n  }",
    "comment": "check if we can receive... if yes:"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "isFixedLength",
    "code": "public static boolean isFixedLength(DataType dt) {\n    if (dt instanceof UserDefinedType udt) {\n      return isFixedLength(udt.sqlType());\n    }\n    PhysicalDataType pdt = PhysicalDataType.apply(dt);\n    if (pdt instanceof PhysicalDecimalType) {\n      return ((DecimalType) dt).precision() <= Decimal.MAX_LONG_DIGITS();\n    } else {\n      return pdt instanceof PhysicalPrimitiveType;\n    }\n  }",
    "comment": "Field types that hold fixed-length, store the value directly in an 8-byte word"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/money/src/test/java/com/iluwater/money/MoneyTest.java",
    "type": "method",
    "name": "testAddMoney_DifferentCurrency",
    "code": "void testAddMoney_DifferentCurrency() {\n    Money money1 = new Money(100.00, \"USD\");\n    Money money2 = new Money(50.25, \"EUR\");\n\n    assertThrows(CannotAddTwoCurrienciesException.class, () -> money1.addMoney(money2));\n  }",
    "comment": "Test adding two Money objects with the same currency\nTest adding two Money objects with different currencies"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testSimpleBagAdd",
    "code": "public void testSimpleBagAdd() {\n        IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n        assertEquals(expected, f14CHF.add(fMB1));\n    }",
    "comment": "[14 CHF] + {[12 CHF][7 USD]} == {[26 CHF][7 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getDouble",
    "code": "public double getDouble() {\n    return VariantUtil.getDouble(value, pos);\n  }",
    "comment": "Get a double value from the variant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/JavaAPISuite.java",
    "type": "method",
    "name": "compileSaveAsJavaAPI",
    "code": "private void compileSaveAsJavaAPI(JavaPairDStream<LongWritable,Text> pds) {\n    pds.saveAsNewAPIHadoopFiles(\n        \"\", \"\", LongWritable.class, Text.class,\n        org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat.class);\n    pds.saveAsHadoopFiles(\n        \"\", \"\", LongWritable.class, Text.class,\n        org.apache.hadoop.mapred.SequenceFileOutputFormat.class);\n    pds.saveAsNewAPIHadoopFiles(\n        \"\", \"\", LongWritable.class, Text.class,\n        (Class) org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat.class);\n    pds.saveAsHadoopFiles(\n        \"\", \"\", LongWritable.class, Text.class,\n        (Class) org.apache.hadoop.mapred.SequenceFileOutputFormat.class);\n  }",
    "comment": "SPARK-5795: no logic assertions, just testing that intended API invocations compile\nChecks that a previous common workaround for this API still compiles"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/Result.java",
    "type": "method",
    "name": "error",
    "code": "public static <T> Result<T> error(T model, Iterable<? extends ModelProblem> problems) {\n        return new Result<>(true, model, problems);\n    }",
    "comment": "Error with partial result and problems describing the cause\n\n@param model\n@param problems"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/pipeline/src/main/java/com/iluwatar/pipeline/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    /*\n     Suppose we wanted to pass through a String to a series of filtering stages and convert it\n     as a char array on the last stage.\n\n     - Stage handler 1 (pipe): Removing the alphabets, accepts a String input and returns the\n     processed String output. This will be used by the next handler as its input.\n\n     - Stage handler 2 (pipe): Removing the digits, accepts a String input and returns the\n     processed String output. This shall also be used by the last handler we have.\n\n     - Stage handler 3 (pipe): Converting the String input to a char array handler. We would\n     be returning a different type in here since that is what's specified by the requirement.\n     This means that at any stages along the pipeline, the handler can return any type of data\n     as long as it fulfills the requirements for the next handler's input.\n\n     Suppose we wanted to add another handler after ConvertToCharArrayHandler. That handler\n     then is expected to receive an input of char[] array since that is the type being returned\n     by the previous handler, ConvertToCharArrayHandler.\n    */\n    LOGGER.info(\"Creating pipeline\");\n    var filters =\n        new Pipeline<>(new RemoveAlphabetsHandler())\n            .addHandler(new RemoveDigitsHandler())\n            .addHandler(new ConvertToCharArrayHandler());\n    var input = \"GoYankees123!\";\n    LOGGER.info(\"Executing pipeline with input: {}\", input);\n    var output = filters.execute(input);\n    LOGGER.info(\"Pipeline output: {}\", output);\n  }",
    "comment": "Specify the initial input type for the first stage handler and the expected output type of the\nlast stage handler as type parameters for Pipeline. Use the fluent builder by calling\naddHandler to add more stage handlers on the pipeline."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/experimental/categories/JavadocTest.java",
    "type": "method",
    "name": "slowTests",
    "code": "public void slowTests() {\n        Result testResult= JUnitCore.runClasses(SlowTestSuite.class);\n        assertTrue(testResult.wasSuccessful());\n        assertThat(\"unexpected run count\", testResult.getRunCount(), is(2));\n        assertThat(\"unexpected failure count\", testResult.getFailureCount(), is(0));\n    }",
    "comment": "Will run A.b and B.d, but not A.a and A.c\nWill run A.c and B.d, but not A.b because it is not any of FastTests or SmokeTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlobUnsigned",
    "code": "public static Tensor fromBlobUnsigned(byte[] data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_ARRAY_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.length, shape);\n    final ByteBuffer byteBuffer = allocateByteBuffer((int) numel(shape));\n    byteBuffer.put(data);\n    return new Tensor_uint8(byteBuffer, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.uint8 with specified shape and data as array of\nbytes.\n\n@param data Tensor elements\n@param shape Tensor shape"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java",
    "type": "method",
    "name": "isAssignableTo",
    "code": "void isAssignableTo() {\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(String.class, Object.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(String.class, CharSequence.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(String.class, String.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(Integer.class, Number.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(Integer.class, Integer.class));\n\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(Object.class, String.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(CharSequence.class, String.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(Number.class, Integer.class));\n\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(int[].class, int[].class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(double[].class, double[].class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(double[].class, Object.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(String[].class, Object.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(String[].class, Object[].class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(String[].class, String[].class));\n\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(Integer.class, int.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(Boolean.class, boolean.class));\n\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(Void.class, void.class));\n\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(Integer.class, long.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(Float.class, double.class));\n\t\t\tassertTrue(ReflectionUtils.isAssignableTo(Byte.class, double.class));\n\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(Integer.class, Long.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(Float.class, Double.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(Byte.class, Double.class));\n\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(Integer.class, char.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(Long.class, byte.class));\n\t\t\tassertFalse(ReflectionUtils.isAssignableTo(Long.class, int.class));\n\t\t}",
    "comment": "Reference Types\nArrays\nWrappers to Primitives\nVoid to void\nWidening Conversions from Wrappers to Primitives\nWidening Conversions from Wrappers to Wrappers (not supported by Java)\nNarrowing Conversions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/TypeDescriptor.java",
    "type": "method",
    "name": "getDecimalDigits",
    "code": "public Integer getDecimalDigits() {\n    switch (this.type) {\n    case BOOLEAN_TYPE:\n    case TINYINT_TYPE:\n    case SMALLINT_TYPE:\n    case INT_TYPE:\n    case BIGINT_TYPE:\n      return 0;\n    case FLOAT_TYPE:\n      return 7;\n    case DOUBLE_TYPE:\n      return 15;\n    case DECIMAL_TYPE:\n      return typeQualifiers.getScale();\n    case TIMESTAMP_TYPE:\n      return 9;\n    default:\n      return null;\n    }\n  }",
    "comment": "The number of fractional digits for this type.\nNull is returned for data types where this is not applicable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClassSource.java",
    "type": "method",
    "name": "from",
    "code": "public static ClassSource from(String className) {\n\t\treturn new ClassSource(className);\n\t}",
    "comment": "Create a new {@code ClassSource} using the supplied class name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventStatistics.java",
    "type": "method",
    "name": "finished",
    "code": "public EventStatistics finished(long expected) {\n\t\tthis.executables.add(() -> assertEquals(expected, this.events.finished().count(), \"finished\"));\n\t\treturn this;\n\t}",
    "comment": "Specify the number of expected <em>finished</em> events.\n\n@param expected the expected number of events\n@return this {@code EventStatistics} for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/server/BlockPushNonFatalFailure.java",
    "type": "method",
    "name": "getReturnCode",
    "code": "public ReturnCode getReturnCode() {\n    Preconditions.checkNotNull(returnCode);\n    return returnCode;\n  }",
    "comment": "Ensure we do not invoke this method if returnCode is not set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "mergeCollapse",
    "code": "private void mergeCollapse() {\n      while (stackSize > 1) {\n        int n = stackSize - 2;\n        if (n > 0 && runLen[n-1] <= runLen[n] + runLen[n+1] ||\n            n > 1 && runLen[n-2] <= runLen[n] + runLen[n-1]) {\n          if (runLen[n - 1] < runLen[n + 1])\n            n--;\n        } else if (n < 0 || runLen[n] > runLen[n + 1]) {\n          break; // Invariant is established\n        }\n        mergeAt(n);\n      }\n    }",
    "comment": "Examines the stack of runs waiting to be merged and merges adjacent runs\nuntil the stack invariants are reestablished:\n\n1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1]\n2. runLen[i - 2] > runLen[i - 1]\n\nThis method is called each time a new run is pushed onto the stack,\nso the invariants are guaranteed to hold for i < stackSize upon\nentry to the method.\n\nThanks to Stijn de Gouw, Jurriaan Rot, Frank S. de Boer,\nRichard Bubel and Reiner Hahnle, this is fixed with respect to\nthe analysis in \"On the Worst-Case Complexity of TimSort\" by\nNicolas Auger, Vincent Jug, Cyril Nicaud, and Carine Pivoteau."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/KVTypeInfo.java",
    "type": "method",
    "name": "KVTypeInfo",
    "code": "public KVTypeInfo(Class<?> type) {\n    this.type = type;\n    this.accessors = new HashMap<>();\n    this.indices = new HashMap<>();\n\n    for (Field f : type.getDeclaredFields()) {\n      KVIndex idx = f.getAnnotation(KVIndex.class);\n      if (idx != null) {\n        checkIndex(idx, indices);\n        f.setAccessible(true);\n        indices.put(idx.value(), idx);\n        accessors.put(idx.value(), new FieldAccessor(f));\n      }\n    }\n\n    for (Method m : type.getDeclaredMethods()) {\n      KVIndex idx = m.getAnnotation(KVIndex.class);\n      if (idx != null) {\n        checkIndex(idx, indices);\n        Preconditions.checkArgument(m.getParameterCount() == 0,\n          \"Annotated method %s::%s should not have any parameters.\", type.getName(), m.getName());\n        m.setAccessible(true);\n        indices.put(idx.value(), idx);\n        accessors.put(idx.value(), new MethodAccessor(m));\n      }\n    }\n\n    Preconditions.checkArgument(indices.containsKey(KVIndex.NATURAL_INDEX_NAME),\n        \"No natural index defined for type %s.\", type.getName());\n\n    for (KVIndex idx : indices.values()) {\n      if (!idx.parent().isEmpty()) {\n        KVIndex parent = indices.get(idx.parent());\n        Preconditions.checkArgument(parent != null,\n          \"Cannot find parent %s of index %s.\", idx.parent(), idx.value());\n        Preconditions.checkArgument(parent.parent().isEmpty(),\n          \"Parent index %s of index %s cannot be itself a child index.\", idx.parent(), idx.value());\n      }\n    }\n  }",
    "comment": "Wrapper around types managed in a KVStore, providing easy access to their indexed fields."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/test/java/org/tensorflow/lite/InterpreterTestHelper.java",
    "type": "method",
    "name": "executionPlanLength",
    "code": "public static int executionPlanLength(Interpreter interpreter) {\n    return interpreter.getExecutionPlanLength();\n  }",
    "comment": "Returns the number of nodes in the execution plan that are invoked per inference.\n\n<p>WARNING: This is an experimental API and subject to change."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaGradientBoostingRegressionExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf sparkConf = new SparkConf()\n      .setAppName(\"JavaGradientBoostedTreesRegressionExample\");\n    JavaSparkContext jsc = new JavaSparkContext(sparkConf);\n    String datapath = \"data/mllib/sample_libsvm_data.txt\";\n    JavaRDD<LabeledPoint> data = MLUtils.loadLibSVMFile(jsc.sc(), datapath).toJavaRDD();\n    JavaRDD<LabeledPoint>[] splits = data.randomSplit(new double[]{0.7, 0.3});\n    System.out.println(\"Test Mean Squared Error: \" + testMSE);\n    System.out.println(\"Learned regression GBT model:\\n\" + model.toDebugString());\n\n    model.save(jsc.sc(), \"target/tmp/myGradientBoostingRegressionModel\");\n    GradientBoostedTreesModel sameModel = GradientBoostedTreesModel.load(jsc.sc(),\n      \"target/tmp/myGradientBoostingRegressionModel\");\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file.\nSplit the data into training and test sets (30% held out for testing)\nSave and load model\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-driven-architecture/src/main/java/com/iluwatar/eda/event/AbstractEvent.java",
    "type": "method",
    "name": "getType",
    "code": "public Class<? extends Event> getType() {\n    return getClass();\n  }",
    "comment": "Returns the event type as a {@link Class} object In this example, this method is used by the\n{@link EventDispatcher} to dispatch events depending on their type.\n\n@return the AbstractEvent type as a {@link Class}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/ClassifierActivity.java",
    "type": "method",
    "name": "processImage",
    "code": "protected void processImage() {\n    rgbFrameBitmap.setPixels(getRgbBytes(), 0, previewWidth, 0, 0, previewWidth, previewHeight);\n    final Canvas canvas = new Canvas(croppedBitmap);\n    canvas.drawBitmap(rgbFrameBitmap, frameToCropTransform, null);\n\n    if (SAVE_PREVIEW_BITMAP) {\n      ImageUtils.saveBitmap(croppedBitmap);\n    }\n    runInBackground(\n        new Runnable() {\n            resultsView.setResults(results);\n            requestRender();\n            readyForNextImage();\n          }\n        });",
    "comment": "For examining the actual TF input."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedParquetRecordReader.java",
    "type": "method",
    "name": "enableReturningBatches",
    "code": "public void enableReturningBatches() {\n    returnColumnarBatch = true;\n  }",
    "comment": "Can be called before any rows are returned to enable returning columnar batches directly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/SavedModelBundle.java",
    "type": "method",
    "name": "loader",
    "code": "public static Loader loader(String exportDir) {\n    return new Loader(exportDir);\n  }",
    "comment": "Load a saved model.\n\n<p/>Returns a <code>Loader</code> object that can set configuration options before actually\nloading the model,\n\n@param exportDir the directory path containing a saved model."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "isResolved",
    "code": "public boolean isResolved() {\n\t\t\treturn this != UNRESOLVED;\n\t\t}",
    "comment": "Whether this resolution contains matches or selectors.\n\n@return {@code true} if this resolution contains matches or selectors"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "contains",
    "code": "public Object contains(List<Object> args) {\n        if (args.size() != 2) {\n            throw new IllegalArgumentException(\"contains function requires exactly two arguments\");\n        }\n        String s = ConditionParser.toString(args.get(0));\n        String substring = ConditionParser.toString(args.get(1));\n        return s.contains(substring);\n    }",
    "comment": "Checks if a string contains a given substring.\n\n@param args A list containing two strings: the main string and the substring to check\n@return true if the main string contains the substring, false otherwise\n@throws IllegalArgumentException if the number of arguments is not exactly two"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/manipulation/Ordering.java",
    "type": "method",
    "name": "shuffledBy",
    "code": "public static Ordering shuffledBy(final Random random) {\n        return new Ordering() {\n\n            @Override\n            protected List<Description> orderItems(Collection<Description> descriptions) {\n                List<Description> shuffled = new ArrayList<Description>(descriptions);\n                Collections.shuffle(shuffled, random);\n                return shuffled;\n            }\n        };\n    }",
    "comment": "Creates an {@link Ordering} that shuffles the items using the given\n{@link Random} instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TagFilter.java",
    "type": "method",
    "name": "includeMatching",
    "code": "private static PostDiscoveryFilter includeMatching(List<String> tagExpressions) {\n\t\tSupplier<String> inclusionReason = () -> inclusionReasonExpressionSatisfy(tagExpressions);\n\t\tSupplier<String> exclusionReason = () -> exclusionReasonExpressionNotSatisfy(tagExpressions);\n\t\tList<TagExpression> parsedTagExpressions = parseAll(tagExpressions);\n\t\treturn descriptor -> {\n\t\t\tSet<TestTag> tags = descriptor.getTags();\n\t\t\tboolean included = parsedTagExpressions.stream().anyMatch(expression -> expression.evaluate(tags));\n\n\t\t\treturn FilterResult.includedIf(included, inclusionReason, exclusionReason);\n\t\t};\n\t}",
    "comment": "Create an <em>exclude</em> filter based on the supplied tag expressions.\n\n<p>Containers and tests will only be executed if their tags do\n<em>not</em> match any of the supplied <em>excluded</em> tag expressions.\n\n@param tagExpressions the excluded tag expressions; never {@code null} or\nempty\n@throws PreconditionViolationException if the supplied tag expressions\narray is {@code null} or empty, or if any individual tag expression is\nnot syntactically valid\n@see #excludeTags(String...)\n@see TestTag#isValid(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-executor/src/main/java/org/apache/maven/cling/executor/internal/ToolboxTool.java",
    "type": "method",
    "name": "ToolboxTool",
    "code": "public ToolboxTool(ExecutorHelper helper) {\n        this.helper = requireNonNull(helper);\n    }",
    "comment": "{@link ExecutorTool} implementation based on Maveniverse Toolbox. It uses Toolbox mojos to implement all the\nrequired operations.\n\n@see <a href=\"https://github.com/maveniverse/toolbox\">Maveniverse Toolbox</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTimeoutPreemptively",
    "code": "public static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier, String message) {\n\t\treturn AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, supplier, message);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code supplier}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>See the {@linkplain Assertions Preemptive Timeouts} section of the\nclass-level Javadoc for further details.\n\n<p>If the assertion passes then the {@code supplier}'s result is returned.\n\n<p>Fails with the supplied failure {@code message}.\n\n@see #assertTimeoutPreemptively(Duration, Executable)\n@see #assertTimeoutPreemptively(Duration, Executable, String)\n@see #assertTimeoutPreemptively(Duration, Executable, Supplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeout(Duration, Executable, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/MethodFilter.java",
    "type": "method",
    "name": "includeMethodNamePatterns",
    "code": "static MethodFilter includeMethodNamePatterns(List<String> patterns) {\n\t\treturn includeMethodNamePatterns(patterns.toArray(new String[0]));\n\t}",
    "comment": "Create a new <em>include</em> {@link MethodFilter} based on the\n@see Class#getName()\n@see Method#getName()\n@see #includeMethodNamePatterns(String...)\n@see #excludeMethodNamePatterns(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tooling-support-tests/src/main/java/platform/tooling/support/Helper.java",
    "type": "method",
    "name": "getJavaHome",
    "code": "public static Optional<Path> getJavaHome(int version) {\n\t\tvar sources = Stream.of( //\n\t\t\tSystem.getProperty(\"java.home.\" + version), //\n\t\t\tSystem.getProperty(\"java.\" + version), //\n\t\t\tSystem.getProperty(\"jdk.home.\" + version), //\n\t\t\tSystem.getProperty(\"jdk.\" + version), //\n\t\t\tSystem.getenv(\"JAVA_HOME_\" + version), //\n\t\t\tSystem.getenv(\"JAVA_\" + version), //\n\t\t\tSystem.getenv(\"JDK\" + version) //\n\t\t);\n\t\treturn sources.filter(Objects::nonNull).findFirst().map(Path::of);\n\t}",
    "comment": "First, try various system sources..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java",
    "type": "method",
    "name": "runParquetSchemaMergingExample",
    "code": "private static void runParquetSchemaMergingExample(SparkSession spark) {\n    List<Square> squares = new ArrayList<>();\n    for (int value = 1; value <= 5; value++) {\n      Square square = new Square();\n      square.setValue(value);\n      square.setSquare(value * value);\n      squares.add(square);\n    }\n\n    Dataset<Row> squaresDF = spark.createDataFrame(squares, Square.class);\n    squaresDF.write().parquet(\"data/test_table/key=1\");\n\n    List<Cube> cubes = new ArrayList<>();\n    for (int value = 6; value <= 10; value++) {\n      Cube cube = new Cube();\n      cube.setValue(value);\n      cube.setCube(value * value * value);\n      cubes.add(cube);\n    }\n\n    Dataset<Row> cubesDF = spark.createDataFrame(cubes, Cube.class);\n    cubesDF.write().parquet(\"data/test_table/key=2\");\n\n    Dataset<Row> mergedDF = spark.read().option(\"mergeSchema\", true).parquet(\"data/test_table\");\n    mergedDF.printSchema();\n\n  }",
    "comment": "$example on:schema_merging$\nCreate a simple DataFrame, store into a partition directory\nCreate another DataFrame in a new partition directory,\nadding a new column and dropping an existing column\nRead the partitioned table\nThe final schema consists of all 3 columns in the Parquet files together\nwith the partitioning column appeared in the partition directory paths\nroot\n|-- value: int (nullable = true)\n|-- square: int (nullable = true)\n|-- cube: int (nullable = true)\n|-- key: int (nullable = true)\n$example off:schema_merging$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/test/java/com/iluwatar/identitymap/IdentityMapTest.java",
    "type": "method",
    "name": "addToMap",
    "code": "void addToMap() {\n    IdentityMap idMap = new IdentityMap();\n    Person person1 = new Person(11, \"Michael\", 27304159);\n    Person person2 = new Person(22, \"John\", 42273631);\n    Person person3 = new Person(33, \"Arthur\", 27489171);\n    Person person4 = new Person(44, \"Finn\", 20499078);\n    Person person5 = new Person(11, \"Michael\", 40599078);\n    idMap.addPerson(person1);\n    idMap.addPerson(person2);\n    idMap.addPerson(person3);\n    idMap.addPerson(person4);\n    idMap.addPerson(person5);\n    Assertions.assertEquals(4, idMap.size(), \"Size of the map is incorrect\");\n    Assertions.assertEquals(\n        27304159, idMap.getPerson(11).getPhoneNum(), \"Incorrect return value for phone number\");\n  }",
    "comment": "new instance of an identity map(not connected to any DB here)\nDummy person instances\nid already in map\nAll records go into identity map\nTest no duplicate in our Map.\nTest record not updated by add method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlob",
    "code": "public static Tensor fromBlob(byte[] data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_ARRAY_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.length, shape);\n    final ByteBuffer byteBuffer = allocateByteBuffer((int) numel(shape));\n    byteBuffer.put(data);\n    return new Tensor_int8(byteBuffer, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.int8 with specified shape and data as array of\nbytes.\n\n@param data Tensor elements\n@param shape Tensor shape"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfig.java",
    "type": "method",
    "name": "addLauncherSessionListeners",
    "code": "public Builder addLauncherSessionListeners(LauncherSessionListener... listeners) {\n\t\t\tPreconditions.notNull(listeners, \"LauncherSessionListener array must not be null\");\n\t\t\tPreconditions.containsNoNullElements(listeners,\n\t\t\t\t\"LauncherSessionListener array must not contain null elements\");\n\t\t\tCollections.addAll(this.sessionListeners, listeners);\n\t\t\treturn this;\n\t\t}",
    "comment": "Add all of the supplied launcher session listeners to the configuration.\n\n@param listeners additional launcher session listeners to register;\nnever {@code null} or containing {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/multiton/src/test/java/com/iluwatar/multiton/NazgulEnumTest.java",
    "type": "method",
    "name": "testTheSameObjectIsReturnedWithMultipleCalls",
    "code": "void testTheSameObjectIsReturnedWithMultipleCalls(NazgulEnum nazgulEnum) {\n    var instance1 = nazgulEnum;\n    var instance2 = nazgulEnum;\n    var instance3 = nazgulEnum;\n    assertSame(instance1, instance2);\n    assertSame(instance1, instance3);\n    assertSame(instance2, instance3);\n  }",
    "comment": "Check that multiple calls to any one of the instances in the multiton returns only that one\nparticular instance, and do that for all instances in multiton"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/logging/Slf4jLogger.java",
    "type": "method",
    "name": "getChildLogger",
    "code": "public Logger getChildLogger(String name) {\n        return null;\n    }",
    "comment": "<b>Warning</b>: ignored (always return <code>null</code>)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/Interpreter.java",
    "type": "method",
    "name": "setAllowFp16PrecisionForFp32",
    "code": "public Options setAllowFp16PrecisionForFp32(boolean allow) {\n      this.allowFp16PrecisionForFp32 = allow;\n      return this;\n    }",
    "comment": "Sets whether to allow float16 precision for FP32 calculation when possible. Defaults to false\n(disallow).\n\n@deprecated Prefer using <a\nhref=\"https://github.com/tensorflow/tensorflow/blob/5dc7f6981fdaf74c8c5be41f393df705841fb7c5/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java#L127\">NnApiDelegate.Options#setAllowFp16(boolean\nenable)</a>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/project/artifact/MavenMetadataSource.java",
    "type": "method",
    "name": "if",
    "code": "if (model != null) {\n            pomArtifact = artifact;\n            dependencies = model.getDependencies();\n            DependencyManagement dependencyManagement = model.getDependencyManagement();\n            managedDependencies = dependencyManagement == null ? null : dependencyManagement.getDependencies();\n            MavenSession session = legacySupport.getSession();\n            if (session != null) {\n                if (session.getProjects() != null) {\n                    pomRepositories = session.getProjects().stream()\n                            .filter(p -> artifact.equals(p.getArtifact()))\n                            .map(MavenProject::getRemoteArtifactRepositories)\n                            .findFirst()\n                            .orElseGet(() -> getRepositoriesFromModel(repositorySession, model));\n                } else {\n                    pomRepositories = getRepositoriesFromModel(repositorySession, model);\n                }\n            } else {\n                pomRepositories = new ArrayList<>();\n            }\n        } else if (artifact instanceof ArtifactWithDependencies artifactWithDependencies) {\n            pomArtifact = artifact;\n\n            dependencies = artifactWithDependencies.getDependencies();\n\n            managedDependencies = artifactWithDependencies.getManagedDependencies();\n        } else {\n            ProjectRelocation rel = retrieveRelocatedProject(artifact, request);\n\n            if (rel == null) {\n                return null;\n            }\n\n            pomArtifact = rel.pomArtifact;\n\n            relocatedArtifact = rel.relocatedArtifact;\n\n            if (rel.project == null) {\n                dependencies = Collections.emptyList();\n            } else {\n                dependencies = rel.project.getModel().getDependencies();\n\n                DependencyManagement depMgmt = rel.project.getModel().getDependencyManagement();\n                managedDependencies = (depMgmt != null) ? depMgmt.getDependencies() : null;\n\n                pomRepositories = rel.project.getRemoteArtifactRepositories();\n            }\n        }",
    "comment": "When this happens we have a Maven 1.x POM, or some invalid POM.\nIt should have never found its way into Maven 2.x repository, but it did."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/ImageUtils.java",
    "type": "method",
    "name": "getYUVByteSize",
    "code": "public static int getYUVByteSize(final int width, final int height) {\n    // The luminance plane requires 1 byte per pixel.\n    final int ySize = width * height;\n\n    // The UV plane works on 2x2 blocks, so dimensions with odd size must be rounded up.\n    // Each 2x2 block takes 2 bytes to encode, one each for U and V.\n    final int uvSize = ((width + 1) / 2) * ((height + 1) / 2) * 2;\n\n    return ySize + uvSize;\n  }",
    "comment": "Utility method to compute the allocated size in bytes of a YUV420SP image\nof the given dimensions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(float unexpected, float actual, float delta) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, delta);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal\nwithin the given {@code delta}.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(float unexpected, float actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/ExpectedException.java",
    "type": "method",
    "name": "reportMissingExceptionWithMessage",
    "code": "public ExpectedException reportMissingExceptionWithMessage(String message) {\n        missingExceptionMessage = message;\n        return this;\n    }",
    "comment": "Specifies the failure message for tests that are expected to throw\nan exception but do not throw any. You can use a {@code %s} placeholder for\nthe description of the expected exception. E.g. \"Test doesn't throw %s.\"\nwill fail with the error message\n\"Test doesn't throw an instance of foo.\".\n\n@param message exception detail message\n@return the rule itself"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionProfileActivator.java",
    "type": "method",
    "name": "presentInConfig",
    "code": "public boolean presentInConfig(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        Activation activation = profile.getActivation();\n        if (activation == null) {\n            return false;\n        }\n        return activation.getCondition() != null && !activation.getCondition().isBlank();\n    }",
    "comment": "Checks if the condition is present in the profile's configuration.\n\n@param profile The profile to check\n@param context The context in which the profile is being evaluated\n@param problems A collector for any problems encountered during evaluation\n@return true if the condition is present and not blank, false otherwise"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-di/src/main/java/org/apache/maven/di/tool/DiIndexProcessor.java",
    "type": "method",
    "name": "logError",
    "code": "private void logError(String message, Exception e) {\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        e.printStackTrace(pw);\n        String stackTrace = sw.toString();\n\n        String fullMessage = message + \"\\n\" + \"Exception: \"\n                + e.getClass().getName() + \"\\n\" + \"Message: \"\n                + e.getMessage() + \"\\n\" + \"Stack trace:\\n\"\n                + stackTrace;\n\n        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, fullMessage);\n    }",
    "comment": "Logs an error message with exception details to the annotation processing environment.\n\n@param message the error message\n@param e the exception that occurred"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/demo/app/src/main/java/com/example/android/tflitecamerademo/Camera2BasicFragment.java",
    "type": "method",
    "name": "configureTransform",
    "code": "private void configureTransform(int viewWidth, int viewHeight) {\n    Activity activity = getActivity();\n    if (null == textureView || null == previewSize || null == activity) {\n      return;\n    }\n    int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\n    Matrix matrix = new Matrix();\n    RectF viewRect = new RectF(0, 0, viewWidth, viewHeight);\n    RectF bufferRect = new RectF(0, 0, previewSize.getHeight(), previewSize.getWidth());\n    float centerX = viewRect.centerX();\n    float centerY = viewRect.centerY();\n    if (Surface.ROTATION_90 == rotation || Surface.ROTATION_270 == rotation) {\n      bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY());\n      matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);\n      float scale =\n          Math.max(\n              (float) viewHeight / previewSize.getHeight(),\n              (float) viewWidth / previewSize.getWidth());\n      matrix.postScale(scale, scale, centerX, centerY);\n      matrix.postRotate(90 * (rotation - 2), centerX, centerY);\n    } else if (Surface.ROTATION_180 == rotation) {\n      matrix.postRotate(180, centerX, centerY);\n    }\n    textureView.setTransform(matrix);\n  }",
    "comment": "Configures the necessary {@link android.graphics.Matrix} transformation to `textureView`. This\nmethod should be called after the camera preview size is determined in setUpCameraOutputs and\nalso the size of `textureView` is fixed.\n\n@param viewWidth The width of `textureView`\n@param viewHeight The height of `textureView`"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Double> create(Scope scope, double[][] data) {\n    return create(scope, data, Double.class);\n  }",
    "comment": "Creates a rank-2 constant of {@code double} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/LruCache.java",
    "type": "method",
    "name": "LruCache",
    "code": "public LruCache(int maxSize) {\n\t\tsuper(maxSize + 1, 1, true);\n\t\tthis.maxSize = maxSize;\n\t}",
    "comment": "Create a new LRU cache that maintains at most the supplied number of\nentries.\n\n<p>For optimal use of the internal data structures, you should pick a\nnumber that's one below a power of two since this is based on a\n{@link java.util.HashMap} and the eldest entry will be evicted after\nadding the entry that increases the {@linkplain #size() size} to be above\n{@code maxSize}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/guarded-suspension/src/main/java/com/iluwatar/guarded/suspension/GuardedQueue.java",
    "type": "method",
    "name": "GuardedQueue",
    "code": "public GuardedQueue() {\n    this.sourceList = new LinkedList<>();\n  }",
    "comment": "Guarded Queue is an implementation for Guarded Suspension Pattern Guarded suspension pattern is\nused to handle a situation when you want to execute a method on an object which is not in a\nproper state.\n\n@see <a\nhref=\"http://java-design-patterns.com/patterns/guarded-suspension/\">http://java-design-patterns.com/patterns/guarded-suspension/</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/combinator/src/main/java/com/iluwatar/combinator/Finders.java",
    "type": "method",
    "name": "filteredFinder",
    "code": "public static Finder filteredFinder(String query, String... excludeQueries) {\n    var finder = Finder.contains(query);\n\n    for (String q : excludeQueries) {\n      finder = finder.not(Finder.contains(q));\n    }\n    return finder;\n  }",
    "comment": "Filtered finder looking a query with excluded queries as well.\n\n@param query to find\n@param excludeQueries to exclude\n@return new finder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/ComparisonFailure.java",
    "type": "method",
    "name": "getMessage",
    "code": "public String getMessage() {\n        return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n    }",
    "comment": "Returns \"...\" in place of common prefix and \"...\" in place of common suffix between expected and actual.\n\n@see Throwable#getMessage()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/KVStoreView.java",
    "type": "method",
    "name": "skip",
    "code": "public KVStoreView<T> skip(long n) {\n    this.skip = n;\n    return this;\n  }",
    "comment": "Skips a number of elements at the start of iteration. Skipped elements are not accounted\nwhen using {@link #max(long)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/crypto/GcmTransportCipher.java",
    "type": "method",
    "name": "if",
    "code": "while (bytesRead < bytesToRead) {\n                long readableBytes = getReadableBytes();\n                int readLimit =\n                        (int) Math.min(readableBytes, plaintextBuffer.remaining());\n                if (plaintextMessage instanceof ByteBuf byteBuf) {\n                    Preconditions.checkState(0 == plaintextBuffer.position());\n                    plaintextBuffer.limit(readLimit);\n                    byteBuf.readBytes(plaintextBuffer);\n                    Preconditions.checkState(readLimit == plaintextBuffer.position());\n                } else if (plaintextMessage instanceof FileRegion fileRegion) {\n                    ByteBufferWriteableChannel plaintextChannel =\n                            new ByteBufferWriteableChannel(plaintextBuffer);\n                    long plaintextRead =\n                            fileRegion.transferTo(plaintextChannel, fileRegion.transferred());\n                    if (plaintextRead < readLimit) {\n                        return transferredThisCall;\n                    }\n                }\n                boolean lastSegment = getReadableBytes() == 0;\n                plaintextBuffer.flip();\n                bytesRead += plaintextBuffer.remaining();\n                ciphertextBuffer.clear();\n                try {\n                    encrypter.encryptSegment(plaintextBuffer, lastSegment, ciphertextBuffer);\n                } catch (GeneralSecurityException e) {\n                    throw new IllegalStateException(\"GeneralSecurityException from encrypter\", e);\n                }\n                plaintextBuffer.clear();\n                ciphertextBuffer.flip();\n                int written = target.write(ciphertextBuffer);\n                transferredThisCall += written;\n                this.transferred += written;\n                if (ciphertextBuffer.hasRemaining()) {\n                    return transferredThisCall;\n                }\n            }",
    "comment": "If we do not read a full plaintext buffer or all the available\nreadable bytes, return what was transferred this call.\nIn this case, upon calling transferTo again, it will try to write the\nremaining ciphertext buffer in the conditional before this loop."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createDayTimeIntervalType",
    "code": "public static DayTimeIntervalType createDayTimeIntervalType() {\n    return DayTimeIntervalType$.MODULE$.DEFAULT();\n  }",
    "comment": "Creates a DayTimeIntervalType with default start and end fields: interval day to second."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/Phase.java",
    "type": "method",
    "name": "setId",
    "code": "public void setId(String id) {\n        this.id = id;\n    } // -- void setId( String )",
    "comment": "Set the ID of this phase, e.g.,\n<code>generate-sources</code>.\n\n@param id a id object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelProblemUtils.java",
    "type": "method",
    "name": "formatLocation",
    "code": "public static String formatLocation(ModelProblem problem, String projectId) {\n        StringBuilder buffer = new StringBuilder(256);\n\n        if (!problem.getModelId().equals(projectId)) {\n            buffer.append(problem.getModelId());\n\n            if (problem.getSource().length() > 0) {\n                if (buffer.length() > 0) {\n                    buffer.append(\", \");\n                }\n                buffer.append(problem.getSource());\n            }\n        }\n\n        if (problem.getLineNumber() > 0) {\n            if (buffer.length() > 0) {\n                buffer.append(\", \");\n            }\n            buffer.append(\"line \").append(problem.getLineNumber());\n        }\n\n        if (problem.getColumnNumber() > 0) {\n            if (buffer.length() > 0) {\n                buffer.append(\", \");\n            }\n            buffer.append(\"column \").append(problem.getColumnNumber());\n        }\n\n        return buffer.toString();\n    }",
    "comment": "Creates a string with all location details for the specified model problem. If the project identifier is\nprovided, the generated location will omit the model id and source information and only give line/column\ninformation for problems originating directly from this POM.\n\n@param problem The problem whose location should be formatted, must not be {@code null}.\n@param projectId The {@code <groupId>:<artifactId>:<version>} of the corresponding project, may be {@code null}\nto force output of model id and source.\n@return The formatted problem location or an empty string if unknown, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryOrchestrator.java",
    "type": "method",
    "name": "discover",
    "code": "public LauncherDiscoveryResult discover(LauncherDiscoveryRequest request, Phase phase, UniqueId parentId) {\n\t\tLauncherDiscoveryResult result = discover(request, phase, parentId::appendEngine);\n\t\treturn result.withRetainedEngines(TestDescriptor::containsTests);\n\t}",
    "comment": "Discovers tests for the supplied request in the supplied phase using the\nconfigured test engines to be used by the suite engine.\n\n<p>Applies {@linkplain org.junit.platform.launcher.EngineFilter engine\nfilters} and {@linkplain PostDiscoveryFilter post-discovery filters} and\n{@linkplain TestDescriptor#prune() prunes} the resulting test tree.\n\n<p>Note: The test descriptors in the discovery result can safely be used\nas non-root descriptors. Engine-test descriptor entries are pruned from\nthe returned result. As such execution by\n{@link EngineExecutionOrchestrator} will not emit start or emit events\nfor engines without tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/DependencyResolverRequest.java",
    "type": "method",
    "name": "dependency",
    "code": "public DependencyResolverRequestBuilder dependency(@Nullable DependencyCoordinates dependency) {\n            if (dependency != null) {\n                if (this.dependencies.isEmpty()) {\n                    this.dependencies = new ArrayList<>();\n                }\n                this.dependencies.add(dependency);\n            }\n            return this;\n        }",
    "comment": "Adds the specified direct dependency.\n\n@param dependency the dependency to add, may be {@code null}\n@return this request for chaining, never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "setInactiveProfileIds",
    "code": "public DefaultProfileActivationContext setInactiveProfileIds(List<String> inactiveProfileIds) {\n        if (inactiveProfileIds != null) {\n            this.inactiveProfileIds = Collections.unmodifiableList(inactiveProfileIds);\n        } else {\n            this.inactiveProfileIds = Collections.emptyList();\n        }\n\n        return this;\n    }",
    "comment": "Sets the identifiers of those profiles that should be deactivated by explicit demand.\n\n@param inactiveProfileIds The identifiers of those profiles to deactivate, may be {@code null}.\n@return This context, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(double unexpected, double actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-di/src/main/java/org/apache/maven/di/tool/DiIndexProcessor.java",
    "type": "method",
    "name": "getFullClassName",
    "code": "private String getFullClassName(TypeElement typeElement) {\n        StringBuilder className = new StringBuilder(typeElement.getSimpleName());\n        Element enclosingElement = typeElement.getEnclosingElement();\n\n        while (enclosingElement instanceof TypeElement enclosingTypeElement) {\n            className.insert(0, \"$\").insert(0, enclosingTypeElement.getSimpleName());\n            enclosingElement = enclosingElement.getEnclosingElement();\n        }\n\n        if (enclosingElement instanceof PackageElement packageElement) {\n            className.insert(0, \".\").insert(0, packageElement.getQualifiedName());\n        }\n\n        return className.toString();\n    }",
    "comment": "Gets the fully qualified class name for a type element, including handling inner classes.\n\n@param typeElement the type element to get the class name for\n@return the fully qualified class name"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/Main.java",
    "type": "method",
    "name": "prepareWindowsCommand",
    "code": "private static String prepareWindowsCommand(List<String> cmd, Map<String, String> childEnv) {\n    StringBuilder cmdline = new StringBuilder();\n    for (Map.Entry<String, String> e : childEnv.entrySet()) {\n      cmdline.append(String.format(\"set %s=%s\", e.getKey(), e.getValue()));\n      cmdline.append(\" && \");\n    }\n    for (String arg : cmd) {\n      cmdline.append(quoteForBatchScript(arg));\n      cmdline.append(\" \");\n    }\n    return cmdline.toString();\n  }",
    "comment": "Prepare a command line for execution from a Windows batch script.\n\nThe method quotes all arguments so that spaces are handled as expected. Quotes within arguments\nare \"double quoted\" (which is batch for escaping a quote). This page has more details about\nquoting and other batch script fun stuff: http://ss64.com/nt/syntax-esc.html"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getEnabledSourceRoots",
    "code": "public Stream<SourceRoot> getEnabledSourceRoots(ProjectScope scope, Language language) {\n        Stream<SourceRoot> stream = sources.stream().filter(SourceRoot::enabled);\n        if (scope != null) {\n            stream = stream.filter(source -> scope.equals(source.scope()));\n        }\n        if (language != null) {\n            stream = stream.filter(source -> language.equals(source.language()));\n        }\n        return stream;\n    }",
    "comment": "{@return all enabled sources that provide files in the given language for the given scope}.\nIf the given scope is {@code null}, then this method returns the enabled sources for all scopes.\nIf the given language is {@code null}, then this method returns the enabled sources for all languages.\nThe iteration order is the order in which the sources are declared in the POM file.\n\n@param scope the scope of the sources to return, or {@code null} for all scopes\n@param language the language of the sources to return, or {@code null} for all languages\n\n@see #addSourceRoot(ProjectScope, Language, Path)\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "skippedWithReason",
    "code": "public static Condition<Event> skippedWithReason(String expectedReason) {\n\t\treturn allOf(type(SKIPPED), reason(expectedReason));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link EventType#SKIPPED} and the\n{@linkplain Event#getPayload() reason} is equal to the supplied\n{@link String}.\n\n@see #reason(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "setScheduler",
    "code": "public void setScheduler(RunnerScheduler scheduler) {\n        this.scheduler = scheduler;\n    }",
    "comment": "Sets a scheduler that determines the order and parallelization\nof children.  Highly experimental feature that may change."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/io/ModelParseException.java",
    "type": "method",
    "name": "ModelParseException",
    "code": "public ModelParseException(String message, int lineNumber, int columnNumber, Throwable cause) {\n        super(message);\n        initCause(cause);\n        this.lineNumber = lineNumber;\n        this.columnNumber = columnNumber;\n    }",
    "comment": "Creates a new parser exception with the specified details.\n\n@param message The error message, may be {@code null}.\n@param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.\n@param columnNumber The one-based index of the column containing the error or {@code -1} if unknown.\n@param cause The nested cause of this error, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultNode.java",
    "type": "method",
    "name": "asString",
    "code": "public String asString() {\n        StringBuilder sb = new StringBuilder();\n        DependencyNode node = getDependencyNode();\n        org.eclipse.aether.artifact.Artifact artifact = node.getArtifact();\n        org.eclipse.aether.graph.Dependency dependency = node.getDependency();\n\n        if (!verbose) {\n            sb.append(artifact);\n            if (dependency != null) {\n                sb.append(\":\").append(dependency.getScope());\n            }\n            return sb.toString();\n        }\n\n        List<String> details = new ArrayList<>();\n        org.eclipse.aether.graph.DependencyNode winner =\n                (org.eclipse.aether.graph.DependencyNode) node.getData().get(ConflictResolver.NODE_DATA_WINNER);\n        String winnerVersion = winner != null ? winner.getArtifact().getBaseVersion() : null;\n        boolean included = (winnerVersion == null);\n\n        String preManagedVersion = DependencyManagerUtils.getPremanagedVersion(node);\n        if (preManagedVersion != null) {\n            details.add(\"version managed from \" + preManagedVersion);\n        }\n\n        String preManagedScope = DependencyManagerUtils.getPremanagedScope(node);\n        if (preManagedScope != null) {\n            details.add(\"scope managed from \" + preManagedScope);\n        }\n\n        String originalScope = (String) node.getData().get(ConflictResolver.NODE_DATA_ORIGINAL_SCOPE);\n        if (originalScope != null && !originalScope.equals(dependency.getScope())) {\n            details.add(\"scope updated from \" + originalScope);\n        }\n\n        if (!included) {\n            if (Objects.equals(winnerVersion, artifact.getVersion())) {\n                details.add(\"omitted for duplicate\");\n            } else {\n                details.add(\"omitted for conflict with \" + winnerVersion);\n            }\n        }\n\n        if (!included) {\n            sb.append('(');\n        }\n\n        sb.append(artifact);\n        if (dependency != null) {\n            sb.append(\":\").append(dependency.getScope());\n        }\n\n        if (!details.isEmpty()) {\n            sb.append(included ? \" (\" : \" - \");\n            appendDetails(sb, details);\n            if (included) {\n                sb.append(')');\n            }\n        }\n\n        if (!included) {\n            sb.append(')');\n        }\n\n        return sb.toString();\n    }",
    "comment": "Returns a detailed string representation of this dependency node.\n<p>\nWhen verbose mode is disabled, returns the basic string representation in the format:\n{@code groupId:artifactId:version[:scope]}\n<p>\nWhen verbose mode is enabled, additional details are included with the following format:\n<ul>\n<li>For included dependencies: {@code groupId:artifactId:version[:scope] (details)}</li>\n<li>For omitted dependencies: {@code (groupId:artifactId:version[:scope] - details)}</li>\n</ul>\nWhere details may include:\n<ul>\n<li>Version management information (if the version was managed from a different version)</li>\n<li>Scope management information (if the scope was managed from a different scope)</li>\n<li>Scope updates (if the scope was changed during resolution)</li>\n<li>Conflict resolution information (if the dependency was omitted due to conflicts or duplicates)</li>\n</ul>\n\n@return a string representation of this dependency node with optional detailed information"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "nextValue",
    "code": "public boolean nextValue() {\n      assert isDefined;\n      long nextAddr = Platform.getLong(baseObject, valueOffset + valueLength);\n      if (nextAddr == 0) {\n        return false;\n      } else {\n        updateAddressesAndSizes(nextAddr);\n        return true;\n      }\n    }",
    "comment": "Find the next pair that has the same key as current one."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java",
    "type": "method",
    "name": "build",
    "code": "public FailOnTimeout build(Statement statement) {\n            if (statement == null) {\n                throw new NullPointerException(\"statement cannot be null\");\n            }\n            return new FailOnTimeout(this, statement);\n        }",
    "comment": "Builds a {@link FailOnTimeout} instance using the values in this builder,\nwrapping the given statement.\n\n@param statement statement to build"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/queue-based-load-leveling/src/main/java/com/iluwatar/queue/load/leveling/TaskGenerator.java",
    "type": "method",
    "name": "TaskGenerator",
    "code": "public TaskGenerator(MessageQueue msgQueue, int msgCount) {\n    this.msgQueue = msgQueue;\n    this.msgCount = msgCount;\n  }",
    "comment": "TaskGenerator class. Each TaskGenerator thread will be a Worker which submits messages to the\nqueue. We need to mention the message count for each of the TaskGenerator threads."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/builders/AnnotatedBuilder.java",
    "type": "method",
    "name": "AnnotatedBuilder",
    "code": "public AnnotatedBuilder(RunnerBuilder suiteBuilder) {\n        this.suiteBuilder = suiteBuilder;\n    }",
    "comment": "The {@code AnnotatedBuilder} is a strategy for constructing runners for test class that have been annotated with the\n{@code @RunWith} annotation. All tests within this class will be executed using the runner that was specified within\nthe annotation.\n<p>\nIf a runner supports inner member classes, the member classes will inherit the runner from the enclosing class, e.g.:\n<pre>\n&#064;RunWith(MyRunner.class)\npublic class MyTest {\n// some tests might go here\n\npublic class MyMemberClass {\n&#064;Test\npublic void thisTestRunsWith_MyRunner() {\n// some test logic\n}\n\n// some more tests might go here\n}\n\n&#064;RunWith(AnotherRunner.class)\npublic class AnotherMemberClass {\n// some tests might go here\n\npublic class DeepInnerClass {\n&#064;Test\npublic void thisTestRunsWith_AnotherRunner() {\n// some test logic\n}\n}\n\npublic class DeepInheritedClass extends SuperTest {\n&#064;Test\npublic void thisTestRunsWith_SuperRunner() {\n// some test logic\n}\n}\n}\n}\n\n&#064;RunWith(SuperRunner.class)\npublic class SuperTest {\n// some tests might go here\n}\n</pre>\nThe key points to note here are:\n<ul>\n<li>If there is no RunWith annotation, no runner will be created.</li>\n<li>The resolve step is inside-out, e.g. the closest RunWith annotation wins</li>\n<li>RunWith annotations are inherited and work as if the class was annotated itself.</li>\n<li>The default JUnit runner does not support inner member classes,\nso this is only valid for custom runners that support inner member classes.</li>\n<li>Custom runners with support for inner classes may or may not support RunWith annotations for member\nclasses. Please refer to the custom runner documentation.</li>\n</ul>\n\n@see org.junit.runners.model.RunnerBuilder\n@see org.junit.runner.RunWith\n@since 4.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/test/java/org/tensorflow/TestUtil.java",
    "type": "method",
    "name": "flattenedNumElements",
    "code": "public static int flattenedNumElements(Object array) {\n    int count = 0;\n    for (int i = 0; i < Array.getLength(array); i++) {\n      Object e = Array.get(array, i);\n      if (!e.getClass().isArray()) {\n        count += 1;\n      } else {\n        count += flattenedNumElements(e);\n      }\n    }\n    return count;\n  }",
    "comment": "Counts the total number of elements in an ND array.\n\n@param array the array to count the elements of\n@return the number of elements"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/BloomFilter.java",
    "type": "method",
    "name": "create",
    "code": "public static BloomFilter create(long expectedNumItems, long numBits) {\n    if (expectedNumItems <= 0) {\n      throw new IllegalArgumentException(\"Expected insertions must be positive\");\n    }\n\n    if (numBits <= 0) {\n      throw new IllegalArgumentException(\"Number of bits must be positive\");\n    }\n\n    return new BloomFilterImpl(optimalNumOfHashFunctions(expectedNumItems, numBits), numBits);\n  }",
    "comment": "Creates a {@link BloomFilter} with given {@code expectedNumItems} and {@code numBits}, it will\npick an optimal {@code numHashFunctions} which can minimize {@code fpp} for the bloom filter."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetDictionary.java",
    "type": "method",
    "name": "decodeToLong",
    "code": "public long decodeToLong(int id) {\n    if (needTransform) {\n      return Integer.toUnsignedLong(dictionary.decodeToInt(id));\n    } else {\n      return dictionary.decodeToLong(id);\n    }\n  }",
    "comment": "For unsigned int32, it stores as dictionary encoded signed int32 in Parquet\nwhenever dictionary is available.\nHere we lazily decode it to the original signed int value then convert to long(unit32)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/bully/BullyMessageManager.java",
    "type": "method",
    "name": "findElectionCandidateInstanceList",
    "code": "private List<Integer> findElectionCandidateInstanceList(int currentId) {\n    return instanceMap.keySet().stream()\n        .filter((i) -> i < currentId && instanceMap.get(i).isAlive())\n        .toList();\n  }",
    "comment": "Find all the alive instances with smaller ID than current instance.\n\n@param currentId ID of current instance.\n@return ID list of all the candidate instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/connector/catalog/IdentityColumnSpec.java",
    "type": "method",
    "name": "IdentityColumnSpec",
    "code": "public IdentityColumnSpec(long start, long step, boolean allowExplicitInsert) {\n      this.start = start;\n      this.step = step;\n      this.allowExplicitInsert = allowExplicitInsert;\n    }",
    "comment": "Creates an identity column specification.\n@param start the start value to generate the identity values\n@param step the step value to generate the identity values\n@param allowExplicitInsert whether the identity column allows explicit insertion of values"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerSession.java",
    "type": "method",
    "name": "getDefault",
    "code": "public static EagerSession getDefault() {\n    if (defaultSession == null) {\n      synchronized (EagerSession.class) {\n        if (defaultSession == null) {\n          defaultSession = options().build();\n        }\n      }\n    }\n    return defaultSession;\n  }",
    "comment": "Returns the default eager session\n\n<p>Once initialized, the default eager session remains active for the whole life of the\napplication, as opposed to sessions obtained from {@link #create()} or {@link Options#build()}\nwhich should be closed after their usage.\n\n<p>The default set of {@link Options} is used to initialize the session on the first call. To\noverride this behavior, it is possible to invoke {@link #initDefault(Options)} with a different\nset of options prior to this first call.\n\n<p>Example usage:\n\n<pre>{@code\n// Starting to build eager operations using default session, by calling\n// EagerSession.getDefault() implicitly\nOps tf = Ops.create();\n\n// Starting to build eager operations using default session, by calling\n// EagerSession.getDefault() explicitly\nOps tf = Ops.create(EagerSession.getDefault());\n}</pre>\n\n@return default eager session\n@see #initDefault"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/BaseParser.java",
    "type": "method",
    "name": "mayOverrideDirectorySystemProperty",
    "code": "protected void mayOverrideDirectorySystemProperty(LocalContext context, String javaSystemPropertyKey, Path value) {\n        String valueString = value.toString();\n        if (!Objects.equals(System.getProperty(javaSystemPropertyKey), valueString)) {\n            context.systemPropertiesOverrides.put(javaSystemPropertyKey, valueString);\n        }\n    }",
    "comment": "This method is needed to \"align\" values used later on for interpolations and path calculations.\nWe enforce \"canonical\" paths, so IF key and canonical path value disagree, let override it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/Money.java",
    "type": "method",
    "name": "Money",
    "code": "public Money(int amount, String currency) {\n        fAmount = amount;\n        fCurrency = currency;\n    }",
    "comment": "Constructs a money from the given amount and currency."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "discover",
    "code": "public static EngineDiscoveryResults discover(String engineId, LauncherDiscoveryRequest discoveryRequest) {\n\t\tPreconditions.notBlank(engineId, \"TestEngine ID must not be null or blank\");\n\t\treturn discover(loadTestEngine(engineId.trim()), discoveryRequest);\n\t}",
    "comment": "Discover tests for the given {@link LauncherDiscoveryRequest} using the\n{@link TestEngine} with the supplied ID.\n\n<p>The {@code TestEngine} will be loaded via Java's {@link ServiceLoader}\nmechanism, analogous to the manner in which test engines are loaded in\nthe JUnit Platform Launcher API.\n\n<p>{@link org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder}\nprovides a convenient way to build an appropriate discovery request to\nsupply to this method. As an alternative, consider using\n{@link #engine(TestEngine)} for a more fluent API.\n\n@param engineId the ID of the {@code TestEngine} to use; must not be\n{@code null} or <em>blank</em>\n@param discoveryRequest the {@code LauncherDiscoveryRequest} to use\n@return the results of the discovery\n@throws PreconditionViolationException for invalid arguments or if the\n{@code TestEngine} with the supplied ID cannot be loaded\n@since 1.13\n@see #discover(TestEngine, LauncherDiscoveryRequest)\n@see #engine(String)\n@see #engine(TestEngine)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/InMemoryStore.java",
    "type": "method",
    "name": "copyElements",
    "code": "private List<T> copyElements() {\n      if (parent != null) {\n        Comparable<Object> parentKey = asKey(parent);\n        if (hasNaturalParentIndex && naturalParentIndexName.equals(ti.getParentIndexName(index))) {\n          // If there is a parent index for the natural index and the parent of `index` happens to\n          // be it, Spark can use the `parentToChildrenMap` to get the related natural keys, and\n          // then copy them from `data`.\n          NaturalKeys children = parentToChildrenMap.getOrDefault(parentKey, new NaturalKeys());\n          ArrayList<T> elements = new ArrayList<>();\n          for (Comparable<Object> naturalKey : children.keySet()) {\n            data.computeIfPresent(naturalKey, (k, v) -> {\n              elements.add(v);\n              return v;\n            });\n          }\n          return elements;\n        } else {\n          // Go through all the values in `data` and collect all the objects has certain parent\n          // value. This can be slow when there is a large number of entries in `data`.\n          KVTypeInfo.Accessor parentGetter = ti.getParentAccessor(index);\n          Preconditions.checkArgument(parentGetter != null, \"Parent filter for non-child index.\");\n          return data.values().stream()\n            .filter(e -> compare(e, parentGetter, parentKey) == 0)\n            .collect(Collectors.toList());\n        }\n      } else {\n        return new ArrayList<>(data.values());\n      }\n    }",
    "comment": "Create a copy of the input elements, filtering the values for child indices if needed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/util/V2ExpressionSQLBuilder.java",
    "type": "method",
    "name": "visitStartsWith",
    "code": "protected String visitStartsWith(String l, String r) {\n    String value = r.substring(1, r.length() - 1);\n    return l + \" LIKE '\" + escapeSpecialCharsForLikePattern(value) + \"%' ESCAPE '\\\\'\";\n  }",
    "comment": "Remove quotes at the beginning and end.\ne.g. converts \"'str'\" to \"str\"."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/support/ModifierSupportTests.java",
    "type": "method",
    "name": "isPublicPreconditions",
    "code": "void isPublicPreconditions() {\n\t\tassertPreconditionViolationException(\"Class\", () -> ModifierSupport.isPublic((Class<?>) null));\n\t\tassertPreconditionViolationException(\"Member\", () -> ModifierSupport.isPublic((Member) null));\n\t}",
    "comment": "Unit tests for {@link ModifierSupport}.\n\n@since 1.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/JavaPageRank.java",
    "type": "method",
    "name": "showWarning",
    "code": "static void showWarning() {\n    String warning = \"WARN: This is a naive implementation of PageRank \" +\n            \"and is given as an example! \\n\" +\n            \"Please use the PageRank implementation found in \" +\n            \"org.apache.spark.graphx.lib.PageRank for more conventional use.\";\n    System.err.println(warning);\n  }",
    "comment": "Computes the PageRank of URLs from an input file. Input file should\nbe in format of:\nURL         neighbor URL\nURL         neighbor URL\nURL         neighbor URL\n...\nwhere URL and their neighbors are separated by space(s).\n\nThis is an example implementation for learning how to use Spark. For more conventional use,\nplease refer to org.apache.spark.graphx.lib.PageRank\n\nExample Usage:\n<pre>\nbin/run-example JavaPageRank data/mllib/pagerank_data.txt 10\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getDecimal",
    "code": "public BigDecimal getDecimal() {\n    return VariantUtil.getDecimal(value, pos);\n  }",
    "comment": "Get a decimal value from the variant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/ShuffleExternalSorter.java",
    "type": "method",
    "name": "cleanupResources",
    "code": "public void cleanupResources() {\n    freeMemory();\n    if (inMemSorter != null) {\n      inMemSorter.free();\n      inMemSorter = null;\n    }\n    for (SpillInfo spill : spills) {\n      if (spill.file.exists() && !spill.file.delete()) {\n        logger.error(\"Unable to delete spill file {}\",\n          MDC.of(LogKeys.PATH$.MODULE$, spill.file.getPath()));\n      }\n    }\n  }",
    "comment": "Force all memory and spill files to be deleted; called by shuffle error-handling code."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-locality/src/test/java/com/iluwatar/data/locality/ApplicationTest.java",
    "type": "method",
    "name": "shouldExecuteGameApplicationWithoutException",
    "code": "void shouldExecuteGameApplicationWithoutException() {\n    assertDoesNotThrow(() -> Application.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link Application#main(String[])} throws an\nexception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/condition/DisabledIfEnvironmentVariableCondition.java",
    "type": "method",
    "name": "evaluate",
    "code": "protected ConditionEvaluationResult evaluate(DisabledIfEnvironmentVariable annotation) {\n\t\tString name = annotation.named().trim();\n\t\tString regex = annotation.matches();\n\t\tPreconditions.notBlank(name, () -> \"The 'named' attribute must not be blank in \" + annotation);\n\t\tPreconditions.notBlank(regex, () -> \"The 'matches' attribute must not be blank in \" + annotation);\n\t\tString actual = getEnvironmentVariable(name);\n\n\t\tif (actual == null) {\n\t\t\treturn enabled(format(\"Environment variable [%s] does not exist\", name));\n\t\t}\n\n\t\tif (actual.matches(regex)) {\n\t\t\treturn disabled(format(\"Environment variable [%s] with value [%s] matches regular expression [%s]\", name,\n\t\t\t\tactual, regex), annotation.disabledReason());\n\t\t}\n\t\treturn enabled(format(\"Environment variable [%s] with value [%s] does not match regular expression [%s]\", name,\n\t\t\tactual, regex));\n\t}",
    "comment": "Nothing to match against?\nelse"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/execution/sort/RecordBinaryComparatorSuite.java",
    "type": "method",
    "name": "beforeEach",
    "code": "public void beforeEach() {\n    // Only compare between two input rows.\n    array = consumer.allocateArray(2);\n    pos = 0;\n\n    dataPage = memoryManager.allocatePage(4096, consumer);\n    pageCursor = dataPage.getBaseOffset();\n  }",
    "comment": "Test the RecordBinaryComparator, which compares two UnsafeRows by their binary form."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/model/MavenModelMergerTest.java",
    "type": "method",
    "name": "testMergeModelProfiles",
    "code": "void testMergeModelProfiles() {\n        Model parent = Model.newBuilder()\n                .profiles(Collections.singletonList(Profile.newInstance()))\n                .build();\n        Model model = Model.newInstance();\n        Model.Builder builder = Model.newBuilder(model);\n        modelMerger.mergeModel_Profiles(builder, model, parent, false, null);\n        assertEquals(0, builder.build().getProfiles().size());\n\n        Profile modelProfile = Profile.newBuilder().id(\"MODEL\").build();\n        model = Model.newBuilder()\n                .profiles(Collections.singletonList(modelProfile))\n                .build();\n        builder = Model.newBuilder(model);\n        modelMerger.mergeModel_Prerequisites(builder, model, parent, false, null);\n        assertEquals(Collections.singletonList(modelProfile), builder.build().getProfiles());\n    }",
    "comment": "Profiles are neither inherited nor injected"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/InterpolatorException.java",
    "type": "method",
    "name": "InterpolatorException",
    "code": "public InterpolatorException(String message, Throwable cause) {\n        super(message, cause);\n    }",
    "comment": "Constructs a new InterpolatorException with the specified detail message and cause.\n\n<p>Note that the detail message associated with {@code cause} is <i>not</i>\nautomatically incorporated in this exception's detail message.</p>\n\n@param message the detail message (which is saved for later retrieval\nby the {@link #getMessage()} method).\n@param cause   the cause (which is saved for later retrieval by the\n{@link #getCause()} method). A {@code null} value is\npermitted, and indicates that the cause is nonexistent or unknown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "configurationParameter",
    "code": "public Builder configurationParameter(String key, String value) {\n\t\t\tthis.requestBuilder.configurationParameter(key, value);\n\t\t\treturn this;\n\t\t}",
    "comment": "Add the supplied <em>configuration parameter</em>.\n\n@param key the configuration parameter key under which to store the\nvalue; never {@code null} or blank\n@param value the value to store\n@return this builder for method chaining\n@see #selectors(DiscoverySelector...)\n@see #filters(Filter...)\n@see #configurationParameters(Map)\n@see #execute()\n@see org.junit.platform.engine.ConfigurationParameters"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "contains",
    "code": "public static boolean contains(char[] array, char valueToFind) {\n        if (array == null) {\n            return false;\n        }\n        for (char c : array) {\n            if (valueToFind == c) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "comment": "<p>Checks if the value is in the given array.</p>\n\n<p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n\n@param array  the array to search through\n@param valueToFind  the value to find\n@return <code>true</code> if the array contains the object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3729MultiForkAggregatorsTest.java",
    "type": "method",
    "name": "MavenITmng3729MultiForkAggregatorsTest",
    "code": "public MavenITmng3729MultiForkAggregatorsTest() {\n        super(\"(2.0.8,3.0-alpha-1),[3.0-alpha-3,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3729\">MNG-3729</a>.\n<p>\nComplicated use case, but say\nyou have an aggregator plugin that forks a lifecycle, and this aggregator is bound to the main lifecycle in a\nmulti-module build. Further, say you call another plugin directly from the command line for this multi-module build,\nwhich forks a new lifecycle (like assembly:assembly).\n</p>\nWhen the directly invoked aggregator forks, it will force the\nforked lifecycle phase to be run for each project in the reactor, regardless of whether this causes the bound\naggregator mojo to run multiple times. When the bound aggregator executes for the first project (this will be in an\ninner fork, two levels removed from the main lifecycle execution) it will set the executionProject to null for the\ncurrent project (which is one of the reactorProjects member instances). On the second pass, as it tries to execute\nthe inner aggregator's forked lifecycle for the second project in the reactor, one of the reactorProjects'\nproject.getExecutionProject() results will be null. If any of the mojos in this inner lifecycle fork requires\ndependency resolution, it will cause a NullPointerException in the DefaultPluginManager when it tries to resolve the\ndependencies for the current project. This happened in 2.0.10-RC11 (which was the predecessor to 2.1.0-RC12, since\nthe version was renamed while the release process was in mid-execution). It did not happen in 2.0.9, and was fixed in\n2.1.0-RC12.\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/internal/AbstractMavenPluginDependenciesValidator.java",
    "type": "method",
    "name": "AbstractMavenPluginDependenciesValidator",
    "code": "protected AbstractMavenPluginDependenciesValidator(PluginValidationManager pluginValidationManager) {\n        this.pluginValidationManager = requireNonNull(pluginValidationManager);\n    }",
    "comment": "Service responsible for validating plugin dependencies.\n\n@since 3.9.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-configuration/src/main/java/org/apache/maven/plugin/coreit/CliConfigMojo.java",
    "type": "method",
    "name": "dumpConfiguration",
    "code": "private void dumpConfiguration(Properties props) {\n        /*\n         * NOTE: This intentionally does not dump the absolute path of a file to check the actual value that was\n         * injected by Maven.\n         */\n        PropertiesUtil.serialize(props, \"propertiesFile\", propertiesFile);\n        PropertiesUtil.serialize(props, \"stringParam\", stringParam);\n        PropertiesUtil.serialize(props, \"fileParam\", fileParam);\n        PropertiesUtil.serialize(props, \"stringParams\", stringParams);\n        PropertiesUtil.serialize(props, \"fileParams\", fileParams);\n        PropertiesUtil.serialize(props, \"listParam\", listParam);\n        PropertiesUtil.serialize(props, \"setParam\", setParam);\n    }",
    "comment": "Dumps the mojo configuration into the specified properties.\n\n@param props The properties to dump the configuration into, must not be <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Long expected, Long actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectUniqueId",
    "code": "public static UniqueIdSelector selectUniqueId(UniqueId uniqueId) {\n\t\tPreconditions.notNull(uniqueId, \"UniqueId must not be null\");\n\t\treturn new UniqueIdSelector(uniqueId);\n\t}",
    "comment": "Create a {@code UniqueIdSelector} for the supplied {@link UniqueId}.\n\n@param uniqueId the {@code UniqueId} to select; never {@code null}\n@see UniqueIdSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/Trigger.java",
    "type": "method",
    "name": "Continuous",
    "code": "public static Trigger Continuous(String interval) {\n    return ContinuousTrigger.apply(interval);\n  }",
    "comment": "A trigger that continuously processes streaming data, asynchronously checkpointing at\nthe specified interval.\n\n{{{\ndf.writeStream.trigger(Trigger.Continuous(\"10 seconds\"))\n}}}\n@since 2.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/demo/app/src/main/java/com/example/android/tflitecamerademo/ImageClassifierFloatInception.java",
    "type": "method",
    "name": "getNormalizedProbability",
    "code": "protected float getNormalizedProbability(int labelIndex) {\n    return getProbability(labelIndex);\n  }",
    "comment": "TODO the following value isn't in [0,1] yet, but may be greater. Why?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/ExecutionRequest.java",
    "type": "method",
    "name": "getOutputDirectoryProvider",
    "code": "public OutputDirectoryProvider getOutputDirectoryProvider() {\n\t\treturn Preconditions.notNull(this.outputDirectoryProvider,\n\t\t\t\"No OutputDirectoryProvider was configured for this request\");\n\t}",
    "comment": "{@return the {@link OutputDirectoryProvider} for this request for writing\nreports and other output files}\n\n@throws PreconditionViolationException if the output directory provider\nis not available\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "isNotBlank",
    "code": "public static boolean isNotBlank(String str) {\n\t\treturn !isBlank(str);\n\t}",
    "comment": "Determine if the supplied {@link String} is not {@linkplain #isBlank\nblank}.\n\n@param str the string to check; may be {@code null}\n@return {@code true} if the string is not blank\n@see #isBlank(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "trace",
    "code": "default MessageBuilder trace(Object message) {\n        return style(\".\" + Constants.MAVEN_STYLE_TRACE_NAME + \":-\" + Constants.MAVEN_STYLE_TRACE_DEFAULT, message);\n    }",
    "comment": "Append message content in trace style.\nBy default, bold magenta\n\n@param message the message to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-bus/src/main/java/com/iluwatar/databus/DataBus.java",
    "type": "method",
    "name": "unsubscribe",
    "code": "public void unsubscribe(final Member member) {\n    this.listeners.remove(member);\n  }",
    "comment": "Deregister a member to stop receiving events.\n\n@param member The member to deregister"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/ComparisonFailure.java",
    "type": "method",
    "name": "ComparisonFailure",
    "code": "public ComparisonFailure(String message, String expected, String actual) {\n        super(message);\n        this.fExpected = expected;\n        this.fActual = actual;\n    }",
    "comment": "Constructs a comparison failure.\n\n@param message the identifying message or null\n@param expected the expected string value\n@param actual the actual string value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getSystemDependencies",
    "code": "public List<Dependency> getSystemDependencies() {\n        Set<Artifact> artifacts = getArtifacts();\n\n        if ((artifacts == null) || artifacts.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Dependency> list = new ArrayList<>(artifacts.size());\n\n        for (Artifact a : getArtifacts()) {\n            if (Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\n                Dependency dependency = new Dependency();\n\n                dependency.setArtifactId(a.getArtifactId());\n                dependency.setGroupId(a.getGroupId());\n                dependency.setVersion(a.getVersion());\n                dependency.setScope(a.getScope());\n                dependency.setType(a.getType());\n                dependency.setClassifier(a.getClassifier());\n\n                list.add(dependency);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }",
    "comment": "TODO let the scope handler deal with this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/test/java/org/apache/maven/model/profile/activation/AbstractProfileActivatorTest.java",
    "type": "method",
    "name": "newContext",
    "code": "protected ProfileActivationContext newContext(final Properties userProperties, final Properties systemProperties) {\n        DefaultProfileActivationContext context = new DefaultProfileActivationContext();\n        return context.setUserProperties(userProperties).setSystemProperties(systemProperties);\n    }",
    "comment": "Provides common services to test {@link ProfileActivator} implementations.\n\n@param <T> the type of {@link ProfileActivator} being tested"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, float actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeWriter.java",
    "type": "method",
    "name": "write",
    "code": "public void write(int ordinal, CalendarInterval input) {\n    grow(16);\n\n    if (input == null) {\n      BitSetMethods.set(getBuffer(), startingOffset, ordinal);\n    } else {\n      long longVal =\n        ((long) input.months & 0xFFFFFFFFL) | (((long) input.days << 32) & 0xFFFFFFFF00000000L);\n      Platform.putLong(getBuffer(), cursor(), longVal);\n      Platform.putLong(getBuffer(), cursor() + 8, input.microseconds);\n    }\n    setOffsetAndSize(ordinal, 16);\n    increaseCursor(16);\n  }",
    "comment": "grow the global buffer before writing data.\nWrite the months, days and microseconds fields of interval to the variable length portion.\nwe need to reserve the space so that we can update it later.\nmove the cursor forward."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/test/java/org/apache/maven/cli/MavenCliTest.java",
    "type": "method",
    "name": "findRootProjectWithAttribute",
    "code": "public void findRootProjectWithAttribute() {\n        Path test = Paths.get(\"src/test/projects/root-attribute\");\n        assertEquals(test, new DefaultRootLocator().findRoot(test.resolve(\"child\")));\n    }",
    "comment": "MNG-7032: Disable colours for {@code --version} if {@code --batch-mode} is also given.\n@throws Exception cli invocation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/business-delegate/src/test/java/com/iluwatar/business/delegate/BusinessDelegateTest.java",
    "type": "method",
    "name": "setup",
    "code": "void setup() {\n    netflixService = spy(new NetflixService());\n    youTubeService = spy(new YouTubeService());\n\n    BusinessLookup businessLookup = spy(new BusinessLookup());\n    businessLookup.setNetflixService(netflixService);\n    businessLookup.setYouTubeService(youTubeService);\n\n    businessDelegate = spy(new BusinessDelegate());\n    businessDelegate.setLookupService(businessLookup);\n  }",
    "comment": "This method sets up the instance variables of this test class. It is executed before the\nexecution of every test."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "getFullyQualifiedMethodName",
    "code": "public static String getFullyQualifiedMethodName(Class<?> clazz, Method method) {\n\t\tPreconditions.notNull(method, \"Method must not be null\");\n\n\t\treturn getFullyQualifiedMethodName(clazz, method.getName(), method.getParameterTypes());\n\t}",
    "comment": "Build the <em>fully qualified method name</em> for the method described by the\nsupplied class and method.\n\n<p>Note that the class is not necessarily the class in which the method is\ndeclared.\n\n@param clazz the class from which the method should be referenced; never {@code null}\n@param method the method; never {@code null}\n@return fully qualified method name; never {@code null}\n@since 1.4\n@see #getFullyQualifiedMethodName(Class, String, Class...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, Float actual) {\n\t\tAssertEquals.assertEquals((Float) expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/runner/BaseTestRunner.java",
    "type": "method",
    "name": "getTest",
    "code": "public Test getTest(String suiteClassName) {\n        if (suiteClassName.length() <= 0) {\n            clearStatus();\n            return null;\n        }\n        Class<?> testClass = null;\n        try {\n            testClass = loadSuiteClass(suiteClassName);\n        } catch (ClassNotFoundException e) {\n            String clazz = e.getMessage();\n            if (clazz == null) {\n                clazz = suiteClassName;\n            }\n            runFailed(\"Class not found \\\"\" + clazz + \"\\\"\");\n            return null;\n        } catch (Exception e) {\n            runFailed(\"Error: \" + e.toString());\n            return null;\n        }\n        Method suiteMethod = null;\n        try {\n            suiteMethod = testClass.getMethod(SUITE_METHODNAME);\n        } catch (Exception e) {\n            // try to extract a test suite automatically\n            clearStatus();\n            return new TestSuite(testClass);\n        }\n        if (!Modifier.isStatic(suiteMethod.getModifiers())) {\n            runFailed(\"Suite() method must be static\");\n            return null;\n        }\n        Test test = null;\n        try {\n            test = (Test) suiteMethod.invoke(null); // static method\n            if (test == null) {\n                return test;\n            }\n        } catch (InvocationTargetException e) {\n            runFailed(\"Failed to invoke suite():\" + e.getTargetException().toString());\n            return null;\n        } catch (IllegalAccessException e) {\n            runFailed(\"Failed to invoke suite():\" + e.toString());\n            return null;\n        }\n\n        clearStatus();\n        return test;\n    }",
    "comment": "Returns the Test corresponding to the given suite. This is\na template method, subclasses override runFailed(), clearStatus()."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/NioDatagramChannel.java",
    "type": "method",
    "name": "getInterestedOps",
    "code": "public int getInterestedOps() {\n    /*\n     * there is no need to accept connections in UDP, so the channel shows interest in reading data.\n     */\n    return SelectionKey.OP_READ;\n  }",
    "comment": "Creates a {@link DatagramChannel} which will bind at provided port and use <code>handler</code>\nto handle incoming events on this channel.\n\n<p>Note the constructor does not bind the socket, {@link #bind()} method should be called for\nbinding the socket.\n\n@param port the port to be bound to listen for incoming datagram requests.\n@param handler the handler to be used for handling incoming requests on this channel.\n@throws IOException if any I/O error occurs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/ReflectionValueExtractor.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n            return idx < expression.length() ? expression.substring(idx) : \"<EOF>\";\n        }",
    "comment": "to make tokenizer look pretty in debugger"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/CompositeService.java",
    "type": "method",
    "name": "stop",
    "code": "public synchronized void stop() {\n    if (this.getServiceState() == STATE.STOPPED) {\n      return;\n    }\n    if (serviceList.size() > 0) {\n      stop(serviceList.size() - 1);\n    }\n    super.stop();\n  }",
    "comment": "The base composite-service is already stopped, don't do anything again."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/cache/CachingSupplier.java",
    "type": "method",
    "name": "AltRes",
    "code": "public AltRes(Throwable throwable) {\n            this.throwable = throwable;\n        }",
    "comment": "Creates a new AltRes with the given throwable.\n\n@param throwable The throwable to store"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Byte expected, Byte actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room3/java/com/example/android/persistence/migrations/User.java",
    "type": "method",
    "name": "User",
    "code": "public User(String userName) {\n        mId = UUID.randomUUID().toString();\n        mUserName = userName;\n        mDate = new Date(System.currentTimeMillis());\n    }",
    "comment": "Immutable model class for a User and entity in the Room database."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testSimpleNegate",
    "code": "public void testSimpleNegate() {\n        Money expected = new Money(-14, \"CHF\");\n        assertEquals(expected, f14CHF.negate());\n    }",
    "comment": "[14 CHF] negate == [-14 CHF]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/DisplayNameUtilsTests.java",
    "type": "method",
    "name": "shouldGetDisplayNameFromDisplayNameAnnotation",
    "code": "void shouldGetDisplayNameFromDisplayNameAnnotation() {\n\n\t\t\tString displayName = DisplayNameUtils.determineDisplayName(MyTestCase.class, () -> \"default-name\");\n\n\t\t\tassertThat(displayName).isEqualTo(\"my-test-case\");\n\t\t}",
    "comment": "Unit tests for {@link DisplayNameUtils}.\n\n@since 5.5"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java",
    "type": "method",
    "name": "makeDescription",
    "code": "private static Description makeDescription(Test test) {\n        if (test instanceof TestCase) {\n            TestCase tc = (TestCase) test;\n            return Description.createTestDescription(tc.getClass(), tc.getName(),\n                    getAnnotations(tc));\n        } else if (test instanceof TestSuite) {\n            TestSuite ts = (TestSuite) test;\n            String name = ts.getName() == null ? createSuiteDescription(ts) : ts.getName();\n            Description description = Description.createSuiteDescription(name);\n            int n = ts.testCount();\n            for (int i = 0; i < n; i++) {\n                Description made = makeDescription(ts.testAt(i));\n                description.addChild(made);\n            }\n            return description;\n        } else if (test instanceof Describable) {\n            Describable adapter = (Describable) test;\n            return adapter.getDescription();\n        } else if (test instanceof TestDecorator) {\n            TestDecorator decorator = (TestDecorator) test;\n            return makeDescription(decorator.getTest());\n        } else {\n            return Description.createSuiteDescription(test.getClass());\n        }\n    }",
    "comment": "This is the best we can do in this case"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/CompositeService.java",
    "type": "method",
    "name": "CompositeServiceShutdownHook",
    "code": "public CompositeServiceShutdownHook(CompositeService compositeService) {\n      this.compositeService = compositeService;\n    }",
    "comment": "JVM Shutdown hook for CompositeService which will stop the given\nCompositeService gracefully in case of JVM shutdown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultMojoExecutionConfigurator.java",
    "type": "method",
    "name": "checkUnknownMojoConfigurationParameters",
    "code": "private void checkUnknownMojoConfigurationParameters(MojoExecution mojoExecution) {\n        if (mojoExecution.getConfiguration() == null\n                || mojoExecution.getConfiguration().getChildCount() == 0) {\n            return;\n        }\n\n        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();\n\n        Set<String> parametersNamesGoal = mojoDescriptor.getParameters().stream()\n                .flatMap(this::getParameterNames)\n                .collect(Collectors.toSet());\n\n        Set<String> unknownParameters = getUnknownParameters(mojoExecution, parametersNamesGoal);\n\n        if (unknownParameters.isEmpty()) {\n            return;\n        }\n\n        Set<String> parametersNamesAll = mojoDescriptor.getPluginDescriptor().getMojos().stream()\n                .flatMap(m -> m.getParameters().stream())\n                .flatMap(this::getParameterNames)\n                .collect(Collectors.toSet());\n\n        unknownParameters = getUnknownParameters(mojoExecution, parametersNamesAll);\n\n        unknownParameters.forEach(name -> {\n            MessageBuilder messageBuilder = messageBuilderFactory\n                    .builder()\n                    .warning(\"Parameter '\")\n                    .warning(name)\n                    .warning(\"' is unknown for plugin '\")\n                    .warning(mojoExecution.getArtifactId())\n                    .warning(\":\")\n                    .warning(mojoExecution.getVersion())\n                    .warning(\":\")\n                    .warning(mojoExecution.getGoal());\n\n            if (mojoExecution.getExecutionId() != null) {\n                messageBuilder.warning(\" (\");\n                messageBuilder.warning(mojoExecution.getExecutionId());\n                messageBuilder.warning(\")\");\n            }\n\n            messageBuilder.warning(\"'\");\n\n            logger.warn(messageBuilder.toString());\n        });\n    }",
    "comment": "in first step get parameter names of current goal\nsecond step get parameter names of all plugin goals"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectFile",
    "code": "public static FileSelector selectFile(File file, FilePosition position) {\n\t\tPreconditions.notNull(file, \"File must not be null\");\n\t\tPreconditions.condition(file.isFile(),\n\t\t\t() -> String.format(\"The supplied java.io.File [%s] must represent an existing file\", file));\n\t\ttry {\n\t\t\treturn new FileSelector(file.getCanonicalPath(), position);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new PreconditionViolationException(\"Failed to retrieve canonical path for file: \" + file, ex);\n\t\t}\n\t}",
    "comment": "Create a {@code FileSelector} for the supplied {@linkplain File file}.\n\n<p>This method selects the file in its {@linkplain File#getCanonicalPath()\ncanonical} form and throws a {@link PreconditionViolationException} if the\nfile does not exist.\n\n@param file the file to select; never {@code null}\n@param position the position inside the file; may be {@code null}\n@see FileSelector\n@see #selectFile(File)\n@see #selectFile(String)\n@see #selectFile(String, FilePosition)\n@see #selectDirectory(String)\n@see #selectDirectory(File)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/sqlite/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "updateUserName",
    "code": "void updateUserName(String userName, UpdateUserCallback callback) {\n        final WeakReference<UpdateUserCallback> updateUserCallback = new WeakReference<>(callback);\n\n        final User user = mCachedUser == null\n                ? new User(userName)\n                : new User(mCachedUser.getId(), userName);\n\n        // update the user on the I/O thread\n        mAppExecutors.diskIO().execute(new Runnable() {\n                mAppExecutors.mainThread().execute(new Runnable() {\n                    }\n                });\n            }",
    "comment": "Insert an new user or update the name of the user.\n\n@param userName the user name\n@param callback callback that gets triggered when the user was updated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/factory-method/src/test/java/com/iluwatar/factory/method/FactoryMethodTest.java",
    "type": "method",
    "name": "verifyWeapon",
    "code": "private void verifyWeapon(Weapon weapon, WeaponType expectedWeaponType, Class<?> clazz) {\n    assertTrue(clazz.isInstance(weapon), \"Weapon must be an object of: \" + clazz.getName());\n    assertEquals(\n        expectedWeaponType,\n        weapon.weaponType(),\n        \"Weapon must be of weaponType: \" + expectedWeaponType);\n  }",
    "comment": "This method asserts that the weapon object that is passed is an instance of the clazz and the\nweapon is of type expectedWeaponType.\n\n@param weapon weapon object which is to be verified\n@param expectedWeaponType expected WeaponType of the weapon\n@param clazz expected class of the weapon"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RetryingBlockTransferor.java",
    "type": "method",
    "name": "handleBlockTransferSuccess",
    "code": "private void handleBlockTransferSuccess(String blockId, ManagedBuffer data) {\n      // We will only forward this success message to our parent listener if this block request is\n      // outstanding and we are still the active listener.\n      boolean shouldForwardSuccess = false;\n      synchronized (RetryingBlockTransferor.this) {\n        if (this == currentListener && outstandingBlocksIds.contains(blockId)) {\n          outstandingBlocksIds.remove(blockId);\n          shouldForwardSuccess = true;\n          // If there were SASL failures earlier, remove them from retryCount, as there was\n          // a SASL success (and some other request post bootstrap was also successful).\n          if (saslRetryCount > 0) {\n            Preconditions.checkState(retryCount >= saslRetryCount,\n              \"retryCount must be greater than or equal to saslRetryCount\");\n            retryCount -= saslRetryCount;\n            saslRetryCount = 0;\n          }\n        }\n      }\n\n      // Now actually invoke the parent listener, outside of the synchronized block.\n      if (shouldForwardSuccess) {\n        listener.onBlockTransferSuccess(blockId, data);\n      }\n    }",
    "comment": "Our RetryListener intercepts block transfer responses and forwards them to our parent\nlistener. Note that in the event of a retry, we will immediately replace the 'currentListener'\nfield, indicating that any responses from non-current Listeners should be ignored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/main/java/com/example/android/observability/ui/UserViewModel.java",
    "type": "method",
    "name": "getUserName",
    "code": "public Flowable<String> getUserName() {\n        return mDataSource.getUser()\n                // for every emission of the user, get the user name\n                .map(user -> {\n                    mUser = user;\n                    return user.getUserName();\n                });\n\n    }",
    "comment": "Get the user name of the user.\n\n@return a {@link Flowable} that will emit every time the user name has been updated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/test/java/com/iluwatar/cleanarchitecture/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java",
    "type": "method",
    "name": "getOrComputeIfAbsentWithTypeSafetyAndInvalidRequiredTypeThrowsException",
    "code": "void getOrComputeIfAbsentWithTypeSafetyAndInvalidRequiredTypeThrowsException() {\n\t\t\tString key = \"pi\";\n\t\t\tFloat value = 3.14f;\n\n\t\t\tstore.put(namespace, key, value);\n\n\t\t\tFunction<String, String> defaultCreator = k -> \"enigma\";\n\n\t\t\tException exception = assertThrows(NamespacedHierarchicalStoreException.class,\n\t\t\t\t() -> store.getOrComputeIfAbsent(namespace, key, defaultCreator, String.class));\n\t\t\tassertEquals(\n\t\t\t\t\"Object stored under key [pi] is not of required type [java.lang.String], but was [java.lang.Float]: 3.14\",\n\t\t\t\texception.getMessage());\n\t\t}",
    "comment": "Store a Float...\nBut declare that our function creates a String..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/kinesis-asl/src/main/java/org/apache/spark/streaming/kinesis/KinesisInitialPositions.java",
    "type": "method",
    "name": "if",
    "code": "if (initialPositionInStream == InitialPositionInStream.LATEST) {\n            return new Latest();\n        } else if (initialPositionInStream == InitialPositionInStream.TRIM_HORIZON) {\n            return new TrimHorizon();\n        } else {\n            // InitialPositionInStream.AT_TIMESTAMP is not supported.\n            // Use InitialPosition.atTimestamp(timestamp) instead.\n            throw new UnsupportedOperationException(\n                    \"Only InitialPositionInStream.LATEST and InitialPositionInStream.\" +\n                            \"TRIM_HORIZON supported in initialPositionInStream(). Please use \" +\n                            \"the initialPosition() from builder API in KinesisInputDStream for \" +\n                            \"using InitialPositionInStream.AT_TIMESTAMP\");\n        }",
    "comment": "Returns instance of [[KinesisInitialPosition]] based on the passed\n[[InitialPositionInStream]]. This method is used in KinesisUtils for translating the\nInitialPositionInStream to InitialPosition. This function would be removed when we deprecate\nthe KinesisUtils.\n\n@return [[InitialPosition]]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "newInstance",
    "code": "static XmlNode newInstance(String name, String value) {\n        return newBuilder().name(name).value(value).build();\n    }",
    "comment": "Creates a new XmlNode instance with the specified name and value.\n\n@param name the name for the new node\n@param value the value for the new node\n@return a new XmlNode instance\n@throws NullPointerException if name is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "withBeforeClasses",
    "code": "protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = testClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }",
    "comment": "Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\nand superclasses before executing {@code statement}; if any throws an\nException, stop execution and pass the exception on."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/regression/JavaLinearRegressionSuite.java",
    "type": "method",
    "name": "linearRegressionWithSetters",
    "code": "public void linearRegressionWithSetters() {\n    LinearRegression lr = new LinearRegression()\n      .setMaxIter(10)\n      .setRegParam(1.0).setSolver(\"l-bfgs\");\n    LinearRegressionModel model = lr.fit(dataset);\n    LinearRegression parent = (LinearRegression) model.parent();\n    assertEquals(10, parent.getMaxIter());\n    assertEquals(1.0, parent.getRegParam(), 0.0);\n\n    LinearRegressionModel model2 =\n      lr.fit(dataset, lr.maxIter().w(5), lr.regParam().w(0.1), lr.predictionCol().w(\"thePred\"));\n    LinearRegression parent2 = (LinearRegression) model2.parent();\n    assertEquals(5, parent2.getMaxIter());\n    assertEquals(0.1, parent2.getRegParam(), 0.0);\n    assertEquals(\"thePred\", model2.getPredictionCol());\n  }",
    "comment": "Set params, train, and check as many params as we can.\nCall fit() with new params, and check as many params as we can."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/ProjectBuildList.java",
    "type": "method",
    "name": "getByTaskSegment",
    "code": "public ProjectBuildList getByTaskSegment(TaskSegment taskSegment) {\n        return new ProjectBuildList(\n                items.stream().filter(pb -> taskSegment == pb.getTaskSegment()).collect(Collectors.toList()));\n    }",
    "comment": "Returns aProjectBuildList that contains only items for the specified taskSegment\n@param taskSegment the requested task segment\n@return a project build list for the supplied task segment"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(boolean condition) {\n        Assert.assertFalse(condition);\n    }",
    "comment": "Asserts that a condition is false. If it isn't it throws\nan AssertionFailedError."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/LookupInvoker.java",
    "type": "method",
    "name": "doConfigureWithTerminalWithRawStreamsDisabled",
    "code": "protected void doConfigureWithTerminalWithRawStreamsDisabled(C context) {\n        MavenSimpleLogger stdout = (MavenSimpleLogger) context.loggerFactory.getLogger(\"stdout\");\n        MavenSimpleLogger stderr = (MavenSimpleLogger) context.loggerFactory.getLogger(\"stderr\");\n        stdout.setLogLevel(LocationAwareLogger.INFO_INT);\n        stderr.setLogLevel(LocationAwareLogger.INFO_INT);\n        PrintStream psOut = new LoggingOutputStream(s -> stdout.info(\"[stdout] \" + s)).printStream();\n        context.closeables.add(() -> LoggingOutputStream.forceFlush(psOut));\n        PrintStream psErr = new LoggingOutputStream(s -> stderr.warn(\"[stderr] \" + s)).printStream();\n        context.closeables.add(() -> LoggingOutputStream.forceFlush(psErr));\n        System.setOut(psOut);\n        System.setErr(psErr);\n        // no need to set them back, this is already handled by MessageUtils.systemUninstall() above\n    }",
    "comment": "Override this method to add some special handling for \"raw streams\" <em>disabled</em> option."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-expression/src/main/java/org/apache/maven/plugin/coreit/ExpressionUtil.java",
    "type": "method",
    "name": "evaluate",
    "code": "public static Map evaluate(String expression, Object context) {\n        Map values = Collections.EMPTY_MAP;\n\n        if (expression != null && expression.length() > 0) {\n            List segments = Arrays.asList(expression.split(\"/\", 0));\n            values = evaluate(\"\", segments, context);\n        }\n\n        return values;\n    }",
    "comment": "Evaluates the specified expression. Expressions are composed of segments which are separated by a forward slash\n('/'). Each segment specifies a (public) bean property of the current object and drives the evaluation further\ndown the object graph. For lists, arrays and maps segments can additionally specify the index/key of an element.\nThe initial segment denotes the root object and the parameter <code>contexts</code> is used to specify which root\nobjects are available. For instance, if <code>contexts</code> maps the token \"project\" to a Maven project\ninstance, the expression \"project/build/resources/0/directory\" specifies the first resource directory of the\nproject.\n\n@param expression The expression to evaluate, may be <code>null</code>.\n@param context    The object to start expression evaluation at, must not be <code>null</code>.\n@return The values of the evaluation, indexed by expression, or an empty map if the segments could not be\nevaluated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterExpressionEvaluatorV4.java",
    "type": "method",
    "name": "alignToBaseDirectory",
    "code": "public File alignToBaseDirectory(File file) {\n        if (file != null) {\n            if (file.isAbsolute()) {\n            } else if (file.getPath().startsWith(File.separator)) {\n                file = file.getAbsoluteFile();\n            } else {\n                file = basedir.resolve(file.getPath())\n                        .normalize()\n                        .toAbsolutePath()\n                        .toFile();\n            }\n        }\n        return file;\n    }",
    "comment": "TODO Copied from the DefaultInterpolator. We likely want to resurrect the PathTranslator or at least a\nsimilar component for re-usage\npath was already absolute, just normalize file separator and we're done\ndrive-relative Windows path, don't align with project directory but with drive root\nan ordinary relative path, align with project directory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProjectBuilderRequest.java",
    "type": "method",
    "name": "builder",
    "code": "static ProjectBuilderRequestBuilder builder() {\n        return new ProjectBuilderRequestBuilder();\n    }",
    "comment": "Creates a new builder for constructing a ProjectBuilderRequest.\n\n@return a new ProjectBuilderRequestBuilder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectNestedClass",
    "code": "public static NestedClassSelector selectNestedClass(List<String> enclosingClassNames, String nestedClassName) {\n\t\treturn selectNestedClass(null, enclosingClassNames, nestedClassName);\n\t}",
    "comment": "Create a {@code NestedClassSelector} for the supplied class name and its enclosing\nclasses' names.\n\n@param enclosingClassNames the names of the enclosing classes; never {@code null} or empty\n@param nestedClassName the name of the nested class to select; never {@code null} or blank\n@since 1.6\n@see NestedClassSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-runner/src/main/java/org/junit/platform/runner/JUnitPlatform.java",
    "type": "method",
    "name": "createDiscoveryRequest",
    "code": "private LauncherDiscoveryRequest createDiscoveryRequest() {\n\t\tSuiteLauncherDiscoveryRequestBuilder requestBuilder = request();\n\t\tboolean isSuite = isSuite();\n\t\tif (!isSuite) {\n\t\t\trequestBuilder.selectors(selectClass(this.testClass));\n\t\t}\n\n\t\treturn requestBuilder\n\t\t\t\t.filterStandardClassNamePatterns(isSuite)\n\t\t\t\t.suite(this.testClass)\n\t\t\t\t.build();\n\t}",
    "comment": "Allows @RunWith(JUnitPlatform.class) to be added to any test case\n@formatter:off\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/ClockSource.java",
    "type": "method",
    "name": "create",
    "code": "private static ClockSource create() {\n         String os = System.getProperty(\"os.name\");\n         if (\"Mac OS X\".equals(os)) {\n            return new MillisecondClockSource();\n         }\n\n         return new NanosecondClockSource();\n      }",
    "comment": "Factory class used to create a platform-specific ClockSource."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<String> create(Scope scope, byte[][][] data) {\n    return create(scope, data, String.class);\n  }",
    "comment": "Creates a rank-2 constant of {@code String} elements, each represented as an array of {@code byte}s.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(int expected, int actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/categories/ExcludeCategories.java",
    "type": "method",
    "name": "createFilter",
    "code": "protected Filter createFilter(List<Class<?>> categories) {\n        return new ExcludesAny(categories);\n    }",
    "comment": "Creates a {@link Filter} which is only passed by tests that are\nnot categorized with any of the specified categories.\n\n@param categories Category classes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/impl/DefaultPackagingRegistry.java",
    "type": "method",
    "name": "DefaultPackagingRegistry",
    "code": "public DefaultPackagingRegistry(Lookup lookup, TypeRegistry typeRegistry, List<PackagingProvider> providers) {\n        super(providers);\n        this.lookup = lookup;\n        this.typeRegistry = typeRegistry;\n    }",
    "comment": "TODO: this is session scoped as SPI can contribute."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/LauncherConnection.java",
    "type": "method",
    "name": "run",
    "code": "public void run() {\n    try {\n      FilteredObjectInputStream in = new FilteredObjectInputStream(socket.getInputStream());\n      while (isOpen()) {\n        Message msg = (Message) in.readObject();\n        handle(msg);\n      }\n    } catch (EOFException eof) {\n      // Remote side has closed the connection, just cleanup.\n      try {\n        close();\n      } catch (Exception unused) {\n        // no-op.\n      }\n    } catch (Exception e) {\n      if (!closed) {\n        LOG.log(Level.WARNING, \"Error in inbound message handling.\", e);\n        try {\n          close();\n        } catch (Exception unused) {\n          // no-op.\n        }\n      }\n    }\n  }",
    "comment": "Encapsulates a connection between a launcher server and client. This takes care of the\ncommunication (sending and receiving messages), while processing of messages is left for\nthe implementations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/MonotonicClock.java",
    "type": "method",
    "name": "withZone",
    "code": "public Clock withZone(ZoneId zone) {\n        // Monotonic clock is always UTC-based\n        return this;\n    }",
    "comment": "Returns this clock since timezone adjustments are not supported.\n<p>\nThis implementation maintains UTC time to ensure monotonic behavior.\nThe provided zone parameter is ignored.\n\n@param zone the target timezone (ignored)\n@return this clock instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng7965PomDuplicateTagsTest.java",
    "type": "method",
    "name": "verifyRegexInLog",
    "code": "private void verifyRegexInLog(List<String> logs, String text) {\n        Pattern p = Pattern.compile(text);\n        assertTrue(logs.stream().anyMatch(p.asPredicate()), \"Log file not contains: \" + text);\n    }",
    "comment": "the POM is not parseable"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/StackTracePruningTests.java",
    "type": "method",
    "name": "shouldPruneStackTraceByDefault",
    "code": "void shouldPruneStackTraceByDefault() {\n\t\tEngineExecutionResults results = EngineTestKit.engine(\"junit-jupiter\") //\n\t\t\t\t.selectors(selectMethod(FailingTestTestCase.class, \"failingAssertion\")) //\n\t\t\t\t.execute();\n\n\t\tList<StackTraceElement> stackTrace = extractStackTrace(results);\n\n\t\tassertStackTraceDoesNotContain(stackTrace,\n\t\t\t\"jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:\");\n\t}",
    "comment": "Test cases for stacktrace pruning.\n\n<p>Note: the package {@code org.junit.platform} this class resides in is\nchosen on purpose. If it was in {@code org.junit.platform.launcher}\nstack traces would be fully pruned.\n\n@since 5.10"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/MirrorProcessorTest.java",
    "type": "method",
    "name": "testExternalURL",
    "code": "void testExternalURL() {\n        assertTrue(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"http://somehost\")));\n        assertTrue(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"http://somehost:9090/somepath\")));\n        assertTrue(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"ftp://somehost\")));\n        assertTrue(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"http://192.168.101.1\")));\n        assertTrue(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"http://\")));\n        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"http://localhost:8080\")));\n        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"http://127.0.0.1:9090\")));\n        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"file://localhost/somepath\")));\n        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"file://localhost/D:/somepath\")));\n        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"http://localhost\")));\n        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"http://127.0.0.1\")));\n        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"file:///somepath\")));\n        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"file://D:/somepath\")));\n\n        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"192.168.101.1\")));\n        assertFalse(DefaultMirrorSelector.isExternalRepo(getRepo(\"foo\", \"\")));\n    }",
    "comment": "these are local\nnot a proper url so returns false;"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicSample/app/src/main/java/com/example/android/persistence/db/DataGenerator.java",
    "type": "method",
    "name": "generateProducts",
    "code": "public static List<ProductEntity> generateProducts() {\n        List<ProductEntity> products = new ArrayList<>(FIRST.length * SECOND.length);\n        Random rnd = new Random();\n        for (int i = 0; i < FIRST.length; i++) {\n            for (int j = 0; j < SECOND.length; j++) {\n                ProductEntity product = new ProductEntity();\n                product.setName(FIRST[i] + \" \" + SECOND[j]);\n                product.setDescription(product.getName() + \" \" + DESCRIPTION[j]);\n                product.setPrice(rnd.nextInt(240));\n                product.setId(FIRST.length * i + j + 1);\n                products.add(product);\n            }\n        }\n        return products;\n    }",
    "comment": "Generates data to pre-populate the database"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng1493NonStandardModulePomNamesTest.java",
    "type": "method",
    "name": "MavenITmng1493NonStandardModulePomNamesTest",
    "code": "public MavenITmng1493NonStandardModulePomNamesTest() {\n        super(\"(2.0.8,)\"); // 2.0.9+ (including snapshots)\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-1493\">MNG-1493</a>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "authEngineVersion",
    "code": "public int authEngineVersion() {\n    return conf.getInt(\"spark.network.crypto.authEngineVersion\", 1);\n  }",
    "comment": "Version number to be used by the AuthEngine key agreement protocol. Valid values are 1 or 2.\nThe default version is 1 for backward compatibility. Version 2 is recommended for stronger\nsecurity properties."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClassSource.java",
    "type": "method",
    "name": "from",
    "code": "public static ClassSource from(String className, FilePosition filePosition) {\n\t\treturn new ClassSource(className, filePosition);\n\t}",
    "comment": "Create a new {@code ClassSource} using the supplied class name and\n\n@param className the class name; must not be {@code null} or blank\n@param filePosition the position in the source file; may be {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3843PomInheritanceTest.java",
    "type": "method",
    "name": "assertPathEquals",
    "code": "private void assertPathEquals(File basedir, String expected, String actual) {\n        File actualFile = new File(actual);\n        if (actualFile.isAbsolute()) {\n            assertEquals(new File(basedir, expected), actualFile);\n        } else {\n            assertEquals(new File(expected), actualFile);\n        }\n    }",
    "comment": "NOTE: Basedir alignment is another issue, so don't test this here"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java",
    "type": "method",
    "name": "getOrComputeIfAbsent",
    "code": "default <V> V getOrComputeIfAbsent(Class<V> type) {\n\t\t\treturn getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);\n\t\t}",
    "comment": "Get the object of type {@code type} that is present in this\n{@code Store} (<em>keyed</em> by {@code type}); and otherwise invoke\nthe default constructor for {@code type} to generate the object,\nstore it, and return it.\n\n<p>This method is a shortcut for the following, where {@code X} is\nthe type of object we wish to retrieve from the store.\n\n<pre style=\"code\">\nX x = store.getOrComputeIfAbsent(X.class, key -&gt; new X(), X.class);\n// Equivalent to:\n// X x = store.getOrComputeIfAbsent(X.class);\n</pre>\n\n<p>See {@link #getOrComputeIfAbsent(Object, Function, Class)} for\nfurther details.\n\n<p>If {@code type} implements {@link CloseableResource} or\n{@link AutoCloseable} (unless the\n{@code junit.jupiter.extensions.store.close.autocloseable.enabled}\nconfiguration parameter is set to {@code false}), then the {@code close()}\nmethod will be invoked on the stored object when the store is closed.\n\n@param type the type of object to retrieve; never {@code null}\n@param <V> the key and value type\n@return the object; never {@code null}\n@since 5.1\n@see #getOrComputeIfAbsent(Object, Function)\n@see #getOrComputeIfAbsent(Object, Function, Class)\n@see CloseableResource\n@see AutoCloseable"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExternalBlockHandler.java",
    "type": "method",
    "name": "applicationRemoved",
    "code": "public void applicationRemoved(String appId, boolean cleanupLocalDirs) {\n    blockManager.applicationRemoved(appId, cleanupLocalDirs);\n    mergeManager.applicationRemoved(appId, cleanupLocalDirs);\n  }",
    "comment": "Removes an application (once it has been terminated), and optionally will clean up any\nlocal directories associated with the executors of that application in a separate thread."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "allocateForBuffer",
    "code": "private static <T> Tensor<T> allocateForBuffer(DataType dataType, long[] shape, int nBuffered) {\n    final int nflattened = numElements(shape);\n    int nbytes = 0;\n    if (dataType != DataType.STRING) {\n      if (nBuffered != nflattened) {\n        throw incompatibleBuffer(nBuffered, shape);\n      }\n      nbytes = nflattened * elemByteSize(dataType);\n    } else {\n      nbytes = nBuffered;\n    }\n    Tensor<T> t = new Tensor<T>(dataType);\n    t.shapeCopy = Arrays.copyOf(shape, shape.length);\n    long nativeHandle = allocate(t.dtype.c(), t.shapeCopy, nbytes);\n    t.nativeRef = new NativeReference(nativeHandle);\n    return t;\n  }",
    "comment": "Helper function to allocate a Tensor for the create() methods that create a Tensor from\na java.nio.Buffer.\nRequires: dataType matches T\nDT_STRING tensor encoded in a ByteBuffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroMapOfArray.java",
    "type": "method",
    "name": "put",
    "code": "public void put(int field$, java.lang.Object value$) {\n    switch (field$) {\n    case 0: string_to_ints_column = (java.util.Map<java.lang.String,java.util.List<java.lang.Integer>>)value$; break;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumReader.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertLinesMatch",
    "code": "public static void assertLinesMatch(List<String> expectedLines, List<String> actualLines, String message) {\n\t\tAssertLinesMatch.assertLinesMatch(expectedLines, actualLines, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} list of {@linkplain String}s matches {@code actual}\nlist.\n\n<p>Find a detailed description of the matching algorithm in {@link #assertLinesMatch(List, List)}.\n\n<p>Fails with the supplied failure {@code message} and the generated message.\n\n@see #assertLinesMatch(List, List)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/impl/DefaultProjectBuilder.java",
    "type": "method",
    "name": "ProjectBuilderResult",
    "code": "return new ProjectBuilderResult() {\n\n                @Nonnull\n                @Override\n                public String getProjectId() {\n                    return res.getProjectId();\n                }\n\n                @Nonnull\n                @Override\n                public Optional<Path> getPomFile() {\n                    return Optional.ofNullable(res.getPomFile()).map(File::toPath);\n                }\n\n                @Nonnull\n                @Override\n                public Optional<Project> getProject() {\n                    return Optional.ofNullable(session.getProject(res.getProject()));\n                }\n\n                @Nonnull\n                @Override\n                public Collection<BuilderProblem> getProblems() {\n                    return new MappedCollection<>(res.getProblems(), this::toProblem);\n                }\n\n                private BuilderProblem toProblem(ModelProblem problem) {\n                    return new BuilderProblem() {\n\n                        @Override\n                        public int getLineNumber() {\n                            return problem.getLineNumber();\n                        }\n\n                        @Override\n                        public int getColumnNumber() {\n                            return problem.getColumnNumber();\n                        }\n\n                        @Override\n                        public String getLocation() {\n                            StringBuilder buffer = new StringBuilder(256);\n\n                            if (!getSource().isEmpty()) {\n                                buffer.append(getSource());\n                            }\n\n                            if (getLineNumber() > 0) {\n                                if (!buffer.isEmpty()) {\n                                    buffer.append(\", \");\n                                }\n                                buffer.append(\"line \").append(getLineNumber());\n                            }\n\n                            if (getColumnNumber() > 0) {\n                                if (!buffer.isEmpty()) {\n                                    buffer.append(\", \");\n                                }\n                                buffer.append(\"column \").append(getColumnNumber());\n                            }\n\n                            return buffer.toString();\n                        }\n\n                        @Override\n                        public Exception getException() {\n                            return problem.getException();\n                        }\n\n                        @Override\n                        public String getMessage() {\n                            return problem.getMessage();\n                        }\n\n                        @Override\n                        public Severity getSeverity() {\n                            return Severity.valueOf(problem.getSeverity().name());\n                        }\n                    };\n                }\n\n                @Nonnull\n                @Override\n                public Optional<DependencyResolverResult> getDependencyResolverResult() {\n                    return Optional.ofNullable(res.getDependencyResolutionResult())\n                            .map(r -> new DefaultDependencyResolverResult(\n                                    null, null, r.getCollectionErrors(), session.getNode(r.getDependencyGraph()), 0));\n                }\n            };",
    "comment": "TODO: this should not be null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/WriteBuilder.java",
    "type": "method",
    "name": "buildForBatch",
    "code": "default BatchWrite buildForBatch() {\n    throw new SparkUnsupportedOperationException(\n      \"_LEGACY_ERROR_TEMP_3135\", Map.of(\"class\", getClass().getName()));\n  }",
    "comment": "Returns a {@link BatchWrite} to write data to batch source.\n\n@deprecated use {@link #build()} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ClassSupport.java",
    "type": "method",
    "name": "nullSafeToString",
    "code": "public static String nullSafeToString(Class<?>... classes) {\n\t\treturn ClassUtils.nullSafeToString(classes);\n\t}",
    "comment": "Generate a comma-separated list of fully qualified class names for the\nsupplied classes.\n\n@param classes the classes whose names should be included in the\ngenerated string\n@return a comma-separated list of fully qualified class names, or an empty\nstring if the supplied class array is {@code null} or empty\n@see #nullSafeToString(Function, Class...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvn/resident/ResidentMavenInvoker.java",
    "type": "method",
    "name": "createContext",
    "code": "protected MavenContext createContext(InvokerRequest invokerRequest) {\n        MavenContext result = residentContext.computeIfAbsent(\"resident\", k -> new MavenContext(invokerRequest, false));\n        return copyIfDifferent(result, invokerRequest);\n    }",
    "comment": "TODO: in a moment Maven stop pushing user properties to system properties (and maybe something more)\nand allow multiple instances per JVM, this may become a pool? derive key based in invokerRequest?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/StreamRequest.java",
    "type": "method",
    "name": "StreamRequest",
    "code": "public StreamRequest(String streamId) {\n     this.streamId = streamId;\n   }",
    "comment": "Request to stream data from the remote end.\n<p>\nThe stream ID is an arbitrary string that needs to be negotiated between the two endpoints before\nthe data can be streamed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginIncompatibleException.java",
    "type": "method",
    "name": "PluginIncompatibleException",
    "code": "public PluginIncompatibleException(Plugin plugin, String message) {\n        this(plugin, message, null);\n    }",
    "comment": "Signals a plugin which is not compatible with the current Maven runtime."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/CumulativeScopeArtifactFilter.java",
    "type": "method",
    "name": "CumulativeScopeArtifactFilter",
    "code": "public CumulativeScopeArtifactFilter(Collection<String> scopes) {\n        this.scopes = new HashSet<>();\n\n        addScopes(scopes);\n    }",
    "comment": "Create a new filter with the specified scopes and their implied scopes enabled.\n\n@param scopes The scopes to enable, along with all implied scopes, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/TypeRegistry.java",
    "type": "method",
    "name": "require",
    "code": "default Type require(@Nonnull String id) {\n        return lookup(id).orElseThrow(() -> new IllegalArgumentException(\"Unknown extensible enum value '\" + id + \"'\"));\n    }",
    "comment": "Obtain the {@link Type} from the specified {@code id}.\nIf no type is known for {@code id}, the registry will\ncreate a custom {@code Type} for it.\n\n@param id the id of the type to retrieve\n@return the type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "chunkFetchHandlerThreads",
    "code": "public int chunkFetchHandlerThreads() {\n    if (!this.getModuleName().equalsIgnoreCase(\"shuffle\")) {\n      return 0;\n    }\n    int chunkFetchHandlerThreadsPercent =\n      Integer.parseInt(conf.get(\"spark.shuffle.server.chunkFetchHandlerThreadsPercent\"));\n    int threads =\n      this.serverThreads() > 0 ? this.serverThreads() : 2 * NettyRuntime.availableProcessors();\n    return (int) Math.ceil(threads * (chunkFetchHandlerThreadsPercent / 100.0));\n  }",
    "comment": "Percentage of io.serverThreads used by netty to process ChunkFetchRequest.\nWhen the config `spark.shuffle.server.chunkFetchHandlerThreadsPercent` is set,\nshuffle server will use a separate EventLoopGroup to process ChunkFetchRequest messages.\nAlthough when calling the async writeAndFlush on the underlying channel to send\nresponse back to client, the I/O on the channel is still being handled by\n{@link org.apache.spark.network.server.TransportServer}'s default EventLoopGroup\nthat's registered with the Channel, by waiting inside the ChunkFetchRequest handler\nthreads for the completion of sending back responses, we are able to put a limit on\nthe max number of threads from TransportServer's default EventLoopGroup that are\ngoing to be consumed by writing response to ChunkFetchRequest, which are I/O intensive\nand could take long time to process due to disk contentions. By configuring a slightly\nhigher number of shuffler server threads, we are able to reserve some threads for\nhandling other RPC messages, thus making the Client less likely to experience timeout\nwhen sending RPC messages to the shuffle server. The number of threads used for handling\nchunked fetch requests are percentage of io.serverThreads (if defined) else it is a percentage\nof 2 * #cores. However, a percentage of 0 means netty default number of threads which\nis 2 * #cores ignoring io.serverThreads. The percentage here is configured via\nspark.shuffle.server.chunkFetchHandlerThreadsPercent. The returned value is rounded off to\nceiling of the nearest integer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/reporting/ReportEntry.java",
    "type": "method",
    "name": "getKeyValuePairs",
    "code": "public Map<String, String> getKeyValuePairs() {\n\t\treturn Collections.unmodifiableMap(this.keyValuePairs);\n\t}",
    "comment": "Get an unmodifiable copy of the map of key-value pairs to be published.\n\n@return a copy of the map of key-value pairs; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom/java/com/example/android/persistence/migrations/MigrationTest.java",
    "type": "method",
    "name": "getMigratedRoomDatabase",
    "code": "private UsersDatabase getMigratedRoomDatabase() {\n        UsersDatabase database = Room.databaseBuilder(ApplicationProvider.getApplicationContext(),\n                UsersDatabase.class, TEST_DB_NAME)\n                .addMigrations(MIGRATION_1_2)\n                .build();\n        mMigrationTestHelper.closeWhenFinished(database);\n        return database;\n    }",
    "comment": "Create the database with the initial version 1 schema and insert a user\nGet the latest, migrated, version of the database\nCheck that the correct data is in the database\nCreate the database with version 2\ndb has schema version 2. insert some data\nopen the db with Room\nverify that the data is correct\nclose the database and release any stream resources when the test finishes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/results/ResultMatchers.java",
    "type": "method",
    "name": "hasSingleFailureContaining",
    "code": "public static Matcher<Object> hasSingleFailureContaining(final String string) {\n        return new BaseMatcher<Object>() {\n\n            public void describeTo(Description description) {\n                description.appendText(\"has single failure containing \" + string);\n            }\n        };\n    }",
    "comment": "Matches if the result has exactly one failure, and it contains {@code string}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/VersionsMetadataGeneratorFactory.java",
    "type": "method",
    "name": "newInstance",
    "code": "public MetadataGenerator newInstance(RepositorySystemSession session, InstallRequest request) {\n        return new VersionsMetadataGenerator(session, request);\n    }",
    "comment": "Maven GA level metadata generator factory.\n\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/runners/model/TestClassTest.java",
    "type": "method",
    "name": "hasHashCodeWithoutJavaClass",
    "code": "public void hasHashCodeWithoutJavaClass() {\n        TestClass testClass = new TestClass(null);\n        testClass.hashCode();\n    }",
    "comment": "everything is fine if no exception is thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/Promise.java",
    "type": "method",
    "name": "ConsumeAction",
    "code": "private ConsumeAction(Promise<T> src, Promise<Void> dest, Consumer<? super T> action) {\n      this.src = src;\n      this.dest = dest;\n      this.action = action;\n    }",
    "comment": "Accesses the value from source promise and calls the consumer, then fulfills the destination\npromise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/entity/Train.java",
    "type": "method",
    "name": "Train",
    "code": "public Train(String manufacturer, String model, int noOfPassengers, int noOfCarriages) {\n    super(manufacturer, model, noOfPassengers);\n    this.noOfCarriages = noOfCarriages;\n  }",
    "comment": "A class that extends the PassengerVehicle class and provides the concrete inheritance\nimplementation of the Car.\n\n@see PassengerVehicle PassengerVehicle\n@see Vehicle Vehicle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/TensorFlow.java",
    "type": "method",
    "name": "loadLibrary",
    "code": "public static byte[] loadLibrary(String filename) {\n    long h = 0;\n    try {\n      h = libraryLoad(filename);\n    } catch (RuntimeException e) {\n      throw new UnsatisfiedLinkError(e.getMessage());\n    }\n    try {\n      return libraryOpList(h);\n    } finally {\n      libraryDelete(h);\n    }\n  }",
    "comment": "Load the dynamic library in filename and register the operations and kernels present in that\nlibrary.\n\n@param filename Path of the dynamic library containing operations and kernels to load.\n@return Serialized bytes of the <a\nhref=\"https://www.tensorflow.org/code/tensorflow/core/framework/op_def.proto\">OpList</a>\nprotocol buffer message defining the operations defined in the library.\n@throws UnsatisfiedLinkError if filename cannot be loaded."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "displayName",
    "code": "public static Condition<Event> displayName(String displayName) {\n\t\treturn new Condition<>(byTestDescriptor(where(TestDescriptor::getDisplayName, isEqual(displayName))),\n\t\t\t\"descriptor with display name '%s'\", displayName);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if the\n{@link Event}'s {@linkplain Event#getTestDescriptor() test descriptor}\nis equal to the supplied {@link String}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/resolver/conflict/OldestConflictResolver.java",
    "type": "method",
    "name": "resolveConflict",
    "code": "public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2) {\n        try {\n            ArtifactVersion version1 = node1.getArtifact().getSelectedVersion();\n            ArtifactVersion version2 = node2.getArtifact().getSelectedVersion();\n\n            return version1.compareTo(version2) <= 0 ? node1 : node2;\n        } catch (OverConstrainedVersionException exception) {\n            // TODO log message or throw exception?\n\n            return null;\n        }\n    }",
    "comment": "Resolves conflicting artifacts by always selecting the <em>oldest</em> declaration. Oldest is defined as the\ndeclaration whose version is less according to <code>ArtifactVersion.compareTo</code>.\n\n@see ArtifactVersion#compareTo\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/AlbumListPage.java",
    "type": "method",
    "name": "selectAlbum",
    "code": "public AlbumPage selectAlbum(String albumTitle) {\n    // uses XPath to find list of html anchor tags with the class album in it\n    var albumLinks = (List<HtmlAnchor>) page.getByXPath(\"//tr[@class='album']//a\");\n    for (var anchor : albumLinks) {\n      if (anchor.getTextContent().equals(albumTitle)) {\n        try {\n          anchor.click();\n          return new AlbumPage(webClient);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n    }\n    throw new IllegalArgumentException(\"No links with the album title: \" + albumTitle);\n  }",
    "comment": "Selects an album by the given album title\n\n@param albumTitle the title of the album to click\n@return the album page"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactResolver.java",
    "type": "method",
    "name": "run",
    "code": "public void run() {\n            ClassLoader old = Thread.currentThread().getContextClassLoader();\n            try {\n                Thread.currentThread().setContextClassLoader(classLoader);\n                resolve(artifact, remoteRepositories, session);\n            } catch (ArtifactNotFoundException anfe) {\n\n                synchronized (result) {\n                    result.addMissingArtifact(artifact);\n                }\n            } catch (ArtifactResolutionException e) {\n\n                synchronized (result) {\n                    result.addErrorArtifactException(e);\n                }\n            } finally {\n                latch.countDown();\n                Thread.currentThread().setContextClassLoader(old);\n            }\n        }",
    "comment": "These are cases where the artifact just isn't present in any of the remote repositories\nbecause it wasn't deployed, or it was deployed in the wrong place.\nThis is really a wagon TransferFailedException so something went wrong after we successfully\nretrieved the metadata."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectDirectory",
    "code": "public static DirectorySelector selectDirectory(File directory) {\n\t\tPreconditions.notNull(directory, \"Directory must not be null\");\n\t\tPreconditions.condition(directory.isDirectory(),\n\t\t\t() -> String.format(\"The supplied java.io.File [%s] must represent an existing directory\", directory));\n\t\ttry {\n\t\t\treturn new DirectorySelector(directory.getCanonicalPath());\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new PreconditionViolationException(\"Failed to retrieve canonical path for directory: \" + directory,\n\t\t\t\tex);\n\t\t}\n\t}",
    "comment": "Create a {@code DirectorySelector} for the supplied {@linkplain File directory}.\n\n<p>This method selects the directory in its {@linkplain File#getCanonicalPath()\ncanonical} form and throws a {@link PreconditionViolationException} if the\ndirectory does not exist.\n\n@param directory the directory to select; never {@code null}\n@see DirectorySelector\n@see #selectDirectory(String)\n@see #selectFile(String)\n@see #selectFile(File)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/crypto/AuthEngineSuite.java",
    "type": "method",
    "name": "getConf",
    "code": "static TransportConf getConf(int authEngineVerison, boolean useCtr) {\n    String authEngineVersion = (authEngineVerison == 1) ? \"1\" : \"2\";\n    String mode = useCtr ? \"AES/CTR/NoPadding\" : \"AES/GCM/NoPadding\";\n    Map<String, String> confMap = ImmutableMap.of(\n            \"spark.network.crypto.enabled\", \"true\",\n            \"spark.network.crypto.authEngineVersion\", authEngineVersion,\n            \"spark.network.crypto.cipher\", mode\n    );\n    ConfigProvider v2Provider = new MapConfigProvider(confMap);\n    return new TransportConf(\"rpc\", v2Provider);\n  }",
    "comment": "This key would have been derived for version 1.0 protocol that did not run a final HKDF round."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProfileActivation.java",
    "type": "method",
    "name": "addProfileActivation",
    "code": "public void addProfileActivation(String id, boolean active, boolean optional) {\n        final ActivationSettings settings = ActivationSettings.of(active, optional);\n        this.activations.put(id, settings);\n    }",
    "comment": "Adds a profile activation to the request.\n@param id The identifier of the profile.\n@param active Should the profile be activated?\n@param optional Can the build continue if the profile does not exist?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenFailOnSeverityLogger.java",
    "type": "method",
    "name": "warn",
    "code": "public void warn(String format, Object... argArray) {\n        super.warn(format, argArray);\n        logLevelRecorder.record(Level.WARN);\n    }",
    "comment": "Perform double parameter substitution before logging the message of level\nWARN according to the format outlined above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/Logger.java",
    "type": "method",
    "name": "error",
    "code": "default void error(@Nonnull String message, @Nullable Throwable error) {\n        log(Level.ERROR, message, error);\n    }",
    "comment": "Logs an error message with an associated exception.\n\n@param message the error message to be logged\n@param error the associated exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/ovic/demo/app/OvicBenchmarkerActivity.java",
    "type": "method",
    "name": "onCreate",
    "code": "protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    // TextView used to display the progress, for information purposes only.\n    textView = (TextView) findViewById(R.id.textView);\n  }",
    "comment": "private static final int WAIT_TIME_FOR_AFFINITY = 1000;\n\n/* The model to be benchmarked."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/test/java/com/example/android/persistence/migrations/UserRepositoryTest.java",
    "type": "method",
    "name": "getUserWithNoUserInDataSource",
    "code": "public void getUserWithNoUserInDataSource() {\n        LoadUserCallback callback = mock(LoadUserCallback.class);\n        when(mUserDataSource.getUser()).thenReturn(null);\n\n        mUserRepository.getUser(callback);\n\n        verify(mUserDataSource).getUser();\n        verify(callback).onDataNotAvailable();\n    }",
    "comment": "Given a callback for loading the user\nAnd no user in the data source\nWhen requesting a user from the repository\nThe user is requested from the user data source\nand the callback triggers correct method"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/DebugResolutionListener.java",
    "type": "method",
    "name": "DebugResolutionListener",
    "code": "public DebugResolutionListener(Logger logger) {\n        this.logger = logger;\n    }",
    "comment": "Send resolution events to the debug log."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "redirectOutput",
    "code": "public SparkLauncher redirectOutput(File outFile) {\n    outputStream = ProcessBuilder.Redirect.to(outFile);\n    return this;\n  }",
    "comment": "Redirects error output to the specified File.\n\n@param outFile The file to which stdout is written.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/TensorImpl.java",
    "type": "method",
    "name": "fromIndex",
    "code": "static TensorImpl fromIndex(long nativeInterpreterHandle, int tensorIndex) {\n    return new TensorImpl(create(nativeInterpreterHandle, tensorIndex, /*subgraphIndex=*/ 0));\n  }",
    "comment": "Creates a Tensor wrapper from the provided interpreter instance and tensor index.\n\n<p>The caller is responsible for closing the created wrapper, and ensuring the provided native\ninterpreter is valid until the tensor is closed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaDatasetSuite.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n    spark = new TestSparkSession();\n    jsc = new JavaSparkContext(spark.sparkContext());\n    spark.loadTestData();\n\n    spark.streams().stateStoreCoordinator();\n  }",
    "comment": "Trigger static initializer of TestData\nInitialize state store coordinator endpoint"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/main/java/com/iluwatar/RegisterWorkerDto.java",
    "type": "method",
    "name": "setupWorkerDto",
    "code": "public void setupWorkerDto(String name, String occupation, LocalDate dateOfBirth) {\n    this.name = name;\n    this.occupation = occupation;\n    this.dateOfBirth = dateOfBirth;\n  }",
    "comment": "Simple set up function for capturing our worker information.\n\n@param name Name of the worker\n@param occupation occupation of the worker\n@param dateOfBirth Date of Birth of the worker"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, boolean expected, boolean actual) {\n        assertEquals(message, Boolean.valueOf(expected), Boolean.valueOf(actual));\n    }",
    "comment": "Asserts that two booleans are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/KVStoreView.java",
    "type": "method",
    "name": "reverse",
    "code": "public KVStoreView<T> reverse() {\n    ascending = !ascending;\n    return this;\n  }",
    "comment": "Reverses the order of iteration. By default, iterates in ascending order."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/shuffle/sort/PackedRecordPointerSuite.java",
    "type": "method",
    "name": "partitionIdsGreaterThanMaximumPartitionIdWillOverflowOrTriggerError",
    "code": "public void partitionIdsGreaterThanMaximumPartitionIdWillOverflowOrTriggerError() {\n    PackedRecordPointer packedPointer = new PackedRecordPointer();\n    assertThrows(AssertionError.class,\n      () -> packedPointer.set(PackedRecordPointer.packPointer(0, MAXIMUM_PARTITION_ID + 1)));\n    assertNotEquals(MAXIMUM_PARTITION_ID + 1, packedPointer.getPartitionId());\n  }",
    "comment": "Pointers greater than the maximum partition ID will overflow or trigger an assertion error"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, double actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/main/java/org/apache/hadoop/hive/ql/exec/HiveFunctionRegistryUtils.java",
    "type": "method",
    "name": "if",
    "code": "for (Method m : mlist) {\n      List<TypeInfo> argumentsAccepted = TypeInfoUtils.getParameterTypeInfos(m,\n          argumentsPassed.size());\n      if (argumentsAccepted == null) {\n        // null means the method does not accept number of arguments passed.\n        continue;\n      }\n\n      boolean match = (argumentsAccepted.size() == argumentsPassed.size());\n      int conversionCost = 0;\n\n      for (int i = 0; i < argumentsPassed.size() && match; i++) {\n        int cost = matchCost(argumentsPassed.get(i), argumentsAccepted.get(i), exact);\n        if (cost == -1) {\n          match = false;\n        } else {\n          conversionCost += cost;\n        }\n      }\n\n      LOG.debug(\"Method {} match: passed = {} accepted = {} method = {}\",\n          match ? \"did\" : \"didn't\", argumentsPassed, argumentsAccepted, m);\n\n      if (match) {\n        // Always choose the function with least implicit conversions.\n        if (conversionCost < leastConversionCost) {\n          udfMethods.clear();\n          udfMethods.add(m);\n          leastConversionCost = conversionCost;\n          // Found an exact match\n          if (leastConversionCost == 0) {\n            break;\n          }\n        } else if (conversionCost == leastConversionCost) {\n          // Ambiguous call: two methods with the same number of implicit\n          // conversions\n          udfMethods.add(m);\n          // Don't break! We might find a better match later.\n        } else {\n          // do nothing if implicitConversions > leastImplicitConversions\n        }\n      }\n    }",
    "comment": "Gets the closest matching method corresponding to the argument list from a\nlist of methods.\n\n@param mlist\nThe list of methods to inspect.\n@param exact\nBoolean to indicate whether this is an exact match or not.\n@param argumentsPassed\nThe classes for the argument.\n@return The matching method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/results/ResultMatchers.java",
    "type": "method",
    "name": "failureCountIs",
    "code": "public static Matcher<PrintableResult> failureCountIs(final int count) {\n        return new TypeSafeMatcher<PrintableResult>() {\n\n            @Override\n            public boolean matchesSafely(PrintableResult item) {\n                return item.failureCount() == count;\n            }\n        };\n    }",
    "comment": "Matches if there are {@code count} failures"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TerminationInfo.java",
    "type": "method",
    "name": "executed",
    "code": "public static TerminationInfo executed(TestExecutionResult testExecutionResult) {\n\t\tPreconditions.notNull(testExecutionResult, \"TestExecutionResult must not be null\");\n\t\treturn new TerminationInfo(false, null, testExecutionResult);\n\t}",
    "comment": "Create an <em>executed</em> {@code TerminationInfo} instance for the\nsupplied {@link TestExecutionResult}.\n\n@param testExecutionResult the result of the execution; never {@code null}\n@return the created {@code TerminationInfo}; never {@code null}\n@see #skipped(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/ByteUnit.java",
    "type": "method",
    "name": "convertTo",
    "code": "public long convertTo(long d, ByteUnit u) {\n    if (multiplier > u.multiplier) {\n      long ratio = multiplier / u.multiplier;\n      if (Long.MAX_VALUE / ratio < d) {\n        throw new IllegalArgumentException(\"Conversion of \" + d + \" exceeds Long.MAX_VALUE in \"\n          + name() + \". Try a larger unit (e.g. MiB instead of KiB)\");\n      }\n      return d * ratio;\n    } else {\n      return d / (u.multiplier / multiplier);\n    }\n  }",
    "comment": "Convert the provided number (d) interpreted as this unit type to unit type (u).\nPerform operations in this order to avoid potential overflow\nwhen computing d * multiplier"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/LoginPage.java",
    "type": "method",
    "name": "enterPassword",
    "code": "public LoginPage enterPassword(String password) {\n    var passwordInputPasswordField = (HtmlPasswordInput) page.getElementById(\"password\");\n    passwordInputPasswordField.setText(password);\n    return this;\n  }",
    "comment": "Enters the password into the password input password field.\n\n@param password the password to enter\n@return {@link LoginPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/test/java/org/apache/maven/artifact/versioning/ComparableVersionTest.java",
    "type": "method",
    "name": "testCompareLowerCaseToUpperCaseNonASCII",
    "code": "void testCompareLowerCaseToUpperCaseNonASCII() {\n        ComparableVersion lower = new ComparableVersion(\"1.\");\n        ComparableVersion upper = new ComparableVersion(\"1.\");\n        assertTrue(upper.compareTo(lower) == 0, \"expected 1. < 1.\");\n        assertTrue(lower.compareTo(upper) == 0, \"expected 1. > 1.\");\n    }",
    "comment": "Lower case is equal to upper case"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "redirectToLog",
    "code": "public SparkLauncher redirectToLog(String loggerName) {\n    setConf(CHILD_PROCESS_LOGGER_NAME, loggerName);\n    return this;\n  }",
    "comment": "Sets all output to be logged and redirected to a logger with the specified name.\n\n@param loggerName The name of the logger to log stdout and stderr.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "getSpaceTrimming",
    "code": "protected static SpaceTrimming getSpaceTrimming(int collationId) {\n        return SpaceTrimming.values()[SpecifierUtils.getSpecValue(collationId,\n          SPACE_TRIMMING_OFFSET, SPACE_TRIMMING_MASK)];\n      }",
    "comment": "Utility function to retrieve `SpaceTrimming` enum instance from collation ID."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "convertAscii",
    "code": "private UTF8String convertAscii(Function<Character, Character> charConverter) {\n    byte[] bytes = new byte[numBytes];\n    for (int i = 0; i < numBytes; i++) {\n        bytes[i] = (byte) charConverter.apply((char) getByte(i)).charValue();\n    }\n    return fromBytes(bytes);\n  }",
    "comment": "Method for ASCII character conversion using a functional interface for chars."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlanExecutor.java",
    "type": "method",
    "name": "computeForkPlan",
    "code": "protected BuildPlan computeForkPlan(BuildStep step, MojoExecution execution, BuildPlan buildPlan) {\n            MojoDescriptor mojoDescriptor = execution.getMojoDescriptor();\n            PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();\n            String forkedGoal = mojoDescriptor.getExecuteGoal();\n            String phase = mojoDescriptor.getExecutePhase();\n            if (forkedGoal != null && !forkedGoal.isEmpty()) {\n                MojoDescriptor forkedMojoDescriptor = pluginDescriptor.getMojo(forkedGoal);\n                if (forkedMojoDescriptor == null) {\n                    throw new MavenException(new MojoNotFoundException(forkedGoal, pluginDescriptor));\n                }\n\n                List<MavenProject> toFork = new ArrayList<>();\n                toFork.add(step.project);\n                if (mojoDescriptor.isAggregator() && step.project.getCollectedProjects() != null) {\n                    toFork.addAll(step.project.getCollectedProjects());\n                }\n\n                BuildPlan plan = new BuildPlan();\n                for (MavenProject project : toFork) {\n                    BuildStep st = new BuildStep(forkedGoal, project, null);\n                    MojoExecution mojoExecution = new MojoExecution(forkedMojoDescriptor, forkedGoal);\n                    st.addMojo(mojoExecution, 0);\n                    Map<String, BuildStep> n = new HashMap<>();\n                    n.put(forkedGoal, st);\n                    plan.addProject(project, n);\n                }\n\n                for (BuildStep astep : plan.allSteps().toList()) {\n                    for (MojoExecution aexecution : astep.executions().toList()) {\n                        plan = computeForkPlan(astep, aexecution, plan);\n                    }\n                }\n\n                return plan;\n\n            } else if (phase != null && !phase.isEmpty()) {\n                String forkedLifecycle = mojoDescriptor.getExecuteLifecycle();\n                Lifecycle lifecycle;\n                if (forkedLifecycle != null && !forkedLifecycle.isEmpty()) {\n                    org.apache.maven.api.plugin.descriptor.lifecycle.Lifecycle lifecycleOverlay;\n                    try {\n                        lifecycleOverlay = pluginDescriptor.getLifecycleMapping(forkedLifecycle);\n                    } catch (IOException | XMLStreamException e) {\n                        throw new MavenException(new PluginDescriptorParsingException(\n                                pluginDescriptor.getPlugin(), pluginDescriptor.getSource(), e));\n                    }\n                    if (lifecycleOverlay == null) {\n                        Optional<Lifecycle> lf = lifecycles.lookup(forkedLifecycle);\n                        if (lf.isPresent()) {\n                            lifecycle = lf.get();\n                        } else {\n                            throw new MavenException(new LifecycleNotFoundException(forkedLifecycle));\n                        }\n                    } else {\n                        lifecycle = new PluginLifecycle(lifecycleOverlay, pluginDescriptor);\n                    }\n                } else {\n                    if (execution.getLifecyclePhase() != null) {\n                        String n = execution.getLifecyclePhase();\n                        String phaseName = n.startsWith(BEFORE)\n                                ? n.substring(BEFORE.length())\n                                : n.startsWith(AFTER) ? n.substring(AFTER.length()) : n;\n                        lifecycle = lifecycles.stream()\n                                .filter(l -> l.allPhases().anyMatch(p -> phaseName.equals(p.name())))\n                                .findFirst()\n                                .orElse(null);\n                        if (lifecycle == null) {\n                            throw new IllegalStateException();\n                        }\n                    } else {\n                        lifecycle = lifecycles.require(Lifecycle.DEFAULT);\n                    }\n                }\n\n                String resolvedPhase = getResolvedPhase(lifecycle, phase);\n\n                Map<MavenProject, List<MavenProject>> map = Collections.singletonMap(\n                        step.project, plan.getAllProjects().get(step.project));\n                BuildPlan forkedPlan = calculateLifecycleMappings(map, lifecycle, resolvedPhase);\n                forkedPlan.then(buildPlan);\n                return forkedPlan;\n            } else {\n                return buildPlan;\n            }\n        }",
    "comment": "We have a fork goal"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "dynamicTestRegistered",
    "code": "public static Event dynamicTestRegistered(TestDescriptor testDescriptor) {\n\t\treturn new Event(EventType.DYNAMIC_TEST_REGISTERED, testDescriptor, null);\n\t}",
    "comment": "Create an {@code Event} for the dynamic registration of the\nsupplied {@link TestDescriptor}.\n\n@param testDescriptor the {@code TestDescriptor} associated with the event;\nnever {@code null}\n@return the newly created {@code Event}\n@see EventType#DYNAMIC_TEST_REGISTERED"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "not",
    "code": "public Object not(List<Object> args) {\n        if (args.size() != 1) {\n            throw new IllegalArgumentException(\"not function requires exactly one argument\");\n        }\n        return !ConditionParser.toBoolean(args.get(0));\n    }",
    "comment": "Negates a boolean value.\n\n@param args A list containing a single boolean argument\n@return The negation of the input boolean\n@throws IllegalArgumentException if the number of arguments is not exactly one"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/AlbumPage.java",
    "type": "method",
    "name": "changeAlbumYear",
    "code": "public AlbumPage changeAlbumYear(int year) {\n    var albumYearSelectOption = (HtmlSelect) page.getElementById(\"albumYear\");\n    var yearOption = albumYearSelectOption.getOptionByValue(Integer.toString(year));\n    albumYearSelectOption.setSelectedAttribute(yearOption, true);\n    return this;\n  }",
    "comment": "Selects the select's option value based on the year value given\n\n@param year the new year value to set\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/ExternalShuffleCleanupSuite.java",
    "type": "method",
    "name": "assertStillThere",
    "code": "private static void assertStillThere(TestShuffleDataContext dataContext) {\n    for (String localDir : dataContext.localDirs) {\n      assertTrue(new File(localDir).exists(), localDir + \" was cleaned up prematurely\");\n    }\n  }",
    "comment": "Same-thread Executor used to ensure cleanup happens synchronously in test thread.\nExecutor which does nothing to ensure we're actually using it.\nMake sure it's not an error to cleanup multiple times"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassLoaderUtils.java",
    "type": "method",
    "name": "getLocation",
    "code": "public static Optional<URL> getLocation(Object object) {\n\t\tPreconditions.notNull(object, \"object must not be null\");\n\t\t// determine class loader\n\t\tClassLoader loader = object.getClass().getClassLoader();\n\t\tif (loader == null) {\n\t\t\tloader = ClassLoader.getSystemClassLoader();\n\t\t\twhile (loader != null && loader.getParent() != null) {\n\t\t\t\tloader = loader.getParent();\n\t\t\t}\n\t\t}\n\t\t// try finding resource by name\n\t\tif (loader != null) {\n\t\t\tString name = object.getClass().getName();\n\t\t\tname = name.replace(\".\", \"/\") + \".class\";\n\t\t\ttry {\n\t\t\t\treturn Optional.ofNullable(loader.getResource(name));\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(t);\n\t\t\t\t/* otherwise ignore */\n\t\t\t}\n\t\t}\n\t\t// try protection domain\n\t\ttry {\n\t\t\tCodeSource codeSource = object.getClass().getProtectionDomain().getCodeSource();\n\t\t\tif (codeSource != null) {\n\t\t\t\treturn Optional.ofNullable(codeSource.getLocation());\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ignore) {\n\t\t\t/* ignore */\n\t\t}\n\t\treturn Optional.empty();\n\t}",
    "comment": "Get the location from which the supplied object's class was loaded.\n\n@param object the object for whose class the location should be retrieved\n@return an {@code Optional} containing the URL of the class' location; never\n{@code null} but potentially empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(boolean condition) {\n        assertTrue(null, condition);\n    }",
    "comment": "Asserts that a condition is true. If it isn't it throws an\n{@link AssertionError} without a message.\n\n@param condition condition to be checked"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/server/HiveServer2.java",
    "type": "method",
    "name": "execute",
    "code": "public void execute() {\n      try {\n        startHiveServer2();\n      } catch (Throwable t) {\n        LOG.error(\"Error starting HiveServer2\", t);\n        System.exit(-1);\n      }\n    }",
    "comment": "StartOptionExecutor: starts HiveServer2.\nThis is the default executor, when no option is specified."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "toUpperCase",
    "code": "public static UTF8String toUpperCase(final UTF8String target) {\n    if (target.isFullAscii()) return target.toUpperCaseAscii();\n    return toUpperCaseSlow(target);\n  }",
    "comment": "Convert the input string to uppercase using the ICU root locale rules.\n\n@param target the input string\n@return the uppercase string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantBuilder.java",
    "type": "method",
    "name": "VariantBuilder",
    "code": "public VariantBuilder(boolean allowDuplicateKeys) {\n    this.allowDuplicateKeys = allowDuplicateKeys;\n  }",
    "comment": "Build variant value and metadata by parsing JSON values."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-settings-builder/src/main/java/org/apache/maven/settings/crypto/MavenSecDispatcher.java",
    "type": "method",
    "name": "MavenSecDispatcher",
    "code": "public MavenSecDispatcher(Map<String, Dispatcher> dispatchers) {\n        super(dispatchers, configurationFile());\n    }",
    "comment": "This class implements \"Maven specific\" {@link SecDispatcher}.\n\n@deprecated since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "finalizeShuffleMergeHandlerThreads",
    "code": "public int finalizeShuffleMergeHandlerThreads() {\n    if (!this.getModuleName().equalsIgnoreCase(\"shuffle\")) {\n      return 0;\n    }\n    Preconditions.checkArgument(separateFinalizeShuffleMerge(),\n        \"Please set spark.shuffle.server.finalizeShuffleMergeThreadsPercent to a positive value\");\n    int finalizeShuffleMergeThreadsPercent =\n        Integer.parseInt(conf.get(\"spark.shuffle.server.finalizeShuffleMergeThreadsPercent\"));\n    int threads =\n        this.serverThreads() > 0 ? this.serverThreads() : 2 * NettyRuntime.availableProcessors();\n    return (int) Math.ceil(threads * (finalizeShuffleMergeThreadsPercent / 100.0));\n  }",
    "comment": "Percentage of io.serverThreads used by netty to process FinalizeShuffleMerge. When the config\n`spark.shuffle.server.finalizeShuffleMergeThreadsPercent` is set, shuffle server will use a\nseparate EventLoopGroup to process FinalizeShuffleMerge messages, which are I/O intensive and\ncould take long time to process due to disk contentions. The number of threads used for\nhandling finalizeShuffleMerge requests are percentage of io.serverThreads (if defined) else it\nis a percentage of 2 * #cores."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(float[] expected, float[] actual, float delta) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, delta);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} float arrays are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3769ExclusionRelocatedTransdepsTest.java",
    "type": "method",
    "name": "MavenITmng3769ExclusionRelocatedTransdepsTest",
    "code": "public MavenITmng3769ExclusionRelocatedTransdepsTest() {\n        // also didn't work in 2.0, but did in 2.0.1+ until regressed in 2.1.0-M1\n        super(\"[2.0.1,2.1.0-M1),(2.1.0-M1,)\");\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3769\">MNG-3769</a>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/ClassMap.java",
    "type": "method",
    "name": "getPublicMethod",
    "code": "private static Method getPublicMethod(Method method) {\n        Class<?> clazz = method.getDeclaringClass();\n\n        // Short circuit for (hopefully the majority of) cases where the declaring\n        // class is public.\n        if ((clazz.getModifiers() & Modifier.PUBLIC) != 0) {\n            return method;\n        }\n\n        return getPublicMethod(clazz, method.getName(), method.getParameterTypes());\n    }",
    "comment": "For a given method, retrieves its publicly accessible counterpart.\nThis method will look for a method with same name\nand signature declared in a public superclass or implemented interface of this\nmethod's declaring class. This counterpart method is publicly callable.\n\n@param method a method whose publicly callable counterpart is requested.\n@return the publicly callable counterpart method. Note that if the parameter\nmethod is itself declared by a public class, this method is an identity\nfunction."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "getArray",
    "code": "public final ColumnarArray getArray(int rowId) {\n    if (isNullAt(rowId)) return null;\n    return new ColumnarArray(arrayData(), getArrayOffset(rowId), getArrayLength(rowId));\n  }",
    "comment": "`WritableColumnVector` puts the data of array in the first child column vector, and puts the\narray offsets and lengths in the current column vector."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertDoesNotThrow",
    "code": "public static <T> T assertDoesNotThrow(ThrowingSupplier<T> supplier) {\n\t\treturn AssertDoesNotThrow.assertDoesNotThrow(supplier);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code supplier} does\n<em>not</em> throw any kind of {@linkplain Throwable exception}.\n\n<p>If the assertion passes, the {@code supplier}'s result will be returned.\n\n<h4>Usage Note</h4>\n<p>Although any exception thrown from a test method will cause the test\nto <em>fail</em>, there are certain use cases where it can be beneficial\nto explicitly assert that an exception is not thrown for a given code\nblock within a test method.\n\n@since 5.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeExternalSorter.java",
    "type": "method",
    "name": "getMemoryUsage",
    "code": "private long getMemoryUsage() {\n    long totalPageSize = 0;\n    for (MemoryBlock page : allocatedPages) {\n      totalPageSize += page.size();\n    }\n    return ((inMemSorter == null) ? 0 : inMemSorter.getMemoryUsage()) + totalPageSize;\n  }",
    "comment": "Return the total memory usage of this sorter, including the data pages and the sorter's pointer\narray."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/arrange-act-assert/src/test/java/com/iluwatar/arrangeactassert/CashAntiAAATest.java",
    "type": "method",
    "name": "testCash",
    "code": "void testCash() {\n    // initialize\n    var cash = new Cash(3);\n    // test plus\n    cash.plus(4);\n    assertEquals(7, cash.count());\n    // test minus\n    cash = new Cash(8);\n    assertTrue(cash.minus(5));\n    assertEquals(3, cash.count());\n    assertFalse(cash.minus(6));\n    assertEquals(3, cash.count());\n    // test update\n    cash.plus(5);\n    assertTrue(cash.minus(5));\n    assertEquals(3, cash.count());\n  }",
    "comment": "({@link CashAAATest}) is an anti-example of AAA pattern. This test is functionally correct, but\nwith the addition of a new feature, it needs refactoring. There are an awful lot of steps in that\ntest method, but it verifies the class' important behavior in just eleven lines. It violates the\nsingle responsibility principle. If this test method failed after a small code change, it might\ntake some digging to discover why."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/TensorImpl.java",
    "type": "method",
    "name": "fromSignatureInput",
    "code": "static TensorImpl fromSignatureInput(long signatureRunnerHandle, String inputName) {\n    long tensorHandle = createSignatureInputTensor(signatureRunnerHandle, inputName);\n    if (tensorHandle == -1) {\n      throw new IllegalArgumentException(\"Input error: input \" + inputName + \" not found.\");\n    } else {\n      return new TensorImpl(tensorHandle);\n    }\n  }",
    "comment": "Creates a Tensor wrapper for a Signature input.\n\n<p>The caller is responsible for closing the created wrapper, and ensuring the provided native\nSignatureRunner is valid until the tensor is closed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaUserDefinedScalar.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"Java Spark SQL UDF scalar example\")\n      .getOrCreate();\n\n    UserDefinedFunction random = udf(\n      () -> Math.random(), DataTypes.DoubleType\n    );\n    random.asNondeterministic();\n    spark.udf().register(\"random\", random);\n    spark.sql(\"SELECT random()\").show();\n\n    spark.udf().register(\"plusOne\",\n      (UDF1<Integer, Integer>) x -> x + 1, DataTypes.IntegerType);\n    spark.sql(\"SELECT plusOne(5)\").show();\n\n    UserDefinedFunction strLen = udf(\n      (String s, Integer x) -> s.length() + x, DataTypes.IntegerType\n    );\n    spark.udf().register(\"strLen\", strLen);\n    spark.sql(\"SELECT strLen('test', 1)\").show();\n\n    spark.udf().register(\"oneArgFilter\",\n      (UDF1<Long, Boolean>) x -> x > 5, DataTypes.BooleanType);\n    spark.range(1, 10).createOrReplaceTempView(\"test\");\n    spark.sql(\"SELECT * FROM test WHERE oneArgFilter(id)\").show();\n\n    spark.stop();\n  }",
    "comment": "$example on:udf_scalar$\n$example off:udf_scalar$\n$example on:udf_scalar$\nDefine and register a zero-argument non-deterministic UDF\nUDF is deterministic by default, i.e. produces the same result for the same input.\n+-------+\n|UDF()  |\n+-------+\n|xxxxxxx|\n+-------+\nDefine and register a one-argument UDF\n+----------+\n|plusOne(5)|\n+----------+\n|         6|\n+----------+\nDefine and register a two-argument UDF\n+------------+\n|UDF(test, 1)|\n+------------+\n|           5|\n+------------+\nUDF in a WHERE clause\n+---+\n| id|\n+---+\n|  6|\n|  7|\n|  8|\n|  9|\n+---+\n$example off:udf_scalar$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/JavaPathType.java",
    "type": "method",
    "name": "option",
    "code": "public String[] option(Iterable<? extends Path> paths) {\n        return format(null, paths);\n    }",
    "comment": "Returns the option followed by a string representation of the given path elements.\nFor example, if this type is {@link #MODULES}, then the option is {@code \"--module-path\"}\nfollowed by the specified path elements.\n\n@param paths the path to format as a tool option\n@return the option associated to this path type followed by the given path elements,\nor an empty array if there is no path element\n@throws IllegalStateException if no option is associated to this path type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java",
    "type": "method",
    "name": "supportsParameter",
    "code": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn parameterContext.isAnnotated(TempDir.class);\n\t}",
    "comment": "Determine if the {@link Parameter} in the supplied {@link ParameterContext}\nis annotated with {@link TempDir @TempDir}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/test/java/org/apache/spark/util/kvstore/DBIteratorSuite.java",
    "type": "method",
    "name": "fallback",
    "code": "default BaseComparator fallback() {\n      return (t1, t2) -> {\n        int result = BaseComparator.this.compare(t1, t2);\n        if (result != 0) {\n          return result;\n        }\n\n        return t1.key.compareTo(t2.key);\n      };\n    }",
    "comment": "Returns a comparator that falls back to natural order if this comparator's ordering\nreturns equality for two elements. Used to mimic how the index sorts things internally."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotNull",
    "code": "public static void assertNotNull(Object actual) {\n\t\tAssertNotNull.assertNotNull(actual);\n\t}",
    "comment": "<em>Assert</em> that {@code actual} is not {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "ioRetryWaitTimeMs",
    "code": "public int ioRetryWaitTimeMs() {\n    return (int) JavaUtils.timeStringAsSec(conf.get(SPARK_NETWORK_IO_RETRYWAIT_KEY, \"5s\")) * 1000;\n  }",
    "comment": "Time (in milliseconds) that we will wait in order to perform a retry after an IOException.\nOnly relevant if maxIORetries &gt; 0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4361ForceDependencySnapshotUpdateTest.java",
    "type": "method",
    "name": "assertChecksum",
    "code": "private void assertChecksum(String checksum, String jar, Properties checksums) {\n        assertEquals(checksum, checksums.getProperty(jar, \"\").toLowerCase(java.util.Locale.ENGLISH));\n    }",
    "comment": "Verify that snapshot updates of dependencies can be forced from the command line via \"-U\". In more detail,\nthis means updating the JAR and its accompanying hierarchy of POMs.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleConfigurationTests.java",
    "type": "method",
    "name": "instancePerClassConfiguredViaConfigParam",
    "code": "void instancePerClassConfiguredViaConfigParam() {\n\t\tClass<?> testClass = AssumedInstancePerClassTestCase.class;\n\n\t\tperformAssertions(testClass, 1, 1, 0);\n\n\t\tperformAssertions(testClass, singletonMap(KEY, PER_CLASS.name()), 2, 0, 1, \"beforeAll\", \"test\", \"afterAll\");\n\t}",
    "comment": "Should fail by default...\nShould pass with the config param"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, float actual, float delta) {\n        assertEquals(null, expected, actual, delta);\n    }",
    "comment": "Asserts that two floats are equal concerning a delta. If the expected\nvalue is infinity then the delta value is ignored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/testFixtures/java/org/junit/platform/commons/test/TestClassLoader.java",
    "type": "method",
    "name": "forClassNamePrefix",
    "code": "public static TestClassLoader forClassNamePrefix(String prefix) {\n\t\treturn new TestClassLoader(getCodeSourceUrl(stackWalker.getCallerClass()), name -> name.startsWith(prefix));\n\t}",
    "comment": "Create a {@link TestClassLoader} that filters classes whose fully\nqualified names start with the provided prefix.\n\n@see #forClasses(Class...)\n@see #forClasses(List)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/checksum/ShuffleChecksumHelper.java",
    "type": "method",
    "name": "getChecksumFileName",
    "code": "public static String getChecksumFileName(String blockName, String algorithm) {\n    return String.format(\"%s.%s\", blockName, algorithm);\n  }",
    "comment": "append the shuffle checksum algorithm as the file extension"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/TestEngineTests.java",
    "type": "method",
    "name": "defaults",
    "code": "void defaults() {\n\t\tTestEngine engine = new DefaultEngine();\n\t\tassertEquals(Optional.empty(), engine.getGroupId());\n\t\tassertEquals(Optional.empty(), engine.getArtifactId());\n\t\tassertEquals(Optional.of(\"DEVELOPMENT\"), engine.getVersion());\n\t}",
    "comment": "Test cases for default implementations of {@link org.junit.platform.engine.TestEngine}.\n\n<p>Note: the package {@code org.junit.platform} this class resides in is\nchosen on purpose. If it was in {@code org.junit.platform.engine} the default\nimplementation will pick up values defined by the real Jupiter test engine.\n\n@since 1.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java",
    "type": "method",
    "name": "getAllAssignmentCompatibleClassesWithNullClass",
    "code": "void getAllAssignmentCompatibleClassesWithNullClass() {\n\t\t\tassertThrows(PreconditionViolationException.class,\n\t\t\t\t() -> ReflectionUtils.getAllAssignmentCompatibleClasses(null));\n\t\t}",
    "comment": "Unit tests for {@link ReflectionUtils}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExternalBlockHandler.java",
    "type": "method",
    "name": "executorRemoved",
    "code": "public void executorRemoved(String executorId, String appId) {\n    blockManager.executorRemoved(executorId, appId);\n  }",
    "comment": "Clean up any non-shuffle files in any local directories associated with an finished executor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "addFile",
    "code": "public T addFile(String file) {\n    checkNotNull(file, \"file\");\n    builder.files.add(file);\n    return self();\n  }",
    "comment": "Adds a file to be submitted with the application.\n\n@param file Path to the file.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/util/V2ExpressionSQLBuilder.java",
    "type": "method",
    "name": "visitEndsWith",
    "code": "protected String visitEndsWith(String l, String r) {\n    String value = r.substring(1, r.length() - 1);\n    return l + \" LIKE '%\" + escapeSpecialCharsForLikePattern(value) + \"' ESCAPE '\\\\'\";\n  }",
    "comment": "Remove quotes at the beginning and end.\ne.g. converts \"'str'\" to \"str\"."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room3/java/com/example/android/persistence/migrations/UsersDatabase.java",
    "type": "method",
    "name": "Migration",
    "code": "static final Migration MIGRATION_1_4 = new Migration(1, 4) {\n    };",
    "comment": "Migrate from\nversion 1 - using the SQLiteDatabase API\nto\nversion 4 - using Room where {@link User} has a new field: {@link User#mDate} and"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java",
    "type": "method",
    "name": "constructFromClassWithInvalidAfterEachDeclaration",
    "code": "void constructFromClassWithInvalidAfterEachDeclaration() {\n\t\tClassTestDescriptor descriptor = new ClassTestDescriptor(uniqueId, TestCaseWithInvalidAfterEachMethod.class,\n\t\t\tconfiguration);\n\n\t\tassertEquals(TestCaseWithInvalidAfterEachMethod.class, descriptor.getTestClass());\n\t}",
    "comment": "Note: if we can instantiate the descriptor, then the invalid configuration\nwill not be reported during the test engine discovery phase."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/CountMinSketch.java",
    "type": "method",
    "name": "create",
    "code": "public static CountMinSketch create(int depth, int width, int seed) {\n    return new CountMinSketchImpl(depth, width, seed);\n  }",
    "comment": "Creates a {@link CountMinSketch} with given {@code depth}, {@code width}, and random\n{@code seed}.\n\n@param depth depth of the Count-min Sketch, must be positive\n@param width width of the Count-min Sketch, must be positive\n@param seed random seed"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroOptionalPrimitives.java",
    "type": "method",
    "name": "setMaybeFloatColumn",
    "code": "public void setMaybeFloatColumn(java.lang.Float value) {\n    this.maybe_float_column = value;\n  }",
    "comment": "Sets the value of the 'maybe_float_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/FilePosition.java",
    "type": "method",
    "name": "fromQuery",
    "code": "public static Optional<FilePosition> fromQuery(String query) {\n\t\tFilePosition result = null;\n\t\tInteger line = null;\n\t\tInteger column = null;\n\t\tif (StringUtils.isNotBlank(query)) {\n\t\t\ttry {\n\t\t\t\tfor (String pair : query.split(\"&\")) {\n\t\t\t\t\tString[] data = pair.split(\"=\");\n\t\t\t\t\tif (data.length == 2) {\n\t\t\t\t\t\tString key = data[0];\n\t\t\t\t\t\tif (line == null && \"line\".equals(key)) {\n\t\t\t\t\t\t\tline = Integer.valueOf(data[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (column == null && \"column\".equals(key)) {\n\t\t\t\t\t\t\tcolumn = Integer.valueOf(data[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Already found what we're looking for?\n\t\t\t\t\tif (line != null && column != null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tlogger.debug(ex, () -> \"Failed to parse 'line' and/or 'column' from query string: \" + query);\n\t\t\t\t// fall-through and continue\n\t\t\t}\n\n\t\t\tif (line != null) {\n\t\t\t\tresult = column == null ? new FilePosition(line) : new FilePosition(line, column);\n\t\t\t}\n\t\t}\n\t\treturn Optional.ofNullable(result);\n\t}",
    "comment": "Create an optional {@code FilePosition} by parsing the supplied\n{@code query} string.\n\n<p>Examples of valid {@code query} strings:\n<ul>\n<li>{@code \"line=23\"}</li>\n<li>{@code \"line=23&column=42\"}</li>\n</ul>\n\n@param query the query string; may be {@code null}\n@return an {@link Optional} containing a {@link FilePosition} with\nthe parsed line and column numbers; never {@code null} but potentially\nempty\n@since 1.3\n@see #from(int)\n@see #from(int, int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getInjectedProfileIds",
    "code": "public Map<String, List<String>> getInjectedProfileIds() {\n        return this.injectedProfileIds;\n    }",
    "comment": "Gets the identifiers of all profiles that contributed to this project's effective model. This includes active\nprofiles from the project's POM and all its parent POMs as well as from external sources like the\n{@code settings.xml}. The profile identifiers are grouped by the identifier of their source, e.g.\n{@code <groupId>:<artifactId>:<version>} for a POM profile or {@code external} for profiles from the\n{@code settings.xml}.\n\n@return The identifiers of all injected profiles, indexed by the source from which the profiles originated, never\n{@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/metadata/MetadataGraphEdge.java",
    "type": "method",
    "name": "equals",
    "code": "public boolean equals(Object o) {\n        if (o instanceof MetadataGraphEdge e) {\n            return objectsEqual(version, e.version)\n                    && ArtifactScopeEnum.checkScope(scope)\n                            .getScope()\n                            .equals(ArtifactScopeEnum.checkScope(e.scope).getScope())\n                    && depth == e.depth;\n        }\n        return false;\n    }",
    "comment": "used to eliminate exact duplicates in the edge list"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertLinesMatch.java",
    "type": "method",
    "name": "assertLinesMatchWithFastForward",
    "code": "void assertLinesMatchWithFastForward() {\n\t\t\tDeque<String> expectedDeque = new ArrayDeque<>(expectedLines);\n\t\t\tDeque<String> actualDeque = new ArrayDeque<>(actualLines);\n\n\t\t\tmain: while (!expectedDeque.isEmpty()) {\n\t\t\t\tString expectedLine = expectedDeque.pop();\n\t\t\t\tint expectedLineNumber = expectedLines.size() - expectedDeque.size(); // 1-based line number\n\t\t\t\tif (actualDeque.isEmpty()) {\n\t\t\t\t\tfail(\"expected line #%d:`%s` not found - actual lines depleted\", expectedLineNumber,\n\t\t\t\t\t\tsnippet(expectedLine));\n\t\t\t\t}\n\n\t\t\t\tString actualLine = actualDeque.peek();\n\t\t\t\tif (matches(expectedLine, actualLine)) {\n\t\t\t\t\tactualDeque.pop();\n\t\t\t\t\tcontinue; // main\n\t\t\t\t}\n\n\t\t\t\tif (isFastForwardLine(expectedLine)) {\n\t\t\t\t\tint fastForwardLimit = parseFastForwardLimit(expectedLine);\n\t\t\t\t\tint actualRemaining = actualDeque.size();\n\n\t\t\t\t\tif (expectedDeque.isEmpty()) {\n\t\t\t\t\t\tif (fastForwardLimit == Integer.MAX_VALUE || fastForwardLimit == actualRemaining) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfail(\"terminal fast-forward(%d) error: fast-forward(%d) expected\", fastForwardLimit,\n\t\t\t\t\t\t\tactualRemaining);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (fastForwardLimit != Integer.MAX_VALUE) {\n\t\t\t\t\t\tif (actualRemaining < fastForwardLimit) {\n\t\t\t\t\t\t\tfail(\"fast-forward(%d) error: not enough actual lines remaining (%s)\", fastForwardLimit,\n\t\t\t\t\t\t\t\tactualRemaining);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = 0; i < fastForwardLimit; i++) {\n\t\t\t\t\t\t\tactualDeque.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue; // main\n\t\t\t\t\t}\n\n\t\t\t\t\texpectedLine = expectedDeque.peek();\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tif (actualDeque.isEmpty()) {\n\t\t\t\t\t\t\tfail(\"fast-forward() didn't find: `%s`\", snippet(expectedLine));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (matches(expectedLine, actualDeque.peek())) {\n\t\t\t\t\t\t\tcontinue main;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tactualDeque.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint actualLineNumber = actualLines.size() - actualDeque.size() + 1; // 1-based line number\n\t\t\t\tfail(\"expected line #%d doesn't match actual line #%d%n\" + \"\\texpected: `%s`%n\" + \"\\t  actual: `%s`\",\n\t\t\t\t\texpectedLineNumber, actualLineNumber, expectedLine, actualLine);\n\t\t\t}\n\n\t\t\tif (!actualDeque.isEmpty()) {\n\t\t\t\tfail(\"more actual lines than expected: %d\", actualDeque.size());\n\t\t\t}\n\t\t}",
    "comment": "trivial case: no more actual lines available\ntrivial case: take the fast path when they match\nfast-forward marker found in expected line: fast-forward actual line...\ntrivial case: fast-forward marker was in last expected line\nno limit given or perfect match? we're done.\nfast-forward limit was given: use it\nfast-forward now: actualDeque.pop(fastForwardLimit)\npeek next expected line\nfast-forward \"unlimited\": until next match\nafter math"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/test/java/com/iluwatar/identitymap/PersonDbSimulatorImplementationTest.java",
    "type": "method",
    "name": "deleteInDb",
    "code": "void deleteInDb() {\n    PersonDbSimulatorImplementation db = new PersonDbSimulatorImplementation();\n    Person person1 = new Person(1, \"Thomas\", 27304159);\n    Person person2 = new Person(2, \"John\", 42273631);\n    db.insert(person1);\n    db.insert(person2);\n    db.delete(1);\n    Assertions.assertEquals(1, db.size(), \"Size after deletion is incorrect.\");\n    Assertions.assertThrows(IdNotFoundException.class, () -> db.find(1));\n  }",
    "comment": "delete the record.\ntest size of database after deletion.\ntry to find deleted record in db."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/DynamicTestsDemo.java",
    "type": "method",
    "name": "dynamicTestsFromArray",
    "code": "DynamicTest[] dynamicTestsFromArray() {\n\t\treturn new DynamicTest[] {\n\t}\n\n\t@TestFactory\n\tStream<DynamicTest> dynamicTestsFromStream() {\n\t\treturn Stream.of(\"racecar\", \"radar\", \"mom\", \"dad\")\n\t\t\t.map(text -> dynamicTest(text, () -> assertTrue(isPalindrome(text))));\n\t}\n\n\t@TestFactory\n\tStream<DynamicTest> dynamicTestsFromIntStream() {\n\t\treturn IntStream.iterate(0, n -> n + 2).limit(10)\n\t\t\t.mapToObj(n -> dynamicTest(\"test\" + n, () -> assertEquals(0, n % 2)));\n\t}\n\n\t@TestFactory\n\tStream<DynamicTest> generateRandomNumberOfTests() {\n\n\t\tIterator<Integer> inputGenerator = new Iterator<Integer>() {\n\t\t\tint current;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tcurrent = random.nextInt(100);\n\t\t\t\treturn current % 7 != 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Integer next() {\n\t\t\t\treturn current;\n\t\t\t}\n\t\t};\n\n\t\tFunction<Integer, String> displayNameGenerator = (input) -> \"input:\" + input;\n\n\t\tThrowingConsumer<Integer> testExecutor = (input) -> assertTrue(input % 7 != 0);\n\n\t\treturn DynamicTest.stream(inputGenerator, displayNameGenerator, testExecutor);\n\t}\n\n\t@TestFactory\n\tStream<DynamicTest> dynamicTestsFromStreamFactoryMethod() {\n\t\tStream<String> inputStream = Stream.of(\"racecar\", \"radar\", \"mom\", \"dad\");\n\n\t\tFunction<String, String> displayNameGenerator = text -> text + \" is a palindrome\";\n\n\t\tThrowingConsumer<String> testExecutor = text -> assertTrue(isPalindrome(text));\n\n\t\treturn DynamicTest.stream(inputStream, displayNameGenerator, testExecutor);\n\t}\n\n\t@TestFactory\n\tStream<DynamicNode> dynamicTestsWithContainers() {\n\t\treturn Stream.of(\"A\", \"B\", \"C\")\n\t\t\t.map(input -> dynamicContainer(\"Container \" + input, Stream.of(\n\t\t\t\tdynamicTest(\"not null\", () -> assertNotNull(input)),\n\t\t\t\tdynamicContainer(\"properties\", Stream.of(\n\t\t\t\t\tdynamicTest(\"length > 0\", () -> assertTrue(input.length() > 0)),\n\t\t\t\t\tdynamicTest(\"not empty\", () -> assertFalse(input.isEmpty()))\n\t\t\t\t))\n\t\t\t)));\n\t}\n\n\t@TestFactory\n\tDynamicNode dynamicNodeSingleTest() {\n\t\treturn dynamicTest(\"'pop' is a palindrome\", () -> assertTrue(isPalindrome(\"pop\")));\n\t}\n\n\t@TestFactory\n\tDynamicNode dynamicNodeSingleContainer() {\n\t\treturn dynamicContainer(\"palindromes\",\n\t\t\tStream.of(\"racecar\", \"radar\", \"mom\", \"dad\")\n\t\t\t\t.map(text -> dynamicTest(text, () -> assertTrue(isPalindrome(text)))\n\t\t));\n\t}\n}",
    "comment": "Generates tests for the first 10 even integers.\nGenerates random positive integers between 0 and 100 until\na number evenly divisible by 7 is encountered.\ntag::user_guide[]\nGenerates display names like: input:5, input:37, input:85, etc.\nExecutes tests based on the current input value.\nReturns a stream of dynamic tests.\nStream of palindromes to check\nGenerates display names like: racecar is a palindrome\nExecutes tests based on the current input value.\nReturns a stream of dynamic tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/UniqueIdTrackingListener.java",
    "type": "method",
    "name": "UniqueIdTrackingListener",
    "code": "public UniqueIdTrackingListener() {\n\t\t// to avoid missing-explicit-ctor warning\n\t}",
    "comment": "The default prefix for the name of the file generated by the\n{@code UniqueIdTrackingListener}: {@value}\n\n@see #OUTPUT_FILE_PREFIX_PROPERTY_NAME"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/exception/ExceptionSummary.java",
    "type": "method",
    "name": "ExceptionSummary",
    "code": "public ExceptionSummary(Throwable exception, String message, String reference) {\n        this(exception, message, reference, null);\n    }",
    "comment": "Provide a summary of the exception, containing:<ul>\n<li>the exception itself,</li>\n<li>useful end-user message,</li>\n<li>useful reference to a solution, or set of solutions: this is usually a wiki page url in\n<a href=\"http://cwiki.apache.org/confluence/display/MAVEN/\">http://cwiki.apache.org/confluence/display/MAVEN/</a>,\n</li>\n<li>child exception summaries.</li>\n</ul>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/metadata/SnapshotArtifactRepositoryMetadata.java",
    "type": "method",
    "name": "SnapshotArtifactRepositoryMetadata",
    "code": "public SnapshotArtifactRepositoryMetadata(Artifact artifact) {\n        super(createMetadata(artifact, null));\n        this.artifact = artifact;\n    }",
    "comment": "Metadata for the artifact version directory of the repository.\n\nTODO split instantiation (versioning, plugin mappings) from definition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/stat/JavaKolmogorovSmirnovTestSuite.java",
    "type": "method",
    "name": "testKSTestNamedDistribution",
    "code": "public void testKSTestNamedDistribution() {\n    double pThreshold = 0.05;\n\n    Row results = KolmogorovSmirnovTest\n            .test(dataset, \"sample\", \"norm\", 0.0, 1.0).head();\n    double pValue1 = results.getDouble(0);\n    Assertions.assertTrue(pValue1 > pThreshold);\n  }",
    "comment": "Comparing a standard normal sample to a standard normal distribution\nCannot reject null hypothesis"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/PackageNameFilter.java",
    "type": "method",
    "name": "includePackageNames",
    "code": "static PackageNameFilter includePackageNames(List<String> names) {\n\t\treturn includePackageNames(names.toArray(new String[0]));\n\t}",
    "comment": "Create a new <em>include</em> {@link PackageNameFilter} based on the\n@see Package#getName()\n@see #includePackageNames(String...)\n@see #excludePackageNames(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/callbacks/DatabaseTestsDemo.java",
    "type": "method",
    "name": "beforeAll",
    "code": "static void beforeAll() {\n\t\tbeforeAllMethod(DatabaseTestsDemo.class.getSimpleName() + \".beforeAll()\");\n\t}",
    "comment": "Extension of {@link AbstractDatabaseTests} that inserts test data\ninto the database (after the database connection has been opened)\nand deletes test data (before the database connection is closed)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "pushRun",
    "code": "private void pushRun(int runBase, int runLen) {\n      this.runBase[stackSize] = runBase;\n      this.runLen[stackSize] = runLen;\n      stackSize++;\n    }",
    "comment": "Pushes the specified run onto the pending-run stack.\n\n@param runBase index of the first element in the run\n@param runLen  the number of elements in the run"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Double expected, double actual) {\n\t\tAssertEquals.assertEquals(expected, (Double) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expressions.java",
    "type": "method",
    "name": "years",
    "code": "public static Transform years(String column) {\n    return LogicalExpressions.years(Expressions.column(column));\n  }",
    "comment": "Create a yearly transform for a timestamp or date column.\n<p>\nThis transform represents a logical mapping from a timestamp or date to a year, such as 2018.\n<p>\nThe name reported by transforms created with this method is \"years\".\n\n@param column an input timestamp or date column\n@return a logical yearly transform with name \"years\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java",
    "type": "method",
    "name": "standardGenerator",
    "code": "void standardGenerator() {\n\t\tcheck(DefaultStyleTestCase.class, //\n\t\t\t\"CONTAINER: DisplayNameGenerationTests$DefaultStyleTestCase\", //\n\t\t\t\"TEST: @DisplayName prevails\", //\n\t\t\t\"TEST: test()\", //\n\t\t\t\"TEST: test(TestInfo)\", //\n\t\t\t\"TEST: testUsingCamelCaseStyle()\", //\n\t\t\t\"TEST: testUsingCamelCase_and_also_UnderScores()\", //\n\t\t\t\"TEST: testUsingCamelCase_and_also_UnderScores_keepingParameterTypeNamesIntact(TestInfo)\", //\n\t\t\t\"TEST: test_with_underscores()\" //\n\t\t);\n\t}",
    "comment": "Check generated display names.\n\n@see DisplayName\n@see DisplayNameGenerator\n@see DisplayNameGeneration\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/converter/src/main/java/com/iluwatar/converter/Converter.java",
    "type": "method",
    "name": "createFromDtos",
    "code": "public final List<U> createFromDtos(final Collection<T> dtos) {\n    return dtos.stream().map(this::convertFromDto).toList();\n  }",
    "comment": "Converts list of DTOs to list of Entities.\n\n@param dtos collection of DTO entities\n@return List of domain representation of provided entities retrieved by mapping each of them\nwith the conversion function"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/functions/ReducibleFunction.java",
    "type": "method",
    "name": "reducer",
    "code": "default Reducer<I, O> reducer(ReducibleFunction<?, ?> otherFunction) {\n    throw new UnsupportedOperationException();\n  }",
    "comment": "This method is for all other functions.\n\nIf this function is 'reducible' on another function, return the {@link Reducer} function.\n<p>\nExample of reducing f_source = days(x) on f_target = hours(x)\n<ul>\n<li>thisFunction = days</li>\n<li>otherFunction = hours</li>\n</ul>\n\n@param otherFunction the other function\n@return a reduction function if it is reducible, null if not."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/RequestTraceHelper.java",
    "type": "method",
    "name": "interpretTrace",
    "code": "public static String interpretTrace(boolean detailed, RequestTrace requestTrace) {\n        while (requestTrace != null) {\n            Object data = requestTrace.getData();\n            if (data instanceof DependencyRequest request) {\n                return \"dependency resolution for \" + request;\n            } else if (data instanceof CollectRequest request) {\n                return \"dependency collection for \" + request;\n            } else if (data instanceof CollectStepData stepData) {\n                String msg = \"dependency collection step for \" + stepData.getContext();\n                if (detailed) {\n                    msg += \". Path to offending node from root:\\n\";\n                    msg += stepData.getPath().stream()\n                            .map(n -> \" -> \" + n.toString())\n                            .collect(Collectors.joining(\"\\n\"));\n                    msg += \"\\n => \" + stepData.getNode();\n                }\n                return msg;\n            } else if (data instanceof ArtifactDescriptorRequest request) {\n                return \"artifact descriptor request for \" + request.getArtifact();\n            } else if (data instanceof ArtifactRequest request) {\n                return \"artifact request for \" + request.getArtifact();\n            } else if (data instanceof org.apache.maven.api.model.Plugin plugin) {\n                return \"plugin \" + plugin.getId();\n            }\n            requestTrace = requestTrace.getParent();\n        }\n\n        return \"n/a\";\n    }",
    "comment": "Creates a human-readable interpretation of a request trace\n@param detailed If true, includes additional details such as dependency paths\n@param requestTrace The trace to interpret\n@return A string describing the trace context and relevant details"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptor.java",
    "type": "method",
    "name": "clone",
    "code": "public PluginDescriptor clone() {\n        try {\n            return (PluginDescriptor) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e);\n        }\n    }",
    "comment": "Creates a shallow copy of this plugin descriptor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/androidTest/java/com/example/android/observability/persistence/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "insertAndGetUser",
    "code": "public void insertAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER).blockingAwait();\n\n        mDataSource.getUser()\n                .test()\n                .assertValue(user -> {\n                    return user != null && user.getId().equals(USER.getId()) &&\n                            user.getUserName().equals(USER.getUserName());\n                });\n    }",
    "comment": "When inserting a new user in the data source\nWhen subscribing to the emissions of the user\nassertValue asserts that there was only one emission of the user\nThe emitted user is the expected one"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/ReactorReader.java",
    "type": "method",
    "name": "processEvent",
    "code": "private void processEvent(ExecutionEvent event) {\n        MavenProject project = event.getProject();\n        switch (event.getType()) {\n            case MojoStarted:\n                String phase = event.getMojoExecution().getLifecyclePhase();\n                if (phase != null) {\n                    Deque<String> phases = getLifecycles(project);\n                    if (!Objects.equals(phase, phases.peekLast())) {\n                        phases.addLast(phase);\n                        if (\"clean\".equals(phase)) {\n                            synchronized (project) {\n                                cleanProjectLocalRepository(project);\n                            }\n                        }\n                    }\n                }\n                break;\n            case ProjectSucceeded:\n            case ForkedProjectSucceeded:\n                synchronized (project) {\n                    installIntoProjectLocalRepository(project);\n                }\n                break;\n            default:\n                break;\n        }\n    }",
    "comment": "We are interested in project success events, in which case we call\nthe {@link #installIntoProjectLocalRepository(MavenProject)} method.\nThe mojo started event is also captured to determine the lifecycle\nphases the project has been through.\n\n@param event the execution event"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/DisabledIfConditionTests.java",
    "type": "method",
    "name": "getExecutionCondition",
    "code": "protected ExecutionCondition getExecutionCondition() {\n\t\treturn new DisabledIfCondition();\n\t}",
    "comment": "Unit tests for {@link DisabledIf}.\n\n<p>Note that test method names MUST match the test method names in\n{@link DisabledIfIntegrationTests}.\n\n@since 5.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng2068ReactorRelativeParentsTest.java",
    "type": "method",
    "name": "MavenITmng2068ReactorRelativeParentsTest",
    "code": "public MavenITmng2068ReactorRelativeParentsTest() {\n        super(\"(2.0.6,)\"); // only test in 2.0.7+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-2068\">MNG-2068</a>.\n\nVerify that a multi-module build, built from the middle node in an inheritance hierarchy,\ncan find all parent POMs necessary to build each project in the reactor using ONLY the\nrelativePath from the parent specification (in this case, the implied one of '../pom.xml').\n\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/TaskSegment.java",
    "type": "method",
    "name": "TaskSegment",
    "code": "public TaskSegment(boolean aggregating) {\n        this.aggregating = aggregating;\n        tasks = new ArrayList<>();\n    }",
    "comment": "Describes the required task segment as provided on the maven command line; i.e. \"clean jetty:run install\"\n\n<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "lazyFileDescriptor",
    "code": "public boolean lazyFileDescriptor() {\n    return conf.getBoolean(SPARK_NETWORK_IO_LAZYFD_KEY, true);\n  }",
    "comment": "Whether to initialize FileDescriptor lazily or not. If true, file descriptors are\ncreated only when data is going to be transferred. This can reduce the number of open files."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isNotFinal",
    "code": "public static boolean isNotFinal(Member member) {\n\t\treturn ReflectionUtils.isNotFinal(member);\n\t}",
    "comment": "Determine if the supplied member is not {@code final}.\n\n@param member the member to check; never {@code null}\n@return {@code true} if the member is not {@code final}\n@since 1.5\n@see java.lang.reflect.Modifier#isFinal(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/main/java/com/iluwatar/circuitbreaker/DefaultCircuitBreaker.java",
    "type": "method",
    "name": "setState",
    "code": "public void setState(State state) {\n    this.state = state;\n    switch (state) {\n      case OPEN -> {\n        this.failureCount = failureThreshold;\n        this.lastFailureTime = System.nanoTime();\n      }\n      case HALF_OPEN -> {\n        this.failureCount = failureThreshold;\n        this.lastFailureTime = System.nanoTime() - retryTimePeriod;\n      }\n      default -> this.failureCount = 0;\n    }\n  }",
    "comment": "Break the circuit beforehand if it is known service is down Or connect the circuit manually if\nservice comes online before expected.\n\n@param state State at which circuit is in"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/main/java/com/iluwatar/identitymap/PersonFinder.java",
    "type": "method",
    "name": "getPerson",
    "code": "public Person getPerson(int key) {\n    // Try to find person in the identity map\n    Person person = this.identityMap.getPerson(key);\n    if (person != null) {\n      LOGGER.info(\"Person found in the Map\");\n      return person;\n    } else {\n      // Try to find person in the database\n      person = this.db.find(key);\n      if (person != null) {\n        this.identityMap.addPerson(person);\n        LOGGER.info(\"Person found in DB.\");\n        return person;\n      }\n      LOGGER.info(\"Person with this ID does not exist.\");\n      return null;\n    }\n  }",
    "comment": "get person corresponding to input ID.\n\n@param key : personNationalId to look for."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setNull",
    "code": "public void setNull() {\n    nullData = (byte) 1;\n  }",
    "comment": "Sets all rows as `null`"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlanExecutor.java",
    "type": "method",
    "name": "if",
    "code": "Map<MavenProject, List<MavenProject>> projects, Lifecycle lifecycle, String lifecyclePhase) {\n            BuildPlan plan = new BuildPlan(projects);\n\n            for (MavenProject project : projects.keySet()) {\n                Map<String, BuildStep> steps = lifecycle\n                        .allPhases()\n                        .flatMap(phase -> {\n                            BuildStep a = new BuildStep(BEFORE + phase.name(), project, phase);\n                            BuildStep b = new BuildStep(phase.name(), project, phase);\n                            BuildStep c = new BuildStep(AFTER + phase.name(), project, phase);\n                            b.executeAfter(a);\n                            c.executeAfter(b);\n                            return Stream.of(a, b, c);\n                        })\n                        .collect(Collectors.toMap(n -> n.name, n -> n));\n                lifecycle.allPhases().forEach(phase -> phase.phases().forEach(child -> {\n                    steps.get(BEFORE + child.name()).executeAfter(steps.get(BEFORE + phase.name()));\n                    steps.get(AFTER + phase.name()).executeAfter(steps.get(AFTER + child.name()));\n                }));\n                lifecycle.allPhases().forEach(phase -> {\n                    phase.links().stream()\n                            .filter(l -> l.pointer().type() == Lifecycle.Pointer.Type.PROJECT)\n                            .forEach(link -> {\n                                String n1 = phase.name();\n                                String n2 = link.pointer().phase();\n                                if (link.kind() == Lifecycle.Link.Kind.AFTER) {\n                                    steps.get(BEFORE + n1).executeAfter(steps.get(AFTER + n2));\n                                } else {\n                                    steps.get(BEFORE + n2).executeAfter(steps.get(AFTER + n1));\n                                }\n                            });\n                });\n\n                String endPhase = lifecyclePhase.startsWith(BEFORE) || lifecyclePhase.startsWith(AFTER)\n                        ? lifecyclePhase\n                        : lifecyclePhase.startsWith(AT)\n                                ? lifecyclePhase.substring(AT.length())\n                                : AFTER + lifecyclePhase;\n                Set<BuildStep> toKeep = steps.get(endPhase).allPredecessors().collect(Collectors.toSet());\n                toKeep.addAll(toKeep.stream()\n                        .filter(s -> s.name.startsWith(BEFORE))\n                        .map(s -> steps.get(AFTER + s.name.substring(BEFORE.length())))\n                        .toList());\n                steps.values().stream().filter(n -> !toKeep.contains(n)).forEach(BuildStep::skip);\n\n                plan.addProject(project, steps);\n            }\n\n            plan.allSteps().filter(step -> step.phase != null).forEach(step -> {\n                Lifecycle.Phase phase = step.phase;\n                MavenProject project = step.project;\n                phase.links().stream().forEach(link -> {\n                    BuildStep before = plan.requiredStep(project, BEFORE + phase.name());\n                    BuildStep after = plan.requiredStep(project, AFTER + phase.name());\n                    Lifecycle.Pointer pointer = link.pointer();\n                    String n2 = pointer.phase();\n                    if (pointer instanceof Lifecycle.DependenciesPointer) {\n                        projects.get(project)\n                                .forEach(p -> plan.step(p, AFTER + n2).ifPresent(before::executeAfter));\n                    } else if (pointer instanceof Lifecycle.ChildrenPointer) {\n                        project.getCollectedProjects().forEach(p -> {\n                            plan.step(p, BEFORE + n2).ifPresent(before::executeBefore);\n                            plan.step(p, AFTER + n2).ifPresent(after::executeAfter);\n                        });\n                    }\n                });\n            });\n\n            Map<String, MavenProject> reactorGavs =\n                    projects.keySet().stream().collect(Collectors.toMap(BuildPlanExecutor::gav, p -> p));\n\n            List<Runnable> toResolve = new ArrayList<>();\n            projects.keySet().forEach(project -> project.getBuild().getPlugins().forEach(plugin -> {\n                MavenProject pluginProject = reactorGavs.get(gav(plugin));\n                if (pluginProject != null) {\n                    plan.requiredStep(project, PLAN).executeAfter(plan.requiredStep(pluginProject, READY));\n                } else {\n                    toResolve.add(() -> resolvePlugin(session, project.getRemotePluginRepositories(), plugin));\n                }\n            }));\n\n            toResolve.parallelStream().forEach(Runnable::run);\n\n            lifecycle.aliases().forEach(alias -> plan.aliases().put(alias.v3Phase(), alias.v4Phase()));\n\n            return plan;\n        }",
    "comment": "For each phase, create and sequence the pre, run and post steps\nfor each phase, make sure children phases are executed between before and after steps\nfor each phase, create links between this project phases\nOnly keep mojo executions before the end phase\nCreate inter project dependencies\nFor dependencies: ensure current project's phase starts after dependency's phase completes\nExample: project's compile starts after dependency's package completes\nTODO: String scope = ((Lifecycle.DependenciesPointer) pointer).scope();\nFor children: ensure bidirectional phase coordination\n1. Child's phase start waits for parent's phase start\n2. Parent's phase completion waits for child's phase completion\nKeep projects in reactors by GAV\nGo through all plugins\nIn order to plan the project, we need all its plugins...\nEagerly resolve all plugins in parallel\nKeep track of phase aliases"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProjectActivation.java",
    "type": "method",
    "name": "activateRequiredProject",
    "code": "public void activateRequiredProject(String selector) {\n        this.activations.add(new ProjectActivationSettings(selector, ActivationSettings.activated()));\n    }",
    "comment": "Mark a project as required and activated.\n@param selector The selector of the project."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/money/src/test/java/com/iluwater/money/MoneyTest.java",
    "type": "method",
    "name": "testSubtractMoney_DifferentCurrency",
    "code": "void testSubtractMoney_DifferentCurrency() {\n    Money money1 = new Money(100.00, \"USD\");\n    Money money2 = new Money(50.25, \"EUR\");\n\n    assertThrows(CannotSubtractException.class, () -> money1.subtractMoney(money2));\n  }",
    "comment": "Test subtracting two Money objects with the same currency\nTest subtracting two Money objects with different currencies"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/GroupStateTimeout.java",
    "type": "method",
    "name": "EventTimeTimeout",
    "code": "public static GroupStateTimeout EventTimeTimeout() { return EventTimeTimeout$.MODULE$; }",
    "comment": "Timeout based on event-time.\n<p>\nThe event-time timestamp for timeout can be set for each\ngroup in {@code map/flatMapGroupsWithState} by calling\n{@code GroupState.setTimeoutTimestamp()}.\nIn addition, you have to define the watermark in the query using\n{@code Dataset.withWatermark}.\nWhen the watermark advances beyond the set timestamp of a group and the group has not\nreceived any data, then the group times out.\n<p>\nSee documentation on {@code GroupState} for more details."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/AssertionsDemo.java",
    "type": "method",
    "name": "timeoutNotExceededWithResult",
    "code": "void timeoutNotExceededWithResult() {\n\t\tString actualResult = assertTimeout(ofMinutes(2), () -> {\n\t\t\treturn \"a result\";\n\t\t});\n\t\tassertEquals(\"a result\", actualResult);\n\t}",
    "comment": "end::user_guide[]\ntag::user_guide[]\nThe following assertion succeeds, and returns the supplied object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/OffHeapColumnVector.java",
    "type": "method",
    "name": "getDictId",
    "code": "public int getDictId(int rowId) {\n    assert(dictionary == null)\n            : \"A ColumnVector dictionary should not have a dictionary for itself.\";\n    return Platform.getInt(null, data + 4L * rowId);\n  }",
    "comment": "Returns the dictionary Id for rowId.\nThis should only be called when the ColumnVector is dictionaryIds.\nWe have this separate method for dictionaryIds as per SPARK-16928."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/DynamicNodeGenerationTests.java",
    "type": "method",
    "name": "testFactoryMethodsAreCorrectlyDiscoveredForClassSelector",
    "code": "void testFactoryMethodsAreCorrectlyDiscoveredForClassSelector() {\n\t\tLauncherDiscoveryRequest request = request().selectors(selectClass(MyDynamicTestCase.class)).build();\n\t\tTestDescriptor engineDescriptor = discoverTests(request).getEngineDescriptor();\n\t\tassertThat(engineDescriptor.getDescendants()).as(\"# resolved test descriptors\").hasSize(13);\n\t}",
    "comment": "Integration tests for {@link TestFactory @TestFactory}, {@link DynamicTest},\nand {@link org.junit.jupiter.api.DynamicContainer}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/queue-based-load-leveling/src/main/java/com/iluwatar/queue/load/leveling/MessageQueue.java",
    "type": "method",
    "name": "submitMsg",
    "code": "public void submitMsg(Message msg) {\n    try {\n      if (null != msg) {\n        blkQueue.add(msg);\n      }\n    } catch (Exception e) {\n      LOGGER.error(e.getMessage());\n    }\n  }",
    "comment": "All the TaskGenerator threads will call this method to insert the Messages in to the Blocking\nQueue."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "dropConstraint",
    "code": "static TableChange dropConstraint(String name, boolean ifExists, boolean cascade) {\n    DropConstraint.Mode mode = cascade ? DropConstraint.Mode.CASCADE : DropConstraint.Mode.RESTRICT;\n    return new DropConstraint(name, ifExists, mode);\n  }",
    "comment": "Create a TableChange for dropping a table constraint"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Named.java",
    "type": "method",
    "name": "of",
    "code": "static <T> Named<T> of(String name, T payload) {\n\t\tPreconditions.notBlank(name, \"name must not be null or blank\");\n\n\t\treturn new Named<T>() {\n\n\t\t\t@Override\n\t\t\tpublic T getPayload() {\n\t\t\t\treturn payload;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t};\n\t}",
    "comment": "Factory method for creating an instance of {@code Named} based on a\n{@code name} and a {@code payload}.\n\n@param name the name associated with the payload; never {@code null} or\nblank\n@param payload the object that serves as the payload; may be {@code null}\ndepending on the use case\n@param <T> the type of the payload\n@return an instance of {@code Named}; never {@code null}\n@see #named(String, java.lang.Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/function/Try.java",
    "type": "method",
    "name": "success",
    "code": "public static <V> Try<V> success(V value) {\n\t\treturn new Success<>(value);\n\t}",
    "comment": "Convert the supplied value into a succeeded {@code Try}.\n\n@param value the value to wrap; potentially {@code null}\n@return a succeeded {@code Try} that contains the supplied value; never\n{@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom_Common/java/com/example/android/persistence/migrations/SqliteTestDbOpenHelper.java",
    "type": "method",
    "name": "SqliteTestDbOpenHelper",
    "code": "public SqliteTestDbOpenHelper(Context context, String databaseName) {\n        super(context, databaseName, null, DATABASE_VERSION);\n    }",
    "comment": "Helper class for creating the test database version 1 with SQLite."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/UnsafeFixedWidthAggregationMap.java",
    "type": "method",
    "name": "iterator",
    "code": "public KVIterator<UnsafeRow, UnsafeRow> iterator() {\n    return new KVIterator<UnsafeRow, UnsafeRow>() {\n          return false;\n        }\n      }",
    "comment": "Returns an iterator over the keys and values in this map. This uses destructive iterator of\nBytesToBytesMap. So it is illegal to call any other method on this map after `iterator()` has\nbeen called.\n\nFor efficiency, each call returns the same object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getContextValue",
    "code": "public Object getContextValue(String key) {\n        if (context == null) {\n            return null;\n        }\n        return context.get(key);\n    }",
    "comment": "Returns context value of this project associated with the given key or null if this project has no such value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterExpressionEvaluator.java",
    "type": "method",
    "name": "isTypeCompatible",
    "code": "private static boolean isTypeCompatible(Class<?> type, Object value) {\n        if (type.isInstance(value)) {\n            return true;\n        }\n        return ((type.isPrimitive() || type.getName().startsWith(\"java.lang.\"))\n                && value.getClass().getName().startsWith(\"java.lang.\"));\n    }",
    "comment": "likely Boolean -> boolean, Short -> int etc. conversions, it's not the problem case we try to avoid"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/collecting-parameter/src/main/java/com/iluwatar/collectingparameter/App.java",
    "type": "method",
    "name": "addValidA4Papers",
    "code": "public static void addValidA4Papers(Queue<PrinterItem> printerItemsCollection) {\n    /*\n     Iterate through the printer queue, and add A4 papers according to the correct policy to the collecting parameter,\n     which is 'printerItemsCollection' in this case.\n    */\n    for (PrinterItem nextItem : printerQueue.getPrinterQueue()) {\n      if (nextItem.paperSize.equals(PaperSizes.A4)) {\n        var isColouredAndSingleSided = nextItem.isColour && !nextItem.isDoubleSided;\n        if (isColouredAndSingleSided || !nextItem.isColour) {\n          printerItemsCollection.add(nextItem);\n        }\n      }\n    }\n  }",
    "comment": "Adds A4 document jobs to the collecting parameter according to some policy that can be whatever\nthe client (the print center) wants.\n\n@param printerItemsCollection the collecting parameter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java",
    "type": "method",
    "name": "selectClasspathResources",
    "code": "void selectClasspathResources() {\n\t\t\tvar selector = selectClasspathResource(\"/foo/bar/spec.xml\");\n\t\t\tassertEquals(\"foo/bar/spec.xml\", selector.getClasspathResourceName());\n\n\t\t\tselector = selectClasspathResource(\"A/B/C/spec.json\");\n\t\t\tassertEquals(\"A/B/C/spec.json\", selector.getClasspathResourceName());\n\t\t}",
    "comment": "with unnecessary \"/\" prefix\nstandard use case"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/thrift/ThriftHttpServlet.java",
    "type": "method",
    "name": "getHttpOnlyCookieHeader",
    "code": "private static String getHttpOnlyCookieHeader(Cookie cookie) {\n    NewCookie newCookie = new NewCookie(cookie.getName(), cookie.getValue(),\n      cookie.getPath(), cookie.getDomain(), cookie.getVersion(),\n      cookie.getComment(), cookie.getMaxAge(), cookie.getSecure());\n    return newCookie + \"; HttpOnly\";\n  }",
    "comment": "Generate httponly cookie from HS2 cookie\n@param cookie HS2 generated cookie\n@return The httponly cookie"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/resource-managers/yarn/src/main/java/org/apache/spark/deploy/yarn/AmIpPrincipal.java",
    "type": "method",
    "name": "AmIpPrincipal",
    "code": "public AmIpPrincipal(String name) {\n    this.name = name;\n  }",
    "comment": "This class is copied from Hadoop 3.4.0\norg.apache.hadoop.yarn.server.webproxy.amfilter.AmIpPrincipal"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaHypothesisTestingKolmogorovSmirnovTestExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf conf =\n      new SparkConf().setAppName(\"JavaHypothesisTestingKolmogorovSmirnovTestExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    JavaDoubleRDD data = jsc.parallelizeDoubles(Arrays.asList(0.1, 0.15, 0.2, 0.3, 0.25));\n    KolmogorovSmirnovTestResult testResult =\n      Statistics.kolmogorovSmirnovTest(data, \"norm\", 0.0, 1.0);\n    System.out.println(testResult);\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nsummary of the test including the p-value, test statistic, and null hypothesis\nif our p-value indicates significance, we can reject the null hypothesis\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/NumericHistogram.java",
    "type": "method",
    "name": "trim",
    "code": "private void trim() {\n    while (nusedbins > nbins) {\n      // Find the closest pair of bins in terms of x coordinates. Break ties randomly.\n      double smallestdiff = bins.get(1).x - bins.get(0).x;\n      int smallestdiffloc = 0, smallestdiffcount = 1;\n      for (int i = 1; i < nusedbins - 1; i++) {\n        double diff = bins.get(i + 1).x - bins.get(i).x;\n        if (diff < smallestdiff) {\n          smallestdiff = diff;\n          smallestdiffloc = i;\n          smallestdiffcount = 1;\n        } else {\n          if (diff == smallestdiff && prng.nextDouble() <= (1.0 / ++smallestdiffcount)) {\n            smallestdiffloc = i;\n          }\n        }\n      }\n\n      // Merge the two closest bins into their average x location, weighted by their heights.\n      // The height of the new bin is the sum of the heights of the old bins.\n      // double d = bins[smallestdiffloc].y + bins[smallestdiffloc+1].y;\n      // bins[smallestdiffloc].x *= bins[smallestdiffloc].y / d;\n      // bins[smallestdiffloc].x += bins[smallestdiffloc+1].x / d *\n      //   bins[smallestdiffloc+1].y;\n      // bins[smallestdiffloc].y = d;\n\n      double d = bins.get(smallestdiffloc).y + bins.get(smallestdiffloc + 1).y;\n      Coord smallestdiffbin = bins.get(smallestdiffloc);\n      smallestdiffbin.x *= smallestdiffbin.y / d;\n      smallestdiffbin.x += bins.get(smallestdiffloc + 1).x / d * bins.get(smallestdiffloc + 1).y;\n      smallestdiffbin.y = d;\n      // Shift the remaining bins left one position\n      bins.remove(smallestdiffloc + 1);\n      nusedbins--;\n    }\n  }",
    "comment": "Trims a histogram down to 'nbins' bins by iteratively merging the closest bins.\nIf two pairs of bins are equally close to each other, decide uniformly at random which\npair to merge, based on a PRNG."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultLifecycleBindingsInjector.java",
    "type": "method",
    "name": "DefaultLifecycleBindingsInjector",
    "code": "public DefaultLifecycleBindingsInjector(LifecycleRegistry lifecycleRegistry, PackagingRegistry packagingRegistry) {\n        this.lifecycleRegistry = lifecycleRegistry;\n        this.packagingRegistry = packagingRegistry;\n    }",
    "comment": "Handles injection of plugin executions induced by the lifecycle bindings for a packaging."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/client/ChunkFetchFailureException.java",
    "type": "method",
    "name": "ChunkFetchFailureException",
    "code": "public ChunkFetchFailureException(String errorMsg, Throwable cause) {\n    super(errorMsg, cause);\n  }",
    "comment": "General exception caused by a remote exception while fetching a chunk."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/FilePosition.java",
    "type": "method",
    "name": "fromQuery",
    "code": "public static Optional<FilePosition> fromQuery(String query) {\n\t\tFilePosition result = null;\n\t\tInteger line = null;\n\t\tInteger column = null;\n\t\tif (StringUtils.isNotBlank(query)) {\n\t\t\ttry {\n\t\t\t\tfor (String pair : query.split(\"&\")) {\n\t\t\t\t\tString[] data = pair.split(\"=\");\n\t\t\t\t\tif (data.length == 2) {\n\t\t\t\t\t\tString key = data[0];\n\t\t\t\t\t\tif (line == null && \"line\".equals(key)) {\n\t\t\t\t\t\t\tline = Integer.valueOf(data[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (column == null && \"column\".equals(key)) {\n\t\t\t\t\t\t\tcolumn = Integer.valueOf(data[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Already found what we're looking for?\n\t\t\t\t\tif (line != null && column != null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tlogger.debug(ex, () -> \"Failed to parse 'line' and/or 'column' from query string: \" + query);\n\t\t\t\t// fall-through and continue\n\t\t\t}\n\n\t\t\tif (line != null) {\n\t\t\t\tresult = column == null ? new FilePosition(line) : new FilePosition(line, column);\n\t\t\t}\n\t\t}\n\t\treturn Optional.ofNullable(result);\n\t}",
    "comment": "Create an optional {@code FilePosition} by parsing the supplied\n{@code query} string.\n\n<p>Examples of valid {@code query} strings:\n<ul>\n<li>{@code \"line=23\"}</li>\n<li>{@code \"line=23&column=42\"}</li>\n</ul>\n\n@param query the query string; may be {@code null}\n@return an {@link Optional} containing a {@link FilePosition} with\nthe parsed line and column numbers; never {@code null} but potentially\nempty\n@since 1.3\n@see #from(int)\n@see #from(int, int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/LruCache.java",
    "type": "method",
    "name": "isFull",
    "code": "public boolean isFull() {\n    return cache.size() >= capacity;\n  }",
    "comment": "Check if the cache is full.\n\n@return boolean"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleKotlinTests.java",
    "type": "method",
    "name": "instancePerClassCanBeUsedForKotlinTestClasses",
    "code": "void instancePerClassCanBeUsedForKotlinTestClasses() {\n\t\tClass<?> testClass = InstancePerClassKotlinTestCase.class;\n\t\tInstancePerClassKotlinTestCase.TEST_INSTANCES.clear();\n\n\t\tEngineExecutionResults executionResults = executeTestsForClass(testClass);\n\n\t\tassertThat(executionResults.testEvents().finished().count()).isEqualTo(2);\n\t\tassertThat(InstancePerClassKotlinTestCase.TEST_INSTANCES.keySet()).hasSize(1);\n\t\tassertThat(getOnlyElement(InstancePerClassKotlinTestCase.TEST_INSTANCES.values())) //\n\t\t\t\t.containsEntry(\"beforeAll\", 1) //\n\t\t\t\t.containsEntry(\"beforeEach\", 2) //\n\t\t\t\t.containsEntry(\"test\", 2) //\n\t\t\t\t.containsEntry(\"afterEach\", 2) //\n\t\t\t\t.containsEntry(\"afterAll\", 1);\n\t}",
    "comment": "Kotlin-specific integration tests for {@link TestInstance @TestInstance}\nlifecycle support.\n\n@since 5.1\n@see TestInstanceLifecycleConfigurationTests\n@see TestInstanceLifecycleTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-aggregator/src/main/java/com/iluwatar/event/aggregator/EventEmitter.java",
    "type": "method",
    "name": "registerObserver",
    "code": "public final void registerObserver(EventObserver obs, Event e) {\n    if (!observerLists.containsKey(e)) {\n      observerLists.put(e, new LinkedList<>());\n    }\n    if (!observerLists.get(e).contains(obs)) {\n      observerLists.get(e).add(obs);\n    }\n  }",
    "comment": "Registers observer for specific event in the related list.\n\n@param obs the observer that observers this emitter\n@param e the specific event for that observation occurs"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/combinator/src/main/java/com/iluwatar/combinator/Finder.java",
    "type": "method",
    "name": "contains",
    "code": "static Finder contains(String word) {\n    return txt ->\n        Stream.of(txt.split(\"\\n\"))\n            .filter(line -> line.toLowerCase().contains(word.toLowerCase()))\n            .collect(Collectors.toList());\n  }",
    "comment": "Simple implementation of function {@link #find(String)}.\n\n@param word for searching\n@return this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(int unexpected, Integer actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Integer) unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-executor/src/main/java/org/apache/maven/cling/executor/internal/ToolboxTool.java",
    "type": "method",
    "name": "validateOutput",
    "code": "private String validateOutput(boolean shave, ByteArrayOutputStream stdout, ByteArrayOutputStream stderr) {\n        String result = stdout.toString();\n        if (shave) {\n            result = result.replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n        }\n        // sanity checks: stderr has any OR result is empty string (no method should emit empty string)\n        if (stderr.size() > 0 || result.trim().isEmpty()) {\n            throw new ExecutorException(\n                    \"Unexpected stdout[\" + stdout.size() + \"]=\" + stdout + \"; stderr[\" + stderr.size() + \"]=\" + stderr);\n        }\n        return result;\n    }",
    "comment": "Performs \"sanity check\" for output, making sure no insane values like empty strings are returned."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/utils/Os.java",
    "type": "method",
    "name": "isFamily",
    "code": "public static boolean isFamily(String family) {\n        return isFamily(family, OS_NAME);\n    }",
    "comment": "Determines if the OS on which Maven is executing matches the\ngiven OS family.\n\n@param family the family to check for\n@return true if the OS matches"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "selectors",
    "code": "public SuiteLauncherDiscoveryRequestBuilder selectors(List<? extends DiscoverySelector> selectors) {\n\t\tthis.delegate.selectors(selectors);\n\t\treturn this;\n\t}",
    "comment": "Add all supplied {@code selectors} to the request.\n\n@param selectors the {@code DiscoverySelectors} to add; never {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/object-pool/src/test/java/com/iluwatar/object/pool/OliphauntPoolTest.java",
    "type": "method",
    "name": "testConcurrentCheckinCheckout",
    "code": "void testConcurrentCheckinCheckout() {\n    assertTimeout(\n        ofMillis(5000),\n        () -> {\n          final var pool = new OliphauntPool();\n          assertEquals(pool.toString(), \"Pool available=0 inUse=0\");\n\n          final var firstOliphaunt = pool.checkOut();\n          assertEquals(pool.toString(), \"Pool available=0 inUse=1\");\n\n          final var secondOliphaunt = pool.checkOut();\n          assertEquals(pool.toString(), \"Pool available=0 inUse=2\");\n\n          assertNotSame(firstOliphaunt, secondOliphaunt);\n          assertEquals(firstOliphaunt.getId() + 1, secondOliphaunt.getId());\n\n          // After checking in the second, we should get the same when checking out a new oliphaunt\n          // ...\n          pool.checkIn(secondOliphaunt);\n          assertEquals(pool.toString(), \"Pool available=1 inUse=1\");\n\n          final var oliphaunt3 = pool.checkOut();\n          assertEquals(pool.toString(), \"Pool available=0 inUse=2\");\n          assertSame(secondOliphaunt, oliphaunt3);\n\n          // ... and the same applies for the first one\n          pool.checkIn(firstOliphaunt);\n          assertEquals(pool.toString(), \"Pool available=1 inUse=1\");\n\n          final var oliphaunt4 = pool.checkOut();\n          assertEquals(pool.toString(), \"Pool available=0 inUse=2\");\n          assertSame(firstOliphaunt, oliphaunt4);\n\n          // When both oliphaunt return to the pool, we should still get the same instances\n          pool.checkIn(firstOliphaunt);\n          assertEquals(pool.toString(), \"Pool available=1 inUse=1\");\n\n          pool.checkIn(secondOliphaunt);\n          assertEquals(pool.toString(), \"Pool available=2 inUse=0\");\n\n          // The order of the returned instances is not determined, so just put them in a list\n          // and verify if both expected instances are in there.\n          final var oliphaunts = List.of(pool.checkOut(), pool.checkOut());\n          assertEquals(pool.toString(), \"Pool available=0 inUse=2\");\n          assertTrue(oliphaunts.contains(firstOliphaunt));\n          assertTrue(oliphaunts.contains(secondOliphaunt));\n        });\n  }",
    "comment": "Use the same object 100 times subsequently. This should not take much time since the heavy\nobject instantiation is done only once. Verify if we get the same object each time."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/SnapshotMetadataGeneratorFactory.java",
    "type": "method",
    "name": "newInstance",
    "code": "public MetadataGenerator newInstance(RepositorySystemSession session, InstallRequest request) {\n        return new LocalSnapshotMetadataGenerator(session, request);\n    }",
    "comment": "Maven GAV level metadata generator factory.\n\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/object-mother/src/main/java/com/iluwatar/objectmother/RoyaltyObjectMother.java",
    "type": "method",
    "name": "createDrunkKing",
    "code": "public static King createDrunkKing() {\n    var king = new King();\n    king.makeDrunk();\n    return king;\n  }",
    "comment": "Method of the object mother to create a drunk king.\n\n@return A drunk {@link com.iluwatar.objectmother.King}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "escapeJava",
    "code": "protected static String escapeJava(String str) {\n        if (str == null) {\n            return null;\n        }\n        int sz = str.length();\n        StringBuilder out = new StringBuilder(sz * 2);\n        for (int i = 0; i < sz; i++) {\n            char ch = str.charAt(i);\n            // handle unicode\n            if (ch > 0xfff) {\n                out.append(\"\\\\u\").append(hex(ch));\n            } else if (ch > 0xff) {\n                out.append(\"\\\\u0\").append(hex(ch));\n            } else if (ch > 0x7f) {\n                out.append(\"\\\\u00\").append(hex(ch));\n            } else if (ch < 32) {\n                switch (ch) {\n                    case '\\b':\n                        out.append('\\\\');\n                        out.append('b');\n                        break;\n                    case '\\n':\n                        out.append('\\\\');\n                        out.append('n');\n                        break;\n                    case '\\t':\n                        out.append('\\\\');\n                        out.append('t');\n                        break;\n                    case '\\f':\n                        out.append('\\\\');\n                        out.append('f');\n                        break;\n                    case '\\r':\n                        out.append('\\\\');\n                        out.append('r');\n                        break;\n                    default:\n                        if (ch > 0xf) {\n                            out.append(\"\\\\u00\").append(hex(ch));\n                        } else {\n                            out.append(\"\\\\u000\").append(hex(ch));\n                        }\n                        break;\n                }\n            } else {\n                switch (ch) {\n                    case '\"':\n                        out.append('\\\\');\n                        out.append('\"');\n                        break;\n                    case '\\\\':\n                        out.append('\\\\');\n                        out.append('\\\\');\n                        break;\n                    default:\n                        out.append(ch);\n                        break;\n                }\n            }\n        }\n        return out.toString();\n    }",
    "comment": "<p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n\n<p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n\n<p>So a tab becomes the characters <code>'\\\\'</code> and\n<code>'t'</code>.</p>\n\n<p>The only difference between Java strings and JavaScript strings\nis that in JavaScript, a single quote must be escaped.</p>\n\n<p>Example:</p>\n<pre>\ninput string: He didn't say, \"Stop!\"\noutput string: He didn't say, \\\"Stop!\\\"\n</pre>\n\n\n@param str  String to escape values in, may be null\n@return String with escaped values, <code>null</code> if null string input"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCache.java",
    "type": "method",
    "name": "newInstance",
    "code": "public static ModelCache newInstance(RepositorySystemSession session) {\n        if (session.getCache() == null) {\n            return null;\n        } else {\n            return new DefaultModelCache(session);\n        }\n    }",
    "comment": "A model builder cache backed by the repository system cache.\n\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/monitor/src/main/java/com/iluwatar/monitor/Main.java",
    "type": "method",
    "name": "runner",
    "code": "public static void runner(Bank bank, CountDownLatch latch) {\n    try {\n      SecureRandom random = new SecureRandom();\n      Thread.sleep(random.nextInt(1000));\n      LOGGER.info(\"Start transferring...\");\n      for (int i = 0; i < 1000000; i++) {\n        bank.transfer(random.nextInt(4), random.nextInt(4), random.nextInt(0, BASE_AMOUNT));\n      }\n      LOGGER.info(\"Finished transferring.\");\n      latch.countDown();\n    } catch (InterruptedException e) {\n      LOGGER.error(e.getMessage());\n      Thread.currentThread().interrupt();\n    }\n  }",
    "comment": "Runner to perform a bunch of transfers and handle exception.\n\n@param bank bank object\n@param latch signal finished execution"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/combinator/src/main/java/com/iluwatar/combinator/Finders.java",
    "type": "method",
    "name": "expandedFinder",
    "code": "public static Finder expandedFinder(String... queries) {\n    var finder = identSum();\n\n    for (String query : queries) {\n      finder = finder.or(Finder.contains(query));\n    }\n    return finder;\n  }",
    "comment": "Expanded query. Looking for alternatives.\n\n@param queries array with queries.\n@return new finder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnenc/CommonsCliEncryptOptions.java",
    "type": "method",
    "name": "displayHelp",
    "code": "public void displayHelp(ParserRequest request, Consumer<String> printStream) {\n        super.displayHelp(request, printStream);\n        printStream.accept(\"\");\n        printStream.accept(\"Goals:\");\n        printStream.accept(\"  diag - display encryption configuration diagnostic\");\n        printStream.accept(\"  init - wizard to configure encryption (interactive only)\");\n        printStream.accept(\"  encrypt - encrypts input\");\n        printStream.accept(\"  decrypt - decrypts encrypted input\");\n        printStream.accept(\"\");\n    }",
    "comment": "we have no DI here (to discover)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/sqlite/java/com/example/android/persistence/migrations/LocalUserDataSource.java",
    "type": "method",
    "name": "getUser",
    "code": "public User getUser() {\n        User user = null;\n\n        SQLiteDatabase db = mDbHelper.getReadableDatabase();\n\n        String[] projection = {\n                COLUMN_NAME_ENTRY_ID,\n                COLUMN_NAME_USERNAME\n        };\n\n        Cursor c = db.query(TABLE_NAME, projection, null, null,\n                null, null, null, \"1\");\n\n        if (c != null && c.getCount() > 0) {\n            if (c.moveToNext()) {\n                int itemId = c.getInt(c.getColumnIndexOrThrow(COLUMN_NAME_ENTRY_ID));\n                String title = c.getString(c.getColumnIndexOrThrow(COLUMN_NAME_USERNAME));\n                user = new User(itemId, title);\n            }\n        }\n        if (c != null) {\n            c.close();\n        }\n        db.close();\n\n        return user;\n    }",
    "comment": "Get the user from the table. Since, for simplicity we only have one user in the database,\nthis query gets all users from the table, but limits the result to just the 1st user"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/MojoExecutionEvent.java",
    "type": "method",
    "name": "MojoExecutionEvent",
    "code": "public MojoExecutionEvent(MavenSession session, MavenProject project, MojoExecution mojoExecution, Mojo mojo) {\n        this(session, project, mojoExecution, mojo, null);\n    }",
    "comment": "<p>\nEncapsulates parameters of MojoExecutionListener callback methods and is meant to provide API evolution path should\nit become necessary to introduce new parameters in the existing callbacks in the future.\n</p>\n<strong>Note:</strong> This class is part of work in progress and can be changed or removed without notice.\n\n@see MojoExecutionListener\n@see org.apache.maven.execution.scope.WeakMojoExecutionListener\n@since 3.1.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "setNumBytesValid",
    "code": "private void setNumBytesValid(int byteCount) {\n    if (byteCount < 0) {\n      throw new IllegalStateException(\"Error in UTF-8 byte count\");\n    }\n    numBytesValid = byteCount;\n  }",
    "comment": "The method sets the total number of bytes of the validated version of the current string\n(after possible replacement), which will be equal to `numBytes` if the UTF8String is valid.\nThis method should generally only be called once, from the `getIsValid` method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "trimRight",
    "code": "public UTF8String trimRight(UTF8String trimString) {\n    if (trimString == null) return null;\n    int charIdx = 0;\n    // number of characters from the source string\n    int numChars = 0;\n    // array of character length for the source string\n    int[] stringCharLen = new int[numBytes];\n    // array of the first byte position for each character in the source string\n    int[] stringCharPos = new int[numBytes];\n    // build the position and length array\n    while (charIdx < numBytes) {\n      stringCharPos[numChars] = charIdx;\n      stringCharLen[numChars] = numBytesForFirstByte(getByte(charIdx));\n      charIdx += stringCharLen[numChars];\n      numChars ++;\n    }\n\n    // index trimEnd points to the first no matching byte position from the right side of\n    // the source string.\n    int trimEnd = numBytes - 1;\n    while (numChars > 0) {\n      UTF8String searchChar = copyUTF8String(\n          stringCharPos[numChars - 1],\n          stringCharPos[numChars - 1] + stringCharLen[numChars - 1] - 1);\n      if (trimString.find(searchChar, 0) >= 0) {\n        trimEnd -= stringCharLen[numChars - 1];\n      } else {\n        break;\n      }\n      numChars --;\n    }\n\n    if (trimEnd == numBytes - 1) {\n      // Nothing trimmed\n      return this;\n    }\n    if (trimEnd < 0) {\n      // Everything trimmed\n      return EMPTY_UTF8;\n    }\n    return copyUTF8String(0, trimEnd);\n  }",
    "comment": "Trims instances of the given trim string from the end of this string.\n\n@param trimString the trim character string\n@return this string with no occurrences of the trim string at the end, or `null`\nif `trimString` is `null`"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/cisupport/GenericCIDetector.java",
    "type": "method",
    "name": "detectCI",
    "code": "public Optional<CIInfo> detectCI() {\n        String ciEnv = System.getenv(CI);\n        if (ciEnv != null && !\"false\".equals(ciEnv)) {\n            return Optional.of(new CIInfo() {\n\n                @Override\n                public String message() {\n                    return \"Environment variable \" + CI\n                            + \" is set and its value is not \\\"false\\\". Disable this detection by removing that variable or by setting it to \\\"false\\\"\";\n                }\n            });\n        }\n        return Optional.empty();\n    }",
    "comment": "Generic CI support. This offers same support as Maven 3 always had. Is also special, as code will reject this\ndetector result IF there are also any other returned via discovered services."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(double unexpected, Double actual, String message) {\n\t\tAssertNotEquals.assertNotEquals((Double) unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room/java/com/example/android/persistence/migrations/UsersDatabase.java",
    "type": "method",
    "name": "Migration",
    "code": "static final Migration MIGRATION_1_2 = new Migration(1, 2) {\n    };",
    "comment": "Migrate from:\nversion 1 - using the SQLiteDatabase API\nto\nversion 2 - using Room"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "trimRight",
    "code": "public UTF8String trimRight() {\n    int e = numBytes - 1;\n    // skip all of the space (0x20) in the right side\n    while (e >= 0 && getByte(e) == 0x20) e--;\n    if (e == numBytes - 1) {\n      // Nothing trimmed\n      return this;\n    }\n    if (e < 0) {\n      // Everything trimmed\n      return EMPTY_UTF8;\n    }\n    return copyUTF8String(0, e);\n  }",
    "comment": "Trims space characters (ASCII 32) from the end of this string.\n\n@return this string with no spaces at the end"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/BuildSummary.java",
    "type": "method",
    "name": "BuildSummary",
    "code": "protected BuildSummary(MavenProject project, long time) {\n        this(project, Duration.ofMillis(time), Duration.ofMillis(time));\n    }",
    "comment": "Creates a new build summary for the specified project.\n\n@param project The project being summarized, must not be {@code null}.\n@param time The build time of the project in milliseconds."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExternalShuffleBlockResolver.java",
    "type": "method",
    "name": "applicationRemoved",
    "code": "public void applicationRemoved(String appId, boolean cleanupLocalDirs) {\n    logger.info(\"Application {} removed, cleanupLocalDirs = {}\",\n      MDC.of(LogKeys.APP_ID$.MODULE$, appId),\n      MDC.of(LogKeys.CLEANUP_LOCAL_DIRS$.MODULE$, cleanupLocalDirs));\n    Iterator<Map.Entry<AppExecId, ExecutorShuffleInfo>> it = executors.entrySet().iterator();\n    while (it.hasNext()) {\n      Map.Entry<AppExecId, ExecutorShuffleInfo> entry = it.next();\n      AppExecId fullId = entry.getKey();\n      final ExecutorShuffleInfo executor = entry.getValue();\n\n      // Only touch executors associated with the appId that was removed.\n      if (appId.equals(fullId.appId)) {\n        it.remove();\n        if (db != null && AppsWithRecoveryDisabled.isRecoveryEnabledForApp(fullId.appId)) {\n          try {\n            db.delete(dbAppExecKey(fullId));\n          } catch (IOException e) {\n            logger.error(\"Error deleting {} from executor state db\", e,\n              MDC.of(LogKeys.APP_ID$.MODULE$, appId));\n          }\n        }\n\n        if (cleanupLocalDirs) {\n          logger.info(\"Cleaning up executor {}'s {} local dirs\",\n            MDC.of(LogKeys.APP_EXECUTOR_ID$.MODULE$, fullId),\n            MDC.of(LogKeys.NUM_LOCAL_DIRS$.MODULE$, executor.localDirs.length));\n\n          // Execute the actual deletion in a different thread, as it may take some time.\n          directoryCleaner.execute(() -> deleteExecutorDirs(executor.localDirs));\n        }\n      }\n    }\n  }",
    "comment": "Removes our metadata of all executors registered for the given application, and optionally\nalso deletes the local directories associated with the executors of that application in a\nseparate thread.\n\nIt is not valid to call registerExecutor() for an executor with this appId after invoking\nthis method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "getBaseObject",
    "code": "public Object getBaseObject() { return base; }\n  public long getBaseOffset() { return offset; }",
    "comment": "Internal flag to indicate whether the string is full ASCII or not. Initially, the ASCII-ness\nis UNKNOWN, and will be set to either FULL_ASCII or NOT_ASCII after the first check."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/OperationState.java",
    "type": "method",
    "name": "getOperationState",
    "code": "public static OperationState getOperationState(TOperationState tOperationState) {\n    return OperationState.values()[tOperationState.getValue()];\n  }",
    "comment": "must be sync with TOperationState in order"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Integer> create(long[] shape, IntBuffer data) {\n    Tensor<Integer> t = allocateForBuffer(DataType.INT32, shape, data.remaining());\n    t.buffer().asIntBuffer().put(data);\n    return t;\n  }",
    "comment": "Create a {@link Integer} Tensor with data from the given buffer.\n\n<p>Creates a Tensor with the given shape by copying elements from the buffer (starting from its\ncurrent position) into the tensor. For example, if {@code shape = {2,3} } (which represents a\n2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaKMeansExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaKMeansExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    String path = \"data/mllib/kmeans_data.txt\";\n    JavaRDD<String> data = jsc.textFile(path);\n    JavaRDD<Vector> parsedData = data.map(s -> {\n      String[] sarray = s.split(\" \");\n      double[] values = new double[sarray.length];\n      for (int i = 0; i < sarray.length; i++) {\n        values[i] = Double.parseDouble(sarray[i]);\n      }\n      return Vectors.dense(values);\n    });\n    parsedData.cache();\n\n    int numClusters = 2;\n    int numIterations = 20;\n    KMeansModel clusters = KMeans.train(parsedData.rdd(), numClusters, numIterations);\n\n    System.out.println(\"Cluster centers:\");\n    for (Vector center: clusters.clusterCenters()) {\n      System.out.println(\" \" + center);\n    }\n    double cost = clusters.computeCost(parsedData.rdd());\n    System.out.println(\"Cost: \" + cost);\n\n    double WSSSE = clusters.computeCost(parsedData.rdd());\n    System.out.println(\"Within Set Sum of Squared Errors = \" + WSSSE);\n\n    clusters.save(jsc.sc(), \"target/org/apache/spark/JavaKMeansExample/KMeansModel\");\n    KMeansModel sameModel = KMeansModel.load(jsc.sc(),\n      \"target/org/apache/spark/JavaKMeansExample/KMeansModel\");\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse data\nCluster the data into two classes using KMeans\nEvaluate clustering by computing Within Set Sum of Squared Errors\nSave and load model\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/CookieSigner.java",
    "type": "method",
    "name": "getSignature",
    "code": "private String getSignature(String str) {\n    try {\n      MessageDigest md = MessageDigest.getInstance(SHA_STRING);\n      md.update(str.getBytes());\n      md.update(secretBytes);\n      byte[] digest = md.digest();\n      return new Base64(0).encodeToString(digest);\n    } catch (NoSuchAlgorithmException ex) {\n      throw new RuntimeException(\"Invalid SHA digest String: \" + SHA_STRING +\n        \" \" + ex.getMessage(), ex);\n    }\n  }",
    "comment": "Get the signature of the input string based on SHA digest algorithm.\n@param str Input token\n@return Signed String"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(int expected, Integer actual) {\n\t\tAssertEquals.assertEquals((Integer) expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testMixedSimpleAdd",
    "code": "public void testMixedSimpleAdd() {\n        IMoney expected = MoneyBag.create(f12CHF, f7USD);\n        assertEquals(expected, f12CHF.add(f7USD));\n    }",
    "comment": "[12 CHF] + [7 USD] == {[12 CHF][7 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/logging/LoggerFactory.java",
    "type": "method",
    "name": "getLogger",
    "code": "public static Logger getLogger(Class<?> clazz) {\n\t\t// NOTE: we cannot use org.junit.platform.commons.util.Preconditions here\n\t\t// since that would introduce a package cycle.\n\t\tif (clazz == null) {\n\t\t\tthrow new JUnitException(\"Class must not be null\");\n\t\t}\n\n\t\treturn new DelegatingLogger(clazz.getName());\n\t}",
    "comment": "Get a {@link Logger} for the specified class.\n\n@param clazz the class for which to get the logger; never {@code null}\n@return the logger"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/hash/Murmur3_x86_32Suite.java",
    "type": "method",
    "name": "testKnownIntegerInputs",
    "code": "public void testKnownIntegerInputs() {\n    Assertions.assertEquals(593689054, hasher.hashInt(0));\n    Assertions.assertEquals(-189366624, hasher.hashInt(-42));\n    Assertions.assertEquals(-1134849565, hasher.hashInt(42));\n    Assertions.assertEquals(-1718298732, hasher.hashInt(Integer.MIN_VALUE));\n    Assertions.assertEquals(-1653689534, hasher.hashInt(Integer.MAX_VALUE));\n  }",
    "comment": "Test file based on Guava's Murmur3Hash32Test."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/main/java/com/iluwatar/pageobject/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    try {\n      var classLoader = App.class.getClassLoader();\n      var applicationFile = new File(classLoader.getResource(\"sample-ui/login.html\").getPath());\n\n      // Should work for unix like OS (mac, unix etc...)\n      if (Desktop.isDesktopSupported()) {\n        Desktop.getDesktop().open(applicationFile);\n\n      } else {\n        // Java Desktop not supported - above unlikely to work for Windows so try the\n        // following instead...\n        Runtime.getRuntime().exec(\"cmd.exe start \" + applicationFile);\n      }\n\n    } catch (IOException ex) {\n      ex.printStackTrace();\n    }\n  }",
    "comment": "Application entry point\n\n<p>The application under development is a web application. Normally you would probably have a\nbackend that is probably implemented in an object-oriented language (e.g. Java) that serves the\nfrontend which comprises of a series of HTML, CSS, JS etc...\n\n<p>For illustrations purposes only, a very simple static html app is used here. This main\nmethod just fires up this simple web app in a default browser.\n\n@param args arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/plugin/testing/stubs/RepositorySystemSupplier.java",
    "type": "method",
    "name": "createArtifactGeneratorFactories",
    "code": "protected Map<String, ArtifactGeneratorFactory> createArtifactGeneratorFactories() {\n        return new HashMap<>();\n    }",
    "comment": "by default none, this is extension point"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "maxIORetries",
    "code": "public int maxIORetries() { return conf.getInt(SPARK_NETWORK_IO_MAXRETRIES_KEY, 3); }",
    "comment": "Max number of times we will try IO exceptions (such as connection timeouts) per request.\nIf set to 0, we will not do any retries."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/configuration/BasedirBeanConfigurationPathTranslator.java",
    "type": "method",
    "name": "BasedirBeanConfigurationPathTranslator",
    "code": "public BasedirBeanConfigurationPathTranslator(File basedir) {\n        this.basedir = basedir;\n    }",
    "comment": "Creates a new path translator using the specified base directory.\n\n@param basedir The base directory to resolve relative paths against, may be {@code null} to disable path\ntranslation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/NettyUtils.java",
    "type": "method",
    "name": "createFrameDecoder",
    "code": "public static TransportFrameDecoder createFrameDecoder() {\n    return new TransportFrameDecoder();\n  }",
    "comment": "Creates a LengthFieldBasedFrameDecoder where the first 8 bytes are the length of the frame.\nThis is used before all decoders."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/collection-pipeline/src/main/java/com/iluwatar/collectionpipeline/FunctionalProgramming.java",
    "type": "method",
    "name": "getGroupingOfCarsByCategory",
    "code": "public static Map<Category, List<Car>> getGroupingOfCarsByCategory(List<Car> cars) {\n    return cars.stream().collect(Collectors.groupingBy(Car::category));\n  }",
    "comment": "Method to group cars by category using groupingBy.\n\n@param cars {@link List} of {@link Car} to be used for grouping\n@return {@link Map} with category as key and cars belonging to that category as value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "fileEntryPublished",
    "code": "public Events fileEntryPublished() {\n\t\treturn new Events(eventsByType(EventType.FILE_ENTRY_PUBLISHED), this.category + \" File Entry Published\");\n\t}",
    "comment": "Get the file entry publication {@link Events} contained in this\n{@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ActivationSettings.java",
    "type": "method",
    "name": "ActivationSettings",
    "code": "public record ActivationSettings(boolean active, boolean optional, boolean recurse) {\n\n    static ActivationSettings of(final boolean active, final boolean optional) {\n        return of(active, optional, true);\n    }\n\n    static ActivationSettings of(final boolean active, final boolean optional, final boolean recursive) {\n        return new ActivationSettings(active, optional, recursive);\n    }\n\n    static ActivationSettings activated() {\n        return new ActivationSettings(true, false, true);\n    }\n\n    static ActivationSettings activatedOpt() {\n        return new ActivationSettings(true, true, true);\n    }\n\n    static ActivationSettings deactivated() {\n        return new ActivationSettings(false, false, false);\n    }\n\n    static ActivationSettings deactivatedOpt() {\n        return new ActivationSettings(false, true, false);\n    }\n}",
    "comment": "Describes whether a target should be activated or not, and if that is required or optional.\n\n@param active Should the target be active?\n@param optional Should the build continue if the target is not present?\n@param recurse Should the target be activated and its children be activated?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetColumnVector.java",
    "type": "method",
    "name": "getNextCollectionStart",
    "code": "private int getNextCollectionStart(int maxRepetitionLevel, int idx) {\n    idx += 1;\n    for (; idx < repetitionLevels.getElementsAppended(); idx++) {\n      if (repetitionLevels.getInt(idx) <= maxRepetitionLevel) {\n        break;\n      }\n    }\n    return idx;\n  }",
    "comment": "For a collection (i.e., array or map) element at index 'idx', returns the starting index of\nthe next collection after it.\n\n@param maxRepetitionLevel the maximum repetition level for the elements in this collection\n@param idx the index of this collection in the Parquet column\n@return the starting index of the next collection"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaDecisionTreeRegressionExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaDecisionTreeRegressionExample\")\n      .getOrCreate();\n    Dataset<Row> data = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_libsvm_data.txt\");\n\n    VectorIndexerModel featureIndexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexedFeatures\")\n      .setMaxCategories(4)\n      .fit(data);\n\n    Dataset<Row>[] splits = data.randomSplit(new double[]{0.7, 0.3});\n      .setStages(new PipelineStage[]{featureIndexer, dt});\n}",
    "comment": "scalastyle:off println\n$example on$\n$example off$\n$example on$\nLoad the data stored in LIBSVM format as a DataFrame.\nAutomatically identify categorical features, and index them.\nSet maxCategories so features with > 4 distinct values are treated as continuous.\nSplit the data into training and test sets (30% held out for testing)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/options/CommandFacade.java",
    "type": "method",
    "name": "CommandFacade",
    "code": "public CommandFacade(ConsoleTestExecutor.Factory consoleTestExecutorFactory) {\n\t\tthis.consoleTestExecutorFactory = consoleTestExecutorFactory;\n\t}",
    "comment": "Internal facade to run a CLI command that exists to hide implementation\ndetails such as the used library.\n\n@since 1.10"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/monad/src/main/java/com/iluwatar/monad/Validator.java",
    "type": "method",
    "name": "Validator",
    "code": "private Validator(T obj) {\n    this.obj = obj;\n  }",
    "comment": "Creates a monadic value of given object.\n\n@param obj object to be validated"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/MonotonicClock.java",
    "type": "method",
    "name": "get",
    "code": "public static MonotonicClock get() {\n        return CLOCK;\n    }",
    "comment": "Returns the singleton instance of MonotonicClock.\n\n@return the monotonic clock instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(long unexpected, long actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/io/xpp3/MavenXpp3Reader.java",
    "type": "method",
    "name": "getAddDefaultEntities",
    "code": "public boolean getAddDefaultEntities() {\n        return delegate.getAddDefaultEntities();\n    } // -- boolean getAddDefaultEntities()",
    "comment": "Returns the state of the \"add default entities\" flag.\n\n@return boolean"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/NavigationBasicSample/app/src/uiTest/java/com/example/android/navigationsample/TitleScreenTestJava.java",
    "type": "method",
    "name": "testNavigateToLeaderboard",
    "code": "public void testNavigateToLeaderboard() {\n        TestNavHostController navController = new TestNavHostController(ApplicationProvider.getApplicationContext());\n\n        FragmentScenario<TitleScreen> titleScenario =\n                FragmentScenario.launchInContainer(TitleScreen.class);\n\n        titleScenario.onFragment(fragment -> {\n                navController.setGraph(R.navigation.navigation);\n                Navigation.setViewNavController(fragment.requireView(), navController);\n            }\n\n        );\n\n        onView(withId(R.id.leaderboard_btn)).perform(click());\n        List<NavBackStackEntry> backStack = navController.getBackStack();\n        NavBackStackEntry currentDestination = backStack.get(backStack.size() - 1);\n        assertThat(currentDestination.getDestination().getId()).isEqualTo(R.id.leaderboard);\n    }",
    "comment": "Create a TestNavHostController\nCreate a graphical FragmentScenario for the TitleScreen\nSet the NavController property on the fragment\nVerify that performing a click changes the NavController's state"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "getStruct",
    "code": "public final ColumnarRow getStruct(int rowId) {\n    if (isNullAt(rowId)) return null;\n    return new ColumnarRow(this, rowId);\n  }",
    "comment": "Returns the struct type value for {@code rowId}. If the slot for {@code rowId} is null, it\nshould return null.\n<p>\nTo support struct type, implementations must implement {@link #getChild(int)} and make this\nvector a tree structure. The number of child vectors must be same as the number of fields of\nthe struct type, and each child vector is responsible to store the data for its corresponding\nstruct field."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "addTarget",
    "code": "public Runner addTarget(String operation) {\n      GraphOperation op = operationByName(operation);\n      if (op != null) {\n        targets.add(op);\n      }\n      return this;\n    }",
    "comment": "Make {@link #run()} execute {@code operation}, but not return any evaluated {@link Tensor\nTensors}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java",
    "type": "method",
    "name": "getMethodName",
    "code": "public final String getMethodName() {\n\t\treturn this.methodName;\n\t}",
    "comment": "Get the method name of this source."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/AssertTest.java",
    "type": "method",
    "name": "testAssertionFailedErrorToStringWithNoMessage",
    "code": "public void testAssertionFailedErrorToStringWithNoMessage() {\n        try {\n            fail();\n        } catch (AssertionFailedError e) {\n            assertEquals(\"junit.framework.AssertionFailedError\", e.toString());\n            return;\n        }\n        throw new AssertionFailedError();\n    }",
    "comment": "Also, we are testing fail, so we can't rely on fail() working.\nWe have to throw the exception manually."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java",
    "type": "method",
    "name": "instancePerMethodOnOuterTestClassWithInstancePerClassOnNestedTestClass",
    "code": "void instancePerMethodOnOuterTestClassWithInstancePerClassOnNestedTestClass() {\n\t\tClass<?> testClass = MixedLifecyclesOuterTestCase.class;\n\t\tClass<?> nestedTestClass = MixedLifecyclesOuterTestCase.NestedInstancePerClassTestCase.class;\n\t\tint containers = 4;\n\t\tint tests = 4;\n\t\tMap.Entry<Class<?>, Integer>[] instances = instanceCounts(entry(testClass, 2), entry(nestedTestClass, 1));\n\t\tint allMethods = 1;\n\t\tint eachMethods = 7;\n\n\t\tperformAssertions(testClass, containers, tests, instances, allMethods, eachMethods);\n\n\t\tString containerExecutionConditionKey = executionConditionKey(testClass, null);\n\t\tString nestedContainerExecutionConditionKey = executionConditionKey(nestedTestClass, null);\n\t\tString nestedTestTemplateKey = testTemplateKey(nestedTestClass, \"singletonTest\");\n\t\tString postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);\n\t\tString nestedPostProcessTestInstanceKey = postProcessTestInstanceKey(nestedTestClass);\n\t\tString preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);\n\t\tString nestedPreDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(nestedTestClass);\n\t\tString beforeAllCallbackKey = beforeAllCallbackKey(testClass);\n\t\tString afterAllCallbackKey = afterAllCallbackKey(testClass);\n\t\tString outerTestExecutionConditionKey = executionConditionKey(testClass, \"outerTest\");\n\t\tString beforeEachCallbackKey = beforeEachCallbackKey(testClass, \"outerTest\");\n\t\tString afterEachCallbackKey = afterEachCallbackKey(testClass, \"outerTest\");\n\t\tString nestedBeforeAllCallbackKey = beforeAllCallbackKey(nestedTestClass);\n\t\tString nestedAfterAllCallbackKey = afterAllCallbackKey(nestedTestClass);\n\t\tString nestedExecutionConditionKey1 = executionConditionKey(nestedTestClass, testsInvoked.getFirst());\n\t\tString nestedBeforeEachCallbackKey1 = beforeEachCallbackKey(nestedTestClass, testsInvoked.get(0));\n\t\tString nestedAfterEachCallbackKey1 = afterEachCallbackKey(nestedTestClass, testsInvoked.get(0));\n\t\tString nestedExecutionConditionKey2 = executionConditionKey(nestedTestClass, testsInvoked.get(1));\n\t\tString nestedBeforeEachCallbackKey2 = beforeEachCallbackKey(nestedTestClass, testsInvoked.get(1));\n\t\tString nestedAfterEachCallbackKey2 = afterEachCallbackKey(nestedTestClass, testsInvoked.get(1));\n\t\tString nestedExecutionConditionKey3 = executionConditionKey(nestedTestClass, testsInvoked.get(2));\n\t\tString nestedBeforeEachCallbackKey3 = beforeEachCallbackKey(nestedTestClass, testsInvoked.get(2));\n\t\tString nestedAfterEachCallbackKey3 = afterEachCallbackKey(nestedTestClass, testsInvoked.get(2));\n\n\t\tassertThat(instanceMap.keySet()).containsExactlyInAnyOrder(\n\t\t\t\tcontainerExecutionConditionKey,\n\t\t\t\tnestedTestTemplateKey,\n\t\t\t\tnestedContainerExecutionConditionKey,\n\t\t\t\tpostProcessTestInstanceKey,\n\t\t\t\tnestedPostProcessTestInstanceKey,\n\t\t\t\tpreDestroyCallbackTestInstanceKey,\n\t\t\t\tnestedPreDestroyCallbackTestInstanceKey,\n\t\t\t\tbeforeAllCallbackKey,\n\t\t\t\tafterAllCallbackKey,\n\t\t\t\touterTestExecutionConditionKey,\n\t\t\t\tbeforeEachCallbackKey,\n\t\t\t\tafterEachCallbackKey,\n\t\t\t\tnestedBeforeAllCallbackKey,\n\t\t\t\tnestedAfterAllCallbackKey,\n\t\t\t\tnestedExecutionConditionKey1,\n\t\t\t\tnestedBeforeEachCallbackKey1,\n\t\t\t\tnestedAfterEachCallbackKey1,\n\t\t\t\tnestedExecutionConditionKey2,\n\t\t\t\tnestedBeforeEachCallbackKey2,\n\t\t\t\tnestedAfterEachCallbackKey2,\n\t\t\t\tnestedExecutionConditionKey3,\n\t\t\t\tnestedBeforeEachCallbackKey3,\n\t\t\t\tnestedAfterEachCallbackKey3\n\t\t);\n\n\t\tassertNull(instanceMap.get(containerExecutionConditionKey));\n\t\tassertNull(instanceMap.get(beforeAllCallbackKey));\n\t\tassertNull(instanceMap.get(afterAllCallbackKey));\n\n\t\tTestInstances outerInstances = instanceMap.get(beforeEachCallbackKey);\n\t\tassertSame(outerInstances, instanceMap.get(afterEachCallbackKey));\n\t\tassertSame(outerInstances, instanceMap.get(outerTestExecutionConditionKey));\n\n\t\tObject nestedInstance = instanceMap.get(nestedPostProcessTestInstanceKey).getInnermostInstance();\n\t\tassertNotNull(nestedInstance);\n\t\tassertNotSame(outerInstances.getInnermostInstance(), nestedInstance);\n\t\tassertNull(instanceMap.get(nestedContainerExecutionConditionKey));\n\t\tassertSame(nestedInstance, instanceMap.get(nestedBeforeAllCallbackKey).getInnermostInstance());\n\t\tassertSame(nestedInstance, instanceMap.get(nestedAfterAllCallbackKey).getInnermostInstance());\n\t\tassertSame(nestedInstance, instanceMap.get(nestedExecutionConditionKey1).getInnermostInstance());\n\t\tassertSame(nestedInstance, instanceMap.get(nestedBeforeEachCallbackKey1).getInnermostInstance());\n\t\tassertSame(nestedInstance, instanceMap.get(nestedAfterEachCallbackKey1).getInnermostInstance());\n\t\tassertSame(nestedInstance, instanceMap.get(nestedExecutionConditionKey2).getInnermostInstance());\n\t\tassertSame(nestedInstance, instanceMap.get(nestedBeforeEachCallbackKey2).getInnermostInstance());\n\t\tassertSame(nestedInstance, instanceMap.get(nestedAfterEachCallbackKey2).getInnermostInstance());\n\t\tassertSame(nestedInstance, instanceMap.get(nestedExecutionConditionKey3).getInnermostInstance());\n\t\tassertSame(nestedInstance, instanceMap.get(nestedBeforeEachCallbackKey3).getInnermostInstance());\n\t\tassertSame(nestedInstance, instanceMap.get(nestedAfterEachCallbackKey3).getInnermostInstance());\n\t\tassertSame(nestedInstance, instanceMap.get(nestedPreDestroyCallbackTestInstanceKey).getInnermostInstance());\n\n\t\tObject outerInstance = instanceMap.get(nestedExecutionConditionKey1).findInstance(testClass).get();\n\t\tassertEquals(outerInstances.getInnermostInstance().getClass(), outerInstance.getClass());\n\t\tassertNotSame(outerInstances.getInnermostInstance(), outerInstance);\n\t\tassertThat(instanceMap.get(nestedExecutionConditionKey1).getAllInstances()).containsExactly(outerInstance,\n\t\t\tnestedInstance);\n\t\tassertThat(instanceMap.get(nestedBeforeEachCallbackKey1).getAllInstances()).containsExactly(outerInstance,\n\t\t\tnestedInstance);\n\t\tassertThat(instanceMap.get(nestedAfterEachCallbackKey1).getAllInstances()).containsExactly(outerInstance,\n\t\t\tnestedInstance);\n\t\tassertThat(instanceMap.get(nestedExecutionConditionKey2).getAllInstances()).containsExactly(outerInstance,\n\t\t\tnestedInstance);\n\t\tassertThat(instanceMap.get(nestedBeforeEachCallbackKey2).getAllInstances()).containsExactly(outerInstance,\n\t\t\tnestedInstance);\n\t\tassertThat(instanceMap.get(nestedAfterEachCallbackKey2).getAllInstances()).containsExactly(outerInstance,\n\t\t\tnestedInstance);\n\t\tassertThat(instanceMap.get(nestedExecutionConditionKey3).getAllInstances()).containsExactly(outerInstance,\n\t\t\tnestedInstance);\n\t\tassertThat(instanceMap.get(nestedBeforeEachCallbackKey3).getAllInstances()).containsExactly(outerInstance,\n\t\t\tnestedInstance);\n\t\tassertThat(instanceMap.get(nestedAfterEachCallbackKey3).getAllInstances()).containsExactly(outerInstance,\n\t\t\tnestedInstance);\n\n\t\tassertThat(lifecyclesMap.keySet()).containsExactly(testClass, nestedTestClass);\n\t\tassertThat(lifecyclesMap.get(testClass).stream()).allMatch(Lifecycle.PER_METHOD::equals);\n\t\tassertThat(lifecyclesMap.get(nestedTestClass).stream()).allMatch(Lifecycle.PER_CLASS::equals);\n\t}",
    "comment": "@formatter:off\n@formatter:on\nThe last tracked instance stored under postProcessTestInstanceKey\nis only created in order to instantiate the nested test class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicSample/app/src/main/java/com/example/android/persistence/DataRepository.java",
    "type": "method",
    "name": "DataRepository",
    "code": "private DataRepository(final AppDatabase database) {\n        mDatabase = database;\n        mObservableProducts = new MediatorLiveData<>();\n\n        mObservableProducts.addSource(mDatabase.productDao().loadAllProducts(),\n                productEntities -> {\n                    if (mDatabase.getDatabaseCreated().getValue() != null) {\n                        mObservableProducts.postValue(productEntities);\n                    }\n                });\n    }",
    "comment": "Repository handling the work with products and comments."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "createSSLEngine",
    "code": "public SSLEngine createSSLEngine(boolean isClient, ByteBufAllocator allocator) {\n    SSLEngine engine = createEngine(isClient, allocator);\n    engine.setUseClientMode(isClient);\n    engine.setNeedClientAuth(false);\n    engine.setEnabledProtocols(enabledProtocols(engine, requestedProtocol));\n    engine.setEnabledCipherSuites(enabledCipherSuites(engine, requestedCiphers));\n    return engine;\n  }",
    "comment": "Creates a new {@link SSLEngine}.\n@return A valid {@link SSLEngine}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/BeforeAndAfterEachTests.java",
    "type": "method",
    "name": "beforeEachCallbackThrowsAnException",
    "code": "void beforeEachCallbackThrowsAnException() {\n\t\tEvents testEvents = executeTestsForClass(ExceptionInBeforeEachCallbackTestCase.class).testEvents();\n\n\t\tassertEquals(1, testEvents.started().count(), \"# tests started\");\n\t\tassertEquals(0, testEvents.succeeded().count(), \"# tests succeeded\");\n\t\tassertEquals(0, testEvents.skipped().count(), \"# tests skipped\");\n\t\tassertEquals(0, testEvents.aborted().count(), \"# tests aborted\");\n\t\tassertEquals(1, testEvents.failed().count(), \"# tests failed\");\n\n\t\tassertEquals(asList(\n\t\t\t\"fooBeforeEachCallback\",\n\t\t\t\"exceptionThrowingBeforeEachCallback\", // throws an exception.\n\t\t\t\"barAfterEachCallback\",\n\t\t\t\"fooAfterEachCallback\"\n\t\t), callSequence, \"wrong call sequence\");\n\n\t\tassertThat(actualExceptionInAfterEachCallback).containsInstanceOf(EnigmaException.class);\n\t}",
    "comment": "@formatter:off\nbarBeforeEachCallback should not get invoked.\nbeforeEachMethod should not get invoked.\ntest should not get invoked.\nafterEachMethod should not get invoked.\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/scanning/ClassFilter.java",
    "type": "method",
    "name": "match",
    "code": "public boolean match(Class<?> type) {\n\t\treturn classPredicate.test(type);\n\t}",
    "comment": "Test the given class using the stored class predicate.\n\n@param type the type to test; never {@code null}\n@return {@code true} if the input type matches the predicate, otherwise\n{@code false}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java",
    "type": "method",
    "name": "getExclusiveResourceCollector",
    "code": "public ExclusiveResourceCollector getExclusiveResourceCollector() {\n\t\tExclusiveResourceCollector collector = ExclusiveResourceCollector.from(getTestMethod());\n\n\t\tif (collector.getStaticResourcesFor(CHILDREN).findAny().isPresent()) {\n\t\t\tString message = \"'ResourceLockTarget.CHILDREN' is not supported for methods.\" + //\n\t\t\t\t\t\" Invalid method: \" + getTestMethod();\n\t\t\tthrow new JUnitException(message);\n\t\t}\n\n\t\treturn collector;\n\t}",
    "comment": "--- Node ----------------------------------------------------------------\nThere's no need to cache this as this method should only be called once"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlan.java",
    "type": "method",
    "name": "sortedNodes",
    "code": "public List<BuildStep> sortedNodes() {\n        if (sortedNodes == null) {\n            synchronized (this) {\n                if (sortedNodes == null) {\n                    List<BuildStep> sortedNodes = new ArrayList<>();\n                    Set<BuildStep> visited = new HashSet<>();\n                    allSteps().forEach(node -> visitNode(node, visited, sortedNodes));\n                    Collections.reverse(sortedNodes);\n                    this.sortedNodes = sortedNodes;\n                }\n            }\n        }\n        return sortedNodes;\n    }",
    "comment": "Visit each unvisited node\nReverse the sorted nodes to get the correct order"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/KVStoreSerializer.java",
    "type": "method",
    "name": "KVStoreSerializer",
    "code": "public KVStoreSerializer() {\n    this.mapper = new ObjectMapper();\n  }",
    "comment": "Object mapper used to process app-specific types. If an application requires a specific\nconfiguration of the mapper, it can subclass this serializer and add custom configuration\nto this object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/aether/DefaultRepositorySystemSessionFactory.java",
    "type": "method",
    "name": "createMergedProperties",
    "code": "private Map<String, String> createMergedProperties(MavenExecutionRequest request) {\n        Map<String, String> mergedProps = new HashMap<>();\n        mergedProps.putAll(getPropertiesFromRequestedProfiles(request));\n        mergedProps.putAll(new HashMap<String, String>((Map) request.getSystemProperties()));\n        mergedProps.putAll(new HashMap<String, String>((Map) request.getUserProperties()));\n        return mergedProps;\n    }",
    "comment": "this throwaway map is really ONLY to get config from (profiles + env + system + user)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "gallopRight",
    "code": "private int gallopRight(K key, Buffer a, int base, int len, int hint, Comparator<? super K> c) {\n      assert len > 0 && hint >= 0 && hint < len;\n\n      int ofs = 1;\n      int lastOfs = 0;\n      K key1 = s.newKey();\n\n      if (c.compare(key, s.getKey(a, base + hint, key1)) < 0) {\n        // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]\n        int maxOfs = hint + 1;\n        while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint - ofs, key1)) < 0) {\n          lastOfs = ofs;\n          ofs = (ofs << 1) + 1;\n          if (ofs <= 0)   // int overflow\n            ofs = maxOfs;\n        }\n        if (ofs > maxOfs)\n          ofs = maxOfs;\n\n        // Make offsets relative to b\n        int tmp = lastOfs;\n        lastOfs = hint - ofs;\n        ofs = hint - tmp;\n      } else { // a[b + hint] <= key\n        // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]\n        int maxOfs = len - hint;\n        while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint + ofs, key1)) >= 0) {\n          lastOfs = ofs;\n          ofs = (ofs << 1) + 1;\n          if (ofs <= 0)   // int overflow\n            ofs = maxOfs;\n        }\n        if (ofs > maxOfs)\n          ofs = maxOfs;\n\n        // Make offsets relative to b\n        lastOfs += hint;\n        ofs += hint;\n      }\n      assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;\n\n      /*\n       * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to\n       * the right of lastOfs but no farther right than ofs.  Do a binary\n       * search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].\n       */\n      lastOfs++;\n      while (lastOfs < ofs) {\n        int m = lastOfs + ((ofs - lastOfs) >>> 1);\n\n        if (c.compare(key, s.getKey(a, base + m, key1)) < 0)\n          ofs = m;          // key < a[b + m]\n        else\n          lastOfs = m + 1;  // a[b + m] <= key\n      }\n      assert lastOfs == ofs;    // so a[b + ofs - 1] <= key < a[b + ofs]\n      return ofs;\n    }",
    "comment": "Like gallopLeft, except that if the range contains an element equal to\nkey, gallopRight returns the index after the rightmost equal element.\n\n@param key the key whose insertion point to search for\n@param a the array in which to search\n@param base the index of the first element in the range\n@param len the length of the range; must be > 0\n@param hint the index at which to begin the search, 0 <= hint < n.\nThe closer hint is to the result, the faster this method will run.\n@param c the comparator used to order the range, and to search\n@return the int k,  0 <= k <= n such that a[b + k - 1] <= key < a[b + k]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getSourceRootDirs",
    "code": "private List<String> getSourceRootDirs(ProjectScope scope, Language language) {\n        return getEnabledSourceRoots(scope, language)\n                .map((source) -> source.directory().toString())\n                .toList();\n    }",
    "comment": "Returns a list of paths for the given scope.\n\n@deprecated Used only for the implementation of deprecated methods."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/test/java/org/apache/spark/sql/catalyst/expressions/HiveHasherSuite.java",
    "type": "method",
    "name": "randomizedStressTestBytes",
    "code": "public void randomizedStressTestBytes() {\n    int size = 65536;\n    Random rand = new Random();\n\n    Set<Integer> hashcodes = new HashSet<>();\n    for (int i = 0; i < size; i++) {\n      int byteArrSize = rand.nextInt(100) * 8;\n      byte[] bytes = new byte[byteArrSize];\n      rand.nextBytes(bytes);\n\n      Assertions.assertEquals(\n          HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize),\n          HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n\n      hashcodes.add(HiveHasher.hashUnsafeBytes(\n          bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n    }\n\n    Assertions.assertTrue(hashcodes.size() > size * 0.95);\n  }",
    "comment": "A set used to track collision rate.\nA very loose bound."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestInstanceFactoryTests.java",
    "type": "method",
    "name": "createTestInstance",
    "code": "public Object createTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext extensionContext) {\n\t\t\tClass<?> testClass = factoryContext.getTestClass();\n\t\t\tString className = testClass.getName();\n\n\t\t\tinstantiated(getClass(), testClass);\n\n\t\t\ttry (var testClassLoader = TestClassLoader.forClasses(testClass)) {\n\t\t\t\t// Load test class from different class loader\n\t\t\t\tClass<?> clazz = testClassLoader.loadClass(className);\n\t\t\t\treturn ReflectionSupport.newInstance(clazz);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new RuntimeException(\"Failed to load class [\" + className + \"]\", ex);\n\t\t\t}\n\t\t}",
    "comment": "This does not actually create a proxy. Rather, it simulates what\na proxy-based implementation might do, by loading the class from a\ndifferent {@link ClassLoader}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/extensions/HttpServerResource.java",
    "type": "method",
    "name": "start",
    "code": "void start() {\n\t\t// Example handler\n\t\thttpServer.createContext(\"/example\", exchange -> {\n\t\t\tString body = \"This is a test\";\n\t\t\texchange.sendResponseHeaders(200, body.length());\n\t\t\ttry (OutputStream os = exchange.getResponseBody()) {\n\t\t\t\tos.write(body.getBytes(UTF_8));\n\t\t\t}\n\t\t});\n\t\thttpServer.setExecutor(null);\n\t\thttpServer.start();\n\t}",
    "comment": "Starts the Http server with an example handler."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/model/profile/ConditionParserTest.java",
    "type": "method",
    "name": "testParenthesesMismatch",
    "code": "void testParenthesesMismatch() {\n        functions.put(\"property\", args -> \"foo\");\n        functions.put(\"inrange\", args -> false);\n        assertThrows(\n                RuntimeException.class,\n                () -> parser.parse(\n                        \"property('os.name') == 'windows' && property('os.arch') != 'amd64') && inrange(property('os.version'), '[99,)')\"),\n                \"Should throw RuntimeException due to parentheses mismatch\");\n\n        assertThrows(\n                RuntimeException.class,\n                () -> parser.parse(\n                        \"(property('os.name') == 'windows' && property('os.arch') != 'amd64') && inrange(property('os.version'), '[99,)'\"),\n                \"Should throw RuntimeException due to parentheses mismatch\");\n\n        assertDoesNotThrow(\n                () -> parser.parse(\n                        \"(property('os.name') == 'windows' && property('os.arch') != 'amd64') && inrange(property('os.version'), '[99,)')\"));\n    }",
    "comment": "This should not throw an exception if parentheses are balanced and properties are handled correctly"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-stub/src/main/java/com/iluwatar/servicestub/RealSentimentAnalysisServer.java",
    "type": "method",
    "name": "RealSentimentAnalysisServer",
    "code": "public RealSentimentAnalysisServer(Supplier<Integer> sentimentSupplier) {\n    this.sentimentSupplier = sentimentSupplier;\n  }",
    "comment": "A real sentiment analysis implementation would analyze the input string using, e.g., NLP and\ndetermine whether the sentiment is positive, negative or neutral. Here we simply choose a\nrandom number to simulate this. The \"model\" may take some time to process the input and we\nsimulate this by delaying the execution 5 seconds. Analyzes the sentiment of the given input\nstring and returns the classification result (Positive, Negative, or Neutral)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelData.java",
    "type": "method",
    "name": "setActiveProfiles",
    "code": "public void setActiveProfiles(List<Profile> activeProfiles) {\n        this.activeProfiles = activeProfiles;\n    }",
    "comment": "Sets the active profiles from the model.\n\n@param activeProfiles The active profiles, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "normalizedCollationName",
    "code": "protected String normalizedCollationName() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(locale);\n        if (caseSensitivity != CaseSensitivity.CS) {\n          builder.append('_');\n          builder.append(caseSensitivity.toString());\n        }\n        if (accentSensitivity != AccentSensitivity.AS) {\n          builder.append('_');\n          builder.append(accentSensitivity.toString());\n        }\n        if(spaceTrimming != SpaceTrimming.NONE) {\n          builder.append('_');\n          builder.append(spaceTrimming.toString());\n        }\n        return builder.toString();\n      }",
    "comment": "Compute normalized collation name. Components of collation name are given in order:\n- Locale name\n- Optional case sensitivity when non-default preceded by underscore\n- Optional accent sensitivity when non-default preceded by underscore\n- Optional space trimming when non-default preceded by underscore\nExamples: en, en_USA_CI_LTRIM, en_USA_CI_AI, en_USA_CI_AI_TRIM, sr_Cyrl_SRB_AI."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "trimLeft",
    "code": "public UTF8String trimLeft() {\n    int s = 0;\n    // skip all of the space (0x20) in the left side\n    while (s < this.numBytes && getByte(s) == 0x20) s++;\n    if (s == 0) {\n      // Nothing trimmed\n      return this;\n    }\n    if (s == this.numBytes) {\n      // Everything trimmed\n      return EMPTY_UTF8;\n    }\n    return copyUTF8String(s, this.numBytes - 1);\n  }",
    "comment": "Trims space characters (ASCII 32) from the start of this string.\n\n@return this string with no spaces at the start"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/protocol/StreamHandle.java",
    "type": "method",
    "name": "StreamHandle",
    "code": "public StreamHandle(long streamId, int numChunks) {\n    this.streamId = streamId;\n    this.numChunks = numChunks;\n  }",
    "comment": "Identifier for a fixed number of chunks to read from a stream created by an \"open blocks\"\nmessage. This is used by {@link org.apache.spark.network.shuffle.OneForOneBlockFetcher}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/manipulation/Filter.java",
    "type": "method",
    "name": "matchMethodDescription",
    "code": "public static Filter matchMethodDescription(final Description desiredDescription) {\n        return new Filter() {\n\n                // explicitly check if any children want to run\n                for (Description each : description.getChildren()) {\n                    if (shouldRun(each)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            @Override\n            public String describe() {\n                return String.format(\"Method %s\", desiredDescription.getDisplayName());\n            }\n        };",
    "comment": "Returns a {@code Filter} that only runs the single method described by\n{@code desiredDescription}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(long expected, Long actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals((Long) expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/filter/Not.java",
    "type": "method",
    "name": "Not",
    "code": "public Not(Predicate child) {\n    super(\"NOT\", new Predicate[]{child});\n\n  public Predicate child() { return (Predicate) children()[0]; }\n}",
    "comment": "A predicate that evaluates to {@code true} iff {@code child} is evaluated to {@code false}.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(String message, boolean condition) {\n        Assert.assertTrue(message, condition);\n    }",
    "comment": "Asserts that a condition is true. If it isn't it throws\nan AssertionFailedError with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "a",
    "code": "default MessageBuilder a(Object value) {\n        return append(String.valueOf(value));\n    }",
    "comment": "Append content to the message buffer.\n\n@param value the content to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/gpu/java/src/main/java/org/tensorflow/lite/gpu/GpuDelegate.java",
    "type": "method",
    "name": "GpuDelegate",
    "code": "public GpuDelegate(GpuDelegateFactory.Options options) {\n    GpuDelegateNative.init();\n    delegateHandle =\n        createDelegate(\n            options.isPrecisionLossAllowed(),\n            options.areQuantizedModelsAllowed(),\n            options.getInferencePreference(),\n            options.getSerializationDir(),\n            options.getModelToken(),\n            options.getForceBackend().value());\n  }",
    "comment": "{@link Delegate} for GPU inference.\n\n<p>Note: When calling {@code Interpreter.Options.addDelegate()} and {@code Interpreter.run()},\nthe caller must have an {@code EGLContext} in the <b>current thread</b> and {@code\nInterpreter.run()} must be called from the same {@code EGLContext}. If an {@code EGLContext} does\nnot exist, the delegate will internally create one, but then the developer must ensure that\n{@code Interpreter.run()} is always called from the same thread in which {@code\nInterpreter.Options.addDelegate()} was called."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfig.java",
    "type": "method",
    "name": "enableLauncherDiscoveryListenerAutoRegistration",
    "code": "public Builder enableLauncherDiscoveryListenerAutoRegistration(boolean enabled) {\n\t\t\tthis.launcherDiscoveryListenerAutoRegistrationEnabled = enabled;\n\t\t\treturn this;\n\t\t}",
    "comment": "Configure the auto-registration flag for launcher discovery\nlisteners.\n\n<p>Defaults to {@code true}.\n\n@param enabled {@code true} if launcher discovery listeners should be\nautomatically registered\n@return this builder for method chaining\n@since 1.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Long> create(Scope scope, long[][][][][] data) {\n    return create(scope, data, Long.class);\n  }",
    "comment": "Creates a rank-5 constant of {@code long} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "createTestDescription",
    "code": "public static Description createTestDescription(String className, String name, Serializable uniqueId) {\n        return new Description(null, formatDisplayName(name, className), uniqueId);\n    }",
    "comment": "Create a <code>Description</code> of a single test named <code>name</code> in the class <code>clazz</code>.\nGenerally, this will be a leaf <code>Description</code>.\n\n@param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n@return a <code>Description</code> named <code>name</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isStatic",
    "code": "public static boolean isStatic(Member member) {\n\t\treturn ReflectionUtils.isStatic(member);\n\t}",
    "comment": "Determine if the supplied member is {@code static}.\n\n@param member the member to check; never {@code null}\n@return {@code true} if the member is {@code static}\n@see java.lang.reflect.Modifier#isStatic(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dynamic-proxy/src/main/java/com/iluwatar/dynamicproxy/tinyrestclient/JsonUtil.java",
    "type": "method",
    "name": "jsonToObject",
    "code": "public static <T> T jsonToObject(String json, Class<T> clazz) {\n    try {\n      return objectMapper.readValue(json, clazz);\n    } catch (IOException e) {\n      LOGGER.error(\"Cannot convert the Json \" + json + \" to class \" + clazz.getName() + \".\", e);\n      return null;\n    }\n  }",
    "comment": "Convert a Json string to an object of a class.\n\n@param json Json string to convert.\n@param clazz Object's class.\n@param <T> Object's generic class.\n@return Object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/PartitionReaderFactory.java",
    "type": "method",
    "name": "createColumnarReader",
    "code": "default PartitionReader<ColumnarBatch> createColumnarReader(InputPartition partition) {\n    throw new SparkUnsupportedOperationException(\"_LEGACY_ERROR_TEMP_3150\");\n  }",
    "comment": "Returns a columnar partition reader to read data from the given {@link InputPartition}.\n<p>\nImplementations probably need to cast the input partition to the concrete\n{@link InputPartition} class defined for the data source."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/service/VehicleService.java",
    "type": "method",
    "name": "updateVehicle",
    "code": "public Vehicle updateVehicle(Vehicle vehicle) {\n    return vehicleRepository.save(vehicle);\n  }",
    "comment": "A method to update a vehicle in the database.\n\n@param vehicle Vehicle object\n@see Vehicle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/RuntimeUtils.java",
    "type": "method",
    "name": "getInputArguments",
    "code": "static Optional<List<String>> getInputArguments() {\n\t\tOptional<Class<?>> managementFactoryClass = ReflectionUtils.tryToLoadClass(\n\t\t\t\"java.lang.management.ManagementFactory\").toOptional();\n\t\tif (!managementFactoryClass.isPresent()) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\t// Can't use \"java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments()\"\n\t\t// directly as module \"java.management\" might not be available and/or the current platform\n\t\t// doesn't support the Java Management Extensions (JMX) API (like Android?).\n\t\t// See https://github.com/junit-team/junit4/pull/1187\n\t\ttry {\n\t\t\tObject bean = managementFactoryClass.get().getMethod(\"getRuntimeMXBean\").invoke(null);\n\t\t\tClass<?> mx = ReflectionUtils.tryToLoadClass(\"java.lang.management.RuntimeMXBean\").get();\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tList<String> args = (List<String>) mx.getMethod(\"getInputArguments\").invoke(bean);\n\t\t\treturn Optional.of(args);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t}",
    "comment": "Try to get the input arguments the VM was started with."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Named.java",
    "type": "method",
    "name": "named",
    "code": "static <T> Named<T> named(String name, T payload) {\n\t\treturn of(name, payload);\n\t}",
    "comment": "Factory method for creating an instance of {@code Named} based on a\n{@code name} and a {@code payload}.\n\n<p>This method is an <em>alias</em> for {@link Named#of} and is\nintended to be used when statically imported &mdash; for example, via:\n{@code import static org.junit.jupiter.api.Named.named;}\n\n@param name the name associated with the payload; never {@code null} or\nblank\n@param payload the object that serves as the payload; may be {@code null}\ndepending on the use case\n@param <T> the type of the payload\n@return an instance of {@code Named}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/ImageUtils.java",
    "type": "method",
    "name": "YUV2RGB",
    "code": "private static int YUV2RGB(int y, int u, int v) {\n    y = (y - 16) < 0 ? 0 : (y - 16);\n    u -= 128;\n    v -= 128;\n\n    int y1192 = 1192 * y;\n    int r = (y1192 + 1634 * v);\n    int g = (y1192 - 833 * v - 400 * u);\n    int b = (y1192 + 2066 * u);\n\n    r = r > kMaxChannelValue ? kMaxChannelValue : (r < 0 ? 0 : r);\n    g = g > kMaxChannelValue ? kMaxChannelValue : (g < 0 ? 0 : g);\n    b = b > kMaxChannelValue ? kMaxChannelValue : (b < 0 ? 0 : b);\n\n    return 0xff000000 | ((r << 6) & 0xff0000) | ((g >> 2) & 0xff00) | ((b >> 10) & 0xff);\n  }",
    "comment": "Adjust and check YUV values\nThis is the floating point equivalent. We do the conversion in integer\nbecause some Android devices do not have floating point in hardware.\nnR = (int)(1.164 * nY + 2.018 * nU);\nnG = (int)(1.164 * nY - 0.813 * nV - 0.391 * nU);\nnB = (int)(1.164 * nY + 1.596 * nV);\nClipping RGB values to be inside boundaries [ 0 , kMaxChannelValue ]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/tasks/VerboseTreePrintingListener.java",
    "type": "method",
    "name": "printDetails",
    "code": "private void printDetails(TestIdentifier testIdentifier) {\n\t\tprintDetail(NONE, \"tags\", \"%s%n\", testIdentifier.getTags());\n\t\tprintDetail(NONE, \"uniqueId\", \"%s%n\", testIdentifier.getUniqueId());\n\t\tprintDetail(NONE, \"parent\", \"%s%n\", testIdentifier.getParentId().orElse(\"[]\"));\n\t\ttestIdentifier.getSource().ifPresent(source -> printDetail(NONE, \"source\", \"%s%n\", source));\n\t}",
    "comment": "Print static information about the test identifier."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "engine",
    "code": "public static Builder engine(String engineId) {\n\t\tPreconditions.notBlank(engineId, \"TestEngine ID must not be null or blank\");\n\t\treturn engine(loadTestEngine(engineId.trim()));\n\t}",
    "comment": "Create an execution {@link Builder} for the {@link TestEngine} with the\nsupplied ID.\n\n<p>The {@code TestEngine} will be loaded via Java's {@link ServiceLoader}\nmechanism, analogous to the manner in which test engines are loaded in\nthe JUnit Platform Launcher API.\n\n<h4>Example Usage</h4>\n\n<pre class=\"code\">\nEngineTestKit\n.engine(\"junit-jupiter\")\n.selectors(selectClass(MyTests.class))\n.execute()\n.testEvents()\n.assertStatistics(stats -&gt; stats.started(2).finished(2));\n</pre>\n\n@param engineId the ID of the {@code TestEngine} to use; must not be\n{@code null} or <em>blank</em>\n@return the engine execution {@code Builder}\n@throws PreconditionViolationException if the supplied ID is {@code null}\nor <em>blank</em>, or if the {@code TestEngine} with the supplied ID\ncannot be loaded\n@see #engine(TestEngine)\n@see #execute(String, LauncherDiscoveryRequest)\n@see #execute(TestEngine, LauncherDiscoveryRequest)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/Product.java",
    "type": "method",
    "name": "Product",
    "code": "public Product(final String pdtId, final String firstName, final double p) {\n    this.id = pdtId;\n    this.name = firstName;\n    this.price = p;\n  }",
    "comment": "Constructs a new Product with the given details.\n\n@param pdtId The unique identifier of the product.\n@param firstName The name of the product.\n@param p The price of the product."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/transfer/FileSizeFormat.java",
    "type": "method",
    "name": "formatRate",
    "code": "public void formatRate(MessageBuilder builder, double rate) {\n        if (Double.isNaN(rate) || Double.isInfinite(rate) || rate < 0) {\n            builder.append(\"? B/s\");\n            return;\n        }\n\n        ScaleUnit unit = ScaleUnit.getScaleUnit(Math.round(rate));\n        double scaledRate = rate / unit.bytes();\n        builder.append(String.format(\"%.1f\", scaledRate));\n        builder.append(\" \").append(unit.symbol()).append(\"/s\");\n    }",
    "comment": "Handle invalid rates gracefully (including negative values)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeArrayWriter.java",
    "type": "method",
    "name": "initialize",
    "code": "public void initialize(int numElements) {\n    this.numElements = numElements;\n    this.headerInBytes = calculateHeaderPortionInBytes(numElements);\n\n    this.startingOffset = cursor();\n\n    long fixedPartInBytesLong =\n      ByteArrayMethods.roundNumberOfBytesToNearestWord((long) elementSize * numElements);\n    long totalInitialSize = headerInBytes + fixedPartInBytesLong;\n\n    if (totalInitialSize > Integer.MAX_VALUE) {\n      throw QueryExecutionErrors.tooManyArrayElementsError(\n        fixedPartInBytesLong,  Integer.MAX_VALUE);\n    }\n\n    int fixedPartInBytes = (int) fixedPartInBytesLong;\n    holder.grow((int)totalInitialSize);\n\n    Platform.putLong(getBuffer(), startingOffset, numElements);\n    for (int i = 8; i < headerInBytes; i += 8) {\n      Platform.putLong(getBuffer(), startingOffset + i, 0L);\n    }\n\n    for (int i = elementSize * numElements; i < fixedPartInBytes; i++) {\n      Platform.putByte(getBuffer(), startingOffset + headerInBytes + i, (byte) 0);\n    }\n    increaseCursor(headerInBytes + fixedPartInBytes);\n  }",
    "comment": "We need 8 bytes to store numElements in header\nit's now safe to cast fixedPartInBytesLong and totalInitialSize to int\nGrows the global buffer ahead for header and fixed size data.\nWrite numElements and clear out null bits to header\nfill 0 into reminder part of 8-bytes alignment in unsafe array"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/BloomFilterImpl.java",
    "type": "method",
    "name": "putLong",
    "code": "public boolean putLong(long item) {\n    int h1 = Murmur3_x86_32.hashLong(item, 0);\n    int h2 = Murmur3_x86_32.hashLong(item, h1);\n\n    long bitSize = bits.bitSize();\n    boolean bitsChanged = false;\n    for (int i = 1; i <= numHashFunctions; i++) {\n      int combinedHash = h1 + (i * h2);\n      if (combinedHash < 0) {\n        combinedHash = ~combinedHash;\n      }\n      bitsChanged |= bits.set(combinedHash % bitSize);\n    }\n    return bitsChanged;\n  }",
    "comment": "Here we first hash the input long element into 2 int hash values, h1 and h2, then produce n\nhash values by `h1 + i * h2` with 1 <= i <= numHashFunctions.\nNote that `CountMinSketch` use a different strategy, it hash the input long element with\nevery i to produce n hash values.\nTODO: the strategy of `CountMinSketch` looks more advanced, should we follow it here?\nFlip all the bits if it's negative (guaranteed positive number)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "errors",
    "code": "public synchronized Enumeration<TestFailure> errors() {\n        return Collections.enumeration(fErrors);\n    }",
    "comment": "Returns an Enumeration for the errors."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertDoesNotThrow",
    "code": "public static <T> T assertDoesNotThrow(ThrowingSupplier<T> supplier, String message) {\n\t\treturn AssertDoesNotThrow.assertDoesNotThrow(supplier, message);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code supplier} does\n<em>not</em> throw any kind of {@linkplain Throwable exception}.\n\n<p>If the assertion passes, the {@code supplier}'s result will be returned.\n\n<p>Fails with the supplied failure {@code message}.\n\n<h4>Usage Note</h4>\n<p>Although any exception thrown from a test method will cause the test\nto <em>fail</em>, there are certain use cases where it can be beneficial\nto explicitly assert that an exception is not thrown for a given code\nblock within a test method.\n\n@since 5.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaApplySchemaSuite.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n    spark = SparkSession.builder()\n      .master(\"local[*]\")\n      .appName(\"testing\")\n      .getOrCreate();\n    jsc = new JavaSparkContext(spark.sparkContext());\n  }",
    "comment": "The test suite itself is Serializable so that anonymous Function implementations can be\nserialized, as an alternative to converting these anonymous classes to static inner classes;\nsee http://stackoverflow.com/questions/758570/."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestPlan.java",
    "type": "method",
    "name": "getDescendants",
    "code": "public Set<TestIdentifier> getDescendants(TestIdentifier parent) {\n\t\tPreconditions.notNull(parent, \"parent must not be null\");\n\t\tSet<TestIdentifier> result = new LinkedHashSet<>(16);\n\t\tSet<TestIdentifier> children = getChildren(parent);\n\t\tresult.addAll(children);\n\t\tfor (TestIdentifier child : children) {\n\t\t\tresult.addAll(getDescendants(child));\n\t\t}\n\t\treturn unmodifiableSet(result);\n\t}",
    "comment": "Get all descendants of the supplied {@link TestIdentifier} (i.e.,\nall of its children and their children, recursively).\n\n@param parent the identifier to look up the descendants for; never {@code null}\n@return an unmodifiable set of the parent's descendants, potentially empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "updateColumnComment",
    "code": "static TableChange updateColumnComment(String[] fieldNames, String newComment) {\n    return new UpdateColumnComment(fieldNames, newComment);\n  }",
    "comment": "Create a TableChange for updating the comment of a field.\n<p>\nThe name is used to find the field to update.\n<p>\nIf the field does not exist, the change will result in an {@link IllegalArgumentException}.\n\n@param fieldNames field names of the column to update\n@param newComment the new comment\n@return a TableChange for the update"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(byte[] expected, byte[] actual, Supplier<String> messageSupplier) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} byte arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(int[] expected, int[] actual) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} int arrays are equal.\n<p>If both are {@code null}, they are considered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicSample/app/src/main/java/com/example/android/persistence/AppExecutors.java",
    "type": "method",
    "name": "AppExecutors",
    "code": "private AppExecutors(Executor diskIO, Executor networkIO, Executor mainThread) {\n        this.mDiskIO = diskIO;\n        this.mNetworkIO = networkIO;\n        this.mMainThread = mainThread;\n    }",
    "comment": "Global executor pools for the whole application.\n<p>\nGrouping tasks like this avoids the effects of task starvation (e.g. disk reads don't wait behind\nwebservice requests)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setByte",
    "code": "public void setByte(byte value) {\n    byteData = value;\n  }",
    "comment": "Sets the byte `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "newBuilder",
    "code": "static Builder newBuilder() {\n        return new Builder();\n    }",
    "comment": "Returns a new builder for creating XmlNode instances.\n\n@return a new Builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/DefaultMavenProjectHelper.java",
    "type": "method",
    "name": "attachArtifact",
    "code": "public void attachArtifact(MavenProject project, Artifact artifact) {\n        project.addAttachedArtifact(artifact);\n    }",
    "comment": "Add an attached artifact or replace the file for an existing artifact.\n\n@see MavenProject#addAttachedArtifact(org.apache.maven.artifact.Artifact)\n@param project project reference.\n@param artifact artifact to add or replace."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/bully/BullyMessageManager.java",
    "type": "method",
    "name": "sendLeaderMessage",
    "code": "public boolean sendLeaderMessage(int currentId, int leaderId) {\n    var leaderMessage = new Message(MessageType.LEADER, String.valueOf(leaderId));\n    instanceMap.keySet().stream()\n        .filter((i) -> i != currentId)\n        .forEach((i) -> instanceMap.get(i).onMessage(leaderMessage));\n    return false;\n  }",
    "comment": "Send leader message to all the instances to notify the new leader.\n\n@param currentId Instance ID of which sends this message.\n@param leaderId Leader message content.\n@return {@code true} if the message is accepted."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/filter/ClasspathScanningSupport.java",
    "type": "method",
    "name": "buildClassNamePredicate",
    "code": "public static Predicate<String> buildClassNamePredicate(EngineDiscoveryRequest request) {\n\t\tList<DiscoveryFilter<String>> filters = new ArrayList<>();\n\t\tfilters.addAll(request.getFiltersByType(ClassNameFilter.class));\n\t\tfilters.addAll(request.getFiltersByType(PackageNameFilter.class));\n\t\treturn composeFilters(filters).toPredicate();\n\t}",
    "comment": "Build a {@link Predicate} for fully qualified class names to be used for\nclasspath scanning from an {@link EngineDiscoveryRequest}.\n\n@param request the request to build a predicate from\n@deprecated Please use {@link org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/transaction-script/src/test/java/com/iluwatar/transactionscript/HotelDaoImplTest.java",
    "type": "method",
    "name": "addingARoomFailsWithExceptionAsFeedbackToClient",
    "code": "void addingARoomFailsWithExceptionAsFeedbackToClient() {\n      assertThrows(Exception.class, () -> dao.add(new Room(2, \"Double\", 80, false)));\n    }",
    "comment": "setup a connection failure scenario.\n\n@throws SQLException if any error occurs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/condition/OS.java",
    "type": "method",
    "name": "isCurrentOs",
    "code": "public boolean isCurrentOs() {\n\t\treturn this == CURRENT_OS;\n\t}",
    "comment": "@return {@code true} if <em>this</em> {@code OS} is known to be the\noperating system on which the current JVM is executing"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RetryingBlockTransferor.java",
    "type": "method",
    "name": "onBlockTransferSuccess",
    "code": "public void onBlockTransferSuccess(String blockId, ManagedBuffer data) {\n      throw new RuntimeException(\n        \"Invocation on RetryingBlockTransferListener.onBlockTransferSuccess is unexpected.\");\n    }",
    "comment": "RetryingBlockTransferListener's onBlockTransferSuccess and onBlockTransferFailure\nshouldn't be invoked. We only invoke these 2 methods on the parent listener."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "newDefaultFilterMap",
    "code": "public Map<String, String> newDefaultFilterMap() {\n        Map<String, String> filterMap = new HashMap<>();\n\n        Path basedir = Paths.get(getBasedir()).toAbsolutePath();\n        filterMap.put(\"@basedir@\", basedir.toString());\n        filterMap.put(\"@baseurl@\", basedir.toUri().toASCIIString());\n\n        return filterMap;\n    }",
    "comment": "Gets a new copy of the default filter map. These default filter map, contains the tokens \"@basedir@\" and\n\"@baseurl@\" to the test's base directory and its base <code>file:</code> URL, respectively.\n\n@return The (modifiable) map with the default filter map, never <code>null</code>.\n@since 2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/scanning/DefaultClasspathScanner.java",
    "type": "method",
    "name": "determineFullyQualifiedResourceName",
    "code": "private String determineFullyQualifiedResourceName(Path baseDir, String basePackageName, Path resourceFile) {\n\t\t// @formatter:off\n\t\treturn Stream.of(\n\t\t\t\t\tpackagePath(basePackageName),\n\t\t\t\t\tpackagePath(determineSubpackageName(baseDir, resourceFile)),\n\t\t\t\t\tdetermineSimpleResourceName(resourceFile)\n\t\t\t\t)\n\t\t\t\t.filter(value -> !value.isEmpty()) // Handle default package appropriately.\n\t\t\t\t.collect(joining(CLASSPATH_RESOURCE_PATH_SEPARATOR_STRING));\n\t\t// @formatter:on\n\t}",
    "comment": "The fully qualified resource name is a {@code /}-separated path.\n\n<p>The path is relative to the classpath root in which the resource is\nlocated.\n\n@return the resource name; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "mergeLo",
    "code": "private void mergeLo(int base1, int len1, int base2, int len2) {\n      assert len1 > 0 && len2 > 0 && base1 + len1 == base2;\n\n      // Copy first run into temp array\n      Buffer a = this.a; // For performance\n      Buffer tmp = ensureCapacity(len1);\n      s.copyRange(a, base1, tmp, 0, len1);\n\n      int cursor1 = 0;       // Indexes into tmp array\n      int cursor2 = base2;   // Indexes int a\n      int dest = base1;      // Indexes int a\n\n      // Move first element of second run and deal with degenerate cases\n      s.copyElement(a, cursor2++, a, dest++);\n      if (--len2 == 0) {\n        s.copyRange(tmp, cursor1, a, dest, len1);\n        return;\n      }\n      if (len1 == 1) {\n        s.copyRange(a, cursor2, a, dest, len2);\n        s.copyElement(tmp, cursor1, a, dest + len2); // Last elt of run 1 to end of merge\n        return;\n      }\n\n      K key0 = s.newKey();\n      K key1 = s.newKey();\n\n      Comparator<? super K> c = this.c;  // Use local variable for performance\n      int minGallop = this.minGallop;    //  \"    \"       \"     \"      \"\n      outer:\n      while (true) {\n        int count1 = 0; // Number of times in a row that first run won\n        int count2 = 0; // Number of times in a row that second run won\n\n        /*\n         * Do the straightforward thing until (if ever) one run starts\n         * winning consistently.\n         */\n        do {\n          assert len1 > 1 && len2 > 0;\n          if (c.compare(s.getKey(a, cursor2, key0), s.getKey(tmp, cursor1, key1)) < 0) {\n            s.copyElement(a, cursor2++, a, dest++);\n            count2++;\n            count1 = 0;\n            if (--len2 == 0)\n              break outer;\n          } else {\n            s.copyElement(tmp, cursor1++, a, dest++);\n            count1++;\n            count2 = 0;\n            if (--len1 == 1)\n              break outer;\n          }\n        } while ((count1 | count2) < minGallop);\n\n        /*\n         * One run is winning so consistently that galloping may be a\n         * huge win. So try that, and continue galloping until (if ever)\n         * neither run appears to be winning consistently anymore.\n         */\n        do {\n          assert len1 > 1 && len2 > 0;\n          count1 = gallopRight(s.getKey(a, cursor2, key0), tmp, cursor1, len1, 0, c);\n          if (count1 != 0) {\n            s.copyRange(tmp, cursor1, a, dest, count1);\n            dest += count1;\n            cursor1 += count1;\n            len1 -= count1;\n            if (len1 <= 1) // len1 == 1 || len1 == 0\n              break outer;\n          }\n          s.copyElement(a, cursor2++, a, dest++);\n          if (--len2 == 0)\n            break outer;\n\n          count2 = gallopLeft(s.getKey(tmp, cursor1, key0), a, cursor2, len2, 0, c);\n          if (count2 != 0) {\n            s.copyRange(a, cursor2, a, dest, count2);\n            dest += count2;\n            cursor2 += count2;\n            len2 -= count2;\n            if (len2 == 0)\n              break outer;\n          }\n          s.copyElement(tmp, cursor1++, a, dest++);\n          if (--len1 == 1)\n            break outer;\n          minGallop--;\n        } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);\n        if (minGallop < 0)\n          minGallop = 0;\n        minGallop += 2;  // Penalize for leaving gallop mode\n      }  // End of \"outer\" loop\n      this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field\n\n      if (len1 == 1) {\n        assert len2 > 0;\n        s.copyRange(a, cursor2, a, dest, len2);\n        s.copyElement(tmp, cursor1, a, dest + len2); //  Last elt of run 1 to end of merge\n      } else if (len1 == 0) {\n        throw new IllegalArgumentException(\n            \"Comparison method violates its general contract!\");\n      } else {\n        assert len2 == 0;\n        assert len1 > 1;\n        s.copyRange(tmp, cursor1, a, dest, len1);\n      }\n    }",
    "comment": "Merges two adjacent runs in place, in a stable fashion.  The first\nelement of the first run must be greater than the first element of the\nsecond run (a[base1] > a[base2]), and the last element of the first run\n(a[base1 + len1-1]) must be greater than all elements of the second run.\n\nFor performance, this method should be called only when len1 <= len2;\nits twin, mergeHi should be called if len1 >= len2.  (Either method\nmay be called if len1 == len2.)\n\n@param base1 index of first element in first run to be merged\n@param len1  length of first run to be merged (must be > 0)\n@param base2 index of first element in second run to be merged\n(must be aBase + aLen)\n@param len2  length of second run to be merged (must be > 0)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/AssertionsDemo.java",
    "type": "method",
    "name": "timeoutNotExceededWithMethod",
    "code": "void timeoutNotExceededWithMethod() {\n\t\tString actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);\n\t\tassertEquals(\"Hello, World!\", actualGreeting);\n\t}",
    "comment": "end::user_guide[]\ntag::user_guide[]\nThe following assertion invokes a method reference and returns an object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/builder/singlethreaded/SingleThreadedBuilder.java",
    "type": "method",
    "name": "SingleThreadedBuilder",
    "code": "public SingleThreadedBuilder(LifecycleModuleBuilder lifecycleModuleBuilder) {\n        this.lifecycleModuleBuilder = lifecycleModuleBuilder;\n    }",
    "comment": "<p>\nA {@link Builder} encapsulates a strategy for building a set of Maven projects. The default strategy in Maven builds\nthe projects serially, but a {@link Builder} can employ any type of concurrency model to build the projects."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/main/java/com/iluwatar/RegisterWorker.java",
    "type": "method",
    "name": "fail",
    "code": "protected void fail(boolean condition, NotificationError error) {\n    if (condition) {\n      super.getNotification().addError(error);\n    }\n  }",
    "comment": "If a condition is met, adds the error to our notification.\n\n@param condition condition to check for.\n@param error error to add if condition met."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertSame",
    "code": "public static void assertSame(Object expected, Object actual) {\n        assertSame(null, expected, actual);\n    }",
    "comment": "Asserts that two objects refer to the same object. If they are not the\nsame, an {@link AssertionError} without a message is thrown.\n\n@param expected the expected object\n@param actual the object to compare to <code>expected</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/money/src/test/java/com/iluwater/money/MoneyTest.java",
    "type": "method",
    "name": "testExchangeCurrency_NegativeExchangeRate",
    "code": "void testExchangeCurrency_NegativeExchangeRate() {\n    Money money = new Money(100.00, \"USD\");\n\n    assertThrows(IllegalArgumentException.class, () -> money.exchangeCurrency(\"EUR\", -0.85));\n  }",
    "comment": "Test converting currency with a negative exchange rate"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "execute",
    "code": "public static EngineExecutionResults execute(String engineId, LauncherDiscoveryRequest discoveryRequest) {\n\t\tPreconditions.notBlank(engineId, \"TestEngine ID must not be null or blank\");\n\t\treturn execute(loadTestEngine(engineId.trim()), discoveryRequest);\n\t}",
    "comment": "Execute tests for the given {@link LauncherDiscoveryRequest} using the\n{@link TestEngine} with the supplied ID.\n\n<p>The {@code TestEngine} will be loaded via Java's {@link ServiceLoader}\nmechanism, analogous to the manner in which test engines are loaded in\nthe JUnit Platform Launcher API.\n\n<p>{@link org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder}\nprovides a convenient way to build an appropriate discovery request to\nsupply to this method. As an alternative, consider using\n{@link #engine(TestEngine)} for a more fluent API.\n\n@param engineId the ID of the {@code TestEngine} to use; must not be\n{@code null} or <em>blank</em>\n@param discoveryRequest the {@code LauncherDiscoveryRequest} to use\n@return the results of the execution\n@throws PreconditionViolationException for invalid arguments or if the\n{@code TestEngine} with the supplied ID cannot be loaded\n@since 1.7\n@see #execute(TestEngine, LauncherDiscoveryRequest)\n@see #engine(String)\n@see #engine(TestEngine)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/ExtensibleEnums.java",
    "type": "method",
    "name": "projectScope",
    "code": "static ProjectScope projectScope(String id) {\n        return new DefaultProjectScope(id);\n    }",
    "comment": "Creates a new ProjectScope instance with the specified ID.\n\n@param id the identifier for the project scope\n@return a new ProjectScope instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/SupportsOverwriteV2.java",
    "type": "method",
    "name": "truncate",
    "code": "default WriteBuilder truncate() {\n    return overwrite(new Predicate[] { new AlwaysTrue() });\n}",
    "comment": "Configures a write to replace data matching the filters with data committed in the write.\n<p>\nRows must be deleted from the data source if and only if all of the filters match. That is,\nfilters must be interpreted as ANDed together.\n\n@param predicates filters used to match data to overwrite\n@return this write builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-locator/src/main/java/com/iluwatar/servicelocator/ServiceCache.java",
    "type": "method",
    "name": "addService",
    "code": "public void addService(Service newService) {\n    serviceCache.put(newService.getName(), newService);\n  }",
    "comment": "Adds the service into the cache map.\n\n@param newService a {@link Service}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeCustomDefaultParameter",
    "code": "void cleanupModeCustomDefaultParameter() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.configurationParameter(TempDir.DEFAULT_CLEANUP_MODE_PROPERTY_NAME, \"never\")//\n\t\t\t\t\t.selectors(selectMethod(DefaultParameterCase.class, \"testDefaultParameter\", \"java.nio.file.Path\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(defaultParameterDir).exists();\n\t\t}",
    "comment": "Ensure that a custom, global cleanup mode is used for parameters.\n<p/>\nExpect the TempDir NOT to be cleaned up if set to NEVER."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/role-object/src/main/java/com/iluwatar/roleobject/Customer.java",
    "type": "method",
    "name": "newCustomer",
    "code": "public static Customer newCustomer() {\n    return new CustomerCore();\n  }",
    "comment": "Get specific instance associated with this role @see {@link Role}.\n\n@param role to get\n@param expectedRole instance class expected to get\n@return optional with value if the instance exists and corresponds expected class"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/FunctionUtils.java",
    "type": "method",
    "name": "where",
    "code": "public static <T, V> Predicate<T> where(Function<T, V> function, Predicate<? super V> predicate) {\n\t\tPreconditions.notNull(function, \"function must not be null\");\n\t\tPreconditions.notNull(predicate, \"predicate must not be null\");\n\t\treturn input -> predicate.test(function.apply(input));\n\t}",
    "comment": "Return a predicate that first applies the specified function and then\ntests the specified predicate against the result of the function.\n\n@param function the function to apply\n@param predicate the predicate to test against the result of the function"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/event/ExecutionEventLogger.java",
    "type": "method",
    "name": "projectStarted",
    "code": "public void projectStarted(ExecutionEvent event) {\n        if (logger.isInfoEnabled()) {\n            init();\n            MavenProject project = event.getProject();\n\n            logger.info(\"\");\n\n            String projectKey = project.getGroupId() + ':' + project.getArtifactId();\n\n            final String preHeader = \"--< \";\n            final String postHeader = \" >--\";\n\n            final int headerLen = preHeader.length() + projectKey.length() + postHeader.length();\n\n            String prefix = chars('-', Math.max(0, (lineLength - headerLen) / 2)) + preHeader;\n\n            String suffix =\n                    postHeader + chars('-', Math.max(0, lineLength - headerLen - prefix.length() + preHeader.length()));\n\n            logger.info(\n                    builder().strong(prefix).project(projectKey).strong(suffix).toString());\n\n            String building = \"Building \" + event.getProject().getName() + \" \"\n                    + event.getProject().getVersion();\n\n            if (totalProjects <= 1) {\n                infoMain(building);\n            } else {\n                int number;\n                synchronized (this) {\n                    number = ++currentVisitedProjectCount;\n                }\n                String progress = \" [\" + number + '/' + totalProjects + ']';\n\n                int pad = lineLength - building.length() - progress.length();\n\n                infoMain(building + ((pad > 0) ? chars(' ', pad) : \"\") + progress);\n            }\n\n            File currentPom = project.getFile();\n            if (currentPom != null) {\n                MavenSession session = event.getSession();\n                Path current = currentPom.toPath().toAbsolutePath().normalize();\n                Path topDirectory = session.getTopDirectory();\n                if (topDirectory != null && current.startsWith(topDirectory)) {\n                    current = topDirectory.relativize(current);\n                }\n                logger.info(\"  from \" + current);\n            }\n\n            prefix = chars('-', Math.max(0, (lineLength - project.getPackaging().length() - 4) / 2));\n            suffix = chars('-', Math.max(0, lineLength - project.getPackaging().length() - 4 - prefix.length()));\n            infoMain(prefix + \"[ \" + project.getPackaging() + \" ]\" + suffix);\n        }\n    }",
    "comment": "-------< groupId:artifactId >-------\nBuilding Project Name Version    [i/n]\ndisplay progress [i/n]\npath to pom.xml\n----------[ packaging ]----------"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/LevelDBIterator.java",
    "type": "method",
    "name": "loadNext",
    "code": "private byte[] loadNext() {\n    if (count >= max) {\n      return null;\n    }\n\n    while (true) {\n      boolean hasNext = ascending ? it.hasNext() : it.hasPrev();\n      if (!hasNext) {\n        return null;\n      }\n\n      Map.Entry<byte[], byte[]> nextEntry;\n      try {\n        nextEntry = ascending ? it.next() : it.prev();\n      } catch (NoSuchElementException e) {\n        return null;\n      }\n\n      byte[] nextKey = nextEntry.getKey();\n      if (!startsWith(nextKey, indexKeyPrefix)) {\n        return null;\n      }\n\n      if (isEndMarker(nextKey)) {\n        continue;\n      }\n\n      if (end != null) {\n        int comp = compare(nextKey, end) * (ascending ? 1 : -1);\n        if (comp > 0) {\n          return null;\n        }\n      }\n\n      count++;\n\n      return nextEntry.getValue();\n    }\n  }",
    "comment": "Avoid races if another thread is updating the DB.\nNext key is not part of the index, stop.\nIf the next key is an end marker, then skip it.\nIf there's a known end key and iteration has gone past it, stop.\nNext element is part of the iteration, return it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "useOldFetchProtocol",
    "code": "public boolean useOldFetchProtocol() {\n    return conf.getBoolean(\"spark.shuffle.useOldFetchProtocol\", false);\n  }",
    "comment": "Whether to use the old protocol while doing the shuffle block fetching.\nIt is only enabled while we need the compatibility in the scenario of new spark version\njob fetching blocks from old version external shuffle service."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/LimitedInputStream.java",
    "type": "method",
    "name": "LimitedInputStream",
    "code": "public LimitedInputStream(InputStream in, long limit) {\n    this(in, limit, true);\n  }",
    "comment": "Wraps a {@link InputStream}, limiting the number of bytes which can be read.\n\nThis code is from Guava's 14.0 source code, because there is no compatible way to\nuse this functionality in both a Guava 11 environment and a Guava &gt;14 environment."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createVarcharType",
    "code": "public static VarcharType createVarcharType(int length) {\n    return new VarcharType(length);\n  }",
    "comment": "Creates a VarcharType with the given length.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Object expected, Object actual) {\n        assertEquals(null, expected, actual);\n    }",
    "comment": "Asserts that two objects are equal. If they are not, an\n{@link AssertionError} without a message is thrown. If\n<code>expected</code> and <code>actual</code> are <code>null</code>,\nthey are considered equal.\n\n@param expected expected value\n@param actual the value to check against <code>expected</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "length",
    "code": "public Object length(List<Object> args) {\n        if (args.size() != 1) {\n            throw new IllegalArgumentException(\"length function requires exactly one argument\");\n        }\n        String s = ConditionParser.toString(args.get(0));\n        return s.length();\n    }",
    "comment": "Returns the length of the given string.\n\n@param args A list containing a single string argument\n@return The length of the string\n@throws IllegalArgumentException if the number of arguments is not exactly one"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Float> create(Scope scope, float[][][][][][] data) {\n    return create(scope, data, Float.class);\n  }",
    "comment": "Creates a rank-6 constant of {@code float} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/DefaultWagonManagerTest.java",
    "type": "method",
    "name": "getRepo",
    "code": "private ArtifactRepository getRepo(String id) {\n        return getRepo(id, \"http://something\");\n    }",
    "comment": "Build an ArtifactRepository object.\n\n@param id\n@return"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/FrameworkField.java",
    "type": "method",
    "name": "FrameworkField",
    "code": "public FrameworkField(Field field) {\n        if (field == null) {\n            throw new NullPointerException(\n                    \"FrameworkField cannot be created without an underlying field.\");\n        }\n        this.field = field;\n\n        if (isPublic()) {\n            // This field could be a public field in a package-scope base class\n            try {\n                field.setAccessible(true);\n            } catch (SecurityException e) {\n                // We may get an IllegalAccessException when we try to access the field\n            }\n        }\n    }",
    "comment": "Returns a new {@code FrameworkField} for {@code field}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/test/java/org/apache/maven/artifact/versioning/DefaultArtifactVersionTest.java",
    "type": "method",
    "name": "testVersionSnapshotComparing",
    "code": "void testVersionSnapshotComparing() {\n        assertVersionEqual(\"1-SNAPSHOT\", \"1-SNAPSHOT\");\n        assertVersionOlder(\"1-SNAPSHOT\", \"2-SNAPSHOT\");\n        assertVersionOlder(\"1.5-SNAPSHOT\", \"2-SNAPSHOT\");\n        assertVersionOlder(\"1-SNAPSHOT\", \"2.5-SNAPSHOT\");\n        assertVersionEqual(\"1-SNAPSHOT\", \"1.0-SNAPSHOT\");\n        assertVersionEqual(\"1-SNAPSHOT\", \"1.0.0-SNAPSHOT\");\n        assertVersionOlder(\"1.0-SNAPSHOT\", \"1.1-SNAPSHOT\");\n        assertVersionOlder(\"1.1-SNAPSHOT\", \"1.2-SNAPSHOT\");\n        assertVersionOlder(\"1.0.0-SNAPSHOT\", \"1.1-SNAPSHOT\");\n        assertVersionOlder(\"1.1-SNAPSHOT\", \"1.2.0-SNAPSHOT\");\n\n        assertVersionOlder(\"1.0-alpha-1-SNAPSHOT\", \"1.0-alpha-2-SNAPSHOT\");\n        assertVersionOlder(\"1.0-alpha-1-SNAPSHOT\", \"1.0-beta-1-SNAPSHOT\");\n\n        assertVersionOlder(\"1.0-beta-1-SNAPSHOT\", \"1.0-SNAPSHOT-SNAPSHOT\");\n        assertVersionOlder(\"1.0-SNAPSHOT-SNAPSHOT\", \"1.0-SNAPSHOT\");\n        assertVersionOlder(\"1.0-alpha-1-SNAPSHOT-SNAPSHOT\", \"1.0-alpha-1-SNAPSHOT\");\n\n        assertVersionOlder(\"1.0-SNAPSHOT\", \"1.0-1-SNAPSHOT\");\n        assertVersionOlder(\"1.0-1-SNAPSHOT\", \"1.0-2-SNAPSHOT\");\n        assertVersionOlder(\"2.0-SNAPSHOT\", \"2.0-1-SNAPSHOT\");\n        assertVersionOlder(\"2.0.0-SNAPSHOT\", \"2.0-1-SNAPSHOT\");\n        assertVersionOlder(\"2.0-1-SNAPSHOT\", \"2.0.1-SNAPSHOT\");\n\n        assertVersionOlder(\"2.0.1-klm-SNAPSHOT\", \"2.0.1-lmn-SNAPSHOT\");\n        assertVersionOlder(\"2.0.1-SNAPSHOT\", \"2.0.1-123-SNAPSHOT\");\n        assertVersionOlder(\"2.0.1-xyz-SNAPSHOT\", \"2.0.1-123-SNAPSHOT\");\n    }",
    "comment": "assertVersionOlder( \"1.0-alpha-1-SNAPSHOT\", \"1.0-SNAPSHOT\" );\nassertVersionEqual( \"2.0-0-SNAPSHOT\", \"2.0-SNAPSHOT\" );\nassertVersionOlder( \"2.0.1-xyz-SNAPSHOT\", \"2.0.1-SNAPSHOT\" );"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/root/RootLocator.java",
    "type": "method",
    "name": "findMandatoryRoot",
    "code": "default Path findMandatoryRoot(Path basedir) {\n        Path rootDirectory = findRoot(basedir);\n        if (rootDirectory == null) {\n            throw new IllegalStateException(getNoRootMessage());\n        }\n        return rootDirectory;\n    }",
    "comment": "Interface used to locate the root directory for a given project.\n\nThe root locator is usually looked up from the plexus container.\nOne notable exception is the computation of the early {@code session.rootDirectory}\nproperty which happens very early.  The implementation used in this case\nwill be discovered using the JDK service mechanism.\n\nThe default implementation will look for a {@code .mvn} child directory\nor a {@code pom.xml} containing the {@code root=\"true\"} attribute.\n\n@see DefaultRootLocator\n@deprecated use {@code org.apache.maven.api.services.model.RootLocator} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/MergedBlockMeta.java",
    "type": "method",
    "name": "MergedBlockMeta",
    "code": "public MergedBlockMeta(int numChunks, ManagedBuffer chunksBitmapBuffer) {\n    this.numChunks = numChunks;\n    this.chunksBitmapBuffer = Preconditions.checkNotNull(chunksBitmapBuffer);\n  }",
    "comment": "Contains meta information for a merged block. Currently this information constitutes:\n1. Number of chunks in a merged shuffle block.\n2. Bitmaps for each chunk in the merged block. A chunk bitmap contains all the mapIds that were\nmerged to that merged block chunk.\n\n@since 3.1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testMixedSimpleAdd",
    "code": "public void testMixedSimpleAdd() {\n        IMoney expected = MoneyBag.create(f12CHF, f7USD);\n        assertEquals(expected, f12CHF.add(f7USD));\n    }",
    "comment": "[12 CHF] + [7 USD] == {[12 CHF][7 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom_Common/java/com/example/android/persistence/migrations/SqliteDatabaseTestHelper.java",
    "type": "method",
    "name": "insertUser",
    "code": "public static void insertUser(int userid, String userName, SqliteTestDbOpenHelper helper) {\n        SQLiteDatabase db = helper.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(\"userid\", userid);\n        values.put(\"username\", userName);\n\n        db.insertWithOnConflict(\"users\", null, values,\n                SQLiteDatabase.CONFLICT_REPLACE);\n\n        db.close();\n    }",
    "comment": "Helper class for working with the SQLiteDatabase."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/commander/src/main/java/com/iluwatar/commander/paymentservice/PaymentService.java",
    "type": "method",
    "name": "PaymentService",
    "code": "public PaymentService(PaymentDatabase db, Exception... exc) {\n    super(db, exc);\n  }",
    "comment": "The PaymentService class receives request from the {@link com.iluwatar.commander.Commander} and\nadds to the {@link PaymentDatabase}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/aether/ReverseTreeRepositoryListener.java",
    "type": "method",
    "name": "artifactResolved",
    "code": "public void artifactResolved(RepositoryEvent event) {\n        requireNonNull(event, \"event cannot be null\");\n\n        if (!isLocalRepositoryArtifactOrMissing(event.getSession(), event.getArtifact())) {\n            return;\n        }\n\n        RequestTrace trace = event.getTrace();\n\n        CollectStepData collectStepTrace = null;\n        ArtifactRequest artifactRequest = null;\n        ArtifactDescriptorRequest artifactDescriptorRequest = null;\n        Plugin plugin = null;\n\n        while (trace != null) {\n            Object data = trace.getData();\n            if (data instanceof CollectStepData collectStepData) {\n                collectStepTrace = collectStepData;\n            } else if (data instanceof ArtifactDescriptorRequest artifactDescriptorRequestData) {\n                artifactDescriptorRequest = artifactDescriptorRequestData;\n            } else if (data instanceof ArtifactRequest artifactRequestData) {\n                artifactRequest = artifactRequestData;\n            } else if (data instanceof Plugin pluginData) {\n                plugin = pluginData;\n            } else if (data instanceof org.apache.maven.model.Plugin pluginData) {\n                plugin = pluginData.getDelegate();\n            }\n            trace = trace.getParent();\n        }\n\n        Path trackingDir;\n        boolean missing = event.getFile() == null;\n        if (missing) {\n            // missing artifact - let's track the path anyway\n            File dir = event.getSession().getLocalRepository().getBasedir();\n            dir = new File(\n                    dir, event.getSession().getLocalRepositoryManager().getPathForLocalArtifact(event.getArtifact()));\n            trackingDir = dir.getParentFile().toPath().resolve(\".tracking\");\n        } else {\n            trackingDir = event.getFile().getParentFile().toPath().resolve(\".tracking\");\n        }\n\n        String baseName;\n        String ext = missing ? \".miss\" : \".dep\";\n        Path trackingFile = null;\n\n        StringBuilder indent = new StringBuilder();\n        ArrayList<String> trackingData = new ArrayList<>();\n\n        if (collectStepTrace == null && plugin != null) {\n            ext = \".plugin\";\n            baseName = plugin.getGroupId() + \"_\" + plugin.getArtifactId() + \"_\" + plugin.getVersion();\n            trackingFile = trackingDir.resolve(baseName + ext);\n            if (Files.exists(trackingFile)) {\n                return;\n            }\n\n            if (event.getArtifact() != null) {\n                trackingData.add(indent.toString() + event.getArtifact());\n                indent.append(\"  \");\n            }\n            trackingData.add(indent + plugin.getGroupId() + \":\" + plugin.getArtifactId() + \":\" + plugin.getVersion());\n            indent.append(\"  \");\n\n            InputLocation location = plugin.getLocation(\"\");\n            if (location != null && location.getSource() != null) {\n                trackingData.add(indent + location.getSource().getModelId() + \" (implicit)\");\n                indent.append(\"  \");\n            }\n        } else if (collectStepTrace != null) {\n            if (collectStepTrace.getPath().get(0).getArtifact() == null) {\n                return;\n            }\n            baseName = ArtifactIdUtils.toId(collectStepTrace.getPath().get(0).getArtifact())\n                    .replace(\":\", \"_\");\n            trackingFile = trackingDir.resolve(baseName + ext);\n            if (Files.exists(trackingFile)) {\n                return;\n            }\n\n            Artifact resolvedArtifact = event.getArtifact();\n            Artifact nodeArtifact = collectStepTrace.getNode().getArtifact();\n\n            if (isInScope(resolvedArtifact, nodeArtifact) || \"pom\".equals(resolvedArtifact.getExtension())) {\n                Dependency node = collectStepTrace.getNode();\n                trackingData.add(resolvedArtifact.toString());\n                indent.append(\"  \");\n                trackingData.add(indent.toString() + node + \" (\" + collectStepTrace.getContext() + \")\");\n                ListIterator<DependencyNode> iter = collectStepTrace\n                        .getPath()\n                        .listIterator(collectStepTrace.getPath().size());\n                while (iter.hasPrevious()) {\n                    DependencyNode curr = iter.previous();\n                    indent.append(\"  \");\n                    trackingData.add(indent.toString() + curr + \" (\" + collectStepTrace.getContext() + \")\");\n                }\n            }\n        }\n\n        if (trackingFile == null) {\n            return; // parent or imported bom ?\n        }\n        try {\n            Files.createDirectories(trackingDir);\n\n            trackingData.add(\"\");\n            if (!missing) {\n                if (event.getRepository() != null) {\n                    trackingData.add(\"Repository: \" + event.getRepository());\n                }\n            } else {\n                List<RemoteRepository> repositories = new ArrayList<>();\n                if (artifactRequest != null && artifactRequest.getRepositories() != null) {\n                    repositories.addAll(artifactRequest.getRepositories());\n                } else if (artifactDescriptorRequest != null && artifactDescriptorRequest.getRepositories() != null) {\n                    repositories.addAll(artifactDescriptorRequest.getRepositories());\n                }\n                if (!repositories.isEmpty()) {\n                    trackingData.add(\"Configured repositories:\");\n                    for (RemoteRepository r : repositories) {\n                        trackingData.add(\" - \" + r.getId() + \" : \" + r.getUrl());\n                    }\n                } else {\n                    trackingData.add(\"No repositories configured\");\n                }\n            }\n\n            Files.write(trackingFile, trackingData, StandardCharsets.UTF_8);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }",
    "comment": "A class building reverse tree using {@link CollectStepData} trace data provided in {@link RepositoryEvent}\nevents fired during collection.\n\n@since 3.9.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "byteStringAsBytes",
    "code": "public static long byteStringAsBytes(String str) {\n    return byteStringAs(str, ByteUnit.BYTE);\n  }",
    "comment": "Convert a passed byte string (e.g. 50b, 100k, or 250m) to bytes for\ninternal use.\n\nIf no suffix is provided, the passed number is assumed to be in bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/JavaTC.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaTC\")\n      .getOrCreate();\n\n    JavaSparkContext jsc = new JavaSparkContext(spark.sparkContext());\n\n    int slices = (args.length > 0) ? Integer.parseInt(args[0]): 2;\n    JavaPairRDD<Integer, Integer> tc = jsc.parallelizePairs(generateGraph(), slices).cache();\n\n\n    JavaPairRDD<Integer, Integer> edges = tc.mapToPair(e -> new Tuple2<>(e._2(), e._1()));\n\n    long oldCount;\n    long nextCount = tc.count();\n    do {\n      oldCount = nextCount;\n      tc = tc.union(tc.join(edges).mapToPair(ProjectFn.INSTANCE)).distinct().cache();\n      nextCount = tc.count();\n    } while (nextCount != oldCount);\n\n    System.out.println(\"TC has \" + tc.count() + \" edges.\");\n    spark.stop();\n  }",
    "comment": "Linear transitive closure: each round grows paths by one edge,\nby joining the graph's edges with the already-discovered paths.\ne.g. join the path (y, z) from the TC with the edge (x, y) from\nthe graph to obtain the path (x, z).\nBecause join() joins on keys, the edges are stored in reversed order.\nPerform the join, obtaining an RDD of (y, (z, x)) pairs,\nthen project the result to obtain the new (x, z) paths."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/ExternalShuffleIntegrationSuite.java",
    "type": "method",
    "name": "BlockFetchingListener",
    "code": "clientConf, null, false, 5000)) {\n      client.init(APP_ID);\n      client.fetchBlocks(TestUtils.getLocalHost(), port, execId, blockIds,\n        new BlockFetchingListener() {\n            }\n          }",
    "comment": "Fetch a set of blocks from a pre-registered executor.\nFetch a set of blocks from a pre-registered executor. Connects to the server on the given port,\nto allow connecting to invalid servers."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createYearMonthIntervalType",
    "code": "public static YearMonthIntervalType createYearMonthIntervalType() {\n    return YearMonthIntervalType$.MODULE$.DEFAULT();\n  }",
    "comment": "Creates a YearMonthIntervalType with default start and end fields: interval year to month."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertFalseAssertionsTests.java",
    "type": "method",
    "name": "assertFalseWithBooleanFalse",
    "code": "void assertFalseWithBooleanFalse() {\n\t\tassertFalse(false);\n\t\tassertFalse(false, \"test\");\n\t\tassertFalse(false, () -> \"test\");\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ParameterResolverTests.java",
    "type": "method",
    "name": "constructorInjection",
    "code": "void constructorInjection() {\n\t\tEngineExecutionResults executionResults = executeTestsForClass(ConstructorInjectionTestCase.class);\n\n\t\tassertEquals(2, executionResults.testEvents().started().count(), \"# tests started\");\n\t\tassertEquals(2, executionResults.testEvents().succeeded().count(), \"# tests succeeded\");\n\t\tassertEquals(0, executionResults.testEvents().skipped().count(), \"# tests skipped\");\n\t\tassertEquals(0, executionResults.testEvents().aborted().count(), \"# tests aborted\");\n\t\tassertEquals(0, executionResults.testEvents().failed().count(), \"# tests failed\");\n\t}",
    "comment": "Integration tests that verify support for {@link ParameterResolver}\nextensions in the {@link JupiterTestEngine}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/client/TransportClient.java",
    "type": "method",
    "name": "TransportClient",
    "code": "public TransportClient(Channel channel, TransportResponseHandler handler) {\n    this.channel = Preconditions.checkNotNull(channel);\n    this.handler = Preconditions.checkNotNull(handler);\n    this.timedOut = false;\n  }",
    "comment": "Client for fetching consecutive chunks of a pre-negotiated stream. This API is intended to allow\nefficient transfer of a large amount of data, broken up into chunks with size ranging from\nhundreds of KB to a few MB.\n\nNote that while this client deals with the fetching of chunks from a stream (i.e., data plane),\nthe actual setup of the streams is done outside the scope of the transport layer. The convenience\nmethod \"sendRPC\" is provided to enable control plane communication between the client and server\nto perform this setup.\n\nFor example, a typical workflow might be:\nclient.sendRPC(new OpenFile(\"/foo\")) --&gt; returns StreamId = 100\nclient.fetchChunk(streamId = 100, chunkIndex = 0, callback)\nclient.fetchChunk(streamId = 100, chunkIndex = 1, callback)\n...\nclient.sendRPC(new CloseStream(100))\n\nConstruct an instance of TransportClient using {@link TransportClientFactory}. A single\nTransportClient may be used for multiple streams, but any given stream must be restricted to a\nsingle client, in order to avoid out-of-order responses.\n\nNB: This class is used to make requests to the server, while {@link TransportResponseHandler} is\nresponsible for handling responses from the server.\n\nConcurrency: thread safe and can be called from multiple threads."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/ParquetEnum.java",
    "type": "method",
    "name": "setSuit",
    "code": "public void setSuit(org.apache.spark.sql.execution.datasources.parquet.test.avro.Suit value) {\n    this.suit = value;\n  }",
    "comment": "Sets the value of the 'suit' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/ComparisonFailure.java",
    "type": "method",
    "name": "ComparisonCompactor",
    "code": "public ComparisonCompactor(int contextLength, String expected, String actual) {\n            this.contextLength = contextLength;\n            this.expected = expected;\n            this.actual = actual;\n        }",
    "comment": "@param contextLength the maximum length of context surrounding the difference between the compared strings.\nWhen context length is exceeded, the prefixes and suffixes are compacted.\n@param expected the expected string value\n@param actual the actual string value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectClasspathResource",
    "code": "public static ClasspathResourceSelector selectClasspathResource(Set<Resource> classpathResources) {\n\t\tPreconditions.notEmpty(classpathResources, \"classpath resources must not be null or empty\");\n\t\tPreconditions.containsNoNullElements(classpathResources, \"individual classpath resources must not be null\");\n\t\tList<String> resourceNames = classpathResources.stream().map(Resource::getName).distinct().collect(toList());\n\t\tPreconditions.condition(resourceNames.size() == 1, \"all classpath resources must have the same name\");\n\t\tPreconditions.notBlank(resourceNames.get(0), \"classpath resource names must not be null or blank\");\n\t\treturn new ClasspathResourceSelector(classpathResources);\n\t}",
    "comment": "Create a {@code ClasspathResourceSelector} for the supplied classpath\nresources.\n\n<p>Since {@linkplain org.junit.platform.engine.TestEngine engines} are not\nexpected to modify the classpath, the supplied resource must be on the\nclasspath of the\n{@linkplain Thread#getContextClassLoader() context class loader} of the\n{@linkplain Thread thread} that uses the resulting selector.\n\n<p>Note: Since Java 9, all resources are on the module path. Either in\nnamed or unnamed modules. These resources are also considered to be\nclasspath resources.\n\n@param classpathResources a set of classpath resources; never\n{@code null} or empty. All resources must have the same name, may not\nbe {@code null} or blank.\n@since 1.12\n@see #selectClasspathResource(String, FilePosition)\n@see #selectClasspathResource(String)\n@see ClasspathResourceSelector\n@see ReflectionSupport#tryToGetResources(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, float expected, float actual, float delta) {\n        Assert.assertEquals(message, expected, actual, delta);\n    }",
    "comment": "Asserts that two floats are equal concerning a positive delta. If they\nare not an AssertionFailedError is thrown with the given message. If the\nexpected value is infinity then the delta value is ignored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/experimental/theories/runner/SuccessfulWithDataPointFields.java",
    "type": "method",
    "name": "onlyAnnotatedFields",
    "code": "public void onlyAnnotatedFields(int i) {\n            assertTrue(i == 0);\n        }",
    "comment": "DataPoint which passes the test\nNot annotated as a DataPoint and therefore should be ignored:"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/TagExpression.java",
    "type": "method",
    "name": "parseFrom",
    "code": "static ParseResult parseFrom(String infixTagExpression) {\n\t\treturn new Parser().parse(infixTagExpression);\n\t}",
    "comment": "Attempt to parse a {@link TagExpression} from the supplied <em>tag\nexpression string</em>.\n\n@param infixTagExpression the tag expression string to parse; never {@code null}.\n@see ParseResult"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterApi.java",
    "type": "method",
    "name": "getUseXNNPACK",
    "code": "public boolean getUseXNNPACK() {\n      return useXNNPACK == null || useXNNPACK.booleanValue();\n    }",
    "comment": "A null value indicates the default behavior, which is currently to apply the delegate."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroMapOfArray.java",
    "type": "method",
    "name": "getSchema",
    "code": "public org.apache.avro.Schema getSchema() { return SCHEMA$; }\n  public java.lang.Object get(int field$) {\n    switch (field$) {\n    case 0: return string_to_ints_column;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumWriter.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setShort",
    "code": "public void setShort(short value) {\n    shortData = value;\n  }",
    "comment": "Sets the short `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/BloomFilter.java",
    "type": "method",
    "name": "create",
    "code": "public static BloomFilter create(long expectedNumItems, double fpp) {\n    if (fpp <= 0D || fpp >= 1D) {\n      throw new IllegalArgumentException(\n        \"False positive probability must be within range (0.0, 1.0)\"\n      );\n    }\n\n    return create(expectedNumItems, optimalNumOfBits(expectedNumItems, fpp));\n  }",
    "comment": "Creates a {@link BloomFilter} with the expected number of insertions and expected false\npositive probability.\n\nNote that overflowing a {@code BloomFilter} with significantly more elements than specified,\nwill result in its saturation, and a sharp deterioration of its false positive probability."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "mergedShuffleFileManagerImpl",
    "code": "public String mergedShuffleFileManagerImpl() {\n    return conf.get(\"spark.shuffle.push.server.mergedShuffleFileManagerImpl\",\n      \"org.apache.spark.network.shuffle.NoOpMergedShuffleFileManager\");\n  }",
    "comment": "Class name of the implementation of MergedShuffleFileManager that merges the blocks\npushed to it when push-based shuffle is enabled. By default, push-based shuffle is disabled at\na cluster level because this configuration is set to\n'org.apache.spark.network.shuffle.NoOpMergedShuffleFileManager'.\nTo turn on push-based shuffle at a cluster level, set the configuration to\n'org.apache.spark.network.shuffle.RemoteBlockPushResolver'."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(int expected, Integer actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals((Integer) expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/notification/RunNotifier.java",
    "type": "method",
    "name": "fireTestFailure",
    "code": "public void fireTestFailure(Failure failure) {\n        fireTestFailures(listeners, asList(failure));\n    }",
    "comment": "Invoke to tell listeners that an atomic test failed.\n\n@param failure the description of the test that failed and the exception thrown"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelBuildingException.java",
    "type": "method",
    "name": "getModel",
    "code": "public Model getModel() {\n        if (result == null) {\n            return null;\n        }\n        if (result.getEffectiveModel() != null) {\n            return result.getEffectiveModel();\n        }\n        return result.getRawModel();\n    }",
    "comment": "Gets the model that could not be built properly.\n\n@return The erroneous model or {@code null} if not available."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "reportingEntryPublished",
    "code": "public Events reportingEntryPublished() {\n\t\treturn new Events(eventsByType(EventType.REPORTING_ENTRY_PUBLISHED),\n\t\t\tthis.category + \" Reporting Entry Published\");\n\t}",
    "comment": "Get the reporting entry publication {@link Events} contained in this\n{@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/AppIsolationSuite.java",
    "type": "method",
    "name": "beforeAll",
    "code": "public static void beforeAll() {\n    Map<String, String> confMap = new HashMap<>();\n    confMap.put(\"spark.network.crypto.enabled\", \"true\");\n    confMap.put(\"spark.network.crypto.saslFallback\", \"false\");\n    conf = new TransportConf(\"shuffle\", new MapConfigProvider(confMap));\n\n    secretKeyHolder = mock(SecretKeyHolder.class);\n    when(secretKeyHolder.getSaslUser(eq(\"app-1\"))).thenReturn(\"app-1\");\n    when(secretKeyHolder.getSecretKey(eq(\"app-1\"))).thenReturn(\"app-1\");\n    when(secretKeyHolder.getSaslUser(eq(\"app-2\"))).thenReturn(\"app-2\");\n    when(secretKeyHolder.getSecretKey(eq(\"app-2\"))).thenReturn(\"app-2\");\n  }",
    "comment": "Use a long timeout to account for slow / overloaded build machines. In the normal case,\ntests should finish way before the timeout expires."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/MessageWithHeader.java",
    "type": "method",
    "name": "if",
    "code": "if (body instanceof FileRegion fileRegion) {\n      writtenBody = fileRegion.transferTo(target, totalBytesTransferred - headerLength);\n    } else if (body instanceof ByteBuf byteBuf) {\n      writtenBody = copyByteBuf(byteBuf, target);\n    }",
    "comment": "Bytes written for body in this call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/RetryConfigTest.java",
    "type": "method",
    "name": "shouldRetryThreeTimesWithTwoSecondDelay",
    "code": "void shouldRetryThreeTimesWithTwoSecondDelay() {\n    AtomicInteger attempts = new AtomicInteger();\n    Runnable retryableOperation =\n        () -> {\n          attempts.incrementAndGet();\n          throw new RuntimeException(\"Test exception for retry\");\n        };\n\n    long startTime = System.currentTimeMillis();\n    try {\n      retryTemplate.execute(\n          context -> {\n            retryableOperation.run();\n            return null;\n          });\n    } catch (Exception e) {\n      // Expected exception\n    }\n    long endTime = System.currentTimeMillis();\n\n    assertEquals(3, attempts.get(), \"Should have retried three times\");\n    assertTrue(\n        (endTime - startTime) >= 4000,\n        \"Should have waited at least 4 seconds in total for backoff\");\n  }",
    "comment": "Tests that the retry template retries three times with a two-second delay.\n\n<p>Verifies that the retryable operation is executed three times before throwing an exception,\nand that the total elapsed time for the retries is at least four seconds."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Stopwatch.java",
    "type": "method",
    "name": "failed",
    "code": "protected void failed(long nanos, Throwable e, Description description) {\n    }",
    "comment": "Invoked when a test fails"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelData.java",
    "type": "method",
    "name": "setRawModel",
    "code": "public void setRawModel(Model rawModel) {\n        this.rawModel = rawModel;\n    }",
    "comment": "Sets the raw model being wrapped.\n\n@param rawModel The raw model, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TestInfoParameterResolver.java",
    "type": "method",
    "name": "getTestInstantiationExtensionContextScope",
    "code": "public ExtensionContextScope getTestInstantiationExtensionContextScope(ExtensionContext rootContext) {\n\t\treturn ExtensionContextScope.TEST_METHOD;\n\t}",
    "comment": "{@link ParameterResolver} that resolves the {@link TestInfo} for\nthe currently executing test.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/ExpressionImplUtils.java",
    "type": "method",
    "name": "randStr",
    "code": "public static UTF8String randStr(XORShiftRandom rng, int length) {\n    byte[] bytes = new byte[length];\n    for (int i = 0; i < bytes.length; i++) {\n      int v = Math.abs(rng.nextInt() % 62);\n      if (v < 10) {\n        bytes[i] = (byte)('0' + v);\n      } else if (v < 36) {\n        bytes[i] = (byte)('a' + (v - 10));\n      } else {\n        bytes[i] = (byte)('A' + (v - 36));\n      }\n    }\n    return UTF8String.fromBytes(bytes);\n  }",
    "comment": "We generate a random number between 0 and 61, inclusive. Between the 62 different choices\nwe choose 0-9, a-z, or A-Z, where each category comprises 10 choices, 26 choices, or 26\nchoices, respectively (10 + 26 + 26 = 62)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/tools/java/org/junit/api/tools/ApiReportGenerator.java",
    "type": "method",
    "name": "scanClasspath",
    "code": "private static ScanResult scanClasspath() {\n\t\tvar classGraph = new ClassGraph() //\n\t\t\t\t.acceptPackages(\"org.junit\") //\n\t\t\t\t.rejectPackages(\"*.shadow.*\", \"org.opentest4j.*\", \"org.junit.platform.commons.logging\",\n\t\t\t\t\t\"org.junit.platform.commons.util\") //\n\t\t\t\t.disableNestedJarScanning() //\n\t\t\t\t.enableClassInfo() //\n\t\t\t\t.enableMethodInfo() //\n\t\t\t\t.enableAnnotationInfo(); //\n\t\tvar apiClasspath = System.getProperty(\"api.classpath\");\n\t\tif (apiClasspath != null) {\n\t\t\tvar paths = Arrays.stream(apiClasspath.split(File.pathSeparator)).map(Path::of).toArray(Path[]::new);\n\t\t\tvar bootLayer = ModuleLayer.boot();\n\t\t\tvar configuration = bootLayer.configuration().resolveAndBind(ModuleFinder.of(), ModuleFinder.of(paths),\n\t\t\t\tSet.of());\n\t\t\tvar layer = bootLayer.defineModulesWithOneLoader(configuration, ClassLoader.getPlatformClassLoader());\n\t\t\tclassGraph = classGraph.overrideModuleLayers(layer);\n\t\t}\n\t\treturn classGraph.scan();\n\t}",
    "comment": "scan all types below \"org.junit\" package"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3415JunkRepositoryMetadataTest.java",
    "type": "method",
    "name": "getMethodName",
    "code": "private String getMethodName() {\n        return new Throwable().getStackTrace()[1].getMethodName();\n    }",
    "comment": "This test simply verifies that when a metadata transfer fails (network error, etc.)\nno metadata file is written to the local repository.\n<p>\nSteps executed to verify this test:\n</p>\n0. Find the local repository directory:\na. build the maven-find-local-repo-plugin, then run it, to spit out the path of the\nlocal repository in use by default. Read the output file to get this path.\n(Yes, it's heavy, but it's reliable.)\n1. Setup the test:\na. Make sure the metadata for the test-repo is NOT in the local repository.\nb. Make sure the dependency POM IS in the local repository, so we're not\ndistracted by failed builds that are unrelated.\nc. Create the settings file for use in this test, which contains the invalid\nremote repository entry.\n2. Build the test project the first time\na. Verify that a TransferFailedException is in the build output for the test-repo\nb. Verify that the metadata for the dependency POM is NOT in the local\nrepository afterwards.\n3. Build the test project the second time\na. See (2.a) and (2.b) above; the same criteria applies here.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/DiscoveryIssueReporter.java",
    "type": "method",
    "name": "consuming",
    "code": "static DiscoveryIssueReporter consuming(Consumer<? super DiscoveryIssue> consumer) {\n\t\tPreconditions.notNull(consumer, \"consumer must not be null\");\n\t\treturn consumer::accept;\n\t}",
    "comment": "Create a new {@code DiscoveryIssueReporter} that adds reported issues to"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/path/DefaultModelPathTranslator.java",
    "type": "method",
    "name": "setPathTranslator",
    "code": "public DefaultModelPathTranslator setPathTranslator(PathTranslator pathTranslator) {\n        this.pathTranslator = pathTranslator;\n        return this;\n    }",
    "comment": "Resolves relative paths within a model against a specific base directory.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/BenchmarkLatencyImpl.java",
    "type": "method",
    "name": "initialize",
    "code": "public boolean initialize() {\n    if (tfliteSettingsJsonFiles == null || tfliteSettingsJsonFiles.length == 0) {\n      Log.e(TAG, \"No TFLiteSettings file provided.\");\n      return false;\n    }\n    try {\n      // Creates root result folder.\n      String resultFolderPath =\n          DelegatePerformanceBenchmark.createResultFolder(\n              context.getFilesDir(), LATENCY_FOLDER_NAME);\n      report.addWriter(JsonWriter.create(resultFolderPath));\n      report.addWriter(CsvWriter.create(resultFolderPath));\n      report.addWriter(HtmlWriter.create(resultFolderPath));\n    } catch (IOException e) {\n      Log.e(\n          TAG, \"Failed to create result folder \" + LATENCY_FOLDER_NAME + \" in files directory.\", e);\n      return false;\n    }\n\n    try {\n      // Loads default latency criteria.\n      defaultLatencyCriteria = loadLatencyCriteria(DEFAULT_LATENCY_CRITERIA_FILENAME);\n    } catch (IOException e) {\n      Log.e(TAG, \"Failed to load default latency criteria \" + DEFAULT_LATENCY_CRITERIA_FILENAME, e);\n      return false;\n    }\n    return true;\n  }",
    "comment": "Initializes the test environment. Creates the result folder and loads the default latency\ncriteria file.\n\n<p>Returns {@code true} if the initialization was successful. Otherwise, returns {@code false}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "execute",
    "code": "public EngineExecutionResults execute() {\n\t\t\tLauncherDiscoveryRequest request = this.requestBuilder.build();\n\t\t\tExecutionRecorder executionRecorder = new ExecutionRecorder();\n\t\t\tEngineTestKit.executeUsingLauncherOrchestration(this.testEngine, request, executionRecorder);\n\t\t\treturn executionRecorder.getExecutionResults();\n\t\t}",
    "comment": "Execute tests for the configured {@link TestEngine},\n{@linkplain DiscoverySelector discovery selectors},\n{@linkplain DiscoveryFilter discovery filters}, and\n<em>configuration parameters</em>.\n\n@return the recorded {@code EngineExecutionResults}\n@see #selectors(DiscoverySelector...)\n@see #filters(Filter...)\n@see #configurationParameter(String, String)\n@see #configurationParameters(Map)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "hashCode",
    "code": "public int hashCode() {\n\t\tint value = this.hashCode;\n\t\tif (value == 0) {\n\t\t\tvalue = this.segments.hashCode();\n\t\t\tif (value == 0) {\n\t\t\t\tvalue = 1;\n\t\t\t}\n\t\t\tthis.hashCode = value;\n\t\t}\n\t\treturn value;\n\t}",
    "comment": "handle the edge case of the computed hashCode being 0\nthis is a benign race like String#hash\nwe potentially read and write values from multiple threads\nwithout a happens-before relationship\nhowever the JMM guarantees us that we only ever see values\nthat were valid at one point, either 0 or the hash code\nso we might end up not seeing a value that a different thread\nhas computed or multiple threads writing the same value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "mergeForceCollapse",
    "code": "private void mergeForceCollapse() {\n      while (stackSize > 1) {\n        int n = stackSize - 2;\n        if (n > 0 && runLen[n - 1] < runLen[n + 1])\n          n--;\n        mergeAt(n);\n      }\n    }",
    "comment": "Merges all runs on the stack until only one remains.  This method is\ncalled once, to complete the sort."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/UniqueIdParsingForArrayParameterIntegrationTests.java",
    "type": "method",
    "name": "executeTestsForPrimitiveArrayMethodInjectionCases",
    "code": "void executeTestsForPrimitiveArrayMethodInjectionCases() {\n\t\tEngineExecutionResults executionResults = executeTestsForClass(PrimitiveArrayMethodInjectionTestCase.class);\n\n\t\tassertEquals(1, executionResults.testEvents().started().count(), \"# tests started\");\n\t\tassertEquals(1, executionResults.testEvents().succeeded().count(), \"# tests succeeded\");\n\t\tassertEquals(0, executionResults.testEvents().failed().count(), \"# tests failed\");\n\n\t\t// @formatter:off\n\t\tUniqueId uniqueId = executionResults.allEvents()\n\t\t\t\t.map(Event::getTestDescriptor)\n\t\t\t\t.distinct()\n\t\t\t\t.skip(2)\n\t\t\t\t.map(TestDescriptor::getUniqueId)\n\t\t\t\t.findFirst()\n\t\t\t\t.orElseThrow(AssertionError::new);\n\t\t// @formatter:on\n\n\t\tassertThat(UniqueId.parse(uniqueId.toString())).isEqualTo(uniqueId);\n\t}",
    "comment": "Integration tests for {@link UniqueId#parse(String)} for methods\nwith array type parameters.\n\n@see <a href=\"https://github.com/junit-team/junit5/issues/810\">#810</a>\n@see org.junit.platform.engine.UniqueIdTests\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/ShreddingUtils.java",
    "type": "method",
    "name": "if",
    "code": "VariantBuilder builder) {\n    int typedIdx = schema.typedIdx;\n    int variantIdx = schema.variantIdx;\n    if (typedIdx >= 0 && !row.isNullAt(typedIdx)) {\n      if (schema.scalarSchema != null) {\n        VariantSchema.ScalarType scalar = schema.scalarSchema;\n        if (scalar instanceof VariantSchema.StringType) {\n          builder.appendString(row.getString(typedIdx));\n        } else if (scalar instanceof VariantSchema.IntegralType) {\n          VariantSchema.IntegralType it = (VariantSchema.IntegralType) scalar;\n          long value = 0;\n          switch (it.size) {\n            case BYTE:\n              value = row.getByte(typedIdx);\n              break;\n            case SHORT:\n              value = row.getShort(typedIdx);\n              break;\n            case INT:\n              value = row.getInt(typedIdx);\n              break;\n            case LONG:\n              value = row.getLong(typedIdx);\n              break;\n          }\n          builder.appendLong(value);\n        } else if (scalar instanceof VariantSchema.FloatType) {\n          builder.appendFloat(row.getFloat(typedIdx));\n        } else if (scalar instanceof VariantSchema.DoubleType) {\n          builder.appendDouble(row.getDouble(typedIdx));\n        } else if (scalar instanceof VariantSchema.BooleanType) {\n          builder.appendBoolean(row.getBoolean(typedIdx));\n        } else if (scalar instanceof VariantSchema.BinaryType) {\n          builder.appendBinary(row.getBinary(typedIdx));\n        } else if (scalar instanceof VariantSchema.UuidType) {\n          builder.appendUuid(row.getUuid(typedIdx));\n        } else if (scalar instanceof VariantSchema.DecimalType) {\n          VariantSchema.DecimalType dt = (VariantSchema.DecimalType) scalar;\n          builder.appendDecimal(row.getDecimal(typedIdx, dt.precision, dt.scale));\n        } else if (scalar instanceof VariantSchema.DateType) {\n          builder.appendDate(row.getInt(typedIdx));\n        } else if (scalar instanceof VariantSchema.TimestampType) {\n          builder.appendTimestamp(row.getLong(typedIdx));\n        } else {\n          assert scalar instanceof VariantSchema.TimestampNTZType;\n          builder.appendTimestampNtz(row.getLong(typedIdx));\n        }\n      } else if (schema.arraySchema != null) {\n        VariantSchema elementSchema = schema.arraySchema;\n        ShreddedRow array = row.getArray(typedIdx);\n        int start = builder.getWritePos();\n        ArrayList<Integer> offsets = new ArrayList<>(array.numElements());\n        for (int i = 0; i < array.numElements(); i++) {\n          offsets.add(builder.getWritePos() - start);\n          rebuild(array.getStruct(i, elementSchema.numFields), metadata, elementSchema, builder);\n        }\n        builder.finishWritingArray(start, offsets);\n      } else {\n        ShreddedRow object = row.getStruct(typedIdx, schema.objectSchema.length);\n        ArrayList<VariantBuilder.FieldEntry> fields = new ArrayList<>();\n        int start = builder.getWritePos();\n        for (int fieldIdx = 0; fieldIdx < schema.objectSchema.length; ++fieldIdx) {\n          if (object.isNullAt(fieldIdx)) {\n            throw malformedVariant();\n          }\n          String fieldName = schema.objectSchema[fieldIdx].fieldName;\n          VariantSchema fieldSchema = schema.objectSchema[fieldIdx].schema;\n          ShreddedRow fieldValue = object.getStruct(fieldIdx, fieldSchema.numFields);\n          if ((fieldSchema.typedIdx >= 0 && !fieldValue.isNullAt(fieldSchema.typedIdx)) ||\n              (fieldSchema.variantIdx >= 0 && !fieldValue.isNullAt(fieldSchema.variantIdx))) {\n            int id = builder.addKey(fieldName);\n            fields.add(new VariantBuilder.FieldEntry(fieldName, id, builder.getWritePos() - start));\n            rebuild(fieldValue, metadata, fieldSchema, builder);\n          }\n        }\n        if (variantIdx >= 0 && !row.isNullAt(variantIdx)) {\n          Variant v = new Variant(row.getBinary(variantIdx), metadata);\n          if (v.getType() != VariantUtil.Type.OBJECT) throw malformedVariant();\n          for (int i = 0; i < v.objectSize(); ++i) {\n            Variant.ObjectField field = v.getFieldAtIndex(i);\n            if (schema.objectSchemaMap.containsKey(field.key)) {\n              throw malformedVariant();\n            }\n            int id = builder.addKey(field.key);\n            fields.add(new VariantBuilder.FieldEntry(field.key, id, builder.getWritePos() - start));\n            builder.appendVariant(field.value);\n          }\n        }\n        builder.finishWritingObject(start, fields);\n      }\n    } else if (variantIdx >= 0 && !row.isNullAt(variantIdx)) {\n      builder.appendVariant(new Variant(row.getBinary(variantIdx), metadata));\n    } else {\n      throw malformedVariant();\n    }\n  }",
    "comment": "Rebuild a variant value from the shredded data according to the reconstruction algorithm in\nhttps://github.com/apache/parquet-format/blob/master/VariantShredding.md.\nAppend the result to `builder`.\nShredded field must not be null.\nIf the field doesn't have non-null `typed_value` or `value`, it is missing.\nAdd the leftover fields in the variant binary.\n`value` must not contain any shredded field.\n`typed_value` doesn't exist or is null. Read from `value`.\nThis means the variant is missing in a context where it must present, so the input data is\ninvalid."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/di/testing/MavenDIExtension.java",
    "type": "method",
    "name": "getTestFile",
    "code": "public static File getTestFile(String basedir, String path) {\n        File basedirFile = new File(basedir);\n\n        if (!basedirFile.isAbsolute()) {\n            basedirFile = getTestFile(basedir);\n        }\n\n        return new File(basedirFile, path);\n    }",
    "comment": "Creates a File object for a path relative to a specified base directory.\n\n@param basedir The base directory path\n@param path The relative path\n@return A File object representing the path"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/AssertionsDemo.java",
    "type": "method",
    "name": "dependentAssertions",
    "code": "void dependentAssertions() {\n\t\tassertAll(\"properties\",\n\t\t\t() -> {\n\t\t\t\tString firstName = person.getFirstName();\n\t\t\t\tassertNotNull(firstName);\n\n\t\t\t\tassertAll(\"first name\",\n\t\t\t\t\t() -> assertTrue(firstName.startsWith(\"J\")),\n\t\t\t\t\t() -> assertTrue(firstName.endsWith(\"e\"))\n\t\t\t\t);\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\tString lastName = person.getLastName();\n\t\t\t\tassertNotNull(lastName);\n\n\t\t\t\tassertAll(\"last name\",\n\t\t\t\t\t() -> assertTrue(lastName.startsWith(\"D\")),\n\t\t\t\t\t() -> assertTrue(lastName.endsWith(\"e\"))\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}",
    "comment": "Within a code block, if an assertion fails the\nsubsequent code in the same block will be skipped.\nExecuted only if the previous assertion is valid.\nGrouped assertion, so processed independently\nof results of first name assertions.\nExecuted only if the previous assertion is valid."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-di/src/main/java/org/apache/maven/di/Key.java",
    "type": "method",
    "name": "getTypeParameter",
    "code": "public <U> Key<U> getTypeParameter(int index) {\n        if (type instanceof ParameterizedType parameterizedType) {\n            return new KeyImpl<>(parameterizedType.getActualTypeArguments()[index], null);\n        }\n        throw new IllegalStateException(\"Expected type from key \" + getDisplayString() + \" to be parameterized\");\n    }",
    "comment": "Returns a type parameter of the underlying type wrapped as a key with no qualifier.\n\n@throws IllegalStateException when underlying type is not a parameterized one."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroPrimitives.java",
    "type": "method",
    "name": "getSchema",
    "code": "public org.apache.avro.Schema getSchema() { return SCHEMA$; }\n  public java.lang.Object get(int field$) {\n    switch (field$) {\n    case 0: return bool_column;\n    case 1: return int_column;\n    case 2: return long_column;\n    case 3: return float_column;\n    case 4: return double_column;\n    case 5: return binary_column;\n    case 6: return string_column;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumWriter.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/TestWatcherTest.java",
    "type": "method",
    "name": "testWithExpectedException",
    "code": "public void testWithExpectedException() {\n                thrown.expect(RuntimeException.class);\n                throw new RuntimeException(\"expected exception\");\n            }",
    "comment": "The following tests check the information in TestWatcher's Javadoc\nregarding interplay with other rules.\nthe field name must be alphabetically lower than \"thrown\" in order\nto make the test failing if order is not set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/SupportsAtomicPartitionManagement.java",
    "type": "method",
    "name": "dropPartition",
    "code": "default boolean dropPartition(InternalRow ident) {\n    return dropPartitions(new InternalRow[]{ident});\n\n  void createPartitions(\n      InternalRow[] idents,\n      Map<String, String>[] properties)\n      throws PartitionsAlreadyExistException, UnsupportedOperationException;\n\n  boolean dropPartitions(InternalRow[] idents);\n\n  default boolean purgePartitions(InternalRow[] idents)\n    throws NoSuchPartitionException, UnsupportedOperationException {\n    throw QueryExecutionErrors.unsupportedPurgePartitionError();\n  }\n\n  default boolean truncatePartitions(InternalRow[] idents)\n      throws NoSuchPartitionException, SparkUnsupportedOperationException {\n    throw new SparkUnsupportedOperationException(\"_LEGACY_ERROR_TEMP_3145\");\n  }\n}",
    "comment": "Truncate an array of partitions atomically from table, and completely remove partitions data.\n<p>\nIf any partition doesn't exists,\nthe operation of truncatePartitions need to be safely rolled back.\n\n@param idents an array of partition identifiers\n@return true if partitions were truncated successfully otherwise false\n@throws NoSuchPartitionException If any partition identifier to truncate doesn't exist\n@throws UnsupportedOperationException If partition truncate is not supported\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "selectors",
    "code": "public SuiteLauncherDiscoveryRequestBuilder selectors(DiscoverySelector... selectors) {\n\t\tthis.delegate.selectors(selectors);\n\t\treturn this;\n\t}",
    "comment": "Add all supplied {@code selectors} to the request.\n\n@param selectors the {@code DiscoverySelectors} to add; never {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/SimpleDownloadFile.java",
    "type": "method",
    "name": "SimpleDownloadFile",
    "code": "public SimpleDownloadFile(File file, TransportConf transportConf) {\n    this.file = file;\n    this.transportConf = transportConf;\n  }",
    "comment": "A DownloadFile that does not take any encryption settings into account for reading and\nwriting data.\n\nThis does *not* mean the data in the file is unencrypted -- it could be that the data is\nalready encrypted when its written, and subsequent layer is responsible for decrypting."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineIdValidator.java",
    "type": "method",
    "name": "validate",
    "code": "static Iterable<TestEngine> validate(Iterable<TestEngine> testEngines) {\n\t\tSet<String> ids = new HashSet<>();\n\t\tfor (TestEngine testEngine : testEngines) {\n\t\t\tif (!validateReservedIds(testEngine)) {\n\t\t\t\tgetLogger().warn(() -> String.format(\n\t\t\t\t\t\"Third-party TestEngine implementations are forbidden to use the reserved 'junit-' prefix for their ID: '%s'\",\n\t\t\t\t\ttestEngine.getId()));\n\t\t\t}\n\n\t\t\tif (!ids.add(testEngine.getId())) {\n\t\t\t\tthrow new JUnitException(String.format(\n\t\t\t\t\t\"Cannot create Launcher for multiple engines with the same ID '%s'.\", testEngine.getId()));\n\t\t\t}\n\t\t}\n\t\treturn testEngines;\n\t}",
    "comment": "check usage of reserved ID prefix\ncheck uniqueness"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/constraints/Constraint.java",
    "type": "method",
    "name": "primaryKey",
    "code": "static PrimaryKey.Builder primaryKey(String name, NamedReference[] columns) {\n    return new PrimaryKey.Builder(name, columns);\n  }",
    "comment": "Instantiates a builder for a PRIMARY KEY constraint.\n\n@param name the constraint name\n@param columns columns that comprise the primary key\n@return a PRIMARY KEY constraint builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/TestClass.java",
    "type": "method",
    "name": "getAnnotations",
    "code": "public Annotation[] getAnnotations() {\n        if (clazz == null) {\n            return new Annotation[0];\n        }\n        return clazz.getAnnotations();\n    }",
    "comment": "Returns the annotations on this class"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertionFailureBuilder.java",
    "type": "method",
    "name": "actual",
    "code": "public AssertionFailureBuilder actual(Object actual) {\n\t\tthis.mismatch = true;\n\t\tthis.actual = actual;\n\t\treturn this;\n\t}",
    "comment": "Set the actual value of the assertion.\n\n@param actual the actual value; may be {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(long expected, long actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/classification/JavaNaiveBayesSuite.java",
    "type": "method",
    "name": "testPredictJavaRDD",
    "code": "public void testPredictJavaRDD() {\n    JavaRDD<LabeledPoint> examples = jsc.parallelize(POINTS, 2).cache();\n    NaiveBayesModel model = NaiveBayes.train(examples.rdd());\n    JavaRDD<Vector> vectors = examples.map(LabeledPoint::features);\n    JavaRDD<Double> predictions = model.predict(vectors);\n    predictions.first();\n  }",
    "comment": "Should be able to get the first prediction."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnsh/ShellInvoker.java",
    "type": "method",
    "name": "SimpleSystemRegistryImpl",
    "code": "try (holder) {\n            SimpleSystemRegistryImpl systemRegistry =\n                    new SimpleSystemRegistryImpl(parser, context.terminal, context.cwd, configPath) {\n                    };\n            systemRegistry.setCommandRegistries(holder.getCommandRegistries());\n\n            Path history = context.userDirectory.resolve(\".mvnsh_history\");\n            LineReader reader = LineReaderBuilder.builder()\n                    .terminal(context.terminal)\n                    .history(new DefaultHistory())\n                    .highlighter(new ReplHighlighter())\n                    .completer(systemRegistry.completer())\n                    .parser(parser)\n                    .variable(LineReader.LIST_MAX, 50) // max tab completion candidates\n                    .variable(LineReader.HISTORY_FILE, history)\n                    .variable(LineReader.OTHERS_GROUP_NAME, \"Others\")\n                    .variable(LineReader.COMPLETION_STYLE_GROUP, \"fg:blue,bold\")\n                    .variable(\"HELP_COLORS\", \"ti=1;34:co=38:ar=3:op=33:de=90\")\n                    .option(LineReader.Option.GROUP_PERSIST, true)\n                    .build();\n            builtins.setLineReader(reader);\n            systemRegistry.setLineReader(reader);\n            new TailTipWidgets(reader, systemRegistry::commandDescription, 5, TailTipWidgets.TipType.COMPLETER);\n            KeyMap<Binding> keyMap = reader.getKeyMaps().get(\"main\");\n            keyMap.bind(new Reference(\"tailtip-toggle\"), KeyMap.alt(\"s\"));\n\n            AtomicReference<Exception> failure = new AtomicReference<>();\n            while (true) {\n                try {\n                    failure.set(null);\n                    systemRegistry.cleanUp();\n                    Thread commandThread = new Thread(() -> {\n                            failure.set(e);\n                        }\n                    });\n                    context.terminal.handle(Terminal.Signal.INT, signal -> commandThread.interrupt());\n                    commandThread.start();\n                    commandThread.join();\n                    if (failure.get() != null) {\n                        throw failure.get();\n                    }\n                } catch (UserInterruptException e) {\n                } catch (EndOfFileException e) {\n                    return OK;\n                } catch (SystemRegistryImpl.UnknownCommandException e) {\n                    context.writer.accept(context.invokerRequest\n                            .messageBuilderFactory()\n                            .builder()\n                            .error(e.getMessage())\n                            .build());\n                } catch (Exception e) {\n                    systemRegistry.trace(e);\n                    context.writer.accept(context.invokerRequest\n                            .messageBuilderFactory()\n                            .builder()\n                            .error(\"Error: \" + e.getMessage())\n                            .build());\n                    if (context.invokerRequest.options().showErrors().orElse(false)) {\n                        e.printStackTrace(context.terminal.writer());\n                    }\n                    return ERROR;\n                }\n            }",
    "comment": "start the shell and process input until the user quits with Ctrl-D\nIgnore\nreturn CANCELED;"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/project/artifact/MavenMetadataSource.java",
    "type": "method",
    "name": "getEffectiveScope",
    "code": "private static String getEffectiveScope(String originalScope, String inheritedScope) {\n        String effectiveScope = Artifact.SCOPE_RUNTIME;\n\n        if (originalScope == null) {\n            originalScope = Artifact.SCOPE_COMPILE;\n        }\n\n        if (inheritedScope == null) {\n            effectiveScope = originalScope;\n        } else if (Artifact.SCOPE_TEST.equals(originalScope) || Artifact.SCOPE_PROVIDED.equals(originalScope)) {\n            effectiveScope = null;\n        } else if (Artifact.SCOPE_SYSTEM.equals(originalScope)) {\n            effectiveScope = Artifact.SCOPE_SYSTEM;\n        } else if (Artifact.SCOPE_COMPILE.equals(originalScope) && Artifact.SCOPE_COMPILE.equals(inheritedScope)) {\n            effectiveScope = Artifact.SCOPE_COMPILE;\n        } else if (Artifact.SCOPE_TEST.equals(inheritedScope)) {\n            effectiveScope = Artifact.SCOPE_TEST;\n        } else if (Artifact.SCOPE_PROVIDED.equals(inheritedScope)) {\n            effectiveScope = Artifact.SCOPE_PROVIDED;\n        }\n\n        return effectiveScope;\n    }",
    "comment": "direct dependency retains its scope\ntest and provided are not transitive, so exclude them\nsystem scope come through unchanged...\nadded to retain compile scope. Remove if you want compile inherited as runtime"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/InvalidRepositoryException.java",
    "type": "method",
    "name": "InvalidRepositoryException",
    "code": "public InvalidRepositoryException(String message, String repositoryId, MalformedURLException cause) {\n        super(message, cause);\n        this.repositoryId = repositoryId;\n    }",
    "comment": "Error constructing an artifact repository."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/Nested.java",
    "type": "method",
    "name": "put",
    "code": "public void put(int field$, java.lang.Object value$) {\n    switch (field$) {\n    case 0: nested_ints_column = (java.util.List<java.lang.Integer>)value$; break;\n    case 1: nested_string_column = (java.lang.String)value$; break;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumReader.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProfileActivation.java",
    "type": "method",
    "name": "getInactiveProfiles",
    "code": "public List<String> getInactiveProfiles() {\n        return Collections.unmodifiableList(new ArrayList<>(getProfileIds(pa -> !pa.active())));\n    }",
    "comment": "Mimics the pre-Maven 4 \"inactive profiles\" list.\n@deprecated Use {@link #getRequiredInactiveProfileIds()} and {@link #getOptionalInactiveProfileIds()} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "getTestClass",
    "code": "public final TestClass getTestClass() {\n        return testClass;\n    }",
    "comment": "Returns a {@link TestClass} object wrapping the class to be executed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/DefensiveAllDefaultPossibilitiesBuilder.java",
    "type": "method",
    "name": "runnerForClass",
    "code": "public Runner runnerForClass(Class<?> testClass) {\n\t\t\t// don't ignore entire test classes just yet\n\t\t\treturn null;\n\t\t}",
    "comment": "Customization of {@link IgnoredBuilder} that always returns {@code null}.\n\n@since 5.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/cache/CachingSupplier.java",
    "type": "method",
    "name": "CachingSupplier",
    "code": "public CachingSupplier(Function<REQ, REP> supplier) {\n        this.supplier = supplier;\n    }",
    "comment": "A caching supplier wrapper that caches results and exceptions from the underlying supplier.\nUsed internally to cache expensive computations in the session.\n\n@param <REQ> The request type\n@param <REP> The response type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/TimeoutRuleTest.java",
    "type": "method",
    "name": "after",
    "code": "public void after() {\n        run4done = true;\n        run1Lock.unlock();\n    }",
    "comment": "set run4done to make sure that the thread won't continue at run4()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/max/MaxHistory.java",
    "type": "method",
    "name": "forFolder",
    "code": "public static MaxHistory forFolder(File file) {\n        if (file.exists()) {\n            try {\n                return readHistory(file);\n            } catch (CouldNotReadCoreException e) {\n                e.printStackTrace();\n                file.delete();\n            }\n        }\n        return new MaxHistory(file);\n    }",
    "comment": "Loads a {@link MaxHistory} from {@code file}, or generates a new one that"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroPrimitives.java",
    "type": "method",
    "name": "put",
    "code": "public void put(int field$, java.lang.Object value$) {\n    switch (field$) {\n    case 0: bool_column = (java.lang.Boolean)value$; break;\n    case 1: int_column = (java.lang.Integer)value$; break;\n    case 2: long_column = (java.lang.Long)value$; break;\n    case 3: float_column = (java.lang.Float)value$; break;\n    case 4: double_column = (java.lang.Double)value$; break;\n    case 5: binary_column = (java.nio.ByteBuffer)value$; break;\n    case 6: string_column = (java.lang.String)value$; break;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumReader.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/VersionsMetadataGeneratorFactory.java",
    "type": "method",
    "name": "newInstance",
    "code": "public MetadataGenerator newInstance(RepositorySystemSession session, InstallRequest request) {\n        return new VersionsMetadataGenerator(session, request);\n    }",
    "comment": "Maven GA level metadata generator factory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/CountMinSketch.java",
    "type": "method",
    "name": "create",
    "code": "public static CountMinSketch create(double eps, double confidence, int seed) {\n    return new CountMinSketchImpl(eps, confidence, seed);\n  }",
    "comment": "Creates a {@link CountMinSketch} with given relative error ({@code eps}), {@code confidence},\nand random {@code seed}.\n\n@param eps relative error, must be positive\n@param confidence confidence, must be positive and less than 1.0\n@param seed random seed"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/LookupInvoker.java",
    "type": "method",
    "name": "createTerminal",
    "code": "protected final void createTerminal(C context) {\n        if (context.terminal == null) {\n            ProjectBuildLogAppender projectBuildLogAppender =\n                    new ProjectBuildLogAppender(determineBuildEventListener(context));\n            context.closeables.add(projectBuildLogAppender);\n\n            MessageUtils.systemInstall(\n                    builder -> doCreateTerminal(context, builder),\n                    terminal -> doConfigureWithTerminal(context, terminal));\n\n            context.terminal = MessageUtils.getTerminal();\n            context.closeables.add(MessageUtils::systemUninstall);\n            MessageUtils.registerShutdownHook(); // safety belt\n        } else {\n            doConfigureWithTerminal(context, context.terminal);\n        }\n    }",
    "comment": "Create the build log appender; also sets MavenSimpleLogger sink"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Timeout.java",
    "type": "method",
    "name": "Timeout",
    "code": "public Timeout(long timeout, TimeUnit timeUnit) {\n        this.timeout = timeout;\n        this.timeUnit = timeUnit;\n        lookForStuckThread = false;\n    }",
    "comment": "Create a {@code Timeout} instance with the timeout specified\nat the timeUnit of granularity of the provided {@code TimeUnit}.\n\n@param timeout the maximum time to allow the test to run\nbefore it should timeout\n@param timeUnit the time unit for the {@code timeout}\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/ArtifactDescriptorUtils.java",
    "type": "method",
    "name": "toPomArtifactUnconditionally",
    "code": "public static Artifact toPomArtifactUnconditionally(Artifact artifact) {\n        return new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), \"pom\", artifact.getVersion());\n    }",
    "comment": "Creates POM artifact out of passed in artifact by dropping classifier (if exists) and rewriting extension to\n\"pom\". Unconditionally, unlike {@link #toPomArtifact(Artifact)} that does this only for artifacts without\nclassifiers.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/DependencyResolverRequest.java",
    "type": "method",
    "name": "dependencies",
    "code": "public DependencyResolverRequestBuilder dependencies(@Nullable List<DependencyCoordinates> dependencies) {\n            this.dependencies = (dependencies != null) ? dependencies : Collections.emptyList();\n            return this;\n        }",
    "comment": "Sets the direct dependencies. If both a root dependency and direct dependencies are given in the request, the\ndirect dependencies from the request will be merged with the direct dependencies from the root dependency's\nartifact descriptor, giving higher priority to the dependencies from the request.\n\n@param dependencies the direct dependencies, may be {@code null}\n@return this request for chaining, never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4231SnapshotUpdatePolicyTest.java",
    "type": "method",
    "name": "assertChecksum",
    "code": "private void assertChecksum(String checksum, String jar, Properties checksums) {\n        assertEquals(checksum, checksums.getProperty(jar, \"\").toLowerCase(java.util.Locale.ENGLISH));\n    }",
    "comment": "Test the update policy \"never\" for snapshot dependencies is respected.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java",
    "type": "method",
    "name": "handleBeforeAllMethodExecutionException",
    "code": "public void handleBeforeAllMethodExecutionException(ExtensionContext context, Throwable throwable) {\n\t}",
    "comment": "--- Lifecycle methods exception handling"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/server/BlockPushNonFatalFailure.java",
    "type": "method",
    "name": "getResponse",
    "code": "public ByteBuffer getResponse() {\n    Preconditions.checkNotNull(response);\n    return response;\n  }",
    "comment": "Ensure we do not invoke this method if response is not set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/chain-of-responsibility/src/test/java/com/iluwatar/chain/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "contains",
    "code": "public boolean contains(final UTF8String substring) {\n    if (substring.numBytes == 0) {\n      return true;\n    }\n\n    byte first = substring.getByte(0);\n    for (int i = 0; i <= numBytes - substring.numBytes; i++) {\n      if (getByte(i) == first && matchAt(substring, i)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "Returns whether this contains `substring` or not."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/update-method/src/main/java/com/iluwatar/updatemethod/World.java",
    "type": "method",
    "name": "update",
    "code": "private void update() {\n    for (var entity : entities) {\n      entity.update();\n    }\n  }",
    "comment": "Update internal status. The update method pattern invoke update method for each entity in the\ngame."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestPlan.java",
    "type": "method",
    "name": "countTestIdentifiers",
    "code": "public long countTestIdentifiers(Predicate<? super TestIdentifier> predicate) {\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\t\treturn allIdentifiers.values().stream().filter(predicate).count();\n\t}",
    "comment": "Count all {@link TestIdentifier TestIdentifiers} that satisfy the\ngiven {@linkplain Predicate predicate}.\n\n@param predicate a predicate which returns {@code true} for identifiers\nto be counted; never {@code null}\n@return the number of identifiers that satisfy the supplied predicate"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/scanning/ClassFilter.java",
    "type": "method",
    "name": "of",
    "code": "public static ClassFilter of(Predicate<String> namePredicate, Predicate<Class<?>> classPredicate) {\n\t\treturn new ClassFilter(namePredicate, classPredicate);\n\t}",
    "comment": "Create a {@link ClassFilter} instance that filters by names and classes.\n\n@param namePredicate the class name predicate; never {@code null}\n@param classPredicate the class type predicate; never {@code null}\n@return an instance of {@code ClassFilter}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeAlwaysParameter",
    "code": "void cleanupModeAlwaysParameter() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(AlwaysParameterCase.class, \"testAlwaysParameter\", \"java.nio.file.Path\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(alwaysParameterDir).doesNotExist();\n\t\t}",
    "comment": "Ensure that ALWAYS cleanup modes are obeyed for parameters.\n<p/>\nExpect the TempDir to be cleaned up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/demo/app/src/main/java/com/example/android/tflitecamerademo/ImageClassifierFloatMobileNet.java",
    "type": "method",
    "name": "getModelPath",
    "code": "protected String getModelPath() {\n    // you can download this file from\n    // see build.gradle for where to obtain this file. It should be auto\n    // downloaded into assets.\n    return \"mobilenet_v1_1.0_224.tflite\";\n  }",
    "comment": "Initializes an {@code ImageClassifierFloatMobileNet}.\n\n@param activity"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/RemoteSnapshotMetadataGenerator.java",
    "type": "method",
    "name": "if",
    "code": "RemoteSnapshotMetadataGenerator(RepositorySystemSession session, DeployRequest request) {\n        timestamp = (Instant) ConfigUtils.getObject(session, MonotonicClock.now(), Constants.MAVEN_START_INSTANT);\n        Object bn = ConfigUtils.getObject(session, null, Constants.MAVEN_DEPLOY_SNAPSHOT_BUILD_NUMBER);\n        if (bn instanceof Integer integer) {\n            this.buildNumber = integer;\n        } else if (bn instanceof String string) {\n            this.buildNumber = Integer.valueOf(string);\n        } else {\n            this.buildNumber = null;\n        }\n\n        snapshots = new LinkedHashMap<>();\n\n        /*\n         * NOTE: This should be considered a quirk to support interop with Maven's legacy ArtifactDeployer which\n         * processes one artifact at a time and hence cannot associate the artifacts from the same project to use the\n         * same timestamp+buildno for the snapshot versions. Allowing the caller to pass in metadata from a previous\n         * deployment allows to re-establish the association between the artifacts of the same project.\n         */\n        for (Metadata metadata : request.getMetadata()) {\n            if (metadata instanceof RemoteSnapshotMetadata snapshotMetadata) {\n                snapshots.put(snapshotMetadata.getKey(), snapshotMetadata);\n            }\n        }\n    }",
    "comment": "Maven remote GAV level metadata generator.\n<p>\nRemote snapshot metadata converts artifact on-the-fly to use timestamped snapshot version, and enlist it accordingly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-aggregator/src/test/java/com/iluwatar/event/aggregator/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "binaryEquals",
    "code": "public boolean binaryEquals(final UTF8String other) {\n    if (numBytes != other.numBytes) {\n      return false;\n    }\n\n    return ByteArrayMethods.arrayEquals(base, offset, other.base, other.offset, numBytes);\n  }",
    "comment": "Binary equality check of two UTF8String. Note that binary equality is not the same as\nequality under given collation. E.g. if string is collated in case-insensitive two strings\nare considered equal even if they are different in binary comparison."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/main/java/com/iluwatar/circuitbreaker/DefaultCircuitBreaker.java",
    "type": "method",
    "name": "recordFailure",
    "code": "public void recordFailure(String response) {\n    failureCount = failureCount + 1;\n    this.lastFailureTime = System.nanoTime();\n    this.lastFailureResponse = response;\n  }",
    "comment": "Cache the failure response for returning on open state"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/LimitedInputStream.java",
    "type": "method",
    "name": "mark",
    "code": "@Override public synchronized void mark(int readLimit) {\n    in.mark(readLimit);\n    mark = left;\n  }",
    "comment": "it's okay to mark even if mark isn't supported, as reset won't work"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-sourcing/src/main/java/com/iluwatar/event/sourcing/domain/Account.java",
    "type": "method",
    "name": "handleTransferFromEvent",
    "code": "public void handleTransferFromEvent(MoneyTransferEvent moneyTransferEvent) {\n    handleWithdrawal(moneyTransferEvent.getMoney(), moneyTransferEvent.isRealTime());\n  }",
    "comment": "Handles transfer from account event.\n\n@param moneyTransferEvent the money transfer event"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "writeFieldTo",
    "code": "public void writeFieldTo(int ordinal, ByteBuffer buffer) {\n    final long offsetAndSize = getLong(ordinal);\n    final int offset = (int) (offsetAndSize >> 32);\n    final int size = (int) offsetAndSize;\n\n    buffer.putInt(size);\n    int pos = buffer.position();\n    buffer.position(pos + size);\n    Platform.copyMemory(\n      baseObject,\n      baseOffset + offset,\n      buffer.array(),\n      Platform.BYTE_ARRAY_OFFSET + buffer.arrayOffset() + pos,\n      size);\n  }",
    "comment": "Write the bytes of var-length field into ByteBuffer\n\nNote: only work with HeapByteBuffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/profiles/DefaultProfileManager.java",
    "type": "method",
    "name": "DefaultProfileManager",
    "code": "public DefaultProfileManager(PlexusContainer container, Properties props) {\n        try {\n            this.profileSelector = container.lookup(ProfileSelector.class);\n            this.logger = ((MutablePlexusContainer) container).getLogger();\n        } catch (ComponentLookupException e) {\n            throw new IllegalStateException(e);\n        }\n        this.requestProperties = props;\n    }",
    "comment": "the properties passed to the profile manager are the props that\nare passed to maven, possibly containing profile activator properties"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/runner/BaseTestRunner.java",
    "type": "method",
    "name": "setLoading",
    "code": "public void setLoading(boolean enable) {\n        fLoading = enable;\n    }",
    "comment": "Sets the loading behaviour of the test runner"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestReporter.java",
    "type": "method",
    "name": "publishFile",
    "code": "default void publishFile(String name, MediaType mediaType, ThrowingConsumer<Path> action) {\n\t\tthrow new UnsupportedOperationException();\n\t}",
    "comment": "Publish a file or directory with the supplied name and media type written\nby the supplied action and attach it to the current test or container.\n\n<p>The {@link Path} passed to the supplied action will be relative to the\nreport output directory, but it's up to the action to write the file.\n\n@param name the name of the file to be attached; never {@code null} or\nblank and must not contain any path separators\n@param mediaType the media type of the file; never {@code null}; use\n{@link MediaType#APPLICATION_OCTET_STREAM} if unknown\n@param action the action to be executed to write the file; never {@code null}\n@since 5.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(char unexpected, Character actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Character) unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-bus/src/main/java/com/iluwatar/databus/DataBus.java",
    "type": "method",
    "name": "publish",
    "code": "public void publish(final DataType event) {\n    event.setDataBus(this);\n    listeners.forEach(listener -> listener.accept(event));\n  }",
    "comment": "Publish and event to all members.\n\n@param event The event"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/ViewChange.java",
    "type": "method",
    "name": "removeProperty",
    "code": "static ViewChange removeProperty(String property) {\n    return new RemoveProperty(property);\n  }",
    "comment": "Create a ViewChange for removing a table property.\n\n@param property the property name\n@return a ViewChange"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "format",
    "code": "default MessageBuilder format(String pattern, Object... args) {\n        return append(String.format(pattern, args));\n    }",
    "comment": "Append formatted content to the buffer.\n@see String#format(String, Object...)\n\n@param pattern a <a href=\"../util/Formatter.html#syntax\">format string</a>\n@param args arguments referenced by the format specifiers in the format string\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(ClasspathResourceSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link ClasspathResourceSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "removeAppShufflePartitionInfoFromDB",
    "code": "void removeAppShufflePartitionInfoFromDB(AppAttemptShuffleMergeId appAttemptShuffleMergeId) {\n    if (db != null) {\n      try {\n        db.delete(getDbAppAttemptShufflePartitionKey(appAttemptShuffleMergeId));\n      } catch (Exception e) {\n        logger.error(\"Error deleting {} from application shuffle merged partition info in DB\", e,\n          MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId));\n      }\n    }\n  }",
    "comment": "Remove the finalized shuffle partition information for a specific appAttemptShuffleMergeId\n@param appAttemptShuffleMergeId"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/App.java",
    "type": "method",
    "name": "App",
    "code": "public App(final boolean isMongo) {\n    DbManager dbManager = DbManagerFactory.initDb(isMongo);\n    appManager = new AppManager(dbManager);\n    appManager.initDb();\n  }",
    "comment": "Constructor of current App.\n\n@param isMongo boolean"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "isTestPathElement",
    "code": "private static boolean isTestPathElement(final String scope) {\n        return true;\n    }",
    "comment": "TODO let the scope handler deal with this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlob",
    "code": "public static Tensor fromBlob(float[] data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_ARRAY_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.length, shape);\n    final FloatBuffer floatBuffer = allocateFloatBuffer((int) numel(shape));\n    floatBuffer.put(data);\n    return new Tensor_float32(floatBuffer, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.float32 with specified shape and data as array\nof floats.\n\n@param data Tensor elements\n@param shape Tensor shape"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/FrameworkMethod.java",
    "type": "method",
    "name": "producesType",
    "code": "public boolean producesType(Type type) {\n        return getParameterTypes().length == 0 && type instanceof Class<?>\n                && ((Class<?>) type).isAssignableFrom(method.getReturnType());\n    }",
    "comment": "Returns true if this is a no-arg method that returns a value assignable\nto {@code type}\n\n@deprecated This is used only by the Theories runner, and does not\nuse all the generic type info that it ought to. It will be replaced\nwith a forthcoming ParameterSignature#canAcceptResultOf(FrameworkMethod)\nonce Theories moves to junit-contrib."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/VintageDiscovererTests.java",
    "type": "method",
    "name": "classNameFilterExcludesClass",
    "code": "void classNameFilterExcludesClass() {\n\t\t// @formatter:off\n\t\tEngineDiscoveryRequest request = request()\n\t\t\t\t.selectors(selectClass(Foo.class), selectClass(Bar.class))\n\t\t\t\t.filters(ClassNameFilter.includeClassNamePatterns(\".*Foo\"))\n\t\t\t\t.build();\n\t\t// @formatter:on\n\n\t\tvar testDescriptor = discover(request);\n\n\t\tassertThat(testDescriptor.getChildren()).hasSize(1);\n\t\tassertThat(getOnlyElement(testDescriptor.getChildren()).getUniqueId().toString()).contains(Foo.class.getName());\n\t}",
    "comment": "Tests for {@link VintageDiscoverer}.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/TestClass.java",
    "type": "method",
    "name": "TestClass",
    "code": "public TestClass(Class<?> clazz) {\n        this.clazz = clazz;\n        if (clazz != null && clazz.getConstructors().length > 1) {\n            throw new IllegalArgumentException(\n                    \"Test class can only have one constructor\");\n        }\n\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkMethod>>();\n        Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkField>>();\n\n        scanAnnotatedMembers(methodsForAnnotations, fieldsForAnnotations);\n\n        this.methodsForAnnotations = makeDeeplyUnmodifiable(methodsForAnnotations);\n        this.fieldsForAnnotations = makeDeeplyUnmodifiable(fieldsForAnnotations);\n    }",
    "comment": "Creates a {@code TestClass} wrapping {@code clazz}. Each time this\nconstructor executes, the class is scanned for annotations, which can be\nan expensive process (we hope in future JDK's it will not be.) Therefore,\ntry to share instances of {@code TestClass} where possible."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/repository/Proxy.java",
    "type": "method",
    "name": "setHost",
    "code": "public void setHost(String host) {\n        this.host = host;\n    }",
    "comment": "Set proxy host name.\n\n@param host proxy server host name"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ToStringBuilder.java",
    "type": "method",
    "name": "ToStringBuilder",
    "code": "public ToStringBuilder(Object obj) {\n\t\tthis(Preconditions.notNull(obj, \"Object must not be null\").getClass().getSimpleName());\n\t}",
    "comment": "Simple builder for generating strings in custom implementations of\n{@link Object#toString toString()}.\n\n<h2>DISCLAIMER</h2>\n\n<p>These utilities are intended solely for usage within the JUnit framework\nitself. <strong>Any usage by external parties is not supported.</strong>\nUse at your own risk!\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(float unexpected, float actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/interpreter/src/test/java/com/iluwatar/interpreter/NumberExpressionTest.java",
    "type": "method",
    "name": "expressionProvider",
    "code": "public Stream<Arguments> expressionProvider() {\n    return prepareParameters((f, s) -> f);\n  }",
    "comment": "Create a new set of test entries with the expected result\n\n@return The list of parameters used during this test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarBatch.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n    for (ColumnVector c: columns) {\n      c.close();\n    }\n  }",
    "comment": "Called to close all the columns in this batch. It is not valid to access the data after\ncalling this. This must be called at the end to clean up memory allocations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/OldestConflictResolverTest.java",
    "type": "method",
    "name": "testDepthReversed",
    "code": "void testDepthReversed() {\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a1n, a2n, a1n);\n    }",
    "comment": "Tests that <code>a:1.0</code> wins in the scenario:\n<pre>\nb:1.0 -&gt; a:2.0\na:1.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-api-gateway/api-gateway-service/src/main/java/com/iluwatar/api/gateway/ApiGateway.java",
    "type": "method",
    "name": "getProductDesktop",
    "code": "public DesktopProduct getProductDesktop() {\n    var desktopProduct = new DesktopProduct();\n    desktopProduct.setImagePath(imageClient.getImagePath());\n    desktopProduct.setPrice(priceClient.getPrice());\n    return desktopProduct;\n  }",
    "comment": "Retrieves product information that desktop clients need.\n\n@return Product information for clients on a desktop"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getCompileArtifacts",
    "code": "public List<Artifact> getCompileArtifacts() {\n        List<Artifact> list = new ArrayList<>(getArtifacts().size());\n\n        for (Artifact a : getArtifacts()) {\n            if (a.getArtifactHandler().isAddedToClasspath()) {\n                if (isCompilePathElement(a.getScope())) {\n                    list.add(a);\n                }\n            }\n        }\n        return list;\n    }",
    "comment": "TODO classpath check doesn't belong here - that's the other method\nTODO let the scope handler deal with this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/protocol/DiagnoseCorruption.java",
    "type": "method",
    "name": "encode",
    "code": "public void encode(ByteBuf buf) {\n    Encoders.Strings.encode(buf, appId);\n    Encoders.Strings.encode(buf, execId);\n    buf.writeInt(shuffleId);\n    buf.writeLong(mapId);\n    buf.writeInt(reduceId);\n    buf.writeLong(checksum);\n    Encoders.Strings.encode(buf, algorithm);\n  }",
    "comment": "public class DiagnoseCorruption extends BlockTransferMessage {\npublic final String appId;\npublic final String execId;\npublic final int shuffleId;\npublic final long mapId;\npublic final int reduceId;\npublic final long checksum;\npublic final String algorithm;\n\npublic DiagnoseCorruption(\nString appId,\nString execId,\nint shuffleId,\nlong mapId,\nint reduceId,\nlong checksum,\nString algorithm) {\nthis.appId = appId;\nthis.execId = execId;\nthis.shuffleId = shuffleId;\nthis.mapId = mapId;\nthis.reduceId = reduceId;\nthis.checksum = checksum;\nthis.algorithm = algorithm;\n}\n\n@Override\nprotected Type type() {\nreturn Type.DIAGNOSE_CORRUPTION;\n}\n\n@Override\npublic String toString() {\nreturn new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)\n.append(\"appId\", appId)\n.append(\"execId\", execId)\n.append(\"shuffleId\", shuffleId)\n.append(\"mapId\", mapId)\n.append(\"reduceId\", reduceId)\n.append(\"checksum\", checksum)\n.append(\"algorithm\", algorithm)\n.toString();\n}\n\n@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\n\nDiagnoseCorruption that = (DiagnoseCorruption) o;\n\nif (checksum != that.checksum) return false;\nif (shuffleId != that.shuffleId) return false;\nif (mapId != that.mapId) return false;\nif (reduceId != that.reduceId) return false;\nif (!algorithm.equals(that.algorithm)) return false;\nif (!appId.equals(that.appId)) return false;\nif (!execId.equals(that.execId)) return false;\nreturn true;\n}\n\n@Override\npublic int hashCode() {\nint result = appId.hashCode();\nresult = 31 * result + execId.hashCode();\nresult = 31 * result + Integer.hashCode(shuffleId);\nresult = 31 * result + Long.hashCode(mapId);\nresult = 31 * result + Integer.hashCode(reduceId);\nresult = 31 * result + Long.hashCode(checksum);\nresult = 31 * result + algorithm.hashCode();\nreturn result;\n}\n\n@Override\npublic int encodedLength() {\nreturn Encoders.Strings.encodedLength(appId)\n+ Encoders.Strings.encodedLength(execId)\n+ 4 /* encoded length of shuffleId"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/FilePosition.java",
    "type": "method",
    "name": "from",
    "code": "public static FilePosition from(int line) {\n\t\treturn new FilePosition(line);\n\t}",
    "comment": "Create a new {@code FilePosition} using the supplied {@code line} number"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/JUnitCore.java",
    "type": "method",
    "name": "run",
    "code": "public Result run(Computer computer, Class<?>... classes) {\n        return run(Request.classes(computer, classes));\n    }",
    "comment": "Run all the tests in <code>classes</code>.\n\n@param computer Helps construct Runners from classes\n@param classes the classes containing tests\n@return a {@link Result} describing the details of the test run and the failed tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/graph/DefaultGraphBuilderTest.java",
    "type": "method",
    "name": "parameters",
    "code": "public static Stream<Arguments> parameters() {\n        return Stream.of(\n                scenario(\"Full reactor in order\")\n                        .expectResult(\n                                PARENT_MODULE,\n                                MODULE_C,\n                                MODULE_C_1,\n                                MODULE_A,\n                                MODULE_B,\n                                MODULE_C_2,\n                                INDEPENDENT_MODULE),\n                scenario(\"Selected project\").activeRequiredProjects(MODULE_B).expectResult(MODULE_B),\n                scenario(\"Selected aggregator project (including child modules)\")\n                        .activeRequiredProjects(MODULE_C)\n                        .expectResult(MODULE_C, MODULE_C_1, MODULE_C_2),\n                scenario(\"Selected aggregator project with non-recursive\")\n                        .activeRequiredProjects(MODULE_C)\n                        .nonRecursive()\n                        .expectResult(MODULE_C),\n                scenario(\"Selected optional project\")\n                        .activeOptionalProjects(MODULE_B)\n                        .expectResult(MODULE_B),\n                scenario(\"Selected missing optional project\")\n                        .activeOptionalProjects(\"non-existing-module\")\n                        .expectResult(\n                                PARENT_MODULE,\n                                MODULE_C,\n                                MODULE_C_1,\n                                MODULE_A,\n                                MODULE_B,\n                                MODULE_C_2,\n                                INDEPENDENT_MODULE),\n                scenario(\"Selected missing optional and required project\")\n                        .activeOptionalProjects(\"non-existing-module\")\n                        .activeRequiredProjects(MODULE_B)\n                        .expectResult(MODULE_B),\n                scenario(\"Excluded project\")\n                        .inactiveRequiredProjects(MODULE_B)\n                        .expectResult(PARENT_MODULE, MODULE_C, MODULE_C_1, MODULE_A, MODULE_C_2, INDEPENDENT_MODULE),\n                scenario(\"Excluded optional project\")\n                        .inactiveOptionalProjects(MODULE_B)\n                        .expectResult(PARENT_MODULE, MODULE_C, MODULE_C_1, MODULE_A, MODULE_C_2, INDEPENDENT_MODULE),\n                scenario(\"Excluded missing optional project\")\n                        .inactiveOptionalProjects(\"non-existing-module\")\n                        .expectResult(\n                                PARENT_MODULE,\n                                MODULE_C,\n                                MODULE_C_1,\n                                MODULE_A,\n                                MODULE_B,\n                                MODULE_C_2,\n                                INDEPENDENT_MODULE),\n                scenario(\"Excluded missing optional and required project\")\n                        .inactiveOptionalProjects(\"non-existing-module\")\n                        .inactiveRequiredProjects(MODULE_B)\n                        .expectResult(PARENT_MODULE, MODULE_C, MODULE_C_1, MODULE_A, MODULE_C_2, INDEPENDENT_MODULE),\n                scenario(\"Excluded aggregator project with non-recursive\")\n                        .inactiveRequiredProjects(MODULE_C)\n                        .nonRecursive()\n                        .expectResult(PARENT_MODULE, MODULE_C_1, MODULE_A, MODULE_B, MODULE_C_2, INDEPENDENT_MODULE),\n                scenario(\"Selected and excluded same project\")\n                        .activeRequiredProjects(MODULE_A)\n                        .inactiveRequiredProjects(MODULE_A)\n                        .expectResult(MavenExecutionException.class, \"empty reactor\"),\n                scenario(\"Excluded aggregator, but selected child\")\n                        .activeRequiredProjects(MODULE_C_1)\n                        .inactiveRequiredProjects(MODULE_C)\n                        .expectResult(MavenExecutionException.class, \"empty reactor\"),\n                scenario(\"Project selected with different selector resolves to same project\")\n                        .activeRequiredProjects(GROUP_ID + \":\" + MODULE_A)\n                        .inactiveRequiredProjects(MODULE_A)\n                        .expectResult(MavenExecutionException.class, \"empty reactor\"),\n                scenario(\"Selected and excluded same project, but also selected another project\")\n                        .activeRequiredProjects(MODULE_A, MODULE_B)\n                        .inactiveRequiredProjects(MODULE_A)\n                        .expectResult(MODULE_B),\n                scenario(\"Selected missing project as required and as optional\")\n                        .activeRequiredProjects(\"non-existing-module\")\n                        .activeOptionalProjects(\"non-existing-module\")\n                        .expectResult(MavenExecutionException.class, \"do not exist\"),\n                scenario(\"Resuming from project\")\n                        .resumeFrom(MODULE_B)\n                        .expectResult(MODULE_B, MODULE_C_2, INDEPENDENT_MODULE),\n                scenario(\"Selected project with also make dependencies\")\n                        .activeRequiredProjects(MODULE_C_2)\n                        .makeBehavior(REACTOR_MAKE_UPSTREAM)\n                        .expectResult(PARENT_MODULE, MODULE_C, MODULE_A, MODULE_B, MODULE_C_2),\n                scenario(\"Selected project with also make dependents\")\n                        .activeRequiredProjects(MODULE_B)\n                        .makeBehavior(REACTOR_MAKE_DOWNSTREAM)\n                        .expectResult(MODULE_B, MODULE_C_2),\n                scenario(\"Resuming from project with also make dependencies\")\n                        .makeBehavior(REACTOR_MAKE_UPSTREAM)\n                        .resumeFrom(MODULE_C_2)\n                        .expectResult(PARENT_MODULE, MODULE_C, MODULE_A, MODULE_B, MODULE_C_2, INDEPENDENT_MODULE),\n                scenario(\"Selected project with resume from and also make dependency (MNG-4960 IT#1)\")\n                        .activeRequiredProjects(MODULE_C_2)\n                        .resumeFrom(MODULE_B)\n                        .makeBehavior(REACTOR_MAKE_UPSTREAM)\n                        .expectResult(PARENT_MODULE, MODULE_C, MODULE_A, MODULE_B, MODULE_C_2),\n                scenario(\"Selected project with resume from and also make dependent (MNG-4960 IT#2)\")\n                        .activeRequiredProjects(MODULE_B)\n                        .resumeFrom(MODULE_C_2)\n                        .makeBehavior(REACTOR_MAKE_DOWNSTREAM)\n                        .expectResult(MODULE_C_2),\n                scenario(\"Excluding an also make dependency from selectedProject does take its transitive dependency\")\n                        .activeRequiredProjects(MODULE_C_2)\n                        .inactiveRequiredProjects(MODULE_B)\n                        .makeBehavior(REACTOR_MAKE_UPSTREAM)\n                        .expectResult(PARENT_MODULE, MODULE_C, MODULE_A, MODULE_C_2),\n                scenario(\"Excluding a project also excludes its children\")\n                        .inactiveRequiredProjects(MODULE_C)\n                        .expectResult(PARENT_MODULE, MODULE_A, MODULE_B, INDEPENDENT_MODULE),\n                scenario(\"Excluding an also make dependency from resumeFrom does take its transitive dependency\")\n                        .resumeFrom(MODULE_C_2)\n                        .inactiveRequiredProjects(MODULE_B)\n                        .makeBehavior(REACTOR_MAKE_UPSTREAM)\n                        .expectResult(PARENT_MODULE, MODULE_C, MODULE_A, MODULE_C_2, INDEPENDENT_MODULE),\n                scenario(\"Resume from exclude project downstream\")\n                        .resumeFrom(MODULE_A)\n                        .inactiveRequiredProjects(MODULE_B)\n                        .expectResult(MODULE_A, MODULE_C_2, INDEPENDENT_MODULE),\n                scenario(\"Exclude the project we are resuming from (as proposed in MNG-6676)\")\n                        .resumeFrom(MODULE_B)\n                        .inactiveRequiredProjects(MODULE_B)\n                        .expectResult(MODULE_C_2, INDEPENDENT_MODULE),\n                scenario(\"Selected projects in wrong order are resumed correctly in order\")\n                        .activeRequiredProjects(MODULE_C_2, MODULE_B, MODULE_A)\n                        .resumeFrom(MODULE_B)\n                        .expectResult(MODULE_B, MODULE_C_2),\n                scenario(\"Duplicate projects are filtered out\")\n                        .activeRequiredProjects(MODULE_A, MODULE_A)\n                        .expectResult(MODULE_A),\n                scenario(\"Select reactor by specific pom\")\n                        .requestedPom(MODULE_C)\n                        .expectResult(MODULE_C, MODULE_C_1, MODULE_C_2),\n                scenario(\"Select reactor by specific pom with also make dependencies\")\n                        .requestedPom(MODULE_C)\n                        .makeBehavior(REACTOR_MAKE_UPSTREAM)\n                        .expectResult(PARENT_MODULE, MODULE_C, MODULE_C_1, MODULE_A, MODULE_B, MODULE_C_2),\n                scenario(\"Select reactor by specific pom with also make dependents\")\n                        .requestedPom(MODULE_B)\n                        .makeBehavior(REACTOR_MAKE_DOWNSTREAM)\n                        .expectResult(MODULE_B, MODULE_C_2));\n    }",
    "comment": "Not using mocks for these strategies - a mock would just copy the actual implementation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/AbstractTestDescriptor.java",
    "type": "method",
    "name": "AbstractTestDescriptor",
    "code": "protected AbstractTestDescriptor(UniqueId uniqueId, String displayName) {\n\t\tthis(uniqueId, displayName, null);\n\t}",
    "comment": "Create a new {@code AbstractTestDescriptor} with the supplied\n\n@param uniqueId the unique ID of this {@code TestDescriptor}; never\n{@code null}\n@param displayName the display name for this {@code TestDescriptor};\nnever {@code null} or blank\n@see #AbstractTestDescriptor(UniqueId, String, TestSource)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-di/src/main/java/org/apache/maven/di/tool/DiIndexProcessor.java",
    "type": "method",
    "name": "process",
    "code": "public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        logMessage(\n                Diagnostic.Kind.NOTE, \"Processing \" + roundEnv.getRootElements().size() + \" classes\");\n\n        for (Element element : roundEnv.getElementsAnnotatedWith(Named.class)) {\n            if (element instanceof TypeElement typeElement) {\n                String className = getFullClassName(typeElement);\n                processedClasses.add(className);\n            }\n        }\n\n        if (roundEnv.processingOver()) {\n            try {\n                updateFileIfChanged();\n            } catch (Exception e) {\n                logError(\"Error updating file\", e);\n            }\n        }\n\n        return true;\n    }",
    "comment": "Processes classes with the {@link Named} annotation and generates an index file.\n\n@param annotations the annotation types requested to be processed\n@param roundEnv environment for information about the current and prior round\n@return whether or not the set of annotations are claimed by this processor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java",
    "type": "method",
    "name": "alphanumeric",
    "code": "void alphanumeric() {\n\t\tClass<?> testClass = AlphanumericTestCase.class;\n\n\t\tassertThat(testClass.getSuperclass().getName()).isGreaterThan(testClass.getName());\n\n\t\tvar tests = executeTestsInParallel(testClass, Random.class);\n\n\t\ttests.assertStatistics(stats -> stats.succeeded(callSequence.size()));\n\n\t\tassertThat(callSequence).containsExactly(\"$()\", \"AAA()\", \"AAA(org.junit.jupiter.api.TestInfo)\",\n\t\t\t\"AAA(org.junit.jupiter.api.TestReporter)\", \"ZZ_Top()\", \"___()\", \"a1()\", \"a2()\", \"b()\", \"c()\", \"zzz()\");\n\t\tassertThat(threadNames).hasSize(1);\n\t}",
    "comment": "The name of the base class MUST start with a letter alphanumerically\ngreater than \"A\" so that BaseTestCase comes after AlphanumericTestCase\nif methods are sorted by class name for the fallback ordering if two\nmethods have the same name but different parameter lists. Note, however,\nthat Alphanumeric actually does not order methods like that, but we want\nthis check to remain in place to ensure that the ordering does not rely\non the class names."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ModuleUtils.java",
    "type": "method",
    "name": "findAllResourcesInModule",
    "code": "public static List<Resource> findAllResourcesInModule(String moduleName, Predicate<Resource> filter) {\n\t\tPreconditions.notBlank(moduleName, \"Module name must not be null or empty\");\n\t\tPreconditions.notNull(filter, \"Resource filter must not be null\");\n\n\t\tlogger.config(() -> \"Basic version of findAllResourcesInModule() always returns an empty list!\");\n\t\treturn emptyList();\n\t}",
    "comment": "Find all resources for the given module name.\n\n@param moduleName the name of the module to scan; never {@code null} or\n<em>empty</em>\n@param filter the class filter to apply; never {@code null}\n@return an immutable list of all such resources found; never {@code null}\nbut potentially empty\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Literal.java",
    "type": "method",
    "name": "children",
    "code": "default Expression[] children() { return EMPTY_EXPRESSION; }\n}",
    "comment": "Returns the SQL data type of the literal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/options/CommandResult.java",
    "type": "method",
    "name": "success",
    "code": "public static <T> CommandResult<T> success() {\n\t\treturn create(SUCCESS, null);\n\t}",
    "comment": "Exit code indicating any failure(s)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/retry/src/main/java/com/iluwatar/retry/FindCustomer.java",
    "type": "method",
    "name": "FindCustomer",
    "code": "public FindCustomer(String customerId, BusinessException... errors) {\n    this(customerId, new ArrayDeque<>(List.of(errors)));\n  }",
    "comment": "Finds a customer, returning its ID from our records.\n\n<p>This is an imaginary operation that, for some imagined input, returns the ID for a customer.\nHowever, this is a \"flaky\" operation that is supposed to fail intermittently, but for the\npurposes of this example it fails in a programmed way depending on the constructor parameters."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testSimpleMultiply",
    "code": "public void testSimpleMultiply() {\n        Money expected = new Money(28, \"CHF\");\n        assertEquals(expected, f14CHF.multiply(2));\n    }",
    "comment": "[14 CHF] *2 == [28 CHF]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/object-mother/src/main/java/com/iluwatar/objectmother/RoyaltyObjectMother.java",
    "type": "method",
    "name": "createHappyKing",
    "code": "public static King createHappyKing() {\n    var king = new King();\n    king.makeHappy();\n    return king;\n  }",
    "comment": "Method to create a happy king.\n\n@return A happy {@link com.iluwatar.objectmother.King}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/protocol/FetchShuffleBlocks.java",
    "type": "method",
    "name": "encode",
    "code": "public void encode(ByteBuf buf) {\n    super.encode(buf);\n    Encoders.LongArrays.encode(buf, mapIds);\n    buf.writeInt(reduceIds.length);\n    for (int[] ids: reduceIds) {\n      Encoders.IntArrays.encode(buf, ids);\n    }\n    buf.writeBoolean(batchFetchEnabled);\n  }",
    "comment": "public class FetchShuffleBlocks extends AbstractFetchShuffleBlocks {\n// The length of mapIds must equal to reduceIds.size(), for the i-th mapId in mapIds,\n// it corresponds to the i-th int[] in reduceIds, which contains all reduce id for this map id.\npublic final long[] mapIds;\n// When batchFetchEnabled=true, reduceIds[i] contains 2 elements: startReduceId (inclusive) and\n// endReduceId (exclusive) for the mapper mapIds[i].\n// When batchFetchEnabled=false, reduceIds[i] contains all the reduce IDs that mapper mapIds[i]\n// needs to fetch.\npublic final int[][] reduceIds;\npublic final boolean batchFetchEnabled;\n\npublic FetchShuffleBlocks(\nString appId,\nString execId,\nint shuffleId,\nlong[] mapIds,\nint[][] reduceIds,\nboolean batchFetchEnabled) {\nsuper(appId, execId, shuffleId);\nthis.mapIds = mapIds;\nthis.reduceIds = reduceIds;\nassert(mapIds.length == reduceIds.length);\nthis.batchFetchEnabled = batchFetchEnabled;\nif (batchFetchEnabled) {\nfor (int[] ids: reduceIds) {\nassert(ids.length == 2);\n}\n}\n}\n\n@Override\nprotected Type type() { return Type.FETCH_SHUFFLE_BLOCKS; }\n\n@Override\npublic String toString() {\nreturn toStringHelper()\n.append(\"mapIds\", Arrays.toString(mapIds))\n.append(\"reduceIds\", Arrays.deepToString(reduceIds))\n.append(\"batchFetchEnabled\", batchFetchEnabled)\n.toString();\n}\n\n@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\n\nFetchShuffleBlocks that = (FetchShuffleBlocks) o;\nif (!super.equals(that)) return false;\nif (batchFetchEnabled != that.batchFetchEnabled) return false;\nif (!Arrays.equals(mapIds, that.mapIds)) return false;\nreturn Arrays.deepEquals(reduceIds, that.reduceIds);\n}\n\n@Override\npublic int hashCode() {\nint result = super.hashCode();\nresult = 31 * result + Arrays.hashCode(mapIds);\nresult = 31 * result + Arrays.deepHashCode(reduceIds);\nresult = 31 * result + (batchFetchEnabled ? 1 : 0);\nreturn result;\n}\n\n@Override\npublic int getNumBlocks() {\nif (batchFetchEnabled) {\nreturn mapIds.length;\n}\nint numBlocks = 0;\nfor (int[] ids : reduceIds) {\nnumBlocks += ids.length;\n}\nreturn numBlocks;\n}\n\n@Override\npublic int encodedLength() {\nint encodedLengthOfReduceIds = 0;\nfor (int[] ids: reduceIds) {\nencodedLengthOfReduceIds += Encoders.IntArrays.encodedLength(ids);\n}\nreturn super.encodedLength()\n+ Encoders.LongArrays.encodedLength(mapIds)\n+ 4 /* encoded length of reduceIds.size()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/OnHeapColumnVector.java",
    "type": "method",
    "name": "putByteArray",
    "code": "public int putByteArray(int rowId, byte[] value, int offset, int length) {\n    int result = arrayData().appendBytes(length, value, offset);\n    arrayOffsets[rowId] = result;\n    arrayLengths[rowId] = length;\n    return result;\n  }",
    "comment": "APIs dealing with Byte Arrays"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/HealthEndpointIntegrationTest.java",
    "type": "method",
    "name": "customHealthIndicatorShouldReturnUpStatusAndDetails",
    "code": "void customHealthIndicatorShouldReturnUpStatusAndDetails() {\n    // Make the HTTP request to the health endpoint\n    Response response = given(requestSpec).get(getEndpointBasePath()).andReturn();\n\n    // Log the response details\n    logResponseDetails(response);\n\n    // Check if the status is 503 (SERVICE_UNAVAILABLE)\n    if (response.getStatusCode() == HttpStatus.SERVICE_UNAVAILABLE.value()) {\n      LOGGER.warn(\n          \"Custom health indicator returned 503 Service Unavailable. This may be due to CI pipeline \"\n              + \"configuration. Please check the CI pipeline logs.\");\n      // If status is 503, the test passes without further checks\n      response\n          .then()\n          .assertThat()\n          .statusCode(HttpStatus.SERVICE_UNAVAILABLE.value())\n          .log()\n          .all(); // Log the entire response for visibility\n      return;\n    }\n\n    // If status is 200, proceed with additional checks\n    response\n        .then()\n        .assertThat()\n        .statusCode(HttpStatus.OK.value()) // Check that the status is UP\n        .body(\"components.custom.status\", equalTo(\"UP\")) // Verify the custom component status\n        .body(\"components.custom.details.database\", equalTo(\"reachable\")); // Verify custom details\n\n    // Check for \"DOWN\" status and high CPU load\n    if (\"DOWN\".equals(response.path(\"status\"))) {\n      LOGGER.error(\"Custom health indicator response: \" + response.getBody().asString());\n      LOGGER.error(\"Custom health indicator status: \" + response.path(\"status\"));\n      LOGGER.error(\n          \"High CPU load detected: \" + response.path(\"components.cpu.details.processCpuLoad\"));\n    }\n  }",
    "comment": "Test that the custom health indicator returns the UP status and additional details.\n\n<p>The custom health indicator is used to provide more specific information about the health of\na particular component or aspect of the application."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Float> create(Scope scope, float[][] data) {\n    return create(scope, data, Float.class);\n  }",
    "comment": "Creates a rank-2 constant of {@code float} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "escapeKey",
    "code": "private static String escapeKey(String key) {\n        StringBuilder newkey = new StringBuilder();\n\n        for (int i = 0; i < key.length(); i++) {\n            char c = key.charAt(i);\n\n            if (contains(SEPARATORS, c) || contains(WHITE_SPACE, c)) {\n                // escape the separator\n                newkey.append('\\\\');\n                newkey.append(c);\n            } else {\n                newkey.append(c);\n            }\n        }\n\n        return newkey.toString();\n    }",
    "comment": "Escape the separators in the key.\n\n@param key the key\n@return the escaped key"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/DefaultArtifactVersion.java",
    "type": "method",
    "name": "parseVersion",
    "code": "public final void parseVersion(String version) {\n        comparable = new ComparableVersion(version);\n\n        int index = version.indexOf('-');\n\n        String part1;\n        String part2 = null;\n\n        if (index < 0) {\n            part1 = version;\n        } else {\n            part1 = version.substring(0, index);\n            part2 = version.substring(index + 1);\n        }\n\n        if (part2 != null) {\n            if (part2.length() == 1 || !part2.startsWith(\"0\")) {\n                buildNumber = tryParseInt(part2);\n                if (buildNumber == null) {\n                    qualifier = part2;\n                }\n            } else {\n                qualifier = part2;\n            }\n        }\n\n        if ((!part1.contains(\".\")) && !part1.startsWith(\"0\")) {\n            majorVersion = tryParseInt(part1);\n            if (majorVersion == null) {\n                qualifier = version;\n                buildNumber = null;\n            }\n        } else {\n            boolean fallback = false;\n\n            String[] tok = part1.split(\"\\\\.\");\n            int idx = 0;\n            if (idx < tok.length) {\n                majorVersion = getNextIntegerToken(tok[idx++]);\n                if (majorVersion == null) {\n                    fallback = true;\n                }\n            } else {\n                fallback = true;\n            }\n            if (idx < tok.length) {\n                minorVersion = getNextIntegerToken(tok[idx++]);\n                if (minorVersion == null) {\n                    fallback = true;\n                }\n            }\n            if (idx < tok.length) {\n                incrementalVersion = getNextIntegerToken(tok[idx++]);\n                if (incrementalVersion == null) {\n                    fallback = true;\n                }\n            }\n            if (idx < tok.length) {\n                qualifier = tok[idx];\n                fallback = isDigits(qualifier);\n            }\n\n            if (part1.contains(\"..\") || part1.startsWith(\".\") || part1.endsWith(\".\")) {\n                fallback = true;\n            }\n\n            if (fallback) {\n                qualifier = version;\n                majorVersion = null;\n                minorVersion = null;\n                incrementalVersion = null;\n                buildNumber = null;\n            }\n        }\n    }",
    "comment": "qualifier is the whole version, including \"-\"\nstring tokenizer won't detect these and ignores them\nqualifier is the whole version, including \"-\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkSubmitOptionParser.java",
    "type": "method",
    "name": "parse",
    "code": "protected final void parse(List<String> args) {\n    Pattern eqSeparatedOpt = Pattern.compile(\"(--[^=]+)=(.+)\");\n\n    int idx = 0;\n    for (idx = 0; idx < args.size(); idx++) {\n      String arg = args.get(idx);\n      String value = null;\n\n      Matcher m = eqSeparatedOpt.matcher(arg);\n      if (m.matches()) {\n        arg = m.group(1);\n        value = m.group(2);\n      }\n\n      // Look for options with a value.\n      String name = findCliOption(arg, opts);\n      if (name != null) {\n        if (value == null) {\n          if (idx == args.size() - 1) {\n            throw new IllegalArgumentException(\n                String.format(\"Missing argument for option '%s'.\", arg));\n          }\n          idx++;\n          value = args.get(idx);\n        }\n        if (!handle(name, value)) {\n          break;\n        }\n        continue;\n      }\n\n      // Look for a switch.\n      name = findCliOption(arg, switches);\n      if (name != null) {\n        if (!handle(name, null)) {\n          break;\n        }\n        continue;\n      }\n\n      if (!handleUnknown(arg)) {\n        break;\n      }\n    }\n\n    if (idx < args.size()) {\n      idx++;\n    }\n    handleExtraArgs(args.subList(idx, args.size()));\n  }",
    "comment": "Parse a list of spark-submit command line options.\n<p>\nSee SparkSubmitArguments.scala for a more formal description of available options.\n\n@throws IllegalArgumentException If an error is found during parsing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/RocksDB.java",
    "type": "method",
    "name": "db",
    "code": "org.rocksdb.RocksDB db() {\n    org.rocksdb.RocksDB _db = this._db.get();\n    if (_db == null) {\n      throw new IllegalStateException(\"DB is closed.\");\n    }\n    return _db;\n  }",
    "comment": "Try to avoid use-after close since that has the tendency of crashing the JVM. This doesn't\nprevent methods that retrieved the instance from using it after close, but hopefully will\ncatch most cases; otherwise, we'll need some kind of locking."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/eclipse/sisu/plexus/PlexusXmlBeanConverter.java",
    "type": "method",
    "name": "convertText",
    "code": "private Object convertText(final String value, final TypeLiteral<?> toType) {\n        final String text = value.trim();\n\n        final Class<?> rawType = toType.getRawType();\n        if (rawType.isAssignableFrom(String.class)) {\n            return text; // compatible type => no conversion needed\n        }\n\n        // use temporary Key as quick way to auto-box primitive types into their equivalent object types\n        final TypeLiteral<?> boxedType =\n                rawType.isPrimitive() ? Key.get(rawType).getTypeLiteral() : toType;\n\n        for (final TypeConverterBinding b : typeConverterBindings) {\n            if (b.getTypeMatcher().matches(boxedType)) {\n                return b.getTypeConverter().convert(text, toType);\n            }\n        }\n\n        // last chance => attempt to create an instance of the expected type: use the string if non-empty\n        return text.length() == 0 ? newImplementation(rawType) : newImplementation(rawType, text);\n    }",
    "comment": "Converts the given string to the target type, using {@link TypeConverter}s registered with the {@link Injector}.\n\n@param value The string value\n@param toType The target type\n@return Converted instance of the target type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/main/java/com/iluwatar/health/check/CustomHealthIndicator.java",
    "type": "method",
    "name": "evictHealthCache",
    "code": "public void evictHealthCache() {\n    LOGGER.info(\"Evicting health check cache\");\n    try {\n      Cache healthCheckCache = cacheManager.getCache(\"health-check\");\n      LOGGER.info(\"Health check cache: {}\", healthCheckCache);\n      if (healthCheckCache != null) {\n        healthCheckCache.clear();\n      }\n    } catch (Exception e) {\n      LOGGER.error(\"Failed to evict health check cache\", e);\n    }\n  }",
    "comment": "Evicts all entries from the health check cache. This is scheduled to run at a fixed rate\ndefined in the application properties."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Long expected, long actual) {\n\t\tAssertEquals.assertEquals(expected, (Long) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "finalizeShuffleMerge",
    "code": "public MergeStatuses finalizeShuffleMerge(FinalizeShuffleMerge msg) {\n    logger.info(\"{} attempt {} shuffle {} shuffleMerge {}: finalize shuffle merge\",\n      MDC.of(LogKeys.APP_ID$.MODULE$, msg.appId),\n      MDC.of(LogKeys.APP_ATTEMPT_ID$.MODULE$, msg.appAttemptId),\n      MDC.of(LogKeys.SHUFFLE_ID$.MODULE$, msg.shuffleId),\n      MDC.of(LogKeys.SHUFFLE_MERGE_ID$.MODULE$, msg.shuffleMergeId));\n    AppShuffleInfo appShuffleInfo = validateAndGetAppShuffleInfo(msg.appId);\n    if (appShuffleInfo.attemptId != msg.appAttemptId) {\n      throw new IllegalArgumentException(\n        String.format(\"The attempt id %s in this FinalizeShuffleMerge message does not match \"\n            + \"with the current attempt id %s stored in shuffle service for application %s\",\n          msg.appAttemptId, appShuffleInfo.attemptId, msg.appId));\n    }\n    AppAttemptShuffleMergeId appAttemptShuffleMergeId = new AppAttemptShuffleMergeId(\n        msg.appId, msg.appAttemptId, msg.shuffleId, msg.shuffleMergeId);\n    AtomicReference<Map<Integer, AppShufflePartitionInfo>> shuffleMergePartitionsRef =\n      new AtomicReference<>(null);\n    appShuffleInfo.shuffles.compute(msg.shuffleId, (shuffleId, mergePartitionsInfo) -> {\n      if (null != mergePartitionsInfo) {\n        if (msg.shuffleMergeId < mergePartitionsInfo.shuffleMergeId ||\n          mergePartitionsInfo.isFinalized()) {\n          throw new RuntimeException(String.format(\n              \"Shuffle merge finalize request for shuffle %s with\" + \" shuffleMergeId %s is %s\",\n              msg.shuffleId, msg.shuffleMergeId,\n              ErrorHandler.BlockPushErrorHandler.STALE_SHUFFLE_FINALIZE_SUFFIX));\n        } else if (msg.shuffleMergeId > mergePartitionsInfo.shuffleMergeId) {\n          AppAttemptShuffleMergeId currentAppAttemptShuffleMergeId = new AppAttemptShuffleMergeId(\n                  msg.appId, msg.appAttemptId, msg.shuffleId, mergePartitionsInfo.shuffleMergeId);\n          submitCleanupTask(() ->\n              closeAndDeleteOutdatedPartitions(\n                  currentAppAttemptShuffleMergeId, mergePartitionsInfo.shuffleMergePartitions));\n        } else {\n          shuffleMergePartitionsRef.set(mergePartitionsInfo.shuffleMergePartitions);\n        }\n      }\n      writeAppAttemptShuffleMergeInfoToDB(appAttemptShuffleMergeId);\n      return new AppShuffleMergePartitionsInfo(msg.shuffleMergeId, true);\n    });\n    Map<Integer, AppShufflePartitionInfo> shuffleMergePartitions = shuffleMergePartitionsRef.get();\n    MergeStatuses mergeStatuses;\n    if (null == shuffleMergePartitions || shuffleMergePartitions.isEmpty()) {\n      mergeStatuses =\n        new MergeStatuses(msg.shuffleId, msg.shuffleMergeId,\n          new RoaringBitmap[0], new int[0], new long[0]);\n    } else {\n      List<RoaringBitmap> bitmaps = new ArrayList<>(shuffleMergePartitions.size());\n      List<Integer> reduceIds = new ArrayList<>(shuffleMergePartitions.size());\n      List<Long> sizes = new ArrayList<>(shuffleMergePartitions.size());\n      for (AppShufflePartitionInfo partition: shuffleMergePartitions.values()) {\n        synchronized (partition) {\n          try {\n            logger.debug(\"{} attempt {} shuffle {} shuffleMerge {}: finalizing shuffle \" +\n                \"partition {} \", msg.appId, msg.appAttemptId, msg.shuffleId,\n                msg.shuffleMergeId, partition.reduceId);\n            partition.finalizePartition();\n            if (!partition.mapTracker.isEmpty()) {\n              bitmaps.add(partition.mapTracker);\n              reduceIds.add(partition.reduceId);\n              sizes.add(partition.getLastChunkOffset());\n              logger.debug(\"{} attempt {} shuffle {} shuffleMerge {}: finalization results \" +\n                  \"added for partition {} data size {} index size {} meta size {}\",\n                  msg.appId, msg.appAttemptId, msg.shuffleId,\n                  msg.shuffleMergeId, partition.reduceId, partition.getLastChunkOffset(),\n                  partition.indexFile.getPos(), partition.metaFile.getPos());\n            }\n          } catch (IOException ioe) {\n            logger.warn(\"{} attempt {} shuffle {} shuffleMerge {}: exception while \" +\n              \"finalizing shuffle partition {}. Exception message: {}\",\n              MDC.of(LogKeys.APP_ID$.MODULE$, msg.appId),\n              MDC.of(LogKeys.APP_ATTEMPT_ID$.MODULE$, msg.appAttemptId),\n              MDC.of(LogKeys.SHUFFLE_ID$.MODULE$, msg.shuffleId),\n              MDC.of(LogKeys.SHUFFLE_MERGE_ID$.MODULE$, msg.shuffleMergeId),\n              MDC.of(LogKeys.REDUCE_ID$.MODULE$, partition.reduceId),\n              MDC.of(LogKeys.EXCEPTION$.MODULE$, ioe.getMessage()));\n          } finally {\n            partition.cleanable.clean();\n          }\n        }\n      }\n      mergeStatuses = new MergeStatuses(msg.shuffleId, msg.shuffleMergeId,\n        bitmaps.toArray(new RoaringBitmap[bitmaps.size()]), Ints.toArray(reduceIds),\n        Longs.toArray(sizes));\n      appShuffleInfo.shuffles.get(msg.shuffleId).setReduceIds(Ints.toArray(reduceIds));\n    }\n    logger.info(\"{} attempt {} shuffle {} shuffleMerge {}: finalization of shuffle merge completed\",\n      MDC.of(LogKeys.APP_ID$.MODULE$, msg.appId),\n      MDC.of(LogKeys.APP_ATTEMPT_ID$.MODULE$,  msg.appAttemptId),\n      MDC.of(LogKeys.SHUFFLE_ID$.MODULE$, msg.shuffleId),\n      MDC.of(LogKeys.SHUFFLE_MERGE_ID$.MODULE$, msg.shuffleMergeId));\n    return mergeStatuses;\n  }",
    "comment": "If finalizeShuffleMerge from a former application attempt, it is considered late,\nas only the finalizeShuffleMerge request from the current application attempt\nwill be merged. Too old app attempt only being seen by an already failed\napp attempt, and no need use callback to return to client now, because\nthe finalizeShuffleMerge in DAGScheduler has no retry policy, and don't\nuse the BlockPushNonFatalFailure because it's the finalizeShuffleMerge\nrelated case, not the block push case, just throw it in server side now.\nTODO we may use a new exception class to include the finalizeShuffleMerge\nrelated case just as the BlockPushNonFatalFailure contains the block push cases.\nIf no blocks pushed for the finalizeShuffleMerge shuffleMergeId then return\nempty MergeStatuses but cleanup the older shuffleMergeId files.\nThis block covers:\n1. finalization of determinate stage\n2. finalization of indeterminate stage if the shuffleMergeId related to it is the one\nfor which the message is received.\nUpdate the DB for the finalized shuffle\nEven when the mergePartitionsInfo is null, we mark the shuffle as finalized but the results\nsent to the driver will be empty. This can happen when the service didn't receive any\nblocks for the shuffle yet and the driver didn't wait for enough time to finalize the\nshuffle.\nThis can throw IOException which will marks this shuffle partition as not merged."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/test/java/org/junit/vintage/engine/support/UniqueIdReaderTests.java",
    "type": "method",
    "name": "readsUniqueId",
    "code": "void readsUniqueId(LogRecordListener listener) {\n\t\tvar description = createTestDescription(\"ClassName\", \"methodName\", \"uniqueId\");\n\n\t\tvar uniqueId = new UniqueIdReader().apply(description);\n\n\t\tassertEquals(\"uniqueId\", uniqueId);\n\t\tassertThat(listener.stream(UniqueIdReader.class)).isEmpty();\n\t}",
    "comment": "Tests for {@link UniqueIdReader}.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-bus/src/main/java/com/iluwatar/databus/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    final var bus = DataBus.getInstance();\n    bus.subscribe(new StatusMember(1));\n    bus.subscribe(new StatusMember(2));\n    final var foo = new MessageCollectorMember(\"Foo\");\n    final var bar = new MessageCollectorMember(\"Bar\");\n    bus.subscribe(foo);\n    bus.publish(StartingData.of(LocalDateTime.now()));\n    bus.publish(MessageData.of(\"Only Foo should see this\"));\n    bus.subscribe(bar);\n    bus.publish(MessageData.of(\"Foo and Bar should see this\"));\n    bus.unsubscribe(foo);\n    bus.publish(MessageData.of(\"Only Bar should see this\"));\n    bus.publish(StoppingData.of(LocalDateTime.now()));\n  }",
    "comment": "The Data Bus pattern.\n\n@see <a href=\"http://wiki.c2.com/?DataBusPattern\">http://wiki.c2.com/?DataBusPattern</a>\n<p>The Data-Bus pattern provides a method where different parts of an application may pass\nmessages between each other without needing to be aware of the other's existence.\n<p>Similar to the {@code ObserverPattern}, members register themselves with the {@link\nDataBus} and may then receive each piece of data that is published to the Data-Bus. The\nmember may react to any given message or not.\n<p>It allows for Many-to-Many distribution of data, as there may be any number of publishers\nto a Data-Bus, and any number of members receiving the data. All members will receive the\nsame data, the order each receives a given piece of data, is an implementation detail.\n<p>Members may unsubscribe from the Data-Bus to stop receiving data.\n<p>This example of the pattern implements a Synchronous Data-Bus, meaning that when data is\npublished to the Data-Bus, the publish method will not return until all members have received\nthe data and returned.\n<p>The {@link DataBus} class is a Singleton.\n<p>Members of the Data-Bus must implement the {@link Member} interface.\n<p>Data to be published via the Data-Bus must implement the {@link DataType} interface.\n<p>The {@code data} package contains example {@link DataType} implementations.\n<p>The {@code members} package contains example {@link Member} implementations.\n<p>The {@link StatusMember} demonstrates using the DataBus to publish a message to the\nData-Bus when it receives a message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(DiscoverySelector selector, Context context) {\n\t\treturn Resolution.unresolved();\n\t}",
    "comment": "Resolve the supplied {@link DiscoverySelector} using the supplied\n{@link Context Context}.\n\n<p>This method is only called if none of the overloaded variants match.\n\n<p>The default implementation returns {@link Resolution#unresolved()\nunresolved()}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see Context"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeOnSuccessFailingField",
    "code": "void cleanupModeOnSuccessFailingField() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(OnSuccessFailingFieldCase.class, \"testOnSuccessFailingField\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(onSuccessFailingFieldDir).exists();\n\t\t}",
    "comment": "Ensure that ON_SUCCESS cleanup modes are obeyed for failing field tests.\n<p/>\nExpect the TempDir not to be cleaned up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/InputSource.java",
    "type": "method",
    "name": "getModelId",
    "code": "public String getModelId() {\n        return this.modelId;\n    } // -- String getModelId()",
    "comment": "Get the identifier of the POM in the format {@code\n<groupId>:<artifactId>:<version>}.\n\n@return String"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/MojoDescriptor.java",
    "type": "method",
    "name": "clone",
    "code": "public MojoDescriptor clone() {\n        try {\n            return (MojoDescriptor) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e);\n        }\n    }",
    "comment": "Creates a shallow copy of this mojo descriptor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/ProtoLookup.java",
    "type": "method",
    "name": "ProtoLookup",
    "code": "private ProtoLookup(Map<Class<?>, Object> components) {\n        this.components = components;\n    }",
    "comment": "Proto-{@link Lookup} offer ways to provide early components to invoker."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "shouldStop",
    "code": "public synchronized boolean shouldStop() {\n        return fStop;\n    }",
    "comment": "Checks whether the test run should stop."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "map",
    "code": "public <R> Stream<R> map(Function<? super Execution, ? extends R> mapper) {\n\t\tPreconditions.notNull(mapper, \"Mapping function must not be null\");\n\t\treturn stream().map(mapper);\n\t}",
    "comment": "Shortcut for {@code executions.stream().map(mapper)}.\n\n@param mapper a {@code Function} to apply to each execution;\nnever {@code null}\n@return the mapped stream of executions; never {@code null}\n@see #stream()\n@see Stream#map(Function)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getLong",
    "code": "public long getLong() {\n    return VariantUtil.getLong(value, pos);\n  }",
    "comment": "Get a long value from the variant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/special-case/src/main/java/com/iluwatar/specialcase/Db.java",
    "type": "method",
    "name": "seedUser",
    "code": "public void seedUser(String userName, Double amount) {\n    User user = new User(userName);\n    instance.userName2User.put(userName, user);\n    Account account = new Account(amount);\n    instance.user2Account.put(user, account);\n  }",
    "comment": "Seed a user into Db.\n\n@param userName of the user\n@param amount of the user's account"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/management/FakeThreadMXBean.java",
    "type": "method",
    "name": "getThreadCpuTime",
    "code": "public long getThreadCpuTime(long id) {\n    throw new UnsupportedOperationException();\n  }",
    "comment": "{@inheritDoc}\n\n<p>Always throws an {@link UnsupportedOperationException}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/LocalMavenRepo.java",
    "type": "method",
    "name": "determineScope",
    "code": "public ManagedResource.Scope determineScope(ExtensionContext extensionContext) {\n\t\t\tvar store = extensionContext.getRoot().getStore(NAMESPACE);\n\t\t\tvar fileSystemType = store.getOrComputeIfAbsent(\"tempFileSystemType\", key -> {\n\t\t\t\tvar type = getFileSystemType(Path.of(System.getProperty(\"java.io.tmpdir\")));\n\t\t\t\textensionContext.getRoot().publishReportEntry(\"tempFileSystemType\", type);\n\t\t\t\treturn type;\n\t\t\t}, String.class);\n\t\t\treturn \"NTFS\".equalsIgnoreCase(fileSystemType) ? PER_CONTEXT : GLOBAL;\n\t\t}",
    "comment": "Writing to the same file from multiple Maven processes may fail the build on Windows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "setSystemProperties",
    "code": "public DefaultProfileActivationContext setSystemProperties(Map<String, String> systemProperties) {\n        if (systemProperties != null) {\n            this.systemProperties = Collections.unmodifiableMap(systemProperties);\n        } else {\n            this.systemProperties = Collections.emptyMap();\n        }\n\n        return this;\n    }",
    "comment": "Sets the system properties to use for interpolation and profile activation. The system properties are collected\nfrom the runtime environment like {@link System#getProperties()} and environment variables.\n\n@param systemProperties The system properties, may be {@code null}.\n@return This context, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/clustering/JavaKMeansSuite.java",
    "type": "method",
    "name": "testPredictJavaRDD",
    "code": "public void testPredictJavaRDD() {\n    List<Vector> points = Arrays.asList(\n      Vectors.dense(1.0, 2.0, 6.0),\n      Vectors.dense(1.0, 3.0, 0.0),\n      Vectors.dense(1.0, 4.0, 6.0)\n    );\n    JavaRDD<Vector> data = jsc.parallelize(points, 2);\n    KMeansModel model = new KMeans().setK(1).setMaxIterations(5).run(data.rdd());\n    JavaRDD<Integer> predictions = model.predict(data);\n    predictions.first();\n  }",
    "comment": "Should be able to get the first prediction."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/extension/internal/CoreExports.java",
    "type": "method",
    "name": "getExportedPackages",
    "code": "public Map<String, ClassLoader> getExportedPackages() {\n        return packages;\n    }",
    "comment": "Returns packages exported by Maven core and core extensions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelNormalizer.java",
    "type": "method",
    "name": "mergeDuplicates",
    "code": "public Model mergeDuplicates(Model model, ModelBuilderRequest request, ModelProblemCollector problems) {\n        Model.Builder builder = Model.newBuilder(model);\n\n        Build build = model.getBuild();\n        if (build != null) {\n            List<Plugin> plugins = build.getPlugins();\n            Map<Object, Plugin> normalized = new LinkedHashMap<>(plugins.size() * 2);\n\n            for (Plugin plugin : plugins) {\n                Object key = plugin.getKey();\n                Plugin first = normalized.get(key);\n                if (first != null) {\n                    plugin = merger.mergePlugin(plugin, first);\n                }\n                normalized.put(key, plugin);\n            }\n\n            if (plugins.size() != normalized.size()) {\n                builder.build(\n                        Build.newBuilder(build).plugins(normalized.values()).build());\n            }\n        }\n\n        /*\n         * NOTE: This is primarily to keep backward-compat with Maven 2.x which did not validate that dependencies are\n         * unique within a single POM. Upon multiple declarations, 2.x just kept the last one but retained the order of\n         * the first occurrence. So when we're in lenient/compat mode, we have to deal with such broken POMs and mimic\n         * the way 2.x works. When we're in strict mode, the removal of duplicates just saves other merging steps from\n         * aftereffects and bogus error messages.\n         */\n        List<Dependency> dependencies = model.getDependencies();\n        Map<String, Dependency> normalized = new LinkedHashMap<>(dependencies.size() * 2);\n\n        for (Dependency dependency : dependencies) {\n            normalized.put(dependency.getManagementKey(), dependency);\n        }\n\n        if (dependencies.size() != normalized.size()) {\n            builder.dependencies(normalized.values());\n        }\n\n        return builder.build();\n    }",
    "comment": "Handles normalization of a model."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProblemCollector.java",
    "type": "method",
    "name": "create",
    "code": "static <P extends BuilderProblem> ProblemCollector<P> create(@Nullable ProtoSession protoSession) {\n        if (protoSession != null\n                && protoSession.getUserProperties().containsKey(Constants.MAVEN_BUILDER_MAX_PROBLEMS)) {\n            return new Impl<>(\n                    Integer.parseInt(protoSession.getUserProperties().get(Constants.MAVEN_BUILDER_MAX_PROBLEMS)));\n        } else {\n            return create(100);\n        }\n    }",
    "comment": "Creates new instance of problem collector with configuration from the provided session.\n\n@param <P> the type of problem\n@param protoSession the session containing configuration for the problem collector\n@return a new problem collector instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/value-object/src/test/java/com/iluwatar/value/object/HeroStatTest.java",
    "type": "method",
    "name": "testEquals",
    "code": "void testEquals() {\n    var heroStatA = HeroStat.valueOf(3, 9, 2);\n    var heroStatB = HeroStat.valueOf(3, 9, 2);\n    assertEquals(heroStatA, heroStatB);\n  }",
    "comment": "Tester for equals() and hashCode() methods of a class. Using guava's EqualsTester.\n\n@see <a\nhref=\"http://static.javadoc.io/com.google.guava/guava-testlib/19.0/com/google/common/testing/EqualsTester.html\">\nhttp://static.javadoc.io/com.google.guava/guava-testlib/19.0/com/google/common/testing/EqualsTester.html\n</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "RunnerScheduler",
    "code": "private volatile RunnerScheduler scheduler = new RunnerScheduler() {\n\n        public void finished() {\n            // do nothing\n        }\n    };",
    "comment": "Provides most of the functionality specific to a Runner that implements a\n\"parent node\" in the test tree, with children defined by objects of some data\ntype {@code T}. (For {@link BlockJUnit4ClassRunner}, {@code T} is\n{@link Method} . For {@link Suite}, {@code T} is {@link Class}.) Subclasses\nmust implement finding the children of the node, describing each child, and\nrunning each child. ParentRunner will filter and sort children, handle\n{@code @BeforeClass} and {@code @AfterClass} methods,\nhandle annotated {@link ClassRule}s, create a composite\n{@link Description}, and run children sequentially.\n\n@since 4.5"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "readFieldValues",
    "code": "public static List<Object> readFieldValues(List<Field> fields, Object instance) {\n\t\treturn readFieldValues(fields, instance, field -> true);\n\t}",
    "comment": "Read the values of the supplied fields, making each field accessible if\nnecessary and {@linkplain ExceptionUtils#throwAsUncheckedException masking}\nany checked exception as an unchecked exception.\n\n@param fields the list of fields to read; never {@code null}\n@param instance the instance from which the values are to be read; may\nbe {@code null} for static fields\n@return an immutable list of the values of the specified fields; never\n{@code null} but may be empty or contain {@code null} entries"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelCacheTag.java",
    "type": "method",
    "name": "getType",
    "code": "ModelCacheTag<DependencyManagement> IMPORT = new ModelCacheTag<DependencyManagement>() {\n\n        @Override\n        public Class<DependencyManagement> getType() {\n            return DependencyManagement.class;\n        }\n\n        @Override\n        public DependencyManagement intoCache(DependencyManagement data) {\n            return (data != null) ? data.clone() : null;\n        }\n\n        @Override\n        public DependencyManagement fromCache(DependencyManagement data) {\n            return intoCache(data);\n        }\n    };",
    "comment": "The tag used to denote an effective dependency management section from an imported model."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/lazy/LazyFluentIterable.java",
    "type": "method",
    "name": "map",
    "code": "public <T> FluentIterable<T> map(Function<? super E, T> function) {\n    return new LazyFluentIterable<>() {\n        return new DecoratingIterator<>(null) {\n              return null;\n            }\n          }\n        };",
    "comment": "Transforms this FluentIterable into a new one containing objects of the type T.\n\n@param function a function that transforms an instance of E into an instance of T\n@param <T> the target type of the transformation\n@return a new FluentIterable of the new type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java9/org/junit/platform/commons/util/ModuleUtils.java",
    "type": "method",
    "name": "findAllResourcesInModule",
    "code": "public static List<Resource> findAllResourcesInModule(String moduleName, Predicate<Resource> filter) {\n\t\tPreconditions.notBlank(moduleName, \"Module name must not be null or empty\");\n\t\tPreconditions.notNull(filter, \"Resource filter must not be null\");\n\n\t\tlogger.debug(() -> \"Looking for classes in module: \" + moduleName);\n\t\t// @formatter:off\n\t\tSet<ModuleReference> moduleReferences = streamResolvedModules(isEqual(moduleName))\n\t\t\t\t.map(ResolvedModule::reference)\n\t\t\t\t.collect(toSet());\n\t\t// @formatter:on\n\t\treturn scan(moduleReferences, filter, ModuleUtils.class.getClassLoader());\n\t}",
    "comment": "Find all {@linkplain Resource resources} for the given module name.\n\n@param moduleName the name of the module to scan; never {@code null} or\n<em>empty</em>\n@param filter the class filter to apply; never {@code null}\n@return an immutable list of all such resources found; never {@code null}\nbut potentially empty\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertSame",
    "code": "public static void assertSame(Object expected, Object actual, Supplier<String> messageSupplier) {\n\t\tAssertSame.assertSame(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that the {@code expected} object and the {@code actual} object\nare the same object.\n<p>This method should only be used to assert <em>identity</em> between objects.\nTo assert <em>equality</em> between two objects or two primitive values,\nuse one of the {@code assertEquals(...)} methods instead &mdash; for example,\nuse {@code assertEquals(999, 999)} instead of {@code assertSame(999, 999)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/TestImplementorTest.java",
    "type": "method",
    "name": "DoubleTestCase",
    "code": "public DoubleTestCase(TestCase testCase) {\n            fTestCase = testCase;\n        }",
    "comment": "Test an implementor of junit.framework.Test other than TestCase or TestSuite"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/flyweight/src/main/java/com/iluwatar/flyweight/AlchemistShop.java",
    "type": "method",
    "name": "getTopShelf",
    "code": "public final List<Potion> getTopShelf() {\n    return List.copyOf(this.topShelf);\n  }",
    "comment": "Get a read-only list of all the items on the top shelf.\n\n@return The top shelf potions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestDescriptor.java",
    "type": "method",
    "name": "getAncestors",
    "code": "default Set<? extends TestDescriptor> getAncestors() {\n\t\tif (!getParent().isPresent()) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tTestDescriptor parent = getParent().get();\n\t\tSet<TestDescriptor> ancestors = new LinkedHashSet<>();\n\t\tancestors.add(parent);\n\t\t// Need to recurse?\n\t\tif (parent.getParent().isPresent()) {\n\t\t\tancestors.addAll(parent.getAncestors());\n\t\t}\n\t\treturn Collections.unmodifiableSet(ancestors);\n\t}",
    "comment": "Get the immutable set of all <em>ancestors</em> of this descriptor.\n\n<p>An <em>ancestor</em> is the parent of this descriptor or the parent of\none of its parents, recursively.\n\n@see #getParent()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/runner/BaseTestRunner.java",
    "type": "method",
    "name": "getFilteredTrace",
    "code": "public static String getFilteredTrace(String stack) {\n        if (showStackRaw()) {\n            return stack;\n        }\n\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        StringReader sr = new StringReader(stack);\n        BufferedReader br = new BufferedReader(sr);\n\n        String line;\n        try {\n            while ((line = br.readLine()) != null) {\n                if (!filterLine(line)) {\n                    pw.println(line);\n                }\n            }\n        } catch (Exception IOException) {\n            return stack; // return the stack unfiltered\n        }\n        return sw.toString();\n    }",
    "comment": "Filters stack frames from internal JUnit classes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java",
    "type": "method",
    "name": "getThreadsInGroup",
    "code": "private List<Thread> getThreadsInGroup(ThreadGroup group) {\n        final int activeThreadCount = group.activeCount(); // this is just an estimate\n        int threadArraySize = Math.max(activeThreadCount * 2, 100);\n        for (int loopCount = 0; loopCount < 5; loopCount++) {\n            Thread[] threads = new Thread[threadArraySize];\n            int enumCount = group.enumerate(threads);\n            if (enumCount < threadArraySize) {\n                return Arrays.asList(threads).subList(0, enumCount);\n            }\n            // if there are too many threads to fit into the array, enumerate's result\n            // is >= the array's length; therefore we can't trust that it returned all\n            // the threads.  Try again.\n            threadArraySize += 100;\n        }\n        // threads are proliferating too fast for us.  Bail before we get into \n        // trouble.\n        return Collections.emptyList();\n    }",
    "comment": "Returns all active threads belonging to a thread group.\n@param group The thread group.\n@return The active threads in the thread group.  The result should be a\ncomplete list of the active threads at some point in time.  Returns an empty list\nif this cannot be determined, e.g. because new threads are being created at an\nextremely fast rate."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3843PomInheritanceTest.java",
    "type": "method",
    "name": "assertUrlCommon",
    "code": "private void assertUrlCommon(String expected, String actual) {\n        assertTrue(actual.startsWith(expected), \"expected \" + expected + \" but was \" + actual);\n    }",
    "comment": "NOTE: URL adjustment is a slightly different issue, so don't test here and merely check for common prefix"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-aggregrator/information-microservice/src/main/java/com/iluwatar/information/microservice/InformationController.java",
    "type": "method",
    "name": "getProductTitle",
    "code": "public String getProductTitle() {\n    return \"The Product Title.\";\n  }",
    "comment": "Endpoint to retrieve a product's information.\n\n@return product inventory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java",
    "type": "method",
    "name": "createExtensionArtifact",
    "code": "public Artifact createExtensionArtifact(String groupId, String artifactId, String version) {\n        VersionRange versionRange;\n        try {\n            versionRange = VersionRange.createFromVersionSpec(version);\n        } catch (InvalidVersionSpecificationException e) {\n            this.logger.error(\n                    String.format(\n                            \"Invalid version specification '%s' creating extension artifact '%s:%s:%s'.\",\n                            version, groupId, artifactId, version),\n                    e);\n\n            return null;\n        }\n\n        return artifactFactory.createExtensionArtifact(groupId, artifactId, versionRange);\n    }",
    "comment": "MNG-5368: Log a message instead of returning 'null' silently."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/InputLocation.java",
    "type": "method",
    "name": "getColumnNumber",
    "code": "public int getColumnNumber() {\n        return this.columnNumber;\n    } // -- int getColumnNumber()",
    "comment": "Get the one-based column number. The value will be\nnon-positive if unknown.\n\n@return int"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/serialized-lob/src/main/java/com/iluwatar/slob/dbservice/DatabaseService.java",
    "type": "method",
    "name": "DatabaseService",
    "code": "public DatabaseService(String dataTypeDb) {\n    this.dataTypeDb = dataTypeDb;\n  }",
    "comment": "Constructor initializes {@link DatabaseService#dataTypeDb}.\n\n@param dataTypeDb Type of data that is to be stored in DB can be 'TEXT' or 'BINARY'."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java",
    "type": "method",
    "name": "nodeSkipped",
    "code": "default void nodeSkipped(C context, TestDescriptor testDescriptor, SkipResult result) {\n\t}",
    "comment": "Callback invoked when the execution of this node has been skipped.\n\n<p>The default implementation does nothing.\n\n@param context the execution context\n@param testDescriptor the test descriptor that was skipped\n@param result the result of skipped execution\n@since 1.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/JavaPathType.java",
    "type": "method",
    "name": "patchModule",
    "code": "public static Modular patchModule(@Nonnull String moduleName) {\n        return PATCH_MODULE.new Modular(moduleName);\n    }",
    "comment": "Creates a path identified by the Java {@code --patch-module} option.\nContrarily to the other types of paths, this path is applied to only\none specific module. Used for compilation and execution among others.\n\n<h4>Context-sensitive interpretation</h4>\nThis path type makes sense only when a main module is added on the module path by another dependency.\nIn no main module is found, the patch dependency may be added on the class path or module path\ndepending on whether {@link #CLASSES} or {@link #MODULES} is present.\n\n@param moduleName name of the module on which to apply the path\n@return an identification of the patch-module path for the given module.\n\n@see Modular#moduleName()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ClassLoaderUtilsTests.java",
    "type": "method",
    "name": "getClassLoaderPreconditions",
    "code": "void getClassLoaderPreconditions() {\n\t\tassertThatExceptionOfType(PreconditionViolationException.class)//\n\t\t\t\t.isThrownBy(() -> ClassLoaderUtils.getClassLoader(null))//\n\t\t\t\t.withMessage(\"Class must not be null\");\n\t}",
    "comment": "Unit tests for {@link ClassLoaderUtils}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "apply",
    "code": "public Ansi apply(Consumer fun) {\n        fun.apply(this);\n        return this;\n    }",
    "comment": "Applies another function to this Ansi instance.\n\n@param fun the function to apply\n@return this Ansi instance\n@since 2.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/kinesis-asl/src/test/java/org/apache/spark/streaming/kinesis/JavaKinesisInputDStreamBuilderSuite.java",
    "type": "method",
    "name": "testJavaKinesisDStreamBuilderOldApi",
    "code": "public void testJavaKinesisDStreamBuilderOldApi() {\n    String streamName = \"a-very-nice-stream-name\";\n    String endpointUrl = \"https://kinesis.us-west-2.amazonaws.com\";\n    String region = \"us-west-2\";\n    String appName = \"a-very-nice-kinesis-app\";\n    Duration checkpointInterval = Seconds.apply(30);\n    StorageLevel storageLevel = StorageLevel.MEMORY_ONLY();\n\n    KinesisInputDStream<byte[]> kinesisDStream = KinesisInputDStream.builder()\n      .streamingContext(ssc)\n      .streamName(streamName)\n      .endpointUrl(endpointUrl)\n      .regionName(region)\n      .initialPositionInStream(InitialPositionInStream.LATEST)\n      .checkpointAppName(appName)\n      .checkpointInterval(checkpointInterval)\n      .storageLevel(storageLevel)\n      .build();\n    Assertions.assertEquals(streamName, kinesisDStream.streamName());\n    Assertions.assertEquals(endpointUrl, kinesisDStream.endpointUrl());\n    Assertions.assertEquals(region, kinesisDStream.regionName());\n    Assertions.assertEquals(InitialPositionInStream.LATEST,\n        kinesisDStream.initialPosition().getPosition());\n    Assertions.assertEquals(appName, kinesisDStream.checkpointAppName());\n    Assertions.assertEquals(checkpointInterval, kinesisDStream.checkpointInterval());\n    Assertions.assertEquals(storageLevel, kinesisDStream._storageLevel());\n    ssc.stop();\n  }",
    "comment": "Test to ensure that the old API for InitialPositionInStream\nis supported in KinesisDStream.Builder.\nThis test would be removed when we deprecate the KinesisUtils."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "advanceToNextPage",
    "code": "private void advanceToNextPage() {\n      MemoryBlock pageToFree = null;\n\n      try {\n        synchronized (this) {\n          int nextIdx = dataPages.indexOf(currentPage) + 1;\n          if (destructive && currentPage != null) {\n            dataPages.remove(currentPage);\n            pageToFree = currentPage;\n            nextIdx--;\n          }\n          if (dataPages.size() > nextIdx) {\n            currentPage = dataPages.get(nextIdx);\n            pageBaseObject = currentPage.getBaseObject();\n            offsetInPage = currentPage.getBaseOffset();\n            recordsInPage = UnsafeAlignedOffset.getSize(pageBaseObject, offsetInPage);\n            offsetInPage += UnsafeAlignedOffset.getUaoSize();\n          } else {\n            currentPage = null;\n            if (reader != null) {\n              handleFailedDelete();\n            }\n            try {\n              Closeables.close(reader, /* swallowIOException = */ false);\n              reader = spillWriters.getFirst().getReader(serializerManager);\n              recordsInPage = -1;\n            } catch (IOException e) {\n              Platform.throwException(e);\n            }\n          }\n        }\n      } finally {\n        if (pageToFree != null) {\n          freePage(pageToFree);\n        }\n      }\n    }",
    "comment": "SPARK-26265: We will first lock this `MapIterator` and then `TaskMemoryManager` when going\nto free a memory page by calling `freePage`. At the same time, it is possibly that another\nmemory consumer first locks `TaskMemoryManager` and then this `MapIterator` when it\nacquires memory and causes spilling on this `MapIterator`. To avoid deadlock here, we keep\nreference to the page to free and free it after releasing the lock of `MapIterator`.\nScala iterator does not handle exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3581PluginUsesWagonDependencyTest.java",
    "type": "method",
    "name": "MavenITmng3581PluginUsesWagonDependencyTest",
    "code": "public MavenITmng3581PluginUsesWagonDependencyTest() {\n        // Not 2.0.9\n        super(\"(2.0.4,2.0.9),(2.0.9,)\");\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3581\">MNG-3581</a>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "indexOf",
    "code": "public int indexOf(UTF8String v, int start) {\n    if (v.numBytes() == 0) {\n      return indexOfEmpty(start);\n    }\n\n    // locate to the start position.\n    int i = 0; // position in byte\n    int c = 0; // position in character\n    while (i < numBytes && c < start) {\n      i += numBytesForFirstByte(getByte(i));\n      c += 1;\n    }\n\n    do {\n      if (i + v.numBytes > numBytes) {\n        return -1;\n      }\n      if (ByteArrayMethods.arrayEquals(base, offset + i, v.base, v.offset, v.numBytes)) {\n        return c;\n      }\n      i += numBytesForFirstByte(getByte(i));\n      c += 1;\n    } while (i < numBytes);\n\n    return -1;\n  }",
    "comment": "Returns the position of the first occurrence of substr in\ncurrent string from the specified position (0-based index).\n\n@param v the string to be searched\n@param start the start position of the current string for searching\n@return the position of the first occurrence of substr, if not found, -1 returned."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/BenchmarkLatencyActivity.java",
    "type": "method",
    "name": "onCreate",
    "code": "public void onCreate(Bundle savedInstanceState) {\n    Log.i(TAG, \"Create benchmark latency activity.\");\n    super.onCreate(savedInstanceState);\n\n    Intent intent = getIntent();\n    Bundle bundle = intent.getExtras();\n    String[] tfliteSettingsJsonFiles = bundle.getStringArray(TFLITE_SETTINGS_FILES_INTENT_KEY_0);\n    String[] args = bundle.getStringArray(ARGS_INTENT_KEY_0);\n\n    BenchmarkLatencyImpl impl =\n        new BenchmarkLatencyImpl(getApplicationContext(), tfliteSettingsJsonFiles, args);\n    if (impl.initialize()) {\n      impl.benchmark();\n    } else {\n      Log.e(TAG, \"Failed to initialize the latency benchmarking.\");\n    }\n    finish();\n  }",
    "comment": "{@link Activity} class for Delegate Performance Latency Benchmark.\n\n<p>This Activity receives test arguments via a command line specified in an intent extra. It\npasses the arguments to the {@link BenchmarkLatencyImpl} class to perform latency benchmark tests\nvia TFLite Benchmark Tool. Please check the test example in\ntensorflow/lite/tools/benchmark/experimental/delegate_performance/android/README.md."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarBatch.java",
    "type": "method",
    "name": "closeIfFreeable",
    "code": "public void closeIfFreeable() {\n    for (ColumnVector c: columns) {\n      c.closeIfFreeable();\n    }\n  }",
    "comment": "Called to close all the columns if their resources are freeable between batches.\nThis is used to clean up memory allocated during columnar processing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/AssumptionViolatedException.java",
    "type": "method",
    "name": "AssumptionViolatedException",
    "code": "public AssumptionViolatedException(String assumption, Object value, Matcher<?> matcher) {\n        this(assumption, true, value, matcher);\n    }",
    "comment": "An assumption exception with the given <i>value</i> (String or\nThrowable) and an additional failing {@link Matcher}.\n\n@deprecated Please use {@link org.junit.AssumptionViolatedException} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java",
    "type": "method",
    "name": "getConsoleTransferListener",
    "code": "protected TransferListener getConsoleTransferListener(boolean printResourceNames) {\n        return new SimplexTransferListener(new ConsoleMavenTransferListener(System.out, printResourceNames));\n    }",
    "comment": "Customizations available via the CLI"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/AppIsolationSuite.java",
    "type": "method",
    "name": "BlockFetchingListener",
    "code": "TestUtils.getLocalHost(), blockServer.getPort())) {\n\n      AtomicReference<Throwable> exception = new AtomicReference<>();\n\n      CountDownLatch blockFetchLatch = new CountDownLatch(1);\n      BlockFetchingListener listener = new BlockFetchingListener() {\n        @Override\n        public void onBlockFetchFailure(String blockId, Throwable t) {\n          exception.set(t);\n          blockFetchLatch.countDown();\n        }\n      };\n\n      String[] blockIds = { \"shuffle_0_1_2\", \"shuffle_0_3_4\" };\n      OneForOneBlockFetcher fetcher =\n          new OneForOneBlockFetcher(client1, \"app-2\", \"0\", blockIds, listener, conf);\n      fetcher.start();\n      blockFetchLatch.await();\n      checkSecurityException(exception.get());\n\n      ExecutorShuffleInfo executorInfo = new ExecutorShuffleInfo(\n        new String[] { System.getProperty(\"java.io.tmpdir\") }, 1,\n        ChunkReceivedCallback callback = new ChunkReceivedCallback() {\n\n          @Override\n          public void onFailure(int chunkIndex, Throwable t) {\n            exception.set(t);\n            chunkReceivedLatch.countDown();\n          }\n        };\n\n        exception.set(null);\n        client2.fetchChunk(streamId, 0, callback);\n        chunkReceivedLatch.await();\n        checkSecurityException(exception.get());\n      }",
    "comment": "Start a new server with the correct RPC handler to serve block data.\nCreate a client, and make a request to fetch blocks from a different app.\nRegister an executor so that the next steps work."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/PlatformUtilSuite.java",
    "type": "method",
    "name": "heapMemoryReuse",
    "code": "public void heapMemoryReuse() {\n    MemoryAllocator heapMem = new HeapMemoryAllocator();\n    MemoryBlock onheap1 = heapMem.allocate(513);\n    Object obj1 = onheap1.getBaseObject();\n    heapMem.free(onheap1);\n    MemoryBlock onheap2 = heapMem.allocate(514);\n    Assertions.assertNotEquals(obj1, onheap2.getBaseObject());\n\n    MemoryBlock onheap3 = heapMem.allocate(1024 * 1024 + 1);\n    Assertions.assertEquals(1024 * 1024 + 1, onheap3.size());\n    Object obj3 = onheap3.getBaseObject();\n    heapMem.free(onheap3);\n    MemoryBlock onheap4 = heapMem.allocate(1024 * 1024 + 7);\n    Assertions.assertEquals(1024 * 1024 + 7, onheap4.size());\n    Assertions.assertEquals(obj3, onheap4.getBaseObject());\n  }",
    "comment": "The size is less than `HeapMemoryAllocator.POOLING_THRESHOLD_BYTES`,\nallocate new memory every time.\nThe size is greater than `HeapMemoryAllocator.POOLING_THRESHOLD_BYTES`,\nreuse the previous memory which has released."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/half-sync-half-async/src/main/java/com/iluwatar/halfsynchalfasync/AsynchronousService.java",
    "type": "method",
    "name": "AsynchronousService",
    "code": "public AsynchronousService(BlockingQueue<Runnable> workQueue) {\n    service = new ThreadPoolExecutor(10, 10, 10, TimeUnit.SECONDS, workQueue);\n  }",
    "comment": "Creates an asynchronous service using {@code workQueue} as communication channel between\nasynchronous layer and synchronous layer. Different types of queues such as Priority queue, can\nbe used to control the pattern of communication between the layers."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/lockable-object/src/main/java/com/iluwatar/lockableobject/domain/Creature.java",
    "type": "method",
    "name": "acquire",
    "code": "public boolean acquire(@NonNull Lockable lockable) {\n    if (lockable.lock(this)) {\n      instruments.add(lockable);\n      return true;\n    }\n    return false;\n  }",
    "comment": "Reaches for the Lockable and tried to hold it.\n\n@param lockable as the Lockable to lock.\n@return true of Lockable was locked by this creature."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java",
    "type": "method",
    "name": "StreamManager",
    "code": "final StreamManager manager = new StreamManager() {\n    };",
    "comment": "First request should eventually fail.\nIncrement the semaphore and the second request should succeed quickly.\nThe timeout is relative to the LAST request sent, which is kinda weird, but still.\nThis test also makes sure the timeout works for Fetch requests as well as RPCs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/factory-method/src/test/java/com/iluwatar/factory/method/FactoryMethodTest.java",
    "type": "method",
    "name": "testOrcBlacksmithWithSpear",
    "code": "void testOrcBlacksmithWithSpear() {\n    var blacksmith = new OrcBlacksmith();\n    var weapon = blacksmith.manufactureWeapon(WeaponType.SPEAR);\n    verifyWeapon(weapon, WeaponType.SPEAR, OrcWeapon.class);\n  }",
    "comment": "Testing {@link OrcBlacksmith} to produce a SPEAR asserting that the Weapon is an instance of\n{@link OrcWeapon}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fanout-fanin/src/main/java/com/iluwatar/fanout/fanin/SquareNumberRequest.java",
    "type": "method",
    "name": "delayedSquaring",
    "code": "public void delayedSquaring(final Consumer consumer) {\n\n    var minTimeOut = 5000L;\n\n    SecureRandom secureRandom = new SecureRandom();\n    var randomTimeOut = secureRandom.nextInt(2000);\n\n    try {\n      // this will make the thread sleep from 5-7s.\n      Thread.sleep(minTimeOut + randomTimeOut);\n    } catch (InterruptedException e) {\n      LOGGER.error(\"Exception while sleep \", e);\n      Thread.currentThread().interrupt();\n    } finally {\n      consumer.add(number * number);\n    }\n  }",
    "comment": "Squares the number with a little timeout to give impression of long-running process that return\nat different times.\n\n@param consumer callback class that takes the result after the delay."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(boolean expected, boolean actual) {\n        Assert.assertEquals(expected, actual);\n    }",
    "comment": "Asserts that two booleans are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/buffer/FileSegmentManagedBuffer.java",
    "type": "method",
    "name": "FileSegmentManagedBuffer",
    "code": "public FileSegmentManagedBuffer(TransportConf conf, File file, long offset, long length) {\n    this.conf = conf;\n    this.file = file;\n    this.offset = offset;\n    this.length = length;\n  }",
    "comment": "A {@link ManagedBuffer} backed by a segment in a file."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testBagSumAdd",
    "code": "public void testBagSumAdd() {\n        IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(28, \"USD\"));\n        assertEquals(expected, fMB1.add(fMB2));\n    }",
    "comment": "{[12 CHF][7 USD]} + {[14 CHF][21 USD]} == {[26 CHF][28 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginManagerException.java",
    "type": "method",
    "name": "PluginManagerException",
    "code": "protected PluginManagerException(Plugin plugin, String message, MavenProject project, Throwable cause) {\n        super(message, cause);\n\n        this.project = project;\n        pluginGroupId = plugin.getGroupId();\n        pluginArtifactId = plugin.getArtifactId();\n        pluginVersion = plugin.getVersion();\n    }",
    "comment": "Exception in the plugin manager."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/function/Try.java",
    "type": "method",
    "name": "andThen",
    "code": "public <U> Try<U> andThen(Function<V, Try<U>> function) {\n\t\t\treturn uncheckedCast();\n\t\t}",
    "comment": "don't call function because this Try is a failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/mapping/DefaultLifecycleMapping.java",
    "type": "method",
    "name": "DefaultLifecycleMapping",
    "code": "public DefaultLifecycleMapping(final List<Lifecycle> lifecycles) {\n        this.lifecycleMap =\n                Collections.unmodifiableMap(lifecycles.stream().collect(toMap(Lifecycle::getId, identity())));\n    }",
    "comment": "Ctor to be used in Java code/providers."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/anti-corruption-layer/src/main/java/com/iluwatar/corruption/system/DataStore.java",
    "type": "method",
    "name": "DataStore",
    "code": "public DataStore() {\n    inner = new HashMap<>();\n  }",
    "comment": "The class represents a data store for the modern system.\n\n@param <V> the type of the value stored in the data store"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/main/java/com/iluwatar/identitymap/IdentityMap.java",
    "type": "method",
    "name": "getPerson",
    "code": "public Person getPerson(int id) {\n    Person person = personMap.get(id);\n    if (person == null) {\n      LOGGER.info(\"ID not in Map.\");\n      return null;\n    }\n    LOGGER.info(person.toString());\n    return person;\n  }",
    "comment": "Get Person with given id.\n\n@param id : personNationalId as requested by user."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/InputSource.java",
    "type": "method",
    "name": "setModelId",
    "code": "public void setModelId(String modelId) {\n        this.modelId = modelId;\n    } // -- void setModelId( String )",
    "comment": "Set the identifier of the POM in the format {@code\n<groupId>:<artifactId>:<version>}.\n\n@param modelId"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/Scope.java",
    "type": "method",
    "name": "applyControlDependencies",
    "code": "public OperationBuilder applyControlDependencies(OperationBuilder builder) {\n    for (Operand<?> control : controlDependencies) {\n      builder = builder.addControlInput(control.asOutput().op());\n    }\n    return builder;\n  }",
    "comment": "Adds each Operand in controlDependencies as a control input to the provided builder.\n\n@param builder OperationBuilder to add control inputs to"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-builder-support/src/main/java/org/apache/maven/building/StringSource.java",
    "type": "method",
    "name": "StringSource",
    "code": "public StringSource(CharSequence content, String location) {\n        this.content = (content != null) ? content.toString() : \"\";\n        this.location = (location != null) ? location : \"(memory)\";\n        this.hashCode = this.content.hashCode();\n    }",
    "comment": "Creates a new source backed by the specified string.\n\n@param content The String representation, may be empty or {@code null}.\n@param location The location to report for this use, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/TunnelingProxyServer.java",
    "type": "method",
    "name": "TunnelingProxyServer",
    "code": "public TunnelingProxyServer(int port, String targetHost, int targetPort, String connectFilter) {\n        this.port = port;\n        this.targetHost = targetHost;\n        this.targetPort = targetPort;\n        this.connectFilter = connectFilter;\n    }",
    "comment": "A simple HTTP proxy that only understands the CONNECT method to check HTTPS tunneling.\n\n@author Benjamin Bentmann"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/connector/catalog/functions/JavaStrLen.java",
    "type": "method",
    "name": "invoke",
    "code": "public int invoke(UTF8String str) {\n      if (str == null) {\n        return 0;\n      }\n      return str.toString().length();\n    }",
    "comment": "a null-safe version which returns 0 for null arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/resource-managers/yarn/src/main/java/org/apache/spark/deploy/yarn/AmIpFilter.java",
    "type": "method",
    "name": "if",
    "code": "if (proxyUriBases.size() == 1) {\n      addr = proxyUriBases.values().iterator().next();\n    } else if (rmUrls != null) {\n      for (String url : rmUrls) {\n        String host = proxyUriBases.get(url);\n        if (isValidUrl(host)) {\n          addr = host;\n          break;\n        }\n      }\n    }",
    "comment": "external proxy or not RM HA"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/notification/RunNotifier.java",
    "type": "method",
    "name": "fireTestSuiteFinished",
    "code": "public void fireTestSuiteFinished(final Description description) {\n        new SafeNotifier() {\n        }.run();\n    }",
    "comment": "Invoke to tell listeners that a test suite is about to finish. Always invoke\nthis method if you invoke {@link #fireTestSuiteStarted(Description)}\nas listeners are likely to expect them to come in pairs.\n\n@param description the description of the suite test (generally a class name)\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/ArtifactDescriptorReaderDelegate.java",
    "type": "method",
    "name": "convert",
    "code": "private Dependency convert(org.apache.maven.api.model.Dependency dependency, ArtifactTypeRegistry stereotypes) {\n        ArtifactType stereotype = stereotypes.get(dependency.getType());\n        if (stereotype == null) {\n            stereotype = new DefaultType(dependency.getType(), Language.NONE, \"\", null, false);\n        }\n\n        boolean system = dependency.getSystemPath() != null\n                && !dependency.getSystemPath().isEmpty();\n\n        Map<String, String> props = null;\n        if (system) {\n            props = Collections.singletonMap(MavenArtifactProperties.LOCAL_PATH, dependency.getSystemPath());\n        }\n\n        Artifact artifact = new DefaultArtifact(\n                dependency.getGroupId(),\n                dependency.getArtifactId(),\n                dependency.getClassifier(),\n                null,\n                dependency.getVersion(),\n                props,\n                stereotype);\n\n        List<Exclusion> exclusions = new ArrayList<>(dependency.getExclusions().size());\n        for (org.apache.maven.api.model.Exclusion exclusion : dependency.getExclusions()) {\n            exclusions.add(convert(exclusion));\n        }\n\n        return new Dependency(\n                artifact,\n                dependency.getScope(),\n                dependency.getOptional() != null ? dependency.isOptional() : null,\n                exclusions);\n    }",
    "comment": "TODO: this here is fishy"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/HikariConfig.java",
    "type": "method",
    "name": "if",
    "code": "else if (dataSourceClassName != null) {\n         if (driverClassName != null) {\n            LOGGER.error(\"{} - cannot use driverClassName and dataSourceClassName together.\", poolName);\n            throw new IllegalStateException(\"cannot use driverClassName and dataSourceClassName together.\");\n         }\n         else if (jdbcUrl != null) {\n            LOGGER.warn(\"{} - using dataSourceClassName and ignoring jdbcUrl.\", poolName);\n         }\n      }",
    "comment": "NOTE: This exception text is referenced by a Spring Boot FailureAnalyzer, it should not be\nchanged without first notifying the Spring Boot developers."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/TestCaseTest.java",
    "type": "method",
    "name": "tearDown",
    "code": "protected void tearDown() {\n            fTornDown = true;\n        }",
    "comment": "A test case testing the testing framework."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/AllTests.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n        junit.textui.TestRunner.run(suite());\n    }",
    "comment": "TestSuite that runs all the JUnit tests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/util/collection/unsafe/sort/UnsafeExternalSorterSuite.java",
    "type": "method",
    "name": "RecordComparator",
    "code": "final RecordComparator recordComparator = new RecordComparator() {\n  };",
    "comment": "Use integer comparison for comparing prefixes (which are partition ids, in this case)\nSince the key fits within the 8-byte prefix, we don't need to do any record comparison, so\nuse a dummy comparator"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroNonNullableArrays.java",
    "type": "method",
    "name": "setStringsColumn",
    "code": "public void setStringsColumn(java.util.List<java.lang.String> value) {\n    this.strings_column = value;\n  }",
    "comment": "Sets the value of the 'strings_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/ParseResult.java",
    "type": "method",
    "name": "tagExpressionOrThrow",
    "code": "default TagExpression tagExpressionOrThrow(Function<String, RuntimeException> exceptionCreator) {\n\t\tif (errorMessage().isPresent()) {\n\t\t\tthrow exceptionCreator.apply(errorMessage().get());\n\t\t}\n\t\treturn tagExpression().get();\n\t}",
    "comment": "Return the parsed {@link TagExpression} or throw an exception with the\ncontained parse error.\n\n@param exceptionCreator will be called with the error message in case\nthis parse result contains a parse error; never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(char unexpected, char actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java",
    "type": "method",
    "name": "copyIncludingDescendants",
    "code": "protected JupiterTestDescriptor copyIncludingDescendants(UnaryOperator<UniqueId> uniqueIdTransformer) {\n\t\tJupiterTestDescriptor result = withUniqueId(uniqueIdTransformer);\n\t\tgetChildren().forEach(oldChild -> {\n\t\t\tTestDescriptor newChild = ((JupiterTestDescriptor) oldChild).copyIncludingDescendants(uniqueIdTransformer);\n\t\t\tresult.addChild(newChild);\n\t\t});\n\t\treturn result;\n\t}",
    "comment": "{@return a deep copy (with copies of children) of this descriptor with the supplied unique ID}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/clustering/JavaLDASuite.java",
    "type": "method",
    "name": "localLDAModel",
    "code": "public void localLDAModel() {\n    Matrix topics = LDASuite.tinyTopics();\n    double[] topicConcentration = new double[topics.numRows()];\n    Arrays.fill(topicConcentration, 1.0D / topics.numRows());\n    LocalLDAModel model = new LocalLDAModel(topics, Vectors.dense(topicConcentration), 1.0, 100.0);\n\n    assertEquals(model.k(), tinyK);\n    assertEquals(model.vocabSize(), tinyVocabSize);\n    assertEquals(model.topicsMatrix(), tinyTopics);\n\n    Tuple2<int[], double[]>[] fullTopicSummary = model.describeTopics();\n    assertEquals(fullTopicSummary.length, tinyK);\n    for (int i = 0; i < fullTopicSummary.length; i++) {\n      assertArrayEquals(fullTopicSummary[i]._1(), tinyTopicDescription[i]._1());\n      assertArrayEquals(fullTopicSummary[i]._2(), tinyTopicDescription[i]._2(), 1e-5);\n    }\n  }",
    "comment": "Check: basic parameters\nCheck: describeTopics() with all terms"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ArtifactResolverRequest.java",
    "type": "method",
    "name": "builder",
    "code": "static ArtifactResolverRequestBuilder builder() {\n        return new ArtifactResolverRequestBuilder();\n    }",
    "comment": "A request for resolving an artifact.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/TimeMode.java",
    "type": "method",
    "name": "EventTime",
    "code": "public static final TimeMode EventTime() { return EventTime$.MODULE$; }\n}",
    "comment": "Stateful processor that uses event time to register timers. Note that ttl is not\nsupported in this TimeMode."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testBagNegate",
    "code": "public void testBagNegate() {\n        IMoney expected = MoneyBag.create(new Money(-12, \"CHF\"), new Money(-7, \"USD\"));\n        assertEquals(expected, fMB1.negate());\n    }",
    "comment": "{[12 CHF][7 USD]} negate == {[-12 CHF][-7 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/special-case/src/main/java/com/iluwatar/specialcase/Db.java",
    "type": "method",
    "name": "withdraw",
    "code": "public MoneyTransaction withdraw(Double price) {\n      if (price > amount) {\n        return null;\n      }\n      return new MoneyTransaction(amount, price);\n    }",
    "comment": "Withdraw the price of the item from the account.\n\n@param price of the item\n@return instance of MoneyTransaction"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/TensorImpl.java",
    "type": "method",
    "name": "fromSignatureOutput",
    "code": "static TensorImpl fromSignatureOutput(long signatureRunnerHandle, String outputName) {\n    long tensorHandle = createSignatureOutputTensor(signatureRunnerHandle, outputName);\n    if (tensorHandle == -1) {\n      throw new IllegalArgumentException(\"Input error: output \" + outputName + \" not found.\");\n    } else {\n      return new TensorImpl(tensorHandle);\n    }\n  }",
    "comment": "Creates a Tensor wrapper for a Signature output.\n\n<p>The caller is responsible for closing the created wrapper, and ensuring the provided native\nSignatureRunner is valid until the tensor is closed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Short expected, Short actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationSupport.java",
    "type": "method",
    "name": "if",
    "code": "final UTF8String replace, final int collationId) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType) {\n        return execBinary(src, search, replace);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(src, search, replace);\n      } else {\n        return execICU(src, search, replace, collationId);\n      }\n    }",
    "comment": "Space trimming does not affect the output of this expression."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertNull",
    "code": "public static void assertNull(Object object) {\n        assertNull(null, object);\n    }",
    "comment": "Asserts that an object is null. If it isn't an {@link AssertionError} is\nthrown.\n\n@param object Object to check or <code>null</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-to-worker/src/main/java/com/iluwatar/servicetoworker/GiantController.java",
    "type": "method",
    "name": "GiantController",
    "code": "public GiantController(Dispatcher dispatcher) {\n    this.dispatcher = dispatcher;\n  }",
    "comment": "Instantiates a new Giant controller.\n\n@param dispatcher the dispatcher"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/gpu/java/src/main/java/org/tensorflow/lite/gpu/CompatibilityList.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n    if (compatibilityListHandle != INVALID_COMPATIBILITY_LIST_HANDLE) {\n      deleteCompatibilityList(compatibilityListHandle);\n      compatibilityListHandle = INVALID_COMPATIBILITY_LIST_HANDLE;\n    }\n  }",
    "comment": "Frees TFLite resources in C runtime.\n\n<p>User is expected to call this method explicitly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfig.java",
    "type": "method",
    "name": "addLauncherDiscoveryListeners",
    "code": "public Builder addLauncherDiscoveryListeners(LauncherDiscoveryListener... listeners) {\n\t\t\tPreconditions.notNull(listeners, \"LauncherDiscoveryListener array must not be null\");\n\t\t\tPreconditions.containsNoNullElements(listeners,\n\t\t\t\t\"LauncherDiscoveryListener array must not contain null elements\");\n\t\t\tCollections.addAll(this.discoveryListeners, listeners);\n\t\t\treturn this;\n\t\t}",
    "comment": "Add all of the supplied launcher discovery listeners to the configuration.\n\n@param listeners additional launcher discovery listeners to register;\nnever {@code null} or containing {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3641ProfileActivationWarningTest.java",
    "type": "method",
    "name": "MavenITmng3641ProfileActivationWarningTest",
    "code": "public MavenITmng3641ProfileActivationWarningTest() {\n        super(\"[2.0.11,2.1.0-M1),[2.1.0,4.0.0-alpha-1)\"); // only test in 2.0.11+, 2.1.0+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3641\">MNG-3641</a>:\nProfile activation warning test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4464PlatformIndependentFileSeparatorTest.java",
    "type": "method",
    "name": "assertPath",
    "code": "private void assertPath(Properties props, String key, String path) {\n        String actual = props.getProperty(key, \"\");\n        assertTrue(actual.endsWith(path.replace('/', File.separatorChar)), actual);\n    }",
    "comment": "Test that Maven recognizes both the forward and the backward slash as file separators, regardless of the\nunderlying filesystem (i.e. even on Unix).\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Request.java",
    "type": "method",
    "name": "classWithoutSuiteMethod",
    "code": "public static Request classWithoutSuiteMethod(Class<?> clazz) {\n        return new ClassRequest(clazz, false);\n    }",
    "comment": "Create a <code>Request</code> that, when processed, will run all the tests\nin a class. If the class has a suite() method, it will be ignored.\n\n@param clazz the class containing the tests\n@return a <code>Request</code> that will cause all tests in the class to be run"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "getProperty",
    "code": "public String getProperty(String key) {\n        return this.get(key);\n    }",
    "comment": "Searches for the property with the specified key in this property list.\n\n@param key the property key.\n@return the value in this property list with the specified key value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/ByteArray.java",
    "type": "method",
    "name": "padWithEmptyPattern",
    "code": "private static byte[] padWithEmptyPattern(byte[] bytes, int len) {\n    len = Math.min(bytes.length, len);\n    final byte[] result = new byte[len];\n    Platform.copyMemory(bytes, Platform.BYTE_ARRAY_OFFSET, result, Platform.BYTE_ARRAY_OFFSET, len);\n    return result;\n  }",
    "comment": "Helper method for implementing `lpad` and `rpad`.\nIf the padding pattern's length is 0, return the first `len` bytes of the input byte\nsequence if it is longer than `len` bytes, or a copy of the byte sequence, otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java",
    "type": "method",
    "name": "before",
    "code": "public final JupiterEngineExecutionContext before(JupiterEngineExecutionContext context) {\n\t\tThrowableCollector throwableCollector = context.getThrowableCollector();\n\n\t\tif (isPerClassLifecycle(context)) {\n\t\t\tClassExtensionContext extensionContext = (ClassExtensionContext) context.getExtensionContext();\n\t\t\tthrowableCollector.execute(() -> {\n\t\t\t\tTestInstances testInstances = context.getTestInstancesProvider().getTestInstances(context);\n\t\t\t\textensionContext.setTestInstances(testInstances);\n\t\t\t});\n\t\t}\n\n\t\tif (throwableCollector.isEmpty()) {\n\t\t\tcontext.beforeAllCallbacksExecuted(true);\n\t\t\tinvokeBeforeAllCallbacks(context);\n\n\t\t\tif (throwableCollector.isEmpty()) {\n\t\t\t\tcontext.beforeAllMethodsExecuted(true);\n\t\t\t\tinvokeBeforeAllMethods(context);\n\t\t\t}\n\t\t}\n\n\t\tthrowableCollector.assertEmpty();\n\n\t\treturn context;\n\t}",
    "comment": "Eagerly load test instance for BeforeAllCallbacks, if necessary,\nand store the instance in the ExtensionContext."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolver.java",
    "type": "method",
    "name": "buildClassNamePredicate",
    "code": "private Predicate<String> buildClassNamePredicate(EngineDiscoveryRequest request) {\n\t\t\tList<DiscoveryFilter<String>> filters = new ArrayList<>();\n\t\t\tfilters.addAll(request.getFiltersByType(ClassNameFilter.class));\n\t\t\tfilters.addAll(request.getFiltersByType(PackageNameFilter.class));\n\t\t\treturn Filter.composeFilters(filters).toPredicate();\n\t\t}",
    "comment": "Build a {@link Predicate} for fully qualified class names to be used for\nclasspath scanning from an {@link EngineDiscoveryRequest}.\n\n@param request the request to build a predicate from"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
    "type": "method",
    "name": "reportCompletion",
    "code": "private void reportCompletion() {\n\t\tif (throwableCollector.isEmpty() && skipResult.isSkipped()) {\n\t\t\ttry {\n\t\t\t\tnode.nodeSkipped(context, testDescriptor, skipResult);\n\t\t\t}\n\t\t\tcatch (Throwable throwable) {\n\t\t\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(throwable);\n\t\t\t\tlogger.debug(throwable,\n\t\t\t\t\t() -> String.format(\"Failed to invoke nodeSkipped() on Node %s\", testDescriptor.getUniqueId()));\n\t\t\t}\n\t\t\ttaskContext.getListener().executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n\t\t\treturn;\n\t\t}\n\t\tif (!started) {\n\t\t\ttaskContext.getListener().executionStarted(testDescriptor);\n\t\t}\n\t\ttry {\n\t\t\tnode.nodeFinished(context, testDescriptor, throwableCollector.toTestExecutionResult());\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(throwable);\n\t\t\tlogger.debug(throwable,\n\t\t\t\t() -> String.format(\"Failed to invoke nodeFinished() on Node %s\", testDescriptor.getUniqueId()));\n\t\t}\n\t\ttaskContext.getListener().executionFinished(testDescriptor, throwableCollector.toTestExecutionResult());\n\t\tthrowableCollector = null;\n\t}",
    "comment": "Call executionStarted first to comply with the contract of EngineExecutionListener."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/ErrorCollector.java",
    "type": "method",
    "name": "checkThat",
    "code": "public <T> void checkThat(final T value, final Matcher<T> matcher) {\n        checkThat(\"\", value, matcher);\n    }",
    "comment": "Adds a failure to the table if {@code matcher} does not match {@code value}.\nExecution continues, but the test will fail at the end if the match fails."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/JavaAPISuite.java",
    "type": "method",
    "name": "testVariousTransformWith",
    "code": "public void testVariousTransformWith() {\n\n    List<List<Integer>> inputData1 = Arrays.asList(Arrays.asList(1));\n    List<List<String>> inputData2 = Arrays.asList(Arrays.asList(\"x\"));\n    JavaDStream<Integer> stream1 = JavaTestUtils.attachTestInputStream(ssc, inputData1, 1);\n    JavaDStream<String> stream2 = JavaTestUtils.attachTestInputStream(ssc, inputData2, 1);\n\n    List<List<Tuple2<String, Integer>>> pairInputData1 =\n        Arrays.asList(Arrays.asList(new Tuple2<>(\"x\", 1)));\n    List<List<Tuple2<Double, Character>>> pairInputData2 =\n        Arrays.asList(Arrays.asList(new Tuple2<>(1.0, 'x')));\n    JavaPairDStream<String, Integer> pairStream1 = JavaPairDStream.fromJavaDStream(\n        JavaTestUtils.attachTestInputStream(ssc, pairInputData1, 1));\n    JavaPairDStream<Double, Character> pairStream2 = JavaPairDStream.fromJavaDStream(\n        JavaTestUtils.attachTestInputStream(ssc, pairInputData2, 1));\n\n    stream1.transformWith(stream2, (rdd1, rdd2, time) -> null);\n\n    stream1.transformWith(pairStream1, (rdd1, rdd2, time) -> null);\n\n    stream1.transformWithToPair(stream2, (rdd1, rdd2, time) -> null);\n\n    stream1.transformWithToPair(pairStream1, (rdd1, rdd2, time) -> null);\n\n    pairStream1.transformWith(stream2, (rdd1, rdd2, time) -> null);\n\n    pairStream1.transformWith(pairStream1, (rdd1, rdd2, time) -> null);\n\n    pairStream1.transformWithToPair(stream2, (rdd1, rdd2, time) -> null);\n\n    pairStream1.transformWithToPair(pairStream2, (rdd1, rdd2, time) -> null);\n  }",
    "comment": "tests whether all variations of transformWith can be called from Java"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/JavaAPISuite.java",
    "type": "method",
    "name": "testForeachRDD",
    "code": "public void testForeachRDD() {\n    final LongAccumulator accumRdd = ssc.sparkContext().sc().longAccumulator();\n    final LongAccumulator accumEle = ssc.sparkContext().sc().longAccumulator();\n    List<List<Integer>> inputData = Arrays.asList(\n        Arrays.asList(1,1,1),\n        Arrays.asList(1,1,1));\n\n    JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1);\n    JavaTestUtils.attachTestOutputStream(stream.count()); // dummy output\n\n    stream.foreachRDD(rdd -> {\n      accumRdd.add(1);\n      rdd.foreach(i -> accumEle.add(1));\n    });\n\n    stream.foreachRDD((rdd, time) -> {});\n\n    JavaTestUtils.runStreams(ssc, 2, 2);\n\n    Assertions.assertEquals(2, accumRdd.value().intValue());\n    Assertions.assertEquals(6, accumEle.value().intValue());\n  }",
    "comment": "This is a test to make sure foreachRDD(VoidFunction2) can be called from Java"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ErrorHandler.java",
    "type": "method",
    "name": "shouldRetryError",
    "code": "public boolean shouldRetryError(Throwable t) {\n      // If it is a connection time-out or a connection closed exception, no need to retry.\n      // If it is a FileNotFoundException originating from the client while pushing the shuffle\n      // blocks to the server, even then there is no need to retry. We will still log this\n      // exception once which helps with debugging.\n      if (t.getCause() instanceof ConnectException ||\n          t.getCause() instanceof FileNotFoundException) {\n        return false;\n      }\n\n      // If the block is too late or the invalid block push or the attempt is not the latest one,\n      // there is no need to retry it\n      return !(t instanceof BlockPushNonFatalFailure blockPushNonFatalFailure &&\n        BlockPushNonFatalFailure\n          .shouldNotRetryErrorCode(blockPushNonFatalFailure.getReturnCode()));\n    }",
    "comment": "String constant used for generating exception messages indicating the server rejecting a\nshuffle finalize request since shuffle blocks of a higher shuffleMergeId for a shuffle is\nalready being pushed. This typically happens in the case of indeterminate stage retries\nwhere if a stage attempt fails then the entirety of the shuffle output needs to be rolled\nback. For more details refer SPARK-23243, SPARK-25341 and SPARK-32923."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/EngineFilter.java",
    "type": "method",
    "name": "excludeEngines",
    "code": "public static EngineFilter excludeEngines(String... engineIds) {\n\t\treturn excludeEngines(Arrays.asList(engineIds));\n\t}",
    "comment": "Create a new <em>exclude</em> {@code EngineFilter} based on the\n<em>excluded</em> from test discovery and execution.\n\n@param engineIds the list of engine IDs to match against; never {@code null}\nor empty; individual IDs must also not be null or blank\n@see #excludeEngines(List)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java",
    "type": "method",
    "name": "randomWithCustomSeed",
    "code": "void randomWithCustomSeed(@TrackLogRecords LogRecordListener listener) {\n\t\tvar seed = \"42\";\n\t\tvar expectedMessage = \"Using custom seed for configuration parameter [\" + Random.RANDOM_SEED_PROPERTY_NAME\n\t\t\t\t+ \"] with value [\" + seed + \"].\";\n\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\tcallSequence.clear();\n\t\t\tlistener.clear();\n\n\t\t\tvar tests = executeRandomTestCaseInParallelWithRandomSeed(seed);\n\n\t\t\ttests.assertStatistics(stats -> stats.succeeded(callSequence.size()));\n\n\t\t\tassertThat(callSequence).containsExactly(\"test2()\", \"test3()\", \"test4()\", \"repetition 1 of 1\", \"test1()\");\n\n\t\t\tassertThat(listener.stream(Random.class, Level.CONFIG)\n\t\t\t\t\t.map(LogRecord::getMessage))\n\t\t\t\t\t.contains(expectedMessage);\n\t\t}\n\n\t\tassertThat(threadNames).size().isGreaterThanOrEqualTo(3);\n\t}",
    "comment": "With a custom seed, the \"randomness\" must be the same for every iteration.\n@formatter:off\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/TensorFlowLite.java",
    "type": "method",
    "name": "schemaVersion",
    "code": "public static String schemaVersion(TfLiteRuntime runtime) {\n    return getFactory(runtime, \"org.tensorflow.lite.TensorFlowLite\", \"schemaVersion\")\n        .schemaVersion();\n  }",
    "comment": "Returns the version of the TensorFlowLite model schema that is supported by the specified\nTensorFlowLite runtime."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "cursorMove",
    "code": "public Ansi cursorMove(final int x, final int y) {\n        return cursorRight(x).cursorDown(y);\n    }",
    "comment": "Moves the cursor relative to the current position. The cursor is moved right if x is\npositive, left if negative and down if y is positive and up if negative.\n\n@param x the number of characters to move horizontally\n@param y the number of lines to move vertically\n@return this Ansi instance\n@since 2.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Stopwatch.java",
    "type": "method",
    "name": "succeeded",
    "code": "protected void succeeded(long nanos, Description description) {\n    }",
    "comment": "Invoked when a test succeeds"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "UpdateColumnNullability",
    "code": "private UpdateColumnNullability(String[] fieldNames, boolean nullable) {\n      this.fieldNames = fieldNames;\n      this.nullable = nullable;\n    }",
    "comment": "A TableChange to update the nullability of a field.\n<p>\nThe field names are used to find the field to update.\n<p>\nIf the field does not exist, the change must result in an {@link IllegalArgumentException}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/Lifecycle.java",
    "type": "method",
    "name": "setPhases",
    "code": "public void setPhases(java.util.List<Phase> phases) {\n        this.phases = phases;\n    } // -- void setPhases( java.util.List )",
    "comment": "Set the phase mappings for this lifecycle.\n\n@param phases a phases object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/DirectorySelectorTests.java",
    "type": "method",
    "name": "equalsAndHashCode",
    "code": "void equalsAndHashCode() {\n\t\tvar selector1 = new DirectorySelector(\"/example/foo\");\n\t\tvar selector2 = new DirectorySelector(\"/example/foo\");\n\t\tvar selector3 = new DirectorySelector(\"/example/bar\");\n\n\t\tassertEqualsAndHashCode(selector1, selector2, selector3);\n\t}",
    "comment": "Unit tests for {@link DirectorySelector}.\n\n@since 1.3\n@see DiscoverySelectorsTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantBuilder.java",
    "type": "method",
    "name": "finishWritingObject",
    "code": "public void finishWritingObject(int start, ArrayList<FieldEntry> fields) {\n    int size = fields.size();\n    Collections.sort(fields);\n    int maxId = size == 0 ? 0 : fields.get(0).id;\n    if (allowDuplicateKeys) {\n      int distinctPos = 0;\n      for (int i = 1; i < size; ++i) {\n        maxId = Math.max(maxId, fields.get(i).id);\n        if (fields.get(i).id == fields.get(i - 1).id) {\n          if (fields.get(distinctPos).offset < fields.get(i).offset) {\n            fields.set(distinctPos, fields.get(distinctPos).withNewOffset(fields.get(i).offset));\n          }\n        } else {\n          ++distinctPos;\n          fields.set(distinctPos, fields.get(i));\n        }\n      }\n      if (distinctPos + 1 < fields.size()) {\n        size = distinctPos + 1;\n        fields.subList(size, fields.size()).clear();\n        fields.sort(Comparator.comparingInt(f -> f.offset));\n        int currentOffset = 0;\n        for (int i = 0; i < size; ++i) {\n          int oldOffset = fields.get(i).offset;\n          int fieldSize = VariantUtil.valueSize(writeBuffer, start + oldOffset);\n          System.arraycopy(writeBuffer, start + oldOffset,\n              writeBuffer, start + currentOffset, fieldSize);\n          fields.set(i, fields.get(i).withNewOffset(currentOffset));\n          currentOffset += fieldSize;\n        }\n        writePos = start + currentOffset;\n        Collections.sort(fields);\n      }\n    } else {\n      for (int i = 1; i < size; ++i) {\n        maxId = Math.max(maxId, fields.get(i).id);\n        String key = fields.get(i).key;\n        if (key.equals(fields.get(i - 1).key)) {\n          @SuppressWarnings(\"unchecked\")\n          Map<String, String> parameters = Map$.MODULE$.<String, String>empty().updated(\"key\", key);\n          throw new SparkRuntimeException(\"VARIANT_DUPLICATE_KEY\", parameters,\n              null, new QueryContext[]{}, \"\");\n      }\n    }\n    int dataSize = writePos - start;\n    boolean largeSize = size > U8_MAX;\n    int sizeBytes = largeSize ? U32_SIZE : 1;\n    int idSize = getIntegerSize(maxId);\n    int offsetSize = getIntegerSize(dataSize);\n    int headerSize = 1 + sizeBytes + size * idSize + (size + 1) * offsetSize;\n    checkCapacity(headerSize);\n    System.arraycopy(writeBuffer, start, writeBuffer, start + headerSize, dataSize);\n    writePos += headerSize;\n    writeBuffer[start] = objectHeader(largeSize, idSize, offsetSize);\n    writeLong(writeBuffer, start + 1, size, sizeBytes);\n    int idStart = start + 1 + sizeBytes;\n    int offsetStart = idStart + size * idSize;\n    for (int i = 0; i < size; ++i) {\n      writeLong(writeBuffer, idStart + i * idSize, fields.get(i).id, idSize);\n      writeLong(writeBuffer, offsetStart + i * offsetSize, fields.get(i).offset, offsetSize);\n    }\n    writeLong(writeBuffer, offsetStart + size * offsetSize, dataSize, offsetSize);\n  }\n\n  public void finishWritingArray(int start, ArrayList<Integer> offsets) {\n    int dataSize = writePos - start;\n    int size = offsets.size();\n    boolean largeSize = size > U8_MAX;\n    int sizeBytes = largeSize ? U32_SIZE : 1;\n    int offsetSize = getIntegerSize(dataSize);\n    int headerSize = 1 + sizeBytes + (size + 1) * offsetSize;\n    checkCapacity(headerSize);\n    System.arraycopy(writeBuffer, start, writeBuffer, start + headerSize, dataSize);\n    writePos += headerSize;\n    writeBuffer[start] = arrayHeader(largeSize, offsetSize);\n    writeLong(writeBuffer, start + 1, size, sizeBytes);\n    int offsetStart = start + 1 + sizeBytes;\n    for (int i = 0; i < size; ++i) {\n      writeLong(writeBuffer, offsetStart + i * offsetSize, offsets.get(i), offsetSize);\n    }\n    writeLong(writeBuffer, offsetStart + size * offsetSize, dataSize, offsetSize);\n  }\n\n  public void appendVariant(Variant v) {\n    appendVariantImpl(v.value, v.metadata, v.pos);\n  }\n\n  private void appendVariantImpl(byte[] value, byte[] metadata, int pos) {\n    checkIndex(pos, value.length);\n    int basicType = value[pos] & BASIC_TYPE_MASK;\n    switch (basicType) {\n      case OBJECT:\n        handleObject(value, pos, (size, idSize, offsetSize, idStart, offsetStart, dataStart) -> {\n          ArrayList<FieldEntry> fields = new ArrayList<>(size);\n          int start = writePos;\n          for (int i = 0; i < size; ++i) {\n            int id = readUnsigned(value, idStart + idSize * i, idSize);\n            int offset = readUnsigned(value, offsetStart + offsetSize * i, offsetSize);\n            int elementPos = dataStart + offset;\n            String key = getMetadataKey(metadata, id);\n            int newId = addKey(key);\n            fields.add(new FieldEntry(key, newId, writePos - start));\n            appendVariantImpl(value, metadata, elementPos);\n          }\n          finishWritingObject(start, fields);\n          return null;\n        });\n        break;\n      case ARRAY:\n        handleArray(value, pos, (size, offsetSize, offsetStart, dataStart) -> {\n          ArrayList<Integer> offsets = new ArrayList<>(size);\n          int start = writePos;\n          for (int i = 0; i < size; ++i) {\n            int offset = readUnsigned(value, offsetStart + offsetSize * i, offsetSize);\n            int elementPos = dataStart + offset;\n            offsets.add(writePos - start);\n            appendVariantImpl(value, metadata, elementPos);\n          }\n          finishWritingArray(start, offsets);\n          return null;\n        });\n        break;\n      default:\n        shallowAppendVariantImpl(value, pos);\n        break;\n    }\n  }\n\n  public void shallowAppendVariant(Variant v) {\n    shallowAppendVariantImpl(v.value, v.pos);\n  }\n\n  private void shallowAppendVariantImpl(byte[] value, int pos) {\n    int size = valueSize(value, pos);\n    checkIndex(pos + size - 1, value.length);\n    checkCapacity(size);\n    System.arraycopy(value, pos, writeBuffer, writePos, size);\n    writePos += size;\n  }\n\n  private void checkCapacity(int additional) {\n    int required = writePos + additional;\n    if (required > writeBuffer.length) {\n      int newCapacity = Integer.highestOneBit(required);\n      newCapacity = newCapacity < required ? newCapacity * 2 : newCapacity;\n      if (newCapacity > SIZE_LIMIT) {\n        throw new VariantSizeLimitException();\n      }\n      byte[] newValue = new byte[newCapacity];\n      System.arraycopy(writeBuffer, 0, newValue, 0, writePos);\n      writeBuffer = newValue;\n    }\n  }\n\n  public static final class FieldEntry implements Comparable<FieldEntry> {\n    final String key;\n    final int id;\n    final int offset;\n\n    public FieldEntry(String key, int id, int offset) {\n      this.key = key;\n      this.id = id;\n      this.offset = offset;\n    }\n\n    FieldEntry withNewOffset(int newOffset) {\n      return new FieldEntry(key, id, newOffset);\n    }\n\n    @Override\n    public int compareTo(FieldEntry other) {\n      return key.compareTo(other.key);\n    }\n  }\n\n  private void buildJson(JsonParser parser) throws IOException {\n    JsonToken token = parser.currentToken();\n    if (token == null) {\n      throw new JsonParseException(parser, \"Unexpected null token\");\n    }\n    switch (token) {\n      case START_OBJECT: {\n        ArrayList<FieldEntry> fields = new ArrayList<>();\n        int start = writePos;\n        while (parser.nextToken() != JsonToken.END_OBJECT) {\n          String key = parser.currentName();\n          parser.nextToken();\n          int id = addKey(key);\n          fields.add(new FieldEntry(key, id, writePos - start));\n          buildJson(parser);\n        }\n        finishWritingObject(start, fields);\n        break;\n      }\n      case START_ARRAY: {\n        ArrayList<Integer> offsets = new ArrayList<>();\n        int start = writePos;\n        while (parser.nextToken() != JsonToken.END_ARRAY) {\n          offsets.add(writePos - start);\n          buildJson(parser);\n        }\n        finishWritingArray(start, offsets);\n        break;\n      }\n      case VALUE_STRING:\n        appendString(parser.getText());\n        break;\n      case VALUE_NUMBER_INT:\n        try {\n          appendLong(parser.getLongValue());\n        } catch (InputCoercionException ignored) {\n          parseFloatingPoint(parser);\n        }\n        break;\n      case VALUE_NUMBER_FLOAT:\n        parseFloatingPoint(parser);\n        break;\n      case VALUE_TRUE:\n        appendBoolean(true);\n        break;\n      case VALUE_FALSE:\n        appendBoolean(false);\n        break;\n      case VALUE_NULL:\n        appendNull();\n        break;\n      default:\n        throw new JsonParseException(parser, \"Unexpected token \" + token);\n    }\n  }\n\n  private int getIntegerSize(int value) {\n    assert value >= 0 && value <= U24_MAX;\n    if (value <= U8_MAX) return 1;\n    if (value <= U16_MAX) return 2;\n    return U24_SIZE;\n  }\n\n  private void parseFloatingPoint(JsonParser parser) throws IOException {\n    if (!tryParseDecimal(parser.getText())) {\n      appendDouble(parser.getDoubleValue());\n    }\n  }\n\n  private boolean tryParseDecimal(String input) {\n    for (int i = 0; i < input.length(); ++i) {\n      char ch = input.charAt(i);\n      if (ch != '-' && ch != '.' && !(ch >= '0' && ch <= '9')) {\n        return false;\n      }\n    }\n    BigDecimal d = new BigDecimal(input);\n    if (d.scale() <= MAX_DECIMAL16_PRECISION && d.precision() <= MAX_DECIMAL16_PRECISION) {\n      appendDecimal(d);\n      return true;\n    }\n    return false;\n  }\n\n  private byte[] writeBuffer = new byte[128];\n  private int writePos = 0;\n  private final HashMap<String, Integer> dictionary = new HashMap<>();\n  private final ArrayList<byte[]> dictionaryKeys = new ArrayList<>();\n  private final boolean allowDuplicateKeys;\n}",
    "comment": "Finish writing a variant object after all of its fields have already been written. The process\nis as follows:\n1. The caller calls `getWritePos` before writing any fields to obtain the `start` parameter.\n2. The caller appends all the object fields to the builder. In the meantime, it should maintain\nthe `fields` parameter. Before appending each field, it should append an entry to `fields` to\nrecord the offset of the field. The offset is computed as `getWritePos() - start`.\n3. The caller calls `finishWritingObject` to finish writing a variant object.\n\nThis function is responsible to sort the fields by key. If there are duplicate field keys:\n- when `allowDuplicateKeys` is true, the field with the greatest offset value (the last\nappended one) is kept.\n- otherwise, throw an exception.\nMaintain a list of distinct keys in-place.\nFound a duplicate key. Keep the field with a greater offset.\nFound a distinct key. Add the field to the list.\nResize `fields` to `size`.\nSort the fields by offsets so that we can move the value data of each field to the new\noffset without overwriting the fields after it.\nChange back to the sort order by field keys to meet the variant spec.\nThe space for header byte, object size, id list, and offset list.\nShift the just-written field data to make room for the object header section.\nFinish writing a variant array after all of its elements have already been written. The process\nis similar to that of `finishWritingObject`.\nThe space for header byte, object size, and offset list.\nShift the just-written field data to make room for the header section.\nAppend a variant value to the variant builder. We need to insert the keys in the input variant\ninto the current variant dictionary and rebuild it with new field ids. For scalar values in the\ninput variant, we can directly copy the binary slice.\nAppend the variant value without rewriting or creating any metadata. This is used when\nbuilding an object during shredding, where there is a fixed pre-existing metadata that\nall shredded values will refer to.\nAllocate a new buffer with a capacity of the next power of 2 of `required`.\nTemporarily store the information of a field. We need to collect all fields in an JSON object,\nsort them by their keys, and build the variant object in sorted order.\nIf the value doesn't fit any integer type, parse it as decimal or floating instead.\nChoose the smallest unsigned integer type that can store `value`. It must be within\n`[0, U24_MAX]`.\nTry to parse a JSON number as a decimal. Return whether the parsing succeeds. The input must\nonly use the decimal format (an integer value with an optional '.' in it) and must not use\nscientific notation. It also must fit into the precision limitation of decimal types.\nThe write buffer in building the variant value. Its first `writePos` bytes has been written.\nMap keys to a monotonically increasing id.\nStore all keys in `dictionary` in the order of id."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-to-worker/src/main/java/com/iluwatar/servicetoworker/Action.java",
    "type": "method",
    "name": "updateModel",
    "code": "public void updateModel(Command command) {\n    setFatigue(command.fatigue());\n    setHealth(command.health());\n    setNourishment(command.nourishment());\n  }",
    "comment": "Update model based on command.\n\n@param command the command"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/ring/RingInstance.java",
    "type": "method",
    "name": "handleLeaderMessage",
    "code": "protected void handleLeaderMessage(Message message) {\n    var newLeaderId = Integer.valueOf(message.getContent());\n    if (this.leaderId != newLeaderId) {\n      LOGGER.info(INSTANCE + localId + \" - Update leaderID\");\n      this.leaderId = newLeaderId;\n      messageManager.sendLeaderMessage(localId, newLeaderId);\n    } else {\n      LOGGER.info(INSTANCE + localId + \" - Leader update done. Start heartbeat.\");\n      messageManager.sendHeartbeatInvokeMessage(localId);\n    }\n  }",
    "comment": "Process leader Message. The instance will set the leader ID to be the new one and send the\nmessage to the next instance until all the alive instance in the ring is informed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/connector/catalog/functions/JavaLongAdd.java",
    "type": "method",
    "name": "checkInputType",
    "code": "private static void checkInputType(DataType type) {\n    if (!(type instanceof IntegerType || type instanceof LongType ||\n        type instanceof DayTimeIntervalType)) {\n      throw new UnsupportedOperationException(\n          \"Expect one of [IntegerType|LongType|DateTimeIntervalType] but found \" + type);\n    }\n  }",
    "comment": "also allow integer and interval type for testing purpose"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptor.java",
    "type": "method",
    "name": "getArtifactMap",
    "code": "public Map<String, Artifact> getArtifactMap() {\n        if (artifactMap == null) {\n            artifactMap = ArtifactUtils.artifactMapByVersionlessId(getArtifacts());\n        }\n\n        return artifactMap;\n    }",
    "comment": "The map of artifacts accessible by the versionlessKey, i.e. groupId:artifactId\n\n@return a Map of artifacts, never {@code null}\n@see #getArtifacts()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedProgrammaticExtensionRegistrationTests.java",
    "type": "method",
    "name": "assertAssumptionsAboutDefaultOrderingAlgorithm",
    "code": "static void assertAssumptionsAboutDefaultOrderingAlgorithm() {\n\t\tString fieldName1 = \"extension1\";\n\t\tString fieldName2 = \"extension2\";\n\t\tString fieldName3 = \"extension3\";\n\n\t\tassertThat(fieldName1.hashCode()).isLessThan(fieldName2.hashCode());\n\t\tassertThat(fieldName2.hashCode()).isLessThan(fieldName3.hashCode());\n\t}",
    "comment": "This method basically verifies the implementation of\n{@link java.lang.String#hashCode()} (which needn't really be tested)\nin order to make reasonable assumptions about how fields are sorted\nin {@link org.junit.platform.commons.util.ReflectionUtils#defaultFieldSorter(Field, Field)}.\n\n<p>In other words, this method is just a sanity check for the chosen\nfield names in the test cases used in these tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultDependencyResolverResult.java",
    "type": "method",
    "name": "addPathElement",
    "code": "private void addPathElement(PathType type, Path path) {\n        dispatchedPaths.computeIfAbsent(type, (t) -> new ArrayList<>()).add(path);\n    }",
    "comment": "Adds the given path element to the specified type of path.\n\n@param type the type of path (class-path, module-path, )\n@param path the path element to add"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "hasPrefix",
    "code": "public boolean hasPrefix(UniqueId potentialPrefix) {\n\t\tPreconditions.notNull(potentialPrefix, \"potentialPrefix must not be null\");\n\t\tint size = this.segments.size();\n\t\tint prefixSize = potentialPrefix.segments.size();\n\t\treturn size >= prefixSize && this.segments.subList(0, prefixSize).equals(potentialPrefix.segments);\n\t}",
    "comment": "Determine if the supplied {@code UniqueId} is a prefix for this\n{@code UniqueId}.\n\n@param potentialPrefix the {@code UniqueId} to be checked; never {@code null}\n\n@since 1.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/pool/PoolEntry.java",
    "type": "method",
    "name": "setKeepalive",
    "code": "public void setKeepalive(ScheduledFuture<?> keepalive) {\n      this.keepalive = keepalive;\n   }",
    "comment": "Set the end of life {@link ScheduledFuture}.\n\n@param endOfLife this PoolEntry/Connection's end of life {@link ScheduledFuture}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/builder/src/test/java/com/iluwatar/builder/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/lockable-object/src/main/java/com/iluwatar/lockableobject/domain/Human.java",
    "type": "method",
    "name": "Human",
    "code": "public Human(String name) {\n    super(name);\n    setType(CreatureType.HUMAN);\n    setDamage(CreatureStats.HUMAN_DAMAGE.getValue());\n    setHealth(CreatureStats.HUMAN_HEALTH.getValue());\n  }",
    "comment": "A constructor that initializes the attributes of a human.\n\n@param name as the name of the creature."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/UnsafeShuffleWriter.java",
    "type": "method",
    "name": "updatePeakMemoryUsed",
    "code": "private void updatePeakMemoryUsed() {\n    if (sorter != null) {\n      long mem = sorter.getPeakMemoryUsedBytes();\n      if (mem > peakMemoryUsedBytes) {\n        peakMemoryUsedBytes = mem;\n      }\n    }\n  }",
    "comment": "sorter can be null if this writer is closed"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/NettyUtils.java",
    "type": "method",
    "name": "freeDirectMemory",
    "code": "public static long freeDirectMemory() {\n    return PlatformDependent.maxDirectMemory() - PlatformDependent.usedDirectMemory();\n  }",
    "comment": "Specifies an upper bound on the number of Netty threads that Spark requires by default.\nIn practice, only 2-4 cores should be required to transfer roughly 10 Gb/s, and each core\nthat we use will have an initial overhead of roughly 32 MB of off-heap memory, which comes\nat a premium.\n\nThus, this value should still retain maximum throughput and reduce wasted off-heap memory\nallocation. It can be overridden by setting the number of serverThreads and clientThreads\nmanually in Spark's configuration."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/androidTest/java/com/example/android/observability/persistence/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "initDb",
    "code": "public void initDb() {\n        // using an in-memory database because the information stored here disappears when the\n        // process is killed\n        mDatabase = Room.inMemoryDatabaseBuilder(ApplicationProvider.getApplicationContext(),\n                UsersDatabase.class)\n                // allowing main thread queries, just for testing\n                .allowMainThreadQueries()\n                .build();\n        mDataSource = new LocalUserDataSource(mDatabase.userDao());\n    }",
    "comment": "Integration tests for the {@link LocalUserDataSource} implementation with Room."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/src/graph/ReactorGraph.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n        try {\n            MutableGraph originalGraph = new Parser().read(new File(\"target/graph/reactor-graph.dot\"));\n\n            MutableGraph clusteredGraph = mutGraph(\"G\").setDirected(true);\n            clusteredGraph.graphAttrs().add(GraphAttr.COMPOUND);\n            clusteredGraph.graphAttrs().add(Label.of(\"Reactor Graph\"));\n\n            Map<String, MutableGraph> clusters = new HashMap<>();\n            for (String clusterName : CLUSTER_PATTERNS.keySet()) {\n                String key = \"cluster_\" + clusterName.replaceAll(\"\\\\s+\", \"\");\n                MutableGraph cluster = mutGraph(key).setDirected(true);\n                cluster.graphAttrs().add(Label.of(clusterName));\n                clusters.put(clusterName, cluster);\n                clusteredGraph.add(cluster);\n            }\n\n            Map<String, MutableNode> nodeMap = new HashMap<>();\n            Map<String, String> nodeToCluster = new HashMap<>();\n            Map<String, String> newNames = new HashMap<>();\n\n            for (MutableNode originalNode : originalGraph.nodes()) {\n                String oldNodeName = originalNode.name().toString();\n                if (HIDDEN_NODES.matcher(oldNodeName).matches()) {\n                    continue;\n                }\n                String nodeName = oldNodeName;\n                if (originalNode.get(\"label\") instanceof Label l) {\n                    nodeName = l.value();\n                }\n                MutableNode newNode = mutNode(nodeName);\n                nodeMap.put(nodeName, newNode);\n                newNames.put(oldNodeName, nodeName);\n\n                boolean added = false;\n                for (Map.Entry<String, Pattern> entry : CLUSTER_PATTERNS.entrySet()) {\n                    if (entry.getValue().matcher(oldNodeName).matches()) {\n                        clusters.get(entry.getKey()).add(newNode);\n                        nodeToCluster.put(nodeName, entry.getKey());\n                        added = true;\n                        break;\n                    }\n                }\n\n                if (!added) {\n                    clusteredGraph.add(newNode);\n                }\n            }\n\n            Map<String, MutableNode> substitutes = new HashMap<>();\n            Set<Pair> existingLinks = new HashSet<>();\n            for (MutableNode node : originalGraph.nodes()) {\n                for (Link link : node.links()) {\n                    String sourceName = newNames.get(link.from().name().toString());\n                    String targetName = newNames.get(link.to().name().toString());\n                    String sourceCluster = nodeToCluster.get(sourceName);\n                    String targetCluster = nodeToCluster.get(targetName);\n                    MutableNode sourceNode = nodeMap.get(sourceName);\n                    MutableNode targetNode = nodeMap.get(targetName);\n                    if (sourceNode != null && targetNode != null ) {\n                        if (!Objects.equals(sourceCluster, targetCluster)) {\n                            if (sourceCluster != null) {\n                                sourceName = \"cluster_\" + sourceCluster.replaceAll(\"\\\\s+\", \"\");\n                            }\n                            if (targetCluster != null) {\n                                targetName = \"cluster_\" + targetCluster.replaceAll(\"\\\\s+\", \"\");\n                            }\n                            sourceNode = substitutes.computeIfAbsent(sourceName, n -> createNode(n, clusteredGraph));\n                            targetNode = substitutes.computeIfAbsent(targetName, n -> createNode(n, clusteredGraph));\n                        }\n                        if (existingLinks.add(new Pair(sourceName, targetName))) {\n                    }\n                }\n            }\n\n            String dotContent = Graphviz.fromGraph(clusteredGraph).render(Format.DOT).toString();\n            Files.write(Paths.get(\"target/graph/intermediary_graph.dot\"), dotContent.getBytes());\n            System.out.println(\"Intermediary graph written to intermediary_graph.dot\");\n\n            Graphviz.fromGraph(clusteredGraph)\n                    .engine(Engine.FDP)\n                    .render(Format.SVG).toFile(new File(\"target/graph/intermediary_graph.svg\"));\n            System.out.println(\"Final graph rendered to intermediary_graph.svg\");\n\n            MutableGraph highLevelGraph = generateHighLevelGraph(clusteredGraph, clusters, nodeToCluster, nodeMap);\n\n            String highLevelDotContent = Graphviz.fromGraph(highLevelGraph).render(Format.DOT).toString();\n            Files.write(Paths.get(\"target/graph/high_level_graph.dot\"), highLevelDotContent.getBytes());\n            System.out.println(\"High-level graph written to high_level_graph.dot\");\n\n            Graphviz.fromGraph(highLevelGraph)\n                    .engine(Engine.DOT)\n                    .render(Format.SVG).toFile(new File(\"target/site/images/maven-deps.svg\"));\n            System.out.println(\"High-level graph rendered to high_level_graph.svg\");\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static MutableGraph generateHighLevelGraph(MutableGraph clusteredGraph, Map<String, MutableGraph> clusters,\n                                                       Map<String, String> nodeToCluster, Map<String, MutableNode> nodeMap) {\n        MutableGraph highLevelGraph = mutGraph(\"HighLevelGraph\").setDirected(true);\n        highLevelGraph.graphAttrs().add(GraphAttr.COMPOUND);\n        highLevelGraph.graphAttrs().add(Label.of(\"High-Level Reactor Graph\"));\n\n        Map<String, MutableNode> highLevelNodes = new HashMap<>();\n\n        for (Map.Entry<String, MutableGraph> entry : clusters.entrySet()) {\n            String key = entry.getKey();\n            String clusterName = key.replaceAll(\"\\\\s+\", \"\");\n            MutableGraph cluster = entry.getValue();\n\n            String headerColor = clusterName.startsWith(\"Maven\") ? \"black\" : \"#808080\";  // #808080 is a middle gray\n            StringBuilder labelBuilder = new StringBuilder();\n            labelBuilder.append(\"<table border='0' cellborder='0' cellspacing='0'>\");\n            labelBuilder.append(\"<tr><td bgcolor='\")\n                    .append(headerColor)\n                    .append(\"'><font color='white'>\")\n                    .append(key)\n                    .append(\"</font></td></tr>\");\n            cluster.nodes().stream().map(MutableNode::name).map(Label::toString).sorted()\n                    .forEach(nodeName -> {\n                        labelBuilder.append(\"<tr>\");\n                        String prefix = null;\n                        switch (clusterName) {\n                            case \"MavenAPI\": prefix = \"../api/\"; break;\n                            case \"MavenImplementation\": prefix = \"../maven-impl-modules/\"; break;\n                            case \"MavenCompatibility\": prefix = \"../maven-compat-modules/\"; break;\n                            case \"MavenResolver\": prefix = \"https://maven.apache.org/resolver/\"; break;\n                        }\n                        if (prefix != null) {\n                            labelBuilder.append(\"<td\")\n                                    .append(\" href=\\\"\")\n                                    .append(prefix)\n                                    .append(nodeName)\n                                    .append(\"\\\"\")\n                                    .append(\" title=\\\"\")\n                                    .append(nodeName)\n                                    .append(\"\\\"\")\n                                    .append(\" target=\\\"_parent\\\"\")\n                                    .append(\">\")\n                                    .append(nodeName)\n                                    .append(\"</td>\");\n                        } else {\n                            labelBuilder.append(\"<td>\").append(nodeName).append(\"</td>\");\n                        }\n                        labelBuilder.append(\"</tr>\");\n                    });\n            labelBuilder.append(\"</table>\");\n\n            MutableNode clusterNode = mutNode(clusterName).add(Label.html(labelBuilder.toString()))\n                    .add(\"shape\", \"rectangle\");\n            highLevelNodes.put(clusterName, clusterNode);\n            highLevelGraph.add(clusterNode);\n        }\n\n        for (MutableNode node : clusteredGraph.nodes()) {\n            String nodeName = node.name().toString();\n            if (!nodeToCluster.containsKey(nodeName) && !nodeName.startsWith(\"cluster_\")) {\n                throw new IllegalStateException(\"All nodes should be in a cluster: \" + node.name());\n            }\n        }\n\n        Set<Pair> existingLinks = new HashSet<>();\n        for (MutableNode node : clusteredGraph.nodes()) {\n            String sourceName = node.name().toString().replace(\"cluster_\", \"\");\n            String sourceCluster = nodeToCluster.getOrDefault(sourceName, sourceName);\n\n            for (Link link : node.links()) {\n                String targetName = link.to().name().toString().replace(\"cluster_\", \"\");\n                String targetCluster = nodeToCluster.getOrDefault(targetName, targetName);\n\n                Pair linkPair = new Pair(sourceCluster, targetCluster);\n                if (existingLinks.add(linkPair)) {\n                    MutableNode sourceNode = highLevelNodes.get(sourceCluster);\n                    MutableNode targetNode = highLevelNodes.get(targetCluster);\n                    if (sourceNode != null && targetNode != null && sourceNode != targetNode) {\n                        sourceNode.addLink(targetNode);\n                    }\n                }\n            }\n        }\n\n        return highLevelGraph;\n    }\n\n    private static MutableNode createNode(String n, MutableGraph clusteredGraph) {\n        MutableNode t = mutNode(n);\n        clusteredGraph.add(t);\n        return t;\n    }\n\n    record Pair(String from, String to) {};\n}",
    "comment": "usr/bin/env jbang \"$0\" \"$@\" ; exit $?\nJAVA 14+\nDEPS guru.nidi:graphviz-java:0.18.1\nParse DOT file\nCreate final graph\nCreate clusters\nMap to store new nodes by node name\nFirst pass: Create nodes and organize them into clusters\nSecond pass: Add links to the clustered graph\nInter-cluster link\nWrite intermediary graph to DOT file\nRender graph to SVF\nGenerate and render the high-level graph\nWrite high-level graph to DOT file\nRender high-level graph to SVG\nCreate nodes for each cluster\nAdd individual nodes for unclustered nodes\nAdd edges"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/EngineDiscoveryResult.java",
    "type": "method",
    "name": "successful",
    "code": "public static EngineDiscoveryResult successful() {\n\t\treturn SUCCESSFUL_RESULT;\n\t}",
    "comment": "Create a {@code EngineDiscoveryResult} for a <em>successful</em> test\ndiscovery.\n@return the {@code EngineDiscoveryResult}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedColumnReader.java",
    "type": "method",
    "name": "getValuesReader",
    "code": "private ValuesReader getValuesReader(Encoding encoding) {\n    return switch (encoding) {\n      case PLAIN -> new VectorizedPlainValuesReader();\n      case DELTA_BYTE_ARRAY -> new VectorizedDeltaByteArrayReader();\n      case DELTA_LENGTH_BYTE_ARRAY -> new VectorizedDeltaLengthByteArrayReader();\n      case DELTA_BINARY_PACKED -> new VectorizedDeltaBinaryPackedReader();\n      case RLE -> {\n        PrimitiveType.PrimitiveTypeName typeName =\n          this.descriptor.getPrimitiveType().getPrimitiveTypeName();\n        if (typeName == BOOLEAN) {\n          yield new VectorizedRleValuesReader(1);\n        } else {\n          throw new SparkUnsupportedOperationException(\n            \"_LEGACY_ERROR_TEMP_3190\", Map.of(\"typeName\", typeName.toString()));\n        }\n      }\n      default ->\n        throw new SparkUnsupportedOperationException(\n          \"_LEGACY_ERROR_TEMP_3189\", Map.of(\"encoding\", encoding.toString()));\n    };\n  }",
    "comment": "RLE encoding only supports boolean type `Values`, and  `bitwidth` is always 1."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/SavedModelBundle.java",
    "type": "method",
    "name": "withTags",
    "code": "public Loader withTags(String... tags) {\n      this.tags = tags;\n      return this;\n    }",
    "comment": "Sets the set of tags that identify the specific graph in the saved model to load.\n\n@param tags the tags identifying the specific MetaGraphDef to load."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "mergeHi",
    "code": "private void mergeHi(int base1, int len1, int base2, int len2) {\n      assert len1 > 0 && len2 > 0 && base1 + len1 == base2;\n\n      // Copy second run into temp array\n      Buffer a = this.a; // For performance\n      Buffer tmp = ensureCapacity(len2);\n      s.copyRange(a, base2, tmp, 0, len2);\n\n      int cursor1 = base1 + len1 - 1;  // Indexes into a\n      int cursor2 = len2 - 1;          // Indexes into tmp array\n      int dest = base2 + len2 - 1;     // Indexes into a\n\n      K key0 = s.newKey();\n      K key1 = s.newKey();\n\n      // Move last element of first run and deal with degenerate cases\n      s.copyElement(a, cursor1--, a, dest--);\n      if (--len1 == 0) {\n        s.copyRange(tmp, 0, a, dest - (len2 - 1), len2);\n        return;\n      }\n      if (len2 == 1) {\n        dest -= len1;\n        cursor1 -= len1;\n        s.copyRange(a, cursor1 + 1, a, dest + 1, len1);\n        s.copyElement(tmp, cursor2, a, dest);\n        return;\n      }\n\n      Comparator<? super K> c = this.c;  // Use local variable for performance\n      int minGallop = this.minGallop;    //  \"    \"       \"     \"      \"\n      outer:\n      while (true) {\n        int count1 = 0; // Number of times in a row that first run won\n        int count2 = 0; // Number of times in a row that second run won\n\n        /*\n         * Do the straightforward thing until (if ever) one run\n         * appears to win consistently.\n         */\n        do {\n          assert len1 > 0 && len2 > 1;\n          if (c.compare(s.getKey(tmp, cursor2, key0), s.getKey(a, cursor1, key1)) < 0) {\n            s.copyElement(a, cursor1--, a, dest--);\n            count1++;\n            count2 = 0;\n            if (--len1 == 0)\n              break outer;\n          } else {\n            s.copyElement(tmp, cursor2--, a, dest--);\n            count2++;\n            count1 = 0;\n            if (--len2 == 1)\n              break outer;\n          }\n        } while ((count1 | count2) < minGallop);\n\n        /*\n         * One run is winning so consistently that galloping may be a\n         * huge win. So try that, and continue galloping until (if ever)\n         * neither run appears to be winning consistently anymore.\n         */\n        do {\n          assert len1 > 0 && len2 > 1;\n          count1 = len1 - gallopRight(s.getKey(tmp, cursor2, key0), a, base1, len1, len1 - 1, c);\n          if (count1 != 0) {\n            dest -= count1;\n            cursor1 -= count1;\n            len1 -= count1;\n            s.copyRange(a, cursor1 + 1, a, dest + 1, count1);\n            if (len1 == 0)\n              break outer;\n          }\n          s.copyElement(tmp, cursor2--, a, dest--);\n          if (--len2 == 1)\n            break outer;\n\n          count2 = len2 - gallopLeft(s.getKey(a, cursor1, key0), tmp, 0, len2, len2 - 1, c);\n          if (count2 != 0) {\n            dest -= count2;\n            cursor2 -= count2;\n            len2 -= count2;\n            s.copyRange(tmp, cursor2 + 1, a, dest + 1, count2);\n            if (len2 <= 1)  // len2 == 1 || len2 == 0\n              break outer;\n          }\n          s.copyElement(a, cursor1--, a, dest--);\n          if (--len1 == 0)\n            break outer;\n          minGallop--;\n        } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);\n        if (minGallop < 0)\n          minGallop = 0;\n        minGallop += 2;  // Penalize for leaving gallop mode\n      }  // End of \"outer\" loop\n      this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field\n\n      if (len2 == 1) {\n        assert len1 > 0;\n        dest -= len1;\n        cursor1 -= len1;\n        s.copyRange(a, cursor1 + 1, a, dest + 1, len1);\n        s.copyElement(tmp, cursor2, a, dest); // Move first elt of run2 to front of merge\n      } else if (len2 == 0) {\n        throw new IllegalArgumentException(\n            \"Comparison method violates its general contract!\");\n      } else {\n        assert len1 == 0;\n        assert len2 > 0;\n        s.copyRange(tmp, 0, a, dest - (len2 - 1), len2);\n      }\n    }",
    "comment": "Like mergeLo, except that this method should be called only if\nlen1 >= len2; mergeLo should be called if len1 <= len2.  (Either method\nmay be called if len1 == len2.)\n\n@param base1 index of first element in first run to be merged\n@param len1  length of first run to be merged (must be > 0)\n@param base2 index of first element in second run to be merged\n(must be aBase + aLen)\n@param len2  length of second run to be merged (must be > 0)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaDataFrameSuite.java",
    "type": "method",
    "name": "validateDataFrameWithBeans",
    "code": "void validateDataFrameWithBeans(Bean bean, Dataset<Row> df) {\n    StructType schema = df.schema();\n    Assertions.assertEquals(new StructField(\"a\", DoubleType$.MODULE$, false, Metadata.empty()),\n      schema.apply(\"a\"));\n    Assertions.assertEquals(\n      new StructField(\"b\", new ArrayType(IntegerType$.MODULE$, true), true, Metadata.empty()),\n      schema.apply(\"b\"));\n    ArrayType valueType = new ArrayType(DataTypes.IntegerType, false);\n    MapType mapType = new MapType(DataTypes.StringType, valueType, true);\n    Assertions.assertEquals(\n      new StructField(\"c\", mapType, true, Metadata.empty()),\n      schema.apply(\"c\"));\n    Assertions.assertEquals(\n      new StructField(\"d\", new ArrayType(DataTypes.StringType, true), true, Metadata.empty()),\n      schema.apply(\"d\"));\n    Assertions.assertEquals(new StructField(\"e\", DataTypes.createDecimalType(38,0), true,\n      Metadata.empty()), schema.apply(\"e\"));\n    StructType nestedBeanType =\n      DataTypes.createStructType(Collections.singletonList(new StructField(\n        \"a\", IntegerType$.MODULE$, false, Metadata.empty())));\n    Assertions.assertEquals(new StructField(\"f\", nestedBeanType, true, Metadata.empty()),\n      schema.apply(\"f\"));\n    Assertions.assertEquals(new StructField(\"g\", nestedBeanType, true, Metadata.empty()),\n      schema.apply(\"g\"));\n    Row first = df.select(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\").first();\n    Assertions.assertEquals(bean.getA(), first.getDouble(0), 0.0);\n    Seq<Integer> result = first.getAs(1);\n    Assertions.assertEquals(bean.getB().length, result.length());\n    for (int i = 0; i < result.length(); i++) {\n      Assertions.assertEquals(bean.getB()[i], result.apply(i));\n    }\n    @SuppressWarnings(\"unchecked\")\n    Seq<Integer> outputBuffer = (Seq<Integer>) first.getJavaMap(2).get(\"hello\");\n    Assertions.assertArrayEquals(\n      bean.getC().get(\"hello\"),\n      Ints.toArray(CollectionConverters.asJava(outputBuffer)));\n    Seq<String> d = first.getAs(3);\n    Assertions.assertEquals(bean.getD().size(), d.length());\n    for (int i = 0; i < d.length(); i++) {\n      Assertions.assertEquals(bean.getD().get(i), d.apply(i));\n    }\n    Assertions.assertEquals(new BigDecimal(bean.getE()), first.getDecimal(4));\n    Row nested = first.getStruct(5);\n    Assertions.assertEquals(bean.getF().getA(), nested.getInt(0));\n    Assertions.assertTrue(first.isNullAt(6));\n  }",
    "comment": "Now Java lists and maps are converted to Scala Seq's and Map's. Once we get a Seq below,\nverify that it has the expected length, and contains expected elements.\nJava.math.BigInteger is equivalent to Spark Decimal(38,0)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-repository-metadata/src/test/java/org/apache/maven/artifact/repository/metadata/MetadataTest.java",
    "type": "method",
    "name": "mergeWithSameSnapshotWithSameVersionAndTimestamp",
    "code": "void mergeWithSameSnapshotWithSameVersionAndTimestamp() {\n        Metadata source = createMetadataFromArtifact(artifact);\n        Date date = new Date();\n        addSnapshotVersion(target.getVersioning(), date, artifact);\n        SnapshotVersion sv1 = addSnapshotVersion(source.getVersioning(), date, artifact);\n        assertTrue(target.merge(source));\n        assertEquals(1, target.getVersioning().getSnapshotVersions().size());\n        assertEquals(sv1, target.getVersioning().getSnapshotVersions().get(0));\n        assertEquals(formatDate(date, false), target.getVersioning().getLastUpdated());\n        assertEquals(\n                formatDate(date, true), target.getVersioning().getSnapshot().getTimestamp());\n    }",
    "comment": "although nothing has changed merge returns true, as the last modified date is equal\nTODO: improve merge here?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterApi.java",
    "type": "method",
    "name": "setNumThreads",
    "code": "public Options setNumThreads(int numThreads) {\n      this.numThreads = numThreads;\n      return this;\n    }",
    "comment": "Sets the number of threads to be used for ops that support multi-threading.\n\n<p>{@code numThreads} should be {@code >= -1}. Setting {@code numThreads} to 0 has the effect\nof disabling multithreading, which is equivalent to setting {@code numThreads} to 1. If\nunspecified, or set to the value -1, the number of threads used will be\nimplementation-defined and platform-dependent."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-jfr/src/main/java/org/junit/platform/jfr/FlightRecordingDiscoveryListener.java",
    "type": "method",
    "name": "launcherDiscoveryStarted",
    "code": "public void launcherDiscoveryStarted(LauncherDiscoveryRequest request) {\n\t\tLauncherDiscoveryEvent event = new LauncherDiscoveryEvent();\n\t\tevent.selectors = request.getSelectorsByType(DiscoverySelector.class).size();\n\t\tevent.filters = request.getFiltersByType(DiscoveryFilter.class).size();\n\t\tevent.begin();\n\t\tlauncherDiscoveryEvent.set(event);\n\t}",
    "comment": "A {@link LauncherDiscoveryListener} that generates Java Flight Recorder\nevents.\n\n@since 1.8\n@see <a href=\"https://openjdk.java.net/jeps/328\">JEP 328: Flight Recorder</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "compareLowerCase",
    "code": "public static int compareLowerCase(final UTF8String left, final UTF8String right) {\n    // Only if both strings are ASCII, we can use faster comparison (no string allocations).\n    if (left.isFullAscii() && right.isFullAscii()) {\n      return compareLowerCaseAscii(left, right);\n    }\n    return compareLowerCaseSlow(left, right);\n  }",
    "comment": "Lowercase UTF8String comparison used for UTF8_LCASE collation. This method uses lowercased\ncode points to compare the strings in a case-insensitive manner using ICU rules, taking into\naccount special rules for one-to-many case mappings (see: lowerCaseCodePoints).\n\n@param left The first UTF8String to compare.\n@param right The second UTF8String to compare.\n@return An integer representing the comparison result."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/LevelDBTypeInfo.java",
    "type": "method",
    "name": "checkParent",
    "code": "private void checkParent(byte[] prefix) {\n      if (prefix != null) {\n        Preconditions.checkState(parent != null, \"Parent prefix provided for parent index.\");\n      } else {\n        Preconditions.checkState(parent == null, \"Parent prefix missing for child index.\");\n      }\n    }",
    "comment": "Gets the index value for a particular entity (which is the value of the field or method\ntagged with the index annotation). This is used as part of the LevelDB key where the\nentity (or its id) is stored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "toLowerCaseSlow",
    "code": "private static UTF8String toLowerCaseSlow(final UTF8String target) {\n    return UTF8String.fromString(UCharacter.toLowerCase(target.toValidString()));\n  }",
    "comment": "Note: In order to achieve the desired behavior, we use the ICU UCharacter class to\nconvert the string to lowercase, which only accepts a Java strings as input."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkSubmitCommandBuilder.java",
    "type": "method",
    "name": "isClientMode",
    "code": "boolean isClientMode(Map<String, String> userProps) {\n    String userMaster = firstNonEmpty(master, userProps.get(SparkLauncher.SPARK_MASTER));\n    String userDeployMode = firstNonEmpty(deployMode, userProps.get(SparkLauncher.DEPLOY_MODE));\n    return userMaster == null || userDeployMode == null || \"client\".equals(userDeployMode);\n  }",
    "comment": "Default master is \"local[*]\", so assume client mode in that case"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/streaming/JavaRecoverableNetworkWordCount.java",
    "type": "method",
    "name": "getInstance",
    "code": "public static LongAccumulator getInstance(JavaSparkContext jsc) {\n    if (instance == null) {\n      synchronized (JavaDroppedWordsCounter.class) {\n        if (instance == null) {\n          instance = jsc.sc().longAccumulator(\"DroppedWordsCounter\");\n        }\n      }\n    }\n    return instance;\n  }",
    "comment": "Use this singleton to get or register an Accumulator."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/repository/MavenArtifactRepository.java",
    "type": "method",
    "name": "basedir",
    "code": "private String basedir(String url) {\n        String retValue = null;\n\n        if (protocol.equalsIgnoreCase(\"file\")) {\n            retValue = url.substring(protocol.length() + 1);\n            retValue = decode(retValue);\n            // special case: if omitted // on protocol, keep path as is\n            if (retValue.startsWith(\"//\")) {\n                retValue = retValue.substring(2);\n\n                if (retValue.length() >= 2 && (retValue.charAt(1) == '|' || retValue.charAt(1) == ':')) {\n                    // special case: if there is a windows drive letter, then keep the original return value\n                    retValue = retValue.charAt(0) + \":\" + retValue.substring(2);\n                } else {\n                    // Now we expect the host\n                    int index = retValue.indexOf('/');\n                    if (index >= 0) {\n                        retValue = retValue.substring(index + 1);\n                    }\n\n                    // special case: if there is a windows drive letter, then keep the original return value\n                    if (retValue.length() >= 2 && (retValue.charAt(1) == '|' || retValue.charAt(1) == ':')) {\n                        retValue = retValue.charAt(0) + \":\" + retValue.substring(2);\n                    } else if (index >= 0) {\n                        // leading / was previously stripped\n                        retValue = \"/\" + retValue;\n                    }\n                }\n            }\n\n            // special case: if there is a windows drive letter using |, switch to :\n            if (retValue.length() >= 2 && retValue.charAt(1) == '|') {\n                retValue = retValue.charAt(0) + \":\" + retValue.substring(2);\n            }\n\n            // normalize separators\n            retValue = new File(retValue).getPath();\n        }\n\n        if (retValue == null) {\n            retValue = \"/\";\n        }\n        return retValue.trim();\n    }",
    "comment": "Derive the path portion of the given URL.\n\n@param url the repository URL\n@return the basedir of the repository\nTODO need to URL decode for spaces?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "equals",
    "code": "public boolean equals(Object o) {\n            if (o instanceof Record record) {\n                return Objects.equals(usedActiveProfiles, record.usedActiveProfiles)\n                        && Objects.equals(usedInactiveProfiles, record.usedInactiveProfiles)\n                        && Objects.equals(usedSystemProperties, record.usedSystemProperties)\n                        && Objects.equals(usedUserProperties, record.usedUserProperties)\n                        && Objects.equals(usedModelProperties, record.usedModelProperties)\n                        && Objects.equals(usedModelInfos, record.usedModelInfos)\n                        && Objects.equals(usedExists, record.usedExists);\n            }\n            return false;\n        }",
    "comment": "This class keeps track of information that are used during profile activation.\nThis allows to cache the activated parent and check if the result of the\nactivation will be the same by verifying that the used keys are the same."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RetryingBlockTransferor.java",
    "type": "method",
    "name": "shouldRetry",
    "code": "private synchronized boolean shouldRetry(Throwable e) {\n    boolean isIOException = e instanceof IOException\n      || e.getCause() instanceof IOException;\n    boolean isSaslTimeout = enableSaslRetries && e instanceof SaslTimeoutException;\n    // If this is a non SASL request failure, reduce earlier SASL failures from retryCount\n    // since some subsequent SASL attempt was successful\n    if (!isSaslTimeout && saslRetryCount > 0) {\n      Preconditions.checkState(retryCount >= saslRetryCount,\n        \"retryCount must be greater than or equal to saslRetryCount\");\n      retryCount -= saslRetryCount;\n      saslRetryCount = 0;\n    }\n    boolean hasRemainingRetries = retryCount < maxRetries;\n    boolean shouldRetry =  (isSaslTimeout || isIOException) &&\n        hasRemainingRetries && errorHandler.shouldRetryError(e);\n    return shouldRetry;\n  }",
    "comment": "Returns true if we should retry due a block transfer failure. We will retry if and only if\nthe exception was an IOException or SaslTimeoutException and we haven't retried\n'maxRetries' times already."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "update",
    "code": "public boolean update(MavenProperties properties) {\n        boolean modified = false;\n        for (String key : new ArrayList<String>(this.keySet())) {\n        }\n        for (String key : properties.keySet()) {\n            String v = this.get(key);\n            List<String> comments = properties.getComments(key);\n            List<String> value = properties.getRaw(key);\n            if (v == null) {\n                this.put(key, comments, value);\n                modified = true;\n            } else if (!v.equals(properties.get(key))) {\n                if (comments.isEmpty()) {\n                    comments = this.getComments(key);\n                }\n                this.put(key, comments, value);\n                modified = true;\n            }\n        }\n        return modified;\n    }",
    "comment": "Remove \"removed\" properties from the cfg file\nUpdate existing keys"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(float unexpected, Float actual, String message) {\n\t\tAssertNotEquals.assertNotEquals((Float) unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/MetadataGraph.java",
    "type": "method",
    "name": "findNode",
    "code": "public MetadataGraphNode findNode(MavenArtifactMetadata md) {\n        for (MetadataGraphNode mgn : nodes) {\n            if (mgn.metadata.equals(md)) {\n                return mgn;\n            }\n        }\n\n        MetadataGraphNode node = new MetadataGraphNode(md);\n        addNode(node);\n        return node;\n    }",
    "comment": "find a node by the GAV (metadata)\n\n@param md"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/main/java/com/iluwatar/health/check/CustomHealthIndicator.java",
    "type": "method",
    "name": "check",
    "code": "private Health check() {\n    Integer result = healthCheckRepository.checkHealth();\n    boolean databaseIsUp = result != null && result == 1;\n    LOGGER.info(\"Health check result: {}\", databaseIsUp);\n    return databaseIsUp\n        ? Health.up().withDetail(\"database\", \"reachable\").build()\n        : Health.down().withDetail(\"database\", \"unreachable\").build();\n  }",
    "comment": "Checks the health of the database by querying for a simple constant value expected from the\ndatabase.\n\n@return Health indicating UP if the database returns the constant correctly, otherwise DOWN."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/CryptoUtils.java",
    "type": "method",
    "name": "toCryptoConf",
    "code": "public static Properties toCryptoConf(String prefix, Iterable<Map.Entry<String, String>> conf) {\n    Properties props = new Properties();\n    for (Map.Entry<String, String> e : conf) {\n      String key = e.getKey();\n      if (key.startsWith(prefix)) {\n        props.setProperty(COMMONS_CRYPTO_CONFIG_PREFIX + key.substring(prefix.length()),\n          e.getValue());\n      }\n    }\n    return props;\n  }",
    "comment": "Extract the commons-crypto configuration embedded in a list of config values.\n\n@param prefix Prefix in the given configuration that identifies the commons-crypto configs.\n@param conf List of configuration values."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/LruCache.java",
    "type": "method",
    "name": "contains",
    "code": "public boolean contains(final String userId) {\n    return cache.containsKey(userId);\n  }",
    "comment": "Check if Cache contains the userId.\n\n@param userId {@link String}\n@return boolean"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/DoublePrecisionAssertTest.java",
    "type": "method",
    "name": "testAssertEqualsNaNFails",
    "code": "public void testAssertEqualsNaNFails() {\n        try {\n            assertEquals(1.234, Double.NaN, 0.0);\n        } catch (AssertionFailedError e) {\n            return;\n        }\n        fail();\n    }",
    "comment": "Test for the special Double.NaN value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeExternalSorter.java",
    "type": "method",
    "name": "deleteSpillFiles",
    "code": "private void deleteSpillFiles() {\n    for (UnsafeSorterSpillWriter spill : spillWriters) {\n      File file = spill.getFile();\n      if (file != null && file.exists()) {\n        if (!file.delete()) {\n          logger.error(\"Was unable to delete spill file {}\",\n            MDC.of(LogKeys.PATH$.MODULE$, file.getAbsolutePath()));\n        }\n      }\n    }\n  }",
    "comment": "Deletes any spill files created by this sorter."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/BlockFetchingListener.java",
    "type": "method",
    "name": "onBlockTransferSuccess",
    "code": "default void onBlockTransferSuccess(String blockId, ManagedBuffer data) {\n    onBlockFetchSuccess(blockId, data);\n  }",
    "comment": "Called at least once per block upon failures."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isFinal",
    "code": "public static boolean isFinal(Class<?> clazz) {\n\t\treturn ReflectionUtils.isFinal(clazz);\n\t}",
    "comment": "Determine if the supplied class is {@code final}.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is {@code final}\n@since 1.5\n@see java.lang.reflect.Modifier#isFinal(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/Graph.java",
    "type": "method",
    "name": "if",
    "code": "LinkedList<String> cycle) {\n        if (children != null) {\n            for (String v : children) {\n                DfsState state = stateMap.putIfAbsent(v, DfsState.VISITING);\n                if (state == null) {\n                    cycle.addLast(v);\n                    List<String> ret = visitCycle(graph, graph.get(v), stateMap, cycle);\n                    if (ret != null) {\n                        return ret;\n                    }\n                    cycle.removeLast();\n                    stateMap.put(v, DfsState.VISITED);\n                } else if (state == DfsState.VISITING) {\n                    int pos = cycle.lastIndexOf(v);\n                    List<String> ret = cycle.subList(pos, cycle.size());\n                    ret.add(v);\n                    return ret;\n                }\n            }\n        }\n        return null;\n    }",
    "comment": "we are already visiting this vertex, this mean we have a cycle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/test/java/org/tensorflow/lite/TestInit.java",
    "type": "method",
    "name": "init",
    "code": "public static void init() {\n    if (!initialized) {\n      try {\n        System.loadLibrary(\"tensorflowlite_test_jni\");\n        logger.info(\"Loaded native library for tests: tensorflowlite_test_jni\");\n      } catch (UnsatisfiedLinkError e) {\n        logger.info(\"Didn't load native library for tests: tensorflowlite_test_jni\");\n        try {\n          System.loadLibrary(\"tensorflowlite_stable_test_jni\");\n          logger.info(\"Loaded native library for tests: tensorflowlite_stable_test_jni\");\n        } catch (UnsatisfiedLinkError e2) {\n          logger.info(\"Didn't load native library for tests: tensorflowlite_stable_test_jni\");\n        }\n      }\n      initTfLiteForTest();\n      initialized = true;\n    }\n  }",
    "comment": "Initialize TF Lite for tests. In tests, this should be called before executing any native code\nthat uses TF Lite. It may, for example, dynamically load the TF Lite library."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ModuleUtils.java",
    "type": "method",
    "name": "isJavaPlatformModuleSystemAvailable",
    "code": "public static boolean isJavaPlatformModuleSystemAvailable() {\n\t\treturn false;\n\t}",
    "comment": "Determine if the current Java runtime supports the Java Platform Module System.\n\n@return {@code true} if the Java Platform Module System is available,\notherwise {@code false}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/Platform.java",
    "type": "method",
    "name": "allocateDirectBuffer",
    "code": "public static ByteBuffer allocateDirectBuffer(int size) {\n    try {\n      if (CLEANER_CREATE_METHOD == null) {\n        // Can't set a Cleaner (see comments on field), so need to allocate via normal Java APIs\n        try {\n          return ByteBuffer.allocateDirect(size);\n        } catch (OutOfMemoryError oome) {\n          // checkstyle.off: RegexpSinglelineJava\n          throw new OutOfMemoryError(\"Failed to allocate direct buffer (\" + oome.getMessage() +\n              \"); try increasing -XX:MaxDirectMemorySize=... to, for example, your heap size\");\n          // checkstyle.on: RegexpSinglelineJava\n        }\n      }\n      // Otherwise, use internal JDK APIs to allocate a DirectByteBuffer while ignoring the JVM's\n      // MaxDirectMemorySize limit (the default limit is too low and we do not want to\n      // require users to increase it).\n      long memory = allocateMemory(size);\n      ByteBuffer buffer = (ByteBuffer) DBB_CONSTRUCTOR.newInstance(memory, size);\n      try {\n        DBB_CLEANER_FIELD.set(buffer,\n            CLEANER_CREATE_METHOD.invoke(null, buffer, (Runnable) () -> freeMemory(memory)));\n      } catch (IllegalAccessException | InvocationTargetException e) {\n        freeMemory(memory);\n        throw new IllegalStateException(e);\n      }\n      return buffer;\n    } catch (Exception e) {\n      throwException(e);\n    }\n    throw new IllegalStateException(\"unreachable\");\n  }",
    "comment": "Allocate a DirectByteBuffer, potentially bypassing the JVM's MaxDirectMemorySize limit."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/PackageNameFilter.java",
    "type": "method",
    "name": "excludePackageNames",
    "code": "static PackageNameFilter excludePackageNames(List<String> names) {\n\t\treturn excludePackageNames(names.toArray(new String[0]));\n\t}",
    "comment": "Create a new <em>exclude</em> {@link PackageNameFilter} based on the\n@see Package#getName()\n@see #excludePackageNames(String...)\n@see #includePackageNames(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "fullyQualifiedName",
    "code": "public static String fullyQualifiedName(int collationId) {\n    if (collationId == INDETERMINATE_COLLATION_ID) {\n      return Collation.CollationSpec.INDETERMINATE_COLLATION.collationName;\n    }\n\n    Collation.CollationSpec.DefinitionOrigin definitionOrigin =\n        Collation.CollationSpec.getDefinitionOrigin(collationId);\n    // Currently only predefined collations are supported.\n    assert definitionOrigin == Collation.CollationSpec.DefinitionOrigin.PREDEFINED;\n    return String.format(\"%s.%s.%s\", CATALOG, SCHEMA,\n      Collation.CollationSpec.fetchCollation(collationId).collationName);\n  }",
    "comment": "Returns the fully qualified collation name for the given collation ID."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(char expected, char actual) {\n        Assert.assertEquals(expected, actual);\n    }",
    "comment": "Asserts that two chars are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java",
    "type": "method",
    "name": "parameterTypesAsString",
    "code": "static String parameterTypesAsString(Method method) {\n\t\tPreconditions.notNull(method, \"Method must not be null\");\n\t\treturn '(' + ClassUtils.nullSafeToString(Class::getSimpleName, method.getParameterTypes()) + ')';\n\t}",
    "comment": "Generate a string representation of the formal parameters of the supplied\nmethod, consisting of the {@linkplain Class#getSimpleName() simple names}\nof the parameter types, separated by commas, and enclosed in parentheses.\n\n@param method the method from to extract the parameter types from; never\n{@code null}\n@return a string representation of all parameter types of the supplied\nmethod or {@code \"()\"} if the method declares no parameters"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/main/java/com/iluwatar/async/method/invocation/App.java",
    "type": "method",
    "name": "callback",
    "code": "private static <T> AsyncCallback<T> callback(String name) {\n    return new AsyncCallback<>() {\n\n      @Override\n      public void onError(Exception ex) {\n        log(name + \" failed: \" + ex.getMessage());\n      }\n    };\n  }",
    "comment": "Creates a simple callback that logs the complete status of the async result.\n\n@param name callback name\n@return new async callback"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClasspathResourceSource.java",
    "type": "method",
    "name": "from",
    "code": "public static ClasspathResourceSource from(String classpathResourceName) {\n\t\treturn new ClasspathResourceSource(classpathResourceName);\n\t}",
    "comment": "Create a new {@code ClasspathResourceSource} using the supplied classpath\n\n<p>If the supplied classpath resource name is prefixed with a slash\n({@code /}), the slash will be removed.\n\n@param classpathResourceName the name of the classpath resource; never\n{@code null} or blank\n@see ClassLoader#getResource(String)\n@see ClassLoader#getResourceAsStream(String)\n@see ClassLoader#getResources(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/ByteArray.java",
    "type": "method",
    "name": "getPrefix",
    "code": "static long getPrefix(Object base, long offset, int numBytes) {\n    final long p;\n    final long mask;\n    if (numBytes >= 8) {\n      p = Platform.getLong(base, offset);\n      mask = 0;\n    } else if (numBytes > 4) {\n      p = Platform.getLong(base, offset);\n      mask = (1L << (8 - numBytes) * 8) - 1;\n    } else if (numBytes > 0) {\n      long pRaw = Platform.getInt(base, offset);\n      p = IS_LITTLE_ENDIAN ? pRaw : (pRaw << 32);\n      mask = (1L << (8 - numBytes) * 8) - 1;\n    } else {\n      p = 0;\n      mask = 0;\n    }\n    return (IS_LITTLE_ENDIAN ? java.lang.Long.reverseBytes(p) : p) & ~mask;\n  }",
    "comment": "Since JVMs are either 4-byte aligned or 8-byte aligned, we check the size of the bytes.\nIf size is 0, just return 0.\nIf size is between 1 and 4 (inclusive), assume data is 4-byte aligned under the hood and\nuse a getInt to fetch the prefix.\nIf size is greater than 4, assume we have at least 8 bytes of data to fetch.\nAfter getting the data, we use a mask to mask out data that is not part of the bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "debug",
    "code": "public Events debug(Writer writer) {\n\t\tPreconditions.notNull(writer, \"Writer must not be null\");\n\t\tdebug(new PrintWriter(writer, true));\n\t\treturn this;\n\t}",
    "comment": "Print all events to the supplied {@link Writer}.\n\n@param writer the {@code Writer} to print to; never {@code null}\n@return this {@code Events} object for method chaining; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "createTestDescription",
    "code": "public static Description createTestDescription(Class<?> clazz, String name) {\n        return new Description(clazz, formatDisplayName(name, clazz.getName()));\n    }",
    "comment": "Create a <code>Description</code> of a single test named <code>name</code> in the class <code>clazz</code>.\nGenerally, this will be a leaf <code>Description</code>.\n(This remains for binary compatibility with clients of JUnit 4.3)\n\n@param clazz the class of the test\n@param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n@return a <code>Description</code> named <code>name</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/entity/Car.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n    return \"Car{\" + super.toString() + '}';\n  }",
    "comment": "Overridden the toString method to specify the Vehicle object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/api/services/model/ModelResolverException.java",
    "type": "method",
    "name": "ModelResolverException",
    "code": "public ModelResolverException(String message, String groupId, String artifactId, String version, Throwable cause) {\n        super(message, cause);\n        this.groupId = (groupId != null) ? groupId : \"\";\n        this.artifactId = (artifactId != null) ? artifactId : \"\";\n        this.version = (version != null) ? version : \"\";\n    }",
    "comment": "Creates a new exception with specified detail message and cause.\n\n@param message The detail message, may be {@code null}.\n@param groupId The group id of the unresolvable model, may be {@code null}.\n@param artifactId The artifact id of the unresolvable model, may be {@code null}.\n@param version The version of the unresolvable model, may be {@code null}.\n@param cause The cause, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/CLIService.java",
    "type": "method",
    "name": "setupBlockedUdfs",
    "code": "private void setupBlockedUdfs() {\n    FunctionRegistry.setupPermissionsForBuiltinUDFs(\n        hiveConf.getVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_WHITELIST),\n        hiveConf.getVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST));\n  }",
    "comment": "authorization setup using SessionState should be revisited eventually, as\nauthorization and authentication are not session specific settings"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/TestCaseTest.java",
    "type": "method",
    "name": "testExceptionRunningAndTearDown",
    "code": "public void testExceptionRunningAndTearDown() {\n        Test t = new TornDown() {\n        };\n        TestResult result = new TestResult();\n        t.run(result);\n        TestFailure failure = result.errors().nextElement();\n        assertEquals(\"running\", failure.thrownException().getMessage());\n    }",
    "comment": "With 1.4, we should\nwrap the exception thrown while running with the exception thrown\nwhile tearing down"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Long expected, Long actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/gpu/java/src/main/java/org/tensorflow/lite/gpu/GpuDelegateFactory.java",
    "type": "method",
    "name": "setQuantizedModelsAllowed",
    "code": "public Options setQuantizedModelsAllowed(boolean quantizedModelsAllowed) {\n      this.quantizedModelsAllowed = quantizedModelsAllowed;\n      return this;\n    }",
    "comment": "Enables running quantized models with the delegate.\n\n<p>WARNING: This is an experimental API and subject to change.\n\n@param quantizedModelsAllowed When {@code true} (default), the GPU may run quantized models."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/lockable-object/src/main/java/com/iluwatar/lockableobject/App.java",
    "type": "method",
    "name": "run",
    "code": "public void run() {\n    var sword = new SwordOfAragorn();\n    List<Creature> creatures = new ArrayList<>();\n    for (var i = 0; i < WORKERS; i++) {\n      creatures.add(new Elf(String.format(\"Elf %s\", i)));\n      creatures.add(new Orc(String.format(\"Orc %s\", i)));\n      creatures.add(new Human(String.format(\"Human %s\", i)));\n    }\n    int totalFiends = WORKERS * MULTIPLICATION_FACTOR;\n    ExecutorService service = Executors.newFixedThreadPool(totalFiends);\n    for (var i = 0; i < totalFiends; i = i + MULTIPLICATION_FACTOR) {\n      service.submit(new Feind(creatures.get(i), sword));\n      service.submit(new Feind(creatures.get(i + 1), sword));\n      service.submit(new Feind(creatures.get(i + 2), sword));\n    }\n    try {\n      if (!service.awaitTermination(WAIT_TIME, TimeUnit.SECONDS)) {\n        LOGGER.info(\"The master of the sword is now {}.\", sword.getLocker().getName());\n      }\n    } catch (InterruptedException e) {\n      LOGGER.error(e.getMessage());\n      Thread.currentThread().interrupt();\n    } finally {\n      service.shutdown();\n    }\n  }",
    "comment": "The target object for this example.\nCreation of creatures.\nAttach every creature and the sword is a Fiend to fight for the sword.\nWait for program to terminate."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/session-facade/src/main/java/com/iluwatar/sessionfacade/CartService.java",
    "type": "method",
    "name": "CartService",
    "code": "public CartService(Map<Integer, Product> cart, Map<Integer, Product> productCatalog) {\n    this.cart = cart;\n    this.productCatalog = productCatalog;\n  }",
    "comment": "Instantiates a new Cart service.\n\n@param cart the cart\n@param productCatalog the product catalog"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Graph.java",
    "type": "method",
    "name": "opBuilder",
    "code": "public GraphOperationBuilder opBuilder(String type, String name) {\n    return new GraphOperationBuilder(this, type, name);\n  }",
    "comment": "Returns a builder to add {@link Operation}s to the Graph.\n\n@param type of the Operation (i.e., identifies the computation to be performed)\n@param name to refer to the created Operation in the graph.\n@return an {@link OperationBuilder}, which will add the Operation to the graph when {@link\nOperationBuilder#build()} is invoked. If {@link OperationBuilder#build()} is not invoked,\nthen some resources may leak."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(double unexpected, double actual, double delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }",
    "comment": "Asserts that two doubles are <b>not</b> equal to within a positive delta.\nIf they are, an {@link AssertionError} is thrown. If the unexpected\nvalue is infinity then the delta value is ignored.NaNs are considered\nequal: <code>assertNotEquals(Double.NaN, Double.NaN, *)</code> fails\n\n@param unexpected unexpected value\n@param actual the value to check against <code>unexpected</code>\n@param delta the maximum delta between <code>unexpected</code> and\n<code>actual</code> for which both numbers are still\nconsidered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(long expected, long actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "filter",
    "code": "public Stream<Execution> filter(Predicate<? super Execution> predicate) {\n\t\tPreconditions.notNull(predicate, \"Filter predicate must not be null\");\n\t\treturn stream().filter(predicate);\n\t}",
    "comment": "Shortcut for {@code executions.stream().filter(predicate)}.\n\n@param predicate a {@code Predicate} to apply to each execution to decide\nif it should be included in the filtered stream; never {@code null}\n@return the filtered stream of executions; never {@code null}\n@see #stream()\n@see Stream#filter(Predicate)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/VehicleDatabase.java",
    "type": "method",
    "name": "getCar",
    "code": "public Car getCar(int id) {\n    return carTable.get(id);\n  }",
    "comment": "Retrieves a car by its ID.\n\n@param id the ID of the car\n@return the car with the given ID, or null if not found"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java",
    "type": "method",
    "name": "isIgnored",
    "code": "protected boolean isIgnored(FrameworkMethod child) {\n        return child.getAnnotation(Ignore.class) != null;\n    }",
    "comment": "Evaluates whether {@link FrameworkMethod}s are ignored based on the\n{@link Ignore} annotation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/function/Try.java",
    "type": "method",
    "name": "getOrThrow",
    "code": "public <E extends Exception> V getOrThrow(Function<? super Exception, E> exceptionTransformer) {\n\t\t\treturn this.value;\n\t\t}",
    "comment": "don't call exceptionTransformer because this Try is a success"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/MirrorProcessorTest.java",
    "type": "method",
    "name": "testMirrorStopOnFirstMatch",
    "code": "void testMirrorStopOnFirstMatch() {\n        Mirror mirrorA2 = newMirror(\"a2\", \"a,b\", \"http://a2\");\n        Mirror mirrorA = newMirror(\"a\", \"a\", \"http://a\");\n        Mirror mirrorA3 = newMirror(\"a\", \"a\", \"http://a3\");\n\n        Mirror mirrorB = newMirror(\"b\", \"b\", \"http://b\");\n        Mirror mirrorC = newMirror(\"c\", \"d,e\", \"http://de\");\n        Mirror mirrorC2 = newMirror(\"c\", \"*\", \"http://wildcard\");\n        Mirror mirrorC3 = newMirror(\"c\", \"e,f\", \"http://ef\");\n\n        List<Mirror> mirrors = Arrays.asList(mirrorA2, mirrorA, mirrorA3, mirrorB, mirrorC, mirrorC2, mirrorC3);\n\n        assertSame(mirrorA, mirrorSelector.getMirror(getRepo(\"a\", \"http://a.a\"), mirrors));\n\n        assertSame(mirrorB, mirrorSelector.getMirror(getRepo(\"b\", \"http://a.a\"), mirrors));\n\n        assertSame(mirrorC2, mirrorSelector.getMirror(getRepo(\"c\", \"http://c.c\"), mirrors));\n\n        assertSame(mirrorC, mirrorSelector.getMirror(getRepo(\"d\", \"http://d\"), mirrors));\n\n        assertSame(mirrorC, mirrorSelector.getMirror(getRepo(\"e\", \"http://e\"), mirrors));\n\n        assertSame(mirrorC2, mirrorSelector.getMirror(getRepo(\"f\", \"http://f\"), mirrors));\n    }",
    "comment": "exact matches win first\nmake sure repeated entries are skipped"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Character unexpected, Character actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/JavaPipelineSuite.java",
    "type": "method",
    "name": "pipeline",
    "code": "public void pipeline() {\n    StandardScaler scaler = new StandardScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\");\n    LogisticRegression lr = new LogisticRegression()\n      .setFeaturesCol(\"scaledFeatures\");\n    Pipeline pipeline = new Pipeline()\n      .setStages(new PipelineStage[]{scaler, lr});\n}",
    "comment": "Test Pipeline construction and fitting in Java."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/test/java/org/apache/spark/sql/catalyst/expressions/HiveHasherSuite.java",
    "type": "method",
    "name": "randomizedStressTest",
    "code": "public void randomizedStressTest() {\n    int size = 65536;\n    Random rand = new Random();\n\n    Set<Integer> hashcodes = new HashSet<>();\n    for (int i = 0; i < size; i++) {\n      int vint = rand.nextInt();\n      long lint = rand.nextLong();\n      Assertions.assertEquals(HiveHasher.hashInt(vint), HiveHasher.hashInt(vint));\n      Assertions.assertEquals(HiveHasher.hashLong(lint), HiveHasher.hashLong(lint));\n\n      hashcodes.add(HiveHasher.hashLong(lint));\n    }\n\n    Assertions.assertTrue(hashcodes.size() > size * 0.95);\n  }",
    "comment": "A set used to track collision rate.\nA very loose bound."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/LevelDB.java",
    "type": "method",
    "name": "notifyIteratorClosed",
    "code": "void notifyIteratorClosed(DBIterator dbIterator) {\n    iteratorTracker.removeIf(ref -> {\n      LevelDBIterator<?> it = ref.get();\n      return it != null && dbIterator.equals(it.internalIterator());\n    });\n  }",
    "comment": "Remove iterator from iterator tracker. `LevelDBIterator` calls it to notify\niterator is closed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/notification/RunNotifier.java",
    "type": "method",
    "name": "fireTestFinished",
    "code": "public void fireTestFinished(final Description description) {\n        new SafeNotifier() {\n        }.run();\n    }",
    "comment": "Invoke to tell listeners that an atomic test finished. Always invoke\nthis method if you invoke {@link #fireTestStarted(Description)}\nas listeners are likely to expect them to come in pairs.\n\n@param description the description of the test that finished"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/testkit/engine/ExecutionsIntegrationTests.java",
    "type": "method",
    "name": "executionsFromFinishedTestEvents",
    "code": "void executionsFromFinishedTestEvents() {\n\t\tvar testEvents = getTestEvents();\n\n\t\tassertThat(testEvents.executions().finished().count()).isEqualTo(3);\n\t\tassertThat(testEvents.finished().executions().count()).isEqualTo(0);\n\t}",
    "comment": "We expect 3 if the executions are created BEFORE filtering out \"started\" events.\nWe expect 0 if the executions are created AFTER filtering out \"started\" events."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "contains",
    "code": "public static boolean contains(char[] array, char valueToFind) {\n        if (array == null) {\n            return false;\n        }\n        for (char c : array) {\n            if (valueToFind == c) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "comment": "<p>Checks if the value is in the given array.</p>\n\n<p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n\n@param array  the array to search through\n@param valueToFind  the value to find\n@return <code>true</code> if the array contains the object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenIT0108SnapshotUpdateTest.java",
    "type": "method",
    "name": "constructMetadata",
    "code": "private String constructMetadata(String buildNumber, long timestamp, boolean writeLastUpdated) {\n        String ts = new SimpleDateFormat(\"yyyyMMddHHmmss\", Locale.US).format(new Date(timestamp));\n\n        return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><metadata>\\n\" + \"<groupId>org.apache.maven</groupId>\\n\"\n                + \"<artifactId>maven-core-it-support</artifactId>\\n\"\n                + \"<version>1.0-SNAPSHOT</version>\\n\" + \"<versioning>\\n\"\n                + \"<snapshot>\\n\" + \"<buildNumber>\" + buildNumber + \"</buildNumber>\\n\" + \"</snapshot>\\n\"\n                + (writeLastUpdated ? \"<lastUpdated>\" + ts + \"</lastUpdated>\\n\" : \"\")\n                + \"</versioning>\\n\" + \"</metadata>\";\n    }",
    "comment": "create a repository (TODO: into verifier)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TimeoutExtensionTests.java",
    "type": "method",
    "name": "applyTimeoutOnAnnotatedTestMethodsUsingDisabledOnDebugTimeoutMode",
    "code": "void applyTimeoutOnAnnotatedTestMethodsUsingDisabledOnDebugTimeoutMode() {\n\t\tEngineExecutionResults results = executeTests(request() //\n\t\t\t\t.selectors(selectMethod(TimeoutAnnotatedTestMethodTestCase.class, \"testMethod\")) //\n\t\t\t\t.configurationParameter(DEFAULT_TEST_METHOD_TIMEOUT_PROPERTY_NAME, \"42ns\") //\n\t\t\t\t.configurationParameter(TIMEOUT_MODE_PROPERTY_NAME, \"disabled_on_debug\").build());\n\n\t\tExecution execution = findExecution(results.testEvents(), \"testMethod()\");\n\n\t\tassertThat(execution.getDuration()) //\n\t\t\t\t.isGreaterThanOrEqualTo(Duration.ofMillis(10)) //\n\t\t\t\t.isLessThan(Duration.ofSeconds(2));\n\n\t\tif (RuntimeUtils.isDebugMode()) {\n\t\t\tassertThat(execution.getTerminationInfo().getExecutionResult().getThrowable()) //\n\t\t\t\t\t.isEmpty();\n\t\t}\n\t\telse {\n\t\t\tassertThat(execution.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //\n\t\t\t\t\t.isInstanceOf(TimeoutException.class) //\n\t\t\t\t\t.hasMessage(\"testMethod() timed out after 10 milliseconds\");\n\t\t}\n\t}",
    "comment": "The check to see if debugging is pushing the timer just above 1 second\nShould we test if we're debugging? This test will fail if we are debugging."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/KVStoreView.java",
    "type": "method",
    "name": "parent",
    "code": "public KVStoreView<T> parent(Object value) {\n    this.parent = value;\n    return this;\n  }",
    "comment": "Defines the value of the parent index when iterating over a child index. Only elements that\nmatch the parent index's value will be included in the iteration.\n\n<p>\nRequired for iterating over child indices, will generate an error if iterating over a\nparent-less index.\n</p>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java",
    "type": "method",
    "name": "if",
    "code": "MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer) {\n        String expression = param.getExpression();\n\n        if (param.isEditable()) {\n            boolean isArray = param.getType().endsWith(\"[]\");\n            boolean isCollection = false;\n            boolean isMap = false;\n            boolean isProperties = false;\n            if (!isArray) {\n                try {\n                    isCollection = Collection.class.isAssignableFrom(Class.forName(param.getType()));\n                    isMap = Map.class.isAssignableFrom(Class.forName(param.getType()));\n                    isProperties = Properties.class.isAssignableFrom(Class.forName(param.getType()));\n                } catch (ClassNotFoundException e) {\n                }\n            }\n\n            messageBuffer.append(\"Inside the definition for plugin '\");\n            messageBuffer.append(mojo.getPluginDescriptor().getArtifactId());\n            messageBuffer.append(\"', specify the following:\").append(LS).append(LS);\n            messageBuffer.append(\"<configuration>\").append(LS).append(\"  ...\").append(LS);\n            messageBuffer.append(\"  <\").append(param.getName()).append('>');\n            if (isArray || isCollection) {\n                messageBuffer.append(LS);\n                messageBuffer.append(\"    <item>\");\n            } else if (isProperties) {\n                messageBuffer.append(LS);\n                messageBuffer.append(\"    <property>\").append(LS);\n                messageBuffer.append(\"      <name>KEY</name>\").append(LS);\n                messageBuffer.append(\"      <value>\");\n            } else if (isMap) {\n                messageBuffer.append(LS);\n                messageBuffer.append(\"    <KEY>\");\n            }\n            messageBuffer.append(\"VALUE\");\n            if (isArray || isCollection) {\n                messageBuffer.append(\"</item>\").append(LS);\n                messageBuffer.append(\"  \");\n            } else if (isProperties) {\n                messageBuffer.append(\"</value>\").append(LS);\n                messageBuffer.append(\"    </property>\").append(LS);\n                messageBuffer.append(\"  \");\n            } else if (isMap) {\n                messageBuffer.append(\"</KEY>\").append(LS);\n                messageBuffer.append(\"  \");\n            }\n            messageBuffer.append(\"</\").append(param.getName()).append(\">\").append(LS);\n            messageBuffer.append(\"</configuration>\");\n\n            String alias = param.getAlias();\n            if ((alias != null && !alias.isEmpty()) && !alias.equals(param.getName())) {\n                messageBuffer.append(LS).append(LS).append(\"-OR-\").append(LS).append(LS);\n                messageBuffer\n                        .append(\"<configuration>\")\n                        .append(LS)\n                        .append(\"  ...\")\n                        .append(LS);\n                messageBuffer\n                        .append(\"  <\")\n                        .append(alias)\n                        .append(\">VALUE</\")\n                        .append(alias)\n                        .append(\">\")\n                        .append(LS)\n                        .append(\"</configuration>\")\n                        .append(LS);\n            }\n        }\n\n        if (expression == null || expression.isEmpty()) {\n            messageBuffer.append('.');\n        } else {\n            if (param.isEditable()) {\n                messageBuffer.append(LS).append(LS).append(\"-OR-\").append(LS).append(LS);\n            }\n\n        }\n    }",
    "comment": "assuming Type is available in current ClassLoader\nassume it is not assignable from Collection or Map\naddParameterUsageInfo( expression, messageBuffer );"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/AlbumPage.java",
    "type": "method",
    "name": "changeArtist",
    "code": "public AlbumPage changeArtist(String artist) {\n    var artistInputTextField = (HtmlTextInput) page.getElementById(\"albumArtist\");\n    artistInputTextField.setText(artist);\n    return this;\n  }",
    "comment": "Sets the artist input text field\n\n@param artist the new artist value to set\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/MirrorProcessorTest.java",
    "type": "method",
    "name": "getRepo",
    "code": "private ArtifactRepository getRepo(String id) {\n        return getRepo(id, \"http://something\");\n    }",
    "comment": "Build an ArtifactRepository object.\n\n@param id\n@return"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfig.java",
    "type": "method",
    "name": "enableLauncherSessionListenerAutoRegistration",
    "code": "public Builder enableLauncherSessionListenerAutoRegistration(boolean enabled) {\n\t\t\tthis.launcherSessionListenerAutoRegistrationEnabled = enabled;\n\t\t\treturn this;\n\t\t}",
    "comment": "Configure the auto-registration flag for launcher session\nlisteners.\n\n<p>Defaults to {@code true}.\n\n@param enabled {@code true} if launcher session listeners should be\nautomatically registered\n@return this builder for method chaining\n@since 1.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/model-view-controller/src/test/java/com/iluwatar/model/view/controller/GiantViewTest.java",
    "type": "method",
    "name": "testDisplayGiant",
    "code": "void testDisplayGiant() {\n    final var view = new GiantView();\n\n    final var model = mock(GiantModel.class);\n    view.displayGiant(model);\n\n    assertEquals(model.toString(), appender.getLastMessage());\n    assertEquals(1, appender.getLogSize());\n  }",
    "comment": "Verify if the {@link GiantView} does what it has to do: Print the {@link GiantModel} to the\nstandard out stream, nothing more, nothing less."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractOrderingVisitor.java",
    "type": "method",
    "name": "distinctWrappersToIndex",
    "code": "private Map<Object, Integer> distinctWrappersToIndex(List<?> wrappers) {\n\t\t\tMap<Object, Integer> toIndex = new HashMap<>();\n\t\t\tfor (int i = 0; i < wrappers.size(); i++) {\n\t\t\t\tObject wrapper = wrappers.get(i);\n\t\t\t\tif (!toIndex.containsKey(wrapper)) {\n\t\t\t\t\ttoIndex.put(wrapper, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn toIndex;\n\t\t}",
    "comment": "Avoid ClassCastException if a misbehaving ordering action added a non-WRAPPER"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/logging/LogRecordListener.java",
    "type": "method",
    "name": "stream",
    "code": "public Stream<LogRecord> stream(Class<?> clazz, Level level) {\n\t\t// NOTE: we cannot use org.junit.platform.commons.util.Preconditions here\n\t\t// since that would introduce a package cycle.\n\t\tif (level == null) {\n\t\t\tthrow new JUnitException(\"Level must not be null\");\n\t\t}\n\n\t\treturn stream(clazz).filter(logRecord -> logRecord.getLevel() == level);\n\t}",
    "comment": "Get a stream of {@link LogRecord log records} that have been\n{@linkplain #logRecordSubmitted submitted} to this listener by the current\nthread for the logger name equal to the name of the given class at the given\nlog level.\n\n<p>As stated in the Javadoc for {@code LogRecord}, a submitted\n{@code LogRecord} should not be updated by the client application. Thus,\nthe {@code LogRecords} in the returned stream should only be inspected for\ntesting purposes and not modified in any way.\n\n@param clazz the class for which to get the log records; never {@code null}\n@param level the log level for which to get the log records; never {@code null}\n@see #stream()\n@see #stream(Level)\n@see #stream(Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-di/src/main/java/org/apache/maven/di/Key.java",
    "type": "method",
    "name": "of",
    "code": "public static <T> Key<T> of(Class<T> type) {\n        return new KeyImpl<>(type, null);\n    }",
    "comment": "Creates a new Key instance for the specified type.\n\n@param <T> the type parameter\n@param type the Class object representing the type\n@return a new Key instance\n@throws NullPointerException if type is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/test/org/apache/spark/JavaTaskContextCompileCheck.java",
    "type": "method",
    "name": "onTaskCompletion",
    "code": "public void onTaskCompletion(TaskContext context) {\n      context.isCompleted();\n      context.isInterrupted();\n      context.stageId();\n      context.stageAttemptNumber();\n      context.partitionId();\n      context.addTaskCompletionListener(this);\n    }",
    "comment": "A simple implementation of TaskCompletionListener that makes sure TaskCompletionListener and\nTaskContext is Java friendly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/DependencyResolverRequest.java",
    "type": "method",
    "name": "rootArtifact",
    "code": "public DependencyResolverRequestBuilder rootArtifact(@Nullable Artifact rootArtifact) {\n            this.rootArtifact = rootArtifact;\n            return this;\n        }",
    "comment": "Sets the root artifact for the dependency graph.\nThis must not be confused with {@link #root(DependencyCoordinates)}: The root <em>dependency</em>, like any\nother specified dependency, will be subject to dependency collection/resolution, i.e. should have an artifact\ndescriptor and a corresponding artifact file. The root <em>artifact</em> on the other hand is only used\nas a label for the root node of the graph in case no root dependency was specified. As such, the configured\nroot artifact is ignored if {@link #root(DependencyCoordinates)} has been set.\n\n@param rootArtifact the root artifact for the dependency graph, may be {@code null}\n@return this request for chaining, never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Request.java",
    "type": "method",
    "name": "classes",
    "code": "public static Request classes(Computer computer, Class<?>... classes) {\n        try {\n            AllDefaultPossibilitiesBuilder builder = new AllDefaultPossibilitiesBuilder();\n            Runner suite = computer.getSuite(builder, classes);\n            return runner(suite);\n        } catch (InitializationError e) {\n            return runner(new ErrorReportingRunner(e, classes));\n        }\n    }",
    "comment": "Create a <code>Request</code> that, when processed, will run all the tests\nin a set of classes.\n\n@param computer Helps construct Runners from classes\n@param classes the classes containing the tests\n@return a <code>Request</code> that will cause all tests in the classes to be run"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/component/src/main/java/com/iluwatar/component/component/graphiccomponent/ObjectGraphicComponent.java",
    "type": "method",
    "name": "update",
    "code": "public void update(GameObject gameObject) {\n    LOGGER.info(gameObject.getName() + \"'s current velocity: \" + gameObject.getVelocity());\n  }",
    "comment": "The method updates the graphics based on the velocity of gameObject.\n\n@param gameObject the gameObject instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestExecutionListener.java",
    "type": "method",
    "name": "fileEntryPublished",
    "code": "default void fileEntryPublished(TestIdentifier testIdentifier, FileEntry file) {\n\t}",
    "comment": "Called when a file or directory has been published for the supplied\n{@link TestIdentifier}.\n\n<p>Can be called at any time during the execution of a test plan.\n\n@param testIdentifier describes the test or container to which the entry pertains\n@param file the published {@code FileEntry}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/Throwables.java",
    "type": "method",
    "name": "getCauseStackTraceLines",
    "code": "private static List<String> getCauseStackTraceLines(Throwable exception) {\n        if (exception.getCause() != null || hasSuppressed(exception)) {\n            String fullTrace = getFullStackTrace(exception);\n            BufferedReader reader = new BufferedReader(\n                    new StringReader(fullTrace.substring(exception.toString().length())));\n            List<String> causedByLines = new ArrayList<String>();\n    \n            try {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (line.startsWith(\"Caused by: \") || line.trim().startsWith(\"Suppressed: \")) {\n                        causedByLines.add(line);\n                        while ((line = reader.readLine()) != null) {\n                            causedByLines.add(line);\n                        }\n                        return causedByLines;\n                    }\n                }\n            } catch (IOException e) {\n            }\n        }\n\n        return Collections.emptyList();\n    }",
    "comment": "We should never get here, because we are reading from a StringReader"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/interpreter/src/main/java/com/iluwatar/interpreter/App.java",
    "type": "method",
    "name": "isOperator",
    "code": "public static boolean isOperator(String s) {\n    return s.equals(\"+\") || s.equals(\"-\") || s.equals(\"*\");\n  }",
    "comment": "Checks whether the input parameter is an operator.\n\n@param s input string\n@return true if the input parameter is an operator"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/test/java/com/iluwatar/identitymap/PersonDbSimulatorImplementationTest.java",
    "type": "method",
    "name": "testInsert",
    "code": "void testInsert() {\n    PersonDbSimulatorImplementation db = new PersonDbSimulatorImplementation();\n    Assertions.assertEquals(0, db.size(), \"Size of null database should be 0\");\n    Person person1 = new Person(1, \"Thomas\", 27304159);\n    Person person2 = new Person(2, \"John\", 42273631);\n    Person person3 = new Person(3, \"Arthur\", 27489171);\n    db.insert(person1);\n    db.insert(person2);\n    db.insert(person3);\n    Assertions.assertEquals(3, db.size(), \"Incorrect size for database.\");\n    Person person4 = new Person(4, \"Finn\", 20499078);\n    Person person5 = new Person(5, \"Michael\", 40599078);\n    db.insert(person4);\n    db.insert(person5);\n    Assertions.assertEquals(5, db.size(), \"Incorrect size for database.\");\n    Person person5duplicate = new Person(5, \"Kevin\", 89589122);\n    db.insert(person5duplicate);\n    Assertions.assertEquals(5, db.size(), \"Incorrect size for data base\");\n  }",
    "comment": "DataBase initialization.\nDummy persons.\nTest size after insertion.\nTest size after more insertions.\nTest size after attempt to insert record with duplicate key."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Long> create(Scope scope, long data) {\n    return create(scope, data, Long.class);\n  }",
    "comment": "Creates a constant containing a single {@code long} element.\n\n@param scope is a scope used to add the underlying operation.\n@param data The value to put into the new constant.\n@return a long constant"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "cursorDownLine",
    "code": "public Ansi cursorDownLine(final int n) {\n        return n < 0 ? cursorUpLine(-n) : appendEscapeSequence('E', n);\n    }",
    "comment": "Moves the cursor to the beginning of the n-th line below. If the parameter n is negative it\nmoves the cursor to the beginning of the n-th line above.\n\n@param n the number of lines to move the cursor\n@return this Ansi instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/cache/AbstractRequestCache.java",
    "type": "method",
    "name": "request",
    "code": "public <REQ extends Request<?>, REP extends Result<REQ>> REP request(REQ req, Function<REQ, REP> supplier) {\n        CachingSupplier<REQ, REP> cs = doCache(req, supplier);\n        return cs.apply(req);\n    }",
    "comment": "Executes and optionally caches a single request.\n<p>\nThe caching behavior is determined by the specific implementation of {@link #doCache(Request, Function)}.\nIf caching is enabled, the result is retrieved from the cache or computed using the supplier function.\n</p>\n\n@param <REQ> The request type\n@param <REP> The response type\n@param req The request object used as the cache key\n@param supplier The function that provides the response if not cached\n@return The cached or computed response"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom/java/com/example/android/persistence/migrations/MigrationTest.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n        // To test migrations from version 1 of the database, we need to create the database\n        // with version 1 using SQLite API\n        mSqliteTestDbHelper = new SqliteTestDbOpenHelper(ApplicationProvider.getApplicationContext(),\n                TEST_DB_NAME);\n        // We're creating the table for every test, to ensure that the table is in the correct state\n        SqliteDatabaseTestHelper.createTable(mSqliteTestDbHelper);\n    }",
    "comment": "Test the migration from database database version 1 to version 2."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<String> create(byte[] data) {\n    return Tensor.create(data, String.class);\n  }",
    "comment": "Creates a scalar tensor containing a single {@code byte} element.\n\n@param data An array containing the data to put into the new tensor. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "namespaceUri",
    "code": "public Builder namespaceUri(String namespaceUri) {\n            this.namespaceUri = namespaceUri;\n            return this;\n        }",
    "comment": "Sets the namespace URI of the XML node.\n\n@param namespaceUri the namespace URI of the XML node\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "isCommentLine",
    "code": "static boolean isCommentLine(String line) {\n        String s = line.trim();\n        // blank lines are also treated as comment lines\n        return s.isEmpty() || COMMENT_CHARS.indexOf(s.charAt(0)) >= 0;\n    }",
    "comment": "Tests whether a line is a comment, i.e. whether it starts with a comment\ncharacter.\n\n@param line the line\n@return a flag if this is a comment line"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroNonNullableArrays.java",
    "type": "method",
    "name": "getSchema",
    "code": "public org.apache.avro.Schema getSchema() { return SCHEMA$; }\n  public java.lang.Object get(int field$) {\n    switch (field$) {\n    case 0: return strings_column;\n    case 1: return maybe_ints_column;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumWriter.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/DefaultMaven.java",
    "type": "method",
    "name": "getAllProfiles",
    "code": "private Set<String> getAllProfiles(MavenSession session) {\n        final Map<String, Model> superPomModels = new HashMap<>();\n        final Set<MavenProject> projectsIncludingParents = new HashSet<>();\n        for (MavenProject project : session.getProjects()) {\n            superPomModels.computeIfAbsent(\n                    project.getModelVersion(),\n                    v -> superPomProvider.getSuperModel(v).getDelegate());\n            boolean isAdded = projectsIncludingParents.add(project);\n            MavenProject parent = project.getParent();\n            while (isAdded && parent != null) {\n                isAdded = projectsIncludingParents.add(parent);\n                parent = parent.getParent();\n            }\n        }\n\n        final Stream<String> projectProfiles = projectsIncludingParents.stream()\n                .flatMap(p -> p.getModel().getDelegate().getProfiles().stream())\n                .map(Profile::getId);\n        final Stream<String> settingsProfiles =\n                session.getSettings().getProfiles().stream().map(org.apache.maven.settings.Profile::getId);\n        final Stream<String> superPomProfiles = superPomModels.values().stream()\n                .flatMap(p -> p.getProfiles().stream())\n                .map(Profile::getId);\n\n        return Stream.of(projectProfiles, settingsProfiles, superPomProfiles)\n                .flatMap(Function.identity())\n                .collect(toSet());\n    }",
    "comment": "Get all profiles that are detected in the projects, any parent of the projects, or the settings.\n@param session The Maven session\n@return A {@link Set} of profile identifiers, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-transfer-object/src/test/java/com/iluwatar/datatransfer/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "finishedSuccessfully",
    "code": "public static Condition<Event> finishedSuccessfully() {\n\t\treturn finished(TestExecutionResultConditions.status(SUCCESSFUL));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link EventType#FINISHED} and its\n{@linkplain Event#getPayload() result} has a\n{@linkplain TestExecutionResult#getStatus() status} of\n{@link TestExecutionResult.Status#SUCCESSFUL SUCCESSFUL}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/project/MissingRepositoryElementException.java",
    "type": "method",
    "name": "MissingRepositoryElementException",
    "code": "public MissingRepositoryElementException(String message, String repositoryId) {\n        super(message, repositoryId);\n    }",
    "comment": "Error constructing an artifact repository."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaNaiveBayesExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaNaiveBayesExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Load training data\n    Dataset<Row> dataFrame =\n      spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n    // Split the data into train and test\n    Dataset<Row>[] splits = dataFrame.randomSplit(new double[]{0.6, 0.4}, 1234L);\n}",
    "comment": "An example for Naive Bayes Classification."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/serializer/DummySerializerInstance.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n        try {\n          s.close();\n        } catch (IOException e) {\n          Platform.throwException(e);\n        }\n      }",
    "comment": "Need to implement this because DiskObjectWriter uses it to close the compression stream"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfig.java",
    "type": "method",
    "name": "addTestEngines",
    "code": "public Builder addTestEngines(TestEngine... engines) {\n\t\t\tPreconditions.notNull(engines, \"TestEngine array must not be null\");\n\t\t\tPreconditions.containsNoNullElements(engines, \"TestEngine array must not contain null elements\");\n\t\t\tCollections.addAll(this.engines, engines);\n\t\t\treturn this;\n\t\t}",
    "comment": "Add all of the supplied test engines to the configuration.\n\n@param engines additional test engines to register; never {@code null}\nor containing {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/DeltaWriteBuilder.java",
    "type": "method",
    "name": "build",
    "code": "default DeltaWrite build() {\n    throw new SparkUnsupportedOperationException(\n      \"_LEGACY_ERROR_TEMP_3140\", Map.of(\"class\", getClass().getName()));\n  }",
    "comment": "An interface for building a {@link DeltaWrite}.\n\n@since 3.4.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/test/java/org/apache/spark/sql/catalyst/expressions/XXH64Suite.java",
    "type": "method",
    "name": "randomizedStressTestPaddedStrings",
    "code": "public void randomizedStressTestPaddedStrings() {\n    int size = 64000;\n    Set<Long> hashcodes = new HashSet<>();\n    for (int i = 0; i < size; i++) {\n      int byteArrSize = 8;\n      byte[] strBytes = String.valueOf(i).getBytes(StandardCharsets.UTF_8);\n      byte[] paddedBytes = new byte[byteArrSize];\n      System.arraycopy(strBytes, 0, paddedBytes, 0, strBytes.length);\n\n      Assertions.assertEquals(\n              hasher.hashUnsafeWords(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize),\n              hasher.hashUnsafeWords(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n\n      hashcodes.add(hasher.hashUnsafeWords(\n              paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n    }\n\n    Assertions.assertTrue(hashcodes.size() > size * 0.95d);\n  }",
    "comment": "A set used to track collision rate.\nA very loose bound."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(double[] expected, double[] actual) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} double arrays are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-xml/src/main/java/org/apache/maven/internal/xml/ImmutableCollections.java",
    "type": "method",
    "name": "ROProperties",
    "code": "private ROProperties(Properties props) {\n            super();\n            if (props != null) {\n                for (Map.Entry<Object, Object> e : props.entrySet()) {\n                    super.put(e.getKey(), e.getValue());\n                }\n            }\n        }",
    "comment": "Do not use super.putAll, as it may delegate to put which throws an UnsupportedOperationException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "getClassName",
    "code": "public String getClassName() {\n        return fTestClass != null ? fTestClass.getName() : methodAndClassNamePatternGroupOrDefault(2, toString());\n    }",
    "comment": "@return If this describes a method invocation,\nthe name of the class of the test instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/filter/OrArtifactFilter.java",
    "type": "method",
    "name": "OrArtifactFilter",
    "code": "public OrArtifactFilter() {\n        this.filters = new LinkedHashSet<>();\n    }",
    "comment": "Apply multiple filters, accepting an artifact if at least one of the filters accepts it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertTrueAssertionsTests.java",
    "type": "method",
    "name": "assertTrueWithBooleanTrue",
    "code": "void assertTrueWithBooleanTrue() {\n\t\tassertTrue(true);\n\t\tassertTrue(true, \"test\");\n\t\tassertTrue(true, () -> \"test\");\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ClassUtilsTests.java",
    "type": "method",
    "name": "nullSafeToStringWithDefaultMapper",
    "code": "void nullSafeToStringWithDefaultMapper() {\n\t\tassertEquals(\"\", nullSafeToString((Class<?>[]) null));\n\t\tassertEquals(\"\", nullSafeToString());\n\t\tassertEquals(\"java.lang.String\", nullSafeToString(String.class));\n\t\tassertEquals(\"java.lang.String, java.lang.Integer\", nullSafeToString(String.class, Integer.class));\n\t\tassertEquals(\"java.lang.String, null, java.lang.Integer\", nullSafeToString(String.class, null, Integer.class));\n\t}",
    "comment": "Unit tests for {@link ClassUtils}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/collection-pipeline/src/main/java/com/iluwatar/collectionpipeline/CarFactory.java",
    "type": "method",
    "name": "createCars",
    "code": "public static List<Car> createCars() {\n    return List.of(\n        new Car(\"Jeep\", \"Wrangler\", 2011, Category.JEEP),\n        new Car(\"Jeep\", \"Comanche\", 1990, Category.JEEP),\n        new Car(\"Dodge\", \"Avenger\", 2010, Category.SEDAN),\n        new Car(\"Buick\", \"Cascada\", 2016, Category.CONVERTIBLE),\n        new Car(\"Ford\", \"Focus\", 2012, Category.SEDAN),\n        new Car(\"Chevrolet\", \"Geo Metro\", 1992, Category.CONVERTIBLE));\n  }",
    "comment": "Factory method to create a {@link List} of {@link Car} instances.\n\n@return {@link List} of {@link Car}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/ExpressionImplUtils.java",
    "type": "method",
    "name": "if",
    "code": "byte[] aad) {\n    try {\n      SecretKeySpec secretKey = getSecretKeySpec(key);\n      CipherMode cipherMode = CipherMode.fromString(mode, padding);\n      Cipher cipher = Cipher.getInstance(cipherMode.transformation);\n      if (opmode == Cipher.ENCRYPT_MODE) {\n        if (iv == null || iv.length == 0) {\n          iv = generateIv(cipherMode);\n        } else if (!cipherMode.usesSpec) {\n          throw QueryExecutionErrors.aesUnsupportedIv(mode);\n        }\n        if (iv.length != cipherMode.ivLength) {\n          throw QueryExecutionErrors.invalidAesIvLengthError(mode, iv.length);\n        }\n\n        if (cipherMode.usesSpec) {\n          AlgorithmParameterSpec algSpec = getParamSpec(cipherMode, iv);\n          cipher.init(opmode, secretKey, algSpec);\n        } else {\n          cipher.init(opmode, secretKey);\n        }\n\n        if (aad != null && aad.length != 0) {\n          if (cipherMode.supportsAad != true) {\n            throw QueryExecutionErrors.aesUnsupportedAad(mode);\n          }\n          cipher.updateAAD(aad);\n        }\n\n        byte[] encrypted = cipher.doFinal(input, 0, input.length);\n        if (iv.length > 0) {\n          ByteBuffer byteBuffer = ByteBuffer.allocate(iv.length + encrypted.length);\n          byteBuffer.put(iv);\n          byteBuffer.put(encrypted);\n          return byteBuffer.array();\n        } else {\n          return encrypted;\n        }\n      } else {\n        assert(opmode == Cipher.DECRYPT_MODE);\n        if (cipherMode.usesSpec) {\n          AlgorithmParameterSpec algSpec = getParamSpec(cipherMode, input);\n          cipher.init(opmode, secretKey, algSpec);\n          if (aad != null && aad.length != 0) {\n            if (cipherMode.supportsAad != true) {\n              throw QueryExecutionErrors.aesUnsupportedAad(mode);\n            }\n            cipher.updateAAD(aad);\n          }\n          return cipher.doFinal(input, cipherMode.ivLength, input.length - cipherMode.ivLength);\n        } else {\n          cipher.init(opmode, secretKey);\n          return cipher.doFinal(input, 0, input.length);\n        }\n      }\n    } catch (GeneralSecurityException e) {\n      throw QueryExecutionErrors.aesCryptoError(e.getMessage());\n    }\n  }",
    "comment": "This may be 0-length for ECB\nIf the caller passes an IV, ensure the mode actually uses it.\nIf the cipher mode supports additional authenticated data and it is provided, update it"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/Encoders.java",
    "type": "method",
    "name": "encode",
    "code": "public static void encode(ByteBuf buf, RoaringBitmap b) {\n      // RoaringBitmap requires nio ByteBuffer for serde. We expose the netty ByteBuf as a nio\n      // ByteBuffer. Here, we need to explicitly manage the index so we can write into the\n      // ByteBuffer, and the write is reflected in the underneath ByteBuf.\n      ByteBuffer byteBuffer = buf.nioBuffer(buf.writerIndex(), buf.writableBytes());\n      b.serialize(byteBuffer);\n      buf.writerIndex(buf.writerIndex() + byteBuffer.position());\n    }",
    "comment": "The input ByteBuf for this encoder should have enough write capacity to fit the serialized\nbitmap. Other encoders which use {@link io.netty.buffer.AbstractByteBuf#writeBytes(byte[])}\nto write can expand the buf as writeBytes calls {@link ByteBuf#ensureWritable} internally.\nHowever, this encoder doesn't rely on netty's writeBytes and will fail if the input buf\ndoesn't have enough write capacity."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/RunnerBuilder.java",
    "type": "method",
    "name": "safeRunnerForClass",
    "code": "public Runner safeRunnerForClass(Class<?> testClass) {\n        try {\n            Runner runner = runnerForClass(testClass);\n            if (runner != null) {\n                configureRunner(runner);\n            }\n            return runner;\n        } catch (Throwable e) {\n            return new ErrorReportingRunner(testClass, e);\n        }\n    }",
    "comment": "Always returns a runner for the given test class.\n\n<p>In case of an exception a runner will be returned that prints an error instead of running\ntests.\n\n<p>Note that some of the internal JUnit implementations of RunnerBuilder will return\n{@code null} from this method, but no RunnerBuilder passed to a Runner constructor will\nreturn {@code null} from this method.\n\n@param testClass class to be run\n@return a Runner"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/testhelper/java/org/tensorflow/lite/TestHelper.java",
    "type": "method",
    "name": "getInputDims",
    "code": "public static int[] getInputDims(Interpreter interpreter, int index) {\n    if (interpreter != null && interpreter.wrapper != null) {\n      return interpreter.wrapper.getInputTensor(index).shape();\n    } else {\n      throw new IllegalArgumentException(\n          \"Interpreter has not initialized;\" + \" Failed to get input dimensions.\");\n    }\n  }",
    "comment": "Gets the dimensions of an input.\n\n@param interpreter an instance of {@code Interpreter}. If it is not initialized, an {@code\nIllegalArgumentException} will be thrown.\n@param index an integer index of the input. If it is invalid, an {@code\nIllegalArgumentException} will be thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Object expected, Object actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@see Object#equals(Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeWriter.java",
    "type": "method",
    "name": "UnsafeWriter",
    "code": "protected UnsafeWriter(BufferHolder holder) {\n    this.holder = holder;\n  }",
    "comment": "Base class for writing Unsafe* structures."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/ParserRequest.java",
    "type": "method",
    "name": "mvnenc",
    "code": "static Builder mvnenc(@Nonnull List<String> args, @Nonnull MessageBuilderFactory messageBuilderFactory) {\n        return builder(Tools.MVNENC_CMD, Tools.MVNENC_NAME, args, messageBuilderFactory);\n    }",
    "comment": "Creates a new Builder instance for constructing a Maven Encrypting Tool ParserRequest.\n\n@param args the command-line arguments\n@param messageBuilderFactory the factory for creating message builders\n@return a new Builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/UniqueIdTests.java",
    "type": "method",
    "name": "uniqueIdCanBeCreatedFromEngineId",
    "code": "void uniqueIdCanBeCreatedFromEngineId() {\n\t\t\tvar uniqueId = UniqueId.forEngine(ENGINE_ID);\n\n\t\t\tassertEquals(\"[engine:junit-jupiter]\", uniqueId.toString());\n\t\t\tassertSegment(uniqueId.getSegments().getFirst(), \"engine\", \"junit-jupiter\");\n\t\t}",
    "comment": "Unit tests for {@link UniqueId}.\n\n@since 1.0\n@see org.junit.jupiter.engine.execution.UniqueIdParsingForArrayParameterIntegrationTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaIsotonicRegressionExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    // Create a SparkSession.\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaIsotonicRegressionExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Loads data.\n    Dataset<Row> dataset = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_isotonic_regression_libsvm_data.txt\");\n\n    // Trains an isotonic regression model.\n    IsotonicRegression ir = new IsotonicRegression();\n    IsotonicRegressionModel model = ir.fit(dataset);\n\n    System.out.println(\"Boundaries in increasing order: \" + model.boundaries() + \"\\n\");\n    System.out.println(\"Predictions associated with the boundaries: \" + model.predictions() + \"\\n\");\n\n    // Makes predictions.\n    model.transform(dataset).show();\n    // $example off$\n\n    spark.stop();\n  }",
    "comment": "An example demonstrating IsotonicRegression.\nRun with\n<pre>\nbin/run-example ml.JavaIsotonicRegressionExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfig.java",
    "type": "method",
    "name": "addTestExecutionListeners",
    "code": "public Builder addTestExecutionListeners(TestExecutionListener... listeners) {\n\t\t\tPreconditions.notNull(listeners, \"TestExecutionListener array must not be null\");\n\t\t\tPreconditions.containsNoNullElements(listeners,\n\t\t\t\t\"TestExecutionListener array must not contain null elements\");\n\t\t\tCollections.addAll(this.executionListeners, listeners);\n\t\t\treturn this;\n\t\t}",
    "comment": "Add all of the supplied test execution listeners to the configuration.\n\n@param listeners additional test execution listeners to register;\nnever {@code null} or containing {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/test/java/com/iluwatar/identitymap/PersonDbSimulatorImplementationTest.java",
    "type": "method",
    "name": "updateNotInDb",
    "code": "void updateNotInDb() {\n    PersonDbSimulatorImplementation db = new PersonDbSimulatorImplementation();\n    Person person1 = new Person(1, \"Thomas\", 27304159);\n    Person person2 = new Person(2, \"John\", 42273631);\n    db.insert(person1);\n    db.insert(person2);\n    Person person3 = new Person(3, \"Micheal\", 25671234);\n    Assertions.assertThrows(IdNotFoundException.class, () -> db.update(person3));\n  }",
    "comment": "Test if IdNotFoundException is thrown when person with ID 3 is not in DB."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/ColumnDefaultValue.java",
    "type": "method",
    "name": "ColumnDefaultValue",
    "code": "public ColumnDefaultValue(String sql, Literal<?> value) {\n    this(sql, null /* no expression */, value);\n  }",
    "comment": "A class representing the default value of a column. It contains both the SQL string and literal\nvalue of the user-specified default value expression. The SQL string should be re-evaluated for\neach table writing command, which may produce different values if the default value expression is\nsomething like {@code CURRENT_DATE()}. The literal value is used to back-fill existing data if\nnew columns with default value are added. Note: the back-fill can be lazy. The data sources can\nremember the column default value and let the reader fill the column value when reading existing\ndata that do not have these new columns."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-api-gateway/image-microservice/src/main/java/com/iluwatar/image/microservice/ImageController.java",
    "type": "method",
    "name": "getImagePath",
    "code": "public String getImagePath() {\n    LOGGER.info(\"Successfully found image path\");\n    return \"/product-image.png\";\n  }",
    "comment": "An endpoint for a user to retrieve an image path.\n\n@return An image path"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkSubmitCommandBuilder.java",
    "type": "method",
    "name": "isThriftServer",
    "code": "private boolean isThriftServer(String mainClass) {\n    return (mainClass != null &&\n      mainClass.equals(\"org.apache.spark.sql.hive.thriftserver.HiveThriftServer2\"));\n  }",
    "comment": "Return whether the given main class represents a thrift server."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/Platform.java",
    "type": "method",
    "name": "getInt",
    "code": "public static int getInt(Object object, long offset) {\n    return _UNSAFE.getInt(object, offset);\n  }",
    "comment": "This class is duplicated from `org.apache.spark.unsafe.Platform` to make sure spark-sketch has no\nexternal dependencies."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/procedures/ProcedureParameter.java",
    "type": "method",
    "name": "comment",
    "code": "public Builder comment(String comment) {\n      this.comment = comment;\n      return this;\n    }",
    "comment": "Sets the comment of the parameter."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/HealthEndpointIntegrationTest.java",
    "type": "method",
    "name": "healthEndpointReturnsCompleteDetails",
    "code": "void healthEndpointReturnsCompleteDetails() {\n    // Make the HTTP request to the health endpoint\n    Response response = given(requestSpec).get(getEndpointBasePath()).andReturn();\n\n    // Log the response details\n    logResponseDetails(response);\n\n    // Check if the status is 503 (SERVICE_UNAVAILABLE)\n    if (response.getStatusCode() == HttpStatus.SERVICE_UNAVAILABLE.value()) {\n      LOGGER.warn(\n          \"Health endpoint returned 503 Service Unavailable. This may be due to CI pipeline \"\n              + \"configuration. Please check the CI pipeline logs.\");\n      response\n          .then()\n          .assertThat()\n          .statusCode(HttpStatus.SERVICE_UNAVAILABLE.value())\n          .log()\n          .all(); // Log the entire response for visibility\n      return;\n    }\n\n    // If status is 200, proceed with additional checks\n    response\n        .then()\n        .assertThat()\n        .statusCode(HttpStatus.OK.value()) // Check that the status is UP\n        .body(\"status\", equalTo(\"UP\")) // Verify the status body is UP\n        .body(\"components.cpu.status\", equalTo(\"UP\")) // Check CPU status\n        .body(\"components.db.status\", equalTo(\"UP\")) // Check DB status\n        .body(\"components.diskSpace.status\", equalTo(\"UP\")) // Check disk space status\n        .body(\"components.ping.status\", equalTo(\"UP\")) // Check ping status\n        .body(\"components.custom.status\", equalTo(\"UP\")); // Check custom component status\n\n    // Check for \"DOWN\" status and high CPU load\n    if (\"DOWN\".equals(response.path(\"status\"))) {\n      LOGGER.error(\"Health endpoint response: \" + response.getBody().asString());\n      LOGGER.error(\"Health endpoint status: \" + response.path(\"status\"));\n      LOGGER.error(\n          \"High CPU load detected: \" + response.path(\"components.cpu.details.processCpuLoad\"));\n    }\n  }",
    "comment": "Test that the health endpoint returns complete details about the application's health. If the\nstatus is 503, the test passes without further checks. If the status is 200, additional checks\nare performed on various components. In case of a \"DOWN\" status, the test logs the entire\nresponse for visibility."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertNotNull",
    "code": "public static void assertNotNull(String message, Object object) {\n        assertTrue(message, object != null);\n    }",
    "comment": "Asserts that an object isn't null. If it is an {@link AssertionError} is\nthrown with the given message.\n\n@param message the identifying message for the {@link AssertionError} (<code>null</code>\nokay)\n@param object Object to check or <code>null</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-runner/src/main/java/org/junit/platform/runner/JUnitPlatformTestTree.java",
    "type": "method",
    "name": "getTechnicalName",
    "code": "private String getTechnicalName(TestIdentifier testIdentifier) {\n\t\tOptional<TestSource> optionalSource = testIdentifier.getSource();\n\t\tif (optionalSource.isPresent()) {\n\t\t\tTestSource source = optionalSource.get();\n\t\t\tif (source instanceof ClassSource) {\n\t\t\t\treturn ((ClassSource) source).getJavaClass().getName();\n\t\t\t}\n\t\t\telse if (source instanceof MethodSource) {\n\t\t\t\tMethodSource methodSource = (MethodSource) source;\n\t\t\t\tString methodParameterTypes = methodSource.getMethodParameterTypes();\n\t\t\t\tif (StringUtils.isBlank(methodParameterTypes)) {\n\t\t\t\t\treturn methodSource.getMethodName();\n\t\t\t\t}\n\t\t\t\treturn String.format(\"%s(%s)\", methodSource.getMethodName(), methodParameterTypes);\n\t\t\t}\n\t\t}\n\n\t\treturn testIdentifier.getDisplayName();\n\t}",
    "comment": "Else fall back to display name"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-queue/src/main/java/com/iluwatar/event/queue/Audio.java",
    "type": "method",
    "name": "init",
    "code": "public void init() {\n    if (updateThread == null) {\n      updateThread =\n          new Thread(\n              () -> {\n                while (!Thread.currentThread().isInterrupted()) {\n                  update();\n                }\n              });\n    }\n    startThread();\n  }",
    "comment": "Starts the thread for the Update Method pattern if it was not started previously. Also, when\nthe thread is ready initializes the indexes of the queue"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/test/java/org/apache/spark/sql/hive/execution/UDFListListInt.java",
    "type": "method",
    "name": "evaluate",
    "code": "public long evaluate(Object obj) {\n    if (obj == null) {\n      return 0L;\n    }\n    List<List<?>> listList = (List<List<?>>) obj;\n    long retVal = 0;\n    for (List<?> aList : listList) {\n      Number someInt = (Number) aList.get(1);\n      try {\n        retVal += someInt.longValue();\n      } catch (NullPointerException e) {\n        System.out.println(e);\n      }\n    }\n    return retVal;\n  }",
    "comment": "@param obj\nSQL schema: array&lt;struct&lt;x: int, y: int, z: int&gt;&gt;\nJava Type: List&lt;List&lt;Integer&gt;&gt;"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "toUpperCaseSlow",
    "code": "private static UTF8String toUpperCaseSlow(final UTF8String target) {\n    return UTF8String.fromString(UCharacter.toUpperCase(target.toValidString()));\n  }",
    "comment": "Note: In order to achieve the desired behavior, we use the ICU UCharacter class to\nconvert the string to uppercase, which only accepts a Java strings as input."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TemporaryFolder.java",
    "type": "method",
    "name": "tryDelete",
    "code": "private boolean tryDelete() {\n        if (folder == null) {\n            return true;\n        }\n        \n        return recursiveDelete(folder);\n    }",
    "comment": "Tries to delete all files and folders under the temporary folder and\nreturns whether deletion was successful or not.\n\n@return {@code true} if all resources are deleted successfully,\n{@code false} otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/test/java/com/iluwatar/identitymap/IdentityMapTest.java",
    "type": "method",
    "name": "testGetFromMap",
    "code": "void testGetFromMap() {\n    IdentityMap idMap = new IdentityMap();\n    Person person1 = new Person(11, \"Michael\", 27304159);\n    Person person2 = new Person(22, \"John\", 42273631);\n    Person person3 = new Person(33, \"Arthur\", 27489171);\n    Person person4 = new Person(44, \"Finn\", 20499078);\n    Person person5 = new Person(55, \"Michael\", 40599078);\n    idMap.addPerson(person1);\n    idMap.addPerson(person2);\n    idMap.addPerson(person3);\n    idMap.addPerson(person4);\n    idMap.addPerson(person5);\n    Assertions.assertEquals(person1, idMap.getPerson(11), \"Incorrect person record returned\");\n    Assertions.assertEquals(person4, idMap.getPerson(44), \"Incorrect person record returned\");\n    Assertions.assertNull(idMap.getPerson(1), \"Incorrect person record returned\");\n  }",
    "comment": "new instance of an identity map(not connected to any DB here)\nDummy person instances\nAll records go into identity map\nTest for dummy persons in the map\nTest for person with given id not in map"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/PathModularization.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n        return getClass().getCanonicalName() + '[' + filename + ']';\n    }",
    "comment": "{@return a string representation of this object for debugging purposes}\nThis string representation may change in any future version."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/di/testing/MavenDIExtension.java",
    "type": "method",
    "name": "setContext",
    "code": "protected void setContext(ExtensionContext context) {\n        MavenDIExtension.context = context;\n    }",
    "comment": "Stores the extension context for use during test execution.\n\n@param context The extension context to store"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng2387InactiveProxyTest.java",
    "type": "method",
    "name": "MavenITmng2387InactiveProxyTest",
    "code": "public MavenITmng2387InactiveProxyTest() {\n        super(\"[2.0.11,2.1.0-M1),[2.1.0,)\"); // 2.0.11+, 2.1.0+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-2387\">MNG-2387</a>.\n\n@author Brett Porter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/ParserRequest.java",
    "type": "method",
    "name": "mvnsh",
    "code": "static Builder mvnsh(@Nonnull String[] args, @Nonnull MessageBuilderFactory messageBuilderFactory) {\n        return mvnsh(Arrays.asList(args), messageBuilderFactory);\n    }",
    "comment": "Creates a new Builder instance for constructing a Maven Shell Tool ParserRequest.\n\n@param args the command-line arguments\n@param messageBuilderFactory the factory for creating message builders\n@return a new Builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java",
    "type": "method",
    "name": "getResumeFromSelector",
    "code": "String getResumeFromSelector(List<MavenProject> mavenProjects, MavenProject firstFailedProject) {\n        boolean hasOverlappingArtifactId = mavenProjects.stream()\n                        .filter(project -> firstFailedProject.getArtifactId().equals(project.getArtifactId()))\n                        .count()\n                > 1;\n\n        if (hasOverlappingArtifactId) {\n            return firstFailedProject.getGroupId() + \":\" + firstFailedProject.getArtifactId();\n        }\n\n        return \":\" + firstFailedProject.getArtifactId();\n    }",
    "comment": "A helper method to determine the value to resume the build with {@code -rf} taking into account the edge case\nwhere multiple modules in the reactor have the same artifactId.\n<p>\n{@code -rf :artifactId} will pick up the first module which matches, but when multiple modules in the reactor\nhave the same artifactId, effective failed module might be later in build reactor.\nThis means that developer will either have to type groupId or wait for build execution of all modules which\nwere fine, but they are still before one which reported errors.\n<p>Then the returned value is {@code groupId:artifactId} when there is a name clash and\n{@code :artifactId} if there is no conflict.\nThis method is made package-private for testing purposes.\n\n@param mavenProjects Maven projects which are part of build execution.\n@param firstFailedProject The first project which has failed.\n@return Value for -rf flag to resume build exactly from place where it failed ({@code :artifactId} in general\nand {@code groupId:artifactId} when there is a name clash)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/graph/ProjectSelector.java",
    "type": "method",
    "name": "isMatchingProject",
    "code": "boolean isMatchingProject(MavenProject project, String selector, File reactorDirectory) {\n        if (selector.contains(\":\")) {\n            String id = ':' + project.getArtifactId();\n\n            if (id.equals(selector)) {\n                return true;\n            }\n\n            id = project.getGroupId() + id;\n\n            return id.equals(selector);\n        }\n\n        else if (reactorDirectory != null) {\n            File selectedProject =\n                    new File(new File(reactorDirectory, selector).toURI().normalize());\n\n            if (selectedProject.isFile()) {\n                return selectedProject.equals(project.getFile());\n            } else if (selectedProject.isDirectory()) {\n                return selectedProject.equals(project.getBasedir());\n            }\n        }\n\n        return false;\n    }",
    "comment": "[groupId]:artifactId\nrelative path, e.g. \"sub\", \"../sub\" or \".\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n    if (impl != null) {\n      impl.close();\n      impl = null;\n    }\n  }",
    "comment": "Frees TFLite resources in C runtime.\n\n<p>User is expected to call this method explicitly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "childrenInvoker",
    "code": "protected Statement childrenInvoker(final RunNotifier notifier) {\n        return new Statement() {\n        };\n    }",
    "comment": "Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\non each object returned by {@link #getChildren()} (subject to any imposed\nfilter and sort)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterExpressionEvaluator.java",
    "type": "method",
    "name": "PluginParameterExpressionEvaluator",
    "code": "public PluginParameterExpressionEvaluator(MavenSession session, MojoExecution mojoExecution) {\n        this.session = session;\n        this.mojoExecution = mojoExecution;\n        this.properties = new Properties();\n        this.project = session.getCurrentProject();\n\n        this.properties.putAll(session.getUserProperties());\n        this.properties.putAll(session.getSystemProperties());\n\n        String basedir = null;\n\n        if (project != null) {\n            File projectFile = project.getBasedir();\n\n            if (projectFile != null) {\n                basedir = projectFile.getAbsolutePath();\n            }\n        }\n\n        if (basedir == null) {\n            basedir = session.getExecutionRootDirectory();\n        }\n\n        if (basedir == null) {\n            basedir = System.getProperty(\"user.dir\");\n        }\n\n        this.basedir = basedir;\n    }",
    "comment": "Maven4: We may want to evaluate how this is used but we add these separate as the\ngetExecutionProperties is deprecated in MavenSession.\n\nthis should always be the case for non-super POM instances..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelProblemUtils.java",
    "type": "method",
    "name": "toId",
    "code": "static String toId(String groupId, String artifactId, String version) {\n        StringBuilder buffer = new StringBuilder(128);\n\n        buffer.append((groupId != null && groupId.length() > 0) ? groupId : \"[unknown-group-id]\");\n        buffer.append(':');\n        buffer.append((artifactId != null && artifactId.length() > 0) ? artifactId : \"[unknown-artifact-id]\");\n        buffer.append(':');\n        buffer.append((version != null && version.length() > 0) ? version : \"[unknown-version]\");\n\n        return buffer.toString();\n    }",
    "comment": "Creates a user-friendly artifact id from the specified coordinates.\n\n@param groupId The group id, may be {@code null}.\n@param artifactId The artifact id, may be {@code null}.\n@param version The version, may be {@code null}.\n@return The user-friendly artifact id, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "separateChunkFetchRequest",
    "code": "public boolean separateChunkFetchRequest() {\n    return conf.getInt(\"spark.shuffle.server.chunkFetchHandlerThreadsPercent\", 0) > 0;\n  }",
    "comment": "Whether to use a separate EventLoopGroup to process ChunkFetchRequest messages, it is decided\nby the config `spark.shuffle.server.chunkFetchHandlerThreadsPercent` is set or not."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/hash/Murmur3_x86_32Suite.java",
    "type": "method",
    "name": "randomizedStressTestBytes",
    "code": "public void randomizedStressTestBytes() {\n    int size = 65536;\n    Random rand = new Random();\n\n    Set<Integer> hashcodes = new HashSet<>();\n    for (int i = 0; i < size; i++) {\n      int byteArrSize = rand.nextInt(100) * 8;\n      byte[] bytes = new byte[byteArrSize];\n      rand.nextBytes(bytes);\n\n      Assertions.assertEquals(\n        hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize),\n        hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n\n      hashcodes.add(hasher.hashUnsafeWords(\n        bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n    }\n\n    Assertions.assertTrue(hashcodes.size() > size * 0.95);\n  }",
    "comment": "A set used to track collision rate.\nA very loose bound."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/test/java/com/example/android/persistence/migrations/UserRepositoryTest.java",
    "type": "method",
    "name": "updateUserName",
    "code": "public void updateUserName() {\n        UpdateUserCallback callback = mock(UpdateUserCallback.class);\n\n        mUserRepository.updateUserName(\"name\", callback);\n\n        verify(mUserDataSource).insertOrUpdateUser(mUserArgumentCaptor.capture());\n        User user = mUserArgumentCaptor.getValue();\n        assertEquals(\"name\", user.getUserName());\n        verify(callback).onUserUpdated(user);\n    }",
    "comment": "Given a callback for updating the username\nWhen updating the username\nThe user with the correct user name was saved\nThe callback is triggered"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/rtinfo/internal/DefaultRuntimeInformation.java",
    "type": "method",
    "name": "DefaultRuntimeInformation",
    "code": "public DefaultRuntimeInformation(VersionScheme versionScheme) {\n        this.versionScheme = versionScheme;\n        this.mavenVersion = loadMavenVersion();\n    }",
    "comment": "Provides information about the current Maven runtime."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/test/java/com/example/android/persistence/migrations/UserPresenterTest.java",
    "type": "method",
    "name": "updateUserName_updatesUserNameInRepo",
    "code": "public void updateUserName_updatesUserNameInRepo() {\n        mPresenter.updateUserName(\"user name\");\n\n        verify(mUserRepository).updateUserName(eq(\"user name\"), any(UpdateUserCallback.class));\n    }",
    "comment": "When updating the username\nThe userName is updated in the repository"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/WagonC.java",
    "type": "method",
    "name": "getSupportedProtocols",
    "code": "public String[] getSupportedProtocols() {\n        return new String[] {\"c\"};\n}",
    "comment": "Wagon for testing, for protocol <code>c</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "getBooleans",
    "code": "public boolean[] getBooleans(int rowId, int count) {\n    boolean[] res = new boolean[count];\n    for (int i = 0; i < count; i++) {\n      res[i] = getBoolean(rowId + i);\n    }\n    return res;\n  }",
    "comment": "Gets boolean type values from {@code [rowId, rowId + count)}. The return values for the null\nslots are undefined and can be anything."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/singleton/src/test/java/com/iluwatar/singleton/SingletonTest.java",
    "type": "method",
    "name": "SingletonTest",
    "code": "public SingletonTest(final Supplier<S> singletonInstanceMethod) {\n    this.singletonInstanceMethod = singletonInstanceMethod;\n  }",
    "comment": "Create a new singleton test instance using the given 'getInstance' method.\n\n@param singletonInstanceMethod The singleton's getInstance method"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Double> create(Scope scope, double[] data) {\n    return create(scope, data, Double.class);\n  }",
    "comment": "Creates a rank-1 constant of {@code double} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/version/DefaultPluginVersionRequest.java",
    "type": "method",
    "name": "DefaultPluginVersionRequest",
    "code": "public DefaultPluginVersionRequest(Plugin plugin, MavenSession session) {\n        setGroupId(plugin.getGroupId());\n        setArtifactId(plugin.getArtifactId());\n\n        setRepositorySession(session.getRepositorySession());\n\n        MavenProject project = session.getCurrentProject();\n        if (project != null) {\n            setRepositories(project.getRemotePluginRepositories());\n        }\n    }",
    "comment": "Creates a request for the specified plugin by copying settings from the specified build session. If the session\nhas a current project, its plugin repositories will be used as well.\n\n@param plugin The plugin for which to resolve a version, must not be {@code null}.\n@param session The Maven session to use, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "isVelocityError",
    "code": "private static boolean isVelocityError(String line) {\n        return line.contains(\"VM_global_library.vm\") || line.contains(\"VM #\") && line.contains(\"macro\");\n    }",
    "comment": "Checks whether the specified line is just an error message from Velocity. Especially old versions of Doxia employ\na very noisy Velocity instance.\n\n@param line The log line to check, must not be <code>null</code>.\n@return <code>true</code> if the line appears to be a Velocity error, <code>false</code> otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetColumnVector.java",
    "type": "method",
    "name": "setColumnReader",
    "code": "void setColumnReader(VectorizedColumnReader reader) {\n    if (!isPrimitive) {\n      throw new IllegalStateException(\"Can't set reader for non-primitive column\");\n    }\n    this.columnReader = reader;\n  }",
    "comment": "Sets the column vector to 'reader'. Note this can only be called on a primitive Parquet\ncolumn."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/Preconditions.java",
    "type": "method",
    "name": "checkNotNull",
    "code": "public static <T> T checkNotNull(/* @Nullable */ T reference) {\n    if (reference == null) {\n      throw new NullPointerException();\n    }\n    return reference;\n  }",
    "comment": "Ensures that an object reference passed as a parameter to the calling method is not null.\n\n<p>TODO(b/250876587): Consider adding proper annotation support.\n\n@param reference an object reference\n@return the non-null reference that was validated\n@throws NullPointerException if {@code reference} is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/MethodFilter.java",
    "type": "method",
    "name": "includeMethodNamePatterns",
    "code": "static MethodFilter includeMethodNamePatterns(String... patterns) {\n\t\treturn new IncludeMethodFilter(patterns);\n\t}",
    "comment": "Create a new <em>include</em> {@link MethodFilter} based on the\n@see Class#getName()\n@see Method#getName()\n@see #includeMethodNamePatterns(List)\n@see #excludeMethodNamePatterns(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/Trigger.java",
    "type": "method",
    "name": "Continuous",
    "code": "public static Trigger Continuous(Duration interval) {\n    return ContinuousTrigger.apply(interval);\n  }",
    "comment": "(Scala-friendly)\nA trigger that continuously processes streaming data, asynchronously checkpointing at\nthe specified interval.\n\n{{{\nimport scala.concurrent.duration._\ndf.writeStream.trigger(Trigger.Continuous(10.seconds))\n}}}\n@since 2.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java",
    "type": "method",
    "name": "resolve",
    "code": "public ArtifactResolutionResult resolve(ArtifactResolutionRequest request) {\n        /*\n         * Probably is not worth it, but here I make sure I restore request\n         * to its original state.\n         */\n        try {\n            LocalArtifactRepository ideWorkspace =\n                    plexus.lookup(LocalArtifactRepository.class, LocalArtifactRepository.IDE_WORKSPACE);\n\n            if (request.getLocalRepository() instanceof DelegatingLocalArtifactRepository delegatingLocalRepository) {\n                LocalArtifactRepository orig = delegatingLocalRepository.getIdeWorkspace();\n\n                delegatingLocalRepository.setIdeWorkspace(ideWorkspace);\n\n                try {\n                    return artifactResolver.resolve(request);\n                } finally {\n                    delegatingLocalRepository.setIdeWorkspace(orig);\n                }\n            } else {\n                ArtifactRepository localRepository = request.getLocalRepository();\n                DelegatingLocalArtifactRepository delegatingLocalRepository =\n                        new DelegatingLocalArtifactRepository(localRepository);\n                delegatingLocalRepository.setIdeWorkspace(ideWorkspace);\n                request.setLocalRepository(delegatingLocalRepository);\n                try {\n                    return artifactResolver.resolve(request);\n                } finally {\n                    request.setLocalRepository(localRepository);\n                }\n            }\n        } catch (ComponentLookupException e) {\n        }\n\n        return artifactResolver.resolve(request);\n    }",
    "comment": "no ide workspace artifact resolution"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Integer> create(Scope scope, int data) {\n    return create(scope, data, Integer.class);\n  }",
    "comment": "Creates a constant containing a single {@code int} element.\n\n@param scope is a scope used to add the underlying operation.\n@param data The value to put into the new constant.\n@return an integer constant"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/serialized-lob/src/main/java/com/iluwatar/slob/lob/Plant.java",
    "type": "method",
    "name": "toXmlElement",
    "code": "public Element toXmlElement(Document xmlDoc) {\n    Element root = xmlDoc.createElement(Plant.class.getSimpleName());\n    root.setAttribute(\"name\", name);\n    root.setAttribute(\"type\", type);\n    xmlDoc.appendChild(root);\n    return xmlDoc.getDocumentElement();\n  }",
    "comment": "Provides XML Representation of the Plant.\n\n@param xmlDoc to which the XML representation is to be written to\n@return XML Element contain the Animal representation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(byte expected, byte actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/database/MongoDb.java",
    "type": "method",
    "name": "writeToDb",
    "code": "public UserAccount writeToDb(final UserAccount userAccount) {\n    db.getCollection(USER_ACCOUNT)\n        .insertOne(\n            new Document(USER_ID, userAccount.getUserId())\n                .append(USER_NAME, userAccount.getUserName())\n                .append(ADD_INFO, userAccount.getAdditionalInfo()));\n    return userAccount;\n  }",
    "comment": "Write data to DB.\n\n@param userAccount {@link UserAccount}\n@return {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/tasks/ConsoleTestExecutor.java",
    "type": "method",
    "name": "executeTests",
    "code": "private TestExecutionSummary executeTests(PrintWriter out, Optional<Path> reportsDir) {\n\t\tLauncher launcher = launcherSupplier.get();\n\t\tSummaryGeneratingListener summaryListener = registerListeners(out, reportsDir, launcher);\n\n\t\tPrintStream originalOut = System.out;\n\t\tPrintStream originalErr = System.err;\n\t\ttry (StandardStreamsHandler standardStreamsHandler = new StandardStreamsHandler()) {\n\t\tfinally {\n\t\t\tSystem.setOut(originalOut);\n\t\t\tSystem.setErr(originalErr);\n\t\t}\n\n\t\tTestExecutionSummary summary = summaryListener.getSummary();\n\t\tif (summary.getTotalFailureCount() > 0 || outputOptions.getDetails() != Details.NONE) {\n\t\t\tprintSummary(summary, out);\n\t\t}\n\n\t\treturn summary;\n\t}\n\n\tprivate void launchTests(Launcher launcher, Optional<Path> reportsDir) {\n\t\tLauncherDiscoveryRequestBuilder discoveryRequestBuilder = toDiscoveryRequestBuilder(discoveryOptions);\n\t\treportsDir.ifPresent(dir -> discoveryRequestBuilder.configurationParameter(OUTPUT_DIR_PROPERTY_NAME,\n\t\t\tdir.toAbsolutePath().toString()));\n\t\tlauncher.execute(discoveryRequestBuilder.build());\n\t}\n\n\tprivate Optional<ClassLoader> createCustomClassLoader() {\n\t\tList<Path> additionalClasspathEntries = discoveryOptions.getExistingAdditionalClasspathEntries();\n\t\tif (!additionalClasspathEntries.isEmpty()) {\n\t\t\tURL[] urls = additionalClasspathEntries.stream().map(this::toURL).toArray(URL[]::new);\n\t\t\tClassLoader parentClassLoader = ClassLoaderUtils.getDefaultClassLoader();\n\t\t\tClassLoader customClassLoader = URLClassLoader.newInstance(urls, parentClassLoader);\n\t\t\treturn Optional.of(customClassLoader);\n\t\t}\n\t\treturn Optional.empty();\n\t}\n\n\tprivate URL toURL(Path path) {\n\t\ttry {\n\t\t\treturn path.toUri().toURL();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JUnitException(\"Invalid classpath entry: \" + path, ex);\n\t\t}\n\t}\n\n\tprivate SummaryGeneratingListener registerListeners(PrintWriter out, Optional<Path> reportsDir, Launcher launcher) {\n\t\tSummaryGeneratingListener summaryListener = new SummaryGeneratingListener();\n\t\tlauncher.registerTestExecutionListeners(summaryListener);\n\t\tcreateDetailsPrintingListener(out).ifPresent(launcher::registerTestExecutionListeners);\n\t\tcreateXmlWritingListener(out, reportsDir).ifPresent(launcher::registerTestExecutionListeners);\n\t\treturn summaryListener;\n\t}\n\n\tprivate Optional<DetailsPrintingListener> createDetailsPrintingListener(PrintWriter out) {\n\t\tColorPalette colorPalette = getColorPalette();\n\t\tTheme theme = outputOptions.getTheme();\n\t\tswitch (outputOptions.getDetails()) {\n\t\t\tcase SUMMARY:\n\t\t\t\treturn Optional.empty();\n\t\t\tcase FLAT:\n\t\t\t\treturn Optional.of(new FlatPrintingListener(out, colorPalette));\n\t\t\tcase TREE:\n\t\t\t\treturn Optional.of(new TreePrintingListener(out, colorPalette, theme));\n\t\t\tcase VERBOSE:\n\t\t\t\treturn Optional.of(new VerboseTreePrintingListener(out, colorPalette, 16, theme));\n\t\t\tcase TESTFEED:\n\t\t\t\treturn Optional.of(new TestFeedPrintingListener(out, colorPalette));\n\t\t\tdefault:\n\t\t\t\treturn Optional.empty();\n\t\t}\n\t}\n\n\tprivate ColorPalette getColorPalette() {\n\t\tif (outputOptions.isAnsiColorOutputDisabled()) {\n\t\t\treturn ColorPalette.NONE;\n\t\t}\n\t\tif (outputOptions.getColorPalettePath() != null) {\n\t\t\treturn new ColorPalette(outputOptions.getColorPalettePath());\n\t\t}\n\t\tif (outputOptions.isSingleColorPalette()) {\n\t\t\treturn ColorPalette.SINGLE_COLOR;\n\t\t}\n\t\treturn ColorPalette.DEFAULT;\n\t}\n\n\tprivate Optional<TestExecutionListener> createXmlWritingListener(PrintWriter out, Optional<Path> reportsDir) {\n\t\treturn reportsDir.map(it -> new LegacyXmlReportGeneratingListener(it, out));\n\t}\n\n\tprivate void printSummary(TestExecutionSummary summary, PrintWriter out) {\n\t\tif (EnumSet.of(Details.NONE, Details.SUMMARY, Details.TREE).contains(outputOptions.getDetails())) {\n\t\t\tsummary.printFailuresTo(out);\n\t\t}\n\t\tsummary.printTo(out);\n\t}\n\n\t@FunctionalInterface\n\tpublic interface Factory {\n\t\tConsoleTestExecutor create(TestDiscoveryOptions discoveryOptions, TestConsoleOutputOptions outputOptions);\n\t}\n\n}",
    "comment": "always register summary generating listener\noptionally, register test plan execution details printing listener\noptionally, register XML reports writing listener\nsummary listener is always created and registered\nOtherwise the failures have already been printed in detail"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "getKeyLength",
    "code": "public int getKeyLength() {\n      assert (isDefined);\n      return keyLength;\n    }",
    "comment": "Returns the length of the key defined at this position.\nUnspecified behavior if the key is not defined."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/LauncherServer.java",
    "type": "method",
    "name": "registerHandle",
    "code": "synchronized String registerHandle(AbstractAppHandle handle) {\n    String secret = createSecret();\n    secretToPendingApps.put(secret, handle);\n    return secret;\n  }",
    "comment": "Registers a handle with the server, and returns the secret the child app needs to connect\nback."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/server/StreamManager.java",
    "type": "method",
    "name": "openStream",
    "code": "public ManagedBuffer openStream(String streamId) {\n    throw new UnsupportedOperationException();\n  }",
    "comment": "Called in response to a stream() request. The returned data is streamed to the client\nthrough a single TCP connection.\n\nNote the <code>streamId</code> argument is not related to the similarly named argument in the\n{@link #getChunk(long, int)} method.\n\n@param streamId id of a stream that has been previously registered with the StreamManager.\n@return A managed buffer for the stream, or null if the stream was not found."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "pointTo",
    "code": "public void pointTo(Object baseObject, long baseOffset, int sizeInBytes) {\n    assert numFields >= 0 : \"numFields (\" + numFields + \") should >= 0\";\n    assert sizeInBytes % 8 == 0 : \"sizeInBytes (\" + sizeInBytes + \") should be a multiple of 8\";\n    if (baseObject instanceof byte[] bytes) {\n      int offsetInByteArray = (int) (baseOffset - Platform.BYTE_ARRAY_OFFSET);\n      if (offsetInByteArray < 0 || sizeInBytes < 0 ||\n          bytes.length < offsetInByteArray + sizeInBytes) {\n        throw new SparkIllegalArgumentException(\n          \"INTERNAL_ERROR\",\n          Map.of(\"message\", \"Invalid byte array backed UnsafeRow: byte array length=\" +\n            bytes.length + \", offset=\" + offsetInByteArray + \", byte size=\" + sizeInBytes)\n        );\n      }\n    }\n    this.baseObject = baseObject;\n    this.baseOffset = baseOffset;\n    this.sizeInBytes = sizeInBytes;\n  }",
    "comment": "Update this UnsafeRow to point to different backing data.\n\n@param baseObject the base object\n@param baseOffset the offset within the base object\n@param sizeInBytes the size of this row's backing data, in bytes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java",
    "type": "method",
    "name": "ClassTestDescriptor",
    "code": "public ClassTestDescriptor(UniqueId uniqueId, Class<?> testClass, JupiterConfiguration configuration) {\n\t\tsuper(uniqueId, testClass, createDisplayNameSupplierForClass(testClass, configuration), configuration);\n\t}",
    "comment": "{@link TestDescriptor} for tests based on Java classes.\n\n<h2>Default Display Names</h2>\n\n<p>The default display name for a top-level or nested static test class is\nthe fully qualified name of the class with the package name and leading dot\n(\".\") removed.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterApi.java",
    "type": "method",
    "name": "setCancellable",
    "code": "public Options setCancellable(boolean allow) {\n      this.allowCancellation = allow;\n      return this;\n    }",
    "comment": "Advanced: Set if the interpreter is able to be cancelled.\n\n<p>Interpreters may have an experimental API <a\nhref=\"https://www.tensorflow.org/lite/api_docs/java/org/tensorflow/lite/Interpreter#setCancelled(boolean)\">setCancelled(boolean)</a>.\nIf this interpreter is cancellable and such a method is invoked, a cancellation flag will be\nset to true. The interpreter will check the flag between Op invocations, and if it's {@code\ntrue}, the interpreter will stop execution. The interpreter will remain a cancelled state\nuntil explicitly \"uncancelled\" by {@code setCancelled(false)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerContextTests.java",
    "type": "method",
    "name": "executeTestsForClass",
    "code": "protected EngineExecutionResults executeTestsForClass(Class<?> testClass) {\n\t\treturn executeTests(requestBuilder(testClass).build());\n\t}",
    "comment": "Integration tests for the legacy behavior of the {@link TempDirectory}\nextension to create a single temp directory per context, i.e., test class or\nmethod.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/AutoCloseTests.java",
    "type": "method",
    "name": "allFieldsAreClosedIfAnyFieldThrowsAnException",
    "code": "void allFieldsAreClosedIfAnyFieldThrowsAnException() {\n\t\tassertThat(\"staticField1\".hashCode()).isLessThan(\"staticField2\".hashCode()).isLessThan(\n\t\t\t\"staticField3\".hashCode());\n\t\tassertThat(\"field1\".hashCode()).isLessThan(\"field2\".hashCode()).isLessThan(\"field3\".hashCode());\n\n\t\tClass<?> testClass = FailingFieldsTestCase.class;\n\t\tEngineExecutionResults allEvents = executeTestsForClass(testClass);\n\n\t\tEvents tests = allEvents.testEvents();\n\t\ttests.assertStatistics(stats -> stats.succeeded(0).failed(1));\n\n\t\tassertThat(recorder).containsExactly(//\n\t\t\t\"FailingFieldsTestCase.field1.close()\", //\n\t\t\t\"FailingFieldsTestCase.field2.close()\", //\n\t\t\t\"FailingFieldsTestCase.field3.close()\", //\n\t\t\t\"FailingFieldsTestCase.staticField1.close()\", //\n\t\t\t\"FailingFieldsTestCase.staticField2.close()\", //\n\t\t\t\"FailingFieldsTestCase.staticField3.close()\" //\n\t\t);\n\n\t\tassertThat(findFailure(tests, \"test()\")) //\n\t\t\t\t.isExactlyInstanceOf(RuntimeException.class) //\n\t\t\t\t.hasMessage(\"FailingFieldsTestCase.field1.close()\")//\n\t\t\t\t.hasNoCause()//\n\t\t\t\t.hasSuppressedException(new RuntimeException(\"FailingFieldsTestCase.field2.close()\"));\n\n\t\tEvents containers = allEvents.containerEvents();\n\t\tcontainers.assertStatistics(stats -> stats.succeeded(1).failed(1));\n\n\t\tassertThat(findFailure(containers, testClass.getSimpleName())) //\n\t\t\t\t.isExactlyInstanceOf(RuntimeException.class) //\n\t\t\t\t.hasMessage(\"FailingFieldsTestCase.staticField1.close()\")//\n\t\t\t\t.hasNoCause()//\n\t\t\t\t.hasSuppressedException(new RuntimeException(\"FailingFieldsTestCase.staticField2.close()\"));\n\t}",
    "comment": "Prerequisites to ensure fields are \"ordered\" as expected (based on the hash codes for their names).\nVerify that ALL fields were closed in the proper order.\nTest-level failures\nContainer-level failures"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "root",
    "code": "public static UniqueId root(String segmentType, String value) {\n\t\treturn new UniqueId(UniqueIdFormat.getDefault(), new Segment(segmentType, value));\n\t}",
    "comment": "Create a root unique ID from the supplied {@code segmentType} and\n{@code value} using the default format.\n\n@param segmentType the segment type; never {@code null} or blank\n@param value the value; never {@code null} or blank\n@see #forEngine(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/crypto/AuthServerBootstrap.java",
    "type": "method",
    "name": "AuthServerBootstrap",
    "code": "public AuthServerBootstrap(TransportConf conf, SecretKeyHolder secretKeyHolder) {\n    this.conf = conf;\n    this.secretKeyHolder = secretKeyHolder;\n  }",
    "comment": "A bootstrap which is executed on a TransportServer's client channel once a client connects\nto the server, enabling authentication using Spark's auth protocol (and optionally SASL for\nclients that don't support the new protocol).\n\nIt also automatically falls back to SASL if the new encryption backend is disabled, so that\ncallers only need to install this bootstrap when authentication is enabled."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "defaultToString",
    "code": "public static String defaultToString(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn \"null\";\n\t\t}\n\n\t\treturn obj.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(obj));\n\t}",
    "comment": "Convert the supplied {@code Object} to a <em>default</em> {@code String}\nrepresentation using the following algorithm.\n\n<ul>\n<li>If the supplied object is {@code null}, this method returns {@code \"null\"}.</li>\n<li>Otherwise, the String returned by this method will be generated analogous\nto the default implementation of {@link Object#toString()} by using the supplied\nobject's class name and hash code as follows:\n{@code obj.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(obj))}</li>\n</ul>\n\n@param obj the object to convert to a String; may be {@code null}\n@return the default String representation of the supplied object; never {@code null}\n@see #nullSafeToString(Object)\n@see ClassUtils#nullSafeToString(Class...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/repository/metadata/io/MetadataParseException.java",
    "type": "method",
    "name": "MetadataParseException",
    "code": "public MetadataParseException(String message, int lineNumber, int columnNumber) {\n        super(message);\n        this.lineNumber = lineNumber;\n        this.columnNumber = columnNumber;\n    }",
    "comment": "Creates a new parser exception with the specified details.\n\n@param message The error message, may be {@code null}.\n@param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.\n@param columnNumber The one-based index of the column containing the error or {@code -1} if unknown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/callback/src/test/java/com/iluwatar/callback/CallbackTest.java",
    "type": "method",
    "name": "test",
    "code": "void test() {\n    Callback callback = () -> callingCount++;\n\n    var task = new SimpleTask();\n\n    assertEquals(Integer.valueOf(0), callingCount, \"Initial calling count of 0\");\n\n    task.executeWith(callback);\n\n    assertEquals(Integer.valueOf(1), callingCount, \"Callback called once\");\n\n    task.executeWith(callback);\n\n    assertEquals(Integer.valueOf(2), callingCount, \"Callback called twice\");\n  }",
    "comment": "Add a field as a counter. Every time the callback method is called increment this field. Unit\ntest checks that the field is being incremented.\n\n<p>Could be done with mock objects as well where the call method call is verified."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Character unexpected, char actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Character) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/Lifecycle.java",
    "type": "method",
    "name": "setId",
    "code": "public void setId(String id) {\n        this.id = id;\n    } // -- void setId( String )",
    "comment": "Set the ID of this lifecycle, for identification in the mojo\ndescriptor.\n\n@param id a id object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/test/java/org/apache/spark/util/SparkLoggerSuiteBase.java",
    "type": "method",
    "name": "testBasicMsg",
    "code": "public void testBasicMsg() {\n    Runnable errorFn = () -> logger().error(basicMsg);\n    Runnable warnFn = () -> logger().warn(basicMsg);\n    Runnable infoFn = () -> logger().info(basicMsg);\n    Runnable debugFn = () -> logger().debug(basicMsg);\n    Runnable traceFn = () -> logger().trace(basicMsg);\n    List.of(\n        Pair.of(Level.ERROR, errorFn),\n        Pair.of(Level.WARN, warnFn),\n        Pair.of(Level.INFO, infoFn),\n        Pair.of(Level.DEBUG, debugFn),\n        Pair.of(Level.TRACE, traceFn)).forEach(pair ->\n      checkLogOutput(pair.getLeft(), pair.getRight(), this::expectedPatternForBasicMsg));\n  }",
    "comment": "test for message (with mdc - the value is null)\ntest for scala custom LogKey\ntest for java custom LogKey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/TestShuffleDataContext.java",
    "type": "method",
    "name": "createExecutorInfo",
    "code": "public ExecutorShuffleInfo createExecutorInfo(String shuffleManager) {\n    return new ExecutorShuffleInfo(localDirs, subDirsPerLocalDir, shuffleManager);\n  }",
    "comment": "Creates an ExecutorShuffleInfo object based on the given shuffle manager which targets this\ncontext's directories."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/ParserRequest.java",
    "type": "method",
    "name": "mvn",
    "code": "static Builder mvn(@Nonnull List<String> args, @Nonnull MessageBuilderFactory messageBuilderFactory) {\n        return builder(Tools.MVN_CMD, Tools.MVN_NAME, args, messageBuilderFactory);\n    }",
    "comment": "Creates a new Builder instance for constructing a Maven ParserRequest.\n\n@param args the command-line arguments\n@param messageBuilderFactory the factory for creating message builders\n@return a new Builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/org/apache/spark/streaming/JavaDurationSuite.java",
    "type": "method",
    "name": "testLess",
    "code": "public void testLess() {\n    Assertions.assertTrue(new Duration(999).less(new Duration(1000)));\n  }",
    "comment": "Just testing the methods that are specially exposed for Java.\nThis does not repeat all tests found in the Scala suite."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "byteStringAs",
    "code": "public static long byteStringAs(String str, ByteUnit unit) {\n    String lower = str.toLowerCase(Locale.ROOT).trim();\n\n    try {\n      Matcher m = BYTE_STRING_PATTERN.matcher(lower);\n      Matcher fractionMatcher = BYTE_STRING_FRACTION_PATTERN.matcher(lower);\n\n      if (m.matches()) {\n        long val = Long.parseLong(m.group(1));\n        String suffix = m.group(2);\n\n        // Check for invalid suffixes\n        if (suffix != null && !byteSuffixes.containsKey(suffix)) {\n          throw new NumberFormatException(\"Invalid suffix: \\\"\" + suffix + \"\\\"\");\n        }\n\n        // If suffix is valid use that, otherwise none was provided and use the default passed\n        return unit.convertFrom(val, suffix != null ? byteSuffixes.get(suffix) : unit);\n      } else if (fractionMatcher.matches()) {\n        throw new NumberFormatException(\"Fractional values are not supported. Input was: \"\n          + fractionMatcher.group(1));\n      } else {\n        throw new NumberFormatException(\"Failed to parse byte string: \" + str);\n      }\n\n    } catch (NumberFormatException e) {\n      String byteError = \"Size must be specified as bytes (b), \" +\n        \"kibibytes (k), mebibytes (m), gibibytes (g), tebibytes (t), or pebibytes(p). \" +\n        \"E.g. 50b, 100k, or 250m.\";\n\n      throw new NumberFormatException(byteError + \"\\n\" + e.getMessage());\n    }\n  }",
    "comment": "Convert a passed byte string (e.g. 50b, 100kb, or 250mb) to the given. If no suffix is\nprovided, a direct conversion to the provided unit is attempted."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/OnHeapColumnVector.java",
    "type": "method",
    "name": "allocateColumns",
    "code": "public static OnHeapColumnVector[] allocateColumns(int capacity, StructField[] fields) {\n    OnHeapColumnVector[] vectors = new OnHeapColumnVector[fields.length];\n    for (int i = 0; i < fields.length; i++) {\n      vectors[i] = new OnHeapColumnVector(capacity, fields[i].dataType());\n    }\n    return vectors;\n  }",
    "comment": "Allocates columns to store elements of each field on heap.\nCapacity is the initial capacity of the vector and it will grow as necessary. Capacity is\nin number of elements, not number of bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/flyweight/src/main/java/com/iluwatar/flyweight/PotionFactory.java",
    "type": "method",
    "name": "PotionFactory",
    "code": "public PotionFactory() {\n    potions = new EnumMap<>(PotionType.class);\n  }",
    "comment": "PotionFactory is the Flyweight in this example. It minimizes memory use by sharing object\ninstances. It holds a map of potion instances and new potions are created only when none of the\ntype already exists."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "append",
    "code": "public final UniqueId append(String segmentType, String value) {\n\t\treturn append(new Segment(segmentType, value));\n\t}",
    "comment": "Construct a new {@code UniqueId} by appending a new {@link Segment}, based\n{@code UniqueId}.\n\n<p>This {@code UniqueId} will not be modified.\n\n<p>Neither the {@code segmentType} nor the {@code value} may contain any\nof the special characters used for constructing the string representation\nof this {@code UniqueId}.\n\n@param segmentType the type of the segment; never {@code null} or blank\n@param value the value of the segment; never {@code null} or blank"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/test/org/apache/spark/JavaAPISuite.java",
    "type": "method",
    "name": "sparkContextUnion",
    "code": "public void sparkContextUnion() {\n    List<String> strings = Arrays.asList(\"Hello\", \"World\");\n    JavaRDD<String> s1 = sc.parallelize(strings);\n    JavaRDD<String> s2 = sc.parallelize(strings);\n    JavaRDD<String> sUnion = sc.union(s1, s2);\n    assertEquals(4, sUnion.count());\n\n    List<Double> doubles = Arrays.asList(1.0, 2.0);\n    JavaDoubleRDD d1 = sc.parallelizeDoubles(doubles);\n    JavaDoubleRDD d2 = sc.parallelizeDoubles(doubles);\n    JavaDoubleRDD dUnion = sc.union(d1, d2);\n    assertEquals(4, dUnion.count());\n\n    List<Tuple2<Integer, Integer>> pairs = new ArrayList<>();\n    pairs.add(new Tuple2<>(1, 2));\n    pairs.add(new Tuple2<>(3, 4));\n    JavaPairRDD<Integer, Integer> p1 = sc.parallelizePairs(pairs);\n    JavaPairRDD<Integer, Integer> p2 = sc.parallelizePairs(pairs);\n    JavaPairRDD<Integer, Integer> pUnion = sc.union(p1, p2);\n    assertEquals(4, pUnion.count());\n  }",
    "comment": "Union of non-specialized JavaRDDs\nVarargs\nUnion of JavaDoubleRDDs\nUnion of JavaPairRDDs"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-sourcing/src/main/java/com/iluwatar/event/sourcing/processor/JsonFileJournal.java",
    "type": "method",
    "name": "readNext",
    "code": "public DomainEvent readNext() {\n    if (index >= events.size()) {\n      return null;\n    }\n    var event = events.get(index);\n    index++;\n\n    var mapper = new ObjectMapper();\n    DomainEvent domainEvent;\n    try {\n      var jsonElement = mapper.readTree(event);\n      var eventClassName = jsonElement.get(\"eventClassName\").asText();\n      domainEvent =\n          switch (eventClassName) {\n            case \"AccountCreateEvent\" -> mapper.treeToValue(jsonElement, AccountCreateEvent.class);\n            case \"MoneyDepositEvent\" -> mapper.treeToValue(jsonElement, MoneyDepositEvent.class);\n            case \"MoneyTransferEvent\" -> mapper.treeToValue(jsonElement, MoneyTransferEvent.class);\n            default -> throw new RuntimeException(\"Journal Event not recognized\");\n          };\n    } catch (JsonProcessingException jsonProcessingException) {\n      throw new RuntimeException(\"Failed to convert JSON\");\n    }\n\n    domainEvent.setRealTime(false);\n    return domainEvent;\n  }",
    "comment": "Read the next domain event.\n\n@return the domain event"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(byte unexpected, Byte actual, String message) {\n\t\tAssertNotEquals.assertNotEquals((Byte) unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "selectors",
    "code": "public LauncherDiscoveryRequestBuilder selectors(DiscoverySelector... selectors) {\n\t\tPreconditions.notNull(selectors, \"selectors array must not be null\");\n\t\tselectors(Arrays.asList(selectors));\n\t\treturn this;\n\t}",
    "comment": "Add all supplied {@code selectors} to the request.\n\n@param selectors the {@code DiscoverySelectors} to add; never {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/resource-managers/yarn/src/main/java/org/apache/spark/deploy/yarn/AmIpServletRequestWrapper.java",
    "type": "method",
    "name": "isUserInRole",
    "code": "public boolean isUserInRole(String role) {\n    return false;\n  }",
    "comment": "No role info so far"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextStoreTests.java",
    "type": "method",
    "name": "getOrDefaultWithNoValuePresent",
    "code": "void getOrDefaultWithNoValuePresent() {\n\t\tassertThat(store.get(KEY)).isNull();\n\n\t\tassertThat(store.getOrDefault(KEY, boolean.class, true)).isTrue();\n\t\tassertThat(store.getOrDefault(KEY, String.class, VALUE)).isEqualTo(VALUE);\n\t}",
    "comment": "Unit tests for {@link NamespaceAwareStore} and {@link NamespacedHierarchicalStore}.\n\n@since 5.5\n@see ExtensionContextStoreConcurrencyTests\n@see ExtensionValuesStoreTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-idempotent-consumer/src/main/java/com/iluwatar/idempotentconsumer/App.java",
    "type": "method",
    "name": "run",
    "code": "public CommandLineRunner run(RequestService requestService, RequestRepository requestRepository) {\n    return args -> {\n      Request req = requestService.create(UUID.randomUUID());\n      requestService.create(req.getUuid());\n      requestService.create(req.getUuid());\n      LOGGER.info(\n          \"Nb of requests : {}\", requestRepository.count()); // 1, processRequest is idempotent\n      req = requestService.start(req.getUuid());\n      try {\n        req = requestService.start(req.getUuid());\n      } catch (InvalidNextStateException ex) {\n        LOGGER.error(\"Cannot start request twice!\");\n      }\n      req = requestService.complete(req.getUuid());\n      LOGGER.info(\"Request: {}\", req);\n    };\n  }",
    "comment": "The starting point of the CommandLineRunner where the main program is run.\n\n@param requestService idempotent request service\n@param requestRepository request jpa repository"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "isRuntimePathElement",
    "code": "private static boolean isRuntimePathElement(final String scope) {\n        return Artifact.SCOPE_COMPILE.equals(scope) || Artifact.SCOPE_RUNTIME.equals(scope);\n    }",
    "comment": "TODO let the scope handler deal with this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/launcher/listeners/SummaryGenerationTests.java",
    "type": "method",
    "name": "reportingCorrectFailures",
    "code": "void reportingCorrectFailures() {\n\t\tvar iaeCausedBy = new IllegalArgumentException(\"Illegal Argument Exception\");\n\t\tvar failedException = new RuntimeException(\"Runtime Exception\", iaeCausedBy);\n\t\tvar npeSuppressed = new NullPointerException(\"Null Pointer Exception\");\n\t\tfailedException.addSuppressed(npeSuppressed);\n\n\t\tvar testDescriptor = new TestDescriptorStub(UniqueId.root(\"root\", \"2\"), \"failingTest\") {\n\t\t};\n\t\tvar failed = TestIdentifier.from(testDescriptor);\n\t\tvar aborted = TestIdentifier.from(new TestDescriptorStub(UniqueId.root(\"root\", \"3\"), \"abortedTest\"));\n\n\t\tlistener.testPlanExecutionStarted(testPlan);\n\t\tlistener.executionStarted(failed);\n\t\tlistener.executionFinished(failed, TestExecutionResult.failed(failedException));\n\t\tlistener.executionStarted(aborted);\n\t\tlistener.executionFinished(aborted, TestExecutionResult.aborted(new RuntimeException(\"aborted\")));\n\t\tlistener.testPlanExecutionFinished(testPlan);\n\n\t\tassertEquals(1, listener.getSummary().getTestsFailedCount());\n\n\t\tvar failuresString = failuresAsString();\n\t\tassertAll(\"failures\", //\n\t\t\t() -> assertTrue(failuresString.contains(\"Failures (1)\"), \"test failures\"), //\n\t\t\t() -> assertTrue(failuresString.contains(Object.class.getName()), \"source\"), //\n\t\t\t() -> assertTrue(failuresString.contains(\"failingTest\"), \"display name\"), //\n\t\t\t() -> assertTrue(failuresString.contains(\"=> \" + failedException), \"main exception\"), //\n\t\t\t() -> assertTrue(failuresString.contains(\"Caused by: \" + iaeCausedBy), \"Caused by exception\"), //\n\t\t\t() -> assertTrue(failuresString.contains(\"Suppressed: \" + npeSuppressed), \"Suppressed exception\") //\n\t\t);\n\t}",
    "comment": "An aborted test is not a failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterApi.java",
    "type": "method",
    "name": "addDelegate",
    "code": "public Options addDelegate(Delegate delegate) {\n      delegates.add(delegate);\n      return this;\n    }",
    "comment": "Adds a {@link Delegate} to be applied during interpreter creation.\n\n<p>Delegates added here are applied before any delegates created from a {@link\nDelegateFactory} that was added with {@link #addDelegateFactory}.\n\n<p>Note that TF Lite in Google Play Services (see {@link #setRuntime}) does not support\nexternal (developer-provided) delegates, and adding a {@link Delegate} other than {@link\nNnApiDelegate} here is not allowed when using TF Lite in Google Play Services."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/buffer/NettyManagedBuffer.java",
    "type": "method",
    "name": "NettyManagedBuffer",
    "code": "public NettyManagedBuffer(ByteBuf buf) {\n    this.buf = buf;\n  }",
    "comment": "A {@link ManagedBuffer} backed by a Netty {@link ByteBuf}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(short expected, Short actual) {\n\t\tAssertEquals.assertEquals((Short) expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/MethodMap.java",
    "type": "method",
    "name": "isApplicable",
    "code": "private static boolean isApplicable(Method method, Class<?>... classes) {\n        Class<?>[] methodArgs = method.getParameterTypes();\n\n        if (methodArgs.length != classes.length) {\n            return false;\n        }\n\n        for (int i = 0; i < classes.length; ++i) {\n            if (!isMethodInvocationConvertible(methodArgs[i], classes[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }",
    "comment": "Returns true if the supplied method is applicable to actual\nargument types.\n\n@param method  The method to check for applicability\n@param classes The arguments\n@return true if the method applies to the parameter types"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/EngineDiscoveryListener.java",
    "type": "method",
    "name": "EngineDiscoveryListener",
    "code": "EngineDiscoveryListener NOOP = new EngineDiscoveryListener() {\n\n\tdefault void selectorProcessed(UniqueId engineId, DiscoverySelector selector, SelectorResolutionResult result) {\n\t}\n\n\t@API(status = EXPERIMENTAL, since = \"1.13\")\n\tdefault void issueEncountered(UniqueId engineId, DiscoveryIssue issue) {\n\t}\n\n}",
    "comment": "Called when the engine with the supplied {@code engineId} encountered an\nissue during test discovery.\n\n@param engineId the unique ID of the engine descriptor\n@param issue the encountered issue\n@since 1.13\n@see DiscoveryIssue"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/TensorFlowMultiBoxDetector.java",
    "type": "method",
    "name": "TensorFlowMultiBoxDetector",
    "code": "final String outputScoresName) {\n    final TensorFlowMultiBoxDetector d = new TensorFlowMultiBoxDetector();\n\n    d.inferenceInterface = new TensorFlowInferenceInterface(assetManager, modelFilename);\n\n    final Graph g = d.inferenceInterface.graph();\n\n    d.inputName = inputName;\n    // The inputName node has a shape of [N, H, W, C], where\n    // N is the batch size\n    // H = W are the height and width\n    // C is the number of channels (3 for our purposes - RGB)\n    final Operation inputOp = g.operation(inputName);\n    if (inputOp == null) {\n      throw new RuntimeException(\"Failed to find input Node '\" + inputName + \"'\");\n    }\n    d.inputSize = (int) inputOp.output(0).shape().size(1);\n    d.imageMean = imageMean;\n    d.imageStd = imageStd;\n    // The outputScoresName node has a shape of [N, NumLocations], where N\n    // is the batch size.\n    final Operation outputOp = g.operation(outputScoresName);\n    if (outputOp == null) {\n      throw new RuntimeException(\"Failed to find output Node '\" + outputScoresName + \"'\");\n    }\n    d.numLocations = (int) outputOp.output(0).shape().size(1);\n\n    d.boxPriors = new float[d.numLocations * 8];\n\n    try {\n      d.loadCoderOptions(assetManager, locationFilename, d.boxPriors);\n    } catch (final IOException e) {\n      throw new RuntimeException(\"Error initializing box priors from \" + locationFilename, e);\n    }\n\n    // Pre-allocate buffers.\n    d.outputNames = new String[] {outputLocationsName, outputScoresName};\n\n  private TensorFlowMultiBoxDetector() {}\n\n  private void loadCoderOptions(\n      final AssetManager assetManager, final String locationFilename, final float[] boxPriors)\n      throws IOException {\n    // Try to be intelligent about opening from assets or sdcard depending on prefix.\n    final String assetPrefix = \"file:///android_asset/\";\n    InputStream is;\n    if (locationFilename.startsWith(assetPrefix)) {\n      is = assetManager.open(locationFilename.split(assetPrefix)[1]);\n    } else {\n      is = new FileInputStream(locationFilename);\n    }\n\n    // Read values. Number of values per line doesn't matter, as long as they are separated\n    // by commas and/or whitespace, and there are exactly numLocations * 8 values total.\n    // Values are in the order mean, std for each consecutive corner of each box, for a total of 8\n    // per location.\n    final BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n    int priorIndex = 0;\n    String line;\n    while ((line = reader.readLine()) != null) {\n      final StringTokenizer st = new StringTokenizer(line, \", \");\n      while (st.hasMoreTokens()) {\n        final String token = st.nextToken();\n        try {\n          final float number = Float.parseFloat(token);\n          boxPriors[priorIndex++] = number;\n        } catch (final NumberFormatException e) {\n          // Silently ignore.\n        }\n      }\n    }\n    if (priorIndex != boxPriors.length) {\n      throw new RuntimeException(\n          \"BoxPrior length mismatch: \" + priorIndex + \" vs \" + boxPriors.length);\n    }\n  }\n\n  private float[] decodeLocationsEncoding(final float[] locationEncoding) {\n    final float[] locations = new float[locationEncoding.length];\n    boolean nonZero = false;\n    for (int i = 0; i < numLocations; ++i) {\n      for (int j = 0; j < 4; ++j) {\n        final float currEncoding = locationEncoding[4 * i + j];\n        nonZero = nonZero || currEncoding != 0.0f;\n\n        final float mean = boxPriors[i * 8 + j * 2];\n        final float stdDev = boxPriors[i * 8 + j * 2 + 1];\n        float currentLocation = currEncoding * stdDev + mean;\n        currentLocation = Math.max(currentLocation, 0.0f);\n        currentLocation = Math.min(currentLocation, 1.0f);\n        locations[4 * i + j] = currentLocation;\n      }\n    }\n\n    if (!nonZero) {\n      LOGGER.w(\"No non-zero encodings; check log for inference errors.\");\n    }\n    return locations;\n  }\n\n  private float[] decodeScoresEncoding(final float[] scoresEncoding) {\n    final float[] scores = new float[scoresEncoding.length];\n    for (int i = 0; i < scoresEncoding.length; ++i) {\n      scores[i] = 1 / ((float) (1 + Math.exp(-scoresEncoding[i])));\n    }\n    return scores;\n  }\n\n  @Override\n  public List<Recognition> recognizeImage(final Bitmap bitmap) {\n    // Log this method so that it can be analyzed with systrace.\n    Trace.beginSection(\"recognizeImage\");\n\n    Trace.beginSection(\"preprocessBitmap\");\n    // Preprocess the image data from 0-255 int to normalized float based\n    // on the provided parameters.\n    bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());\n\n    for (int i = 0; i < intValues.length; ++i) {\n      floatValues[i * 3 + 0] = (((intValues[i] >> 16) & 0xFF) - imageMean) / imageStd;\n      floatValues[i * 3 + 1] = (((intValues[i] >> 8) & 0xFF) - imageMean) / imageStd;\n      floatValues[i * 3 + 2] = ((intValues[i] & 0xFF) - imageMean) / imageStd;\n    }\n    Trace.endSection(); // preprocessBitmap\n\n    // Copy the input data into TensorFlow.\n    Trace.beginSection(\"feed\");\n    inferenceInterface.feed(inputName, floatValues, 1, inputSize, inputSize, 3);\n    Trace.endSection();\n\n    // Run the inference call.\n    Trace.beginSection(\"run\");\n    inferenceInterface.run(outputNames, logStats);\n    Trace.endSection();\n\n    // Copy the output Tensor back into the output array.\n    Trace.beginSection(\"fetch\");\n    final float[] outputScoresEncoding = new float[numLocations];\n    final float[] outputLocationsEncoding = new float[numLocations * 4];\n    inferenceInterface.fetch(outputNames[0], outputLocationsEncoding);\n    inferenceInterface.fetch(outputNames[1], outputScoresEncoding);\n    Trace.endSection();\n\n    outputLocations = decodeLocationsEncoding(outputLocationsEncoding);\n    outputScores = decodeScoresEncoding(outputScoresEncoding);\n\n    // Find the best detections.\n    final PriorityQueue<Recognition> pq =\n        new PriorityQueue<Recognition>(\n            1,\n            new Comparator<Recognition>() {\n            });\n\n    // Scale them back to the input size.\n    for (int i = 0; i < outputScores.length; ++i) {\n      final RectF detection =\n          new RectF(\n              outputLocations[4 * i] * inputSize,\n              outputLocations[4 * i + 1] * inputSize,\n              outputLocations[4 * i + 2] * inputSize,\n              outputLocations[4 * i + 3] * inputSize);\n      pq.add(new Recognition(\"\" + i, null, outputScores[i], detection));\n    }\n\n    final ArrayList<Recognition> recognitions = new ArrayList<Recognition>();\n    for (int i = 0; i < Math.min(pq.size(), MAX_RESULTS); ++i) {\n      recognitions.add(pq.poll());\n    }\n    Trace.endSection(); // \"recognizeImage\"\n    return recognitions;\n  }\n\n  @Override\n  public void enableStatLogging(final boolean logStats) {\n    this.logStats = logStats;\n  }\n\n  @Override\n  public String getStatString() {\n    return inferenceInterface.getStatString();\n  }\n\n  @Override\n  public void close() {\n    inferenceInterface.close();\n  }\n}",
    "comment": "Initializes a native TensorFlow session for classifying images.\n\n@param assetManager The asset manager to be used to load assets.\n@param modelFilename The filepath of the model GraphDef protocol buffer.\n@param locationFilename The filepath of label file for classes.\n@param inputSize The input size. A square image of inputSize x inputSize is assumed.\n@param imageMean The assumed mean of the image values.\n@param imageStd The assumed std of the image values.\n@param inputName The label of the image input node.\n@param outputName The label of the output node."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-migrationsupport/src/main/java/org/junit/jupiter/migrationsupport/conditions/IgnoreCondition.java",
    "type": "method",
    "name": "evaluateExecutionCondition",
    "code": "public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {\n\t\tAnnotatedElement element = context.getElement().orElse(null);\n\t\treturn findAnnotation(element, Ignore.class) //\n\t\t\t\t.map(annotation -> toResult(element, annotation)) //\n\t\t\t\t.orElse(ENABLED);\n\t}",
    "comment": "Containers/tests are disabled if {@link Ignore @Ignore} is present on\nthe test class or method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "dataType",
    "code": "public final DataType dataType() { return type; }",
    "comment": "Returns the data type of this column vector."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerSession.java",
    "type": "method",
    "name": "devicePlacementPolicy",
    "code": "public Options devicePlacementPolicy(DevicePlacementPolicy value) {\n      devicePlacementPolicy = value;\n      return this;\n    }",
    "comment": "Controls how to act when we try to run an operation on a given device but some input tensors\nare not on that device.\n\n<p>{@link DevicePlacementPolicy#SILENT} is used by default.\n\n@param value policy to apply\n@see DevicePlacementPolicy"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/UriSource.java",
    "type": "method",
    "name": "from",
    "code": "static UriSource from(URI uri) {\n\t\tPreconditions.notNull(uri, \"URI must not be null\");\n\n\t\ttry {\n\t\t\tURI uriWithoutQuery = ResourceUtils.stripQueryComponent(uri);\n\t\t\tPath path = Paths.get(uriWithoutQuery);\n\t\t\tif (Files.isRegularFile(path)) {\n\t\t\t\treturn FileSource.from(path.toFile(), FilePosition.fromQuery(uri.getQuery()).orElse(null));\n\t\t\t}\n\t\t\tif (Files.isDirectory(path)) {\n\t\t\t\treturn DirectorySource.from(path.toFile());\n\t\t\t}\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tLoggerFactory.getLogger(UriSource.class).debug(ex, () -> String.format(\n\t\t\t\t\"The supplied URI [%s] is not path-based. Falling back to default UriSource implementation.\", uri));\n\t\t}\n\n\t\t// Store supplied URI as-is\n\t\treturn new DefaultUriSource(uri);\n\t}",
    "comment": "Create a new {@code UriSource} using the supplied {@code URI}.\nto a path-based {@code UriSource} in the local filesystem. If that fails\nfor any reason, an instance of the default {@code UriSource}\nimplementation storing the supplied {@code URI} <em>as-is</em> will be\nreturned.\n\n@param uri the URI to use as the source; never {@code null}\n@return an appropriate {@code UriSource} for the supplied {@code URI}\n@since 1.3\n@see org.junit.platform.engine.support.descriptor.FileSource\n@see org.junit.platform.engine.support.descriptor.DirectorySource"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TemporaryFolder.java",
    "type": "method",
    "name": "TemporaryFolder",
    "code": "protected TemporaryFolder(Builder builder) {\n        this.parentFolder = builder.parentFolder;\n        this.assureDeletion = builder.assureDeletion;\n    }",
    "comment": "Create a {@link TemporaryFolder} initialized with\nvalues from a builder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/multiton/src/test/java/com/iluwatar/multiton/NazgulTest.java",
    "type": "method",
    "name": "testGetInstance",
    "code": "void testGetInstance() {\n    for (final var name : NazgulName.values()) {\n      final var nazgul = Nazgul.getInstance(name);\n      assertNotNull(nazgul);\n      assertSame(nazgul, Nazgul.getInstance(name));\n      assertEquals(name, nazgul.getName());\n    }\n  }",
    "comment": "Verify if {@link Nazgul#getInstance(NazgulName)} returns the correct Nazgul multiton instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/InvalidPluginException.java",
    "type": "method",
    "name": "InvalidPluginException",
    "code": "public InvalidPluginException(String message, ProjectBuildingException e) {\n        super(message, e);\n    }",
    "comment": "Thrown when a plugin is not internally consistent."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/JavaModuleOptions.java",
    "type": "method",
    "name": "defaultModuleOptions",
    "code": "public static String defaultModuleOptions() {\n      return String.join(\" \", DEFAULT_MODULE_OPTIONS);\n    }",
    "comment": "Returns the default JVM runtime options used by Spark."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/plugin/testing/stubs/MojoExecutionStub.java",
    "type": "method",
    "name": "MojoExecutionStub",
    "code": "public MojoExecutionStub(String executionId, String goal) {\n        this(executionId, goal, null);\n    }",
    "comment": "A stub implementation of {@link MojoExecution} for testing Maven plugins.\nThis class provides a simplified representation of a Mojo execution context,\nallowing tests to simulate plugin executions without a full Maven environment.\n\n<p>Example usage:</p>\n<pre>\nMojoExecutionStub execution = new MojoExecutionStub(\"myExecution\", \"myGoal\");\nexecution.setPlugin(new PluginStub());\nexecution.setDescriptor(mojoDescriptor);\n</pre>\n\n@see MojoExecution\n@see PluginStub\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/OffHeapColumnVector.java",
    "type": "method",
    "name": "allocateColumns",
    "code": "public static OffHeapColumnVector[] allocateColumns(int capacity, StructType schema) {\n    return allocateColumns(capacity, schema.fields());\n  }",
    "comment": "Allocates columns to store elements of each field of the schema off heap.\nCapacity is the initial capacity of the vector and it will grow as necessary. Capacity is\nin number of elements, not number of bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlob",
    "code": "public static Tensor fromBlob(ByteBuffer data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_BUFFER_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.capacity(), shape);\n    checkArgument(data.isDirect(), ERROR_MSG_DATA_BUFFER_MUST_BE_DIRECT);\n    checkArgument(\n        (data.order() == ByteOrder.nativeOrder()),\n        ERROR_MSG_DATA_BUFFER_MUST_HAVE_NATIVE_BYTE_ORDER);\n    return new Tensor_int8(data, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.int8 with specified shape and data.\n\n@param data Direct buffer with native byte order that contains {@code Tensor.numel(shape)}\nelements. The buffer is used directly without copying, and changes to its content will\nchange the tensor.\n@param shape Tensor shape"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaCorrelationExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaCorrelationExample\")\n      .getOrCreate();\n\n    // $example on$\n    List<Row> data = Arrays.asList(\n      RowFactory.create(Vectors.sparse(4, new int[]{0, 3}, new double[]{1.0, -2.0})),\n      RowFactory.create(Vectors.sparse(4, new int[]{0, 3}, new double[]{9.0, 1.0}))\n    StructType schema = new StructType(new StructField[]{\n\n    Dataset<Row> df = spark.createDataFrame(data, schema);\n    Row r1 = Correlation.corr(df, \"features\").head();\n    System.out.println(\"Pearson correlation matrix:\\n\" + r1.get(0).toString());\n\n    Row r2 = Correlation.corr(df, \"features\", \"spearman\").head();\n    System.out.println(\"Spearman correlation matrix:\\n\" + r2.get(0).toString());\n    // $example off$\n\n    spark.stop();\n  }\n}",
    "comment": "An example for computing correlation matrix.\nRun with\n<pre>\nbin/run-example ml.JavaCorrelationExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-suite-engine/src/main/java/org/junit/platform/suite/engine/ClassSelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "public Resolution resolve(UniqueIdSelector selector, Context context) {\n\t\tUniqueId uniqueId = selector.getUniqueId();\n\t\tUniqueId engineId = suiteEngineDescriptor.getUniqueId();\n\t\tList<Segment> resolvedSegments = engineId.getSegments();\n\t\treturn uniqueId.getSegments()\n\t\t\t\t.stream()\n\t\t\t\t.skip(resolvedSegments.size())\n\t\t\t\t.findFirst()\n\t\t\t\t.filter(suiteSegment -> SuiteTestDescriptor.SEGMENT_TYPE.equals(suiteSegment.getType()))\n\t\t\t\t.flatMap(ClassSelectorResolver::tryLoadSuiteClass)\n\t\t\t\t.filter(isSuiteClass)\n\t\t\t\t.map(suiteClass -> context\n\t\t\t\t\t\t.addToParent(parent -> newSuiteDescriptor(suiteClass, parent))\n\t\t\t\t\t\t.map(suite -> uniqueId.equals(suite.getUniqueId())\n\t\t\t\t\t\t\t\t? suite.addDiscoveryRequestFrom(suiteClass)\n\t\t\t\t\t\t\t\t: suite.addDiscoveryRequestFrom(uniqueId)))\n\t\t\t\t.map(ClassSelectorResolver::toResolution)\n\t\t\t\t.orElseGet(Resolution::unresolved);\n\t}",
    "comment": "@formatter:off\nThe uniqueId selector either targeted a class annotated with @Suite;\nor a specific test in that suite\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/InMemoryStore.java",
    "type": "method",
    "name": "InstanceList",
    "code": "private InstanceList(Class<?> klass) {\n      this.ti = new KVTypeInfo(klass);\n      this.naturalKey = ti.getAccessor(KVIndex.NATURAL_INDEX_NAME);\n      this.data = new ConcurrentHashMap<>();\n      this.naturalParentIndexName = ti.getParentIndexName(KVIndex.NATURAL_INDEX_NAME);\n      this.parentToChildrenMap = new ConcurrentHashMap<>();\n      this.hasNaturalParentIndex = !naturalParentIndexName.isEmpty();\n    }",
    "comment": "A mapping from parent to the natural keys of its children.\nFor example, a mapping from a stage ID to all the task IDs in the stage."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/SettingsBuilder.java",
    "type": "method",
    "name": "validate",
    "code": "default ProblemCollector<BuilderProblem> validate(@Nonnull Settings settings) {\n        return validate(settings, false);\n    }",
    "comment": "Validate the specified settings.\n\n@param settings The settings to validate, must not be {@code null}.\n@return The list of problems that were encountered, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(char unexpected, char actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/PackedRecordPointer.java",
    "type": "method",
    "name": "packPointer",
    "code": "public static long packPointer(long recordPointer, int partitionId) {\n    assert (partitionId <= MAXIMUM_PARTITION_ID);\n    // Note that without word alignment we can address 2^27 bytes = 128 megabytes per page.\n    // Also note that this relies on some internals of how TaskMemoryManager encodes its addresses.\n    final long pageNumber = (recordPointer & MASK_LONG_UPPER_13_BITS) >>> 24;\n    final long compressedAddress = pageNumber | (recordPointer & MASK_LONG_LOWER_27_BITS);\n    return (((long) partitionId) << 40) | compressedAddress;\n  }",
    "comment": "Pack a record address and partition id into a single word.\n\n@param recordPointer a record pointer encoded by TaskMemoryManager.\n@param partitionId a shuffle partition id (maximum value of 2^24).\n@return a packed pointer that can be decoded using the {@link PackedRecordPointer} class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/AnnotationSupport.java",
    "type": "method",
    "name": "findAnnotation",
    "code": "public static <A extends Annotation> Optional<A> findAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\treturn AnnotationUtils.findAnnotation(element, annotationType);\n\t}",
    "comment": "Find the first annotation of {@code annotationType} that is either\n<em>directly present</em>, <em>meta-present</em>, or <em>indirectly\npresent</em> on the supplied {@code element}.\n\n<p>If the element is a class and the annotation is neither <em>directly\npresent</em> nor <em>meta-present</em> on the class, this method will\nadditionally search on interfaces implemented by the class before\nfinding an annotation that is <em>indirectly present</em> on the class.\n\n@param <A> the annotation type\n@param element the element on which to search for the annotation; may be\n{@code null}\n@param annotationType the annotation type to search for; never {@code null}\n@return an {@code Optional} containing the annotation; never {@code null} but\npotentially empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/memory/TestPartialSpillingMemoryConsumer.java",
    "type": "method",
    "name": "TestPartialSpillingMemoryConsumer",
    "code": "public TestPartialSpillingMemoryConsumer(TaskMemoryManager memoryManager, MemoryMode mode) {\n    super(memoryManager, mode);\n  }",
    "comment": "A TestMemoryConsumer which, when asked to spill, releases only enough memory to satisfy the\nrequest rather than releasing all its memory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-distributed-tracing/order-microservice/src/main/java/com/iluwatar/order/microservice/OrderService.java",
    "type": "method",
    "name": "processPayment",
    "code": "Boolean processPayment() {\n    try {\n      ResponseEntity<Boolean> paymentProcessResult =\n          restTemplateBuilder\n              .build()\n              .postForEntity(\n                  \"http://localhost:30301/payment/process\", \"processing payment\", Boolean.class);\n      LOGGER.info(\"Payment processing result: {}\", paymentProcessResult.getBody());\n      return paymentProcessResult.getBody();\n    } catch (ResourceAccessException | HttpClientErrorException e) {\n      LOGGER.error(\"Error communicating with payment service: {}\", e.getMessage());\n      return false;\n    }\n  }",
    "comment": "Validates the product by calling the respective microservice.\n\n@return true if the product is valid, false otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/BuildFailure.java",
    "type": "method",
    "name": "BuildFailure",
    "code": "public BuildFailure(MavenProject project, long time, Throwable cause) {\n        this(project, Duration.ofMillis(time), cause);\n    }",
    "comment": "Creates a new build summary for the specified project.\n\n@param project The project being summarized, must not be {@code null}.\n@param time The build time of the project in milliseconds.\n@param cause The cause of the build failure, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/ResourceUtils.java",
    "type": "method",
    "name": "packageName",
    "code": "private static String packageName(String classpathResourceName) {\n\t\tint lastIndexOf = classpathResourceName.lastIndexOf(CLASSPATH_RESOURCE_PATH_SEPARATOR);\n\t\tif (lastIndexOf < 0) {\n\t\t\treturn DEFAULT_PACKAGE_NAME;\n\t\t}\n\t\tString resourcePackagePath = classpathResourceName.substring(0, lastIndexOf);\n\t\treturn resourcePackagePath.replace(CLASSPATH_RESOURCE_PATH_SEPARATOR, PACKAGE_SEPARATOR_CHAR);\n\t}",
    "comment": "classpath resource names do not start with"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/OldestConflictResolverTest.java",
    "type": "method",
    "name": "testEqual",
    "code": "void testEqual() {\n        ResolutionNode a1n = createResolutionNode(a1);\n        ResolutionNode a2n = createResolutionNode(a2);\n\n        assertResolveConflict(a1n, a1n, a2n);\n    }",
    "comment": "Tests that <code>a:1.0</code> wins in the scenario:\n<pre>\na:1.0\na:2.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dependency-injection/src/test/java/com/iluwatar/dependency/injection/SimpleWizardTest.java",
    "type": "method",
    "name": "testSmoke",
    "code": "void testSmoke() {\n    final var simpleWizard = new SimpleWizard();\n    simpleWizard.smoke();\n    assertEquals(\"SimpleWizard smoking OldTobyTobacco\", appender.getLastMessage());\n    assertEquals(1, appender.getLogSize());\n  }",
    "comment": "Test if the {@link SimpleWizard} does the only thing it can do: Smoke it's {@link\nOldTobyTobacco}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java",
    "type": "method",
    "name": "throwsExceptionWhenParameterizedTestIsNotInvokedAtLeastOnce",
    "code": "void throwsExceptionWhenParameterizedTestIsNotInvokedAtLeastOnce() {\n\t\tvar extensionContextWithAnnotatedTestMethod = getExtensionContextReturningSingleMethod(\n\t\t\tnew TestCaseWithAnnotatedMethod());\n\n\t\tvar stream = this.parameterizedTestExtension.provideTestTemplateInvocationContexts(\n\t\t\textensionContextWithAnnotatedTestMethod);\n\t\tstream.toArray();\n\t\tvar exception = assertThrows(TemplateInvocationValidationException.class, stream::close);\n\n\t\tassertThat(exception).hasMessage(\n\t\t\t\"Configuration error: You must configure at least one set of arguments for this @ParameterizedTest\");\n\t}",
    "comment": "cause the stream to be evaluated"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/ring/RingInstance.java",
    "type": "method",
    "name": "handleHeartbeatInvokeMessage",
    "code": "protected void handleHeartbeatInvokeMessage() {\n    try {\n      var isLeaderAlive = messageManager.sendHeartbeatMessage(this.leaderId);\n      if (isLeaderAlive) {\n        LOGGER.info(INSTANCE + localId + \"- Leader is alive. Start next heartbeat in 5 second.\");\n        Thread.sleep(HEARTBEAT_INTERVAL);\n        messageManager.sendHeartbeatInvokeMessage(this.localId);\n      } else {\n        LOGGER.info(INSTANCE + localId + \"- Leader is not alive. Start election.\");\n        messageManager.sendElectionMessage(this.localId, String.valueOf(this.localId));\n      }\n    } catch (InterruptedException e) {\n      LOGGER.info(INSTANCE + localId + \"- Interrupted.\");\n    }\n  }",
    "comment": "Process the heartbeat invoke message. After receiving the message, the instance will send a\nheartbeat to leader to check its health. If alive, it will inform the next instance to do the\nheartbeat. If not, it will start the election process."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Character expected, Character actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/DefaultUpdateCheckManager.java",
    "type": "method",
    "name": "getRepositoryKey",
    "code": "String getRepositoryKey(ArtifactRepository repository) {\n        StringBuilder buffer = new StringBuilder(256);\n\n        Proxy proxy = repository.getProxy();\n        if (proxy != null) {\n            if (proxy.getUserName() != null) {\n                int hash = (proxy.getUserName() + proxy.getPassword()).hashCode();\n                buffer.append(hash).append('@');\n            }\n            buffer.append(proxy.getHost()).append(':').append(proxy.getPort()).append('>');\n        }\n\n        Authentication auth = repository.getAuthentication();\n        if (auth != null) {\n            int hash = (auth.getUsername() + auth.getPassword()).hashCode();\n            buffer.append(hash).append('@');\n        }\n\n        buffer.append(repository.getUrl());\n\n        return buffer.toString();\n    }",
    "comment": "consider the username&password because a repo manager might block artifacts depending on authorization\nconsider the URL (instead of the id) as this most closely relates to the contents in the repo"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProjectBuilderRequest.java",
    "type": "method",
    "name": "path",
    "code": "public ProjectBuilderRequestBuilder path(Path path) {\n            this.path = path;\n            return this;\n        }",
    "comment": "Sets the path to the project to build.\nThis is typically the path to a pom.xml file or a directory containing a pom.xml file.\n\n@param path the path to the project\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom2/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "deleteAndGetUser",
    "code": "public void deleteAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        mDataSource.deleteAllUsers();\n\n        User dbUser = mDataSource.getUser();\n        assertNull(dbUser);\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are deleting all users\nThe user is no longer in the data source"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/condition/DisabledIfEnvironmentVariableCondition.java",
    "type": "method",
    "name": "getEnvironmentVariable",
    "code": "protected String getEnvironmentVariable(String name) {\n\t\treturn System.getenv(name);\n\t}",
    "comment": "Get the value of the named environment variable.\n\n<p>The default implementation delegates to\n{@link System#getenv(String)}. Can be overridden in a subclass for\ntesting purposes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "UnsafeRow",
    "code": "public UnsafeRow(int numFields) {\n    this.numFields = numFields;\n    this.bitSetWidthInBytes = calculateBitSetWidthInBytes(numFields);\n  }",
    "comment": "Construct a new UnsafeRow. The resulting row won't be usable until `pointTo()` has been called,\nsince the value returned by this constructor is equivalent to a null pointer.\n\n@param numFields the number of fields in this row"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3671PluginLevelDepInterpolationTest.java",
    "type": "method",
    "name": "MavenITmng3671PluginLevelDepInterpolationTest",
    "code": "public MavenITmng3671PluginLevelDepInterpolationTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3671\">MNG-3671</a>.\n\nTests to make sure that custom plugin dependencies (defined in your local POM) have\ntheir information interpolated before they are injected into the plugin descriptor\nfor eventual resolution and inclusion in the plugin classpath. Otherwise, resolution\nerrors will occur and the plugin will fail to initialize.\n\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/server/OneForOneStreamManagerSuite.java",
    "type": "method",
    "name": "streamStatesAreFreeOrNotWhenConnectionIsClosed",
    "code": "public void streamStatesAreFreeOrNotWhenConnectionIsClosed() {\n    OneForOneStreamManager manager = new OneForOneStreamManager();\n    ManagedBuffer mockManagedBuffer = Mockito.mock(ManagedBuffer.class);\n\n    Iterator<ManagedBuffer> buffers1 = Mockito.mock(Iterator.class);\n    Mockito.when(buffers1.hasNext()).thenReturn(true).thenReturn(false);\n    Mockito.when(buffers1.next()).thenReturn(mockManagedBuffer);\n\n    Iterator<ManagedBuffer> buffers2 = Mockito.mock(Iterator.class);\n    Mockito.when(buffers2.hasNext()).thenReturn(true);\n    Mockito.when(buffers2.next()).thenReturn(mockManagedBuffer);\n\n    Channel dummyChannel = Mockito.mock(Channel.class, Mockito.RETURNS_SMART_NULLS);\n    manager.registerStream(\"appId\", buffers1, dummyChannel, false);\n    manager.registerStream(\"appId\", buffers2, dummyChannel, true);\n    Assertions.assertEquals(2, manager.numStreamStates());\n\n    manager.connectionTerminated(dummyChannel);\n\n    Mockito.verify(buffers1, Mockito.times(2)).hasNext();\n    Mockito.verify(buffers1, Mockito.times(1)).next();\n\n    Mockito.verify(buffers2, Mockito.times(0)).hasNext();\n    Mockito.verify(buffers2, Mockito.times(0)).next();\n    Mockito.verify(mockManagedBuffer, Mockito.times(1)).release();\n    Assertions.assertEquals(0, manager.numStreamStates());\n  }",
    "comment": "should Release,\nshould NOT Release\nconnectionTerminated\nonly buffers1 has been released"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportFrameDecoder.java",
    "type": "method",
    "name": "decodeFrameSize",
    "code": "private long decodeFrameSize() {\n    if (nextFrameSize != UNKNOWN_FRAME_SIZE || totalSize < LENGTH_SIZE) {\n      return nextFrameSize;\n    }\n\n    ByteBuf first = buffers.getFirst();\n    if (first.readableBytes() >= LENGTH_SIZE) {\n      nextFrameSize = first.readLong() - LENGTH_SIZE;\n      totalSize -= LENGTH_SIZE;\n      if (!first.isReadable()) {\n        buffers.removeFirst().release();\n      }\n      return nextFrameSize;\n    }\n\n    while (frameLenBuf.readableBytes() < LENGTH_SIZE) {\n      ByteBuf next = buffers.getFirst();\n      int toRead = Math.min(next.readableBytes(), LENGTH_SIZE - frameLenBuf.readableBytes());\n      frameLenBuf.writeBytes(next, toRead);\n      if (!next.isReadable()) {\n        buffers.removeFirst().release();\n      }\n    }\n\n    nextFrameSize = frameLenBuf.readLong() - LENGTH_SIZE;\n    totalSize -= LENGTH_SIZE;\n    frameLenBuf.clear();\n    return nextFrameSize;\n  }",
    "comment": "We know there's enough data. If the first buffer contains all the data, great. Otherwise,\nhold the bytes for the frame length in a composite buffer until we have enough data to read\nthe frame size. Normally, it should be rare to need more than one buffer to read the frame\nsize."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/FilterCompositionTests.java",
    "type": "method",
    "name": "composingNoFiltersCreatesFilterThatIncludesEverything",
    "code": "void composingNoFiltersCreatesFilterThatIncludesEverything() {\n\t\tvar composedFilter = Filter.composeFilters();\n\n\t\tassertTrue(composedFilter.apply(String.class).included());\n\t\tassertTrue(composedFilter.toPredicate().test(String.class));\n\t\tassertTrue(composedFilter.apply(Object.class).included());\n\t\tassertTrue(composedFilter.toPredicate().test(Object.class));\n\t}",
    "comment": "Unit tests for {@link Filter#composeFilters}.\n\n{@link Filter#composeFilters} will delegate to {@linkplain CompositeFilter} under the hood.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/backpressure/src/main/java/com/iluwatar/backpressure/Publisher.java",
    "type": "method",
    "name": "publish",
    "code": "public static Flux<Integer> publish(int start, int count, int delay) {\n    return Flux.range(start, count).delayElements(Duration.ofMillis(delay)).log();\n  }",
    "comment": "On message method will trigger when the subscribed event is published.\n\n@param start starting integer\n@param count how many integers to emit\n@param delay delay between each item in milliseconds\n@return a flux stream of integers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/UnsafeExternalRowSorter.java",
    "type": "method",
    "name": "setTestSpillFrequency",
    "code": "void setTestSpillFrequency(int frequency) {\n    assert frequency > 0 : \"Frequency must be positive\";\n    testSpillFrequency = frequency;\n  }",
    "comment": "Forces spills to occur every `frequency` records. Only for use in tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "openCamera",
    "code": "private void openCamera(final int width, final int height) {\n    setUpCameraOutputs();\n    configureTransform(width, height);\n    final Activity activity = getActivity();\n    final CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);\n    try {\n      if (!cameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {\n        throw new RuntimeException(\"Time out waiting to lock camera opening.\");\n      }\n      manager.openCamera(cameraId, stateCallback, backgroundHandler);\n    } catch (final CameraAccessException e) {\n      LOGGER.e(e, \"Exception!\");\n    } catch (final InterruptedException e) {\n      throw new RuntimeException(\"Interrupted while trying to lock camera opening.\", e);\n    }\n  }",
    "comment": "Opens the camera specified by {@link CameraConnectionFragment#cameraId}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/delegation/src/main/java/com/iluwatar/delegation/simple/PrinterController.java",
    "type": "method",
    "name": "PrinterController",
    "code": "public PrinterController(Printer printer) {\n    this.printer = printer;\n  }",
    "comment": "Delegator Class to delegate the implementation of the Printer. This ensures two things: - when\nthe actual implementation of the Printer class changes the delegation will still be operational -\nthe actual benefit is observed when there are more than one implementor, and they share a\ndelegation control"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/test/java/com/iluwatar/async/method/invocation/ThreadAsyncExecutorTest.java",
    "type": "method",
    "name": "testLongRunningTaskWithCallback",
    "code": "void testLongRunningTaskWithCallback() {\n    assertTimeout(\n        ofMillis(5000),\n        () -> {\n          // Instantiate a new executor and start a new 'null' task ...\n          final var executor = new ThreadAsyncExecutor();\n\n          final var result = new Object();\n          when(task.call())\n              .thenAnswer(\n                  i -> {\n                    Thread.sleep(1500);\n                    return result;\n                  });\n\n          final var asyncResult = executor.startProcess(task, callback);\n          assertNotNull(asyncResult);\n          assertFalse(asyncResult.isCompleted());\n\n          verifyNoMoreInteractions(callback);\n\n          try {\n            asyncResult.getValue();\n            fail(\n                \"Expected IllegalStateException when calling AsyncResult#getValue on a non-completed task\");\n          } catch (IllegalStateException e) {\n            assertNotNull(e.getMessage());\n          }\n\n          // Our task should only execute once, but it can take a while ...\n          verify(task, timeout(3000).times(1)).call();\n          verify(callback, timeout(3000).times(1)).onComplete(eq(result));\n          verify(callback, times(0)).onError(isA(Exception.class));\n\n          // Prevent timing issues, and wait until the result is available\n          asyncResult.await();\n          assertTrue(asyncResult.isCompleted());\n          verifyNoMoreInteractions(task, callback);\n\n          // ... and the result should be exactly the same object\n          assertSame(result, asyncResult.getValue());\n        });\n  }",
    "comment": "Test used to verify the happy path of {@link ThreadAsyncExecutor#startProcess(Callable,\nAsyncCallback)} when a task takes a while to execute"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/HiveSQLException.java",
    "type": "method",
    "name": "HiveSQLException",
    "code": "public HiveSQLException(TStatus status) {\n    super(status.getErrorMessage(), status.getSqlState(), status.getErrorCode());\n    if (status.getInfoMessages() != null) {\n      initCause(toCause(status.getInfoMessages()));\n    }\n  }",
    "comment": "TODO: set correct vendorCode field"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Character expected, char actual) {\n\t\tAssertEquals.assertEquals(expected, (Character) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "getDescription",
    "code": "public Description getDescription() {\n        Class<?> clazz = getTestClass().getJavaClass();\n        Description description;\n        if (clazz == null || !clazz.getName().equals(getName())) {\n            description = Description.createSuiteDescription(getName(), getRunnerAnnotations());\n        } else {\n            description = Description.createSuiteDescription(clazz, getRunnerAnnotations());\n        }\n\n        for (T child : getFilteredChildren()) {\n            description.addChild(describeChild(child));\n        }\n        return description;\n    }",
    "comment": "Implementation of Runner\n\nif subclass overrides `getName()` then we should use it\nto maintain backwards compatibility with JUnit 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "codePointFrom",
    "code": "public int codePointFrom(int byteIndex) {\n    if (byteIndex < 0 || byteIndex >= numBytes) {\n      throw new IndexOutOfBoundsException();\n    }\n    byte b = getByte(byteIndex);\n    int numBytes = numBytesForFirstByte(b);\n    return switch (numBytes) {\n      case 1 ->\n        b & 0x7F;\n      case 2 ->\n        ((b & 0x1F) << 6) | (getByte(byteIndex + 1) & 0x3F);\n      case 3 ->\n        ((b & 0x0F) << 12) | ((getByte(byteIndex + 1) & 0x3F) << 6) |\n        (getByte(byteIndex + 2) & 0x3F);\n      case 4 ->\n        ((b & 0x07) << 18) | ((getByte(byteIndex + 1) & 0x3F) << 12) |\n        ((getByte(byteIndex + 2) & 0x3F) << 6) | (getByte(byteIndex + 3) & 0x3F);\n      default ->\n        throw new IllegalStateException(\"Error in UTF-8 code point\");\n    };\n  }",
    "comment": "Returns the code point starting from the byte at position `byteIndex`.\nIf byte index is invalid, throws exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/money/src/test/java/com/iluwater/money/MoneyTest.java",
    "type": "method",
    "name": "testMultiply",
    "code": "void testMultiply() {\n    Money money = new Money(100.00, \"USD\");\n\n    money.multiply(3);\n\n    assertEquals(300.00, money.getAmount(), \"Amount after multiplication should be 300.00\");\n  }",
    "comment": "Test multiplying the money amount by a factor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/main/java/com/example/android/observability/ui/UserActivity.java",
    "type": "method",
    "name": "onCreate",
    "code": "protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_user);\n\n        mUserName = findViewById(R.id.user_name);\n        mUserNameInput = findViewById(R.id.user_name_input);\n        mUpdateButton = findViewById(R.id.update_user);\n\n        mViewModelFactory = Injection.provideViewModelFactory(this);\n        mViewModel = new ViewModelProvider(this, mViewModelFactory).get(UserViewModel.class);\n        mUpdateButton.setOnClickListener(v -> updateUserName());\n    }",
    "comment": "Main screen of the app. Displays a user name and gives the option to update the user name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/conversion/FallbackStringToObjectConverter.java",
    "type": "method",
    "name": "test",
    "code": "public boolean test(Method method) {\n\t\t\tif (!method.getReturnType().equals(this.targetType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (isNotStatic(method)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn isNotPrivateAndAcceptsSingleStringArgument(method);\n\t\t}",
    "comment": "Please do not collapse the following into a single statement."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/org/apache/spark/sql/execution/streaming/state/POJOTestClass.java",
    "type": "method",
    "name": "equals",
    "code": "public boolean equals(Object obj) {\n    POJOTestClass testObj = (POJOTestClass) obj;\n    return id == testObj.id && name.equals(testObj.name);\n  }",
    "comment": "Override equals and hashCode for custom equality"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/trampoline/src/main/java/com/iluwatar/trampoline/Trampoline.java",
    "type": "method",
    "name": "more",
    "code": "static <T> Trampoline<T> more(final Trampoline<Trampoline<T>> trampoline) {\n    return new Trampoline<T>() {\n\n      @Override\n      public Trampoline<T> jump() {\n        return trampoline.result();\n      }\n\n      @Override\n      public T get() {\n        return trampoline(this);\n      }\n\n      T trampoline(final Trampoline<T> trampoline) {\n        return Stream.iterate(trampoline, Trampoline::jump)\n            .filter(Trampoline::complete)\n            .findFirst()\n            .map(Trampoline::result)\n            .get();\n      }\n    };\n  }",
    "comment": "Create a Trampoline that has more work to do.\n\n@param trampoline Next stage in Trampoline\n@return Trampoline with more work"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/CompositeTestSource.java",
    "type": "method",
    "name": "from",
    "code": "public static CompositeTestSource from(Collection<? extends TestSource> sources) {\n\t\treturn new CompositeTestSource(sources);\n\t}",
    "comment": "Create a new {@code CompositeTestSource} based on the supplied\n\n<p>This constructor makes a defensive copy of the supplied collection\nand stores the sources as a list in the order in which they are\nreturned by the collection's iterator.\n\n@param sources the collection of sources to store in this\n{@code CompositeTestSource}; never {@code null} or empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertionFailureBuilder.java",
    "type": "method",
    "name": "reason",
    "code": "public AssertionFailureBuilder reason(String reason) {\n\t\tthis.reason = reason;\n\t\treturn this;\n\t}",
    "comment": "Set the reason why the assertion failed.\n\n@param reason the failure reason; may be {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/BeforeAndAfterAllTests.java",
    "type": "method",
    "name": "beforeAllAndAfterAllCallbacksInSubSubclassWithoutStaticMethodHiding",
    "code": "void beforeAllAndAfterAllCallbacksInSubSubclassWithoutStaticMethodHiding() {\n\t\t// NOTE: both the @BeforeAll AND the @AfterAll methods in level 3 are\n\t\t// executed as 1/2/3 due to the \"stable\" method sort order on the Platform.\n\n\t\t// @formatter:off\n\t\tassertBeforeAllAndAfterAllCallbacks(ThirdLevelStaticHidingTestCase.class,\n\t\t\t\"fooBeforeAllCallback\",\n\t\t\t\"barBeforeAllCallback\",\n\t\t\t\t\"bazBeforeAllCallback\",\n\t\t\t\t\t\"quuxBeforeAllCallback\",\n\t\t\t\t\t\t\"beforeAllMethod-1\",\n\t\t\t\t\t\t\t\"beforeAllMethod-2\",\n\t\t\t\t\t\t\t\t\"beforeAllMethod-1-level3\",\n\t\t\t\t\t\t\t\t\"beforeAllMethod-2-level3\",\n\t\t\t\t\t\t\t\t\"beforeAllMethod-3-level3\",\n\t\t\t\t\t\t\t\t\t\"test-3\",\n\t\t\t\t\t\t\t\t\"afterAllMethod-1-level3\",\n\t\t\t\t\t\t\t\t\"afterAllMethod-2-level3\",\n\t\t\t\t\t\t\t\t\"afterAllMethod-3-level3\",\n\t\t\t\t\t\t\t\"afterAllMethod-2\",\n\t\t\t\t\t\t\"afterAllMethod-1\",\n\t\t\t\t\t\"quuxAfterAllCallback\",\n\t\t\t\t\"bazAfterAllCallback\",\n\t\t\t\"barAfterAllCallback\",\n\t\t\t\"fooAfterAllCallback\"\n\t\t);\n\t\t// @formatter:on\n\n\t\tassertThat(actualExceptionInAfterAllCallback).isEmpty();\n\t}",
    "comment": "Since static methods cannot be overridden, \"static hiding\" no longer occurs since 5.11."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Double> create(double data) {\n    return Tensor.create(data, Double.class);\n  }",
    "comment": "Creates a scalar tensor containing a single {@code double} element.\n\n@param data The value to put into the new scalar tensor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/discovery/LauncherDiscoveryListeners.java",
    "type": "method",
    "name": "logging",
    "code": "public static LauncherDiscoveryListener logging() {\n\t\treturn new LoggingLauncherDiscoveryListener();\n\t}",
    "comment": "Create a {@link LauncherDiscoveryListener} that logs test discovery\nevents based on their severity.\n\n<p>For example, failures during test discovery are logged as errors."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/transformation/impl/DefaultConsumerPomArtifactTransformer.java",
    "type": "method",
    "name": "doDeleteFiles",
    "code": "private void doDeleteFiles() {\n        for (Path file : toDelete) {\n            try {\n                Files.delete(file);\n            } catch (IOException e) {\n            }\n        }\n    }",
    "comment": "ignore, we did our best..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetVectorUpdaterFactory.java",
    "type": "method",
    "name": "getUpdater",
    "code": "public ParquetVectorUpdater getUpdater(ColumnDescriptor descriptor, DataType sparkType) {\n    PrimitiveType.PrimitiveTypeName typeName = descriptor.getPrimitiveType().getPrimitiveTypeName();\n\n    switch (typeName) {\n      case BOOLEAN -> {\n        if (sparkType == DataTypes.BooleanType) {\n          return new BooleanUpdater();\n        }\n      }\n      case INT32 -> {\n        if (sparkType == DataTypes.IntegerType || canReadAsIntDecimal(descriptor, sparkType)) {\n          return new IntegerUpdater();\n        } else if (sparkType == DataTypes.LongType && isUnsignedIntTypeMatched(32)) {\n          return new UnsignedIntegerUpdater();\n        } else if (sparkType == DataTypes.LongType || canReadAsLongDecimal(descriptor, sparkType)) {\n          return new IntegerToLongUpdater();\n        } else if (canReadAsBinaryDecimal(descriptor, sparkType)) {\n          return new IntegerToBinaryUpdater();\n        } else if (sparkType == DataTypes.ByteType) {\n          return new ByteUpdater();\n        } else if (sparkType == DataTypes.ShortType) {\n          return new ShortUpdater();\n        } else if (sparkType == DataTypes.DoubleType) {\n          return new IntegerToDoubleUpdater();\n        } else if (sparkType == DataTypes.DateType) {\n          if (\"CORRECTED\".equals(datetimeRebaseMode)) {\n            return new IntegerUpdater();\n          } else {\n            boolean failIfRebase = \"EXCEPTION\".equals(datetimeRebaseMode);\n            return new IntegerWithRebaseUpdater(failIfRebase);\n          }\n        } else if (sparkType == DataTypes.TimestampNTZType && isDateTypeMatched(descriptor)) {\n          if (\"CORRECTED\".equals(datetimeRebaseMode)) {\n            return new DateToTimestampNTZUpdater();\n          } else {\n            boolean failIfRebase = \"EXCEPTION\".equals(datetimeRebaseMode);\n            return new DateToTimestampNTZWithRebaseUpdater(failIfRebase);\n          }\n        } else if (sparkType instanceof YearMonthIntervalType) {\n          return new IntegerUpdater();\n        } else if (canReadAsDecimal(descriptor, sparkType)) {\n          return new IntegerToDecimalUpdater(descriptor, (DecimalType) sparkType);\n        }\n      }\n      case INT64 -> {\n        if (sparkType == DataTypes.LongType || canReadAsLongDecimal(descriptor, sparkType)) {\n          if (DecimalType.is32BitDecimalType(sparkType)) {\n            return new DowncastLongUpdater();\n          } else {\n            return new LongUpdater();\n          }\n        } else if (canReadAsBinaryDecimal(descriptor, sparkType)) {\n          return new LongToBinaryUpdater();\n        } else if (isLongDecimal(sparkType) && isUnsignedIntTypeMatched(64)) {\n          return new UnsignedLongUpdater();\n        } else if (sparkType == DataTypes.TimestampType &&\n          isTimestampTypeMatched(LogicalTypeAnnotation.TimeUnit.MICROS)) {\n          if (\"CORRECTED\".equals(datetimeRebaseMode)) {\n            return new LongUpdater();\n          } else {\n            boolean failIfRebase = \"EXCEPTION\".equals(datetimeRebaseMode);\n            return new LongWithRebaseUpdater(failIfRebase, datetimeRebaseTz);\n          }\n        } else if (sparkType == DataTypes.TimestampType &&\n          isTimestampTypeMatched(LogicalTypeAnnotation.TimeUnit.MILLIS)) {\n          if (\"CORRECTED\".equals(datetimeRebaseMode)) {\n            return new LongAsMicrosUpdater();\n          } else {\n            final boolean failIfRebase = \"EXCEPTION\".equals(datetimeRebaseMode);\n            return new LongAsMicrosRebaseUpdater(failIfRebase, datetimeRebaseTz);\n          }\n        } else if (sparkType == DataTypes.TimestampNTZType &&\n          isTimestampTypeMatched(LogicalTypeAnnotation.TimeUnit.MICROS)) {\n          return new LongUpdater();\n        } else if (sparkType == DataTypes.TimestampNTZType &&\n          isTimestampTypeMatched(LogicalTypeAnnotation.TimeUnit.MILLIS)) {\n          return new LongAsMicrosUpdater();\n        } else if (sparkType instanceof DayTimeIntervalType) {\n          return new LongUpdater();\n        } else if (canReadAsDecimal(descriptor, sparkType)) {\n          return new LongToDecimalUpdater(descriptor, (DecimalType) sparkType);\n        } else if (sparkType instanceof TimeType) {\n          return new LongUpdater();\n        }\n      }\n      case FLOAT -> {\n        if (sparkType == DataTypes.FloatType) {\n          return new FloatUpdater();\n        } else if (sparkType == DataTypes.DoubleType) {\n          return new FloatToDoubleUpdater();\n        }\n      }\n      case DOUBLE -> {\n        if (sparkType == DataTypes.DoubleType) {\n          return new DoubleUpdater();\n        }\n      }\n      case INT96 -> {\n        if (sparkType == DataTypes.TimestampNTZType) {\n          return new BinaryToSQLTimestampUpdater();\n        } else if (sparkType == DataTypes.TimestampType) {\n          final boolean failIfRebase = \"EXCEPTION\".equals(int96RebaseMode);\n          if (!shouldConvertTimestamps()) {\n            if (\"CORRECTED\".equals(int96RebaseMode)) {\n              return new BinaryToSQLTimestampUpdater();\n            } else {\n              return new BinaryToSQLTimestampRebaseUpdater(failIfRebase, int96RebaseTz);\n            }\n          } else {\n            if (\"CORRECTED\".equals(int96RebaseMode)) {\n              return new BinaryToSQLTimestampConvertTzUpdater(convertTz);\n            } else {\n              return new BinaryToSQLTimestampConvertTzRebaseUpdater(\n                failIfRebase,\n                convertTz,\n                int96RebaseTz);\n            }\n          }\n        }\n      }\n      case BINARY -> {\n        if (sparkType instanceof  StringType || sparkType == DataTypes.BinaryType ||\n          canReadAsBinaryDecimal(descriptor, sparkType)) {\n          return new BinaryUpdater();\n        } else if (canReadAsDecimal(descriptor, sparkType)) {\n          return new BinaryToDecimalUpdater(descriptor, (DecimalType) sparkType);\n        }\n      }\n      case FIXED_LEN_BYTE_ARRAY -> {\n        int arrayLen = descriptor.getPrimitiveType().getTypeLength();\n        if (canReadAsIntDecimal(descriptor, sparkType)) {\n          return new FixedLenByteArrayAsIntUpdater(arrayLen);\n        } else if (canReadAsLongDecimal(descriptor, sparkType)) {\n          return new FixedLenByteArrayAsLongUpdater(arrayLen);\n        } else if (canReadAsBinaryDecimal(descriptor, sparkType)) {\n          return new FixedLenByteArrayUpdater(arrayLen);\n        } else if (sparkType == DataTypes.BinaryType) {\n          return new FixedLenByteArrayUpdater(arrayLen);\n        } else if (canReadAsDecimal(descriptor, sparkType)) {\n          return new FixedLenByteArrayToDecimalUpdater(descriptor, (DecimalType) sparkType);\n        }\n      }\n      default -> {}\n    }\n\n    throw constructConvertNotSupportedException(descriptor, sparkType);\n  }",
    "comment": "In `ParquetToSparkSchemaConverter`, we map parquet UINT32 to our LongType.\nFor unsigned int32, it stores as plain signed int32 in Parquet when dictionary\nfallbacks. We read them as long values.\nThis is where we implement support for the valid type conversions.\nIn `ParquetToSparkSchemaConverter`, we map parquet UINT64 to our Decimal(20, 0).\nFor unsigned int64, it stores as plain signed int64 in Parquet when dictionary\nfallbacks. We read them as decimal values.\nTIMESTAMP_NTZ is a new data type and has no legacy files that need to do rebase.\nTIMESTAMP_NTZ is a new data type and has no legacy files that need to do rebase.\nTimestampNTZ type does not require rebasing due to its lack of time zone context.\nIf we get here, it means the combination of Spark and Parquet type is invalid or not\nsupported."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "hasLifecyclePhase",
    "code": "public boolean hasLifecyclePhase(String phase) {\n        return lifecyclePhases.contains(phase);\n    }",
    "comment": "<strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not\npart of the public API. In particular, this method can be changed or deleted without prior notice and must not be\nused by plugins.\n\n@param phase The phase to check for, must not be {@code null}.\n@return {@code true} if the phase has been seen."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/notification/RunNotifier.java",
    "type": "method",
    "name": "wrapIfNotThreadSafe",
    "code": "RunListener wrapIfNotThreadSafe(RunListener listener) {\n        return listener.getClass().isAnnotationPresent(RunListener.ThreadSafe.class) ?\n                listener : new SynchronizedRunListener(listener, this);\n    }",
    "comment": "Wraps the given listener with {@link SynchronizedRunListener} if\nit is not annotated with {@link RunListener.ThreadSafe}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/entity/Freighter.java",
    "type": "method",
    "name": "Freighter",
    "code": "public Freighter(String manufacturer, String model, int loadCapacity, double flightLength) {\n    super(manufacturer, model, loadCapacity);\n    this.flightLength = flightLength;\n  }",
    "comment": "A class that extends the TransportVehicle class and provides the concrete inheritance\nimplementation of the Car.\n\n@see TransportVehicle TransportVehicle\n@see Vehicle Vehicle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeArrayData.java",
    "type": "method",
    "name": "pointTo",
    "code": "public void pointTo(Object baseObject, long baseOffset, int sizeInBytes) {\n    // Read the number of elements from the first 8 bytes.\n    final long numElements = Platform.getLong(baseObject, baseOffset);\n    assert numElements >= 0 : \"numElements (\" + numElements + \") should >= 0\";\n    assert numElements <= Integer.MAX_VALUE :\n      \"numElements (\" + numElements + \") should <= Integer.MAX_VALUE\";\n\n    this.numElements = (int)numElements;\n    this.baseObject = baseObject;\n    this.baseOffset = baseOffset;\n    this.sizeInBytes = sizeInBytes;\n    this.elementOffset = baseOffset + calculateHeaderPortionInBytes(this.numElements);\n  }",
    "comment": "Update this UnsafeArrayData to point to different backing data.\n\n@param baseObject the base object\n@param baseOffset the offset within the base object\n@param sizeInBytes the size of this array's backing data, in bytes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "getInterval",
    "code": "public CalendarInterval getInterval(int rowId) {\n    if (isNullAt(rowId)) return null;\n    final int months = getChild(0).getInt(rowId);\n    final int days = getChild(1).getInt(rowId);\n    final long microseconds = getChild(2).getLong(rowId);\n    return new CalendarInterval(months, days, microseconds);\n  }",
    "comment": "Returns the calendar interval type value for {@code rowId}. If the slot for\n{@code rowId} is null, it should return null.\n<p>\nIn Spark, calendar interval type value is basically two integer values representing the number\nof months and days in this interval, and a long value representing the number of microseconds\nin this interval. An interval type vector is the same as a struct type vector with 3 fields:\n{@code months}, {@code days} and {@code microseconds}.\n<p>\nTo support interval type, implementations must implement {@link #getChild(int)} and define 3\nchild vectors: the first child vector is an int type vector, containing all the month values of\nall the interval values in this vector. The second child vector is an int type vector,\ncontaining all the day values of all the interval values in this vector. The third child vector\nis a long type vector, containing all the microsecond values of all the interval values in this\nvector.\nNote that the ArrowColumnVector leverages its built-in IntervalMonthDayNanoVector instead of\nabove-mentioned protocol."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/SelectorResolutionResult.java",
    "type": "method",
    "name": "unresolved",
    "code": "public static SelectorResolutionResult unresolved() {\n\t\treturn UNRESOLVED_RESULT;\n\t}",
    "comment": "Create a {@code SelectorResolutionResult} for an <em>unresolved</em>\nselector.\n@return the {@code SelectorResolutionResult}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/OldestConflictResolverTest.java",
    "type": "method",
    "name": "testDepth",
    "code": "void testDepth() {\n        ResolutionNode a1n = createResolutionNode(a1);\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n\n        assertResolveConflict(a1n, a1n, a2n);\n    }",
    "comment": "Tests that <code>a:1.0</code> wins in the scenario:\n<pre>\na:1.0\nb:1.0 -&gt; a:2.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestSqlite/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "updateAndGetUser",
    "code": "public void updateAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        User updatedUser = new User(USER.getId(), \"new username\");\n        mDataSource.insertOrUpdateUser(updatedUser);\n\n        User dbUser = mDataSource.getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), \"new username\");\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are updating the name of the user\nThe retrieved user has the updated username"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/MavenSessionBuilderSupplier.java",
    "type": "method",
    "name": "get",
    "code": "public SessionBuilder get() {\n        requireNonNull(repositorySystem, \"repositorySystem\");\n        SessionBuilder builder = repositorySystem.createSessionBuilder();\n        configureSessionBuilder(builder);\n        return builder;\n    }",
    "comment": "Creates a new Maven-like repository system session by initializing the session with values typical for\nMaven-based resolution. In more detail, this method configures settings relevant for the processing of dependency\ngraphs, most other settings remain at their generic default value. Use the various setters to further configure\nthe session with authentication, mirror, proxy and other information required for your environment. At least,\nlocal repository manager needs to be configured to make session be able to create session instance.\n\n@return SessionBuilder configured with minimally required things for \"Maven-based resolution\". At least LRM must\nbe set on builder to make it able to create session instances."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/test/java/com/example/android/persistence/migrations/UserPresenterTest.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n        MockitoAnnotations.initMocks(this);\n\n        mPresenter = new UserPresenter(mUserRepository, mView);\n    }",
    "comment": "Unit tests for {@link UserPresenter}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/ExpectedException.java",
    "type": "method",
    "name": "isAnyExceptionExpected",
    "code": "public final boolean isAnyExceptionExpected() {\n        return matcherBuilder.expectsThrowable();\n    }",
    "comment": "Check if any Exception is expected.\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/metadata/GroupRepositoryMetadata.java",
    "type": "method",
    "name": "GroupRepositoryMetadata",
    "code": "public GroupRepositoryMetadata(String groupId) {\n        super(new Metadata());\n        this.groupId = groupId;\n    }",
    "comment": "Metadata for the group directory of the repository."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/test/java/com/iluwatar/circuitbreaker/AppTest.java",
    "type": "method",
    "name": "testFailure_OpenStateTransition",
    "code": "void testFailure_OpenStateTransition() {\n    assertEquals(\"Delayed service is down\", monitoringService.delayedServiceResponse());\n    assertEquals(\"OPEN\", delayedServiceCircuitBreaker.getState());\n    assertEquals(\"Delayed service is down\", monitoringService.delayedServiceResponse());\n\n    assertEquals(\"Quick Service is working\", monitoringService.quickServiceResponse());\n    assertEquals(\"CLOSED\", quickServiceCircuitBreaker.getState());\n  }",
    "comment": "Calling delayed service, which will be unhealthy till 4 seconds\nAs failure threshold is \"1\", the circuit breaker is changed to OPEN\nAs circuit state is OPEN, we expect a quick fallback response from circuit breaker.\nMeanwhile, the quick service is responding and the circuit state is CLOSED"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TestReporterParameterResolver.java",
    "type": "method",
    "name": "getTestInstantiationExtensionContextScope",
    "code": "public ExtensionContextScope getTestInstantiationExtensionContextScope(ExtensionContext rootContext) {\n\t\treturn ExtensionContextScope.TEST_METHOD;\n\t}",
    "comment": "{@link ParameterResolver} that injects a {@link TestReporter}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/SimpleLoggerConfiguration.java",
    "type": "method",
    "name": "loadProperties",
    "code": "private void loadProperties() {\n        ClassLoader threadCL = Thread.currentThread().getContextClassLoader();\n        ClassLoader toUseCL = (threadCL != null ? threadCL : ClassLoader.getSystemClassLoader());\n\n        boolean mavenPropsLoaded = false;\n        try (InputStream in = toUseCL.getResourceAsStream(CONFIGURATION_FILE)) {\n            if (in != null) {\n                properties.load(in);\n                mavenPropsLoaded = true;\n            }\n        } catch (java.io.IOException e) {\n        }\n\n        try (InputStream in = toUseCL.getResourceAsStream(LEGACY_CONFIGURATION_FILE)) {\n            if (in != null) {\n                Properties legacyProps = new Properties();\n                legacyProps.load(in);\n                if (!mavenPropsLoaded) {\n                    Reporter.warn(\"Using deprecated \" + LEGACY_CONFIGURATION_FILE + \". Please migrate to \"\n                            + CONFIGURATION_FILE);\n                }\n                for (String propName : legacyProps.stringPropertyNames()) {\n                    String mavenKey = propName.replace(MavenBaseLogger.LEGACY_PREFIX, Constants.MAVEN_LOGGER_PREFIX);\n                    if (!properties.containsKey(mavenKey)) {\n                        properties.setProperty(mavenKey, legacyProps.getProperty(propName));\n                    }\n                }\n            }\n        } catch (java.io.IOException e) {\n        }\n    }",
    "comment": "Try loading maven properties first\nignored\nTry loading legacy properties\nOnly load legacy properties if there's no maven equivalent\nignored"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/RepeatedTestTests.java",
    "type": "method",
    "name": "customDisplayName",
    "code": "void customDisplayName(TestInfo testInfo) {\n\t\tassertThat(testInfo.getDisplayName()).isEqualTo(\"repetition 1 of 1\");\n\t}",
    "comment": "Integration tests for {@link RepeatedTest @RepeatedTest} and supporting\ninfrastructure.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/streaming/Offset.java",
    "type": "method",
    "name": "equals",
    "code": "public boolean equals(Object obj) {\n        if (obj instanceof Offset offset) {\n            return this.json().equals(offset.json());\n        } else {\n            return false;\n        }\n    }",
    "comment": "Equality based on JSON string representation. We leverage the\nJSON representation for normalization between the Offset's\nin deserialized and serialized representations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java",
    "type": "method",
    "name": "runXmlDatasetExample",
    "code": "private static void runXmlDatasetExample(SparkSession spark) {\n\n    String path = \"examples/src/main/resources/people.xml\";\n    Dataset<Row> peopleDF = spark.read().option(\"rowTag\", \"person\").xml(path);\n\n    peopleDF.printSchema();\n\n    peopleDF.createOrReplaceTempView(\"people\");\n\n    Dataset<Row> teenagerNamesDF = spark.sql(\n            \"SELECT name FROM people WHERE age BETWEEN 13 AND 19\");\n    teenagerNamesDF.show();\n\n    List<String> xmlData = Collections.singletonList(\n            \"<person>\" +\n            \"<name>laglangyue</name><job>Developer</job><age>28</age>\" +\n            \"</person>\");\n    Dataset<String> otherPeopleDataset = spark.createDataset(Lists.newArrayList(xmlData),\n            Encoders.STRING());\n\n    Dataset<Row> otherPeople = spark.read()\n        .option(\"rowTag\", \"person\")\n        .xml(otherPeopleDataset);\n    otherPeople.show();\n\n  }",
    "comment": "$example on:xml_dataset$\nPrimitive types (Int, String, etc) and Product types (case classes) encoders are\nsupported by importing this when creating a Dataset.\nAn XML dataset is pointed to by path.\nThe path can be either a single xml file or more xml files\nThe inferred schema can be visualized using the printSchema() method\nroot\n|-- age: long (nullable = true)\n|-- name: string (nullable = true)\nCreates a temporary view using the DataFrame\nSQL statements can be run by using the sql methods provided by spark\n+------+\n|  name|\n+------+\n|Justin|\n+------+\nAlternatively, a DataFrame can be created for an XML dataset represented by a Dataset[String]\n+---+---------+----------+\n|age|      job|      name|\n+---+---------+----------+\n| 28|Developer|laglangyue|\n+---+---------+----------+\n$example off:xml_dataset$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "build",
    "code": "public GangliaReporter build(GMetric... gmetrics) {\n            return new GangliaReporter(registry, null, gmetrics, prefix, tMax, dMax, rateUnit, durationUnit,\n                    filter, executor, shutdownExecutorOnStop , disabledMetricAttributes);\n        }",
    "comment": "Builds a {@link GangliaReporter} with the given properties, announcing metrics to the\ngiven {@link GMetric} client.\n\n@param gmetrics the clients to use for announcing metrics\n@return a {@link GangliaReporter}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaRandomForestClassificationExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf sparkConf = new SparkConf().setAppName(\"JavaRandomForestClassificationExample\");\n    JavaSparkContext jsc = new JavaSparkContext(sparkConf);\n    String datapath = \"data/mllib/sample_libsvm_data.txt\";\n    JavaRDD<LabeledPoint> data = MLUtils.loadLibSVMFile(jsc.sc(), datapath).toJavaRDD();\n    JavaRDD<LabeledPoint>[] splits = data.randomSplit(new double[]{0.7, 0.3});\n}",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file.\nSplit the data into training and test sets (30% held out for testing)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/OldestConflictResolverTest.java",
    "type": "method",
    "name": "testEqualReversed",
    "code": "void testEqualReversed() {\n        ResolutionNode a2n = createResolutionNode(a2);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a1n, a2n, a1n);\n    }",
    "comment": "Tests that <code>a:1.0</code> wins in the scenario:\n<pre>\na:2.0\na:1.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/ssl/SslSampleConfigs.java",
    "type": "method",
    "name": "getAbsolutePath",
    "code": "public static String getAbsolutePath(String path) {\n    try {\n      return new File(SslSampleConfigs.class.getResource(path).getFile()).getCanonicalPath();\n    } catch (IOException e) {\n       throw new RuntimeException(\"Failed to resolve path \" + path, e);\n    }\n  }",
    "comment": "Creates a keystore with a single key and saves it to a file.\n\n@param keyStore    File keystore to save\n@param password    String store password to set on keystore\n@param keyPassword String key password to set on key\n@param alias       String alias to use for the key\n@param privateKey  Key to save in keystore\n@param cert        Certificate to use as certificate chain associated to key\n@throws GeneralSecurityException for any error with the security APIs\n@throws IOException              if there is an I/O error saving the file"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(UriSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link UriSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Boolean> create(Scope scope, boolean[][][][][] data) {\n    return create(scope, data, Boolean.class);\n  }",
    "comment": "Creates a rank-5 constant of {@code boolean} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Object unexpected, Object actual) {\n        assertNotEquals(null, unexpected, actual);\n    }",
    "comment": "Asserts that two objects are <b>not</b> equals. If they are, an\n{@link AssertionError} without a message is thrown. If\n<code>unexpected</code> and <code>actual</code> are <code>null</code>,\nthey are considered equal.\n\n@param unexpected unexpected value to check\n@param actual the value to check against <code>unexpected</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/repository/Proxy.java",
    "type": "method",
    "name": "setPort",
    "code": "public void setPort(int port) {\n        this.port = port;\n    }",
    "comment": "Set the proxy port.\n\n@param port proxy server port"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/Result.java",
    "type": "method",
    "name": "hasErrors",
    "code": "private static boolean hasErrors(Iterable<? extends ModelProblem> problems) {\n        for (ModelProblem input : problems) {\n            if (input.getSeverity().equals(ERROR) || input.getSeverity().equals(FATAL)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "comment": "helper to determine if problems contain error"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestExecutionListener.java",
    "type": "method",
    "name": "reportingEntryPublished",
    "code": "default void reportingEntryPublished(TestIdentifier testIdentifier, ReportEntry entry) {\n\t}",
    "comment": "Called when additional test reporting data has been published for\nthe supplied {@link TestIdentifier}.\n\n<p>Can be called at any time during the execution of a test plan.\n\n@param testIdentifier describes the test or container to which the entry pertains\n@param entry the published {@code ReportEntry}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "TestCase",
    "code": "public TestCase(String name) {\n        fName = name;\n    }",
    "comment": "Constructs a test case with the given name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationSupport.java",
    "type": "method",
    "name": "exec",
    "code": "public static int exec(final UTF8String word, final UTF8String set, final int collationId) {\n      if (collationId == CollationFactory.UTF8_BINARY_COLLATION_ID) {\n        return execBinary(word, set);\n      } else {\n        return execCollationAware(word, set, collationId);\n      }\n    }",
    "comment": "FindInSet does space trimming collation as comparison is space trimming collation aware"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarArray.java",
    "type": "method",
    "name": "array",
    "code": "public Object[] array() {\n    DataType dt = data.dataType();\n    Object[] list = new Object[length];\n    try {\n      for (int i = 0; i < length; i++) {\n        if (!data.isNullAt(offset + i)) {\n          list[i] = get(i, dt);\n        }\n      }\n      return list;\n    } catch(Exception e) {\n      throw new RuntimeException(\"Could not get the array\", e);\n    }\n  }",
    "comment": "TODO: this is extremely expensive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assumptions.java",
    "type": "method",
    "name": "abort",
    "code": "public static <V> V abort(Supplier<String> messageSupplier) {\n\t\tthrow new TestAbortedException(messageSupplier.get());\n\t}",
    "comment": "<em>Abort</em> the test with the supplied message.\n\n<p>See Javadoc for {@link #abort(String)} for an explanation of this\nmethod's generic return type {@code V}.\n\n@param messageSupplier the supplier of the message to be included in the\n{@code TestAbortedException}\n@throws TestAbortedException always\n@since 5.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, String expected, String actual) {\n        if (expected == null && actual == null) {\n            return;\n        }\n        if (expected != null && expected.equals(actual)) {\n            return;\n        }\n        String cleanMessage = message == null ? \"\" : message;\n        throw new ComparisonFailure(cleanMessage, expected, actual);\n    }",
    "comment": "Asserts that two Strings are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/Project.java",
    "type": "method",
    "name": "getMainArtifact",
    "code": "default Optional<ProducedArtifact> getMainArtifact() {\n        List<ProducedArtifact> artifacts = getArtifacts();\n        return artifacts.size() == 2 ? Optional.of(artifacts.get(1)) : Optional.empty();\n    }",
    "comment": "{@return the project main artifact}, which is the artifact produced by this project build, if applicable.\nThis artifact MAY be absent if the project is actually not producing any main artifact (i.e. \"pom\" packaging).\n\n@see #getPackaging()\n@see org.apache.maven.api.services.ArtifactManager#getPath(Artifact)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/ssl/SslSampleConfigs.java",
    "type": "method",
    "name": "createDefaultConfigProviderForRpcNamespace",
    "code": "public static ConfigProvider createDefaultConfigProviderForRpcNamespace() {\n    return new MapConfigProvider(createDefaultConfigMapForRpcNamespace());\n  }",
    "comment": "Create ConfigProvider based on the method above"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "isWideningConversion",
    "code": "static boolean isWideningConversion(Class<?> sourceType, Class<?> targetType) {\n\t\tPreconditions.condition(targetType.isPrimitive(), \"targetType must be primitive\");\n\n\t\tboolean isPrimitive = sourceType.isPrimitive();\n\t\tboolean isWrapper = primitiveToWrapperMap.containsValue(sourceType);\n\n\t\t// Neither a primitive nor a wrapper?\n\t\tif (!isPrimitive && !isWrapper) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (isPrimitive) {\n\t\t\tsourceType = primitiveToWrapperMap.get(sourceType);\n\t\t}\n\n\t\t// @formatter:off\n\t\tif (sourceType == Byte.class) {\n\t\t\treturn\n\t\t\t\t\ttargetType == short.class ||\n\t\t\t\t\ttargetType == int.class ||\n\t\t\t\t\ttargetType == long.class ||\n\t\t\t\t\ttargetType == float.class ||\n\t\t\t\t\ttargetType == double.class;\n\t\t}\n\n\t\tif (sourceType == Short.class || sourceType == Character.class) {\n\t\t\treturn\n\t\t\t\t\ttargetType == int.class ||\n\t\t\t\t\ttargetType == long.class ||\n\t\t\t\t\ttargetType == float.class ||\n\t\t\t\t\ttargetType == double.class;\n\t\t}\n\n\t\tif (sourceType == Integer.class) {\n\t\t\treturn\n\t\t\t\t\ttargetType == long.class ||\n\t\t\t\t\ttargetType == float.class ||\n\t\t\t\t\ttargetType == double.class;\n\t\t}\n\n\t\tif (sourceType == Long.class) {\n\t\t\treturn\n\t\t\t\t\ttargetType == float.class ||\n\t\t\t\t\ttargetType == double.class;\n\t\t}\n\n\t\tif (sourceType == Float.class) {\n\t\t\treturn\n\t\t\t\t\ttargetType == double.class;\n\t\t}\n\t\t// @formatter:on\n\n\t\treturn false;\n\t}",
    "comment": "Determine if Java supports a <em>widening primitive conversion</em> from the\nsupplied source type to the supplied <strong>primitive</strong> target type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "updateAddressesAndSizes",
    "code": "private void updateAddressesAndSizes(long fullKeyAddress) {\n      updateAddressesAndSizes(\n        taskMemoryManager.getPage(fullKeyAddress),\n        taskMemoryManager.getOffsetInPage(fullKeyAddress));\n    }",
    "comment": "Memory page containing the record. Only set if created by {@link BytesToBytesMap#iterator()}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertNull",
    "code": "public static void assertNull(String message, Object object) {\n        if (object == null) {\n            return;\n        }\n        failNotNull(message, object);\n    }",
    "comment": "Asserts that an object is null. If it is not, an {@link AssertionError}\nis thrown with the given message.\n\n@param message the identifying message for the {@link AssertionError} (<code>null</code>\nokay)\n@param object Object to check or <code>null</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "receiveBlockDataAsStream",
    "code": "public StreamCallbackWithID receiveBlockDataAsStream(PushBlockStream msg) {\n    AppShuffleInfo appShuffleInfo = validateAndGetAppShuffleInfo(msg.appId);\n    final String streamId = OneForOneBlockPusher.SHUFFLE_PUSH_BLOCK_PREFIX + \"_\"\n      + msg.shuffleId + \"_\" + msg.shuffleMergeId + \"_\" + msg.mapIndex + \"_\" + msg.reduceId;\n    if (appShuffleInfo.attemptId != msg.appAttemptId) {\n      throw new BlockPushNonFatalFailure(new BlockPushReturnCode(ReturnCode\n        .TOO_OLD_ATTEMPT_PUSH.id(), streamId).toByteBuffer(),\n        BlockPushNonFatalFailure.getErrorMsg(streamId, ReturnCode.TOO_OLD_ATTEMPT_PUSH));\n    }\n    AppShufflePartitionInfo partitionInfoBeforeCheck;\n    BlockPushNonFatalFailure failure = null;\n    try {\n      partitionInfoBeforeCheck = getOrCreateAppShufflePartitionInfo(appShuffleInfo, msg.shuffleId,\n        msg.shuffleMergeId, msg.reduceId, streamId);\n    } catch (BlockPushNonFatalFailure bpf) {\n      partitionInfoBeforeCheck = null;\n      failure = bpf;\n    }\n\n    final AppShufflePartitionInfo partitionInfo = failure != null ? null :\n      partitionInfoBeforeCheck.mapTracker.contains(msg.mapIndex) ? null : partitionInfoBeforeCheck;\n    if (partitionInfo != null) {\n      return new PushBlockStreamCallback(\n        this, appShuffleInfo, streamId, partitionInfo, msg.mapIndex);\n    } else {\n      pushMergeMetrics.lateBlockPushes.mark();\n      final BlockPushNonFatalFailure finalFailure = failure;\n      return new StreamCallbackWithID() {\n\n        @Override\n        public void onData(String streamId, ByteBuffer buf) {\n          pushMergeMetrics.ignoredBlockBytes.mark(buf.remaining());\n        }\n\n        @Override\n        public void onComplete(String streamId) {\n          if (finalFailure != null) {\n            throw finalFailure;\n          }\n        }\n\n        @Override\n        public void onFailure(String streamId, Throwable cause) {\n        }\n\n        @Override\n        public ByteBuffer getCompletionResponse() {\n          return SUCCESS_RESPONSE.duplicate();\n        }\n      };\n    }\n  }",
    "comment": "Use string concatenation here to avoid the overhead with String.format on every\npushed block.\nIf this Block belongs to a former application attempt, it is considered late,\nas only the blocks from the current application attempt will be merged\nRetrieve merged shuffle file metadata\nSet partitionInfoBeforeCheck to null so that stale block push gets handled.\nHere partitionInfo will be null in 3 cases:\n1) The request is received for a block that has already been merged, this is possible due\nto the retry logic.\n2) The request is received after the merged shuffle is finalized, thus is too late.\n3) The request is received for a older shuffleMergeId, therefore the block push is rejected.\n\nFor case 1, we will drain the data in the channel and just respond success\nto the client. This is required because the response of the previously merged\nblock will be ignored by the client, per the logic in RetryingBlockFetcher.\nNote that the netty server should receive data for a given block id only from 1 channel\nat any time. The block should be pushed only from successful maps, thus there should be\nonly 1 source for a given block at any time. Although the netty client might retry sending\nthis block to the server multiple times, the data of the same block always arrives from the\nsame channel thus the server should have already processed the previous request of this\nblock before seeing it again in the channel. This guarantees that we can simply just\ncheck the bitmap to determine if a block is a duplicate or not.\n\nFor case 2, we will also drain the data in the channel, but throw an exception in\n{@link org.apache.spark.network.client.StreamCallback#onComplete(String)}. This way,\nthe client will be notified of the failure but the channel will remain active. Keeping\nthe channel alive is important because the same channel could be reused by multiple map\ntasks in the executor JVM, which belongs to different stages. While one of the shuffles\nin these stages is finalized, the others might still be active. Tearing down the channel\non the server side will disrupt these other on-going shuffle merges. It's also important\nto notify the client of the failure, so that it can properly halt pushing the remaining\nblocks upon receiving such failures to preserve resources on the server/client side.\n\nFor case 3, we will also drain the data in the channel, but throw an exception in\n{@link org.apache.spark.network.client.StreamCallback#onComplete(String)}. This way,\nthe client will be notified of the failure but the channel will remain active. It is\nimportant to notify the client of the failure, so that it can properly halt pushing the\nremaining blocks upon receiving such failures to preserve resources on the server/client\nside.\n\nSpeculative execution would also raise a possible scenario with duplicate blocks. Although\nspeculative execution would kill the slower task attempt, leading to only 1 task attempt\nsucceeding in the end, there is no guarantee that only one copy of the block will be\npushed. This is due to our handling of block push process outside of the map task, thus\nit is possible for the speculative task attempt to initiate the block push process before\ngetting killed. When this happens, we need to distinguish the duplicate blocks as they\narrive. More details on this is explained in later comments.\nCheck if the given block is already merged by checking the bitmap against the given map\nindex\nThe block would be considered as too late if it received after shuffle merge finalize,\nand hence mark it as a late block push to the pushMergeMetrics\nFor a duplicate block or a block which is late or stale block from an older\nshuffleMergeId, respond back with a callback that handles them differently.\nIgnore the requests. It reaches here either when a request is received after the\nshuffle file is finalized or when a request is for a duplicate block.\nThrow non-fatal failure here so the block data is drained from channel and server\nresponds the error code to the client.\nFor duplicate block that is received before the shuffle merge finalizes, the\nserver should respond success to the client."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/LevelDBTypeInfo.java",
    "type": "method",
    "name": "getCount",
    "code": "long getCount(byte[] key) {\n      byte[] data = db.db().get(key);\n      return data != null ? db.serializer.deserializeLong(data) : 0;\n    }",
    "comment": "Remove a value from the index.\n\n@param batch Write batch with other related changes.\n@param entity The entity being removed, to identify the index entry to modify.\n@param naturalKey The value's natural key (to avoid re-computing it for every index).\n@param prefix The parent index prefix, if this is a child index."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/BuildSuccess.java",
    "type": "method",
    "name": "BuildSuccess",
    "code": "public BuildSuccess(MavenProject project, Duration time) {\n        this(project, time, time);\n    }",
    "comment": "Creates a new build summary for the specified project.\n\n@param project The project being summarized, must not be {@code null}.\n@param time The build time of the project in milliseconds."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/ClassOrderer.java",
    "type": "method",
    "name": "orderClasses",
    "code": "public void orderClasses(ClassOrdererContext context) {\n\t\t\tCollections.shuffle(context.getClassDescriptors(),\n\t\t\t\tnew java.util.Random(RandomOrdererUtils.getSeed(context::getConfigurationParameter, logger)));\n\t\t}",
    "comment": "Order the classes encapsulated in the supplied\n{@link ClassOrdererContext} pseudo-randomly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "mergedShuffleCleanerShutdownTimeout",
    "code": "public long mergedShuffleCleanerShutdownTimeout() {\n    return JavaUtils.timeStringAsSec(\n      conf.get(\"spark.shuffle.push.server.mergedShuffleCleaner.shutdown.timeout\", \"60s\"));\n  }",
    "comment": "The RemoteBlockPushResolver#mergedShuffleCleanermergedShuffleCleaner\nshutdown timeout, in seconds."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenFailOnSeverityLogger.java",
    "type": "method",
    "name": "error",
    "code": "public void error(String format, Object arg) {\n        super.error(format, arg);\n        logLevelRecorder.record(Level.ERROR);\n    }",
    "comment": "Perform single parameter substitution before logging the message of level\nERROR according to the format outlined above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/FileSource.java",
    "type": "method",
    "name": "getFile",
    "code": "public final File getFile() {\n\t\treturn this.file;\n\t}",
    "comment": "Get the source {@linkplain File file}.\n\n@return the source file; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/ClasspathResourceSelectorTests.java",
    "type": "method",
    "name": "equalsAndHashCode",
    "code": "void equalsAndHashCode() {\n\t\tvar selector1 = new ClasspathResourceSelector(\"/foo/bar.txt\", null);\n\t\tvar selector2 = new ClasspathResourceSelector(\"/foo/bar.txt\", null);\n\t\tvar selector3 = new ClasspathResourceSelector(\"/foo/X.txt\", null);\n\n\t\tassertEqualsAndHashCode(selector1, selector2, selector3);\n\t}",
    "comment": "Unit tests for {@link ClasspathResourceSelector}.\n\n@since 1.3\n@see DiscoverySelectorsTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Float unexpected, Float actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationSupport.java",
    "type": "method",
    "name": "if",
    "code": "final int collationId) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType && !collation.supportsSpaceTrimming) {\n        return execBinary(srcString, trimString);\n      }\n\n      if (collation.isUtf8BinaryType) {\n        return execBinaryTrim(srcString, trimString, collationId);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(srcString, trimString, collationId);\n      } else {\n        return execICU(srcString, trimString, collationId);\n      }\n    }",
    "comment": "special handling needed for utf8_binary_rtrim collation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsWithGenericTypeHierarchiesTests.java",
    "type": "method",
    "name": "findMethodWithMostSpecificParameterTypeInHierarchy",
    "code": "public void findMethodWithMostSpecificParameterTypeInHierarchy() {\n\t\tassertSpecificFooMethodFound(ClassImplementingInterfaceWithInvertedHierarchy.class,\n\t\t\tInterfaceWithGenericNumberParameter.class, Double.class);\n\t\tassertSpecificFooMethodFound(ClassImplementingGenericInterfaceWithMoreSpecificMethod.class,\n\t\t\tClassImplementingGenericInterfaceWithMoreSpecificMethod.class, Double.class);\n\t\tassertSpecificFooMethodFound(ClassImplementingGenericAndMoreSpecificInterface.class,\n\t\t\tInterfaceWithGenericNumberParameter.class, Double.class);\n\t\tassertSpecificFooMethodFound(ClassOverridingDefaultMethodAndImplementingMoreSpecificInterface.class,\n\t\t\tClassOverridingDefaultMethodAndImplementingMoreSpecificInterface.class, Double.class);\n\n\t\tassertSpecificFooMethodFound(ClassImplementingGenericInterfaceWithMoreSpecificMethod.class,\n\t\t\tClassImplementingGenericInterfaceWithMoreSpecificMethod.class, Number.class);\n\t}",
    "comment": "Searched Parameter Type is more specific\nExact Type Match"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/config/CachingJupiterConfigurationTests.java",
    "type": "method",
    "name": "cachesDefaultTestMethodOrderer",
    "code": "void cachesDefaultTestMethodOrderer() {\n\t\tfinal Optional<MethodOrderer> methodOrderer = Optional.of(new MethodOrderer.MethodName());\n\t\twhen(delegate.getDefaultTestMethodOrderer()).thenReturn(methodOrderer);\n\n\t\tassertThat(cache.getDefaultTestMethodOrderer()).isSameAs(methodOrderer);\n\t\tassertThat(cache.getDefaultTestMethodOrderer()).isSameAs(methodOrderer);\n\n\t\tverify(delegate, only()).getDefaultTestMethodOrderer();\n\t}",
    "comment": "call `cache.getDefaultTestMethodOrderer()` twice to verify the delegate method is called only once."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/AllTests.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n        junit.textui.TestRunner.run(suite());\n    }",
    "comment": "TestSuite that runs all the sample tests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/merge/MavenModelMerger.java",
    "type": "method",
    "name": "mergeModel",
    "code": "protected void mergeModel(Model target, Model source, boolean sourceDominant, Map<Object, Object> context) {\n        context.put(ARTIFACT_ID, target.getArtifactId());\n\n        super.mergeModel(target, source, sourceDominant, context);\n    }",
    "comment": "The context key for the artifact id of the target model."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/test/org/apache/spark/JavaAPISuite.java",
    "type": "method",
    "name": "sample",
    "code": "public void sample() {\n    List<Integer> ints = IntStream.iterate(1, x -> x + 1)\n      .limit(20)\n      .boxed()\n      .collect(Collectors.toList());\n    JavaRDD<Integer> rdd = sc.parallelize(ints);\n    JavaRDD<Integer> sample20 = rdd.sample(true, 0.2, 8);\n    assertEquals(2, sample20.count());\n    JavaRDD<Integer> sample20WithoutReplacement = rdd.sample(false, 0.2, 2);\n    assertEquals(4, sample20WithoutReplacement.count());\n  }",
    "comment": "the seeds here are \"magic\" to make this work out nicely"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/unsafe/map/AbstractBytesToBytesMapSuite.java",
    "type": "method",
    "name": "setAndRetrieveAKey",
    "code": "public void setAndRetrieveAKey() {\n    BytesToBytesMap map = new BytesToBytesMap(taskMemoryManager, 64, PAGE_SIZE_BYTES);\n    final int recordLengthWords = 10;\n    final int recordLengthBytes = recordLengthWords * 8;\n    final byte[] keyData = getRandomByteArray(recordLengthWords);\n    final byte[] valueData = getRandomByteArray(recordLengthWords);\n    try {\n      final BytesToBytesMap.Location loc =\n        map.lookup(keyData, Platform.BYTE_ARRAY_OFFSET, recordLengthBytes);\n      Assertions.assertFalse(loc.isDefined());\n      Assertions.assertTrue(loc.append(\n        keyData,\n        Platform.BYTE_ARRAY_OFFSET,\n        recordLengthBytes,\n        valueData,\n        Platform.BYTE_ARRAY_OFFSET,\n        recordLengthBytes\n      ));\n      Assertions.assertEquals(recordLengthBytes, loc.getKeyLength());\n      Assertions.assertEquals(recordLengthBytes, loc.getValueLength());\n      Assertions.assertArrayEquals(keyData,\n        getByteArray(loc.getKeyBase(), loc.getKeyOffset(), recordLengthBytes));\n      Assertions.assertArrayEquals(valueData,\n        getByteArray(loc.getValueBase(), loc.getValueOffset(), recordLengthBytes));\n\n      Assertions.assertTrue(\n        map.lookup(keyData, Platform.BYTE_ARRAY_OFFSET, recordLengthBytes).isDefined());\n      Assertions.assertEquals(recordLengthBytes, loc.getKeyLength());\n      Assertions.assertEquals(recordLengthBytes, loc.getValueLength());\n      Assertions.assertArrayEquals(keyData,\n        getByteArray(loc.getKeyBase(), loc.getKeyOffset(), recordLengthBytes));\n      Assertions.assertArrayEquals(valueData,\n        getByteArray(loc.getValueBase(), loc.getValueOffset(), recordLengthBytes));\n\n    } finally {\n      map.free();\n    }\n  }",
    "comment": "After storing the key and value, the other location methods should return results that\nreflect the result of this store without us having to call lookup() again on the same key.\nAfter calling lookup() the location should still point to the correct data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/hash/Murmur3_x86_32Suite.java",
    "type": "method",
    "name": "randomizedStressTest",
    "code": "public void randomizedStressTest() {\n    int size = 65536;\n    Random rand = new Random();\n\n    Set<Integer> hashcodes = new HashSet<>();\n    for (int i = 0; i < size; i++) {\n      int vint = rand.nextInt();\n      long lint = rand.nextLong();\n      Assertions.assertEquals(hasher.hashInt(vint), hasher.hashInt(vint));\n      Assertions.assertEquals(hasher.hashLong(lint), hasher.hashLong(lint));\n\n      hashcodes.add(hasher.hashLong(lint));\n    }\n\n    Assertions.assertTrue(hashcodes.size() > size * 0.95);\n  }",
    "comment": "A set used to track collision rate.\nA very loose bound."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestClassInheritanceTests.java",
    "type": "method",
    "name": "initStatics",
    "code": "void initStatics() {\n\t\tcallSequence.clear();\n\t\tLocalTestCase.countBeforeInvoked = 0;\n\t\tLocalTestCase.countAfterInvoked = 0;\n\t\tAbstractTestCase.countSuperBeforeInvoked = 0;\n\t\tAbstractTestCase.countSuperAfterInvoked = 0;\n\t}",
    "comment": "Integration tests for test class hierarchy support in the {@link JupiterTestEngine}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceContentProviderSample/app/src/main/java/com/example/android/contentprovidersample/data/SampleDatabase.java",
    "type": "method",
    "name": "switchToInMemory",
    "code": "public static void switchToInMemory(Context context) {\n        sInstance = Room.inMemoryDatabaseBuilder(context.getApplicationContext(),\n                SampleDatabase.class).build();\n    }",
    "comment": "Switches the internal implementation with an empty in-memory database.\n\n@param context The context."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "Builder",
    "code": "private Builder(TestEngine testEngine) {\n\t\t\tthis.testEngine = testEngine;\n\t\t}",
    "comment": "{@link TestEngine} execution builder.\n\n<p>See {@link EngineTestKit#engine(String)} and\n{@link EngineTestKit#engine(TestEngine)} for example usage.\n\n@since 1.4\n@see #selectors(DiscoverySelector...)\n@see #filters(Filter...)\n@see #configurationParameter(String, String)\n@see #configurationParameters(Map)\n@see #execute()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toUpperCase",
    "code": "public UTF8String toUpperCase() {\n    if (numBytes == 0) {\n      return EMPTY_UTF8;\n    }\n\n    return isFullAscii() ? toUpperCaseAscii() : toUpperCaseSlow();\n  }",
    "comment": "Returns the upper case of this string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/resolver/transform/ReleaseArtifactTransformation.java",
    "type": "method",
    "name": "createMetadata",
    "code": "private ArtifactMetadata createMetadata(Artifact artifact) {\n        Versioning versioning = new Versioning();\n        versioning.updateTimestamp();\n        versioning.addVersion(artifact.getVersion());\n\n        if (artifact.isRelease()) {\n            versioning.setRelease(artifact.getVersion());\n        }\n\n        return new ArtifactRepositoryMetadata(artifact, versioning);\n    }",
    "comment": "TODO Should this be changed for MNG-6754 too?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/param/JavaParamsSuite.java",
    "type": "method",
    "name": "testParams",
    "code": "public void testParams() {\n    JavaTestParams testParams = new JavaTestParams();\n    Assertions.assertEquals(1, testParams.getMyIntParam());\n    testParams.setMyIntParam(2).setMyDoubleParam(0.4).setMyStringParam(\"a\");\n    Assertions.assertEquals(0.4, testParams.getMyDoubleParam(), 0.0);\n    Assertions.assertEquals(\"a\", testParams.getMyStringParam());\n    Assertions.assertArrayEquals(testParams.getMyDoubleArrayParam(), new double[]{1.0, 2.0}, 0.0);\n\n  @Test\n  public void testParamValidate() {\n    ParamValidators.gt(1.0);\n    ParamValidators.gtEq(1.0);\n    ParamValidators.lt(1.0);\n    ParamValidators.ltEq(1.0);\n    ParamValidators.inRange(0, 1, true, false);\n    ParamValidators.inRange(0, 1);\n    ParamValidators.inArray(Arrays.asList(0, 1, 3));\n    ParamValidators.inArray(Arrays.asList(\"a\", \"b\"));\n  }\n}",
    "comment": "Test Param and related classes in Java"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/session-facade/src/main/java/com/iluwatar/sessionfacade/ShoppingFacade.java",
    "type": "method",
    "name": "isPaymentRequired",
    "code": "public Boolean isPaymentRequired() {\n    double total = this.orderService.getTotal();\n    if (total == 0.0) {\n      LOGGER.info(\"No payment required\");\n      return false;\n    }\n    return true;\n  }",
    "comment": "Is payment required boolean.\n\n@return the boolean"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/CaseInsensitiveStringMap.java",
    "type": "method",
    "name": "getBoolean",
    "code": "public boolean getBoolean(String key, boolean defaultValue) {\n    String value = get(key);\n    // We can't use `Boolean.parseBoolean` here, as it returns false for invalid strings.\n    if (value == null) {\n      return defaultValue;\n    } else if (value.equalsIgnoreCase(\"true\")) {\n      return true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      return false;\n    } else {\n      throw new SparkIllegalArgumentException(\"_LEGACY_ERROR_TEMP_3206\", Map.of(\"value\", value));\n    }\n  }",
    "comment": "Returns the boolean value to which the specified key is mapped,\nor defaultValue if there is no mapping for the key. The key match is case-insensitive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java",
    "type": "method",
    "name": "constructFromClassWithInvalidBeforeAllDeclaration",
    "code": "void constructFromClassWithInvalidBeforeAllDeclaration() {\n\t\tClassTestDescriptor descriptor = new ClassTestDescriptor(uniqueId, TestCaseWithInvalidBeforeAllMethod.class,\n\t\t\tconfiguration);\n\n\t\tassertEquals(TestCaseWithInvalidBeforeAllMethod.class, descriptor.getTestClass());\n\t}",
    "comment": "Note: if we can instantiate the descriptor, then the invalid configuration\nwill not be reported during the test engine discovery phase."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/model/MavenModelMergerTest.java",
    "type": "method",
    "name": "testMergeModelArtifactId",
    "code": "void testMergeModelArtifactId() {\n        Model parent = Model.newBuilder().artifactId(\"PARENT\").build();\n        Model model = Model.newInstance();\n        Model.Builder builder = Model.newBuilder(model);\n        modelMerger.mergeModel_ArtifactId(builder, model, parent, false, null);\n        assertNull(model.getArtifactId());\n\n        model = Model.newBuilder().artifactId(\"MODEL\").build();\n        builder = Model.newBuilder(model);\n        modelMerger.mergeModel_ArtifactId(builder, model, parent, false, null);\n        assertEquals(\"MODEL\", builder.build().getArtifactId());\n    }",
    "comment": "ArtifactId is neither inherited nor injected"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ArtifactCoordinatesFactory.java",
    "type": "method",
    "name": "create",
    "code": "default ArtifactCoordinates create(@Nonnull Session session, @Nonnull String coordinatesString) {\n        return create(ArtifactCoordinatesFactoryRequest.build(session, coordinatesString));\n    }",
    "comment": "Creates coordinates out of string that is formatted like:\n{@code <groupId>:<artifactId>[:<extension>[:<classifier>]]:<version>}\n\n@param session the session.\n@param coordinatesString the string having \"standard\" coordinates.\n@return an {@code ArtifactCoordinates}, never {@code null}\n@throws IllegalArgumentException if {@code session} is null or invalid"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-distributed-tracing/order-microservice/src/main/java/com/iluwatar/order/microservice/OrderService.java",
    "type": "method",
    "name": "OrderService",
    "code": "public OrderService(final RestTemplateBuilder restTemplateBuilder) {\n    this.restTemplateBuilder = restTemplateBuilder;\n  }",
    "comment": "Constructor to inject RestTemplateBuilder.\n\n@param restTemplateBuilder the RestTemplateBuilder to build RestTemplate instances"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom3/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "deleteAndGetUser",
    "code": "public void deleteAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        mDataSource.deleteAllUsers();\n\n        User dbUser = mDataSource.getUser();\n        assertNull(dbUser);\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are deleting all users\nThe user is no longer in the data source"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaDatasetSuite.java",
    "type": "method",
    "name": "testIllegalTestGroupStateCreations",
    "code": "public void testIllegalTestGroupStateCreations() {\n    Assertions.assertThrows(\n      IllegalArgumentException.class,\n      () -> TestGroupState.create(\n        Optional.of(5), GroupStateTimeout.EventTimeTimeout(), 0L, Optional.of(-1000L), false),\n      \"eventTimeWatermarkMs must be 0 or positive if present\");\n\n    Assertions.assertThrows(\n      IllegalArgumentException.class,\n      () -> TestGroupState.create(\n        Optional.of(5), GroupStateTimeout.EventTimeTimeout(), -100L, Optional.of(1000L), false),\n      \"batchProcessingTimeMs must be 0 or positive\");\n\n    Assertions.assertThrows(\n      UnsupportedOperationException.class,\n      () -> TestGroupState.create(\n        Optional.of(5), GroupStateTimeout.NoTimeout(), 100L, Optional.empty(), true),\n      \"hasTimedOut is true however there's no timeout configured\");\n  }",
    "comment": "SPARK-35800: test code throws upon illegal TestGroupState create() calls"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/io/LocalDiskShuffleMapOutputWriter.java",
    "type": "method",
    "name": "getNumBytesWritten",
    "code": "public long getNumBytesWritten() {\n      if (partChannel != null) {\n        try {\n          return partChannel.getCount();\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      } else if (partStream != null) {\n        return partStream.getCount();\n      } else {\n        return 0;\n      }\n    }",
    "comment": "Assume an empty partition if stream and channel are never created"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/json/JsonExpressionUtils.java",
    "type": "method",
    "name": "lengthOfJsonArray",
    "code": "public static Integer lengthOfJsonArray(UTF8String json) {\n    try (JsonParser jsonParser =\n        CreateJacksonParser.utf8String(SharedFactory.jsonFactory(), json)) {\n      if (jsonParser.nextToken() == null) {\n        return null;\n      }\n      if (jsonParser.currentToken() != JsonToken.START_ARRAY) {\n        return null;\n      }\n      int length = 0;\n      while (jsonParser.nextToken() != JsonToken.END_ARRAY) {\n        length += 1;\n        jsonParser.skipChildren();\n      }\n      return length;\n    } catch (IOException e) {\n      return null;\n    }\n  }",
    "comment": "Only JSON array are supported for this function.\nParse the array to compute its length.\nKeep traversing until the end of JSON array\nskip all the child of inner object or array"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/test/java/org/apache/spark/sql/hive/JavaDataFrameSuite.java",
    "type": "method",
    "name": "testUDAF",
    "code": "public void testUDAF() {\n    Dataset<Row> df = hc.range(0, 100).union(hc.range(0, 100)).select(col(\"id\").as(\"value\"));\n    UserDefinedAggregateFunction udaf = new MyDoubleSum();\n    UserDefinedAggregateFunction registeredUDAF = hc.udf().register(\"mydoublesum\", udaf);\n    Dataset<Row> aggregatedDF =\n      df.groupBy()\n        .agg(\n          udaf.distinct(col(\"value\")),\n          udaf.apply(col(\"value\")),\n          registeredUDAF.apply(col(\"value\")),\n          callUDF(\"mydoublesum\", col(\"value\")));  // test deprecated one\n\n    List<Row> expectedResult = new ArrayList<>();\n    expectedResult.add(RowFactory.create(4950.0, 9900.0, 9900.0, 9900.0));\n    checkAnswer(\n      aggregatedDF,\n      expectedResult);\n  }",
    "comment": "Create Columns for the UDAF. For now, callUDF does not take an argument to specific if\nwe want to use distinct aggregation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/SupportsDeleteV2.java",
    "type": "method",
    "name": "canDeleteWhere",
    "code": "default boolean canDeleteWhere(Predicate[] predicates) {\n    return true;\n  }",
    "comment": "Checks whether it is possible to delete data from a data source table that matches filter\nexpressions.\n<p>\nRows should be deleted from the data source iff all of the filter expressions match.\nThat is, the expressions must be interpreted as a set of filters that are ANDed together.\n<p>\nSpark will call this method at planning time to check whether {@link #deleteWhere(Predicate[])}\nwould reject the delete operation because it requires significant effort. If this method\nreturns false, Spark will not call {@link #deleteWhere(Predicate[])} and will try to rewrite\nthe delete operation and produce row-level changes if the data source table supports deleting\nindividual records.\n\n@param predicates V2 filter expressions, used to select rows to delete when all expressions\nmatch\n@return true if the delete operation can be performed\n\n@since 3.4.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(char[] expecteds, char[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }",
    "comment": "Asserts that two char arrays are equal. If they are not, an\n{@link AssertionError} is thrown.\n\n@param expecteds char array with expected values.\n@param actuals char array with actual values"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/Result.java",
    "type": "method",
    "name": "newResultSet",
    "code": "public static <T> Result<Iterable<T>> newResultSet(Iterable<? extends Result<? extends T>> results) {\n        boolean hasErrors = false;\n        List<T> modelsList = new ArrayList<>();\n        List<ModelProblem> problemsList = new ArrayList<>();\n\n        for (Result<? extends T> result : results) {\n            modelsList.add(result.get());\n\n            for (ModelProblem modelProblem : result.getProblems()) {\n                problemsList.add(modelProblem);\n            }\n\n            if (result.hasErrors()) {\n                hasErrors = true;\n            }\n        }\n        return new Result<>(hasErrors, modelsList, problemsList);\n    }",
    "comment": "Turns the given results into a single result by combining problems and models into single collection.\n\n@param results"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testBagSubtract",
    "code": "public void testBagSubtract() {\n        IMoney expected = MoneyBag.create(new Money(-2, \"CHF\"), new Money(-14, \"USD\"));\n        assertEquals(expected, fMB1.subtract(fMB2));\n    }",
    "comment": "{[12 CHF][7 USD]} - {[14 CHF][21 USD] == {[-2 CHF][-14 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/BuildSummary.java",
    "type": "method",
    "name": "BuildSummary",
    "code": "protected BuildSummary(MavenProject project, Duration execTime, Duration wallTime) {\n        this.project = Objects.requireNonNull(project, \"project cannot be null\");\n        // TODO Validate for < 0?\n        this.execTime = execTime;\n        this.wallTime = wallTime;\n    }",
    "comment": "Creates a new build summary for the specified project.\n\n@param project The project being summarized, must not be {@code null}.\n@param execTime The exec time of the project in milliseconds.\n@param wallTime The wall time of the project in milliseconds."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/SerializableMatcherDescription.java",
    "type": "method",
    "name": "SerializableMatcherDescription",
    "code": "private SerializableMatcherDescription(Matcher<T> matcher) {\n        matcherDescription = StringDescription.asString(matcher);\n    }",
    "comment": "This class exists solely to provide a serializable description of a matcher to be serialized as a field in\n{@link AssumptionViolatedException}. Being a {@link Throwable}, it is required to be {@link Serializable}, but most\nimplementations of {@link Matcher} are not. This class works around that limitation as\n{@link AssumptionViolatedException} only every uses the description of the {@link Matcher}, while still retaining\nbackwards compatibility with classes compiled against its class signature before 4.14 and/or deserialization of\npreviously serialized instances."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "filters",
    "code": "public Builder filters(DiscoveryFilter<?>... filters) {\n\t\t\tthis.requestBuilder.filters(filters);\n\t\t\treturn this;\n\t\t}",
    "comment": "Add all of the supplied {@linkplain DiscoveryFilter discovery filters}.\n\n<p>Built-in discovery filters can be created via the static factory\nmethods in {@link org.junit.platform.engine.discovery.ClassNameFilter}\nand {@link org.junit.platform.engine.discovery.PackageNameFilter}.\n\n@param filters the discovery filters to add; never {@code null}\n@return this builder for method chaining\n@see #filters(Filter...)\n@see #selectors(DiscoverySelector...)\n@see #configurationParameter(String, String)\n@see #configurationParameters(Map)\n@see #execute()\n@deprecated Please use {@link #filters(Filter...)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProjectActivation.java",
    "type": "method",
    "name": "overwriteActiveProjects",
    "code": "public void overwriteActiveProjects(List<String> activeProjectSelectors) {\n        List<ProjectActivationSettings> projects =\n                getProjects(pa -> pa.active()).toList();\n        this.activations.removeAll(projects);\n        activeProjectSelectors.forEach(this::activateOptionalProject);\n    }",
    "comment": "Overwrites the active projects based on a pre-Maven 4 \"active projects\" list.\n@param activeProjectSelectors A {@link List} of project selectors that must be activated.\n@deprecated Use {@link #activateOptionalProject(String)} or {@link #activateRequiredProject(String)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "setActiveProfileIds",
    "code": "public DefaultProfileActivationContext setActiveProfileIds(List<String> activeProfileIds) {\n        this.activeProfileIds = unmodifiable(activeProfileIds);\n        return this;\n    }",
    "comment": "Sets the identifiers of those profiles that should be activated by explicit demand.\n\n@param activeProfileIds The identifiers of those profiles to activate, may be {@code null}.\n@return This context, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java",
    "type": "method",
    "name": "parseVersion",
    "code": "public final void parseVersion(String version) {\n        this.value = version;\n\n        items = new ListItem();\n\n        version = version.toLowerCase(Locale.ENGLISH);\n\n        ListItem list = items;\n\n        Deque<Item> stack = new ArrayDeque<>();\n        stack.push(list);\n\n        boolean isDigit = false;\n\n        boolean isCombination = false;\n\n        int startIndex = 0;\n\n        for (int i = 0; i < version.length(); i++) {\n            char character = version.charAt(i);\n            int c = character;\n            if (Character.isHighSurrogate(character)) {\n                try {\n                    char low = version.charAt(i + 1);\n                    char[] both = {character, low};\n                    c = Character.codePointAt(both, 0);\n                    i++;\n                } catch (IndexOutOfBoundsException ex) {\n                }\n            }\n\n            if (c == '.') {\n                if (i == startIndex) {\n                    list.add(IntItem.ZERO);\n                } else {\n                    list.add(parseItem(isCombination, isDigit, version.substring(startIndex, i)));\n                }\n                isCombination = false;\n                startIndex = i + 1;\n            } else if (c == '-') {\n                if (i == startIndex) {\n                    list.add(IntItem.ZERO);\n                } else {\n                    if (!isDigit && i != version.length() - 1) {\n                        char c1 = version.charAt(i + 1);\n                        if (Character.isDigit(c1)) {\n                            isCombination = true;\n                            continue;\n                        }\n                    }\n                    list.add(parseItem(isCombination, isDigit, version.substring(startIndex, i)));\n                }\n                startIndex = i + 1;\n\n                if (!list.isEmpty()) {\n                    list.add(list = new ListItem());\n                    stack.push(list);\n                }\n                isCombination = false;\n            } else if (c >= '0' && c <= '9') { // Check for ASCII digits only\n                if (!isDigit && i > startIndex) {\n                    isCombination = true;\n\n                    if (!list.isEmpty()) {\n                        list.add(list = new ListItem());\n                        stack.push(list);\n                    }\n                }\n\n                isDigit = true;\n            } else {\n                if (isDigit && i > startIndex) {\n                    list.add(parseItem(isCombination, true, version.substring(startIndex, i)));\n                    startIndex = i;\n\n                    list.add(list = new ListItem());\n                    stack.push(list);\n                    isCombination = false;\n                }\n\n                isDigit = false;\n            }\n        }\n\n        if (version.length() > startIndex) {\n            if (!isDigit && !list.isEmpty()) {\n                list.add(list = new ListItem());\n                stack.push(list);\n            }\n\n            list.add(parseItem(isCombination, isDigit, version.substring(startIndex)));\n        }\n\n        while (!stack.isEmpty()) {\n            list = (ListItem) stack.pop();\n            list.normalize();\n        }\n    }",
    "comment": "read the next character as a low surrogate and combine into a single int\nhigh surrogate without low surrogate. Not a lot we can do here except treat it as a regular\ncharacter\nX-1 is going to be treated as X1\nX1\n1.0.0.X1 < 1.0.0-X2\ntreat .X as -X for any string qualifier X"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(int unexpected, int actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/strangler/src/main/java/com/iluwatar/strangler/HalfArithmetic.java",
    "type": "method",
    "name": "ifHasZero",
    "code": "public boolean ifHasZero(int... nums) {\n    LOGGER.info(\"Arithmetic check zero {}\", VERSION);\n    return !newSource.ifNonZero(nums);\n  }",
    "comment": "Check if it has any zero.\n\n@param nums numbers need to check\n@return if it has any zero, return true, else, return false"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assume.java",
    "type": "method",
    "name": "assumeNoException",
    "code": "public static void assumeNoException(String message, Throwable e) {\n        assumeThat(message, e, nullValue());\n    }",
    "comment": "Attempts to halt the test and ignore it if Throwable <code>e</code> is\nnot <code>null</code>. Similar to {@link #assumeNoException(Throwable)},\nbut provides an additional message that can explain the details\nconcerning the assumption.\n\n@param e if non-null, the offending exception\n@param message Additional message to pass to {@link AssumptionViolatedException}.\n@see #assumeNoException(Throwable)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/observer/src/test/java/com/iluwatar/observer/generic/GWeatherTest.java",
    "type": "method",
    "name": "testAddRemoveObserver",
    "code": "void testAddRemoveObserver() {\n    final var observer = mock(Race.class);\n\n    final var weather = new GenWeather();\n    weather.addObserver(observer);\n    verifyNoMoreInteractions(observer);\n\n    weather.timePasses();\n    assertEquals(\"The weather changed to rainy.\", appender.getLastMessage());\n    verify(observer).update(weather, WeatherType.RAINY);\n\n    weather.removeObserver(observer);\n    weather.timePasses();\n    assertEquals(\"The weather changed to windy.\", appender.getLastMessage());\n\n    verifyNoMoreInteractions(observer);\n    assertEquals(2, appender.getLogSize());\n  }",
    "comment": "Add a {@link WeatherObserver}, verify if it gets notified of a weather change, remove the\nobserver again and verify that there are no more notifications."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/UnsafeShuffleWriter.java",
    "type": "method",
    "name": "stop",
    "code": "public Option<MapStatus> stop(boolean success) {\n    try {\n      taskContext.taskMetrics().incPeakExecutionMemory(getPeakMemoryUsedBytes());\n\n      if (stopping) {\n        return Option.apply(null);\n      } else {\n        stopping = true;\n        if (success) {\n          if (mapStatus == null) {\n            throw new IllegalStateException(\"Cannot call stop(true) without having called write()\");\n          }\n          return Option.apply(mapStatus);\n        } else {\n          return Option.apply(null);\n        }\n      }\n    } finally {\n      if (sorter != null) {\n        sorter.cleanupResources();\n      }\n    }\n  }",
    "comment": "If sorter is non-null, then this implies that we called stop() in response to an error,\nso we need to clean up memory and spill files created by the sorter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "writeTo",
    "code": "public void writeTo(FloatBuffer dst) {\n    if (dtype != DataType.FLOAT) {\n      throw incompatibleBuffer(dst, dtype);\n    }\n    ByteBuffer src = buffer();\n    dst.put(src.asFloatBuffer());\n  }",
    "comment": "Write the data of a {@link Float} tensor into the given buffer.\n\n<p>Copies {@code numElements()} elements to the buffer.\n\n@param dst the destination buffer\n@throws BufferOverflowException If there is insufficient space in the given buffer for the data\nin this tensor\n@throws IllegalArgumentException If the tensor datatype is not {@link Float}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/NativeLibrary.java",
    "type": "method",
    "name": "load",
    "code": "public static void load() {\n    if (isLoaded() || tryLoadLibrary()) {\n      // Either:\n      // (1) The native library has already been statically loaded, OR\n      // (2) The required native code has been statically linked (through a custom launcher), OR\n      // (3) The native code is part of another library (such as an application-level library)\n      // that has already been loaded. For example, tensorflow/tools/android/test and\n      // tensorflow/tools/android/inference_interface include the required native code in\n      // differently named libraries.\n      //\n      // Doesn't matter how, but it seems the native code is loaded, so nothing else to do.\n      return;\n    }\n    // Native code is not present, perhaps it has been packaged into the .jar file containing this.\n    // Extract the JNI library itself\n    final String jniLibName = System.mapLibraryName(JNI_LIBNAME);\n    final String jniResourceName = makeResourceName(jniLibName);\n    log(\"jniResourceName: \" + jniResourceName);\n    final InputStream jniResource =\n        NativeLibrary.class.getClassLoader().getResourceAsStream(jniResourceName);\n    // Extract the JNI's dependency\n    final String frameworkLibName =\n        getVersionedLibraryName(System.mapLibraryName(\"tensorflow_framework\"));\n    final String frameworkResourceName = makeResourceName(frameworkLibName);\n    log(\"frameworkResourceName: \" + frameworkResourceName);\n    final InputStream frameworkResource =\n        NativeLibrary.class.getClassLoader().getResourceAsStream(frameworkResourceName);\n    // Do not complain if the framework resource wasn't found. This may just mean that we're\n    // building with --config=monolithic (in which case it's not needed and not included).\n    if (jniResource == null) {\n      throw new UnsatisfiedLinkError(\n          String.format(\n              \"Cannot find TensorFlow native library for OS: %s, architecture: %s. See \"\n                  + \"https://github.com/tensorflow/tensorflow/tree/master/tensorflow/java/README.md\"\n                  + \" for possible solutions (such as building the library from source). Additional\"\n                  + \" information on attempts to find the native library can be obtained by adding\"\n                  + \" org.tensorflow.NativeLibrary.DEBUG=1 to the system properties of the JVM.\",\n              os(), architecture()));\n    }\n    try {\n      // Create a temporary directory for the extracted resource and its dependencies.\n      final File tempPath = createTemporaryDirectory();\n      // Deletions are in the reverse order of requests, so we need to request that the directory be\n      // deleted first, so that it is empty when the request is fulfilled.\n      tempPath.deleteOnExit();\n      final String tempDirectory = tempPath.getCanonicalPath();\n      if (frameworkResource != null) {\n        extractResource(frameworkResource, frameworkLibName, tempDirectory);\n      } else {\n        log(\n            frameworkResourceName\n                + \" not found. This is fine assuming \"\n                + jniResourceName\n                + \" is not built to depend on it.\");\n      }\n      System.load(extractResource(jniResource, jniLibName, tempDirectory));\n    } catch (IOException e) {\n      throw new UnsatisfiedLinkError(\n          String.format(\n              \"Unable to extract native library into a temporary file (%s)\", e.toString()));\n    }\n  }",
    "comment": "Helper class for loading the TensorFlow Java native library.\n\n<p>The Java TensorFlow bindings require a native (JNI) library. This library\n(libtensorflow_jni.so on Linux, libtensorflow_jni.dylib on OS X, tensorflow_jni.dll on Windows)\ncan be made available to the JVM using the java.library.path System property (e.g., using\n-Djava.library.path command-line argument). However, doing so requires an additional step of\nconfiguration.\n\n<p>Alternatively, the native libraries can be packaed in a .jar, making them easily usable from\nbuild systems like Maven. However, in such cases, the native library has to be extracted from the\n.jar archive.\n\n<p>NativeLibrary.load() takes care of this. First looking for the library in java.library.path\nand failing that, it tries to find the OS and architecture specific version of the library in the\nset of ClassLoader resources (under org/tensorflow/native/OS-ARCH). The resources paths used for\nlookup must be consistent with any packaging (such as on Maven Central) of the TensorFlow Java\nnative libraries."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/client/TransportClient.java",
    "type": "method",
    "name": "setClientId",
    "code": "public void setClientId(String id) {\n    Preconditions.checkState(clientId == null, \"Client ID has already been set.\");\n    this.clientId = id;\n  }",
    "comment": "Sets the authenticated client ID. This is meant to be used by the authentication layer.\n\nTrying to set a different client ID after it's been set will result in an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/test/java/com/iluwatar/circuitbreaker/AppTest.java",
    "type": "method",
    "name": "setupCircuitBreakers",
    "code": "void setupCircuitBreakers() {\n    var delayedService = new DelayedRemoteService(System.nanoTime(), STARTUP_DELAY);\n    // Set the circuit Breaker parameters\n    delayedServiceCircuitBreaker =\n        new DefaultCircuitBreaker(\n            delayedService, 3000, FAILURE_THRESHOLD, RETRY_PERIOD * 1000 * 1000 * 1000);\n\n    var quickService = new QuickRemoteService();\n    // Set the circuit Breaker parameters\n    quickServiceCircuitBreaker =\n        new DefaultCircuitBreaker(\n            quickService, 3000, FAILURE_THRESHOLD, RETRY_PERIOD * 1000 * 1000 * 1000);\n\n    monitoringService =\n        new MonitoringService(delayedServiceCircuitBreaker, quickServiceCircuitBreaker);\n  }",
    "comment": "Set up the circuit breakers and services, where {@link DelayedRemoteService} will be start with\na delay of 4 seconds and a {@link QuickRemoteService} responding healthy. Both services are\nwrapped in a {@link DefaultCircuitBreaker} implementation with failure threshold of 1 failure\nand retry time period of 2 seconds."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "hasErrors",
    "code": "public boolean hasErrors() {\n    return getNnapiErrno() != 0 /*ANEURALNETWORKS_NO_ERROR*/;\n  }",
    "comment": "Returns true if any NNAPI call failed since this delegate was associated with an <a\nhref=https://www.tensorflow.org/lite/api_docs/java/org/tensorflow/lite/Interpreter>interpreter</a>.\n\n@throws IllegalStateException if the method is called after {@link #close() close}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "removeShuffleMerge",
    "code": "public void removeShuffleMerge(RemoveShuffleMerge msg) {\n    AppShuffleInfo appShuffleInfo = validateAndGetAppShuffleInfo(msg.appId);\n    if (appShuffleInfo.attemptId != msg.appAttemptId) {\n      throw new IllegalArgumentException(\n          String.format(\"The attempt id %s in this RemoveShuffleMerge message does not match \"\n                  + \"with the current attempt id %s stored in shuffle service for application %s\",\n              msg.appAttemptId, appShuffleInfo.attemptId, msg.appId));\n    }\n    appShuffleInfo.shuffles.compute(msg.shuffleId, (shuffleId, mergePartitionsInfo) -> {\n      if (mergePartitionsInfo == null) {\n        if (msg.shuffleMergeId == DELETE_ALL_MERGED_SHUFFLE) {\n          return null;\n        } else {\n          writeAppAttemptShuffleMergeInfoToDB(new AppAttemptShuffleMergeId(\n              msg.appId, msg.appAttemptId, msg.shuffleId, msg.shuffleMergeId));\n          return new AppShuffleMergePartitionsInfo(msg.shuffleMergeId, true);\n        }\n      }\n      boolean deleteCurrentMergedShuffle =\n          msg.shuffleMergeId == DELETE_ALL_MERGED_SHUFFLE ||\n              msg.shuffleMergeId == mergePartitionsInfo.shuffleMergeId;\n      int shuffleMergeIdToDelete = msg.shuffleMergeId != DELETE_ALL_MERGED_SHUFFLE ?\n          msg.shuffleMergeId : mergePartitionsInfo.shuffleMergeId;\n      if (deleteCurrentMergedShuffle ||\n          shuffleMergeIdToDelete > mergePartitionsInfo.shuffleMergeId) {\n        AppAttemptShuffleMergeId currentAppAttemptShuffleMergeId =\n            new AppAttemptShuffleMergeId(\n                msg.appId, msg.appAttemptId, msg.shuffleId, mergePartitionsInfo.shuffleMergeId);\n        if (!mergePartitionsInfo.isFinalized()) {\n          submitCleanupTask(() ->\n              closeAndDeleteOutdatedPartitions(\n                  currentAppAttemptShuffleMergeId, mergePartitionsInfo.shuffleMergePartitions));\n        } else {\n          submitCleanupTask(() ->\n              deleteMergedFiles(currentAppAttemptShuffleMergeId, appShuffleInfo,\n                  mergePartitionsInfo.getReduceIds(), false));\n        }\n      } else {\n        throw new RuntimeException(String.format(\"Asked to remove old shuffle merged data for \" +\n                \"application %s shuffleId %s shuffleMergeId %s, but current shuffleMergeId %s \",\n            msg.appId, msg.shuffleId, shuffleMergeIdToDelete, mergePartitionsInfo.shuffleMergeId));\n      }\n      writeAppAttemptShuffleMergeInfoToDB(new AppAttemptShuffleMergeId(\n          msg.appId, msg.appAttemptId, msg.shuffleId, shuffleMergeIdToDelete));\n      return new AppShuffleMergePartitionsInfo(shuffleMergeIdToDelete, true);\n    });\n  }",
    "comment": "Clean up shuffle data before the shuffle was finalized. Close and delete all the open\nfiles.\nCurrent shuffle was finalized, delete all the merged files through reduceIds set\nin finalizeShuffleMerge method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterApi.java",
    "type": "method",
    "name": "addDelegateFactory",
    "code": "public Options addDelegateFactory(DelegateFactory delegateFactory) {\n      delegateFactories.add(delegateFactory);\n      return this;\n    }",
    "comment": "Adds a {@link DelegateFactory} which will be invoked to apply its created {@link Delegate}\nduring interpreter creation.\n\n<p>Delegates from a delegated factory that was added here are applied after any delegates\nadded with {@link #addDelegate}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-class-loader/dep-a/src/main/java/org/apache/maven/plugin/coreit/SomeClass.java",
    "type": "method",
    "name": "methodA",
    "code": "public static String methodA() {\n        return \"A\";\n    }",
    "comment": "A test class that is <em>not</em> unique to this artifact. Other artifacts will deliberately contain an equally named\nclass (with different members) to check class path ordering of dependencies.\n\n@author Benjamin Bentmann"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/UnsafeFixedWidthAggregationMap.java",
    "type": "method",
    "name": "getAggregationBufferFromUnsafeRow",
    "code": "public UnsafeRow getAggregationBufferFromUnsafeRow(UnsafeRow key, int hash) {\n    final BytesToBytesMap.Location loc = map.lookup(\n      key.getBaseObject(),\n      key.getBaseOffset(),\n      key.getSizeInBytes(),\n      hash);\n    if (!loc.isDefined()) {\n      boolean putSucceeded = loc.append(\n        key.getBaseObject(),\n        key.getBaseOffset(),\n        key.getSizeInBytes(),\n        emptyAggregationBuffer,\n        Platform.BYTE_ARRAY_OFFSET,\n        emptyAggregationBuffer.length\n      );\n      if (!putSucceeded) {\n        return null;\n      }\n    }\n\n    currentAggregationBuffer.pointTo(\n      loc.getValueBase(),\n      loc.getValueOffset(),\n      loc.getValueLength()\n    );\n    return currentAggregationBuffer;\n  }",
    "comment": "Probe our map using the serialized key\nThis is the first time that we've seen this grouping key, so we'll insert a copy of the\nempty aggregation buffer into the map:\nReset the pointer to point to the value that we just stored or looked up:"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(Object[] expecteds, Object[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }",
    "comment": "Asserts that two object arrays are equal. If they are not, an\n{@link AssertionError} is thrown. If <code>expected</code> and\n<code>actual</code> are <code>null</code>, they are considered\nequal.\n\n@param expecteds Object array or array of arrays (multi-dimensional array) with\nexpected values\n@param actuals Object array or array of arrays (multi-dimensional array) with\nactual values"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/SingleTableInheritance.java",
    "type": "method",
    "name": "run",
    "code": "public void run(String... args) {\n\n    Logger log = LoggerFactory.getLogger(SingleTableInheritance.class);\n\n    log.info(\"Saving Vehicles :- \");\n\n    // Saving Car to DB as a Vehicle\n    Vehicle vehicle1 = new Car(\"Tesla\", \"Model S\", 4, 825);\n    Vehicle car1 = vehicleService.saveVehicle(vehicle1);\n    log.info(\"Vehicle 1 saved : {}\", car1);\n\n    // Saving Truck to DB as a Vehicle\n    Vehicle vehicle2 = new Truck(\"Ford\", \"F-150\", 3325, 14000);\n    Vehicle truck1 = vehicleService.saveVehicle(vehicle2);\n    log.info(\"Vehicle 2 saved : {}\\n\", truck1);\n\n    log.info(\"Fetching Vehicles :- \");\n\n    // Fetching the Car from DB\n    Car savedCar1 = (Car) vehicleService.getVehicle(vehicle1.getVehicleId());\n    log.info(\"Fetching Car1 from DB : {}\", savedCar1);\n\n    // Fetching the Truck from DB\n    Truck savedTruck1 = (Truck) vehicleService.getVehicle(vehicle2.getVehicleId());\n    log.info(\"Fetching Truck1 from DB : {}\\n\", savedTruck1);\n\n    log.info(\"Fetching All Vehicles :- \");\n\n    // Fetching the Vehicles present in the DB\n    List<Vehicle> allVehiclesFromDb = vehicleService.getAllVehicles();\n    allVehiclesFromDb.forEach(s -> log.info(s.toString()));\n  }",
    "comment": "The starting point of the CommandLineRunner where the main program is run.\n\n@param args program runtime arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/LocalRepositoryNotAccessibleException.java",
    "type": "method",
    "name": "LocalRepositoryNotAccessibleException",
    "code": "public LocalRepositoryNotAccessibleException(String message, Throwable cause) {\n        super(message);\n        initCause(cause);\n    }",
    "comment": "Signals a failure to store files within the local repository."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/categories/Categories.java",
    "type": "method",
    "name": "hasCorrectCategoryAnnotation",
    "code": "private boolean hasCorrectCategoryAnnotation(Description description) {\n            final Set<Class<?>> childCategories= categories(description);\n\n            if (childCategories.isEmpty()) {\n                return included.isEmpty();\n            }\n\n            if (!excluded.isEmpty()) {\n                if (excludedAny) {\n                    if (matchesAnyParentCategories(childCategories, excluded)) {\n                        return false;\n                    }\n                } else {\n                    if (matchesAllParentCategories(childCategories, excluded)) {\n                        return false;\n                    }\n                }\n            }\n\n            if (included.isEmpty()) {\n                return true;\n            } else {\n                if (includedAny) {\n                    return matchesAnyParentCategories(childCategories, included);\n                } else {\n                    return matchesAllParentCategories(childCategories, included);\n                }\n            }\n        }",
    "comment": "If a child has no categories, immediately return.\nCouldn't be excluded, and with no suite's included categories treated as should run."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertNotSame",
    "code": "public static void assertNotSame(Object unexpected, Object actual) {\n        assertNotSame(null, unexpected, actual);\n    }",
    "comment": "Asserts that two objects do not refer to the same object. If they do\nrefer to the same object, an {@link AssertionError} without a message is\nthrown.\n\n@param unexpected the object you don't expect\n@param actual the object to compare to <code>unexpected</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-yarn/src/main/java/org/apache/spark/network/yarn/YarnShuffleServiceMetrics.java",
    "type": "method",
    "name": "getMetrics",
    "code": "public void getMetrics(MetricsCollector collector, boolean all) {\n    MetricsRecordBuilder metricsRecordBuilder = collector.addRecord(metricsNamespace);\n\n    for (Map.Entry<String, Metric> entry : metricSet.getMetrics().entrySet()) {\n      collectMetric(metricsRecordBuilder, entry.getKey(), entry.getValue());\n    }\n  }",
    "comment": "Get metrics from the source\n\n@param collector to contain the resulting metrics snapshot\n@param all       if true, return all metrics even if unchanged."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "isMutable",
    "code": "public static boolean isMutable(DataType dt) {\n    if (dt instanceof UserDefinedType udt) {\n      return isMutable(udt.sqlType());\n    }\n    PhysicalDataType pdt = PhysicalDataType.apply(dt);\n    return pdt instanceof PhysicalPrimitiveType || pdt instanceof PhysicalDecimalType ||\n      pdt instanceof PhysicalCalendarIntervalType;\n  }",
    "comment": "Field types that can be updated in place in UnsafeRows (e.g. we support set() for these types)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java",
    "type": "method",
    "name": "message",
    "code": "public static Condition<Throwable> message(String expectedMessage) {\n\t\treturn new Condition<>(where(Throwable::getMessage, isEqual(expectedMessage)), \"message is '%s'\",\n\t\t\texpectedMessage);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if a\nto the supplied {@link String}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/DebugResolutionListener.java",
    "type": "method",
    "name": "updateScopeCurrentPom",
    "code": "public void updateScopeCurrentPom(Artifact artifact, String ignoredScope) {\n        logger.debug(indent + artifact + \" (not setting artifactScope to: \" + ignoredScope + \"; local artifactScope \"\n                + artifact.getScope() + \" wins)\");\n\n        if (!ignoredArtifacts.contains(artifact)) {\n            logger.warn(\"\\n\\tArtifact \" + artifact + \" retains local artifactScope '\" + artifact.getScope()\n                    + \"' overriding broader artifactScope '\" + ignoredScope + \"'\\n\"\n                    + \"\\tgiven by a dependency. If this is not intended, modify or remove the local artifactScope.\\n\");\n            ignoredArtifacts.add(artifact);\n        }\n    }",
    "comment": "TODO better way than static? this might hide messages in a reactor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/main/java/com/example/android/observability/Injection.java",
    "type": "method",
    "name": "provideUserDataSource",
    "code": "public static UserDataSource provideUserDataSource(Context context) {\n        UsersDatabase database = UsersDatabase.getInstance(context);\n        return new LocalUserDataSource(database.userDao());\n    }",
    "comment": "Enables injection of data sources."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TestWatchman.java",
    "type": "method",
    "name": "Statement",
    "code": "Object target) {\n        return new Statement() {\n                    throw e;\n                } catch (Throwable e) {\n                    failed(e, method);\n                    throw e;\n                } finally {\n                    finished(method);\n                }\n            }",
    "comment": "TestWatchman is a base class for Rules that take note of the testing\naction, without modifying it. For example, this class will keep a log of each\npassing and failing test:\n\n<pre>\npublic static class WatchmanTest {\nprivate static String watchedLog;\n\n&#064;Rule\npublic MethodRule watchman= new TestWatchman() {\n\n&#064;Override\npublic void succeeded(FrameworkMethod method) {\nwatchedLog+= method.getName() + &quot; &quot; + &quot;success!\\n&quot;;\n}\n};\n\n&#064;Test\npublic void fails() {\nfail();\n}\n\n&#064;Test\npublic void succeeds() {\n}\n}\n</pre>\n\n@since 4.7\n@deprecated Use {@link TestWatcher} (which implements {@link TestRule}) instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerOperation.java",
    "type": "method",
    "name": "dtype",
    "code": "public DataType dtype(int outputIndex) {\n    Tensor<?> tensor = outputTensors.get(outputIndex);\n    if (tensor != null) {\n      return tensor.dataType();\n    }\n    long outputNativeHandle = getUnsafeNativeHandle(outputIndex);\n    return DataType.fromC(dataType(outputNativeHandle));\n  }",
    "comment": "If the tensor of this output has already been resolved, return its datatype.\nOtherwise, retrieve the tensor datatype from the native library."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/ExecutionRecorder.java",
    "type": "method",
    "name": "executionFinished",
    "code": "public void executionFinished(TestDescriptor testDescriptor, TestExecutionResult testExecutionResult) {\n\t\tthis.events.add(Event.executionFinished(testDescriptor, testExecutionResult));\n\t}",
    "comment": "Record an {@link Event} for a container or test that completed\nwith the provided {@link TestExecutionResult}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeArrayWriter.java",
    "type": "method",
    "name": "write",
    "code": "public void write(int ordinal, Decimal input, int precision, int scale) {\n    assertIndexIsValid(ordinal);\n    if (input != null && input.changePrecision(precision, scale)) {\n      if (precision <= Decimal.MAX_LONG_DIGITS()) {\n        write(ordinal, input.toUnscaledLong());\n      } else {\n        final byte[] bytes = input.toJavaBigDecimal().unscaledValue().toByteArray();\n        final int numBytes = bytes.length;\n        assert numBytes <= 16;\n        int roundedSize = ByteArrayMethods.roundNumberOfBytesToNearestWord(numBytes);\n        holder.grow(roundedSize);\n\n        zeroOutPaddingBytes(numBytes);\n\n        Platform.copyMemory(\n          bytes, Platform.BYTE_ARRAY_OFFSET, getBuffer(), cursor(), numBytes);\n        setOffsetAndSize(ordinal, numBytes);\n\n        increaseCursor(roundedSize);\n      }\n    } else {\n      setNull(ordinal);\n    }\n  }",
    "comment": "make sure Decimal object has the same scale as DecimalType\nWrite the bytes to the variable length portion.\nmove the cursor forward with 8-bytes boundary"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java",
    "type": "method",
    "name": "getPluginsBoundByDefaultToAllLifecycles",
    "code": "public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles(String packaging) {\n        Set<Plugin> plugins;\n\n        if (\"JAR\".equals(packaging)) {\n            plugins = new LinkedHashSet<>();\n\n            plugins.add(newPlugin(\"maven-compiler-plugin\", \"compile\", \"testCompile\"));\n            plugins.add(newPlugin(\"maven-resources-plugin\", \"resources\", \"testResources\"));\n            plugins.add(newPlugin(\"maven-surefire-plugin\", \"test\"));\n            plugins.add(newPlugin(\"maven-jar-plugin\", \"jar\"));\n            plugins.add(newPlugin(\"maven-install-plugin\", \"install\"));\n            plugins.add(newPlugin(\"maven-deploy-plugin\", \"deploy\"));\n        } else {\n            plugins = Collections.emptySet();\n        }\n\n        return plugins;\n    }",
    "comment": "NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getFieldByKey",
    "code": "public Variant getFieldByKey(String key) {\n    return handleObject(value, pos, (size, idSize, offsetSize, idStart, offsetStart, dataStart) -> {\n      final int BINARY_SEARCH_THRESHOLD = 32;\n      if (size < BINARY_SEARCH_THRESHOLD) {\n        for (int i = 0; i < size; ++i) {\n          int id = readUnsigned(value, idStart + idSize * i, idSize);\n          if (key.equals(getMetadataKey(metadata, id))) {\n            int offset = readUnsigned(value, offsetStart + offsetSize * i, offsetSize);\n            return new Variant(value, metadata, dataStart + offset);\n          }\n        }\n      } else {\n        int low = 0;\n        int high = size - 1;\n        while (low <= high) {\n          int mid = (low + high) >>> 1;\n          int id = readUnsigned(value, idStart + idSize * mid, idSize);\n          int cmp = getMetadataKey(metadata, id).compareTo(key);\n          if (cmp < 0) {\n            low = mid + 1;\n          } else if (cmp > 0) {\n            high = mid - 1;\n          } else {\n            int offset = readUnsigned(value, offsetStart + offsetSize * mid, offsetSize);\n            return new Variant(value, metadata, dataStart + offset);\n          }\n        }\n      }\n      return null;\n    });\n  }",
    "comment": "Find the field value whose key is equal to `key`. Return null if the key is not found.\nIt is only legal to call it when `getType()` is `Type.OBJECT`.\nUse linear search for a short list. Switch to binary search when the length reaches\n`BINARY_SEARCH_THRESHOLD`.\nUse unsigned right shift to compute the middle of `low` and `high`. This is not only a\nperformance optimization, because it can properly handle the case where `low + high`\noverflows int."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/UniqueIdSelectorTests.java",
    "type": "method",
    "name": "equalsAndHashCode",
    "code": "void equalsAndHashCode() {\n\t\tvar testEngine = UniqueId.forEngine(\"test-engine\");\n\t\tvar selector1 = new UniqueIdSelector(testEngine.append(\"test-class\", \"org.example.TestClass\"));\n\t\tvar selector2 = new UniqueIdSelector(testEngine.append(\"test-class\", \"org.example.TestClass\"));\n\t\tvar selector3 = new UniqueIdSelector(testEngine.append(\"test-class\", \"org.example.FooBar\"));\n\n\t\tassertEqualsAndHashCode(selector1, selector2, selector3);\n\t}",
    "comment": "Unit tests for {@link UniqueIdSelector}.\n\n@since 1.3\n@see DiscoverySelectorsTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/test/java/org/apache/maven/artifact/versioning/ComparableVersionTest.java",
    "type": "method",
    "name": "testCompareDigitToLetter",
    "code": "void testCompareDigitToLetter() {\n        ComparableVersion seven = new ComparableVersion(\"7\");\n        ComparableVersion capitalJ = new ComparableVersion(\"J\");\n        ComparableVersion lowerCaseC = new ComparableVersion(\"c\");\n        assertTrue(seven.compareTo(capitalJ) > 0, \"expected 7 > J\");\n        assertTrue(capitalJ.compareTo(seven) < 0, \"expected J < 1\");\n        assertTrue(seven.compareTo(lowerCaseC) > 0, \"expected 7 > c\");\n        assertTrue(lowerCaseC.compareTo(seven) < 0, \"expected c < 7\");\n    }",
    "comment": "Digits are greater than letters"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/collector/MultiModuleCollectionStrategy.java",
    "type": "method",
    "name": "isRequestedProjectCollected",
    "code": "private boolean isRequestedProjectCollected(MavenExecutionRequest request, List<MavenProject> projects) {\n        return projects.stream().map(MavenProject::getFile).anyMatch(request.getPom()::equals);\n    }",
    "comment": "multiModuleProjectDirectory in MavenExecutionRequest is not always the parent of the request pom.\nWe should always check whether the request pom project is collected.\nThe integration tests for MNG-6223 are examples for this scenario.\n\n@return true if the collected projects contain the requested project (for example with -f)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "getOutputTensor",
    "code": "TensorImpl getOutputTensor(String outputName, String signatureKey) {\n    if (outputName == null) {\n      throw new IllegalArgumentException(\"Invalid output tensor name provided (null)\");\n    }\n    NativeSignatureRunnerWrapper signatureRunnerWrapper = getSignatureRunnerWrapper(signatureKey);\n    int subgraphIndex = signatureRunnerWrapper.getSubgraphIndex();\n    if (subgraphIndex == 0) {\n      int outputIndex = signatureRunnerWrapper.getOutputIndex(outputName);\n      return getOutputTensor(outputIndex);\n    }\n    return signatureRunnerWrapper.getOutputTensor(outputName);\n  }",
    "comment": "Gets the output {@link TensorImpl} given the tensor name and method in the signature.\n\n@throws IllegalArgumentException if the output name is invalid."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "isValid",
    "code": "public boolean isValid() {\n    if (isValid == UTF8StringValidity.UNKNOWN) {\n      isValid = getIsValid();\n    }\n    return isValid == UTF8StringValidity.IS_VALID;\n  }",
    "comment": "Checks if the current UTF8String is valid.\n\n@return If string represents a valid UTF8 string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(long[] expected, long[] actual, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} long arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/metrics/prometheus/PrometheusHistogramMetricsTrackerFactory.java",
    "type": "method",
    "name": "PrometheusHistogramMetricsTrackerFactory",
    "code": "public PrometheusHistogramMetricsTrackerFactory(CollectorRegistry collectorRegistry) {\n      this.collectorRegistry = collectorRegistry;\n   }",
    "comment": "Constructor that allows to pass in a {@link CollectorRegistry} to which the\nHikari metrics are registered."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3052DepRepoAggregationTest.java",
    "type": "method",
    "name": "MavenITmng3052DepRepoAggregationTest",
    "code": "public MavenITmng3052DepRepoAggregationTest() {\n        super(\"(2.0.9,)\"); // only test in 2.0.10+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3052\">MNG-3052</a>.\n\nWhen a project dependency declares its own repositories, they should be used to\nresolve that dependency's dependencies. This includes both steps: determining\nthe dependency artifact information (version, etc.) AND resolving the actual\nartifact itself.\n\nNOTE: The SNAPSHOT versions are CRITICAL in this test, since they force the\ncorrect resolution of artifact metadata, which depends on having the correct\nset of repositories present.\n\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "container",
    "code": "public static Condition<Event> container(String uniqueIdSubstring) {\n\t\treturn container(uniqueIdSubstring(uniqueIdSubstring));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\na {@linkplain TestDescriptor#isContainer() container} and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the supplied\n{@link String}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeInMemorySorter.java",
    "type": "method",
    "name": "getSortedIterator",
    "code": "public UnsafeSorterIterator getSortedIterator() {\n    if (numRecords() == 0) {\n      // `array` might be null, so make sure that it is not accessed by returning early.\n      return new SortedIterator(0, 0);\n    }\n\n    int offset = 0;\n    long start = System.nanoTime();\n    if (sortComparator != null) {\n      if (this.radixSortSupport != null) {\n        offset = RadixSort.sortKeyPrefixArray(\n          array, nullBoundaryPos, (pos - nullBoundaryPos) / 2L, 0, 7,\n          radixSortSupport.sortDescending(), radixSortSupport.sortSigned());\n      } else {\n        MemoryBlock unused = new MemoryBlock(\n          array.getBaseObject(),\n          array.getBaseOffset() + pos * 8L,\n          (array.size() - pos) * 8L);\n        LongArray buffer = new LongArray(unused);\n        Sorter<RecordPointerAndKeyPrefix, LongArray> sorter =\n          new Sorter<>(new UnsafeSortDataFormat(buffer));\n        sorter.sort(array, 0, pos / 2, sortComparator);\n      }\n    }\n    totalSortTimeNanos += System.nanoTime() - start;\n    if (nullBoundaryPos > 0) {\n      assert radixSortSupport != null : \"Nulls are only stored separately with radix sort\";\n      LinkedList<UnsafeSorterIterator> queue = new LinkedList<>();\n\n      // The null order is either LAST or FIRST, regardless of sorting direction (ASC|DESC)\n      if (radixSortSupport.nullsFirst()) {\n        queue.add(new SortedIterator(nullBoundaryPos / 2, 0));\n        queue.add(new SortedIterator((pos - nullBoundaryPos) / 2, offset));\n      } else {\n        queue.add(new SortedIterator((pos - nullBoundaryPos) / 2, offset));\n        queue.add(new SortedIterator(nullBoundaryPos / 2, 0));\n      }\n      return new UnsafeExternalSorter.ChainedIterator(queue);\n    } else {\n      return new SortedIterator(pos / 2, offset);\n    }\n  }",
    "comment": "Return an iterator over record pointers in sorted order. For efficiency, all calls to\n{@code next()} will return the same mutable object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/Platform.java",
    "type": "method",
    "name": "throwException",
    "code": "public static void throwException(Throwable t) {\n    _UNSAFE.throwException(t);\n  }",
    "comment": "Raises an exception bypassing compiler checks for checked exceptions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/notification/RunNotifier.java",
    "type": "method",
    "name": "fireTestAssumptionFailed",
    "code": "public void fireTestAssumptionFailed(final Failure failure) {\n        new SafeNotifier() {\n        }.run();\n    }",
    "comment": "Invoke to tell listeners that an atomic test flagged that it assumed\nsomething false.\n\n@param failure the description of the test that failed and the\n{@link org.junit.AssumptionViolatedException} thrown"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnenc/EncryptParser.java",
    "type": "method",
    "name": "assembleOptions",
    "code": "protected Options assembleOptions(List<Options> parsedOptions) {\n        return parsedOptions.get(0);\n    }",
    "comment": "nothing to assemble, we deal with CLI only"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java",
    "type": "method",
    "name": "fixTimestamp",
    "code": "private void fixTimestamp(File metadataFile, Metadata metadata, Metadata reference) {\n        boolean changed = false;\n\n        if (metadata != null && reference != null) {\n            Versioning versioning = metadata.getVersioning();\n            Versioning versioningRef = reference.getVersioning();\n            if (versioning != null && versioningRef != null) {\n                String lastUpdated = versioning.getLastUpdated();\n                String now = versioningRef.getLastUpdated();\n                if (lastUpdated != null && now != null && now.compareTo(lastUpdated) < 0) {\n                    getLogger()\n                            .warn(\"The last updated timestamp in \" + metadataFile + \" refers to the future (now = \"\n                                    + now\n                                    + \", lastUpdated = \" + lastUpdated + \"). Please verify that the clocks of all\"\n                                    + \" deploying machines are reasonably synchronized.\");\n                    versioning.setLastUpdated(now);\n                    changed = true;\n                }\n            }\n        }\n\n        if (changed) {\n            getLogger().debug(\"Repairing metadata in \" + metadataFile);\n\n            try (OutputStream out = Files.newOutputStream(metadataFile.toPath())) {\n                new MetadataStaxWriter().write(out, metadata.getDelegate());\n            } catch (IOException | XMLStreamException e) {\n                String msg = \"Could not write fixed metadata to \" + metadataFile + \": \" + e.getMessage();\n                if (getLogger().isDebugEnabled()) {\n                    getLogger().warn(msg, e);\n                } else {\n                    getLogger().warn(msg);\n                }\n            }\n        }\n    }",
    "comment": "Ensures the last updated timestamp of the specified metadata does not refer to the future and fixes the local\nmetadata if necessary to allow proper merging/updating of metadata during deployment."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/OffHeapColumnVector.java",
    "type": "method",
    "name": "allocateColumns",
    "code": "public static OffHeapColumnVector[] allocateColumns(int capacity, StructField[] fields) {\n    OffHeapColumnVector[] vectors = new OffHeapColumnVector[fields.length];\n    for (int i = 0; i < fields.length; i++) {\n      vectors[i] = new OffHeapColumnVector(capacity, fields[i].dataType());\n    }\n    return vectors;\n  }",
    "comment": "Allocates columns to store elements of each field off heap.\nCapacity is the initial capacity of the vector and it will grow as necessary. Capacity is\nin number of elements, not number of bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "started",
    "code": "public Executions started() {\n\t\treturn new Executions(executionsByTerminationInfo(TerminationInfo::notSkipped), this.category + \" Started\");\n\t}",
    "comment": "Get the started {@link Executions} contained in this {@code Executions} object.\n\n@return the filtered {@code Executions}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/layered-architecture/src/main/java/com/iluwatar/layers/Runner.java",
    "type": "method",
    "name": "run",
    "code": "public void run(String... args) {\n    initializeData();\n    var cakeView = new CakeViewImpl(cakeBakingService);\n    cakeView.render();\n  }",
    "comment": "initialize sample data\ncreate view and render it"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java",
    "type": "method",
    "name": "getTestInstantiationExtensionContextScope",
    "code": "public ExtensionContextScope getTestInstantiationExtensionContextScope(ExtensionContext rootContext) {\n\t\treturn ExtensionContextScope.TEST_METHOD;\n\t}",
    "comment": "<em>Kitchen Sink</em> extension that implements every extension API\nsupported by JUnit Jupiter.\n\n<p>This extension should never actually be registered for any tests.\nRather, its sole purpose is to help ensure (via visual inspection)\nthat a concrete extension is able to implement all extension APIs\nsupported by JUnit Jupiter without any naming conflicts or\nambiguities with regard to method names or method signatures.\n{@link ExtensionComposabilityTests}, on the other hand, serves\nthe same purpose in a dynamic and automated fashion.\n\n@since 5.0\n@see ExtensionComposabilityTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/parquet/column/page/TestDataPage.java",
    "type": "method",
    "name": "TestDataPage",
    "code": "public TestDataPage(DataPage wrapped, long firstRowIndex) {\n    super(wrapped.getCompressedSize(), wrapped.getUncompressedSize(), wrapped.getValueCount(),\n      firstRowIndex);\n    this.wrapped = wrapped;\n  }",
    "comment": "A hack to create Parquet data pages with customized first row index. We have to put it under\n'org.apache.parquet.column.page' since the constructor of `DataPage` is package-private."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/observer/src/main/java/com/iluwatar/observer/generic/Observable.java",
    "type": "method",
    "name": "Observable",
    "code": "public Observable() {\n    this.observers = new CopyOnWriteArrayList<>();\n  }",
    "comment": "Generic observer inspired by Java Generics and Collection by {@literal Naftalin & Wadler}.\n\n@param <S> Subject\n@param <O> Observer\n@param <A> Argument type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Character unexpected, Character actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/parameter-object/src/main/java/com/iluwatar/parameter/object/SearchService.java",
    "type": "method",
    "name": "search",
    "code": "public String search(String type, String sortBy) {\n    return getQuerySummary(type, sortBy, SortOrder.ASC);\n  }",
    "comment": "Below two methods of name `search` is overloaded so that we can send a default value for one of\nthe criteria and call the final api. A default SortOrder is sent in the first method and a\ndefault SortBy is sent in the second method. So two separate method definitions are needed for\nhaving default values for one argument in each case. Hence, multiple overloaded methods are\nneeded as the number of argument increases."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedRleValuesReader.java",
    "type": "method",
    "name": "readBooleans",
    "code": "public void readBooleans(int total, WritableColumnVector c, int rowId) {\n    int left = total;\n    while (left > 0) {\n      if (this.currentCount == 0) this.readNextGroup();\n      int n = Math.min(left, this.currentCount);\n      switch (mode) {\n        case RLE -> c.putBooleans(rowId, n, currentValue != 0);\n        case PACKED -> {\n          for (int i = 0; i < n; ++i) {\n            c.putByte(rowId + i, (byte) currentBuffer[currentBufferIdx++]);\n          }\n        }\n      }\n      rowId += n;\n      left -= n;\n      currentCount -= n;\n    }\n  }",
    "comment": "For Boolean types, `currentBuffer[currentBufferIdx++]` can only be 0 or 1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/test/java/com/example/android/observability/UserViewModelTest.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n        MockitoAnnotations.initMocks(this);\n\n        mViewModel = new UserViewModel(mDataSource);\n    }",
    "comment": "Unit test for {@link UserViewModel}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/AbstractResponseMessage.java",
    "type": "method",
    "name": "AbstractResponseMessage",
    "code": "protected AbstractResponseMessage(ManagedBuffer body, boolean isBodyInFrame) {\n    super(body, isBodyInFrame);\n  }",
    "comment": "Abstract class for response messages."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/bytecode/src/main/java/com/iluwatar/bytecode/Wizard.java",
    "type": "method",
    "name": "playSound",
    "code": "public void playSound() {\n    LOGGER.info(\"Playing sound\");\n    numberOfPlayedSounds++;\n  }",
    "comment": "This class represent game objects which properties can be changed by instructions interpreted by\nvirtual machine."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/resolver/transform/LatestArtifactTransformation.java",
    "type": "method",
    "name": "transformForInstall",
    "code": "public void transformForInstall(Artifact artifact, ArtifactRepository localRepository) {\n    }",
    "comment": "metadata is added via addPluginArtifactMetadata"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultToolchainsBuilder.java",
    "type": "method",
    "name": "DefaultToolchainsBuilder",
    "code": "public DefaultToolchainsBuilder(Interpolator interpolator, ToolchainsXmlFactory toolchainsXmlFactory) {\n        this.interpolator = interpolator;\n        this.toolchainsXmlFactory = toolchainsXmlFactory;\n    }",
    "comment": "Builds the effective toolchains from a user toolchains file and/or a global toolchains file."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java",
    "type": "method",
    "name": "runDatasetCreationExample",
    "code": "private static void runDatasetCreationExample(SparkSession spark) {\n    Person person = new Person();\n    person.setName(\"Andy\");\n    person.setAge(32);\n\n    Encoder<Person> personEncoder = Encoders.bean(Person.class);\n    Dataset<Person> javaBeanDS = spark.createDataset(\n      Collections.singletonList(person),\n      personEncoder\n    );\n    javaBeanDS.show();\n\n    Encoder<Long> longEncoder = Encoders.LONG();\n    Dataset<Long> primitiveDS = spark.createDataset(Arrays.asList(1L, 2L, 3L), longEncoder);\n    Dataset<Long> transformedDS = primitiveDS.map(\n        (MapFunction<Long, Long>) value -> value + 1L,\n        longEncoder);\n    transformedDS.collect(); // Returns [2, 3, 4]\n\n    String path = \"examples/src/main/resources/people.json\";\n    Dataset<Person> peopleDS = spark.read().json(path).as(personEncoder);\n    peopleDS.show();\n  }",
    "comment": "$example off:create_ds$\n$example on:init_session$\n$example off:init_session$\n$example on:create_df$\nDisplays the content of the DataFrame to stdout\n+----+-------+\n| age|   name|\n+----+-------+\n|null|Michael|\n|  30|   Andy|\n|  19| Justin|\n+----+-------+\n$example off:create_df$\n$example on:untyped_ops$\nPrint the schema in a tree format\nroot\n|-- age: long (nullable = true)\n|-- name: string (nullable = true)\nSelect only the \"name\" column\n+-------+\n|   name|\n+-------+\n|Michael|\n|   Andy|\n| Justin|\n+-------+\nSelect everybody, but increment the age by 1\n+-------+---------+\n|   name|(age + 1)|\n+-------+---------+\n|Michael|     null|\n|   Andy|       31|\n| Justin|       20|\n+-------+---------+\nSelect people older than 21\n+---+----+\n|age|name|\n+---+----+\n| 30|Andy|\n+---+----+\nCount people by age\n+----+-----+\n| age|count|\n+----+-----+\n|  19|    1|\n|null|    1|\n|  30|    1|\n+----+-----+\n$example off:untyped_ops$\n$example on:run_sql$\nRegister the DataFrame as a SQL temporary view\n+----+-------+\n| age|   name|\n+----+-------+\n|null|Michael|\n|  30|   Andy|\n|  19| Justin|\n+----+-------+\n$example off:run_sql$\n$example on:global_temp_view$\nRegister the DataFrame as a global temporary view\nGlobal temporary view is tied to a system preserved database `global_temp`\n+----+-------+\n| age|   name|\n+----+-------+\n|null|Michael|\n|  30|   Andy|\n|  19| Justin|\n+----+-------+\nGlobal temporary view is cross-session\n+----+-------+\n| age|   name|\n+----+-------+\n|null|Michael|\n|  30|   Andy|\n|  19| Justin|\n+----+-------+\n$example off:global_temp_view$\n$example on:create_ds$\nCreate an instance of a Bean class\nEncoders are created for Java beans\n+---+----+\n|age|name|\n+---+----+\n| 32|Andy|\n+---+----+\nEncoders for most common types are provided in class Encoders\nDataFrames can be converted to a Dataset by providing a class. Mapping based on name\n+----+-------+\n| age|   name|\n+----+-------+\n|null|Michael|\n|  30|   Andy|\n|  19| Justin|\n+----+-------+\n$example off:create_ds$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/resolver/DefaultLegacyArtifactCollector.java",
    "type": "method",
    "name": "checkScopeUpdate",
    "code": "boolean checkScopeUpdate(ResolutionNode farthest, ResolutionNode nearest, List<ResolutionListener> listeners) {\n        boolean updateScope = false;\n        Artifact farthestArtifact = farthest.getArtifact();\n        Artifact nearestArtifact = nearest.getArtifact();\n\n        /* farthest is runtime and nearest has lower priority, change to runtime */\n        if (Artifact.SCOPE_RUNTIME.equals(farthestArtifact.getScope())\n                && (Artifact.SCOPE_TEST.equals(nearestArtifact.getScope())\n                        || Artifact.SCOPE_PROVIDED.equals(nearestArtifact.getScope()))) {\n            updateScope = true;\n        }\n\n        /* farthest is compile and nearest is not (has lower priority), change to compile */\n        if (Artifact.SCOPE_COMPILE.equals(farthestArtifact.getScope())\n                && !Artifact.SCOPE_COMPILE.equals(nearestArtifact.getScope())) {\n            updateScope = true;\n        }\n\n        /* current POM rules all, if nearest is in current pom, do not update its artifactScope */\n        if ((nearest.getDepth() < 2) && updateScope) {\n            updateScope = false;\n\n            fireEvent(ResolutionListener.UPDATE_SCOPE_CURRENT_POM, listeners, nearest, farthestArtifact);\n        }\n\n        if (updateScope) {\n            fireEvent(ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthestArtifact);\n\n            // previously we cloned the artifact, but it is more efficient to just update the artifactScope\n            // if problems are later discovered that the original object needs its original artifactScope value,\n            // cloning may\n            // again be appropriate\n            nearestArtifact.setScope(farthestArtifact.getScope());\n        }\n\n        return updateScope;\n    }",
    "comment": "Check if the artifactScope needs to be updated. <a\nhref=\"http://docs.codehaus.org/x/IGU#DependencyMediationandConflictResolution-Scoperesolution\">More info</a>.\n\n@param farthest farthest resolution node\n@param nearest nearest resolution node\n@param listeners"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "map",
    "code": "public <R> Stream<R> map(Function<? super Event, ? extends R> mapper) {\n\t\tPreconditions.notNull(mapper, \"Mapping function must not be null\");\n\t\treturn stream().map(mapper);\n\t}",
    "comment": "Shortcut for {@code events.stream().map(mapper)}.\n\n@param mapper a {@code Function} to apply to each event; never {@code null}\n@return the mapped stream of events; never {@code null}\n@see #stream()\n@see Stream#map(Function)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClassSource.java",
    "type": "method",
    "name": "from",
    "code": "public static ClassSource from(Class<?> javaClass) {\n\t\treturn new ClassSource(javaClass);\n\t}",
    "comment": "Create a new {@code ClassSource} using the supplied {@linkplain Class class}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/ModelProblemUtils.java",
    "type": "method",
    "name": "toId",
    "code": "static String toId(String groupId, String artifactId, String version) {\n        return ((groupId != null && !groupId.isEmpty()) ? groupId : \"[unknown-group-id]\")\n                + ':'\n                + ((artifactId != null && !artifactId.isEmpty()) ? artifactId : \"[unknown-artifact-id]\")\n                + ':'\n                + ((version != null && !version.isEmpty()) ? version : \"[unknown-version]\");\n    }",
    "comment": "Creates a user-friendly artifact id from the specified coordinates.\n\n@param groupId The group id, may be {@code null}.\n@param artifactId The artifact id, may be {@code null}.\n@param version The version, may be {@code null}.\n@return The user-friendly artifact id, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ColumnVectorUtils.java",
    "type": "method",
    "name": "populate",
    "code": "public static void populate(ConstantColumnVector col, InternalRow row, int fieldIdx) {\n    DataType t = col.dataType();\n    PhysicalDataType pdt = PhysicalDataType.apply(t);\n\n    if (row.isNullAt(fieldIdx)) {\n      col.setNull();\n    } else {\n      if (pdt instanceof PhysicalBooleanType) {\n        col.setBoolean(row.getBoolean(fieldIdx));\n      } else if (pdt instanceof PhysicalBinaryType) {\n        col.setBinary(row.getBinary(fieldIdx));\n      } else if (pdt instanceof PhysicalByteType) {\n        col.setByte(row.getByte(fieldIdx));\n      } else if (pdt instanceof PhysicalShortType) {\n        col.setShort(row.getShort(fieldIdx));\n      } else if (pdt instanceof PhysicalIntegerType) {\n        col.setInt(row.getInt(fieldIdx));\n      } else if (pdt instanceof PhysicalLongType) {\n        col.setLong(row.getLong(fieldIdx));\n      } else if (pdt instanceof PhysicalFloatType) {\n        col.setFloat(row.getFloat(fieldIdx));\n      } else if (pdt instanceof PhysicalDoubleType) {\n        col.setDouble(row.getDouble(fieldIdx));\n      } else if (pdt instanceof PhysicalStringType) {\n        UTF8String v = row.getUTF8String(fieldIdx);\n        col.setUtf8String(v);\n      } else if (pdt instanceof PhysicalDecimalType dt) {\n        Decimal d = row.getDecimal(fieldIdx, dt.precision(), dt.scale());\n        if (dt.precision() <= Decimal.MAX_INT_DIGITS()) {\n          col.setInt((int)d.toUnscaledLong());\n        } else if (dt.precision() <= Decimal.MAX_LONG_DIGITS()) {\n          col.setLong(d.toUnscaledLong());\n        } else {\n          final BigInteger integer = d.toJavaBigDecimal().unscaledValue();\n          byte[] bytes = integer.toByteArray();\n          col.setBinary(bytes);\n        }\n      } else if (pdt instanceof PhysicalCalendarIntervalType) {\n        // The value of `numRows` is irrelevant.\n        col.setCalendarInterval((CalendarInterval) row.get(fieldIdx, t));\n      } else if (pdt instanceof PhysicalVariantType) {\n        col.setVariant((VariantVal)row.get(fieldIdx, t));\n      } else {\n        throw new RuntimeException(String.format(\"DataType %s is not supported\" +\n            \" in column vectorized reader.\", t.sql()));\n      }\n    }\n  }",
    "comment": "Populates the value of `row[fieldIdx]` into `ConstantColumnVector`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/FieldArgumentsProvider.java",
    "type": "method",
    "name": "findField",
    "code": "FieldSource fieldSource) {\n\t\tClass<?> testClass = context.getRequiredTestClass();\n\t\tObject testInstance = context.getTestInstance().orElse(null);\n\t\tString[] fieldNames = fieldSource.value();\n\t\tif (fieldNames.length == 0) {\n\t\t\tOptional<Method> testMethod = context.getTestMethod();\n\t\t\tPreconditions.condition(testMethod.isPresent(),\n\t\t\t\t\"You must specify a field name when using @FieldSource with @ParameterizedClass\");\n\t\t\tfieldNames = new String[] { testMethod.get().getName() };\n\t\t// @formatter:off\n\t\treturn stream(fieldNames)\n\t\t\t\t.map(fieldName -> findField(testClass, fieldName))\n\t\t\t\t.map(field -> validateField(field, testInstance))\n\t\t\t\t.map(field -> readField(field, testInstance))\n\t\t\t\t.flatMap(fieldValue -> {\n\t\t\t\t\tif (fieldValue instanceof Supplier<?>) {\n\t\t\t\t\t\tfieldValue = ((Supplier<?>) fieldValue).get();\n\t\t\t\t\t}\n\t\t\t\t\treturn CollectionUtils.toStream(fieldValue);\n\t\t\t\t})\n\t\t\t\t.map(ArgumentsUtils::toArguments);\n\t\t// @formatter:on\n\t}\n\n\t// package-private for testing\n\tstatic Field findField(Class<?> testClass, String fieldName) {\n\t\tPreconditions.notBlank(fieldName, \"Field name must not be blank\");\n\t\tfieldName = fieldName.trim();\n\n\t\tClass<?> clazz = testClass;\n\t\tif (fieldName.contains(\"#\") || fieldName.contains(\".\")) {\n\t\t\tString[] fieldParts = ReflectionUtils.parseFullyQualifiedFieldName(fieldName);\n\t\t\tString className = fieldParts[0];\n\t\t\tfieldName = fieldParts[1];\n\t\t\tClassLoader classLoader = ClassLoaderUtils.getClassLoader(testClass);\n\t\t\tclazz = ReflectionUtils.loadRequiredClass(className, classLoader);\n\t\t}\n\n\t\tClass<?> resolvedClass = clazz;\n\t\tString resolvedFieldName = fieldName;\n\t\tPredicate<Field> nameMatches = field -> field.getName().equals(resolvedFieldName);\n\t\tField field = ReflectionUtils.streamFields(resolvedClass, nameMatches, HierarchyTraversalMode.BOTTOM_UP)//\n\t\t\t\t.findFirst()//\n\t\t\t\t.orElse(null);\n\n\t\tPreconditions.notNull(field,\n\t\t\t() -> format(\"Could not find field named [%s] in class [%s]\", resolvedFieldName, resolvedClass.getName()));\n\t\treturn field;\n\t}\n\n\tprivate static Field validateField(Field field, Object testInstance) {\n\t\tPreconditions.condition(field.getDeclaringClass().isInstance(testInstance) || ModifierSupport.isStatic(field),\n\t\t\t() -> format(\"Field '%s' must be static: local @FieldSource fields must be static \"\n\t\t\t\t\t+ \"unless the PER_CLASS @TestInstance lifecycle mode is used; \"\n\t\t\t\t\t+ \"external @FieldSource fields must always be static.\",\n\t\t\t\tfield.toGenericString()));\n\t\treturn field;\n\t}\n\n\tprivate static Object readField(Field field, Object testInstance) {\n\t\tObject value = ReflectionSupport.tryToReadFieldValue(field, testInstance).getOrThrow(\n\t\t\tcause -> new JUnitException(format(\"Could not read field [%s]\", field.getName()), cause));\n\n\t\tString fieldName = field.getName();\n\t\tString declaringClass = field.getDeclaringClass().getName();\n\n\t\tPreconditions.notNull(value,\n\t\t\t() -> format(\"The value of field [%s] in class [%s] must not be null\", fieldName, declaringClass));\n\n\t\tPreconditions.condition(!(value instanceof BaseStream),\n\t\t\t() -> format(\"The value of field [%s] in class [%s] must not be a stream\", fieldName, declaringClass));\n\n\t\tPreconditions.condition(!(value instanceof Iterator),\n\t\t\t() -> format(\"The value of field [%s] in class [%s] must not be an Iterator\", fieldName, declaringClass));\n\n\t\tPreconditions.condition(isConvertibleToStream(field, value),\n\t\t\t() -> format(\"The value of field [%s] in class [%s] must be convertible to a Stream\", fieldName,\n\t\t\t\tdeclaringClass));\n\n\t\treturn value;\n\t}\n\n\tprivate static boolean isConvertibleToStream(Field field, Object value) {\n\t\t// Check actual value type.\n\t\tif (CollectionUtils.isConvertibleToStream(value.getClass())) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check declared type T of Supplier<T>.\n\t\tif (Supplier.class.isAssignableFrom(field.getType())) {\n\t\t\tType genericType = field.getGenericType();\n\t\t\tif (genericType instanceof ParameterizedType) {\n\t\t\t\tParameterizedType parameterizedType = (ParameterizedType) genericType;\n\t\t\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\t\t\tif (typeArguments.length == 1) {\n\t\t\t\t\tType type = typeArguments[0];\n\t\t\t\t\t// Handle cases such as Supplier<IntStream>\n\t\t\t\t\tif (type instanceof Class) {\n\t\t\t\t\t\tClass<?> clazz = (Class<?>) type;\n\t\t\t\t\t\treturn CollectionUtils.isConvertibleToStream(clazz);\n\t\t\t\t\t}\n\t\t\t\t\t// Handle cases such as Supplier<Stream<String>>\n\t\t\t\t\tif (type instanceof ParameterizedType) {\n\t\t\t\t\t\tType rawType = ((ParameterizedType) type).getRawType();\n\t\t\t\t\t\tif (rawType instanceof Class<?>) {\n\t\t\t\t\t\t\tClass<?> clazz = (Class<?>) rawType;\n\t\t\t\t\t\t\treturn CollectionUtils.isConvertibleToStream(clazz);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}",
    "comment": "Determine if the supplied value can be converted into a {@code Stream} or\nif the declared type of the supplied field is a {@link Supplier} of a type\nthat can be converted into a {@code Stream}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarBatch.java",
    "type": "method",
    "name": "rowIterator",
    "code": "public Iterator<InternalRow> rowIterator() {\n    final int maxRows = numRows;\n    final ColumnarBatchRow row = new ColumnarBatchRow(columns);\n    return new Iterator<InternalRow>() {\n\n      @Override\n      public InternalRow next() {\n        if (rowId >= maxRows) {\n          throw new NoSuchElementException();\n        }\n        row.rowId = rowId++;\n        return row;\n      }\n    };\n  }",
    "comment": "Returns an iterator over the rows in this batch."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/bytecode/src/main/java/com/iluwatar/bytecode/util/InstructionConverterUtil.java",
    "type": "method",
    "name": "convertToByteCode",
    "code": "public static int[] convertToByteCode(String instructions) {\n    if (instructions == null || instructions.trim().length() == 0) {\n      return new int[0];\n    }\n\n    var splitedInstructions = instructions.trim().split(\" \");\n    var bytecode = new int[splitedInstructions.length];\n    for (var i = 0; i < splitedInstructions.length; i++) {\n      if (isValidInstruction(splitedInstructions[i])) {\n        bytecode[i] = Instruction.valueOf(splitedInstructions[i]).getIntValue();\n      } else if (isValidInt(splitedInstructions[i])) {\n        bytecode[i] = Integer.parseInt(splitedInstructions[i]);\n      } else {\n        var errorMessage = \"Invalid instruction or number: \" + splitedInstructions[i];\n        throw new IllegalArgumentException(errorMessage);\n      }\n    }\n\n    return bytecode;\n  }",
    "comment": "Converts instructions represented as String.\n\n@param instructions to convert\n@return array of int representing bytecode"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/PluginsMetadataGenerator.java",
    "type": "method",
    "name": "extractPluginInfo",
    "code": "private PluginInfo extractPluginInfo(Artifact artifact) {\n        if (artifact != null\n                && \"jar\".equals(artifact.getExtension())\n                && \"\".equals(artifact.getClassifier())\n                && artifact.getPath() != null) {\n            Path artifactPath = artifact.getPath();\n            if (Files.isRegularFile(artifactPath)) {\n                try (JarFile artifactJar = new JarFile(artifactPath.toFile(), false)) {\n                                logger.warn(\n                                        \"Artifact {}:{}\"\n                                                + \" JAR (about to be installed/deployed) contains Maven Plugin metadata for\"\n                                                + \" conflicting coordinates: {}:{}.\"\n                                                + \" Your JAR contains rogue Maven Plugin metadata.\"\n                                                + \" Possible causes may be: shaded into this JAR some Maven Plugin or some rogue resource.\",\n                                        artifact.getGroupId(),\n                                        artifact.getArtifactId(),\n                                        groupId,\n                                        artifactId);\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                }",
    "comment": "sanity: jar, no classifier and file exists\nhere we can have: IO. ZIP or Plexus Conf Ex: but we should not interfere with user intent"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolver.java",
    "type": "method",
    "name": "build",
    "code": "public EngineDiscoveryRequestResolver<T> build() {\n\t\t\treturn new EngineDiscoveryRequestResolver<>(resolverCreators, visitorCreators);\n\t\t}",
    "comment": "Build the {@link EngineDiscoveryRequestResolver} that has been\nconfigured via this builder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/SuiteTest.java",
    "type": "method",
    "name": "suite",
    "code": "public static Test suite() {\n        TestSuite suite = new TestSuite(\"Suite Tests\");\n        suite.addTest(new SuiteTest(\"testNoTestCases\"));\n        suite.addTest(new SuiteTest(\"testOneTestCase\"));\n        suite.addTest(new SuiteTest(\"testNotPublicTestCase\"));\n        suite.addTest(new SuiteTest(\"testNotVoidTestCase\"));\n        suite.addTest(new SuiteTest(\"testNotExistingTestCase\"));\n        suite.addTest(new SuiteTest(\"testInheritedTests\"));\n        suite.addTest(new SuiteTest(\"testOneTestCaseEclipseSeesSameStructureAs381\"));\n        suite.addTest(new SuiteTest(\"testNoTestCaseClass\"));\n        suite.addTest(new SuiteTest(\"testShadowedTests\"));\n        suite.addTest(new SuiteTest(\"testAddTestSuite\"));\n        suite.addTest(new SuiteTest(\"testCreateSuiteFromArray\"));\n\n        return suite;\n    }",
    "comment": "build the suite manually, because some of the suites are testing\nthe functionality that automatically builds suites"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/AutoCloseTests.java",
    "type": "method",
    "name": "allFieldsAreClosedIfAnyFieldThrowsAnExceptionWithNestedTestClassesWithInstancePerMethod",
    "code": "void allFieldsAreClosedIfAnyFieldThrowsAnExceptionWithNestedTestClassesWithInstancePerMethod() {\n\t\tClass<?> enclosingTestClass = FailingFieldsEnclosingTestCase.class;\n\t\tClass<?> nestedTestClass = FailingFieldsEnclosingTestCase.NestedTestCase.class;\n\n\t\tEngineExecutionResults allEvents = executeTestsForClass(nestedTestClass);\n\t\tEvents tests = allEvents.testEvents();\n\t\ttests.assertStatistics(stats -> stats.succeeded(0).failed(1));\n\n\t\tassertThat(recorder).containsExactly(//\n\t\t\t\"NestedTestCase.nestedField1.close()\", //\n\t\t\t\"NestedTestCase.nestedField2.close()\", //\n\t\t\t\"FailingFieldsEnclosingTestCase.enclosingField1.close()\", //\n\t\t\t\"FailingFieldsEnclosingTestCase.enclosingField2.close()\", //\n\t\t\t\"NestedTestCase.nestedStaticField1.close()\", //\n\t\t\t\"NestedTestCase.nestedStaticField2.close()\", //\n\t\t\t\"FailingFieldsEnclosingTestCase.enclosingStaticField1.close()\", //\n\t\t\t\"FailingFieldsEnclosingTestCase.enclosingStaticField2.close()\"//\n\t\t);\n\n\t\tassertThat(findFailure(tests, \"nestedTest()\"))//\n\t\t\t\t.isExactlyInstanceOf(RuntimeException.class)//\n\t\t\t\t.hasMessage(\"NestedTestCase.nestedField1.close()\")//\n\t\t\t\t.hasNoCause()//\n\t\t\t\t.hasSuppressedException(new RuntimeException(\"FailingFieldsEnclosingTestCase.enclosingField1.close()\"));\n\n\t\tEvents containers = allEvents.containerEvents();\n\t\tcontainers.assertStatistics(stats -> stats.succeeded(1).failed(2));\n\n\t\tassertThat(findFailure(containers, nestedTestClass.getSimpleName()))//\n\t\t\t\t.isExactlyInstanceOf(RuntimeException.class)//\n\t\t\t\t.hasMessage(\"NestedTestCase.nestedStaticField1.close()\")//\n\t\t\t\t.hasNoCause()//\n\t\t\t\t.hasNoSuppressedExceptions();\n\t\tassertThat(findFailure(containers, enclosingTestClass.getSimpleName()))//\n\t\t\t\t.isExactlyInstanceOf(RuntimeException.class)//\n\t\t\t\t.hasMessage(\"FailingFieldsEnclosingTestCase.enclosingStaticField1.close()\")//\n\t\t\t\t.hasNoCause()//\n\t\t\t\t.hasNoSuppressedExceptions();\n\n\t\tresetTracking();\n\n\t\tallEvents = executeTestsForClass(enclosingTestClass);\n\t\ttests = allEvents.testEvents();\n\t\ttests.assertStatistics(stats -> stats.succeeded(0).failed(2));\n\n\t\tassertThat(recorder).containsExactly(//\n\t\t\t\"FailingFieldsEnclosingTestCase.enclosingField1.close()\", //\n\t\t\t\"FailingFieldsEnclosingTestCase.enclosingField2.close()\", //\n\n\t\t\t\"NestedTestCase.nestedField1.close()\", //\n\t\t\t\"NestedTestCase.nestedField2.close()\", //\n\t\t\t\"FailingFieldsEnclosingTestCase.enclosingField1.close()\", //\n\t\t\t\"FailingFieldsEnclosingTestCase.enclosingField2.close()\", //\n\t\t\t\"NestedTestCase.nestedStaticField1.close()\", //\n\t\t\t\"NestedTestCase.nestedStaticField2.close()\", //\n\t\t\t\"FailingFieldsEnclosingTestCase.enclosingStaticField1.close()\", //\n\t\t\t\"FailingFieldsEnclosingTestCase.enclosingStaticField2.close()\"//\n\t\t);\n\n\t\tassertThat(findFailure(tests, \"enclosingTest()\"))//\n\t\t\t\t.isExactlyInstanceOf(RuntimeException.class)//\n\t\t\t\t.hasMessage(\"FailingFieldsEnclosingTestCase.enclosingField1.close()\")//\n\t\t\t\t.hasNoCause()//\n\t\t\t\t.hasNoSuppressedExceptions();\n\t\tassertThat(findFailure(tests, \"nestedTest()\"))//\n\t\t\t\t.isExactlyInstanceOf(RuntimeException.class)//\n\t\t\t\t.hasMessage(\"NestedTestCase.nestedField1.close()\")//\n\t\t\t\t.hasNoCause()//\n\t\t\t\t.hasSuppressedException(new RuntimeException(\"FailingFieldsEnclosingTestCase.enclosingField1.close()\"));\n\n\t\tcontainers = allEvents.containerEvents();\n\t\tcontainers.assertStatistics(stats -> stats.succeeded(1).failed(2));\n\n\t\tassertThat(findFailure(containers, nestedTestClass.getSimpleName()))//\n\t\t\t\t.isExactlyInstanceOf(RuntimeException.class)//\n\t\t\t\t.hasMessage(\"NestedTestCase.nestedStaticField1.close()\")//\n\t\t\t\t.hasNoCause()//\n\t\t\t\t.hasNoSuppressedExceptions();\n\t\tassertThat(findFailure(containers, enclosingTestClass.getSimpleName()))//\n\t\t\t\t.isExactlyInstanceOf(RuntimeException.class)//\n\t\t\t\t.hasMessage(\"FailingFieldsEnclosingTestCase.enclosingStaticField1.close()\")//\n\t\t\t\t.hasNoCause()//\n\t\t\t\t.hasNoSuppressedExceptions();\n\t}",
    "comment": "Verify that ALL fields were closed in the proper order.\nResults from NestedTestCase instance\nResults from FailingFieldsEnclosingTestCase instance\nResults from NestedTestCase class\nResults from FailingFieldsEnclosingTestCase class\nTest-level failures\nContainer-level failures\nReset tracking\nVerify that ALL fields were closed in the proper order.\nResults from FailingFieldsEnclosingTestCase instance\nResults from NestedTestCase instance\nResults from FailingFieldsEnclosingTestCase instance\nResults from NestedTestCase class\nResults from FailingFieldsEnclosingTestCase class\nTest-level failures\nContainer-level failures"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<String> create(byte[][][][][] data) {\n    return Tensor.create(data, String.class);\n  }",
    "comment": "Creates a rank-4 tensor of {@code byte} elements.\n\n@param data An array containing the data to put into the new tensor. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assumptions.java",
    "type": "method",
    "name": "assumingThat",
    "code": "public static void assumingThat(boolean assumption, Executable executable) {\n\t\tif (assumption) {\n\t\t\ttry {\n\t\t\t\texecutable.execute();\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tthrow ExceptionUtils.throwAsUncheckedException(t);\n\t\t\t}\n\t\t}\n\t}",
    "comment": "Execute the supplied {@link Executable}, but only if the supplied\nassumption is valid.\n\n<p>Unlike the other assumption methods, this method will not abort the test.\nIf the assumption is invalid, this method does nothing. If the assumption is\nvalid and the {@code executable} throws an exception, it will be treated like\na regular test <em>failure</em>. That exception will be rethrown <em>as is</em>\nbut {@link ExceptionUtils#throwAsUncheckedException masked} as an unchecked\nexception.\n\n@param assumption the assumption to validate\n@param executable the block of code to execute if the assumption is valid\n@see #assumingThat(BooleanSupplier, Executable)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/exception/ExceptionAssertionExactDemo.java",
    "type": "method",
    "name": "testExpectedExceptionIsThrown",
    "code": "void testExpectedExceptionIsThrown() {\n\t\tIllegalArgumentException exception =\n\t\t\tassertThrowsExactly(IllegalArgumentException.class, () -> {\n\t\t\t\tthrow new IllegalArgumentException(\"expected message\");\n\t\t\t});\n\t\tassertEquals(\"expected message\", exception.getMessage());\n\n\t\tassertThrowsExactly(RuntimeException.class, () -> {\n\t\t\tthrow new IllegalArgumentException(\"expected message\");\n\t\t});\n\t}",
    "comment": "@formatter:off\ntag::user_guide[]\nThe following assertion succeeds because the code under assertion throws\nIllegalArgumentException which is exactly equal to the expected type.\nThe assertion also returns the thrown exception which can be used for\nfurther assertions like asserting the exception message.\nThe following assertion fails because the assertion expects exactly\nRuntimeException to be thrown, not subclasses of RuntimeException."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/ClassMap.java",
    "type": "method",
    "name": "makeMethodKey",
    "code": "private String makeMethodKey(Method method) {\n        Class<?>[] parameterTypes = method.getParameterTypes();\n\n        StringBuilder methodKey = new StringBuilder(method.getName());\n\n        for (Class<?> parameterType : parameterTypes) {\n            // If the argument type is primitive then we want\n            // to convert our primitive type signature to the\n            // corresponding Object type so introspection for\n            // methods with primitive types will work correctly.\n            if (parameterType.isPrimitive()) {\n                if (parameterType.equals(Boolean.TYPE)) {\n                    methodKey.append(\"java.lang.Boolean\");\n                } else if (parameterType.equals(Byte.TYPE)) {\n                    methodKey.append(\"java.lang.Byte\");\n                } else if (parameterType.equals(Character.TYPE)) {\n                    methodKey.append(\"java.lang.Character\");\n                } else if (parameterType.equals(Double.TYPE)) {\n                    methodKey.append(\"java.lang.Double\");\n                } else if (parameterType.equals(Float.TYPE)) {\n                    methodKey.append(\"java.lang.Float\");\n                } else if (parameterType.equals(Integer.TYPE)) {\n                    methodKey.append(\"java.lang.Integer\");\n                } else if (parameterType.equals(Long.TYPE)) {\n                    methodKey.append(\"java.lang.Long\");\n                } else if (parameterType.equals(Short.TYPE)) {\n                    methodKey.append(\"java.lang.Short\");\n                }\n            } else {\n                methodKey.append(parameterType.getName());\n            }\n        }\n\n        return methodKey.toString();\n    }",
    "comment": "Make a methodKey for the given method using\nthe concatenation of the name and the\ntypes of the method parameters."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertNullAssertionsTests.java",
    "type": "method",
    "name": "assertNullWithNull",
    "code": "void assertNullWithNull() {\n\t\tassertNull(null);\n\t\tassertNull(null, \"message\");\n\t\tassertNull(null, () -> \"message\");\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/NameScope.java",
    "type": "method",
    "name": "withSubScope",
    "code": "NameScope withSubScope(String scopeName) {\n    checkPattern(NAME_REGEX, scopeName);\n    // Override with opName if it exists.\n    String actualName = (opName != null) ? opName : scopeName;\n    String newPrefix = fullyQualify(makeUnique(actualName));\n    return new NameScope(newPrefix, null, null);\n  }",
    "comment": "A class to manage scoped (hierarchical) names for operators.\n\n<p>{@code NameScope} manages hierarchical names where each component in the hierarchy is\nseparated by a forward slash {@code '/'}. For instance, {@code nn/Const_72} or {@code\nnn/gradient/assign/init}. Each scope is a subtree in this hierarchy.\n\n<p>Use {@code NameScope} to group related operations within a hierarchy, which for example lets\ntensorboard coalesce nodes for better graph visualizations.\n\n<p>This class is package private, user code creates {@link Scope} which internally delegates\ncalls to an underlying {@code NameScope}.\n\n<p>This class is <b>not</b> thread-safe."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/condition/DisabledIfSystemPropertyCondition.java",
    "type": "method",
    "name": "evaluate",
    "code": "protected ConditionEvaluationResult evaluate(DisabledIfSystemProperty annotation) {\n\t\tString name = annotation.named().trim();\n\t\tString regex = annotation.matches();\n\t\tPreconditions.notBlank(name, () -> \"The 'named' attribute must not be blank in \" + annotation);\n\t\tPreconditions.notBlank(regex, () -> \"The 'matches' attribute must not be blank in \" + annotation);\n\t\tString actual = System.getProperty(name);\n\n\t\tif (actual == null) {\n\t\t\treturn enabled(format(\"System property [%s] does not exist\", name));\n\t\t}\n\n\t\tif (actual.matches(regex)) {\n\t\t\treturn disabled(\n\t\t\t\tformat(\"System property [%s] with value [%s] matches regular expression [%s]\", name, actual, regex),\n\t\t\t\tannotation.disabledReason());\n\t\t}\n\t\treturn enabled(\n\t\t\tformat(\"System property [%s] with value [%s] does not match regular expression [%s]\", name, actual, regex));\n\t}",
    "comment": "Nothing to match against?\nelse"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeArrayWriter.java",
    "type": "method",
    "name": "write",
    "code": "public void write(int ordinal, CalendarInterval input) {\n    assertIndexIsValid(ordinal);\n    if (input == null) {\n      setNull(ordinal);\n    } else {\n      super.write(ordinal, input);\n    }\n  }",
    "comment": "the UnsafeWriter version of write(int, CalendarInterval) doesn't handle\nnull intervals appropriately when the container is an array, so we handle\nthat case here."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "render",
    "code": "public Ansi render(final String text, Object... args) {\n        a(String.format(new org.jline.jansi.Ansi().render(text).toString(), args));\n        return this;\n    }",
    "comment": "String formats and renders the supplied arguments.  Uses the {@link org.jline.jansi.AnsiRenderer}\nto generate the ANSI escape sequences.\n\n@param text format\n@param args arguments\n@return this\n@since 2.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-builder-support/src/main/java/org/apache/maven/building/ProblemCollectorFactory.java",
    "type": "method",
    "name": "newInstance",
    "code": "public static ProblemCollector newInstance(List<Problem> problems) {\n        return new DefaultProblemCollector(problems);\n    }",
    "comment": "The default implementation is not visible, create it with this factory\n\n@param problems starting set of problems, may be {@code null}\n@return a new instance of a ProblemCollector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java",
    "type": "method",
    "name": "status",
    "code": "public static Condition<TestExecutionResult> status(Status expectedStatus) {\n\t\treturn new Condition<>(where(TestExecutionResult::getStatus, isEqual(expectedStatus)), \"status is %s\",\n\t\t\texpectedStatus);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if a\nstatus} is equal to the supplied {@link Status Status}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/BenchmarkLatencyImpl.java",
    "type": "method",
    "name": "BenchmarkLatencyImpl",
    "code": "public BenchmarkLatencyImpl(Context context, String[] tfliteSettingsJsonFiles, String[] args) {\n    this.context = context;\n    this.tfliteSettingsJsonFiles = tfliteSettingsJsonFiles;\n    if (args == null) {\n      // The \"--args\" extra key was not provided.\n      this.args = new String[0];\n    } else {\n      this.args = args;\n    }\n    this.report = BenchmarkReport.create();\n  }",
    "comment": "Impl class for Delegate Performance Latency Benchmark.\n\n<p>It performs latency benchmark tests via TFLite Benchmark Tool based on the input arguments.\nPlease check the test example in\ntensorflow/lite/tools/benchmark/experimental/delegate_performance/android/README.md.\n\n<p>Generates below list of files under delegate_performance_result/latency folder to describe the\nbenchmark results.\n\n<ul>\n<li>1. delegate_performance_result/latency/report.csv: the performance of each acceleration\nconfiguration and relative performance differences as percentages in CSV.\n<li>2. delegate_performance_result/latency/report.json: detailed performance results. The file\ncontains the metric-level, delegate-level and model-level results, the latency criteria and\nthe raw metric outputs from the native layer in JSON.\n<li>3. delegate_performance_result/latency/report.html: the performance of each acceleration\nconfiguration and relative performance differences as percentages in HTML.\n</ul>\n\nThe metrics for generating the Pass/Pass with Warning/Fail decision:\n\n<ul>\n<li>1. startup overhead latency: it is equal to (initialization time + average warmup latency -\naverage inference time).\n<li>2. average inference latency: average time for the inferences in the benchmark run.\n</ul>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultInterpolator.java",
    "type": "method",
    "name": "if",
    "code": "boolean defaultsToEmptyString) {\n        if (val == null || val.isEmpty()) {\n            return val;\n        }\n        if (cycleMap == null) {\n            cycleMap = new HashSet<>();\n        }\n\n        if (currentKey != null) {\n            cycleMap.add(currentKey);\n        }\n\n\n        int startDelim;\n        int stopDelim = -1;\n        do {\n            stopDelim = val.indexOf(DELIM_STOP, stopDelim + 1);\n            while (stopDelim > 0 && val.charAt(stopDelim - 1) == ESCAPE_CHAR) {\n                stopDelim = val.indexOf(DELIM_STOP, stopDelim + 1);\n            }\n\n            startDelim = val.indexOf(DELIM_START);\n            while (stopDelim >= 0) {\n                int idx = val.indexOf(DELIM_START, startDelim + DELIM_START.length());\n                if ((idx < 0) || (idx > stopDelim)) {\n                    break;\n                } else if (idx < stopDelim) {\n                    startDelim = idx;\n                }\n            }\n        } while (startDelim >= 0 && stopDelim >= 0 && stopDelim < startDelim + DELIM_START.length());\n\n        if ((startDelim < 0) || (stopDelim < 0)) {\n            cycleMap.remove(currentKey);\n            return val;\n        }\n\n        String variable = val.substring(startDelim + DELIM_START.length(), stopDelim);\n        String org = variable;\n\n        String substValue = processSubstitution(\n                variable, org, cycleMap, configProps, callback, postprocessor, defaultsToEmptyString);\n\n        val = val.substring(0, startDelim) + substValue + val.substring(stopDelim + DELIM_STOP.length());\n\n        val = doSubstVars(val, currentKey, cycleMap, configProps, callback, postprocessor, defaultsToEmptyString);\n\n        cycleMap.remove(currentKey);\n\n        return val;\n    }",
    "comment": "Put the current key in the cycle map.\nAssume we have a value that is something like:\n\"leading ${foo.${bar}} middle ${baz} trailing\"\nFind the first ending '}' variable delimiter, which\nwill correspond to the first deepest nested variable\nplaceholder.\nFind the matching starting \"${\" variable delimiter\nby looping until we find a start delimiter that is\ngreater than the stop delimiter we have found.\nIf we do not have a start or stop delimiter, then just\nreturn the existing value.\nAt this point, we have found a variable placeholder so\nwe must perform a variable substitution on it.\nUsing the start and stop delimiter indices, extract\nthe first, deepest nested variable placeholder.\nAppend the leading characters, the substituted value of\nthe variable, and the trailing characters to get the new\nvalue.\nNow perform substitution again, since there could still\nbe substitutions to make.\nReturn the value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/RowBasedKeyValueBatch.java",
    "type": "method",
    "name": "getValueRow",
    "code": "public final UnsafeRow getValueRow(int rowId) {\n    return getValueFromKey(rowId);\n  }",
    "comment": "Returns the value row in this batch at `rowId`. Returned value row is reused across calls.\nBecause `getValueRow(id)` is always called after `getKeyRow(id)` with the same id, we use\n`getValueFromKey(id) to retrieve value row, which reuses metadata from the cached key."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/LevelDBTypeInfo.java",
    "type": "method",
    "name": "Index",
    "code": "private Index(KVIndex self, KVTypeInfo.Accessor accessor, Index parent) {\n      byte[] name = self.value().getBytes(UTF_8);\n      if (parent != null) {\n        byte[] child = new byte[name.length + 1];\n        child[0] = SECONDARY_IDX_PREFIX;\n        System.arraycopy(name, 0, child, 1, name.length);\n      }\n\n      this.name = name;\n      this.isNatural = self.value().equals(KVIndex.NATURAL_INDEX_NAME);\n      this.copy = isNatural || self.copy();\n      this.accessor = accessor;\n      this.parent = parent;\n    }",
    "comment": "Models a single index in LevelDB. See top-level class's javadoc for a description of how the\nkeys are generated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/CommandBuilderUtils.java",
    "type": "method",
    "name": "firstNonEmptyValue",
    "code": "static String firstNonEmptyValue(String key, Map<?, ?>... maps) {\n    for (Map<?, ?> map : maps) {\n      String value = (String) map.get(key);\n      if (!isEmpty(value)) {\n        return value;\n      }\n    }\n    return null;\n  }",
    "comment": "Returns the first non-empty value mapped to the given key in the given maps, or null otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3810BadProfileActivationTest.java",
    "type": "method",
    "name": "MavenITmng3810BadProfileActivationTest",
    "code": "public MavenITmng3810BadProfileActivationTest() {\n        super(\"(2.0.10,2.1.0-M1),(2.1.0-M1,3.0-alpha-1),[3.0-alpha-3,)\"); // 2.0.11+, 2.1.0-M2+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3810\">MNG-3810</a>.\n\n@author Brett Porter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/classification/JavaLogisticRegressionSuite.java",
    "type": "method",
    "name": "logisticRegressionWithSetters",
    "code": "public void logisticRegressionWithSetters() {\n    LogisticRegression lr = new LogisticRegression()\n      .setMaxIter(10)\n      .setRegParam(1.0)\n      .setThreshold(0.6)\n      .setProbabilityCol(\"myProbability\");\n    LogisticRegressionModel model = lr.fit(dataset);\n    LogisticRegression parent = (LogisticRegression) model.parent();\n    Assertions.assertEquals(10, parent.getMaxIter());\n    Assertions.assertEquals(1.0, parent.getRegParam(), eps);\n    Assertions.assertEquals(0.4, parent.getThresholds()[0], eps);\n    Assertions.assertEquals(0.6, parent.getThresholds()[1], eps);\n    Assertions.assertEquals(0.6, parent.getThreshold(), eps);\n    Assertions.assertEquals(0.6, model.getThreshold(), eps);\n\n    model.setThreshold(1.0);\n    model.transform(dataset).createOrReplaceTempView(\"predAllZero\");\n    Dataset<Row> predAllZero = spark.sql(\"SELECT prediction, myProbability FROM predAllZero\");\n    for (Row r : predAllZero.collectAsList()) {\n      Assertions.assertEquals(0.0, r.getDouble(0), eps);\n    }\n    model.transform(dataset, model.threshold().w(0.0), model.probabilityCol().w(\"myProb\"))\n      .createOrReplaceTempView(\"predNotAllZero\");\n    Dataset<Row> predNotAllZero = spark.sql(\"SELECT prediction, myProb FROM predNotAllZero\");\n    boolean foundNonZero = false;\n    for (Row r : predNotAllZero.collectAsList()) {\n      if (r.getDouble(0) != 0.0) foundNonZero = true;\n    }\n    Assertions.assertTrue(foundNonZero);\n\n    LogisticRegressionModel model2 = lr.fit(dataset, lr.maxIter().w(5), lr.regParam().w(0.1),\n      lr.threshold().w(0.4), lr.probabilityCol().w(\"theProb\"));\n    LogisticRegression parent2 = (LogisticRegression) model2.parent();\n    Assertions.assertEquals(5, parent2.getMaxIter());\n    Assertions.assertEquals(0.1, parent2.getRegParam(), eps);\n    Assertions.assertEquals(0.4, parent2.getThreshold(), eps);\n    Assertions.assertEquals(0.4, model2.getThreshold(), eps);\n    Assertions.assertEquals(\"theProb\", model2.getProbabilityCol());\n  }",
    "comment": "Set params, train, and check as many params as we can.\nModify model params, and check that the params worked.\nCall transform with params, and check that the params worked.\nCall fit() with new params, and check as many params as we can."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-queue/src/main/java/com/iluwatar/event/queue/Audio.java",
    "type": "method",
    "name": "playSound",
    "code": "public void playSound(AudioInputStream stream, float volume) {\n    init();\n    // Walk the pending requests.\n    for (var i = headIndex; i != tailIndex; i = (i + 1) % MAX_PENDING) {\n      var playMessage = getPendingAudio()[i];\n      if (playMessage.getStream() == stream) {\n        // Use the larger of the two volumes.\n        playMessage.setVolume(Math.max(volume, playMessage.getVolume()));\n\n        // Don't need to enqueue.\n        return;\n      }\n    }\n    getPendingAudio()[tailIndex] = new PlayMessage(stream, volume);\n    tailIndex = (tailIndex + 1) % MAX_PENDING;\n  }",
    "comment": "This method adds a new audio into the queue.\n\n@param stream is the AudioInputStream for the method\n@param volume is the level of the audio's volume"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "streamAllResourcesInClasspathRoot",
    "code": "public static Stream<Resource> streamAllResourcesInClasspathRoot(URI root, Predicate<Resource> resourceFilter) {\n\t\treturn ReflectionUtils.streamAllResourcesInClasspathRoot(root, resourceFilter);\n\t}",
    "comment": "Find all {@linkplain Resource resources} in the supplied classpath {@code root}\nthat match the specified {@code resourceFilter} predicate.\n\n<p>The classpath scanning algorithm searches recursively in subpackages\nbeginning with the root of the classpath.\n\n@param root the URI for the classpath root in which to scan; never\n{@code null}\n@param resourceFilter the resource type filter; never {@code null}\n@return a stream of all such classes found; never {@code null}\nbut potentially empty\n@since 1.11\n@see #streamAllResourcesInPackage(String, Predicate)\n@see #streamAllResourcesInModule(String, Predicate)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "toTitleCase",
    "code": "public static UTF8String toTitleCase(final UTF8String target) {\n    // Note: In order to achieve the desired behavior, we use the ICU UCharacter class to\n    // convert the string to titlecase, which only accepts a Java strings as input.\n    return UTF8String.fromString(UCharacter.toTitleCase(target.toValidString(),\n      BreakIterator.getWordInstance()));\n  }",
    "comment": "Convert the input string to titlecase using the ICU root locale rules."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(long unexpected, Long actual, String message) {\n\t\tAssertNotEquals.assertNotEquals((Long) unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterExpressionEvaluator.java",
    "type": "method",
    "name": "alignToBaseDirectory",
    "code": "public File alignToBaseDirectory(File file) {\n        if (file != null) {\n            if (file.isAbsolute()) {\n            } else if (file.getPath().startsWith(File.separator)) {\n                file = file.getAbsoluteFile();\n            } else {\n                file = new File(new File(basedir, file.getPath()).toURI().normalize()).getAbsoluteFile();\n            }\n        }\n        return file;\n    }",
    "comment": "TODO Copied from the DefaultInterpolator. We likely want to resurrect the PathTranslator or at least a\nsimilar component for re-usage\npath was already absolute, just normalize file separator and we're done\ndrive-relative Windows path, don't align with project directory but with drive root\nan ordinary relative path, align with project directory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "update",
    "code": "public boolean update(MavenProperties properties) {\n        boolean modified = false;\n        for (String key : new ArrayList<String>(this.keySet())) {\n        }\n        for (String key : properties.keySet()) {\n            String v = this.get(key);\n            List<String> comments = properties.getComments(key);\n            List<String> value = properties.getRaw(key);\n            if (v == null) {\n                this.put(key, comments, value);\n                modified = true;\n            } else if (!v.equals(properties.get(key))) {\n                if (comments.isEmpty()) {\n                    comments = this.getComments(key);\n                }\n                this.put(key, comments, value);\n                modified = true;\n            }\n        }\n        return modified;\n    }",
    "comment": "Remove \"removed\" properties from the cfg file\nUpdate existing keys"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/NativeLibrary.java",
    "type": "method",
    "name": "createTemporaryDirectory",
    "code": "private static File createTemporaryDirectory() {\n    File baseDirectory = new File(System.getProperty(\"java.io.tmpdir\"));\n    String directoryName = \"tensorflow_native_libraries-\" + System.currentTimeMillis() + \"-\";\n    for (int attempt = 0; attempt < 1000; attempt++) {\n      File temporaryDirectory = new File(baseDirectory, directoryName + attempt);\n      if (temporaryDirectory.mkdir()) {\n        return temporaryDirectory;\n      }\n    }\n    throw new IllegalStateException(\n        \"Could not create a temporary directory (tried to make \"\n            + directoryName\n            + \"*) to extract TensorFlow native libraries.\");\n  }",
    "comment": "Shamelessly adapted from Guava to avoid using java.nio, for Android API\ncompatibility."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/thrift/ThriftHttpCLIService.java",
    "type": "method",
    "name": "initializeServer",
    "code": "protected void initializeServer() {\n    try {\n      String threadPoolName = \"HiveServer2-HttpHandler-Pool\";\n      ThreadPoolExecutor executorService = new ThreadPoolExecutor(minWorkerThreads, maxWorkerThreads,\n          workerKeepAliveTime, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),\n          new ThreadFactoryWithGarbageCleanup(threadPoolName));\n      ExecutorThreadPool threadPool = new ExecutorThreadPool(executorService);\n\n      httpServer = new org.eclipse.jetty.server.Server(threadPool);\n\n\n      ConnectionFactory[] connectionFactories;\n      boolean useSsl = hiveConf.getBoolVar(ConfVars.HIVE_SERVER2_USE_SSL);\n      String schemeName = useSsl ? \"https\" : \"http\";\n      if (useSsl) {\n        String keyStorePath = hiveConf.getVar(ConfVars.HIVE_SERVER2_SSL_KEYSTORE_PATH).trim();\n        String keyStorePassword = ShimLoader.getHadoopShims().getPassword(hiveConf,\n            HiveConf.ConfVars.HIVE_SERVER2_SSL_KEYSTORE_PASSWORD.varname);\n        if (keyStorePath.isEmpty()) {\n          throw new IllegalArgumentException(ConfVars.HIVE_SERVER2_SSL_KEYSTORE_PATH.varname\n              + \" Not configured for SSL connection\");\n        }\n        SslContextFactory.Server sslContextFactoryServer = new SslContextFactory.Server();\n        String[] excludedProtocols = hiveConf.getVar(ConfVars.HIVE_SSL_PROTOCOL_BLACKLIST).split(\",\");\n        LOG.info(\"HTTP Server SSL: adding excluded protocols: \" + Arrays.toString(excludedProtocols));\n        sslContextFactoryServer.addExcludeProtocols(excludedProtocols);\n        LOG.info(\"HTTP Server SSL: SslContextFactory.getExcludeProtocols = \" +\n          Arrays.toString(sslContextFactoryServer.getExcludeProtocols()));\n        sslContextFactoryServer.setKeyStorePath(keyStorePath);\n        sslContextFactoryServer.setKeyStorePassword(keyStorePassword);\n        connectionFactories = AbstractConnectionFactory.getFactories(\n            sslContextFactoryServer, new HttpConnectionFactory());\n      } else {\n        connectionFactories = new ConnectionFactory[] { new HttpConnectionFactory() };\n      ServerConnector connector = new ServerConnector(\n          httpServer,\n          null,\n          new ScheduledExecutorScheduler(\"HiveServer2-HttpHandler-JettyScheduler\", true),\n          null,\n          -1,\n          -1,\n          connectionFactories);\n\n      connector.setPort(portNum);\n      connector.setReuseAddress(!Shell.WINDOWS);\n      int maxIdleTime = (int) hiveConf.getTimeVar(ConfVars.HIVE_SERVER2_THRIFT_HTTP_MAX_IDLE_TIME,\n          TimeUnit.MILLISECONDS);\n      connector.setIdleTimeout(maxIdleTime);\n\n      httpServer.addConnector(connector);\n\n      hiveAuthFactory = new HiveAuthFactory(hiveConf);\n      TProcessor processor = new TCLIService.Processor<Iface>(this);\n      TProtocolFactory protocolFactory = new TBinaryProtocol.Factory();\n      UserGroupInformation serviceUGI = cliService.getServiceUGI();\n      UserGroupInformation httpUGI = cliService.getHttpUGI();\n      String authType = hiveConf.getVar(ConfVars.HIVE_SERVER2_AUTHENTICATION);\n      TServlet thriftHttpServlet = new ThriftHttpServlet(processor, protocolFactory, authType,\n          serviceUGI, httpUGI, hiveAuthFactory);\n\n      final ServletContextHandler context = new ServletContextHandler(\n          ServletContextHandler.SESSIONS);\n      context.setContextPath(\"/\");\n      String httpPath = getHttpPath(hiveConf\n          .getVar(HiveConf.ConfVars.HIVE_SERVER2_THRIFT_HTTP_PATH));\n      httpServer.setHandler(context);\n      context.addServlet(new ServletHolder(thriftHttpServlet), httpPath);\n\n      httpServer.start();\n      portNum = connector.getLocalPort();\n      String msg = \"Started \" + ThriftHttpCLIService.class.getSimpleName() + \" in \" + schemeName\n          + \" mode on port \" + portNum + \" path=\" + httpPath + \" with \" + minWorkerThreads + \"...\"\n          + maxWorkerThreads + \" worker threads\";\n      LOG.info(msg);\n    } catch (Exception t) {\n      throw new ServiceException(\"Error initializing \" + getName(), t);\n    }\n  }\n\n  @Override\n  protected void stopServer() {\n    if ((httpServer != null) && httpServer.isStarted()) {\n      try {\n        httpServer.stop();\n        httpServer = null;\n        LOG.info(\"Thrift HTTP server has been stopped\");\n      } catch (Exception e) {\n        LOG.error(\"Error stopping HTTP server: \", e);\n      }\n    }\n  }\n\n  @Override\n  public void run() {\n    try {\n      httpServer.join();\n    } catch (Throwable t) {\n      if (t instanceof InterruptedException) {\n        // This is likely a shutdown\n        LOG.info(\"Caught \" + t.getClass().getSimpleName() + \". Shutting down thrift server.\");\n      } else {\n        LOG.error(\"Error starting HiveServer2: could not start \"\n            + ThriftHttpCLIService.class.getSimpleName(), t);\n        if (HiveThriftServer2$.MODULE$.systemExitOnError().get()) {\n          System.exit(-1);\n        } else {\n          throw new ServiceException(t);\n        }\n      }\n    }\n  }\n\n  private String getHttpPath(String httpPath) {\n    if(httpPath == null || httpPath.equals(\"\")) {\n      httpPath = \"/*\";\n    }\n    else {\n      if(!httpPath.startsWith(\"/\")) {\n        httpPath = \"/\" + httpPath;\n      }\n      if(httpPath.endsWith(\"/\")) {\n        httpPath = httpPath + \"*\";\n      }\n      if(!httpPath.endsWith(\"/*\")) {\n        httpPath = httpPath + \"/*\";\n      }\n    }\n    return httpPath;\n  }\n}",
    "comment": "The config parameter can be like \"path\", \"/path\", \"/path/\", \"path/*\", \"/path1/path2/*\" and so on.\nhttpPath should end up as \"/*\", \"/path/*\" or \"/path1/../pathN/*\"\n@param httpPath\n@return"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/options/Theme.java",
    "type": "method",
    "name": "valueOf",
    "code": "public static Theme valueOf(Charset charset) {\n\t\tif (StandardCharsets.UTF_8.equals(charset)) {\n\t\t\treturn UNICODE;\n\t\t}\n\t\treturn ASCII;\n\t}",
    "comment": "Unicode (extended ASCII) characters are used to display the test execution tree.\n\n<p>Example test plan execution tree:\n<pre class=\"code\">\n engine alpha \n   container BEGIN \n      test 00 \n      test 01 \n engine omega \n container END \n   test 10 \n   test 11  aborted\n container FINAL \n skipped  because\n failing  BMM\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/orc/OrcFooterReader.java",
    "type": "method",
    "name": "if",
    "code": "DataType sparkSchema, Queue<ColumnStatistics> orcStatistics) {\n    OrcColumnStatistics statistics = new OrcColumnStatistics(orcStatistics.remove());\n    if (sparkSchema instanceof StructType structType) {\n      for (StructField field : structType.fields()) {\n        statistics.add(convertStatistics(field.dataType(), orcStatistics));\n      }\n    } else if (sparkSchema instanceof MapType mapType) {\n      statistics.add(convertStatistics(mapType.keyType(), orcStatistics));\n      statistics.add(convertStatistics(mapType.valueType(), orcStatistics));\n    } else if (sparkSchema instanceof ArrayType arrayType) {\n      statistics.add(convertStatistics(arrayType.elementType(), orcStatistics));\n    }\n    return statistics;\n  }",
    "comment": "Convert a queue of ORC {@link ColumnStatistics}s into Spark {@link OrcColumnStatistics}.\nThe queue of ORC {@link ColumnStatistics}s are assumed to be ordered as tree pre-order."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/ovic/src/main/java/org/tensorflow/ovic/OvicBenchmarker.java",
    "type": "method",
    "name": "OvicBenchmarker",
    "code": "protected OvicBenchmarker(double wallTimeMilli) {\n    benchmarkStarted = false;\n    totalRuntimeNano = 0.0;\n    this.wallTimeMilli = wallTimeMilli;\n  }",
    "comment": "Initializes an {@link OvicBenchmarker}\n\n@param wallTimeMilli: a double number specifying the total amount of time to benchmark."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/EnabledForJreRangeConditionTests.java",
    "type": "method",
    "name": "getExecutionCondition",
    "code": "protected ExecutionCondition getExecutionCondition() {\n\t\treturn new EnabledForJreRangeCondition();\n\t}",
    "comment": "Unit tests for {@link EnabledForJreRange @EnabledForJreRange}.\n\n<p>Note that test method names MUST match the test method names in\n{@link EnabledForJreRangeIntegrationTests}.\n\n@since 5.6"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/types/UTF8StringSuite.java",
    "type": "method",
    "name": "concatWsTest",
    "code": "public void concatWsTest() {\n    assertNull(concatWs(null, (UTF8String) null));\n    assertNull(concatWs(null, fromString(\"a\")));\n\n    UTF8String sep = fromString(\"\");\n    assertEquals(\n      EMPTY_UTF8,\n      concatWs(sep, EMPTY_UTF8));\n    assertEquals(\n      fromString(\"ab\"),\n      concatWs(sep, fromString(\"ab\")));\n    assertEquals(\n      fromString(\"ab\"),\n      concatWs(sep, fromString(\"a\"), fromString(\"b\")));\n    assertEquals(\n      fromString(\"abc\"),\n      concatWs(sep, fromString(\"a\"), fromString(\"b\"), fromString(\"c\")));\n    assertEquals(\n      fromString(\"ac\"),\n      concatWs(sep, fromString(\"a\"), null, fromString(\"c\")));\n    assertEquals(\n      fromString(\"a\"),\n      concatWs(sep, fromString(\"a\"), null, null));\n    assertEquals(\n      EMPTY_UTF8,\n      concatWs(sep, null, null, null));\n    assertEquals(\n      fromString(\"\"),\n      concatWs(sep, fromString(\"\"), fromString(\"\")));\n  }",
    "comment": "Returns null if the separator is null\nIf separator is null, concatWs should skip all null inputs and never return null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectMethod",
    "code": "public static MethodSelector selectMethod(Class<?> javaClass, String methodName, Class<?>... parameterTypes) {\n\t\tPreconditions.notNull(javaClass, \"Class must not be null\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\t\tPreconditions.notNull(parameterTypes, \"Parameter types array must not be null\");\n\t\tPreconditions.containsNoNullElements(parameterTypes, \"Parameter types array must not contain null elements\");\n\t\treturn new MethodSelector(javaClass, methodName, parameterTypes);\n\t}",
    "comment": "Create a {@code MethodSelector} for the supplied {@link Class}, method name,\nand parameter types.\n\n@param javaClass the class in which the method is declared, or a subclass thereof;\nnever {@code null}\n@param methodName the name of the method to select; never {@code null} or blank\n@param parameterTypes the formal parameter types of the method; never\n{@code null} though potentially empty if the method does not declare parameters\n@since 1.10\n@see MethodSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/runner/notification/SynchronizedRunListenerTest.java",
    "type": "method",
    "name": "MethodSignature",
    "code": "public MethodSignature(Method method) {\n            fMethod = method;\n            fName = method.getName();\n            fParameterTypes = Arrays.asList(method.getParameterTypes());\n        }",
    "comment": "Tests for {@link SynchronizedRunListener}.\n\n@author kcooney (Kevin Cooney)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "selectors",
    "code": "public LauncherDiscoveryRequestBuilder selectors(List<? extends DiscoverySelector> selectors) {\n\t\tPreconditions.notNull(selectors, \"selectors list must not be null\");\n\t\tPreconditions.containsNoNullElements(selectors, \"individual selectors must not be null\");\n\t\tthis.selectors.addAll(selectors);\n\t\treturn this;\n\t}",
    "comment": "Add all supplied {@code selectors} to the request.\n\n@param selectors the {@code DiscoverySelectors} to add; never {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/BuildThreadFactory.java",
    "type": "method",
    "name": "newThread",
    "code": "public Thread newThread(Runnable r) {\n        return new Thread(r, String.format(\"%s-%d\", PREFIX, id.getAndIncrement()));\n    }",
    "comment": "Simple {@link ThreadFactory} implementation that ensures the corresponding threads have a meaningful name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testBagNegate",
    "code": "public void testBagNegate() {\n        IMoney expected = MoneyBag.create(new Money(-12, \"CHF\"), new Money(-7, \"USD\"));\n        assertEquals(expected, fMB1.negate());\n    }",
    "comment": "{[12 CHF][7 USD]} negate == {[-12 CHF][-7 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java21/example/DynamicTestsNamedDemo.java",
    "type": "method",
    "name": "dynamicTestsFromStreamFactoryMethodWithNamedExecutables",
    "code": "Stream<DynamicTest> dynamicTestsFromStreamFactoryMethodWithNamedExecutables() {\n\t\tvar inputStream = Stream.of(\"racecar\", \"radar\", \"mom\", \"dad\")\n\t\t\t\t.map(PalindromeNamedExecutable::new);\n\n\t\treturn DynamicTest.stream(inputStream);\n\t}",
    "comment": "Stream of palindromes to check\nend::user_guide[]\n@formatter:off\ntag::user_guide[]\nend::user_guide[]\n@formatter:on\ntag::user_guide[]\nReturns a stream of dynamic tests based on NamedExecutables."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "createTestDescription",
    "code": "public static Description createTestDescription(String className, String name, Annotation... annotations) {\n        return new Description(null, formatDisplayName(name, className), annotations);\n    }",
    "comment": "Create a <code>Description</code> of a single test named <code>name</code> in the 'class' named\n<code>className</code>. Generally, this will be a leaf <code>Description</code>. This method is a better choice\nthan {@link #createTestDescription(Class, String, Annotation...)} for test runners whose test cases are not\ndefined in an actual Java <code>Class</code>.\n\n@param className the class name of the test\n@param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n@param annotations meta-data about the test, for downstream interpreters\n@return a <code>Description</code> named <code>name</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/ArrayWrappers.java",
    "type": "method",
    "name": "forArray",
    "code": "public static Comparable<Object> forArray(Object a) {\n    Preconditions.checkArgument(a.getClass().isArray());\n    Comparable<?> ret;\n    if (a instanceof int[] ia) {\n      ret = new ComparableIntArray(ia);\n    } else if (a instanceof long[] la) {\n      ret = new ComparableLongArray(la);\n    } else if (a instanceof byte[] ba) {\n      ret = new ComparableByteArray(ba);\n    } else {\n      Preconditions.checkArgument(!a.getClass().getComponentType().isPrimitive());\n      ret = new ComparableObjectArray((Object[]) a);\n    }\n    return (Comparable<Object>) ret;\n  }",
    "comment": "A factory for array wrappers so that arrays can be used as keys in a map, sorted or not.\n\nThe comparator implementation makes two assumptions:\n- All elements are instances of Comparable\n- When comparing two arrays, they both contain elements of the same type in corresponding\nindices.\n\nOtherwise, ClassCastExceptions may occur. The equality method can compare any two arrays.\n\nThis class is not efficient and is mostly meant to compare really small arrays, like those\ngenerally used as indices and keys in a KVStore."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaUDFSuite.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n    spark = SparkSession.builder()\n      .master(\"local[*]\")\n      .appName(\"testing\")\n      .getOrCreate();\n  }",
    "comment": "The test suite itself is Serializable so that anonymous Function implementations can be\nserialized, as an alternative to converting these anonymous classes to static inner classes;\nsee http://stackoverflow.com/questions/758570/."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/PackageSelectorTests.java",
    "type": "method",
    "name": "equalsAndHashCode",
    "code": "void equalsAndHashCode() {\n\t\tvar selector1 = new PackageSelector(\"org.example.foo\");\n\t\tvar selector2 = new PackageSelector(\"org.example.foo\");\n\t\tvar selector3 = new PackageSelector(\"org.example.bar\");\n\n\t\tassertEqualsAndHashCode(selector1, selector2, selector3);\n\t}",
    "comment": "Unit tests for {@link PackageSelector}.\n\n@since 1.3\n@see DiscoverySelectorsTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/categories/Categories.java",
    "type": "method",
    "name": "matchesAnyParentCategories",
    "code": "private boolean matchesAnyParentCategories(Set<Class<?>> childCategories, Set<Class<?>> parentCategories) {\n            for (Class<?> parentCategory : parentCategories) {\n                if (hasAssignableTo(childCategories, parentCategory)) {\n                    return true;\n                }\n            }\n            return false;\n        }",
    "comment": "@return <tt>true</tt> if at least one (any) parent category match a child, otherwise <tt>false</tt>.\nIf empty <tt>parentCategories</tt>, returns <tt>false</tt>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/BeforeAndAfterTestExecutionCallbackTests.java",
    "type": "method",
    "name": "resetCallSequence",
    "code": "void resetCallSequence() {\n\t\tcallSequence.clear();\n\t\tactualExceptionInAfterTestExecution = null;\n\t}",
    "comment": "Integration tests that verify support for {@link BeforeTestExecutionCallback},\n{@link AfterTestExecutionCallback}, {@link BeforeEach}, and {@link AfterEach}\nin the {@link JupiterTestEngine}.\n\n@since 5.0\n@see BeforeAndAfterEachTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(boolean condition, String message) {\n\t\tAssertFalse.assertFalse(condition, message);\n\t}",
    "comment": "<em>Assert</em> that the supplied {@code condition} is {@code false}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(IterationSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link IterationSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaGradientBoostingClassificationExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf sparkConf = new SparkConf()\n      .setAppName(\"JavaGradientBoostedTreesClassificationExample\");\n    JavaSparkContext jsc = new JavaSparkContext(sparkConf);\n\n    String datapath = \"data/mllib/sample_libsvm_data.txt\";\n    JavaRDD<LabeledPoint> data = MLUtils.loadLibSVMFile(jsc.sc(), datapath).toJavaRDD();\n    JavaRDD<LabeledPoint>[] splits = data.randomSplit(new double[]{0.7, 0.3});\n\n}",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file.\nSplit the data into training and test sets (30% held out for testing)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/InMemoryCartRepository.java",
    "type": "method",
    "name": "removeItemFromCart",
    "code": "public void removeItemFromCart(final String userId, final String productId) {\n    List<Cart> cart = userCarts.get(userId);\n    if (cart != null) {\n      cart.removeIf(item -> item.getProduct().getId().equals(productId));\n    }\n  }",
    "comment": "Removes an item from the user's cart.\n\n@param userId The ID of the user.\n@param productId The ID of the product to be removed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/main/java/com/iluwatar/health/check/CustomHealthIndicator.java",
    "type": "method",
    "name": "health",
    "code": "public Health health() {\n    LOGGER.info(\"Performing health check\");\n    CompletableFuture<Health> healthFuture =\n        healthChecker.performCheck(this::check, timeoutInSeconds);\n    try {\n      return healthFuture.get(timeoutInSeconds, TimeUnit.SECONDS);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      LOGGER.error(\"Health check interrupted\", e);\n      throw new HealthCheckInterruptedException(e);\n    } catch (Exception e) {\n      LOGGER.error(\"Health check failed\", e);\n      return Health.down(e).build();\n    }\n  }",
    "comment": "Perform a health check and cache the result.\n\n@return the health status of the application\n@throws HealthCheckInterruptedException if the health check is interrupted"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "updateColumnType",
    "code": "static TableChange updateColumnType(String[] fieldNames, DataType newDataType) {\n    return new UpdateColumnType(fieldNames, newDataType);\n  }",
    "comment": "Create a TableChange for updating the type of a field that is nullable.\n<p>\nThe field names are used to find the field to update.\n<p>\nIf the field does not exist, the change will result in an {@link IllegalArgumentException}.\n\n@param fieldNames field names of the column to update\n@param newDataType the new data type\n@return a TableChange for the update"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/ShuffleSortDataFormat.java",
    "type": "method",
    "name": "getKey",
    "code": "public PackedRecordPointer getKey(LongArray data, int pos) {\n    throw new UnsupportedOperationException();\n  }",
    "comment": "Since we re-use keys, this method shouldn't be called."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, boolean expected, boolean actual) {\n        Assert.assertEquals(message, expected, actual);\n    }",
    "comment": "Asserts that two booleans are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/ArtifactUtils.java",
    "type": "method",
    "name": "copyArtifacts",
    "code": "public static <T extends Collection<Artifact>> T copyArtifacts(Collection<Artifact> from, T to) {\n        for (Artifact artifact : from) {\n            to.add(ArtifactUtils.copyArtifact(artifact));\n        }\n        return to;\n    }",
    "comment": "Copy artifact to a collection.\n\n@param <T> the target collection type\n@param from an artifact collection\n@param to the target artifact collection\n@return <code>to</code> collection"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultProjectArtifactFactory.java",
    "type": "method",
    "name": "getEffectiveScope",
    "code": "private static String getEffectiveScope(String originalScope, String inheritedScope) {\n        String effectiveScope = Artifact.SCOPE_RUNTIME;\n\n        if (originalScope == null) {\n            originalScope = Artifact.SCOPE_COMPILE;\n        }\n\n        if (inheritedScope == null) {\n            effectiveScope = originalScope;\n        } else if (Artifact.SCOPE_TEST.equals(originalScope) || Artifact.SCOPE_PROVIDED.equals(originalScope)) {\n            effectiveScope = null;\n        } else if (Artifact.SCOPE_SYSTEM.equals(originalScope)) {\n            effectiveScope = Artifact.SCOPE_SYSTEM;\n        } else if (Artifact.SCOPE_COMPILE.equals(originalScope) && Artifact.SCOPE_COMPILE.equals(inheritedScope)) {\n            effectiveScope = Artifact.SCOPE_COMPILE;\n        } else if (Artifact.SCOPE_TEST.equals(inheritedScope)) {\n            effectiveScope = Artifact.SCOPE_TEST;\n        } else if (Artifact.SCOPE_PROVIDED.equals(inheritedScope)) {\n            effectiveScope = Artifact.SCOPE_PROVIDED;\n        }\n\n        return effectiveScope;\n    }",
    "comment": "direct dependency retains its scope\ntest and provided are not transitive, so exclude them\nsystem scope come through unchanged...\nadded to retain compile scope. Remove if you want to compile inherited as runtime"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "a",
    "code": "default MessageBuilder a(CharSequence value, int start, int end) {\n        return append(value, start, end);\n    }",
    "comment": "Append content to the message buffer.\n\n@param value the content to append\n@param start the starting index of the subsequence to be appended\n@param end the end index of the subsequence to be appended\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/NullOrdering.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n    return switch (this) {\n      case NULLS_FIRST -> \"NULLS FIRST\";\n      case NULLS_LAST -> \"NULLS LAST\";\n    };\n  }",
    "comment": "A null order used in sorting expressions.\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/notification/Failure.java",
    "type": "method",
    "name": "Failure",
    "code": "public Failure(Description description, Throwable thrownException) {\n        this.fThrownException = thrownException;\n        this.fDescription = description;\n    }",
    "comment": "Constructs a <code>Failure</code> with the given description and exception.\n\n@param description a {@link org.junit.runner.Description} of the test that failed\n@param thrownException the exception that was thrown while running the test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "CollationIdentifier",
    "code": "public CollationIdentifier(String provider, String collationName, String version) {\n      this.provider = provider;\n      this.name = collationName;\n      this.version = version;\n    }",
    "comment": "Identifier for single a collation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-class-loader/maven-it-plugin-class-loader/src/main/java/org/apache/maven/plugin/coreit/ExpressionUtil.java",
    "type": "method",
    "name": "getProperty",
    "code": "static Object getProperty(Object context, String property) {\n        Object value;\n\n        Class type = context.getClass();\n        if (context instanceof Collection) {\n            type = Collection.class;\n        } else if (context instanceof Map) {\n            type = Map.class;\n        }\n\n        try {\n            try {\n                Method method = type.getMethod(property, NO_PARAMS);\n                method.setAccessible(true);\n                value = method.invoke(context, NO_ARGS);\n            } catch (NoSuchMethodException e) {\n                try {\n                    String name = \"get\" + Character.toUpperCase(property.charAt(0)) + property.substring(1);\n                    Method method = type.getMethod(name, NO_PARAMS);\n                    method.setAccessible(true);\n                    value = method.invoke(context, NO_ARGS);\n                } catch (NoSuchMethodException e1) {\n                    try {\n                        String name = \"is\" + Character.toUpperCase(property.charAt(0)) + property.substring(1);\n                        Method method = type.getMethod(name, NO_PARAMS);\n                        method.setAccessible(true);\n                        value = method.invoke(context, NO_ARGS);\n                    } catch (NoSuchMethodException e2) {\n                        try {\n                            Method method;\n                            try {\n                                method = type.getMethod(\"get\", STRING_PARAM);\n                            } catch (NoSuchMethodException e3) {\n                                method = type.getMethod(\"get\", OBJECT_PARAM);\n                            }\n                            method.setAccessible(true);\n                            value = method.invoke(context, new Object[] {property});\n                            try {\n                                Field field = type.getField(property);\n                                field.setAccessible(true);\n                                value = field.get(context);\n                            } catch (NoSuchFieldException e4) {\n                                if (\"length\".equals(property) && type.isArray()) {\n                                    value = Array.getLength(context);\n                                } else {\n                                    throw e4;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            value = null;\n        }\n        return value;\n    }",
    "comment": "Gets the value of a (public) bean property from the specified object.\n\n@param context  The object whose bean property should be retrieved, must not be <code>null</code>.\n@param property The name of the bean property, must not be <code>null</code>.\n@return The value of the bean property or <code>null</code> if the property does not exist."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "gallopLeft",
    "code": "private int gallopLeft(K key, Buffer a, int base, int len, int hint, Comparator<? super K> c) {\n      assert len > 0 && hint >= 0 && hint < len;\n      int lastOfs = 0;\n      int ofs = 1;\n      K key0 = s.newKey();\n\n      if (c.compare(key, s.getKey(a, base + hint, key0)) > 0) {\n        // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]\n        int maxOfs = len - hint;\n        while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint + ofs, key0)) > 0) {\n          lastOfs = ofs;\n          ofs = (ofs << 1) + 1;\n          if (ofs <= 0)   // int overflow\n            ofs = maxOfs;\n        }\n        if (ofs > maxOfs)\n          ofs = maxOfs;\n\n        // Make offsets relative to base\n        lastOfs += hint;\n        ofs += hint;\n      } else { // key <= a[base + hint]\n        // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]\n        final int maxOfs = hint + 1;\n        while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint - ofs, key0)) <= 0) {\n          lastOfs = ofs;\n          ofs = (ofs << 1) + 1;\n          if (ofs <= 0)   // int overflow\n            ofs = maxOfs;\n        }\n        if (ofs > maxOfs)\n          ofs = maxOfs;\n\n        // Make offsets relative to base\n        int tmp = lastOfs;\n        lastOfs = hint - ofs;\n        ofs = hint - tmp;\n      }\n      assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;\n\n      /*\n       * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere\n       * to the right of lastOfs but no farther right than ofs.  Do a binary\n       * search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].\n       */\n      lastOfs++;\n      while (lastOfs < ofs) {\n        int m = lastOfs + ((ofs - lastOfs) >>> 1);\n\n        if (c.compare(key, s.getKey(a, base + m, key0)) > 0)\n          lastOfs = m + 1;  // a[base + m] < key\n        else\n          ofs = m;          // key <= a[base + m]\n      }\n      assert lastOfs == ofs;    // so a[base + ofs - 1] < key <= a[base + ofs]\n      return ofs;\n    }",
    "comment": "Locates the position at which to insert the specified key into the\nspecified sorted range; if the range contains an element equal to key,\nreturns the index of the leftmost equal element.\n\n@param key the key whose insertion point to search for\n@param a the array in which to search\n@param base the index of the first element in the range\n@param len the length of the range; must be > 0\n@param hint the index at which to begin the search, 0 <= hint < n.\nThe closer hint is to the result, the faster this method will run.\n@param c the comparator used to order the range, and to search\n@return the int k,  0 <= k <= n such that a[b + k - 1] < key <= a[b + k],\npretending that a[b - 1] is minus infinity and a[b + n] is infinity.\nIn other words, key belongs at index b + k; or in other words,\nthe first k elements of a should precede key, and the last n - k\nshould follow it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/plugin/DefaultReportingConverter.java",
    "type": "method",
    "name": "convertReporting",
    "code": "public void convertReporting(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\n        Reporting reporting = model.getReporting();\n\n        if (reporting == null) {\n            return;\n        }\n\n        Build build = model.getBuild();\n\n        if (build == null) {\n            build = new Build();\n            model.setBuild(build);\n            model.setLocation(\"build\", location);\n        }\n\n        Plugin sitePlugin = findSitePlugin(build);\n\n        if (sitePlugin == null) {\n            sitePlugin = new Plugin();\n            sitePlugin.setArtifactId(\"maven-site-plugin\");\n            sitePlugin.setLocation(\"artifactId\", location);\n            PluginManagement pluginManagement = build.getPluginManagement();\n            if (pluginManagement == null) {\n                pluginManagement = new PluginManagement();\n                build.setPluginManagement(pluginManagement);\n            }\n            pluginManagement.addPlugin(sitePlugin);\n        }\n\n        Xpp3Dom configuration = (Xpp3Dom) sitePlugin.getConfiguration();\n\n        if (configuration == null) {\n            configuration = new Xpp3Dom(\"configuration\", location);\n            sitePlugin.setConfiguration(configuration);\n        }\n\n        Xpp3Dom reportPlugins = configuration.getChild(\"reportPlugins\");\n\n        if (reportPlugins != null) {\n            // new-style report configuration already present: warn since this new style has been deprecated\n            // in favor of classical reporting section MSITE-647 / MSITE-684\n            problems.add(new ModelProblemCollectorRequest(Severity.WARNING, Version.BASE)\n                    .setMessage(\"Reporting configuration should be done in <reporting> section, \"\n                            + \"not in maven-site-plugin <configuration> as reportPlugins parameter.\")\n                    .setLocation(sitePlugin.getLocation(\"configuration\")));\n            return;\n        }\n\n        if (configuration.getChild(\"outputDirectory\") == null) {\n            addDom(\n                    configuration,\n                    \"outputDirectory\",\n                    reporting.getOutputDirectory(),\n                    reporting.getLocation(\"outputDirectory\"));\n        }\n\n        reportPlugins = new Xpp3Dom(\"reportPlugins\", location);\n        configuration.addChild(reportPlugins);\n\n        boolean hasMavenProjectInfoReportsPlugin = false;\n\n        /* waiting for MSITE-484 before deprecating <reporting> section\n        if ( !reporting.getPlugins().isEmpty()\n            && request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1 )\n        {\n\n            problems.add( new ModelProblemCollectorRequest( Severity.WARNING, Version.V31 )\n                    .setMessage( \"The <reporting> section is deprecated, please move the reports to the <configuration>\"\n                                 + \" section of the new Maven Site Plugin.\" )\n                    .setLocation( reporting.getLocation( \"\" ) ) );\n        }*/\n\n        for (ReportPlugin plugin : reporting.getPlugins()) {\n            Xpp3Dom reportPlugin = convert(plugin);\n            reportPlugins.addChild(reportPlugin);\n\n            if (!reporting.isExcludeDefaults()\n                    && !hasMavenProjectInfoReportsPlugin\n                    && \"org.apache.maven.plugins\".equals(plugin.getGroupId())\n                    && \"maven-project-info-reports-plugin\".equals(plugin.getArtifactId())) {\n                hasMavenProjectInfoReportsPlugin = true;\n            }\n        }\n\n        if (!reporting.isExcludeDefaults() && !hasMavenProjectInfoReportsPlugin) {\n            Xpp3Dom dom = new Xpp3Dom(\"reportPlugin\", location);\n\n            addDom(dom, \"groupId\", \"org.apache.maven.plugins\");\n            addDom(dom, \"artifactId\", \"maven-project-info-reports-plugin\");\n\n            reportPlugins.addChild(dom);\n        }\n    }",
    "comment": "Handles conversion of the <code>&lt;reporting&gt;</code> section into the configuration of Maven Site Plugin 3.x,\ni.e. <code>reportPlugins</code> and <code>outputDirectory</code> parameters.\n\n@deprecated since maven 4.0, this class is now a no-op class and is only here for compatibility"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/scanning/DefaultClasspathScanner.java",
    "type": "method",
    "name": "determineSubpackageName",
    "code": "private String determineSubpackageName(Path baseDir, Path classFile) {\n\t\tPath relativePath = baseDir.relativize(classFile.getParent());\n\t\tString pathSeparator = baseDir.getFileSystem().getSeparator();\n\t\tString subpackageName = relativePath.toString().replace(pathSeparator, PACKAGE_SEPARATOR_STRING);\n\t\tif (subpackageName.endsWith(pathSeparator)) {\n\t\t\tsubpackageName = subpackageName.substring(0, subpackageName.length() - pathSeparator.length());\n\t\t}\n\t\treturn subpackageName;\n\t}",
    "comment": "Workaround for JDK bug: https://bugs.openjdk.java.net/browse/JDK-8153248"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SparkSaslServer.java",
    "type": "method",
    "name": "dispose",
    "code": "public synchronized void dispose() {\n    if (saslServer != null) {\n      try {\n        saslServer.dispose();\n      } catch (SaslException e) {\n        // ignore\n      } finally {\n        saslServer = null;\n      }\n    }\n  }",
    "comment": "Disposes of any system resources or security-sensitive information the\nSaslServer might be using."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/DependencyResolverRequest.java",
    "type": "method",
    "name": "verbose",
    "code": "public DependencyResolverRequestBuilder verbose(boolean verbose) {\n            this.verbose = verbose;\n            return this;\n        }",
    "comment": "Specifies that the collection should be verbose.\n\n@param verbose whether the collection should be verbose or not\n@return this request for chaining, never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcProtocol",
    "code": "public String sslRpcProtocol() {\n    return conf.get(\"spark.ssl.rpc.protocol\", null);\n  }",
    "comment": "SSL protocol (remember that SSLv3 was compromised) supported by Java"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "executionStarted",
    "code": "public static Event executionStarted(TestDescriptor testDescriptor) {\n\t\treturn new Event(EventType.STARTED, testDescriptor, null);\n\t}",
    "comment": "Create a <em>started</em> {@code Event} for the supplied\n{@link TestDescriptor}.\n\n@param testDescriptor the {@code TestDescriptor} associated with the event;\nnever {@code null}\n@return the newly created {@code Event}\n@see EventType#STARTED"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java",
    "type": "method",
    "name": "getJavaMethod",
    "code": "public final Method getJavaMethod() {\n\t\tlazyLoadJavaMethod();\n\t\treturn this.javaMethod;\n\t}",
    "comment": "Get the {@linkplain Method Java method} of this source.\n\n<p>If the {@link Method} was not provided, but only the name, this method\nattempts to lazily load the {@code Method} based on its name and throws a\n{@link PreconditionViolationException} if the method cannot be loaded.\n\n@since 1.7\n@see #getMethodName()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/notification/RunNotifier.java",
    "type": "method",
    "name": "pleaseStop",
    "code": "public void pleaseStop() {\n        pleaseStop = true;\n    }",
    "comment": "Ask that the tests run stop before starting the next test. Phrased politely because\nthe test currently running will not be interrupted. It seems a little odd to put this\nfunctionality here, but the <code>RunNotifier</code> is the only object guaranteed\nto be shared amongst the many runners involved."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/InMemoryCartRepository.java",
    "type": "method",
    "name": "clearCart",
    "code": "public void clearCart(final String userId) {\n    userCarts.remove(userId);\n  }",
    "comment": "Clears all items from the user's cart.\n\n@param userId The ID of the user."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertLinesMatch",
    "code": "public static void assertLinesMatch(List<String> expectedLines, List<String> actualLines) {\n\t\tAssertLinesMatch.assertLinesMatch(expectedLines, actualLines);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} list of {@linkplain String}s matches {@code actual}\nlist.\n\n<p>This method differs from other assertions that effectively only check {@link String#equals(Object)},\nin that it uses the following staged matching algorithm:\n\n<p>For each pair of expected and actual lines do\n<ol>\n<li>check if {@code expected.equals(actual)} - if yes, continue with next pair</li>\n<li>otherwise treat {@code expected} as a regular expression and check via\n{@link String#matches(String)} - if yes, continue with next pair</li>\n<li>otherwise check if {@code expected} line is a fast-forward marker, if yes apply\nfast-forward actual lines accordingly (see below) and goto 1.</li>\n</ol>\n\n<p>A valid fast-forward marker is an expected line that starts and ends with the literal\n{@code >>} and contains at least 4 characters. Examples:\n<ul>\n<li>{@code >>>>}<br>{@code >> stacktrace >>}<br>{@code >> single line, non Integer.parse()-able comment >>}\n<br>Skip arbitrary number of actual lines, until first matching subsequent expected line is found. Any\ncharacter between the fast-forward literals are discarded.</li>\n<li>{@code \">> 21 >>\"}\n<br>Skip strictly 21 lines. If they can't be skipped for any reason, an assertion error is raised.</li>\n</ul>\n\n<p>Here is an example showing all three kinds of expected line formats:\n<pre>{@code\nls -la /\ntotal [\\d]+\ndrwxr-xr-x  0 root root   512 Jan  1  1970 .\ndrwxr-xr-x  0 root root   512 Jan  1  1970 ..\ndrwxr-xr-x  0 root root   512 Apr  5 07:45 bin\n>> 4 >>\n-rwxr-xr-x  1 root root [\\d]+ Jan  1  1970 init\n>> M A N Y  M O R E  E N T R I E S >>\ndrwxr-xr-x  0 root root   512 Sep 22  2017 var\n}</pre>\n<p>Fails with a generated failure message describing the difference."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng7468UnsupportedPluginsParametersTest.java",
    "type": "method",
    "name": "assertWarningContains",
    "code": "private void assertWarningContains(List<String> warnLines) {\n        assertTrue(\n                warnLines.remove(\n                        \"[WARNING] Parameter 'invalidParam' is unknown for plugin 'maven-it-plugin-configuration:2.1-SNAPSHOT:touch (default)'\"));\n\n        assertTrue(\n                warnLines.remove(\n                        \"[WARNING] Parameter 'invalidXml' is unknown for plugin 'maven-it-plugin-configuration:2.1-SNAPSHOT:touch (default)'\"));\n\n        assertTrue(warnLines.isEmpty(), \"Not verified line: \" + warnLines);\n    }",
    "comment": "Test that ensures that warning is printed for configuration"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Double expected, Double actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantBuilder.java",
    "type": "method",
    "name": "addKey",
    "code": "public int addKey(String key) {\n    int id;\n    if (dictionary.containsKey(key)) {\n      id = dictionary.get(key);\n    } else {\n      id = dictionaryKeys.size();\n      dictionary.put(key, id);\n      dictionaryKeys.add(key.getBytes(StandardCharsets.UTF_8));\n    }\n    return id;\n  }",
    "comment": "Add a key to the variant dictionary. If the key already exists, the dictionary is not modified.\nIn either case, return the id of the key."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/test/java/org/apache/spark/sql/hive/test/Complex.java",
    "type": "method",
    "name": "Complex",
    "code": "public Complex(Complex other) {\n    __isset_bitfield = other.__isset_bitfield;\n    this.aint = other.aint;\n    if (other.isSetAString()) {\n      this.aString = other.aString;\n    }\n    if (other.isSetLint()) {\n      List<Integer> __this__lint = new ArrayList<>();\n      for (Integer other_element : other.lint) {\n        __this__lint.add(other_element);\n      }\n      this.lint = __this__lint;\n    }\n    if (other.isSetLString()) {\n      List<String> __this__lString = new ArrayList<>();\n      for (String other_element : other.lString) {\n        __this__lString.add(other_element);\n      }\n      this.lString = __this__lString;\n    }\n    if (other.isSetLintString()) {\n      List<IntString> __this__lintString = new ArrayList<>();\n      for (IntString other_element : other.lintString) {\n        __this__lintString.add(new IntString(other_element));\n      }\n      this.lintString = __this__lintString;\n    }\n    if (other.isSetMStringString()) {\n      Map<String,String> __this__mStringString = new HashMap<>();\n      for (Map.Entry<String, String> other_element : other.mStringString.entrySet()) {\n\n        String other_element_key = other_element.getKey();\n        String other_element_value = other_element.getValue();\n\n        String __this__mStringString_copy_key = other_element_key;\n\n        String __this__mStringString_copy_value = other_element_value;\n\n        __this__mStringString.put(__this__mStringString_copy_key, __this__mStringString_copy_value);\n      }\n      this.mStringString = __this__mStringString;\n    }\n  }",
    "comment": "Performs a deep copy on <i>other</i>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Transform.java",
    "type": "method",
    "name": "children",
    "code": "default Expression[] children() { return arguments(); }\n}",
    "comment": "Returns the arguments passed to the transform function."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getUuid",
    "code": "public UUID getUuid() {\n    return VariantUtil.getUuid(value, pos);\n  }",
    "comment": "Get a UUID value from the variant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "getPrefix",
    "code": "public long getPrefix() {\n    return ByteArray.getPrefix(base, offset, numBytes);\n  }",
    "comment": "Returns a 64-bit integer that can be used as the prefix used in sorting."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/MavenSessionBuilderSupplier.java",
    "type": "method",
    "name": "MavenSessionBuilderSupplier",
    "code": "public MavenSessionBuilderSupplier(RepositorySystem repositorySystem) {\n        this.repositorySystem = requireNonNull(repositorySystem);\n        this.scopeManager = new ScopeManagerImpl(Maven4ScopeManagerConfiguration.INSTANCE);\n    }",
    "comment": "A simple {@link Supplier} of {@link SessionBuilder} instances, that on each call supplies newly\nconstructed instance. To create session out of builder, use {@link SessionBuilder#build()}. For proper closing\nof sessions, use {@link CloseableSession#close()} method on built instance(s).\n<p>\nExtend this class and override methods to customize, if needed.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3503Xpp3ShadingTest.java",
    "type": "method",
    "name": "MavenITmng3503Xpp3ShadingTest",
    "code": "public MavenITmng3503Xpp3ShadingTest() {\n        super(\"(2.0.9,2.1.0-M1),(2.1.0-M1,)\"); // only test in 2.0.10+, and not in 2.1.0-M1\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3503\">MNG-3503</a>. The first test verifies that\na plugin using plexus-utils-1.1 does not cause linkage errors. The second test verifies that a plugin with a\ndifferent implementation of the shaded classes is used instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/Utility.java",
    "type": "method",
    "name": "countLines",
    "code": "public static Integer countLines(String fileLocation) {\n    try (var bufferedReader = new BufferedReader(new FileReader(fileLocation))) {\n      LOGGER.error(\"An error occurred: \", ex);\n    }\n    return 0;\n  }",
    "comment": "Count the number of lines in a file.\n\n@return number of lines, 0 if file does not exist."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "stopBackgroundThread",
    "code": "private void stopBackgroundThread() {\n    backgroundThread.quitSafely();\n    try {\n      backgroundThread.join();\n      backgroundThread = null;\n      backgroundHandler = null;\n    } catch (final InterruptedException e) {\n      LOGGER.e(e, \"Exception!\");\n    }\n  }",
    "comment": "Stops the background thread and its {@link Handler}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3314OfflineSnapshotsTest.java",
    "type": "method",
    "name": "MavenITmng3314OfflineSnapshotsTest",
    "code": "public MavenITmng3314OfflineSnapshotsTest() {\n        super(\"(2.0.9,2.1.0-M1),(2.1.0-M1,)\"); // only test in 2.0.10+, and not in 2.1.0-M1\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3314\">MNG-3314</a>.\n\nVerifies that offline mode functions correctly for snapshot dependencies.\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExternalBlockHandler.java",
    "type": "method",
    "name": "shuffleMapIdAndReduceIds",
    "code": "private int[] shuffleMapIdAndReduceIds(String[] blockIds, int shuffleId) {\n      final int[] mapIdAndReduceIds = new int[2 * blockIds.length];\n      for (int i = 0; i < blockIds.length; i++) {\n        String[] blockIdParts = blockIds[i].split(\"_\");\n        if (blockIdParts.length != 4 || !blockIdParts[0].equals(SHUFFLE_BLOCK_ID)) {\n          throw new IllegalArgumentException(\"Unexpected shuffle block id format: \" + blockIds[i]);\n        }\n        if (Integer.parseInt(blockIdParts[1]) != shuffleId) {\n          throw new IllegalArgumentException(\"Expected shuffleId=\" + shuffleId +\n            \", got:\" + blockIds[i]);\n        }\n        // mapId\n        mapIdAndReduceIds[2 * i] = Integer.parseInt(blockIdParts[2]);\n        // reduceId\n        mapIdAndReduceIds[2 * i + 1] = Integer.parseInt(blockIdParts[3]);\n      }\n      return mapIdAndReduceIds;\n    }",
    "comment": "@param blockIds Regular shuffle blockIds starts with SHUFFLE_BLOCK_ID to be parsed\n@param shuffleId shuffle blocks shuffleId\n@return mapId and reduceIds of the shuffle blocks in the same order as that of the blockIds\n\nRegular shuffle blocks format should be shuffle_$shuffleId_$mapId_$reduceId"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java9/org/junit/platform/commons/util/ModuleUtils.java",
    "type": "method",
    "name": "className",
    "code": "private String className(String resourceName) {\n\t\t\tresourceName = resourceName.substring(0, resourceName.length() - 6); // 6 = \".class\".length()\n\t\t\tresourceName = resourceName.replace('/', '.');\n\t\t\treturn resourceName;\n\t\t}",
    "comment": "Convert resource name to binary class name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/Trigger.java",
    "type": "method",
    "name": "AvailableNow",
    "code": "public static Trigger AvailableNow() {\n    return AvailableNowTrigger$.MODULE$;\n  }",
    "comment": "A trigger that processes all available data at the start of the query in one or multiple\nbatches, then terminates the query.\n\nUsers are encouraged to set the source options to control the size of the batch as similar as\ncontrolling the size of the batch in {@link #ProcessingTime(long)} trigger.\n\nNOTES:\n- This trigger provides a strong guarantee of processing: regardless of how many batches were\nleft over in previous run, it ensures all available data at the time of execution gets\nprocessed before termination. All uncommitted batches will be processed first.\n- Watermark gets advanced per each batch, and no-data batch gets executed before termination\nif the last batch advances the watermark. This helps to maintain smaller and predictable\nstate size and smaller latency on the output of stateful operators.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertDoesNotThrow",
    "code": "public static void assertDoesNotThrow(Executable executable) {\n\t\tAssertDoesNotThrow.assertDoesNotThrow(executable);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code executable} does\n<em>not</em> throw any kind of {@linkplain Throwable exception}.\n\n<h4>Usage Note</h4>\n<p>Although any exception thrown from a test method will cause the test\nto <em>fail</em>, there are certain use cases where it can be beneficial\nto explicitly assert that an exception is not thrown for a given code\nblock within a test method.\n\n@since 5.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(int expected, int actual) {\n        Assert.assertEquals(expected, actual);\n    }",
    "comment": "Asserts that two ints are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStore.java",
    "type": "method",
    "name": "get",
    "code": "public Object get(N namespace, Object key) {\n\t\tStoredValue storedValue = getStoredValue(new CompositeKey<>(namespace, key));\n\t\treturn StoredValue.evaluateIfNotNull(storedValue);\n\t}",
    "comment": "Get the value stored for the supplied namespace and key in this store or\nthe parent store, if present.\n\n@param namespace the namespace; never {@code null}\n@param key the key; never {@code null}\n@return the stored value; may be {@code null}\n@throws NamespacedHierarchicalStoreException if this store has already been\nclosed"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
    "type": "method",
    "name": "prepare",
    "code": "private void prepare() {\n\t\tthrowableCollector.execute(() -> context = node.prepare(parentContext));\n\n\t\tparentContext = null;\n\t}",
    "comment": "Clear reference to parent context to allow it to be garbage collected.\nSee https://github.com/junit-team/junit5/issues/1578"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/server/BlockPushNonFatalFailure.java",
    "type": "method",
    "name": "BlockPushNonFatalFailure",
    "code": "public BlockPushNonFatalFailure(ByteBuffer response, String msg) {\n    super(msg);\n    this.response = response;\n  }",
    "comment": "The error code of the failure. This field is only set on the client side when a\nBlockPushNonFatalFailure is recreated from the error code received from the server."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/InMemoryProductRepository.java",
    "type": "method",
    "name": "getProductById",
    "code": "public Product getProductById(final String productId) {\n    return products.get(productId);\n  }",
    "comment": "Retrieves a product by its unique ID.\n\n@param productId The ID of the product to retrieve.\n@return The {@link Product} corresponding to the given ID {@code null} if not found."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantBuilder.java",
    "type": "method",
    "name": "appendLong",
    "code": "public void appendLong(long l) {\n    checkCapacity(1 + 8);\n    if (l == (byte) l) {\n      writeBuffer[writePos++] = primitiveHeader(INT1);\n      writeLong(writeBuffer, writePos, l, 1);\n      writePos += 1;\n    } else if (l == (short) l) {\n      writeBuffer[writePos++] = primitiveHeader(INT2);\n      writeLong(writeBuffer, writePos, l, 2);\n      writePos += 2;\n    } else if (l == (int) l) {\n      writeBuffer[writePos++] = primitiveHeader(INT4);\n      writeLong(writeBuffer, writePos, l, 4);\n      writePos += 4;\n    } else {\n      writeBuffer[writePos++] = primitiveHeader(INT8);\n      writeLong(writeBuffer, writePos, l, 8);\n      writePos += 8;\n    }\n  }",
    "comment": "Append a long value to the variant builder. The actual used integer type depends on the value\nrange of the long value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java",
    "type": "method",
    "name": "postProcessTestInstance",
    "code": "public void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\t\t// @formatter:off\n\t\t\tfindAnnotatedFields(testInstance.getClass(), RegisterExtension.class, isCrystalBall).stream()\n\t\t\t\t.findFirst()\n\t\t\t\t.ifPresent(field -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmakeAccessible(field).set(testInstance, new CrystalBall(\"Outlook good\"));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\t\tthrow ExceptionUtils.throwAsUncheckedException(t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t// @formatter:on\n\t\t}",
    "comment": "Mimics a dependency injection framework such as Spring, Guice, CDI, etc.,\nwhere the instance of the extension registered via\n{@link RegisterExtension @RegisterExtension} is managed by the DI\nframework and injected into the test instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/Size.java",
    "type": "method",
    "name": "getRotatedSize",
    "code": "public static Size getRotatedSize(final Size size, final int rotation) {\n    if (rotation % 180 != 0) {\n      // The phone is portrait, therefore the camera is sideways and frame should be rotated.\n      return new Size(size.height, size.width);\n    }\n    return size;\n  }",
    "comment": "Rotate a size by the given number of degrees.\n@param size Size to rotate.\n@param rotation Degrees {0, 90, 180, 270} to rotate the size.\n@return Rotated size."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/CoreExtensions.java",
    "type": "method",
    "name": "CoreExtensions",
    "code": "public record CoreExtensions(Path source, List<CoreExtension> coreExtensions) {\n    public CoreExtensions(Path source, List<CoreExtension> coreExtensions) {\n        this.source = requireNonNull(source, \"source\");\n        this.coreExtensions = requireNonNull(coreExtensions, \"coreExtensions\");\n    }\n}",
    "comment": "Represents the list of core extensions configured at one source. The list is validated (are GA unique), but no\nother logic than that is applied.\n\n@since 4.0.0\n@param source The source file of core extensions, is never {@code null}.\n@param coreExtensions The configured core extensions, is never {@code null}. Contents of list is guaranteed to be unique by GA.\n\n@see Constants#MAVEN_PROJECT_EXTENSIONS\n@see Constants#MAVEN_USER_EXTENSIONS\n@see Constants#MAVEN_INSTALLATION_EXTENSIONS"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/session/HiveSessionImpl.java",
    "type": "method",
    "name": "acquire",
    "code": "protected synchronized void acquire(boolean userAccess) {\n    SessionState.setCurrentSessionState(sessionState);\n    if (userAccess) {\n      lastAccessTime = System.currentTimeMillis();\n    }\n  }",
    "comment": "Need to make sure that the this HiveServer2's session's SessionState is\nstored in the thread local for the handler thread."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/Execution.java",
    "type": "method",
    "name": "setGoals",
    "code": "public void setGoals(java.util.List<String> goals) {\n        this.goals = goals;\n    } // -- void setGoals( java.util.List )",
    "comment": "Set the goals to execute.\n\n@param goals a goals object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassUtils.java",
    "type": "method",
    "name": "nullSafeToString",
    "code": "public static String nullSafeToString(Function<? super Class<?>, ? extends String> mapper, Class<?>... classes) {\n\t\tPreconditions.notNull(mapper, \"Mapping function must not be null\");\n\n\t\tif (classes == null || classes.length == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn stream(classes).map(clazz -> clazz == null ? \"null\" : mapper.apply(clazz)).collect(joining(\", \"));\n\t}",
    "comment": "Generate a comma-separated list of mapped values for the supplied classes.\n\n<p>The values are generated by the supplied {@code mapper}\n(e.g., {@code Class::getName}, {@code Class::getSimpleName}, etc.), unless\na class reference is {@code null} in which case it will be mapped to\n{@code \"null\"}.\n\n@param mapper the mapper to use; never {@code null}\n@param classes the classes to map\n@return a comma-separated list of mapped values, or an empty string if\nthe supplied class array is {@code null} or empty\n@see #nullSafeToString(Class...)\n@see StringUtils#nullSafeToString(Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/DefaultLifecycles.java",
    "type": "method",
    "name": "lookupLifecycles",
    "code": "private Map<String, Lifecycle> lookupLifecycles() {\n        if (lookup == null) {\n            return customLifecycles != null ? customLifecycles : new HashMap<>();\n        }\n\n        try {\n            return registry != null\n                    ? registry.stream().collect(Collectors.toMap(lf -> lf.id(), lf -> new Lifecycle(registry, lf)))\n                    : Map.of();\n        } catch (LookupException e) {\n            throw new IllegalStateException(\"Unable to lookup lifecycles from the plexus container\", e);\n        }\n    }",
    "comment": "TODO: Remove the following code when maven-compat is gone\nThis code is here to ensure maven-compat's EmptyLifecycleExecutor keeps on working.\nLifecycles cannot be cached as extensions might add custom lifecycles later in the execution."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/DirectorySource.java",
    "type": "method",
    "name": "getUri",
    "code": "public final URI getUri() {\n\t\treturn getFile().toURI();\n\t}",
    "comment": "Get the {@link URI} for the source {@linkplain #getFile directory}.\n\n@return the source {@code URI}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/entity/Truck.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n    return \"Truck{ \" + super.toString() + \", \" + \"towingCapacity=\" + towingCapacity + '}';\n  }",
    "comment": "Overridden the toString method to specify the Vehicle object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginExecutionException.java",
    "type": "method",
    "name": "PluginExecutionException",
    "code": "public PluginExecutionException(MojoExecution mojoExecution, MavenProject project, String message) {\n        super(mojoExecution.getMojoDescriptor(), project, message);\n        this.mojoExecution = mojoExecution;\n    }",
    "comment": "Exception in the plugin manager."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "addColumn",
    "code": "static TableChange addColumn(String[] fieldNames, DataType dataType, boolean isNullable) {\n    return new AddColumn(fieldNames, dataType, isNullable, null, null, null);\n  }",
    "comment": "Create a TableChange for adding a column.\n<p>\nIf the field already exists, the change will result in an {@link IllegalArgumentException}.\nIf the new field is nested and its parent does not exist or is not a struct, the change will\nresult in an {@link IllegalArgumentException}.\n\n@param fieldNames field names of the new column\n@param dataType the new column's data type\n@param isNullable whether the new column can contain null\n@return a TableChange for the addition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/TypeDescriptor.java",
    "type": "method",
    "name": "getColumnSize",
    "code": "public Integer getColumnSize() {\n    if (type.isNumericType()) {\n      return getPrecision();\n    }\n    switch (type) {\n    case STRING_TYPE:\n    case BINARY_TYPE:\n      return Integer.MAX_VALUE;\n    case CHAR_TYPE:\n    case VARCHAR_TYPE:\n      return typeQualifiers.getCharacterMaximumLength();\n    case DATE_TYPE:\n      return 10;\n    case TIMESTAMP_TYPE:\n      return 29;\n    default:\n      return null;\n    }\n  }",
    "comment": "The column size for this type.\nFor numeric data this is the maximum precision.\nFor character data this is the length in characters.\nFor datetime types this is the length in characters of the String representation\n(assuming the maximum allowed precision of the fractional seconds component).\nFor binary data this is the length in bytes.\nNull is returned for data types where the column size is not applicable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeArrayWriter.java",
    "type": "method",
    "name": "setNull8Bytes",
    "code": "public void setNull8Bytes(int ordinal) {\n    setNullBit(ordinal);\n    writeLong(getElementOffset(ordinal), 0);\n  }",
    "comment": "put zero into the corresponding field when set null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "MapIteratorWithKeyIndex",
    "code": "private MapIteratorWithKeyIndex() {\n      this.numRecords = numValues;\n      this.loc = new Location();\n    }",
    "comment": "The index in `longArray` where the key is stored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "reason",
    "code": "public static Condition<Event> reason(String expectedReason) {\n\t\treturn new Condition<>(byPayload(String.class, isEqual(expectedReason)), \"event with reason '%s'\",\n\t\t\texpectedReason);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link String} that is equal to the supplied value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setByteArray",
    "code": "private void setByteArray(byte[] value) {\n    byteArrayData =  value;\n  }",
    "comment": "Sets the byte array `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/serialized-lob/src/main/java/com/iluwatar/slob/lob/Plant.java",
    "type": "method",
    "name": "createObjectFromXml",
    "code": "public void createObjectFromXml(Node node) {\n    NamedNodeMap attributes = node.getAttributes();\n    name = attributes.getNamedItem(\"name\").getNodeValue();\n    type = attributes.getNamedItem(\"type\").getNodeValue();\n  }",
    "comment": "Parses the Plant Object from the input XML Node.\n\n@param node the XML Node from which the Animal Object is to be parsed"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/runner/BaseTestRunner.java",
    "type": "method",
    "name": "startTest",
    "code": "public synchronized void startTest(Test test) {\n        testStarted(test.toString());\n    }",
    "comment": "Base class for all test runners.\nThis class was born live on stage in Sardinia during XP2000."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "setAllNull",
    "code": "public final void setAllNull() {\n    isAllNull = true;\n  }",
    "comment": "Marks this column only contains null values."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-executor/src/test/java/org/apache/maven/cling/executor/MavenExecutorTestSupport.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String... args) {\n                    System.out.println(\"Hello World!\");\n                }",
    "comment": "Note: we do not validate ANSI as Maven3 is weird in this respect (thinks is color but is not)\nassertTrue(stdout.toString().contains(\"[\\u001B[\"), \"No ANSI codes present\");"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "setCancelled",
    "code": "void setCancelled(boolean value) {\n    if (cancellationFlagHandle == 0) {\n      throw new IllegalStateException(\n          \"Cannot cancel the inference. Have you called InterpreterApi.Options.setCancellable?\");\n    }\n    setCancelled(interpreterHandle, cancellationFlagHandle, value);\n  }",
    "comment": "Sets internal cancellation flag. If it's true, the interpreter will try to interrupt any\ninvocation between ops."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-settings-builder/src/main/java/org/apache/maven/settings/building/StringSettingsSource.java",
    "type": "method",
    "name": "StringSettingsSource",
    "code": "public StringSettingsSource(CharSequence settings, String location) {\n        super(settings, location);\n    }",
    "comment": "Creates a new settings source backed by the specified string.\n\n@param settings The settings' string representation, may be empty or {@code null}.\n@param location The location to report for this use, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/test/org/apache/spark/Java8RDDAPISuite.java",
    "type": "method",
    "name": "mapsFromPairsToPairs",
    "code": "public void mapsFromPairsToPairs() {\n    List<Tuple2<Integer, String>> pairs = Arrays.asList(\n      new Tuple2<>(1, \"a\"),\n      new Tuple2<>(2, \"aa\"),\n      new Tuple2<>(3, \"aaa\")\n    );\n    JavaPairRDD<Integer, String> pairRDD = sc.parallelizePairs(pairs);\n\n    JavaPairRDD<String, Integer> swapped =\n      pairRDD.flatMapToPair(x -> Collections.singletonList(x.swap()).iterator());\n    swapped.collect();\n\n    pairRDD.map(Tuple2::swap).collect();\n  }",
    "comment": "Regression test for SPARK-668:\nThere was never a bug here, but it's worth testing:"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java",
    "type": "method",
    "name": "getFragmentSeparator",
    "code": "private static String getFragmentSeparator(Class<?> testClass, List<Class<?>> enclosingInstanceTypes) {\n\t\t\treturn findIndicativeSentencesGeneration(testClass, enclosingInstanceTypes)//\n\t\t\t\t\t.map(IndicativeSentencesGeneration::separator)//\n\t\t\t\t\t.orElse(IndicativeSentencesGeneration.DEFAULT_SEPARATOR);\n\t\t}",
    "comment": "Get the sentence fragment separator.\n\n<p>If {@link IndicativeSentencesGeneration @IndicativeSentencesGeneration}\nis present (searching enclosing classes if not found locally), the\nconfigured {@link IndicativeSentencesGeneration#separator() separator}\nwill be used. Otherwise, {@link IndicativeSentencesGeneration#DEFAULT_SEPARATOR}\nwill be used.\n\n@param testClass the test class to search on for {@code @IndicativeSentencesGeneration}\n@param enclosingInstanceTypes the runtime types of the enclosing\ninstances; never {@code null}\n@return the sentence fragment separator"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java",
    "type": "method",
    "name": "removeWithTypeSafety",
    "code": "void removeWithTypeSafety() {\n\t\t\tInteger key = 42;\n\t\t\tString value = \"enigma\";\n\t\t\tstore.put(namespace, key, value);\n\n\t\t\tString removedValue = store.remove(namespace, key, String.class);\n\t\t\tassertEquals(value, removedValue);\n\t\t\tassertNull(store.get(namespace, key));\n\t\t}",
    "comment": "The fact that we can declare this as a String suffices for testing the required type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java",
    "type": "method",
    "name": "runInferSchemaExample",
    "code": "private static void runInferSchemaExample(SparkSession spark) {\n    JavaRDD<Person> peopleRDD = spark.read()\n      .textFile(\"examples/src/main/resources/people.txt\")\n      .javaRDD()\n      .map(line -> {\n        String[] parts = line.split(\",\");\n        Person person = new Person();\n        person.setName(parts[0]);\n        person.setAge(Integer.parseInt(parts[1].trim()));\n        return person;\n      });\n\n    Dataset<Row> peopleDF = spark.createDataFrame(peopleRDD, Person.class);\n    peopleDF.createOrReplaceTempView(\"people\");\n\n    Dataset<Row> teenagersDF = spark.sql(\"SELECT name FROM people WHERE age BETWEEN 13 AND 19\");\n\n    Encoder<String> stringEncoder = Encoders.STRING();\n    Dataset<String> teenagerNamesByIndexDF = teenagersDF.map(\n        (MapFunction<Row, String>) row -> \"Name: \" + row.getString(0),\n        stringEncoder);\n    teenagerNamesByIndexDF.show();\n\n    Dataset<String> teenagerNamesByFieldDF = teenagersDF.map(\n        (MapFunction<Row, String>) row -> \"Name: \" + row.<String>getAs(\"name\"),\n        stringEncoder);\n    teenagerNamesByFieldDF.show();\n  }",
    "comment": "$example on:schema_inferring$\nCreate an RDD of Person objects from a text file\nApply a schema to an RDD of JavaBeans to get a DataFrame\nRegister the DataFrame as a temporary view\nSQL statements can be run by using the sql methods provided by spark\nThe columns of a row in the result can be accessed by field index\n+------------+\n|       value|\n+------------+\n|Name: Justin|\n+------------+\nor by field name\n+------------+\n|       value|\n+------------+\n|Name: Justin|\n+------------+\n$example off:schema_inferring$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileSelector.java",
    "type": "method",
    "name": "addProfileActivator",
    "code": "public DefaultProfileSelector addProfileActivator(ProfileActivator profileActivator) {\n        if (profileActivator != null) {\n            activators.add(profileActivator);\n        }\n        return this;\n    }",
    "comment": "Calculates the active profiles among a given collection of profiles.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/runner/JUnitPlatformRunnerTests.java",
    "type": "method",
    "name": "requestsClassSelectorForAnnotatedClassWhenNoAdditionalAnnotationsArePresent",
    "code": "void requestsClassSelectorForAnnotatedClassWhenNoAdditionalAnnotationsArePresent() {\n\n\t\t\tclass TestCase {\n\t\t\t}\n\n\t\t\tvar request = instantiateRunnerAndCaptureGeneratedRequest(TestCase.class);\n\n\t\t\tvar selectors = request.getSelectorsByType(ClassSelector.class);\n\t\t\tassertThat(selectors).hasSize(1);\n\t\t\tvar classSelector = getOnlyElement(selectors);\n\t\t\tassertEquals(TestCase.class, classSelector.getJavaClass());\n\t\t}",
    "comment": "Tests for the {@link JUnitPlatform} runner.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertTimeoutAssertionsTests.java",
    "type": "method",
    "name": "assertTimeoutForExecutableThatCompletesBeforeTheTimeout",
    "code": "void assertTimeoutForExecutableThatCompletesBeforeTheTimeout() {\n\t\tchanged.get().set(false);\n\t\tassertTimeout(ofMillis(500), () -> changed.get().set(true));\n\t\tassertTrue(changed.get().get(), \"should have executed in the same thread\");\n\t\tassertTimeout(ofMillis(500), nix, \"message\");\n\t\tassertTimeout(ofMillis(500), nix, () -> \"message\");\n\t}",
    "comment": "Unit tests for {@link AssertTimeout}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assumptions.java",
    "type": "method",
    "name": "abort",
    "code": "public static <V> V abort() {\n\t\tthrow new TestAbortedException();\n\t}",
    "comment": "<em>Abort</em> the test <em>without</em> a message.\n\n<p>Although aborting with an explicit message is recommended, this may be\nuseful when maintaining legacy code.\n\n<p>See Javadoc for {@link #abort(String)} for an explanation of this\nmethod's generic return type {@code V}.\n\n@throws TestAbortedException always\n@since 5.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/ArtifactTransferEvent.java",
    "type": "method",
    "name": "setRequestType",
    "code": "public void setRequestType(final int requestType) {\n        switch (requestType) {\n            case REQUEST_PUT:\n                break;\n            case REQUEST_GET:\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal request type: \" + requestType);\n        }\n\n        this.requestType = requestType;\n    }",
    "comment": "Sets the request type\n\n@param requestType The requestType to set.\nThe Request type value should be either\n<code>TransferEvent.REQUEST_GET</code> or <code>TransferEvent.REQUEST_PUT</code>.\n@throws IllegalArgumentException when"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/BlockStoreClient.java",
    "type": "method",
    "name": "removeShuffleMerge",
    "code": "public boolean removeShuffleMerge(String host, int port, int shuffleId, int shuffleMergeId) {\n    throw new UnsupportedOperationException();\n  }",
    "comment": "Remove the shuffle merge data in shuffle services\n\n@param host the host of the remote node.\n@param port the port of the remote node.\n@param shuffleId shuffle id.\n@param shuffleMergeId shuffle merge id.\n\n@since 3.4.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, Double actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals((Double) expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-yarn/src/main/java/org/apache/spark/network/yarn/YarnShuffleServiceMetrics.java",
    "type": "method",
    "name": "if",
    "code": "MetricsRecordBuilder metricsRecordBuilder, String name, Metric metric) {\n\n    if (metric instanceof Timer t) {\n      // Timer records both the operations count and delay\n      // Snapshot inside the Timer provides the information for the operation delay\n      Snapshot snapshot = t.getSnapshot();\n      metricsRecordBuilder\n        .addCounter(new ShuffleServiceMetricsInfo(name + \"_count\", \"Count of timer \" + name),\n          t.getCount())\n        .addGauge(\n          new ShuffleServiceMetricsInfo(name + \"_rate15\", \"15 minute rate of timer \" + name),\n          t.getFifteenMinuteRate())\n        .addGauge(\n          new ShuffleServiceMetricsInfo(name + \"_rate5\", \"5 minute rate of timer \" + name),\n          t.getFiveMinuteRate())\n        .addGauge(\n          new ShuffleServiceMetricsInfo(name + \"_rate1\", \"1 minute rate of timer \" + name),\n          t.getOneMinuteRate())\n        .addGauge(new ShuffleServiceMetricsInfo(name + \"_rateMean\", \"Mean rate of timer \" + name),\n          t.getMeanRate())\n        .addGauge(\n          getShuffleServiceMetricsInfoForGenericValue(name, \"max\"), snapshot.getMax())\n        .addGauge(\n          getShuffleServiceMetricsInfoForGenericValue(name, \"min\"), snapshot.getMin())\n        .addGauge(\n          getShuffleServiceMetricsInfoForGenericValue(name, \"mean\"), snapshot.getMean())\n        .addGauge(\n          getShuffleServiceMetricsInfoForGenericValue(name, \"stdDev\"), snapshot.getStdDev());\n      for (int percentileThousands : new int[] { 10, 50, 250, 500, 750, 950, 980, 990, 999 }) {\n        metricsRecordBuilder.addGauge(\n          getShuffleServiceMetricsInfoForGenericValue(name, percentileStr),\n          snapshot.getValue(percentileThousands / 1000.0));\n      }\n    } else if (metric instanceof Meter m) {\n      metricsRecordBuilder\n        .addCounter(new ShuffleServiceMetricsInfo(name + \"_count\", \"Count of meter \" + name),\n          m.getCount())\n        .addGauge(\n          new ShuffleServiceMetricsInfo(name + \"_rate15\", \"15 minute rate of meter \" + name),\n          m.getFifteenMinuteRate())\n        .addGauge(\n          new ShuffleServiceMetricsInfo(name + \"_rate5\", \"5 minute rate of meter \" + name),\n          m.getFiveMinuteRate())\n        .addGauge(\n          new ShuffleServiceMetricsInfo(name + \"_rate1\", \"1 minute rate of meter \" + name),\n          m.getOneMinuteRate())\n        .addGauge(new ShuffleServiceMetricsInfo(name + \"_rateMean\", \"Mean rate of meter \" + name),\n          m.getMeanRate());\n    } else if (metric instanceof Gauge gauge) {\n      final Object gaugeValue = gauge.getValue();\n      if (gaugeValue instanceof Integer integer) {\n        metricsRecordBuilder.addGauge(getShuffleServiceMetricsInfoForGauge(name), integer);\n      } else if (gaugeValue instanceof Long longVal) {\n        metricsRecordBuilder.addGauge(getShuffleServiceMetricsInfoForGauge(name), longVal);\n      } else if (gaugeValue instanceof Float floatVal) {\n        metricsRecordBuilder.addGauge(getShuffleServiceMetricsInfoForGauge(name), floatVal);\n      } else if (gaugeValue instanceof Double doubleVal) {\n        metricsRecordBuilder.addGauge(getShuffleServiceMetricsInfoForGauge(name), doubleVal);\n      } else {\n        throw new IllegalStateException(\n                \"Not supported class type of metric[\" + name + \"] for value \" + gaugeValue);\n      }\n    } else if (metric instanceof Counter c) {\n      long counterValue = c.getCount();\n      metricsRecordBuilder.addGauge(getShuffleServiceMetricsInfoForCounter(name), counterValue);\n    }\n  }",
    "comment": "The metric types used in\n{@link org.apache.spark.network.shuffle.ExternalBlockHandler.ShuffleMetrics}.\nVisible for testing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/LegacyReportingUtils.java",
    "type": "method",
    "name": "getClassName",
    "code": "public static String getClassName(TestPlan testPlan, TestIdentifier testIdentifier) {\n\t\tPreconditions.notNull(testPlan, \"testPlan must not be null\");\n\t\tPreconditions.notNull(testIdentifier, \"testIdentifier must not be null\");\n\t\tfor (TestIdentifier current = testIdentifier; current != null; current = getParent(testPlan, current)) {\n\t\t\tClassSource source = getClassSource(current);\n\t\t\tif (source != null) {\n\t\t\t\treturn source.getClassName();\n\t\t\t}\n\t\t}\n\t\treturn getParentLegacyReportingName(testPlan, testIdentifier);\n\t}",
    "comment": "Get the class name for the supplied {@link TestIdentifier} using the\nsupplied {@link TestPlan}.\n\n<p>This implementation attempts to find the closest test identifier with\na {@link ClassSource} by traversing the hierarchy upwards towards the\nroot starting with the supplied test identifier. In case no such source\nis found, it falls back to using the parent's\n{@linkplain TestIdentifier#getLegacyReportingName legacy reporting name}.\n\n@param testPlan the test plan that contains the {@code TestIdentifier};\nnever {@code null}\n@param testIdentifier the identifier to determine the class name for;\nnever {@code null}\n@see TestIdentifier#getLegacyReportingName"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/TypedArgumentConverter.java",
    "type": "method",
    "name": "TypedArgumentConverter",
    "code": "protected TypedArgumentConverter(Class<S> sourceType, Class<T> targetType) {\n\t\tthis.sourceType = Preconditions.notNull(sourceType, \"sourceType must not be null\");\n\t\tthis.targetType = Preconditions.notNull(targetType, \"targetType must not be null\");\n\t}",
    "comment": "Create a new {@code TypedArgumentConverter}.\n@param targetType the type of the target object to create from the source;\nnever {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassNamePatternFilterUtils.java",
    "type": "method",
    "name": "excludeMatchingClassNames",
    "code": "public static Predicate<String> excludeMatchingClassNames(String patterns) {\n\t\treturn matchingClasses(patterns, Function.identity(), FilterType.EXCLUDE);\n\t}",
    "comment": "Create a {@link Predicate} that can be used to exclude (i.e., filter out)\nfully qualified class names matching any of the supplied patterns.\n\n@param patterns a comma-separated list of patterns"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java",
    "type": "method",
    "name": "generateDisplayNameForMethod",
    "code": "default String generateDisplayNameForMethod(Class<?> testClass, Method testMethod) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"Implement generateDisplayNameForMethod(List<Class<?>>, Class<?>, Method) instead\");\n\t}",
    "comment": "Generate a display name for the given method.\n\n<p>If this method returns {@code null}, the default display name\ngenerator will be used instead.\n\n@implNote The class instance supplied as {@code testClass} may differ from\nthe class returned by {@code testMethod.getDeclaringClass()} &mdash; for\nexample, when a test method is inherited from a superclass.\n\n@param testClass the class the test method is invoked on; never {@code null}\n@param testMethod method to generate a display name for; never {@code null}\n@return the display name for the test; never blank\n@deprecated in favor of {@link #generateDisplayNameForMethod(List, Class, Method)}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "lowercaseEndsWith",
    "code": "public static boolean lowercaseEndsWith(final UTF8String target, final UTF8String pattern) {\n    // Fast path for ASCII-only strings.\n    if (target.isFullAscii() && pattern.isFullAscii()) {\n      return target.toLowerCase().endsWith(pattern.toLowerCase());\n    }\n    // Slow path for non-ASCII strings.\n    return CollationAwareUTF8String.lowercaseMatchUntil(target, lowerCaseCodePointsSlow(pattern),\n      target.numChars());\n  }",
    "comment": "Checks whether the target string ends with the pattern string, with respect to the UTF8_LCASE\ncollation. This method generally works with respect to code-point based comparison logic.\n\n@param target the string to be searched in\n@param pattern the string to be searched for\n@return whether the target string ends with the pattern string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java",
    "type": "method",
    "name": "restrict",
    "code": "public VersionRange restrict(VersionRange restriction) {\n        List<Restriction> r1 = this.restrictions;\n        List<Restriction> r2 = restriction.restrictions;\n        List<Restriction> restrictions;\n\n        if (r1.isEmpty() || r2.isEmpty()) {\n            restrictions = Collections.emptyList();\n        } else {\n            restrictions = Collections.unmodifiableList(intersection(r1, r2));\n        }\n\n        ArtifactVersion version = null;\n        if (restrictions.size() > 0) {\n            for (Restriction r : restrictions) {\n                if (recommendedVersion != null && r.containsVersion(recommendedVersion)) {\n                    // if we find the original, use that\n                    version = recommendedVersion;\n                    break;\n                } else if (version == null\n                        && restriction.getRecommendedVersion() != null\n                        && r.containsVersion(restriction.getRecommendedVersion())) {\n                    // use this if we can, but prefer the original if possible\n                    version = restriction.getRecommendedVersion();\n                }\n            }\n        }\n        // Either the original or the specified version ranges have no restrictions\n        else if (recommendedVersion != null) {\n            // Use the original recommended version since it exists\n            version = recommendedVersion;\n        } else if (restriction.recommendedVersion != null) {\n            // Use the recommended version from the specified VersionRange since there is no\n            // original recommended version\n            version = restriction.recommendedVersion;\n        }\n        /* TODO should throw this immediately, but need artifact\n                else\n                {\n                    throw new OverConstrainedVersionException( \"Restricting incompatible version ranges\" );\n                }\n        */\n\n        return new VersionRange(version, restrictions);\n    }",
    "comment": "Creates and returns a new <code>VersionRange</code> that is a restriction of this\nversion range and the specified version range.\n<p>\nNote: Precedence is given to the recommended version from this version range over the\nrecommended version from the specified version range.\n</p>\n\n@param restriction the <code>VersionRange</code> that will be used to restrict this version\nrange.\n@return the <code>VersionRange</code> that is a restriction of this version range and the\nspecified version range.\n<p>\nThe restrictions of the returned version range will be an intersection of the restrictions\nof this version range and the specified version range if both version ranges have\nrestrictions. Otherwise, the restrictions on the returned range will be empty.\n</p>\n<p>\nThe recommended version of the returned version range will be the recommended version of\nthis version range, provided that ranges falls within the intersected restrictions. If\nthe restrictions are empty, this version range's recommended version is used if it is not\n<code>null</code>. If it is <code>null</code>, the specified version range's recommended\nversion is used (provided it is non-<code>null</code>). If no recommended version can be\nobtained, the returned version range's recommended version is set to <code>null</code>.\n</p>\n@throws NullPointerException if the specified <code>VersionRange</code> is\n<code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Long> create(long[][][][][][] data) {\n    return Tensor.create(data, Long.class);\n  }",
    "comment": "Creates a rank-6 tensor of {@code long} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Integer unexpected, Integer actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/Murmur3_x86_32.java",
    "type": "method",
    "name": "hashUnsafeWords",
    "code": "public static int hashUnsafeWords(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes % 8 == 0): \"lengthInBytes must be a multiple of 8 (word-aligned)\";\n    int h1 = hashBytesByInt(base, offset, lengthInBytes, seed);\n    return fmix(h1, lengthInBytes);\n  }",
    "comment": "This is based on Guava's `Murmur32_Hasher.processRemaining(ByteBuffer)` method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/JavaTC.java",
    "type": "method",
    "name": "generateGraph",
    "code": "static List<Tuple2<Integer, Integer>> generateGraph() {\n    Set<Tuple2<Integer, Integer>> edges = new HashSet<>(numEdges);\n    while (edges.size() < numEdges) {\n      int from = rand.nextInt(numVertices);\n      int to = rand.nextInt(numVertices);\n      Tuple2<Integer, Integer> e = new Tuple2<>(from, to);\n      if (from != to) {\n        edges.add(e);\n      }\n    }\n    return new ArrayList<>(edges);\n  }",
    "comment": "Transitive closure on a graph, implemented in Java.\nUsage: JavaTC [partitions]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "attribute",
    "code": "public String attribute(@Nonnull String name) {\n                return attributes.get(name);\n            }",
    "comment": "Validation and normalization from the original constructor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/CommonsCliOptions.java",
    "type": "method",
    "name": "CLIManager",
    "code": "protected CLIManager() {\n            options = new org.apache.commons.cli.Options();\n            prepareOptions(options);\n        }",
    "comment": "Not an Option: used only for early detection, when CLI args may not be even parsed\nparameters handled by script\ndeprecated ones"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/AssumptionViolatedException.java",
    "type": "method",
    "name": "AssumptionViolatedException",
    "code": "public AssumptionViolatedException(String message, Throwable t) {\n        super(message, t);\n    }",
    "comment": "An assumption exception with the given message and a cause."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/command-query-responsibility-segregation/src/main/java/com/iluwatar/cqrs/util/HibernateUtil.java",
    "type": "method",
    "name": "buildSessionFactory",
    "code": "private static SessionFactory buildSessionFactory() {\n\n    // configures settings from hibernate.cfg.xml\n    final var registry = new StandardServiceRegistryBuilder().configure().build();\n    try {\n      return new MetadataSources(registry).buildMetadata().buildSessionFactory();\n    } catch (Exception ex) {\n      StandardServiceRegistryBuilder.destroy(registry);\n      LOGGER.error(\"Initial SessionFactory creation failed.\", ex);\n      throw new ExceptionInInitializerError(ex);\n    }\n  }",
    "comment": "This class simply returns one instance of {@link SessionFactory} initialized when the application\nis started."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/PreInterruptThreadDumpPrinter.java",
    "type": "method",
    "name": "beforeThreadInterrupt",
    "code": "public void beforeThreadInterrupt(PreInterruptContext preInterruptContext, ExtensionContext extensionContext) {\n\n\t\tMap<Thread, StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"Thread \");\n\t\tappendThreadName(sb, preInterruptContext.getThreadToInterrupt());\n\t\tsb.append(\" will be interrupted.\");\n\t\tsb.append(NL);\n\n\t\tfor (Map.Entry<Thread, StackTraceElement[]> entry : stackTraces.entrySet()) {\n\t\t\tThread thread = entry.getKey();\n\t\t\tStackTraceElement[] stack = entry.getValue();\n\t\t\tif (stack.length > 0) {\n\t\t\t\tsb.append(NL);\n\t\t\t\tappendThreadName(sb, thread);\n\t\t\t\tfor (StackTraceElement stackTraceElement : stack) {\n\t\t\t\t\tsb.append(NL);\n\t\t\t\t\t//Do the same prefix as java.lang.Throwable.printStackTrace(java.lang.Throwable.PrintStreamOrWriter)\n\t\t\t\t\tsb.append(\"\\tat \");\n\t\t\t\t\tsb.append(stackTraceElement.toString());\n\n\t\t\t\t}\n\t\t\t\tsb.append(NL);\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(sb);\n\t}",
    "comment": "The default implementation for {@link PreInterruptCallback},\nwhich will print the stacks of all {@link Thread}s to {@code System.out}.\n\n<p>Note: This is disabled by default, and must be enabled with\n{@link Constants#EXTENSIONS_TIMEOUT_THREAD_DUMP_ENABLED_PROPERTY_NAME}\n\n@since 5.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/LevelDB.java",
    "type": "method",
    "name": "db",
    "code": "DB db() {\n    DB _db = this._db.get();\n    if (_db == null) {\n      throw new IllegalStateException(\"DB is closed.\");\n    }\n    return _db;\n  }",
    "comment": "Try to avoid use-after close since that has the tendency of crashing the JVM. This doesn't\nprevent methods that retrieved the instance from using it after close, but hopefully will\ncatch most cases; otherwise, we'll need some kind of locking."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultLifecyclePluginAnalyzer.java",
    "type": "method",
    "name": "lookupLifecycleMapping",
    "code": "private LifecycleMapping lookupLifecycleMapping(final String packaging) {\n        return lookup.lookupOptional(LifecycleMapping.class, packaging).orElse(null);\n    }",
    "comment": "Performs a lookup using Plexus API to make sure we can look up only \"visible\" (see Maven classloading) components\nfrom current module and for example not extensions coming from other modules."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/PhaseComparator.java",
    "type": "method",
    "name": "compare",
    "code": "public int compare(String o1, String o2) {\n        PhaseId p1 = PhaseId.of(o1);\n        PhaseId p2 = PhaseId.of(o2);\n        int i1 = lifecyclePhases.indexOf(p1.executionPoint().prefix() + p1.phase());\n        int i2 = lifecyclePhases.indexOf(p2.executionPoint().prefix() + p2.phase());\n        if (i1 == -1 && i2 == -1) {\n            return 0;\n        }\n        if (i1 == -1) {\n            return 1;\n        }\n        if (i2 == -1) {\n            return -1;\n        }\n        int rv = Integer.compare(i1, i2);\n        if (rv != 0) {\n            return rv;\n        }\n        return Integer.compare(p1.priority(), p2.priority());\n    }",
    "comment": "unknown phases, leave in existing order\nsecond one is known, so it comes first\nfirst one is known, so it comes first\nsame execution point, now compare priorities"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/cache/AbstractRequestCache.java",
    "type": "method",
    "name": "for",
    "code": "List<REQ> reqs, Function<List<REQ>, List<REP>> supplier) {\n        final Map<REQ, Object> nonCachedResults = new HashMap<>();\n        List<RequestResult<REQ, REP>> allResults = new ArrayList<>(reqs.size());\n\n        Function<REQ, REP> individualSupplier = req -> {\n            synchronized (nonCachedResults) {\n                while (!nonCachedResults.containsKey(req)) {\n                    try {\n                        nonCachedResults.wait();\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                        throw new RuntimeException(e);\n                    }\n                }\n                Object val = nonCachedResults.get(req);\n                if (val instanceof CachingSupplier.AltRes altRes) {\n                    uncheckedThrow(altRes.throwable);\n                }\n                return (REP) val;\n            }\n        };\n\n        List<CachingSupplier<REQ, REP>> suppliers = new ArrayList<>(reqs.size());\n        List<REQ> nonCached = new ArrayList<>();\n        for (REQ req : reqs) {\n            CachingSupplier<REQ, REP> cs = doCache(req, individualSupplier);\n            suppliers.add(cs);\n            if (cs.getValue() == null) {\n                nonCached.add(req);\n            }\n        }\n\n        if (!nonCached.isEmpty()) {\n            synchronized (nonCachedResults) {\n                try {\n                    List<REP> reps = supplier.apply(nonCached);\n                    for (int i = 0; i < reps.size(); i++) {\n                        nonCachedResults.put(nonCached.get(i), reps.get(i));\n                    }\n                } catch (MavenExecutionException e) {\n                    // If batch request fails, mark all non-cached requests as failed\n                    for (REQ req : nonCached) {\n                        nonCachedResults.put(\n                                req, new CachingSupplier.AltRes(e.getCause())); // Mark as processed but failed\n                    }\n                } finally {\n                    nonCachedResults.notifyAll();\n                }\n            }\n        }\n\n        // Collect results in original order\n        boolean hasFailures = false;\n        for (int i = 0; i < reqs.size(); i++) {\n            REQ req = reqs.get(i);\n            CachingSupplier<REQ, REP> cs = suppliers.get(i);\n            try {\n                REP value = cs.apply(req);\n                allResults.add(new RequestResult<>(req, value, null));\n            } catch (Throwable t) {\n                hasFailures = true;\n                allResults.add(new RequestResult<>(req, null, t));\n            }\n        }\n\n        if (hasFailures) {\n            throw new BatchRequestException(\"One or more requests failed\", allResults);\n        }\n\n        return allResults.stream().map(RequestResult::result).toList();\n    }",
    "comment": "Executes and optionally caches a batch of requests.\n<p>\nThis method processes a list of requests, utilizing caching where applicable and executing\nonly the non-cached requests using the provided supplier function.\n</p>\n<p>\nIf any request in the batch fails, a {@link BatchRequestException} is thrown, containing\ndetails of all failed requests.\n</p>\n\n@param <REQ> The request type\n@param <REP> The response type\n@param reqs List of requests to process\n@param supplier Function to execute the batch of requests\n@return List of results corresponding to the input requests\n@throws BatchRequestException if any request in the batch fails"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setLong",
    "code": "public void setLong(long value) {\n    longData = value;\n  }",
    "comment": "Sets the long `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/TypeDescriptor.java",
    "type": "method",
    "name": "getPrecision",
    "code": "public Integer getPrecision() {\n    if (this.type == Type.DECIMAL_TYPE) {\n      return typeQualifiers.getPrecision();\n    }\n    return this.type.getMaxPrecision();\n  }",
    "comment": "Maximum precision for numeric types.\nReturns null for non-numeric types.\n@return"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/injection/sample/LongParameterResolver.java",
    "type": "method",
    "name": "supportsParameter",
    "code": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\t// Exact match?\n\t\tif (parameterContext.getParameter().getType() == Long.class) {\n\t\t\treturn true;\n\t\t}\n\n\t\tType typeInMethod = parameterContext.getParameter().getParameterizedType();\n\n\t\t// Type variables in parameterized class\n\t\tfor (TypeVariable<?> typeVariable : parameterContext.getDeclaringExecutable().getDeclaringClass().getTypeParameters()) {\n\t\t\tboolean namesMatch = typeInMethod.getTypeName().equals(typeVariable.getName());\n\t\t\tboolean typesAreCompatible = typeVariable.getBounds().length == 1 && //\n\t\t\t\t\ttypeVariable.getBounds()[0] instanceof Class && //\n\t\t\t\t\t((Class<?>) typeVariable.getBounds()[0]).isAssignableFrom(Long.class);\n\n\t\t\tif (namesMatch && typesAreCompatible) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\n\t}",
    "comment": "Example {@link ParameterResolver} that always resolves a {@link Long}\nparameter to {@code 42}.\n\n<p>This resolver also <em>attempts</em> to support generic parameter type\ndeclarations if the generic type is defined at the class level in a\nsuperclass or interface (extended or implemented by the test class) and\nis assignable from {@link Long}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Computer.java",
    "type": "method",
    "name": "Suite",
    "code": "return new Suite(new RunnerBuilder() {\n        }, classes) {\n            @Override\n            protected String getName() {\n                /*\n                 * #1320 The generated suite is not based on a real class so\n                 * only a 'null' description can be generated from it. This name\n                 * will be overridden here.\n                 */\n                return \"classes\";\n            }\n        };",
    "comment": "Create a suite for {@code classes}, building Runners with {@code builder}.\nThrows an InitializationError if Runner construction fails"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/testhelper/java/org/tensorflow/lite/TestHelper.java",
    "type": "method",
    "name": "getLastNativeInferenceDurationNanoseconds",
    "code": "public static Long getLastNativeInferenceDurationNanoseconds(Interpreter interpreter) {\n    if (interpreter != null && interpreter.wrapper != null) {\n      return interpreter.wrapper.getLastNativeInferenceDurationNanoseconds();\n    } else {\n      throw new IllegalArgumentException(\"Interpreter has not initialized; Failed to get latency.\");\n    }\n  }",
    "comment": "Gets the last inference duration in nanoseconds. It returns null if there is no previous\ninference run or the last inference run failed.\n\n@param interpreter an instance of {@code Interpreter}. If it is not initialized, an {@code\nIllegalArgumentException} will be thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom/java/com/example/android/persistence/migrations/UserDaoTest.java",
    "type": "method",
    "name": "insertAndGetUser",
    "code": "public void insertAndGetUser() {\n        mDatabase.userDao().insertUser(USER);\n\n        User dbUser = mDatabase.userDao().getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), USER.getUserName());\n    }",
    "comment": "When inserting a new user in the data source\nThe user can be retrieved"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/extensions/RandomNumberExtension.java",
    "type": "method",
    "name": "supportsParameter",
    "code": "public boolean supportsParameter(ParameterContext pc, ExtensionContext ec) {\n\t\treturn pc.isAnnotated(Random.class) && isInteger(pc.getParameter().getType());\n\t}",
    "comment": "Determine if the parameter is annotated with {@code @Random} and can be\nassigned an integer value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(float[] expecteds, float[] actuals, float delta) {\n        assertArrayEquals(null, expecteds, actuals, delta);\n    }",
    "comment": "Asserts that two float arrays are equal. If they are not, an\n{@link AssertionError} is thrown.\n\n@param expecteds float array with expected values.\n@param actuals float array with actual values\n@param delta the maximum delta between <code>expecteds[i]</code> and\n<code>actuals[i]</code> for which both numbers are still\nconsidered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/Interpreter.java",
    "type": "method",
    "name": "Interpreter",
    "code": "public Interpreter(@NonNull ByteBuffer byteBuffer) {\n    this(byteBuffer, /* options= */ null);\n  }",
    "comment": "Initializes an {@code Interpreter} with a {@code ByteBuffer} of a model file.\n\n<p>The ByteBuffer should not be modified after the construction of a {@code Interpreter}. The\n{@code ByteBuffer} can be either a {@code MappedByteBuffer} that memory-maps a model file, or a\ndirect {@code ByteBuffer} of nativeOrder() that contains the bytes content of a model.\n\n@throws IllegalArgumentException if {@code byteBuffer} is not a {@code MappedByteBuffer} nor a\ndirect {@code ByteBuffer} of nativeOrder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/Murmur3_x86_32.java",
    "type": "method",
    "name": "hashUnsafeBytes",
    "code": "public static int hashUnsafeBytes(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes >= 0): \"lengthInBytes cannot be negative\";\n    int lengthAligned = lengthInBytes - lengthInBytes % 4;\n    int h1 = hashBytesByInt(base, offset, lengthAligned, seed);\n    for (int i = lengthAligned; i < lengthInBytes; i++) {\n      int halfWord = Platform.getByte(base, offset + i);\n      int k1 = mixK1(halfWord);\n      h1 = mixH1(h1, k1);\n    }\n    return fmix(h1, lengthInBytes);\n  }",
    "comment": "This is not compatible with original and another implementations.\nBut remain it for backward compatibility for the components existing before 2.3."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "getEngineId",
    "code": "public final Optional<String> getEngineId() {\n\t\treturn getRoot().filter(segment -> ENGINE_SEGMENT_TYPE.equals(segment.getType())).map(Segment::getValue);\n\t}",
    "comment": "Get the engine ID stored in this {@code UniqueId}, if available.\n\n@see #forEngine(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/session-facade/src/main/java/com/iluwatar/sessionfacade/ProductCatalogService.java",
    "type": "method",
    "name": "ProductCatalogService",
    "code": "public ProductCatalogService(Map<Integer, Product> products) {\n    this.products = products;\n  }",
    "comment": "Instantiates a new ProductCatalogService.\n\n@param products the map of products to be used by this service"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java",
    "type": "method",
    "name": "cliMerge",
    "code": "private CommandLine cliMerge(CommandLine mavenConfig, CommandLine mavenCli) {\n        CommandLine.Builder commandLineBuilder = new CommandLine.Builder();\n\n        for (String arg : mavenCli.getArgs()) {\n            commandLineBuilder.addArg(arg);\n        }\n\n        /* Although this looks wrong in terms of order Commons CLI stores the value of options in\n         * an array and when a value is potentionally overriden it is added to the array. The single\n         * arg option value is retrieved and instead of returning values[values.length-1] it returns\n         * values[0] which means that the original value instead of the overridden one is returned\n         * (first wins). With properties values are truely overriden since at the end a map is used\n         * to merge which means last wins.\n         *\n         * TODO Report this behavioral bug with Commons CLI\n         */\n        List<Option> setPropertyOptions = new ArrayList<>();\n        for (Option opt : mavenCli.getOptions()) {\n            if (String.valueOf(CLIManager.SET_USER_PROPERTY).equals(opt.getOpt())) {\n                setPropertyOptions.add(opt);\n            } else {\n                commandLineBuilder.addOption(opt);\n            }\n        }\n        for (Option opt : mavenConfig.getOptions()) {\n            commandLineBuilder.addOption(opt);\n        }\n        for (Option opt : setPropertyOptions) {\n            commandLineBuilder.addOption(opt);\n        }\n        return commandLineBuilder.build();\n    }",
    "comment": "the args are easy, CLI only since maven.config file can only contain options\nnow add all options, except for user properties with CLI first then maven.config file\nfinally add the CLI user properties"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/Encoders.java",
    "type": "method",
    "name": "encodedLength",
    "code": "public static int encodedLength(RoaringBitmap b) {\n      // Compress the bitmap before serializing it. Note that since BlockTransferMessage\n      // needs to invoke encodedLength first to figure out the length for the ByteBuf, it\n      // guarantees that the bitmap will always be compressed before being serialized.\n      b.trim();\n      b.runOptimize();\n      return b.serializedSizeInBytes();\n    }",
    "comment": "Bitmaps are encoded with their serialization length followed by the serialization bytes.\n\n@since 3.1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/execution/sort/RecordBinaryComparatorSuite.java",
    "type": "method",
    "name": "testCompareLongsAsUnsigned",
    "code": "public void testCompareLongsAsUnsigned() {\n    long arrayOffset = Platform.LONG_ARRAY_OFFSET + 4;\n\n    long[] arr1 = new long[2];\n    Platform.putLong(arr1, arrayOffset + 4, 0xa000000000000000L);\n    long[] arr2 = new long[2];\n    Platform.putLong(arr2, arrayOffset + 4, 0x0000000000000000L);\n    int result1 = binaryComparator.compare(arr1, arrayOffset + 4, 8, arr2, arrayOffset + 4, 8);\n\n    long[] arr3 = new long[2];\n    Platform.putLong(arr3, arrayOffset, 0xa000000000000000L);\n    long[] arr4 = new long[2];\n    Platform.putLong(arr4, arrayOffset, 0x0000000000000000L);\n    int result2 = binaryComparator.compare(arr3, arrayOffset, 8, arr4, arrayOffset, 8);\n\n    Assertions.assertEquals(result1, result2);\n  }",
    "comment": "both leftBaseOffset and rightBaseOffset are aligned, so it will start by comparing long\nboth leftBaseOffset and rightBaseOffset are not aligned,\nso it will start with byte-by-byte comparison"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/FloatAssertTest.java",
    "type": "method",
    "name": "testAssertEqualsNaNFails",
    "code": "public void testAssertEqualsNaNFails() {\n        try {\n            assertEquals(1.234f, Float.NaN, 0.0);\n        } catch (AssertionFailedError e) {\n            return;\n        }\n        fail();\n    }",
    "comment": "Test for the special Double.NaN value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/BloomFilterImpl.java",
    "type": "method",
    "name": "mightContainLong",
    "code": "public boolean mightContainLong(long item) {\n    int h1 = Murmur3_x86_32.hashLong(item, 0);\n    int h2 = Murmur3_x86_32.hashLong(item, h1);\n\n    long bitSize = bits.bitSize();\n    for (int i = 1; i <= numHashFunctions; i++) {\n      int combinedHash = h1 + (i * h2);\n      if (combinedHash < 0) {\n        combinedHash = ~combinedHash;\n      }\n      if (!bits.get(combinedHash % bitSize)) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": "Flip all the bits if it's negative (guaranteed positive number)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExternalBlockHandler.java",
    "type": "method",
    "name": "ShuffleMetrics",
    "code": "public ShuffleMetrics() {\n      allMetrics = new HashMap<>();\n      allMetrics.put(\"openBlockRequestLatencyMillis\", openBlockRequestLatencyMillis);\n      allMetrics.put(\"registerExecutorRequestLatencyMillis\", registerExecutorRequestLatencyMillis);\n      allMetrics.put(\"fetchMergedBlocksMetaLatencyMillis\", fetchMergedBlocksMetaLatencyMillis);\n      allMetrics.put(\"finalizeShuffleMergeLatencyMillis\", finalizeShuffleMergeLatencyMillis);\n      allMetrics.put(\"blockTransferRate\", blockTransferRate);\n      allMetrics.put(\"blockTransferMessageRate\", blockTransferMessageRate);\n      allMetrics.put(\"blockTransferRateBytes\", blockTransferRateBytes);\n      allMetrics.put(\"blockTransferAvgSize_1min\", new RatioGauge() {\n      });\n      allMetrics.put(\"registeredExecutorsSize\",\n                     (Gauge<Integer>) () -> blockManager.getRegisteredExecutorsSize());\n      allMetrics.put(\"numActiveConnections\", activeConnections);\n      allMetrics.put(\"numCaughtExceptions\", caughtExceptions);\n    }",
    "comment": "A simple class to wrap all shuffle service wrapper metrics"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-class-loader/dep-b/src/main/java/org/apache/maven/plugin/coreit/SomeClass.java",
    "type": "method",
    "name": "methodB",
    "code": "public static String methodB() {\n        return \"B\";\n    }",
    "comment": "A test class that is <em>not</em> unique to this artifact. Other artifacts will deliberately contain an equally named\nclass (with different members) to check class path ordering of dependencies.\n\n@author Benjamin Bentmann"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterExpressionEvaluatorV4.java",
    "type": "method",
    "name": "isTypeCompatible",
    "code": "private static boolean isTypeCompatible(Class<?> type, Object value) {\n        if (type.isInstance(value)) {\n            return true;\n        }\n        return ((type.isPrimitive() || type.getName().startsWith(\"java.lang.\"))\n                && value.getClass().getName().startsWith(\"java.lang.\"));\n    }",
    "comment": "likely Boolean -> boolean, Short -> int etc. conversions, it's not the problem case we try to avoid"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-based-asynchronous/src/main/java/com/iluwatar/event/asynchronous/EventManager.java",
    "type": "method",
    "name": "generateId",
    "code": "private int generateId() {\n    // nextInt is normally exclusive of the top value,\n    // so add 1 to make it inclusive\n    var randomNum = rand.nextInt((MAX_ID - MIN_ID) + 1) + MIN_ID;\n    while (eventPool.containsKey(randomNum)) {\n      randomNum = rand.nextInt((MAX_ID - MIN_ID) + 1) + MIN_ID;\n    }\n\n    return randomNum;\n  }",
    "comment": "Returns a pseudo-random number between min and max, inclusive. The difference between min and\nmax can be at most <code>Integer.MAX_VALUE - 1</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, short expected, short actual) {\n        Assert.assertEquals(message, expected, actual);\n    }",
    "comment": "Asserts that two shorts are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(int expected, int actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/matchers/JUnitMatchers.java",
    "type": "method",
    "name": "isException",
    "code": "public static <T extends Exception> Matcher<T> isException(Matcher<T> exceptionMatcher) {\n        return StacktracePrintingMatcher.isException(exceptionMatcher);\n    }",
    "comment": "@return A matcher that delegates to exceptionMatcher and in addition\nappends the stacktrace of the actual Exception in case of a mismatch."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java",
    "type": "method",
    "name": "runTextDatasetExample",
    "code": "private static void runTextDatasetExample(SparkSession spark) {\n    String path = \"examples/src/main/resources/people.txt\";\n\n    Dataset<Row> df1 = spark.read().text(path);\n    df1.show();\n\n    Dataset<Row> df2 = spark.read().option(\"lineSep\", \",\").text(path);\n    df2.show();\n\n    Dataset<Row> df3 = spark.read().option(\"wholetext\", \"true\").text(path);\n    df3.show();\n\n    df1.write().text(\"output\");\n\n    df1.write().option(\"compression\", \"gzip\").text(\"output_compressed\");\n\n  }",
    "comment": "$example on:text_dataset$\nA text dataset is pointed to by path.\nThe path can be either a single text file or a directory of text files\n+-----------+\n|      value|\n+-----------+\n|Michael, 29|\n|   Andy, 30|\n| Justin, 19|\n+-----------+\nYou can use 'lineSep' option to define the line separator.\nThe line separator handles all `\\r`, `\\r\\n` and `\\n` by default.\n+-----------+\n|      value|\n+-----------+\n|    Michael|\n|   29\\nAndy|\n| 30\\nJustin|\n|       19\\n|\n+-----------+\nYou can also use 'wholetext' option to read each input file as a single row.\n+--------------------+\n|               value|\n+--------------------+\n|Michael, 29\\nAndy...|\n+--------------------+\n\"output\" is a folder which contains multiple text files and a _SUCCESS file.\nYou can specify the compression format using the 'compression' option.\n$example off:text_dataset$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-configuration/src/main/java/org/apache/maven/plugin/coreit/Bean.java",
    "type": "method",
    "name": "set",
    "code": "public void set(String value) {\n        fieldParam = value;\n        setterCalled = true;\n    }",
    "comment": "A bean to receive mojo configuration.\n\n@author Benjamin Bentmann"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/CommandBuilderUtils.java",
    "type": "method",
    "name": "parseOptionString",
    "code": "static List<String> parseOptionString(String s) {\n    List<String> opts = new ArrayList<>();\n    StringBuilder opt = new StringBuilder();\n    boolean inOpt = false;\n    boolean inSingleQuote = false;\n    boolean inDoubleQuote = false;\n    boolean escapeNext = false;\n\n    // This is needed to detect when a quoted empty string is used as an argument (\"\" or '').\n    boolean hasData = false;\n\n    for (int i = 0; i < s.length(); i++) {\n      int c = s.codePointAt(i);\n      if (escapeNext) {\n        opt.appendCodePoint(c);\n        escapeNext = false;\n      } else if (inOpt) {\n        switch (c) {\n          case '\\\\' -> {\n            if (inSingleQuote) {\n              opt.appendCodePoint(c);\n            } else {\n              escapeNext = true;\n            }\n          }\n          case '\\'' -> {\n            if (inDoubleQuote) {\n              opt.appendCodePoint(c);\n            } else {\n              inSingleQuote = !inSingleQuote;\n            }\n          }\n          case '\"' -> {\n            if (inSingleQuote) {\n              opt.appendCodePoint(c);\n            } else {\n              inDoubleQuote = !inDoubleQuote;\n            }\n          }\n          default -> {\n            if (!Character.isWhitespace(c) || inSingleQuote || inDoubleQuote) {\n              opt.appendCodePoint(c);\n            } else {\n              opts.add(opt.toString());\n              opt.setLength(0);\n              inOpt = false;\n              hasData = false;\n            }\n          }\n        }\n      } else {\n        switch (c) {\n          case '\\'' -> {\n            inSingleQuote = true;\n            inOpt = true;\n            hasData = true;\n          }\n          case '\"' -> {\n            inDoubleQuote = true;\n            inOpt = true;\n            hasData = true;\n          }\n          case '\\\\' -> {\n            escapeNext = true;\n            inOpt = true;\n            hasData = true;\n          }\n          default -> {\n            if (!Character.isWhitespace(c)) {\n              inOpt = true;\n              hasData = true;\n              opt.appendCodePoint(c);\n            }\n          }\n        }\n      }\n    }\n\n    checkArgument(!inSingleQuote && !inDoubleQuote && !escapeNext, \"Invalid option string: %s\", s);\n    if (hasData) {\n      opts.add(opt.toString());\n    }\n    return opts;\n  }",
    "comment": "Parse a string as if it were a list of arguments, following bash semantics.\nFor example:\n\nInput: \"\\\"ab cd\\\" efgh 'i \\\" j'\"\nOutput: [ \"ab cd\", \"efgh\", \"i \\\" j\" ]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(double[] expected, double[] actual, Supplier<String> messageSupplier) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} double arrays are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-di/src/main/java/org/apache/maven/di/tool/DiIndexProcessor.java",
    "type": "method",
    "name": "logMessage",
    "code": "private void logMessage(Diagnostic.Kind kind, String message) {\n        processingEnv.getMessager().printMessage(kind, message);\n    }",
    "comment": "Logs a message to the annotation processing environment.\n\n@param kind the kind of diagnostic message\n@param message the message to log"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/RpcIntegrationSuite.java",
    "type": "method",
    "name": "assertErrorAndClosed",
    "code": "private void assertErrorAndClosed(RpcResult result, String expectedError) {\n    assertTrue(result.successMessages.isEmpty(), \"unexpected success: \" + result.successMessages);\n    Set<String> errors = result.errorMessages;\n    assertEquals(2, errors.size(),\n      \"Expected 2 errors, got \" + errors.size() + \"errors: \" + errors);\n\n    Set<String> possibleClosedErrors = Sets.newHashSet(\n        \"closed\",\n        \"Connection reset\",\n        \"java.nio.channels.ClosedChannelException\",\n        \"io.netty.channel.StacklessClosedChannelException\",\n        \"java.io.IOException: Broken pipe\"\n    );\n    Set<String> containsAndClosed = Sets.newHashSet(expectedError);\n    containsAndClosed.addAll(possibleClosedErrors);\n\n    Pair<Set<String>, Set<String>> r = checkErrorsContain(errors, containsAndClosed);\n\n    assertTrue(r.getLeft().isEmpty(), \"Got a non-empty set \" + r.getLeft());\n\n    Set<String> errorsNotFound = r.getRight();\n    assertEquals(\n        possibleClosedErrors.size() - 1,\n        errorsNotFound.size(),\n        \"The size of \" + errorsNotFound + \" was not \" + (possibleClosedErrors.size() - 1));\n    for (String err: errorsNotFound) {\n      assertTrue(containsAndClosed.contains(err), \"Found a wrong error \" + err);\n    }\n  }",
    "comment": "We expect 1 additional error due to closed connection and here are possible keywords in the\nerror message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/Logger.java",
    "type": "method",
    "name": "debug",
    "code": "default void debug(@Nonnull String message, @Nullable Throwable error) {\n        log(Level.DEBUG, message, error);\n    }",
    "comment": "Logs a debug message with an associated exception.\n\n@param message the debug message to be logged\n@param error the associated exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Float unexpected, float actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Float) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/project/inheritance/AbstractProjectInheritanceTestCase.java",
    "type": "method",
    "name": "getLocalRepositoryPath",
    "code": "protected File getLocalRepositoryPath() {\n        return getTestFile(\"target/test-classes/inheritance-repo/\" + getTestSeries());\n    }",
    "comment": "----------------------------------------------------------------------\nThe local repository for this category of tests\n----------------------------------------------------------------------"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestWatcherTests.java",
    "type": "method",
    "name": "testSuccessful",
    "code": "public void testSuccessful(ExtensionContext context) {\n\t\t\tresults.put(KEY, getStore(context).get(KEY, String.class));\n\t\t}",
    "comment": "{@link TestWatcher} that retrieves data from the {@link ExtensionContext.Store}.\n@see <a href=\"https://github.com/junit-team/junit5/issues/3944\">#3944</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/ParquetAvroCompat.java",
    "type": "method",
    "name": "put",
    "code": "public void put(int field$, java.lang.Object value$) {\n    switch (field$) {\n    case 0: strings_column = (java.util.List<java.lang.String>)value$; break;\n    case 1: string_to_int_column = (java.util.Map<java.lang.String,java.lang.Integer>)value$; break;\n    case 2: complex_column = (java.util.Map<java.lang.String,java.util.List<org.apache.spark.sql.execution.datasources.parquet.test.avro.Nested>>)value$; break;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumReader.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/ring/RingMessageManager.java",
    "type": "method",
    "name": "sendHeartbeatMessage",
    "code": "public boolean sendHeartbeatMessage(int leaderId) {\n    var leaderInstance = instanceMap.get(leaderId);\n    return leaderInstance.isAlive();\n  }",
    "comment": "Send heartbeat message to current leader instance to check the health.\n\n@param leaderId leaderID\n@return {@code true} if the leader is alive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/sasl/ShuffleSecretManager.java",
    "type": "method",
    "name": "getSecretKey",
    "code": "public String getSecretKey(String appId) {\n    return shuffleSecretMap.get(appId);\n  }",
    "comment": "Return the secret key registered with the given application.\nThis key is used to authenticate the executors before they can fetch shuffle files\nwritten by this application from the external shuffle service. If the specified\napplication is not registered, return null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/lockable-object/src/main/java/com/iluwatar/lockableobject/domain/Elf.java",
    "type": "method",
    "name": "Elf",
    "code": "public Elf(String name) {\n    super(name);\n    setType(CreatureType.ELF);\n    setDamage(CreatureStats.ELF_DAMAGE.getValue());\n    setHealth(CreatureStats.ELF_HEALTH.getValue());\n  }",
    "comment": "A constructor that initializes the attributes of an elf.\n\n@param name as the name of the creature."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java",
    "type": "method",
    "name": "Lock",
    "code": "public Lock(String key, ResourceAccessMode accessMode) {\n\t\t\tthis.key = Preconditions.notBlank(key, \"key must not be null or blank\");\n\t\t\tthis.accessMode = Preconditions.notNull(accessMode, \"accessMode must not be null\");\n\t\t}",
    "comment": "Create a new {@code Lock}.\n@param accessMode the lock mode to use to synchronize access to the\nresource; never {@code null}\n@see ResourceLock#value()\n@see ResourceLock#mode()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/VariantVal.java",
    "type": "method",
    "name": "VariantVal",
    "code": "public VariantVal(byte[] value, byte[] metadata) {\n    this.value = value;\n    this.metadata = metadata;\n  }",
    "comment": "The physical data representation of {@link org.apache.spark.sql.types.VariantType} that\nrepresents a semi-structured value. It consists of two binary values: {@link VariantVal#value}\nand {@link VariantVal#metadata}. The value encodes types and values, but not field names. The\nmetadata currently contains a version flag and a list of field names. We can extend/modify the\ndetailed binary format given the version flag.\n<p>\nA {@link VariantVal} can be produced by casting another value into the Variant type or parsing a\nJSON string in the {@link org.apache.spark.sql.catalyst.expressions.variant.ParseJson}\nexpression. We can extract a path consisting of field names and array indices from it, cast it\ninto a concrete data type, or rebuild a JSON string from it.\n<p>\nThe storage layout of this class in {@link org.apache.spark.sql.catalyst.expressions.UnsafeRow}\nand {@link org.apache.spark.sql.catalyst.expressions.UnsafeArrayData} is: the fixed-size part is\na long value \"offsetAndSize\". The upper 32 bits is the offset that points to the start position\nof the actual binary content. The lower 32 bits is the total length of the binary content. The\nbinary content contains: 4 bytes representing the length of {@link VariantVal#value}, content of\n{@link VariantVal#value}, content of {@link VariantVal#metadata}. This is an internal and\ntransient format and can be modified at any time."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/Table.java",
    "type": "method",
    "name": "partitioning",
    "code": "default Transform[] partitioning() {\n    return new Transform[0];\n  }",
    "comment": "Returns the physical partitioning of this table."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, short expected, short actual) {\n        assertEquals(message, Short.valueOf(expected), Short.valueOf(actual));\n    }",
    "comment": "Asserts that two shorts are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/RequestTraceHelper.java",
    "type": "method",
    "name": "toMaven",
    "code": "public static org.apache.maven.api.services.RequestTrace toMaven(String context, RequestTrace trace) {\n        if (trace != null) {\n            return new org.apache.maven.api.services.RequestTrace(\n                    context, toMaven(context, trace.getParent()), trace.getData());\n        } else {\n            return null;\n        }\n    }",
    "comment": "Converts a Resolver trace to a Maven trace\n@param context The context string for the new Maven trace\n@param trace The Resolver trace to convert\n@return A new Maven trace, or null if the input trace was null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/TestClass.java",
    "type": "method",
    "name": "compare",
    "code": "public int compare(Field left, Field right) {\n            return left.getName().compareTo(right.getName());\n        }",
    "comment": "Compares two fields by its name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/DisabledForJreRangeConditionTests.java",
    "type": "method",
    "name": "getExecutionCondition",
    "code": "protected ExecutionCondition getExecutionCondition() {\n\t\treturn new DisabledForJreRangeCondition();\n\t}",
    "comment": "Unit tests for {@link DisabledForJreRange}.\n\n<p>Note that test method names MUST match the test method names in\n{@link DisabledForJreRangeIntegrationTests}.\n\n@since 5.6"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/ShuffleExternalSorter.java",
    "type": "method",
    "name": "acquireNewPageIfNecessary",
    "code": "private void acquireNewPageIfNecessary(int required) {\n    if (currentPage == null ||\n      pageCursor + required > currentPage.getBaseOffset() + currentPage.size() ) {\n      // TODO: try to find space in previous pages\n      currentPage = allocatePage(required);\n      pageCursor = currentPage.getBaseOffset();\n      allocatedPages.add(currentPage);\n    }\n  }",
    "comment": "Allocates more memory in order to insert an additional record. This will request additional\nmemory from the memory manager and spill if the requested memory can not be obtained.\n\n@param required the required space in the data page, in bytes, including space for storing\nthe record size. This must be less than or equal to the page size (records\nthat exceed the page size are handled via a different code path which uses\nspecial overflow pages)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/StandardTestClassTests.java",
    "type": "method",
    "name": "standardTestClassIsCorrectlyDiscovered",
    "code": "void standardTestClassIsCorrectlyDiscovered() {\n\t\tLauncherDiscoveryRequest request = request().selectors(selectClass(MyStandardTestCase.class)).build();\n\t\tTestDescriptor engineDescriptor = discoverTests(request).getEngineDescriptor();\n\t\tassertEquals(1 /*class*/ + 6 /*methods*/, engineDescriptor.getDescendants().size(),\n\t\t\t\"# resolved test descriptors\");\n\t}",
    "comment": "Tests for discovery and execution of standard test cases for the\n{@link JupiterTestEngine}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java",
    "type": "method",
    "name": "prepare",
    "code": "public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {\n\t\tMutableExtensionRegistry registry = populateNewExtensionRegistryFromExtendWithAnnotation(\n\t\t\tcontext.getExtensionRegistry(), getTestMethod());\n\n\t\tTestInstances testInstances = context.getExtensionContext().getTestInstances().orElse(null);\n\n\t\tExtensionContext extensionContext = new TestTemplateExtensionContext(context.getExtensionContext(),\n\t\t\tcontext.getExecutionListener(), this, context.getConfiguration(), registry,\n\t\t\tcontext.getLauncherStoreFacade(), testInstances);\n\n\t\treturn context.extend()\n\t\t\t\t.withExtensionRegistry(registry)\n\t\t\t\t.withExtensionContext(extensionContext)\n\t\t\t\t.build();\n\t}",
    "comment": "--- Node ----------------------------------------------------------------\nThe test instance should be properly maintained by the enclosing class's ExtensionContext.\n@formatter:off\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Boolean> create(Scope scope, boolean[] data) {\n    return create(scope, data, Boolean.class);\n  }",
    "comment": "Creates a rank-1 constant of {@code boolean} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/AbstractService.java",
    "type": "method",
    "name": "ensureCurrentState",
    "code": "private void ensureCurrentState(Service.STATE currentState) {\n    ServiceOperations.ensureCurrentState(state, currentState);\n  }",
    "comment": "Verify that a service is in a given state.\n\n@param currentState\nthe desired state\n@throws IllegalStateException\nif the service state is different from\nthe desired state"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/CaseInsensitiveStringMap.java",
    "type": "method",
    "name": "getDouble",
    "code": "public double getDouble(String key, double defaultValue) {\n    String value = get(key);\n    return value == null ? defaultValue : Double.parseDouble(value);\n  }",
    "comment": "Returns the double value to which the specified key is mapped,\nor defaultValue if there is no mapping for the key. The key match is case-insensitive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/Sources.java",
    "type": "method",
    "name": "resolvedSource",
    "code": "public static ModelSource resolvedSource(@Nonnull Path path, @Nullable String location) {\n        return new ResolvedPathSource(requireNonNull(path, \"path\"), location);\n    }",
    "comment": "Creates a new resolved source for the specified path and location.\nResolved sources are used for artifacts that have been resolved by Maven\nfrom repositories (using groupId:artifactId:version coordinates) and\ndownloaded to the local repository. These sources do not support resolving\nother sources.\n\n@param path the path to the POM file or project directory\n@param location optional logical location of the source, used for reporting purposes\n@return a new ModelSource instance configured as a resolved source\n@throws NullPointerException if path is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/thrift/ThriftCLIService.java",
    "type": "method",
    "name": "init",
    "code": "public synchronized void init(HiveConf hiveConf) {\n    this.hiveConf = hiveConf;\n    String portString;\n    hiveHost = System.getenv(\"HIVE_SERVER2_THRIFT_BIND_HOST\");\n    if (hiveHost == null) {\n      hiveHost = hiveConf.getVar(ConfVars.HIVE_SERVER2_THRIFT_BIND_HOST);\n    }\n    try {\n      if (hiveHost != null && !hiveHost.isEmpty()) {\n        serverIPAddress = InetAddress.getByName(hiveHost);\n      } else {\n        serverIPAddress = InetAddress.getLocalHost();\n      }\n    } catch (UnknownHostException e) {\n      throw new ServiceException(e);\n    }\n    if (HiveServer2.isHTTPTransportMode(hiveConf)) {\n      workerKeepAliveTime =\n          hiveConf.getTimeVar(ConfVars.HIVE_SERVER2_THRIFT_HTTP_WORKER_KEEPALIVE_TIME,\n              TimeUnit.SECONDS);\n      portString = System.getenv(\"HIVE_SERVER2_THRIFT_HTTP_PORT\");\n      if (portString != null) {\n        portNum = Integer.valueOf(portString);\n      } else {\n        portNum = hiveConf.getIntVar(ConfVars.HIVE_SERVER2_THRIFT_HTTP_PORT);\n      }\n    }\n    else {\n      workerKeepAliveTime =\n          hiveConf.getTimeVar(ConfVars.HIVE_SERVER2_THRIFT_WORKER_KEEPALIVE_TIME, TimeUnit.SECONDS);\n      portString = System.getenv(\"HIVE_SERVER2_THRIFT_PORT\");\n      if (portString != null) {\n        portNum = Integer.valueOf(portString);\n      } else {\n        portNum = hiveConf.getIntVar(ConfVars.HIVE_SERVER2_THRIFT_PORT);\n      }\n    }\n    minWorkerThreads = hiveConf.getIntVar(ConfVars.HIVE_SERVER2_THRIFT_MIN_WORKER_THREADS);\n    maxWorkerThreads = hiveConf.getIntVar(ConfVars.HIVE_SERVER2_THRIFT_MAX_WORKER_THREADS);\n    super.init(hiveConf);\n  }",
    "comment": "Initialize common server configs needed in both binary & http modes\nHTTP mode\nBinary mode"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroNonNullableArrays.java",
    "type": "method",
    "name": "put",
    "code": "public void put(int field$, java.lang.Object value$) {\n    switch (field$) {\n    case 0: strings_column = (java.util.List<java.lang.String>)value$; break;\n    case 1: maybe_ints_column = (java.util.List<java.lang.Integer>)value$; break;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumReader.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "byteStringAsGb",
    "code": "public static long byteStringAsGb(String str) {\n    return byteStringAs(str, ByteUnit.GiB);\n  }",
    "comment": "Convert a passed byte string (e.g. 50b, 100k, or 250m) to gibibytes for\ninternal use.\n\nIf no suffix is provided, the passed number is assumed to be in gibibytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/unsafe/map/AbstractBytesToBytesMapSuite.java",
    "type": "method",
    "name": "randomizedTestWithRecordsLargerThanPageSize",
    "code": "public void randomizedTestWithRecordsLargerThanPageSize() {\n    final long pageSizeBytes = 128;\n    final BytesToBytesMap map = new BytesToBytesMap(taskMemoryManager, 64, pageSizeBytes);\n    final Map<ByteBuffer, byte[]> expected = new HashMap<>();\n    try {\n      for (int i = 0; i < 1000; i++) {\n        final byte[] key = getRandomByteArray(rand.nextInt(128));\n        final byte[] value = getRandomByteArray(rand.nextInt(128));\n        if (!expected.containsKey(ByteBuffer.wrap(key))) {\n          expected.put(ByteBuffer.wrap(key), value);\n          final BytesToBytesMap.Location loc = map.lookup(\n            key,\n            Platform.BYTE_ARRAY_OFFSET,\n            key.length\n          );\n          Assertions.assertFalse(loc.isDefined());\n          Assertions.assertTrue(loc.append(\n            key,\n            Platform.BYTE_ARRAY_OFFSET,\n            key.length,\n            value,\n            Platform.BYTE_ARRAY_OFFSET,\n            value.length\n          ));\n          Assertions.assertTrue(loc.isDefined());\n          Assertions.assertEquals(key.length, loc.getKeyLength());\n          Assertions.assertEquals(value.length, loc.getValueLength());\n          Assertions.assertTrue(arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), key.length));\n          Assertions.assertTrue(\n            arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), value.length));\n        }\n      }\n      for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) {\n        final byte[] key = JavaUtils.bufferToArray(entry.getKey());\n        final byte[] value = entry.getValue();\n        final BytesToBytesMap.Location loc =\n          map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length);\n        Assertions.assertTrue(loc.isDefined());\n        Assertions.assertTrue(\n          arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), loc.getKeyLength()));\n        Assertions.assertTrue(\n          arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), loc.getValueLength()));\n      }\n    } finally {\n      map.free();\n    }\n  }",
    "comment": "Java arrays' hashCodes() aren't based on the arrays' contents, so we need to wrap arrays\ninto ByteBuffers in order to use them as keys here.\nAfter calling putNewKey, the following should be true, even before calling\nlookup():"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "readFieldValue",
    "code": "public static Optional<Object> readFieldValue(Field field) {\n\t\treturn tryToReadFieldValue(field).toOptional();\n\t}",
    "comment": "Read the value of the supplied static field, making it accessible if\nnecessary and {@linkplain ExceptionUtils#throwAsUncheckedException masking}\nany checked exception as an unchecked exception.\n\n<p>If the value of the field is {@code null}, an empty {@link Optional}\nwill be returned.\n\n@param field the field to read; never {@code null}\n@see #readFieldValue(Field, Object)\n@see #readFieldValue(Class, String, Object)\n@deprecated Please use {@link #tryToReadFieldValue(Field)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java",
    "type": "method",
    "name": "getPluginsBoundByDefaultToAllLifecycles",
    "code": "public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles(String packaging) {\n        Set<Plugin> plugins;\n\n        if (\"JAR\".equals(packaging)) {\n            plugins = new LinkedHashSet<>();\n\n            plugins.add(newPlugin(\"maven-compiler-plugin\", \"compile\", \"testCompile\"));\n            plugins.add(newPlugin(\"maven-resources-plugin\", \"resources\", \"testResources\"));\n            plugins.add(newPlugin(\"maven-surefire-plugin\", \"test\"));\n            plugins.add(newPlugin(\"maven-jar-plugin\", \"jar\"));\n            plugins.add(newPlugin(\"maven-install-plugin\", \"install\"));\n            plugins.add(newPlugin(\"maven-deploy-plugin\", \"deploy\"));\n        } else {\n            plugins = Collections.emptySet();\n        }\n\n        return plugins;\n    }",
    "comment": "NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng2744checksumVerificationTest.java",
    "type": "method",
    "name": "MavenITmng2744checksumVerificationTest",
    "code": "public MavenITmng2744checksumVerificationTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-2744\">MNG-2744</a>.\n\n@author Benjamin Bentmann"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/anti-corruption-layer/src/main/java/com/iluwatar/corruption/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SpringApplication.run(App.class, args);\n  }",
    "comment": "This layer translates communications between the two systems, allowing one system to remain\nunchanged while the other can avoid compromising its design and technological approach."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableCatalog.java",
    "type": "method",
    "name": "tableExists",
    "code": "default boolean tableExists(Identifier ident) {\n    try {\n      return loadTable(ident) != null;\n    } catch (NoSuchTableException e) {\n      return false;\n    }\n  }",
    "comment": "Test whether a table exists using an {@link Identifier identifier} from the catalog.\n<p>\nIf the catalog supports views and contains a view for the identifier and not a table, this\nmust return false.\n\n@param ident a table identifier\n@return true if the table exists, false otherwise"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/lazy/LazyFluentIterable.java",
    "type": "method",
    "name": "from",
    "code": "public static <E> FluentIterable<E> from(Iterable<E> iterable) {\n    return new LazyFluentIterable<>(iterable);\n  }",
    "comment": "Constructors FluentIterable from given iterable.\n\n@return a FluentIterable from a given iterable. Calls the LazyFluentIterable constructor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/toolchain/java/DefaultJavaToolChain.java",
    "type": "method",
    "name": "DefaultJavaToolChain",
    "code": "public DefaultJavaToolChain(ToolchainModel model, Logger logger) {\n        super(model, logger);\n    }",
    "comment": "Provides backwards compatibility with Maven 3.2.3 and earlier. Clients that do not require compatibility with Maven\n3.2.3 and earlier are encouraged to use {@link JavaToolchainImpl}.\n<strong>Note:</strong> This is an internal component whose interface can change without prior notice.\n\n@deprecated clients that do not require compatibility with Maven 3.2.3 and earlier should link to\n{@link JavaToolchainImpl} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/ParquetEnum.java",
    "type": "method",
    "name": "put",
    "code": "public void put(int field$, java.lang.Object value$) {\n    switch (field$) {\n    case 0: suit = (org.apache.spark.sql.execution.datasources.parquet.test.avro.Suit)value$; break;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumReader.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlob",
    "code": "public static Tensor fromBlob(DoubleBuffer data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_BUFFER_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.capacity(), shape);\n    checkArgument(data.isDirect(), ERROR_MSG_DATA_BUFFER_MUST_BE_DIRECT);\n    checkArgument(\n        (data.order() == ByteOrder.nativeOrder()),\n        ERROR_MSG_DATA_BUFFER_MUST_HAVE_NATIVE_BYTE_ORDER);\n    return new Tensor_float64(data, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.float64 with specified shape and data.\n\n@param data Direct buffer with native byte order that contains {@code Tensor.numel(shape)}\nelements. The buffer is used directly without copying, and changes to its content will\nchange the tensor.\n@param shape Tensor shape"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static <T> Constant<T> create(Scope scope, Class<T> type, long[] shape, ByteBuffer data) {\n    try (Tensor<T> value = Tensor.create(type, shape, data)) {\n      return createWithTensor(scope, value);\n    }\n  }",
    "comment": "Create a constant with data from the given buffer.\n\n<p>Creates a Constant with the provided shape of any type where the constant data has been\nencoded into {@code data} as per the specification of the TensorFlow <a\nhref=\"https://www.tensorflow.org/code/tensorflow/c/c_api.h\">C\nAPI</a>.\n\n@param scope is a scope used to add the underlying operation.\n@param type the tensor datatype.\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@return a constant of type `type`\n@throws IllegalArgumentException If the tensor datatype or shape is not compatible with the\nbuffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/resources/mng-5753-custom-mojo-execution-configurator/plugin/src/main/java/org/apache/maven/its/mng5753/plugin/TestMojoExecutionConfigurator.java",
    "type": "method",
    "name": "configure",
    "code": "public void configure(MavenProject project, MojoExecution mojoExecution, boolean allowPluginLevelConfig) {\n        super.configure(project, mojoExecution, allowPluginLevelConfig);\n\n        Xpp3Dom mojoConfiguration = mojoExecution.getConfiguration();\n\n        mojoConfiguration.getChild(\"name\").setValue(\"TRANSFORMED\");\n    }",
    "comment": "We do exactly what the default mojo execution configurator does\nAnd now we'll insert some additional configuration that we can assert was placed\nin the configuration in our test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getTypeInfo",
    "code": "public int getTypeInfo() {\n    return VariantUtil.getTypeInfo(value, pos);\n  }",
    "comment": "Get the type info bits from a variant value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/model-view-presenter/src/main/java/com/iluwatar/model/view/presenter/FileLoader.java",
    "type": "method",
    "name": "setFileName",
    "code": "public void setFileName(String fileName) {\n    this.fileName = fileName;\n  }",
    "comment": "Sets the path of the file to be loaded, to the given value.\n\n@param fileName The path of the file to be loaded."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultDependencyResolverResult.java",
    "type": "method",
    "name": "name",
    "code": "private static String name(final Object value) {\n        if (value instanceof String string) {\n            return string;\n        } else if (value instanceof ModuleDescriptor moduleDescriptor) {\n            return moduleDescriptor.name();\n        } else {\n            return null;\n        }\n    }",
    "comment": "Returns the module name for the given value of the {@link PathModularization#descriptors} map."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/FarthestConflictResolverTest.java",
    "type": "method",
    "name": "testEqual",
    "code": "void testEqual() {\n        ResolutionNode a1n = createResolutionNode(a1);\n        ResolutionNode a2n = createResolutionNode(a2);\n\n        assertResolveConflict(a1n, a1n, a2n);\n    }",
    "comment": "Tests that <code>a:1.0</code> wins in the scenario:\n<pre>\na:1.0\na:2.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Float unexpected, Float actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/CacheStore.java",
    "type": "method",
    "name": "readThroughWithWriteBackPolicy",
    "code": "public UserAccount readThroughWithWriteBackPolicy(final String userId) {\n    if (cache.contains(userId)) {\n      LOGGER.info(\"# Found in cache!\");\n      return cache.get(userId);\n    }\n    LOGGER.info(\"# Not found in Cache!\");\n    UserAccount userAccount = dbManager.readFromDb(userId);\n    if (cache.isFull()) {\n      LOGGER.info(\"# Cache is FULL! Writing LRU data to DB...\");\n      UserAccount toBeWrittenToDb = cache.getLruData();\n      dbManager.upsertDb(toBeWrittenToDb);\n    }\n    cache.set(userId, userAccount);\n    return userAccount;\n  }",
    "comment": "Get user account using read-through cache with write-back policy.\n\n@param userId {@link String}\n@return {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/ComparisonFailure.java",
    "type": "method",
    "name": "ComparisonFailure",
    "code": "public ComparisonFailure(String message, String expected, String actual) {\n        super(message);\n        fExpected = expected;\n        fActual = actual;\n    }",
    "comment": "Constructs a comparison failure.\n\n@param message the identifying message or null\n@param expected the expected string value\n@param actual the actual string value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java",
    "type": "method",
    "name": "constructFromClassWithInvalidAfterAllDeclaration",
    "code": "void constructFromClassWithInvalidAfterAllDeclaration() {\n\t\tClassTestDescriptor descriptor = new ClassTestDescriptor(uniqueId, TestCaseWithInvalidAfterAllMethod.class,\n\t\t\tconfiguration);\n\n\t\tassertEquals(TestCaseWithInvalidAfterAllMethod.class, descriptor.getTestClass());\n\t}",
    "comment": "Note: if we can instantiate the descriptor, then the invalid configuration\nwill not be reported during the test engine discovery phase."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/shuffle/sort/ShuffleInMemorySorterSuite.java",
    "type": "method",
    "name": "testBasicSorting",
    "code": "public void testBasicSorting() {\n    final String[] dataToSort = new String[] {\n    final SparkConf conf = new SparkConf().set(package$.MODULE$.MEMORY_OFFHEAP_ENABLED(), false);\n    final TaskMemoryManager memoryManager =\n      new TaskMemoryManager(new TestMemoryManager(conf), 0);\n    final MemoryConsumer c = new TestMemoryConsumer(memoryManager);\n    final MemoryBlock dataPage = memoryManager.allocatePage(2048, c);\n    final Object baseObject = dataPage.getBaseObject();\n    final ShuffleInMemorySorter sorter = new ShuffleInMemorySorter(\n      consumer, 4, shouldUseRadixSort());\n    final HashPartitioner hashPartitioner = new HashPartitioner(4);\n\n    long position = dataPage.getBaseOffset();\n    for (String str : dataToSort) {\n      if (!sorter.hasSpaceForAnotherRecord()) {\n        sorter.expandPointerArray(\n          consumer.allocateArray(sorter.getMemoryUsage() / 8 * 2));\n      }\n      final long recordAddress = memoryManager.encodePageNumberAndOffset(dataPage, position);\n      final byte[] strBytes = str.getBytes(StandardCharsets.UTF_8);\n      Platform.putInt(baseObject, position, strBytes.length);\n      position += 4;\n      Platform.copyMemory(\n        strBytes, Platform.BYTE_ARRAY_OFFSET, baseObject, position, strBytes.length);\n      position += strBytes.length;\n      sorter.insertRecord(recordAddress, hashPartitioner.getPartition(str));\n    }\n\n    final ShuffleInMemorySorter.ShuffleSorterIterator iter = sorter.getSortedIterator();\n    int prevPartitionId = -1;\n    Arrays.sort(dataToSort);\n    for (int i = 0; i < dataToSort.length; i++) {\n      Assertions.assertTrue(iter.hasNext());\n      iter.loadNext();\n      final int partitionId = iter.packedRecordPointer.getPartitionId();\n      Assertions.assertTrue(partitionId >= 0 && partitionId <= 3);\n      Assertions.assertTrue(partitionId >= prevPartitionId,\n        \"Partition id \" + partitionId + \" should be >= prev id \" + prevPartitionId);\n      final long recordAddress = iter.packedRecordPointer.getRecordPointer();\n      final int recordLength = Platform.getInt(\n        memoryManager.getPage(recordAddress), memoryManager.getOffsetInPage(recordAddress));\n      final String str = getStringFromDataPage(\n        memoryManager.getPage(recordAddress),\n        memoryManager.getOffsetInPage(recordAddress) + 4, // skip over record length\n        recordLength);\n      Assertions.assertTrue(Arrays.binarySearch(dataToSort, str) != -1);\n    }\n    Assertions.assertFalse(iter.hasNext());\n  }\n\n  @Test\n  public void testSortingManyNumbers() {\n    ShuffleInMemorySorter sorter = new ShuffleInMemorySorter(consumer, 4, shouldUseRadixSort());\n    int[] numbersToSort = new int[128000];\n    Random random = new Random(16);\n    for (int i = 0; i < numbersToSort.length; i++) {\n      if (!sorter.hasSpaceForAnotherRecord()) {\n        sorter.expandPointerArray(consumer.allocateArray(sorter.getMemoryUsage() / 8 * 2));\n      }\n      numbersToSort[i] = random.nextInt(PackedRecordPointer.MAXIMUM_PARTITION_ID + 1);\n      sorter.insertRecord(0, numbersToSort[i]);\n    }\n    Arrays.sort(numbersToSort);\n    int[] sorterResult = new int[numbersToSort.length];\n    ShuffleInMemorySorter.ShuffleSorterIterator iter = sorter.getSortedIterator();\n    int j = 0;\n    while (iter.hasNext()) {\n      iter.loadNext();\n      sorterResult[j] = iter.packedRecordPointer.getPartitionId();\n      j += 1;\n    }\n    Assertions.assertArrayEquals(numbersToSort, sorterResult);\n  }\n}",
    "comment": "Write the records into the data page and store pointers into the sorter\nSort the records"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/test/java/org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java",
    "type": "method",
    "name": "testDefaultBuildTimestampFormatShouldFormatTimeIn24HourFormat",
    "code": "public void testDefaultBuildTimestampFormatShouldFormatTimeIn24HourFormat() {\n        Calendar cal = Calendar.getInstance();\n        cal.setTimeZone(MavenBuildTimestamp.DEFAULT_BUILD_TIME_ZONE);\n        cal.set(Calendar.HOUR, 12);\n        cal.set(Calendar.AM_PM, Calendar.AM);\n\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 16);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.YEAR, 1976);\n        cal.set(Calendar.MONTH, Calendar.NOVEMBER);\n        cal.set(Calendar.DATE, 11);\n\n        Date firstTestDate = cal.getTime();\n\n        cal.set(Calendar.HOUR, 11);\n        cal.set(Calendar.AM_PM, Calendar.PM);\n\n        cal.set(Calendar.HOUR_OF_DAY, 23);\n\n        Date secondTestDate = cal.getTime();\n\n        SimpleDateFormat format = new SimpleDateFormat(MavenBuildTimestamp.DEFAULT_BUILD_TIMESTAMP_FORMAT);\n        format.setTimeZone(MavenBuildTimestamp.DEFAULT_BUILD_TIME_ZONE);\n        assertEquals(\"1976-11-11T00:16:00Z\", format.format(firstTestDate));\n        assertEquals(\"1976-11-11T23:16:00Z\", format.format(secondTestDate));\n    }",
    "comment": "just to make sure all the bases are covered...\njust to make sure all the bases are covered..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Long unexpected, Long actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/test/java/org/tensorflow/EagerSessionTest.java",
    "type": "method",
    "name": "buildOp",
    "code": "private static void buildOp(EagerSession s) {\n    try {\n      s.opBuilder(\"Const\", \"Const\");\n    } catch (UnsupportedOperationException e) {\n    }\n  }",
    "comment": "Creating an operation is a safe point for resource cleanup\nTODO (karlllessard) remove this exception catch when EagerOperationBuilder is implemented"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/bully/BullyMessageManager.java",
    "type": "method",
    "name": "sendHeartbeatInvokeMessage",
    "code": "public void sendHeartbeatInvokeMessage(int currentId) {\n    var nextInstance = this.findNextInstance(currentId);\n    var heartbeatInvokeMessage = new Message(MessageType.HEARTBEAT_INVOKE, \"\");\n    nextInstance.onMessage(heartbeatInvokeMessage);\n  }",
    "comment": "Send heartbeat invoke message to the next instance.\n\n@param currentId Instance ID of which sends this message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaKMeansExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    // Create a SparkSession.\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaKMeansExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Loads data.\n    Dataset<Row> dataset = spark.read().format(\"libsvm\").load(\"data/mllib/sample_kmeans_data.txt\");\n\n    // Trains a k-means model.\n    KMeans kmeans = new KMeans().setK(2).setSeed(1L);\n    KMeansModel model = kmeans.fit(dataset);\n\n    // Make predictions\n    Dataset<Row> predictions = model.transform(dataset);\n\n    // Evaluate clustering by computing Silhouette score\n    ClusteringEvaluator evaluator = new ClusteringEvaluator();\n\n    double silhouette = evaluator.evaluate(predictions);\n    System.out.println(\"Silhouette with squared euclidean distance = \" + silhouette);\n\n    // Shows the result.\n    Vector[] centers = model.clusterCenters();\n    System.out.println(\"Cluster Centers: \");\n    for (Vector center: centers) {\n      System.out.println(center);\n    }\n    // $example off$\n\n    spark.stop();\n  }",
    "comment": "An example demonstrating k-means clustering.\nRun with\n<pre>\nbin/run-example ml.JavaKMeansExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/ServiceUtils.java",
    "type": "method",
    "name": "indexOfDomainMatch",
    "code": "public static int indexOfDomainMatch(String userName) {\n    if (userName == null) {\n      return -1;\n    }\n\n    int idx = userName.indexOf('/');\n    int idx2 = userName.indexOf('@');\n    int endIdx = Math.min(idx, idx2); // Use the earlier match.\n    if (endIdx == -1) {\n      endIdx = Math.max(idx, idx2);\n    }\n    return endIdx;\n  }",
    "comment": "Unless at least one of '/' or '@' was not found, in\nwhich case, user the latter match."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/resources/mng-5640-lifecycleParticipant-afterSession/badplugin/src/main/java/org/apache/maven/its/mng5640/lifecycleParticipantAfterSession/BadMojoRt.java",
    "type": "method",
    "name": "execute",
    "code": "public void execute() {\n        throw new RuntimeException(\"Am being bad!\");\n    }",
    "comment": "A bad mojo that fails execution by throwing a runtime exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "allocateFloatBuffer",
    "code": "public static FloatBuffer allocateFloatBuffer(int numElements) {\n    return ByteBuffer.allocateDirect(numElements * FLOAT_SIZE_BYTES)\n        .order(ByteOrder.nativeOrder())\n        .asFloatBuffer();\n  }",
    "comment": "Allocates a new direct {@link java.nio.FloatBuffer} with native byte order with specified\n\n@param numElements capacity (number of elements) of result buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ArtifactModelSource.java",
    "type": "method",
    "name": "ArtifactModelSource",
    "code": "public ArtifactModelSource(File file, String groupId, String artifactId, String version) {\n        super(file);\n        this.groupId = groupId;\n        this.artifactId = artifactId;\n        this.version = version;\n        this.hashCode = Objects.hash(groupId, artifactId, version);\n    }",
    "comment": "Represents a model pulled from a repository\n\n@since 4.0.0\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "getSelectors",
    "code": "public Set<? extends DiscoverySelector> getSelectors() {\n\t\t\treturn selectors;\n\t\t}",
    "comment": "Returns the selectors contained by this resolution.\n\n@return the set of selectors; never {@code null} but potentially empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/PyTorchAndroid.java",
    "type": "method",
    "name": "setNumThreads",
    "code": "public static void setNumThreads(int numThreads) {\n    if (numThreads < 1) {\n      throw new IllegalArgumentException(\"Number of threads cannot be less than 1\");\n    }\n\n    nativeSetNumThreads(numThreads);\n  }",
    "comment": "Globally sets the number of threads used on native side. Attention: Has global effect, all\nmodules use one thread pool with specified number of threads.\n\n@param numThreads number of threads, must be positive number."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/hexagon/java/src/main/java/org/tensorflow/lite/HexagonDelegate.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n    if (delegateHandle != INVALID_DELEGATE_HANDLE) {\n      deleteDelegate(delegateHandle);\n      delegateHandle = INVALID_DELEGATE_HANDLE;\n    }\n  }",
    "comment": "Frees TFLite resources in C runtime.\n\n<p>User is expected to call this method explicitly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/intercepting-filter/src/main/java/com/iluwatar/intercepting/filter/AddressFilter.java",
    "type": "method",
    "name": "execute",
    "code": "public String execute(Order order) {\n    var result = super.execute(order);\n    if (order.getAddress() == null || order.getAddress().isEmpty()) {\n      return result + \"Invalid address! \";\n    } else {\n      return result;\n    }\n  }",
    "comment": "Concrete implementation of filter This filter is responsible for checking/filtering the input in\nthe address field."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "timeStringAsMs",
    "code": "public static long timeStringAsMs(String str) {\n    return timeStringAs(str, TimeUnit.MILLISECONDS);\n  }",
    "comment": "Convert a time parameter such as (50s, 100ms, or 250us) to milliseconds for internal use. If\nno suffix is provided, the passed number is assumed to be in ms."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/RuleContainer.java",
    "type": "method",
    "name": "getSortedEntries",
    "code": "private List<RuleEntry> getSortedEntries() {\n        List<RuleEntry> ruleEntries = new ArrayList<RuleEntry>(\n                methodRules.size() + testRules.size());\n        for (MethodRule rule : methodRules) {\n            ruleEntries.add(new RuleEntry(rule, RuleEntry.TYPE_METHOD_RULE, orderValues.get(rule)));\n        }\n        for (TestRule rule : testRules) {\n            ruleEntries.add(new RuleEntry(rule, RuleEntry.TYPE_TEST_RULE, orderValues.get(rule)));\n        }\n        Collections.sort(ruleEntries, ENTRY_COMPARATOR);\n        return ruleEntries;\n    }",
    "comment": "Returns entries in the order how they should be applied, i.e. inner-to-outer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/src/mdo/java/InputLocation.java",
    "type": "method",
    "name": "merge",
    "code": "public static InputLocation merge(InputLocation target, InputLocation source, boolean sourceDominant) {\n        if (source == null) {\n            return target;\n        } else if (target == null) {\n            return source;\n        }\n\n        Map<Object, InputLocation> locations;\n        Map<Object, InputLocation> sourceLocations = source.locations;\n        Map<Object, InputLocation> targetLocations = target.locations;\n        if (sourceLocations == null) {\n            locations = targetLocations;\n        } else if (targetLocations == null) {\n            locations = sourceLocations;\n        } else {\n            locations = new LinkedHashMap<>();\n            locations.putAll(sourceDominant ? targetLocations : sourceLocations);\n            locations.putAll(sourceDominant ? sourceLocations : targetLocations);\n        }\n\n        return new InputLocation(target.getLineNumber(), target.getColumnNumber(), target.getSource(), locations);\n    } // -- InputLocation merge( InputLocation, InputLocation, boolean )",
    "comment": "Merges the {@code source} location into the {@code target} location.\n\n@param target the target location\n@param source the source location\n@param sourceDominant the boolean indicating of {@code source} is dominant compared to {@code target}\n@return the merged location"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/collecting-parameter/src/main/java/com/iluwatar/collectingparameter/App.java",
    "type": "method",
    "name": "addValidA3Papers",
    "code": "public static void addValidA3Papers(Queue<PrinterItem> printerItemsCollection) {\n    for (PrinterItem nextItem : printerQueue.getPrinterQueue()) {\n      if (nextItem.paperSize.equals(PaperSizes.A3)) {\n\n        // Encoding the policy into a Boolean: the A3 paper cannot be coloured and double-sided at\n        // the same time\n        var isNotColouredAndSingleSided = !nextItem.isColour && !nextItem.isDoubleSided;\n        if (isNotColouredAndSingleSided) {\n          printerItemsCollection.add(nextItem);\n        }\n      }\n    }\n  }",
    "comment": "Adds A3 document jobs to the collecting parameter according to some policy that can be whatever\nthe client (the print center) wants. The code is similar to the 'addA4Papers' method. The code\ncan be changed to accommodate the wants of the client.\n\n@param printerItemsCollection the collecting parameter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isNotFinal",
    "code": "public static boolean isNotFinal(Class<?> clazz) {\n\t\treturn ReflectionUtils.isNotFinal(clazz);\n\t}",
    "comment": "Determine if the supplied class is not {@code final}.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is not {@code final}\n@since 1.5\n@see java.lang.reflect.Modifier#isFinal(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeMapData.java",
    "type": "method",
    "name": "pointTo",
    "code": "public void pointTo(Object baseObject, long baseOffset, int sizeInBytes) {\n    // Read the numBytes of key array from the first 8 bytes.\n    final long keyArraySize = Platform.getLong(baseObject, baseOffset);\n    assert keyArraySize >= 0 : \"keyArraySize (\" + keyArraySize + \") should >= 0\";\n    assert keyArraySize <= Integer.MAX_VALUE :\n      \"keyArraySize (\" + keyArraySize + \") should <= Integer.MAX_VALUE\";\n    final int valueArraySize = sizeInBytes - (int)keyArraySize - 8;\n    assert valueArraySize >= 0 : \"valueArraySize (\" + valueArraySize + \") should >= 0\";\n\n    keys.pointTo(baseObject, baseOffset + 8, (int)keyArraySize);\n    values.pointTo(baseObject, baseOffset + 8 + keyArraySize, valueArraySize);\n\n    assert keys.numElements() == values.numElements();\n\n    this.baseObject = baseObject;\n    this.baseOffset = baseOffset;\n    this.sizeInBytes = sizeInBytes;\n  }",
    "comment": "Update this UnsafeMapData to point to different backing data.\n\n@param baseObject the base object\n@param baseOffset the offset within the base object\n@param sizeInBytes the size of this map's backing data, in bytes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/ImmutableCollections.java",
    "type": "method",
    "name": "ROProperties",
    "code": "private ROProperties(Properties props) {\n            super();\n            if (props != null) {\n                for (Map.Entry<Object, Object> e : props.entrySet()) {\n                    super.put(e.getKey(), e.getValue());\n                }\n            }\n        }",
    "comment": "Do not use super.putAll, as it may delegate to put which throws an UnsupportedOperationException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "concat",
    "code": "public static UTF8String concat(UTF8String... inputs) {\n    // Compute the total length of the result.\n    long totalLength = 0;\n    for (UTF8String input : inputs) {\n      if (input == null) {\n        return null;\n      }\n      totalLength += input.numBytes;\n    }\n\n    // Allocate a new byte array, and copy the inputs one by one into it.\n    final byte[] result = new byte[Math.toIntExact(totalLength)];\n    int offset = 0;\n    for (UTF8String input : inputs) {\n      int len = input.numBytes;\n      copyMemory(\n        input.base, input.offset,\n        result, BYTE_ARRAY_OFFSET + offset,\n        len);\n      offset += len;\n    }\n    return fromBytes(result);\n  }",
    "comment": "Concatenates input strings together into a single string. Returns null if any input is null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/CountMinSketchImpl.java",
    "type": "method",
    "name": "initTablesWith",
    "code": "private void initTablesWith(int depth, int width, int seed) {\n    this.table = new long[depth][width];\n    this.hashA = new long[depth];\n    Random r = new Random(seed);\n    for (int i = 0; i < depth; ++i) {\n      hashA[i] = r.nextInt(Integer.MAX_VALUE);\n    }\n  }",
    "comment": "We're using a linear hash functions\nof the form (a*x+b) mod p.\na,b are chosen independently for each hash function.\nHowever we can set b = 0 as all it does is shift the results\nwithout compromising their uniformity or independence with\nthe other hashes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "calculateBitSetWidthInBytes",
    "code": "public static int calculateBitSetWidthInBytes(int numFields) {\n    return ((numFields + 63)/ 64) * 8;\n  }",
    "comment": "An Unsafe implementation of Row which is backed by raw memory instead of Java objects.\n\nEach tuple has three parts: [null-tracking bit set] [values] [variable length portion]\n\nThe null-tracking bit set is aligned to 8-byte word boundaries. It stores one bit per field.\n\nIn the `values` region, we store one 8-byte word per field. For fields that hold fixed-length\nprimitive types, such as long, double, or int, we store the value directly in the word. For\nfields with non-primitive or variable-length values, we store a relative offset (w.r.t. the\nbase address of the row) that points to the beginning of the variable-length field, and length\n(they are combined into a long).\n\nInstances of `UnsafeRow` act as pointers to row data stored in this format."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-driven-architecture/src/test/java/com/iluwatar/eda/event/UserCreatedEventTest.java",
    "type": "method",
    "name": "testGetEventType",
    "code": "void testGetEventType() {\n    var user = new User(\"iluwatar\");\n    var userCreatedEvent = new UserCreatedEvent(user);\n    assertEquals(UserCreatedEvent.class, userCreatedEvent.getType());\n  }",
    "comment": "This unit test should correctly return the {@link AbstractEvent} class type when calling the\n{@link AbstractEvent#getType() getType} method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/cache/SoftIdentityMapTest.java",
    "type": "method",
    "name": "shouldHandleNullInputs",
    "code": "void shouldHandleNullInputs() {\n        assertThrows(NullPointerException.class, () -> map.computeIfAbsent(null, k -> \"value\"));\n\n        Object key = new Object();\n        assertThrows(NullPointerException.class, () -> map.computeIfAbsent(key, null));\n    }",
    "comment": "Use a block to ensure the key can be garbage collected\nTry to force garbage collection\nCreate a new key and verify that computation happens again"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/NamespaceChange.java",
    "type": "method",
    "name": "setProperty",
    "code": "static NamespaceChange setProperty(String property, String value) {\n    return new SetProperty(property, value);\n  }",
    "comment": "Create a NamespaceChange for setting a namespace property.\n<p>\nIf the property already exists, it will be replaced with the new value.\n\n@param property the property name\n@param value the new property value\n@return a NamespaceChange for the addition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenBaseLogger.java",
    "type": "method",
    "name": "lazyInit",
    "code": "static void lazyInit() {\n        if (initialized) {\n            return;\n        }\n        initialized = true;\n        init();\n    }",
    "comment": "<p>\nSimple implementation of {@link Logger} that sends all enabled log messages,\nfor all defined loggers, to the console ({@code System.err}). The following\nsystem properties are supported to configure the behavior of this logger:\n\n\n<ul>\n<li><code>maven.logger.logFile</code> - The output target which can\nbe the <em>path</em> to a file, or the special values \"System.out\" and\n\"System.err\". Default is \"System.err\".</li>\n\n<li><code>maven.logger.cacheOutputStream</code> - If the output\ntarget is set to \"System.out\" or \"System.err\" (see preceding entry), by\ndefault, logs will be output to the latest value referenced by\n<code>System.out/err</code> variables. By setting this parameter to true, the\noutput stream will be cached, i.e. assigned once at initialization time and\nre-used independently of the current value referenced by\n<code>System.out/err</code>.</li>\n\n<li><code>maven.logger.defaultLogLevel</code> - Default log level\nfor all instances of SimpleLogger. Must be one of (\"trace\", \"debug\", \"info\",\n\"warn\", \"error\" or \"off\"). If not specified, defaults to \"info\".</li>\n\n<li><code>maven.logger.log.<em>a.b.c</em></code> - Logging detail\nlevel for a SimpleLogger instance named \"a.b.c\". Right-side value must be one\nof \"trace\", \"debug\", \"info\", \"warn\", \"error\" or \"off\". When a SimpleLogger\nnamed \"a.b.c\" is initialized, its level is assigned from this property. If\nunspecified, the level of nearest parent logger will be used, and if none is\nset, then the value specified by\n<code>maven.logger.defaultLogLevel</code> will be used.</li>\n\n<li><code>maven.logger.showDateTime</code> - Set to\n<code>true</code> if you want the current date and time to be included in\noutput messages. Default is <code>false</code></li>\n\n<li><code>maven.logger.dateTimeFormat</code> - The date and time\nformat to be used in the output messages. The pattern describing the date and\ntime format is defined by <a href=\n\"http://docs.oracle.com/javase/1.5.0/docs/api/java/text/SimpleDateFormat.html\">\n<code>SimpleDateFormat</code></a>. If the format is not specified or is\ninvalid, the number of milliseconds since start up will be output.</li>\n\n<li><code>maven.logger.showThreadName</code> -Set to\n<code>true</code> if you want to output the current thread name. Defaults to\n<code>true</code>.</li>\n\n<li>(since version 1.7.33 and 2.0.0-alpha6) <code>maven.logger.showThreadId</code> -\nIf you would like to output the current thread id, then set to\n<code>true</code>. Defaults to <code>false</code>.</li>\n\n<li><code>maven.logger.showLogName</code> - Set to\n<code>true</code> if you want the Logger instance name to be included in\noutput messages. Defaults to <code>true</code>.</li>\n\n<li><code>maven.logger.showShortLogName</code> - Set to\n<code>true</code> if you want the last component of the name to be included\nin output messages. Defaults to <code>false</code>.</li>\n\n<li><code>maven.logger.levelInBrackets</code> - Should the level\nstring be output in brackets? Defaults to <code>false</code>.</li>\n\n<li><code>maven.logger.warnLevelString</code> - The string value\noutput for the warn level. Defaults to <code>WARN</code>.</li>\n\n</ul>\n\n<p>\nIn addition to looking for system properties with the names specified above,\nthis implementation also checks for a class loader resource named\n<code>\"simplelogger.properties\"</code>, and includes any matching definitions\nfrom this resource (if it exists).\n\n\n<p>\nWith no configuration, the default output includes the relative time in\nmilliseconds, thread name, the level, logger name, and the message followed\nby the line separator for the host. In log4j terms it amounts to the \"%r [%t]\n%level %logger - %m%n\" pattern.\n\n<p>\nSample output follows.\n\n\n<pre>\n176 [main] INFO examples.Sort - Populating an array of 2 elements in reverse order.\n225 [main] INFO examples.SortAlgo - Entered the sort method.\n304 [main] INFO examples.SortAlgo - Dump of integer array:\n317 [main] INFO examples.SortAlgo - Element [0] = 0\n331 [main] INFO examples.SortAlgo - Element [1] = 1\n343 [main] INFO examples.Sort - The next log statement should be an error message.\n346 [main] ERROR examples.SortAlgo - Tried to dump an uninitialized array.\nat org.log4j.examples.SortAlgo.dump(SortAlgo.java:58)\nat org.log4j.examples.Sort.main(Sort.java:64)\n467 [main] INFO  examples.Sort - Exiting main method.\n</pre>\n\n<p>\nThis implementation is heavily inspired by\n<a href=\"http://commons.apache.org/logging/\">Apache Commons Logging</a>'s\nSimpleLog.\n\n\n@author Ceki G&uuml;lc&uuml;\n@author Scott Sanders\n@author Rod Waldhoff\n@author Robert Burrell Donkin\n@author C&eacute;drik LIME"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String expected, String actual) {\n        assertEquals(null, expected, actual);\n    }",
    "comment": "Asserts that two Strings are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(boolean condition) {\n        assertFalse(null, condition);\n    }",
    "comment": "Asserts that a condition is false. If it isn't it throws an\n{@link AssertionError} without a message.\n\n@param condition condition to be checked"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/collection-pipeline/src/main/java/com/iluwatar/collectionpipeline/ImperativeProgramming.java",
    "type": "method",
    "name": "getModelsAfter2000",
    "code": "public static List<String> getModelsAfter2000(List<Car> cars) {\n    List<Car> carsSortedByYear = new ArrayList<>();\n\n    for (Car car : cars) {\n      if (car.year() > 2000) {\n        carsSortedByYear.add(car);\n      }\n    }\n\n    Collections.sort(\n        carsSortedByYear,\n        new Comparator<Car>() {\n        });\n\n    List<String> models = new ArrayList<>();\n    for (Car car : carsSortedByYear) {\n      models.add(car.model());\n    }\n\n    return models;\n  }",
    "comment": "Method to return the car models built after year 2000 using for loops.\n\n@param cars {@link List} of {@link Car} to iterate over\n@return {@link List} of {@link String} of car models built after year 2000"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "requestedCiphers",
    "code": "public Builder requestedCiphers(String[] requestedCiphers) {\n      this.requestedCiphers = requestedCiphers;\n      return this;\n    }",
    "comment": "Sets the requested cipher suites, i.e., \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", etc\n\n@param requestedCiphers The requested ciphers\n@return The builder object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Short unexpected, short actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Short) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestEngine.java",
    "type": "method",
    "name": "createExecutorService",
    "code": "protected HierarchicalTestExecutorService createExecutorService(ExecutionRequest request) {\n\t\treturn new SameThreadHierarchicalTestExecutorService();\n\t}",
    "comment": "Create the {@linkplain HierarchicalTestExecutorService executor service}\nto use for executing the supplied {@linkplain ExecutionRequest request}.\n\n<p>An engine may use the information in the supplied <em>request</em>\nsuch as the contained\n{@linkplain ExecutionRequest#getConfigurationParameters() configuration parameters}\nto decide what kind of service to return or how to configure it.\n\n<p>By default, this method returns an instance of\n{@link SameThreadHierarchicalTestExecutorService}.\n\n@param request the request about to be executed\n@since 1.3\n@see ForkJoinPoolHierarchicalTestExecutorService\n@see SameThreadHierarchicalTestExecutorService"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/demo/app/src/main/java/com/example/android/tflitecamerademo/Camera2BasicFragment.java",
    "type": "method",
    "name": "setUpCameraOutputs",
    "code": "private void setUpCameraOutputs(int width, int height) {\n    Activity activity = getActivity();\n    CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);\n    try {\n      for (String cameraId : manager.getCameraIdList()) {\n        CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);\n\n        // We don't use a front facing camera in this sample.\n        Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);\n        if (facing != null && facing == CameraCharacteristics.LENS_FACING_FRONT) {\n          continue;\n        }\n\n        StreamConfigurationMap map =\n            characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);\n        if (map == null) {\n          continue;\n        }\n\n        // // For still image captures, we use the largest available size.\n        Size largest =\n            Collections.max(\n                Arrays.asList(map.getOutputSizes(ImageFormat.JPEG)), new CompareSizesByArea());\n        imageReader =\n            ImageReader.newInstance(\n                largest.getWidth(), largest.getHeight(), ImageFormat.JPEG, /*maxImages*/ 2);\n\n        // Find out if we need to swap dimension to get the preview size relative to sensor\n        // coordinate.\n        int displayRotation = activity.getWindowManager().getDefaultDisplay().getRotation();\n        // noinspection ConstantConditions\n        /* Orientation of the camera sensor */\n        int sensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);\n        boolean swappedDimensions = false;\n        switch (displayRotation) {\n          case Surface.ROTATION_0:\n          case Surface.ROTATION_180:\n            if (sensorOrientation == 90 || sensorOrientation == 270) {\n              swappedDimensions = true;\n            }\n            break;\n          case Surface.ROTATION_90:\n          case Surface.ROTATION_270:\n            if (sensorOrientation == 0 || sensorOrientation == 180) {\n              swappedDimensions = true;\n            }\n            break;\n          default:\n            Log.e(TAG, \"Display rotation is invalid: \" + displayRotation);\n        }\n\n        Point displaySize = new Point();\n        activity.getWindowManager().getDefaultDisplay().getSize(displaySize);\n        int rotatedPreviewWidth = width;\n        int rotatedPreviewHeight = height;\n        int maxPreviewWidth = displaySize.x;\n        int maxPreviewHeight = displaySize.y;\n\n        if (swappedDimensions) {\n          rotatedPreviewWidth = height;\n          rotatedPreviewHeight = width;\n          maxPreviewWidth = displaySize.y;\n          maxPreviewHeight = displaySize.x;\n        }\n\n        if (maxPreviewWidth > MAX_PREVIEW_WIDTH) {\n          maxPreviewWidth = MAX_PREVIEW_WIDTH;\n        }\n\n        if (maxPreviewHeight > MAX_PREVIEW_HEIGHT) {\n          maxPreviewHeight = MAX_PREVIEW_HEIGHT;\n        }\n\n        previewSize =\n            chooseOptimalSize(\n                map.getOutputSizes(SurfaceTexture.class),\n                rotatedPreviewWidth,\n                rotatedPreviewHeight,\n                maxPreviewWidth,\n                maxPreviewHeight,\n                largest);\n\n        // We fit the aspect ratio of TextureView to the size of preview we picked.\n        int orientation = getResources().getConfiguration().orientation;\n        if (orientation == Configuration.ORIENTATION_LANDSCAPE) {\n          textureView.setAspectRatio(previewSize.getWidth(), previewSize.getHeight());\n        } else {\n          textureView.setAspectRatio(previewSize.getHeight(), previewSize.getWidth());\n        }\n\n        this.cameraId = cameraId;\n        return;\n      }\n    } catch (CameraAccessException e) {\n      Log.e(TAG, \"Failed to access Camera\", e);\n    } catch (NullPointerException e) {\n      // Currently an NPE is thrown when the Camera2API is used but not supported on the\n      // device this code runs.\n      ErrorDialog.newInstance(getString(R.string.camera_error))\n          .show(getChildFragmentManager(), FRAGMENT_DIALOG);\n    }\n  }",
    "comment": "Sets up member variables related to camera.\n\n@param width The width of available size for camera preview\n@param height The height of available size for camera preview"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/Interpreter.java",
    "type": "method",
    "name": "setAllowBufferHandleOutput",
    "code": "public Options setAllowBufferHandleOutput(boolean allow) {\n      this.allowBufferHandleOutput = allow;\n      return this;\n    }",
    "comment": "Advanced: Set if buffer handle output is allowed.\n\n<p>When a {@link Delegate} supports hardware acceleration, the interpreter will make the data\nof output tensors available in the CPU-allocated tensor buffers by default. If the client can\nconsume the buffer handle directly (e.g. reading output from OpenGL texture), it can set this\nflag to false, avoiding the copy of data to the CPU buffer. The delegate documentation should\nindicate whether this is supported and how it can be used.\n\n<p>WARNING: This is an experimental interface that is subject to change."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(short unexpected, Short actual, String message) {\n\t\tAssertNotEquals.assertNotEquals((Short) unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/double-dispatch/src/test/java/com/iluwatar/doubledispatch/RectangleTest.java",
    "type": "method",
    "name": "testToString",
    "code": "void testToString() {\n    final var rectangle = new Rectangle(1, 2, 3, 4);\n    assertEquals(\"[1,2,3,4]\", rectangle.toString());\n  }",
    "comment": "Test if the values passed through the constructor matches the values in the {@link #toString()}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ExclusiveResource.java",
    "type": "method",
    "name": "globalKeyFirst",
    "code": "private static Comparator<String> globalKeyFirst() {\n\t\treturn comparing(key -> !GLOBAL_KEY.equals(key));\n\t}",
    "comment": "Key of the global resource lock that all direct children of the engine\ndescriptor acquire in {@linkplain LockMode#READ read mode} by default:\n{@value}\n\n<p>If any node {@linkplain Node#getExclusiveResources() requires} an\nexclusive resource with the same key in\n{@linkplain LockMode#READ_WRITE read-write mode}, the lock will be\ncoarsened to be acquired by the node's ancestor that is a direct child of\nthe engine descriptor and all of the ancestor's descendants will be\nforced to run in the {@linkplain ExecutionMode#SAME_THREAD same thread}.\n\n@since 1.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/eclipse/sisu/plexus/PlexusXmlBeanConverter.java",
    "type": "method",
    "name": "newImplementation",
    "code": "private static <T> T newImplementation(final Class<T> clazz, final String value) {\n        try {\n            return clazz.getConstructor(String.class).newInstance(value);\n        } catch (final Exception e) {\n            final Throwable cause = e instanceof InvocationTargetException ? e.getCause() : e;\n            throw new IllegalArgumentException(String.format(CONVERSION_ERROR, value, clazz), cause);\n        } catch (final LinkageError e) {\n            throw new IllegalArgumentException(String.format(CONVERSION_ERROR, value, clazz), e);\n        }\n    }",
    "comment": "Creates an instance of the given implementation using the given string, assumes a public string constructor.\n\n@param clazz The implementation type\n@param value The string argument\n@return Instance of given implementation, constructed using the given string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getCompileDependencies",
    "code": "public List<Dependency> getCompileDependencies() {\n        Set<Artifact> artifacts = getArtifacts();\n\n        if ((artifacts == null) || artifacts.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Dependency> list = new ArrayList<>(artifacts.size());\n\n        for (Artifact a : getArtifacts()) {\n            if (isCompilePathElement(a.getScope())) {\n                Dependency dependency = new Dependency();\n\n                dependency.setArtifactId(a.getArtifactId());\n                dependency.setGroupId(a.getGroupId());\n                dependency.setVersion(a.getVersion());\n                dependency.setScope(a.getScope());\n                dependency.setType(a.getType());\n                dependency.setClassifier(a.getClassifier());\n\n                list.add(dependency);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }",
    "comment": "TODO let the scope handler deal with this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertArrayEqualsAssertionsTests.java",
    "type": "method",
    "name": "assertArrayEqualsWithNulls",
    "code": "void assertArrayEqualsWithNulls() {\n\t\tassertArrayEquals(null, (boolean[]) null);\n\t\tassertArrayEquals(null, (char[]) null);\n\t\tassertArrayEquals(null, (byte[]) null);\n\t\tassertArrayEquals(null, (int[]) null);\n\t\tassertArrayEquals(null, (long[]) null);\n\t\tassertArrayEquals(null, (float[]) null);\n\t\tassertArrayEquals(null, (double[]) null);\n\t\tassertArrayEquals(null, (Object[]) null);\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/PerLookupWagon.java",
    "type": "method",
    "name": "getSupportedProtocols",
    "code": "public String[] getSupportedProtocols() {\n        return new String[] {\"perlookup\"};\n}",
    "comment": "Wagon with per-lookup instantiation strategy."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/GraphOperation.java",
    "type": "method",
    "name": "equals",
    "code": "public boolean equals(Object o) {\n    if (o == this) {\n      return true;\n    }\n    if (!(o instanceof GraphOperation)) {\n      return false;\n    }\n    GraphOperation that = (GraphOperation) o;\n    if (graph != that.graph) {\n      return false;\n    }\n\n    Graph.Reference r = graph.ref();\n    try {\n      return getUnsafeNativeHandle() == that.getUnsafeNativeHandle();\n    } finally {\n      r.close();\n    }\n  }",
    "comment": "The graph object is known to be identical here, so this one\nreference is sufficient to validate the use of native pointers\nin both objects."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java",
    "type": "method",
    "name": "visitFileFailed",
    "code": "public FileVisitResult visitFileFailed(Path file, IOException exc) {\n\t\t\t\t\tLOGGER.trace(exc, () -> \"visitFileFailed: \" + file);\n\t\t\t\t\tif (exc instanceof NoSuchFileException && !Files.exists(file, LinkOption.NOFOLLOW_LINKS)) {\n\t\t\t\t\t\treturn CONTINUE;\n\t\t\t\t\t}\n\t\t\t\t\tresetPermissionsAndTryToDeleteAgain(file, exc);\n\t\t\t\t\treturn CONTINUE;\n\t\t\t\t}",
    "comment": "IOException includes `AccessDeniedException` thrown by non-readable or non-executable flags"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/map-reduce/src/main/java/com/iluwatar/Reducer.java",
    "type": "method",
    "name": "reduce",
    "code": "public static List<Map.Entry<String, Integer>> reduce(Map<String, List<Integer>> grouped) {\n    Map<String, Integer> reduced = new HashMap<>();\n    for (Map.Entry<String, List<Integer>> entry : grouped.entrySet()) {\n      reduced.put(entry.getKey(), entry.getValue().stream().mapToInt(Integer::intValue).sum());\n    }\n\n    List<Map.Entry<String, Integer>> result = new ArrayList<>(reduced.entrySet());\n    result.sort(Map.Entry.comparingByValue(Comparator.reverseOrder()));\n    return result;\n  }",
    "comment": "Sums the occurrences of each word and sorts the results in descending order.\n\n@param grouped A map where keys are words and values are lists of their occurrences.\n@return A sorted list of word counts in descending order."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/console/tasks/ColorPaletteTests.java",
    "type": "method",
    "name": "singleOverride",
    "code": "void singleOverride() {\n\t\t\tString properties = \"\"\"\n\t\t\t\t\tSUCCESSFUL = 35;1\n\t\t\t\t\t\"\"\";\n\t\t\tColorPalette colorPalette = new ColorPalette(new StringReader(properties));\n\n\t\t\tString actual = colorPalette.paint(Style.SUCCESSFUL, \"text\");\n\n\t\t\tassertEquals(\"\\u001B[35;1mtext\\u001B[0m\", actual);\n\t\t}",
    "comment": "Unit tests for {@link ColorPalette}.\n\n@since 1.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/TestClass.java",
    "type": "method",
    "name": "getAnnotatedMethods",
    "code": "public List<FrameworkMethod> getAnnotatedMethods() {\n        List<FrameworkMethod> methods = collectValues(methodsForAnnotations);\n        Collections.sort(methods, METHOD_COMPARATOR);\n        return methods;\n    }",
    "comment": "Returns, efficiently, all the non-overridden methods in this class and\nits superclasses that are annotated}.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ConditionEvaluationResult.java",
    "type": "method",
    "name": "disabled",
    "code": "public static ConditionEvaluationResult disabled(String reason, String customReason) {\n\t\tif (StringUtils.isBlank(customReason)) {\n\t\t\treturn disabled(reason);\n\t\t}\n\t\treturn disabled(String.format(\"%s ==> %s\", reason, customReason));\n\t}",
    "comment": "Factory for creating <em>disabled</em> results with custom reasons\nadded by the user.\n\n@param reason the default reason why the container or test should be disabled\n@param customReason the custom reason why the container or test should be disabled\n@return a disabled {@code ConditionEvaluationResult} with the given reasons\n@since 5.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/presentation-model/src/test/java/com/iluwatar/presentationmodel/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link App}\nthrows an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/BenchmarkAccuracyImpl.java",
    "type": "method",
    "name": "benchmarkDelegatesAndExportReport",
    "code": "private boolean benchmarkDelegatesAndExportReport() {\n    Log.i(\n        TAG,\n        \"Running accuracy benchmark with TFLiteSettings JSON files: \"\n            + Arrays.toString(tfliteSettingsJsonFiles));\n    List<TfLiteSettingsListEntry> tfliteSettingsList =\n        DelegatePerformanceBenchmark.loadTfLiteSettingsList(tfliteSettingsJsonFiles);\n    if (tfliteSettingsList.size() < 2) {\n      Log.e(TAG, \"Failed to load the TFLiteSettings JSON file.\");\n      return false;\n    }\n    String[] assets;\n    try {\n      assets = context.getAssets().list(ACCURACY_FOLDER_NAME);\n    } catch (IOException e) {\n      Log.e(TAG, \"Failed to list files from assets folder.\", e);\n      return false;\n    }\n    for (String asset : assets) {\n      if (!asset.endsWith(\".tflite\")) {\n        Log.i(TAG, asset + \" is not a model file. Skipping.\");\n        continue;\n      }\n      String modelResultPath;\n      String modelName = DelegatePerformanceBenchmark.getModelName(asset);\n      try {\n        modelResultPath =\n            DelegatePerformanceBenchmark.createResultFolder(\n                context.getFilesDir(), ACCURACY_FOLDER_NAME + \"/\" + modelName);\n      } catch (IOException e) {\n        Log.e(TAG, \"Failed to create result folder for \" + modelName + \". Exiting application.\", e);\n        return false;\n      }\n      try (AssetFileDescriptor modelFileDescriptor =\n          context.getAssets().openFd(ACCURACY_FOLDER_NAME + \"/\" + asset)) {\n        List<RawDelegateMetricsEntry> rawDelegateMetricsEntries = new ArrayList<>();\n        for (TfLiteSettingsListEntry tfliteSettingsListEntry : tfliteSettingsList) {\n          BenchmarkEvent benchmarkEvent =\n              DelegatePerformanceBenchmark.runAccuracyBenchmark(\n                  tfliteSettingsListEntry,\n                  modelFileDescriptor.getParcelFileDescriptor().getFd(),\n                  modelFileDescriptor.getStartOffset(),\n                  modelFileDescriptor.getLength(),\n                  modelResultPath);\n\n          rawDelegateMetricsEntries.add(\n              AccuracyBenchmarkReport.parseResults(benchmarkEvent, tfliteSettingsListEntry));\n        }\n        report.addModelBenchmarkReport(\n            AccuracyBenchmarkReport.create(modelName, rawDelegateMetricsEntries));\n      } catch (IOException e) {\n        Log.e(TAG, \"Failed to open assets file \" + asset, e);\n        return false;\n      }\n    }\n    report.export();\n    TfLiteSettingsListEntry testTarget = tfliteSettingsList.get(tfliteSettingsList.size() - 1);\n    Log.i(\n        TAG,\n        String.format(\n            \"Accuracy benchmark result for %s: %s.\", testTarget.filePath(), report.result()));\n    return true;\n  }",
    "comment": "Computes the aggregated results and export the report to local files."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "matches",
    "code": "public static Resolution matches(Set<Match> matches) {\n\t\t\tPreconditions.containsNoNullElements(matches, \"matches must not contain null elements\");\n\t\t\tPreconditions.notEmpty(matches, \"matches must not be empty\");\n\t\t\treturn new Resolution(matches, emptySet());\n\t\t}",
    "comment": "Factory for creating a resolution that contains the supplied\n{@link Match Matches}.\n\n@param matches the resolved {@code Matches}; never {@code null} or\nempty\n@return an resolution that contains the supplied {@code Matches};\nnever {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraActivity.java",
    "type": "method",
    "name": "requestPermission",
    "code": "private void requestPermission() {\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n      if (shouldShowRequestPermissionRationale(PERMISSION_CAMERA) ||\n          shouldShowRequestPermissionRationale(PERMISSION_STORAGE)) {\n        Toast.makeText(CameraActivity.this,\n            \"Camera AND storage permission are required for this demo\", Toast.LENGTH_LONG).show();\n      }\n      requestPermissions(new String[] {PERMISSION_CAMERA, PERMISSION_STORAGE}, PERMISSIONS_REQUEST);\n  }\n\n  private boolean isHardwareLevelSupported(\n      CameraCharacteristics characteristics, int requiredLevel) {\n    int deviceLevel = characteristics.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);\n    if (deviceLevel == CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY) {\n      return requiredLevel == deviceLevel;\n    }\n    return requiredLevel <= deviceLevel;\n  }\n\n  private String chooseCamera() {\n    final CameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);\n    try {\n      for (final String cameraId : manager.getCameraIdList()) {\n        final CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);\n\n        final Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);\n        if (facing != null && facing == CameraCharacteristics.LENS_FACING_FRONT) {\n          continue;\n        }\n\n        final StreamConfigurationMap map =\n            characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);\n\n        if (map == null) {\n          continue;\n        }\n\n        useCamera2API = (facing == CameraCharacteristics.LENS_FACING_EXTERNAL)\n            || isHardwareLevelSupported(characteristics, \n                                        CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL);\n        LOGGER.i(\"Camera API lv2?: %s\", useCamera2API);\n        return cameraId;\n      }\n    } catch (CameraAccessException e) {\n      LOGGER.e(e, \"Not allowed to access camera\");\n    }\n\n    return null;\n  }\n\n  protected void setFragment() {\n    String cameraId = chooseCamera();\n    if (cameraId == null) {\n      Toast.makeText(this, \"No Camera Detected\", Toast.LENGTH_SHORT).show();\n      finish();\n    }\n\n    Fragment fragment;\n    if (useCamera2API) {\n      CameraConnectionFragment camera2Fragment =\n          CameraConnectionFragment.newInstance(\n              new CameraConnectionFragment.ConnectionCallback() {\n              },\n              this,\n              getLayoutId(),\n              getDesiredPreviewFrameSize());\n\n      camera2Fragment.setCamera(cameraId);\n      fragment = camera2Fragment;\n    } else {\n      fragment =\n          new LegacyCameraConnectionFragment(this, getLayoutId(), getDesiredPreviewFrameSize());\n    }\n\n    getFragmentManager()\n        .beginTransaction()\n        .replace(R.id.container, fragment)\n        .commit();\n  }\n\n  protected void fillBytes(final Plane[] planes, final byte[][] yuvBytes) {\n    for (int i = 0; i < planes.length; ++i) {\n      final ByteBuffer buffer = planes[i].getBuffer();\n      if (yuvBytes[i] == null) {\n        LOGGER.d(\"Initializing buffer %d at size %d\", i, buffer.capacity());\n        yuvBytes[i] = new byte[buffer.capacity()];\n      }\n      buffer.get(yuvBytes[i]);\n    }\n  }\n\n  public boolean isDebug() {\n    return debug;\n  }\n\n  public void requestRender() {\n    final OverlayView overlay = (OverlayView) findViewById(R.id.debug_overlay);\n    if (overlay != null) {\n      overlay.postInvalidate();\n    }\n  }\n\n  public void addCallback(final OverlayView.DrawCallback callback) {\n    final OverlayView overlay = (OverlayView) findViewById(R.id.debug_overlay);\n    if (overlay != null) {\n      overlay.addCallback(callback);\n    }\n  }\n\n  public void onSetDebug(final boolean debug) {}\n\n  @Override\n  public boolean onKeyDown(final int keyCode, final KeyEvent event) {\n    if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_UP\n            || keyCode == KeyEvent.KEYCODE_BUTTON_L1 || keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {\n      debug = !debug;\n      requestRender();\n      onSetDebug(debug);\n      return true;\n    }\n    return super.onKeyDown(keyCode, event);\n  }\n\n  protected void readyForNextImage() {\n    if (postInferenceCallback != null) {\n      postInferenceCallback.run();\n    }\n  }\n\n  protected int getScreenOrientation() {\n    switch (getWindowManager().getDefaultDisplay().getRotation()) {\n      case Surface.ROTATION_270:\n        return 270;\n      case Surface.ROTATION_180:\n        return 180;\n      case Surface.ROTATION_90:\n        return 90;\n      default:\n        return 0;\n    }\n  }\n\n  protected abstract void processImage();\n\n  protected abstract void onPreviewSizeChosen(final Size size, final int rotation);\n  protected abstract int getLayoutId();\n  protected abstract Size getDesiredPreviewFrameSize();\n}",
    "comment": "Returns true if the device supports the required hardware level, or better.\ndeviceLevel is not LEGACY, can use numerical sort\nWe don't use a front facing camera in this sample.\nFallback to camera1 API for internal cameras that don't have full support.\nThis should help with legacy situations where using the camera2 API causes\ndistorted or otherwise broken previews.\nBecause of the variable row stride it's not possible to know in\nadvance the actual necessary dimensions of the yuv planes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/aether/ReverseTreeRepositoryListener.java",
    "type": "method",
    "name": "lookupCollectStepData",
    "code": "static CollectStepData lookupCollectStepData(RequestTrace trace) {\n        CollectStepData collectStepTrace = null;\n        while (trace != null) {\n            if (trace.getData() instanceof CollectStepData collectStepData) {\n                collectStepTrace = collectStepData;\n                break;\n            }\n            trace = trace.getParent();\n        }\n        return collectStepTrace;\n    }",
    "comment": "Unravels trace tree (going upwards from current node), looking for {@link CollectStepData} trace data.\nThis method may return {@code null} if no collect step data found in passed trace data or it's parents.\n<p>\nVisible for testing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-repository-metadata/src/test/java/org/apache/maven/artifact/repository/metadata/MetadataTest.java",
    "type": "method",
    "name": "mergeLegacyWithSnapshotLegacy",
    "code": "void mergeLegacyWithSnapshotLegacy() {\n        Metadata source = createMetadataFromArtifact(artifact);\n        Date before = new Date(System.currentTimeMillis() - 5000);\n        Date after = new Date(System.currentTimeMillis());\n        addSnapshotVersionLegacy(target.getVersioning(), before, 1);\n        addSnapshotVersionLegacy(source.getVersioning(), after, 2);\n        assertTrue(target.merge(source));\n        assertEquals(0, target.getVersioning().getSnapshotVersions().size());\n        assertEquals(formatDate(after, false), target.getVersioning().getLastUpdated());\n        assertEquals(\n                formatDate(after, true), target.getVersioning().getSnapshot().getTimestamp());\n    }",
    "comment": "legacy metadata did not have \"versioning.snapshotVersions\"\nalthough nothing has changed merge returns true, as the last modified date is equal\nTODO: improve merge here?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/business-delegate/src/test/java/com/iluwatar/business/delegate/BusinessDelegateTest.java",
    "type": "method",
    "name": "testBusinessDelegate",
    "code": "void testBusinessDelegate() {\n\n    // setup a client object\n    var client = new MobileClient(businessDelegate);\n\n    // action\n    client.playbackMovie(\"Die hard\");\n\n    // verifying that the businessDelegate was used by client during playbackMovie() method.\n    verify(businessDelegate).playbackMovie(anyString());\n    verify(netflixService).doProcessing();\n\n    // action\n    client.playbackMovie(\"Maradona\");\n\n    // verifying that the businessDelegate was used by client during doTask() method.\n    verify(businessDelegate, times(2)).playbackMovie(anyString());\n    verify(youTubeService).doProcessing();\n  }",
    "comment": "In this example the client ({@link MobileClient}) utilizes a business delegate ( {@link\nBusinessDelegate}) to execute a task. The Business Delegate then selects the appropriate\nservice and makes the service call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "removeAppAttemptPathInfoFromDB",
    "code": "void removeAppAttemptPathInfoFromDB(String appId, int attemptId) {\n    AppAttemptId appAttemptId = new AppAttemptId(appId, attemptId);\n    if (db != null && AppsWithRecoveryDisabled.isRecoveryEnabledForApp(appId)) {\n      try {\n        byte[] key = getDbAppAttemptPathsKey(appAttemptId);\n        db.delete(key);\n      } catch (Exception e) {\n        logger.error(\"Failed to remove the application attempt {} local path in DB\", e,\n          MDC.of(LogKeys.APP_ATTEMPT_ID$.MODULE$, appAttemptId));\n      }\n    }\n  }",
    "comment": "Remove the application attempt local paths information from the DB. This method is being\ninvoked within the lock from the ConcurrentHashmap appsShuffleInfo on the specific\napplicationId."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/ClockSource.java",
    "type": "method",
    "name": "elapsedDisplayString",
    "code": "static String elapsedDisplayString(long startTime, long endTime) {\n      return CLOCK.elapsedDisplayString0(startTime, endTime);\n   }",
    "comment": "Get a String representation of the elapsed time in appropriate magnitude terminology.\n\n@param startTime an opaque time-stamp\n@param endTime an opaque time-stamp\n@return a string representation of the elapsed time interval"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventStatistics.java",
    "type": "method",
    "name": "reportingEntryPublished",
    "code": "public EventStatistics reportingEntryPublished(long expected) {\n\t\tthis.executables.add(\n\t\t\t() -> assertEquals(expected, this.events.reportingEntryPublished().count(), \"reporting entry published\"));\n\t\treturn this;\n\t}",
    "comment": "Specify the number of expected <em>reporting entry publication</em> events.\n\n@param expected the expected number of events\n@return this {@code EventStatistics} for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/aggregate/Max.java",
    "type": "method",
    "name": "Max",
    "code": "public Max(Expression column) { this.input = column; }",
    "comment": "An aggregate function that returns the maximum value in a group.\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/collection-pipeline/src/main/java/com/iluwatar/collectionpipeline/ImperativeProgramming.java",
    "type": "method",
    "name": "getGroupingOfCarsByCategory",
    "code": "public static Map<Category, List<Car>> getGroupingOfCarsByCategory(List<Car> cars) {\n    Map<Category, List<Car>> groupingByCategory = new HashMap<>();\n    for (Car car : cars) {\n      if (groupingByCategory.containsKey(car.category())) {\n        groupingByCategory.get(car.category()).add(car);\n      } else {\n        List<Car> categoryCars = new ArrayList<>();\n        categoryCars.add(car);\n        groupingByCategory.put(car.category(), categoryCars);\n      }\n    }\n    return groupingByCategory;\n  }",
    "comment": "Method to group cars by category using for loops.\n\n@param cars {@link List} of {@link Car} to be used for grouping\n@return {@link Map} with category as key and cars belonging to that category as value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/MethodSelectorResolver.java",
    "type": "method",
    "name": "matchMethodDescription",
    "code": "private static Filter matchMethodDescription(final Description desiredDescription) {\n\t\tString desiredMethodName = DescriptionUtils.getMethodName(desiredDescription);\n\t\treturn new Filter() {\n\n\t\t\t\t// explicitly check if any children want to run\n\t\t\t\tfor (Description each : description.getChildren()) {\n\t\t\t\t\tif (shouldRun(each)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tprivate boolean isParameterizedMethod(Description description) {\n\t\t\t\tString methodName = DescriptionUtils.getMethodName(description);\n\t\t\t\treturn methodName.startsWith(desiredMethodName + \"[\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String describe() {\n\t\t\t\treturn String.format(\"Method %s\", desiredDescription.getDisplayName());\n\t\t\t}\n\t\t};",
    "comment": "The method {@link Filter#matchMethodDescription(Description)} returns a\nfilter that does not account for the case when the description is for a\n{@link org.junit.runners.Parameterized} runner."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/AnnotationBasedArgumentsProvider.java",
    "type": "method",
    "name": "provideArguments",
    "code": "protected Stream<? extends Arguments> provideArguments(ExtensionContext context, A annotation) {\n\t\tthrow new JUnitException(String.format(\n\t\t\t\"AnnotationBasedArgumentsProvider does not override the provideArguments(ParameterDeclarations, ExtensionContext, Annotation) method. \"\n\t\t\t\t\t+ \"Please report this issue to the maintainers of %s.\",\n\t\t\tgetClass().getName()));\n\t}",
    "comment": "Provide a {@link Stream} of {@link Arguments} &mdash; based on metadata in the\nprovided annotation &mdash; to be passed to a {@code @ParameterizedTest} method.\n\n@param context the current extension context; never {@code null}\n@param annotation the annotation to process; never {@code null}\n@return a stream of arguments; never {@code null}\n@deprecated Please implement\n{@link #provideArguments(ParameterDeclarations, ExtensionContext, Annotation)}\ninstead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/SameThreadDispatcher.java",
    "type": "method",
    "name": "onChannelReadEvent",
    "code": "public void onChannelReadEvent(AbstractNioChannel channel, Object readObject, SelectionKey key) {\n    /*\n     * Calls the associated handler to notify the read event where application specific code\n     * resides.\n     */\n    channel.getHandler().handleChannelRead(channel, readObject, key);\n  }",
    "comment": "Dispatches the read event in the context of caller thread. <br>\nNote this is a blocking call. It returns only after the associated handler has handled the read\nevent."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/ovic/src/main/java/org/tensorflow/ovic/OvicBenchmarker.java",
    "type": "method",
    "name": "loadsInputToByteBuffer",
    "code": "protected void loadsInputToByteBuffer() {\n    if (imgData == null || intValues == null) {\n      throw new RuntimeException(\"Benchmarker is not yet ready to test.\");\n    }\n    // Convert the image to ByteBuffer.\n    imgData.rewind();\n    int pixel = 0;\n    long startTime = SystemClock.uptimeMillis();\n\n    for (int i = 0; i < imgHeight; ++i) {\n      for (int j = 0; j < imgWidth; ++j) {\n        final int pixelValue = intValues[pixel++];\n        imgData.put((byte) ((pixelValue >> 16) & 0xFF));\n        imgData.put((byte) ((pixelValue >> 8) & 0xFF));\n        imgData.put((byte) (pixelValue & 0xFF));\n      }\n    }\n    long endTime = SystemClock.uptimeMillis();\n    Log.d(TAG, \"Timecost to put values into ByteBuffer: \" + Long.toString(endTime - startTime));\n  }",
    "comment": "Loads input buffer from intValues into ByteBuffer for the interpreter. Input buffer must be\nloaded in intValues and output will be placed in imgData."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaUnivariateFeatureSelectorExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaUnivariateFeatureSelectorExample\")\n      .getOrCreate();\n\n    // $example on$\n    List<Row> data = Arrays.asList(\n      RowFactory.create(1, Vectors.dense(1.7, 4.4, 7.6, 5.8, 9.6, 2.3), 3.0),\n      RowFactory.create(2, Vectors.dense(8.8, 7.3, 5.7, 7.3, 2.2, 4.1), 2.0),\n      RowFactory.create(3, Vectors.dense(1.2, 9.5, 2.5, 3.1, 8.7, 2.5), 3.0),\n      RowFactory.create(4, Vectors.dense(3.7, 9.2, 6.1, 4.1, 7.5, 3.8), 2.0),\n      RowFactory.create(5, Vectors.dense(8.9, 5.2, 7.8, 8.3, 5.2, 3.0), 4.0),\n      RowFactory.create(6, Vectors.dense(7.9, 8.5, 9.2, 4.0, 9.4, 2.1), 4.0)\n    );\n    StructType schema = new StructType(new StructField[]{\n\n    Dataset<Row> df = spark.createDataFrame(data, schema);\n\n    UnivariateFeatureSelector selector = new UnivariateFeatureSelector()\n      .setFeatureType(\"continuous\")\n      .setLabelType(\"categorical\")\n      .setSelectionMode(\"numTopFeatures\")\n      .setSelectionThreshold(1)\n      .setFeaturesCol(\"features\")\n      .setLabelCol(\"label\")\n      .setOutputCol(\"selectedFeatures\");\n\n    Dataset<Row> result = selector.fit(df).transform(df);\n\n    System.out.println(\"UnivariateFeatureSelector output with top \"\n        + selector.getSelectionThreshold() + \" features selected using f_classif\");\n    result.show();\n\n    // $example off$\n    spark.stop();\n  }\n}",
    "comment": "An example for UnivariateFeatureSelector.\nRun with\n<pre>\nbin/run-example ml.JavaUnivariateFeatureSelectorExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/normalization/DefaultModelNormalizer.java",
    "type": "method",
    "name": "injectDependencyDefaults",
    "code": "private void injectDependencyDefaults(List<Dependency> dependencies) {\n        for (Dependency dependency : dependencies) {\n            if (StringUtils.isEmpty(dependency.getScope())) {\n                dependency.setScope(\"compile\");\n            }\n        }\n    }",
    "comment": "we cannot set this directly in the MDO due to the interactions with dependency management"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/DefaultMirrorSelector.java",
    "type": "method",
    "name": "isExternalHttpRepo",
    "code": "static boolean isExternalHttpRepo(ArtifactRepository originalRepository) {\n        try {\n            URL url = new URL(originalRepository.getUrl());\n            return (\"http\".equalsIgnoreCase(url.getProtocol())\n                            || \"dav\".equalsIgnoreCase(url.getProtocol())\n                            || \"dav:http\".equalsIgnoreCase(url.getProtocol())\n                            || \"dav+http\".equalsIgnoreCase(url.getProtocol()))\n                    && !isLocal(url.getHost());\n        } catch (MalformedURLException e) {\n            // bad url just skip it here. It should have been validated already, but the wagon lookup will deal with it\n            return false;\n        }\n    }",
    "comment": "Checks the URL to see if this repository refers to a non-localhost repository using HTTP.\n\n@param originalRepository\n@return true if external."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestPlan.java",
    "type": "method",
    "name": "getParent",
    "code": "public Optional<TestIdentifier> getParent(TestIdentifier child) {\n\t\tPreconditions.notNull(child, \"child must not be null\");\n\t\treturn child.getParentIdObject().map(this::getTestIdentifier);\n\t}",
    "comment": "Get the parent of the supplied {@link TestIdentifier}.\n\n@param child the identifier to look up the parent for; never {@code null}\n@return an {@code Optional} containing the parent, if present"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/MethodFilter.java",
    "type": "method",
    "name": "excludeMethodNamePatterns",
    "code": "static MethodFilter excludeMethodNamePatterns(String... patterns) {\n\t\treturn new ExcludeMethodFilter(patterns);\n\t}",
    "comment": "Create a new <em>exclude</em> {@link MethodFilter} based on the\n@see Class#getName()\n@see Method#getName()\n@see #excludeMethodNamePatterns(List)\n@see #includeMethodNamePatterns(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/AnnotationUtilsTests.java",
    "type": "method",
    "name": "findAnnotatedFieldsForNullClass",
    "code": "void findAnnotatedFieldsForNullClass() {\n\t\tassertThrows(PreconditionViolationException.class,\n\t\t\t() -> findAnnotatedFields(null, Annotation1.class, isStringField, TOP_DOWN));\n\t}",
    "comment": "Prerequisite\nActual use cases for this test\n=== findAnnotatedFields() ==============================================="
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java",
    "type": "method",
    "name": "prune",
    "code": "public void prune() {\n\t\tif (wasFiltered) {\n\t\t\tpruneDescriptorsForObsoleteDescriptions(singletonList(runner.getDescription()));\n\t\t}\n\t\tif (rejectedExclusions.isEmpty()) {\n\t\t\tsuper.prune();\n\t\t}\n\t\telse if (rejectedExclusions.containsAll(getDescription().getChildren())) {\n\t\t\tremoveFromHierarchy();\n\t\t}\n\t\telse {\n\t\t\tlogIncompleteFiltering();\n\t\t}\n\t}",
    "comment": "filtering the runner may render intermediate Descriptions obsolete\n(e.g. test classes without any remaining children in a suite)\nsince the Runner was asked to remove all of its direct children,\nit's safe to remove it entirely"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-configuration/src/main/java/org/apache/maven/plugin/coreit/RequiredConfigMojo.java",
    "type": "method",
    "name": "dumpConfiguration",
    "code": "private void dumpConfiguration(Properties props) {\n        PropertiesUtil.serialize(props, \"requiredParam\", requiredParam);\n        PropertiesUtil.serialize(props, \"requiredParamWithDefault\", requiredParamWithDefault);\n    }",
    "comment": "Dumps the mojo configuration into the specified properties.\n\n@param props The properties to dump the configuration into, must not be <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/eclipse/sisu/plexus/PlexusXmlBeanConverter.java",
    "type": "method",
    "name": "newImplementation",
    "code": "private static <T> T newImplementation(final Class<T> clazz) {\n        try {\n            return clazz.newInstance();\n        } catch (final Exception e) {\n            throw new IllegalArgumentException(\"Cannot create instance of: \" + clazz, e);\n        } catch (final LinkageError e) {\n            throw new IllegalArgumentException(\"Cannot create instance of: \" + clazz, e);\n        }\n    }",
    "comment": "Creates an instance of the given implementation using the default constructor.\n\n@param clazz The implementation type\n@return Instance of given implementation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/PreconditionsTests.java",
    "type": "method",
    "name": "notNullPassesForNonNullObject",
    "code": "void notNullPassesForNonNullObject() {\n\t\tvar object = new Object();\n\t\tvar nonNullObject = notNull(object, \"message\");\n\t\tassertSame(object, nonNullObject);\n\t}",
    "comment": "Unit tests for {@link Preconditions}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ResolverFacade.java",
    "type": "method",
    "name": "create",
    "code": "static ResolverFacade create(Constructor<?> constructor, ParameterizedClass annotation) {\n\t\tint implicitParameters = isInnerClass(constructor.getDeclaringClass()) ? 1 : 0;\n\t\treturn create(constructor, annotation, implicitParameters);\n\t}",
    "comment": "Inner classes get the outer instance as first (implicit) parameter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/factory-method/src/test/java/com/iluwatar/factory/method/FactoryMethodTest.java",
    "type": "method",
    "name": "testElfBlacksmithWithShortSword",
    "code": "void testElfBlacksmithWithShortSword() {\n    var blacksmith = new ElfBlacksmith();\n    var weapon = blacksmith.manufactureWeapon(WeaponType.SHORT_SWORD);\n    verifyWeapon(weapon, WeaponType.SHORT_SWORD, ElfWeapon.class);\n  }",
    "comment": "Testing {@link ElfBlacksmith} to produce a SHORT_SWORD asserting that the Weapon is an instance\nof {@link ElfWeapon}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestInstanceFactoryTests.java",
    "type": "method",
    "name": "createTestInstance",
    "code": "public Object createTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext extensionContext) {\n\t\t\tthrow new RuntimeException(\"boom!\");\n\t\t}",
    "comment": "{@link TestInstanceFactory} that always throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenLoggerFactory.java",
    "type": "method",
    "name": "getLogger",
    "code": "public Logger getLogger(String name) {\n        return loggerMap.computeIfAbsent(name, this::getNewLoggingInstance);\n    }",
    "comment": "Return an appropriate {@link Logger} instance by name."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnenc/goals/GoalSupport.java",
    "type": "method",
    "name": "GoalSupport",
    "code": "protected GoalSupport(MessageBuilderFactory messageBuilderFactory, SecDispatcher secDispatcher) {\n        this.messageBuilderFactory = messageBuilderFactory;\n        this.secDispatcher = secDispatcher;\n    }",
    "comment": "The support class for goal implementations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/MethodMap.java",
    "type": "method",
    "name": "add",
    "code": "void add(Method method) {\n        String methodName = method.getName();\n\n        List<Method> l = get(methodName);\n\n        if (l == null) {\n            l = new ArrayList<>();\n            methodByNameMap.put(methodName, l);\n        }\n\n        l.add(method);\n    }",
    "comment": "Add a method to a list of methods by name.\nFor a particular class we are keeping track\nof all the methods with the same name.\n\n@param method The method"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/ShoppingCartService.java",
    "type": "method",
    "name": "removeItemFromCart",
    "code": "public void removeItemFromCart(final String userId, final String productId) {\n    cartRepository.removeItemFromCart(userId, productId);\n  }",
    "comment": "Removes an item from the user's shopping cart.\n\n@param userId The ID of the user.\n@param productId The ID of the product to be removed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/TempFolderRuleTest.java",
    "type": "method",
    "name": "join",
    "code": "private String join(String... folderNames) {\n            StringBuilder path = new StringBuilder();\n            for (String folderName : folderNames) {\n                path.append(File.separator).append(folderName);\n            }\n            return path.toString();\n        }",
    "comment": "force usage of folder.newFolder(String),\ncheck is available and works, to avoid a potential NoSuchMethodError with non-recompiled code.\nthis uses newFolder(String), ensure that a single String works"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertEqualsAssertionsTests.java",
    "type": "method",
    "name": "assertEqualsByte",
    "code": "void assertEqualsByte() {\n\t\tbyte expected = 1;\n\t\tbyte actual = 1;\n\t\tassertEquals(expected, actual);\n\t\tassertEquals(expected, actual, \"message\");\n\t\tassertEquals(expected, actual, () -> \"message\");\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "project",
    "code": "default MessageBuilder project(Object message) {\n        return style(\".\" + Constants.MAVEN_STYLE_PROJECT_NAME + \":-\" + Constants.MAVEN_STYLE_PROJECT_DEFAULT, message);\n    }",
    "comment": "Append message content in project style.\nBy default, cyan\n\n@param message the message to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/AssertionsDemo.java",
    "type": "method",
    "name": "timeoutExceededWithPreemptiveTermination",
    "code": "void timeoutExceededWithPreemptiveTermination() {\n\t\tassertTimeoutPreemptively(ofMillis(10), () -> {\n\t\t\tnew CountDownLatch(1).await();\n\t\t});\n\t}",
    "comment": "end::user_guide[]\ntag::user_guide[]\nThe following assertion fails with an error message similar to:\nexecution timed out after 10 ms\nSimulate task that takes more than 10 ms."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/StylizeActivity.java",
    "type": "method",
    "name": "stylizeImage",
    "code": "private void stylizeImage(final Bitmap bitmap) {\n    ++frameNum;\n    bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());\n\n    if (DEBUG_MODEL) {\n      final int centerX = (frameNum + bitmap.getWidth() / 2) % bitmap.getWidth();\n      final int centerY = bitmap.getHeight() / 2;\n      final int squareSize = 10;\n      for (int i = 0; i < intValues.length; ++i) {\n        final int x = i % bitmap.getWidth();\n        final int y = i / bitmap.getHeight();\n        final float val =\n            Math.abs(x - centerX) < squareSize && Math.abs(y - centerY) < squareSize ? 1.0f : 0.0f;\n        floatValues[i * 3] = val;\n        floatValues[i * 3 + 1] = val;\n        floatValues[i * 3 + 2] = val;\n      }\n    } else {\n      for (int i = 0; i < intValues.length; ++i) {\n        final int val = intValues[i];\n        floatValues[i * 3] = ((val >> 16) & 0xFF) / 255.0f;\n        floatValues[i * 3 + 1] = ((val >> 8) & 0xFF) / 255.0f;\n        floatValues[i * 3 + 2] = (val & 0xFF) / 255.0f;\n      }\n    }\n\n    LOGGER.i(\"Width: %s , Height: %s\", bitmap.getWidth(), bitmap.getHeight());\n    inferenceInterface.feed(\n        INPUT_NODE, floatValues, 1, bitmap.getWidth(), bitmap.getHeight(), 3);\n    inferenceInterface.feed(STYLE_NODE, styleVals, NUM_STYLES);\n\n    inferenceInterface.run(new String[] {OUTPUT_NODE}, isDebug());\n\n    bitmap.setPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());\n  }",
    "comment": "Create a white square that steps through a black background 1 pixel per frame.\nCopy the input data into TensorFlow."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "lowerCaseCodePoints",
    "code": "public static UTF8String lowerCaseCodePoints(final UTF8String target) {\n    if (target.isFullAscii()) return target.toLowerCaseAscii();\n    return lowerCaseCodePointsSlow(target);\n  }",
    "comment": "Converts an entire string to lowercase using ICU rules, code point by code point, with\nspecial handling for one-to-many case mappings (i.e. characters that map to multiple\ncharacters in lowercase). Also, this method omits information about context-sensitive case\nmappings using special handling in the `appendLowercaseCodePoint` method.\n\n@param target The target string to convert to lowercase.\n@return The string converted to lowercase in a context-unaware manner."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/HiveTableTypeMapping.java",
    "type": "method",
    "name": "mapToHiveType",
    "code": "public String[] mapToHiveType(String clientTypeName) {\n    return new String[] {mapToClientType(clientTypeName)};\n\n  @Override\n  public String mapToClientType(String hiveTypeName) {\n    return hiveTypeName;\n  }\n\n  @Override\n  public Set<String> getTableTypeNames() {\n    Set<String> typeNameSet = new HashSet<String>();\n    for (TableType typeNames : TableType.values()) {\n      typeNameSet.add(typeNames.name());\n    }\n    return typeNameSet;\n  }\n}",
    "comment": "HiveTableTypeMapping.\nDefault table type mapping"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/ExpressionInfo.java",
    "type": "method",
    "name": "ExpressionInfo",
    "code": "public ExpressionInfo(String className, String db, String name, String usage, String extended) {\n        // `arguments` and `examples` are concatenated for the extended description. So, here\n        // simply pass the `extended` as `arguments` and an empty string for `examples`.\n        this(className, db, name, usage, extended, \"\", \"\", \"\", \"\", \"\", \"\");\n    }",
    "comment": "@deprecated This constructor is deprecated as of Spark 3.0. Use other constructors to fully\nspecify each argument for extended usage."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/MavenBuildTimestamp.java",
    "type": "method",
    "name": "MavenBuildTimestamp",
    "code": "public MavenBuildTimestamp(Instant time, Properties properties) {\n        this(time, properties != null ? properties.getProperty(Constants.MAVEN_BUILD_TIMESTAMP_FORMAT) : null);\n    }",
    "comment": "@deprecated Use {@link #MavenBuildTimestamp(Instant, Map)} or extract the format and pass it\nto {@link #MavenBuildTimestamp(Instant, String)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/memory/UnsafeMemoryAllocator.java",
    "type": "method",
    "name": "free",
    "code": "public void free(MemoryBlock memory) {\n    assert (memory.obj == null) :\n      \"baseObject not null; are you trying to use the off-heap allocator to free on-heap memory?\";\n    assert (memory.pageNumber != MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER) :\n      \"page has already been freed\";\n    assert ((memory.pageNumber == MemoryBlock.NO_PAGE_NUMBER)\n            || (memory.pageNumber == MemoryBlock.FREED_IN_TMM_PAGE_NUMBER)) :\n      \"TMM-allocated pages must be freed via TMM.freePage(), not directly in allocator free()\";\n\n    if (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) {\n      memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_FREED_VALUE);\n    }\n    Platform.freeMemory(memory.offset);\n    memory.offset = 0;\n    memory.pageNumber = MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER;\n  }",
    "comment": "As an additional layer of defense against use-after-free bugs, we mutate the\nMemoryBlock to reset its pointer.\nMark the page as freed (so we can detect double-frees)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/function/Try.java",
    "type": "method",
    "name": "ifFailure",
    "code": "public Try<V> ifFailure(Consumer<Exception> causeConsumer) {\n\t\t\treturn this;\n\t\t}",
    "comment": "don't call causeConsumer because this Try was a success"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(double unexpected, double actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClassSource.java",
    "type": "method",
    "name": "getPosition",
    "code": "public final Optional<FilePosition> getPosition() {\n\t\treturn Optional.ofNullable(this.filePosition);\n\t}",
    "comment": "Get the {@linkplain FilePosition position} in the source file for\nthe associated {@linkplain #getClassName class}, if available.\n\n@see #getClassName()\n@see #getJavaClass()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/ShreddingUtils.java",
    "type": "method",
    "name": "rebuild",
    "code": "public static Variant rebuild(ShreddedRow row, VariantSchema schema) {\n    if (schema.topLevelMetadataIdx < 0 || row.isNullAt(schema.topLevelMetadataIdx)) {\n      throw malformedVariant();\n    }\n    byte[] metadata = row.getBinary(schema.topLevelMetadataIdx);\n    if (schema.isUnshredded()) {\n      if (row.isNullAt(schema.variantIdx)) {\n        throw malformedVariant();\n      }\n      return new Variant(row.getBinary(schema.variantIdx), metadata);\n    }\n    VariantBuilder builder = new VariantBuilder(false);\n    rebuild(row, metadata, schema, builder);\n    return builder.result();\n  }",
    "comment": "Interface to read from a shredded result. It essentially has the same interface and semantics\nas Spark's `SpecializedGetters`, but we need a new interface to avoid the dependency.\nThis `rebuild` function should only be called on the top-level schema, and that other private\nimplementation will be called on any recursively shredded sub-schema.\n`rebuild` is unnecessary for unshredded variant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroPrimitives.java",
    "type": "method",
    "name": "setFloatColumn",
    "code": "public void setFloatColumn(java.lang.Float value) {\n    this.float_column = value;\n  }",
    "comment": "Sets the value of the 'float_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/DuplicateProjectException.java",
    "type": "method",
    "name": "DuplicateProjectException",
    "code": "public DuplicateProjectException(String message, Map<String, List<File>> collisions) {\n        super(message, (File) null);\n\n        this.collisions = (collisions != null) ? collisions : new LinkedHashMap<>();\n    }",
    "comment": "Creates a new exception with specified details.\n\n@param message The message text, may be {@code null}.\n@param collisions The POM files of the projects that collided, indexed by their g:a:v, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/metadata/MetadataUtils.java",
    "type": "method",
    "name": "cloneMetadata",
    "code": "public static Metadata cloneMetadata(Metadata src) {\n        if (src == null) {\n            return null;\n        }\n        return src.clone();\n    }",
    "comment": "Assists in handling repository metadata."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/androidTest/java/com/example/android/observability/persistence/UserDaoTest.java",
    "type": "method",
    "name": "deleteAndGetUser",
    "code": "public void deleteAndGetUser() {\n        mDatabase.userDao().insertUser(USER).blockingAwait();\n\n        mDatabase.userDao().deleteAllUsers();\n        mDatabase.userDao().getUser()\n                .test()\n                .assertNoValues();\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are deleting all users\nWhen subscribing to the emissions of the user\ncheck that there's no user emitted"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/Table.java",
    "type": "method",
    "name": "constraints",
    "code": "default Constraint[] constraints() { return new Constraint[0]; }\n}",
    "comment": "Returns the constraints for this table."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactoryTests.java",
    "type": "method",
    "name": "runningInEclipse",
    "code": "static boolean runningInEclipse() {\n\t\treturn StackWalker.getInstance().walk(\n\t\t\tstream -> stream.anyMatch(stackFrame -> stackFrame.getClassName().startsWith(\"org.eclipse.jdt\")));\n\t}",
    "comment": "Determine if the current code is running in the Eclipse IDE.\n<p>Copied from {@code org.springframework.core.testfixture.ide.IdeUtils}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/plugin/testing/MojoExtension.java",
    "type": "method",
    "name": "getPluginBasedir",
    "code": "public static String getPluginBasedir() {\n        return requireNonNull(pluginBasedir);\n    }",
    "comment": "Gets the base directory of the plugin being tested.\n\n@return the plugin base directory path\n@throws NullPointerException if plugin basedir is not set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom/java/com/example/android/persistence/migrations/UserDaoTest.java",
    "type": "method",
    "name": "deleteAndGetUser",
    "code": "public void deleteAndGetUser() {\n        mDatabase.userDao().insertUser(USER);\n\n        mDatabase.userDao().deleteAllUsers();\n\n        User dbUser = mDatabase.userDao().getUser();\n        assertNull(dbUser);\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are deleting all users\nThe user is no longer in the data source"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Timeout.java",
    "type": "method",
    "name": "build",
    "code": "public Timeout build() {\n            return new Timeout(this);\n        }",
    "comment": "Builds a {@link Timeout} instance using the values in this builder.,"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/io/ModelParseException.java",
    "type": "method",
    "name": "ModelParseException",
    "code": "public ModelParseException(String message, int lineNumber, int columnNumber) {\n        super(message);\n        this.lineNumber = lineNumber;\n        this.columnNumber = columnNumber;\n    }",
    "comment": "Creates a new parser exception with the specified details.\n\n@param message The error message, may be {@code null}.\n@param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.\n@param columnNumber The one-based index of the column containing the error or {@code -1} if unknown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/FilePositionTests.java",
    "type": "method",
    "name": "preconditions",
    "code": "void preconditions() {\n\t\tassertThrows(PreconditionViolationException.class, () -> FilePosition.from(-1));\n\t\tassertThrows(PreconditionViolationException.class, () -> FilePosition.from(0, -1));\n\t}",
    "comment": "Unit tests for {@link FilePosition}.\n\n@since 1.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestSqlite/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "insertAndGetUser",
    "code": "public void insertAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        User dbUser = mDataSource.getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), USER.getUserName());\n    }",
    "comment": "When inserting a new user in the data source\nThe user can be retrieved"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/resources/mng-8525-maven-di-plugin/src/main/java/org/apache/maven/plugins/HelloMojo.java",
    "type": "method",
    "name": "execute",
    "code": "public void execute() {\n        String message = component.hello(name);\n        logger.info(message);\n    }",
    "comment": "Say hello to the world, my little constructor injected component!"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/condition/AbstractJreRangeCondition.java",
    "type": "method",
    "name": "isCurrentVersionWithinRange",
    "code": "protected final boolean isCurrentVersionWithinRange(JRE minJre, JRE maxJre, int minVersion, int maxVersion) {\n\t\tboolean minJreSet = minJre != JRE.UNDEFINED;\n\t\tboolean maxJreSet = maxJre != JRE.UNDEFINED;\n\t\tboolean minVersionSet = minVersion != JRE.UNDEFINED_VERSION;\n\t\tboolean maxVersionSet = maxVersion != JRE.UNDEFINED_VERSION;\n\n\t\tPreconditions.condition(!minJreSet || !minVersionSet, () -> String.format(\n\t\t\t\"@%s's minimum value must be configured with either a JRE enum constant or numeric version, but not both\",\n\t\t\tthis.annotationName));\n\t\tPreconditions.condition(!maxJreSet || !maxVersionSet, () -> String.format(\n\t\t\t\"@%s's maximum value must be configured with either a JRE enum constant or numeric version, but not both\",\n\t\t\tthis.annotationName));\n\n\t\tPreconditions.condition(!minVersionSet || (minVersion >= JRE.MINIMUM_VERSION),\n\t\t\t() -> String.format(\"@%s's minVersion [%d] must be greater than or equal to %d\", this.annotationName,\n\t\t\t\tminVersion, JRE.MINIMUM_VERSION));\n\t\tPreconditions.condition(!maxVersionSet || (maxVersion >= JRE.MINIMUM_VERSION),\n\t\t\t() -> String.format(\"@%s's maxVersion [%d] must be greater than or equal to %d\", this.annotationName,\n\t\t\t\tmaxVersion, JRE.MINIMUM_VERSION));\n\n\t\tif (!minJreSet) {\n\t\t\tminJre = JRE.JAVA_8;\n\t\t}\n\t\tif (!maxJreSet) {\n\t\t\tmaxJre = JRE.OTHER;\n\t\t}\n\n\t\tint min = (minVersionSet ? minVersion : minJre.version());\n\t\tint max = (maxVersionSet ? maxVersion : maxJre.version());\n\n\t\tPreconditions.condition((min != JRE.MINIMUM_VERSION || max != Integer.MAX_VALUE),\n\t\t\t() -> \"You must declare a non-default value for the minimum or maximum value in @\" + this.annotationName);\n\t\tPreconditions.condition(min >= JRE.MINIMUM_VERSION,\n\t\t\t() -> String.format(\"@%s's minimum value [%d] must greater than or equal to %d\", this.annotationName, min,\n\t\t\t\tJRE.MINIMUM_VERSION));\n\t\tPreconditions.condition(min <= max,\n\t\t\t() -> String.format(\"@%s's minimum value [%d] must be less than or equal to its maximum value [%d]\",\n\t\t\t\tthis.annotationName, min, max));\n\n\t\treturn JRE.isCurrentVersionWithinRange(min, max);\n\t}",
    "comment": "Users must choose between JRE enum constants and version numbers.\nUsers must supply valid values for minVersion and maxVersion.\nNow that we have checked the basic preconditions, we need to ensure that we are\nusing valid JRE enum constants.\nFinally, we need to validate the effective minimum and maximum values."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "applyConfigurationParametersFromSuite",
    "code": "public SuiteLauncherDiscoveryRequestBuilder applyConfigurationParametersFromSuite(Class<?> suiteClass) {\n\t\tPreconditions.notNull(suiteClass, \"Suite class must not be null\");\n\n\t\t// @formatter:off\n\t\tfindRepeatableAnnotations(suiteClass, ConfigurationParameter.class)\n\t\t\t\t.forEach(configuration -> configurationParameter(configuration.key(), configuration.value()));\n\t\tfindRepeatableAnnotations(suiteClass, ConfigurationParametersResource.class)\n\t\t\t\t.forEach(configResource -> configurationParametersResource(configResource.value()));\n\t\tfindAnnotation(suiteClass, DisableParentConfigurationParameters.class)\n\t\t\t\t.ifPresent(__ -> this.enableParentConfigurationParameters = false);\n\t\t// @formatter:on\n\t\treturn this;\n\t}",
    "comment": "Apply a suite's annotation-based configuration to this builder.\n\n<p>This will apply the configuration from the following annotations.\n<ul>\n<li>{@link ConfigurationParameter}</li>\n<li>{@link DisableParentConfigurationParameters}</li>\n</ul>\n\n@param suiteClass the class to apply the configuration annotations from;\nnever {@code null}\n@return this builder for method chaining\n@since 1.11\n@see org.junit.platform.suite.api.Suite"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "setUpCameraOutputs",
    "code": "private void setUpCameraOutputs() {\n    final Activity activity = getActivity();\n    final CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);\n    try {\n      final CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);\n\n      final StreamConfigurationMap map =\n          characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);\n\n      // For still image captures, we use the largest available size.\n      final Size largest =\n          Collections.max(\n              Arrays.asList(map.getOutputSizes(ImageFormat.YUV_420_888)),\n              new CompareSizesByArea());\n\n      sensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);\n\n      // Danger, W.R.! Attempting to use too large a preview size could  exceed the camera\n      // bus' bandwidth limitation, resulting in gorgeous previews but the storage of\n      // garbage capture data.\n      previewSize =\n          chooseOptimalSize(map.getOutputSizes(SurfaceTexture.class),\n              inputSize.getWidth(),\n              inputSize.getHeight());\n\n      // We fit the aspect ratio of TextureView to the size of preview we picked.\n      final int orientation = getResources().getConfiguration().orientation;\n      if (orientation == Configuration.ORIENTATION_LANDSCAPE) {\n        textureView.setAspectRatio(previewSize.getWidth(), previewSize.getHeight());\n      } else {\n        textureView.setAspectRatio(previewSize.getHeight(), previewSize.getWidth());\n      }\n    } catch (final CameraAccessException e) {\n      LOGGER.e(e, \"Exception!\");\n    } catch (final NullPointerException e) {\n      // Currently an NPE is thrown when the Camera2API is used but not supported on the\n      // device this code runs.\n      // TODO(andrewharp): abstract ErrorDialog/RuntimeException handling out into new method and\n      // reuse throughout app.\n      ErrorDialog.newInstance(getString(R.string.camera_error))\n          .show(getChildFragmentManager(), FRAGMENT_DIALOG);\n      throw new RuntimeException(getString(R.string.camera_error), e);\n    }\n\n    cameraConnectionCallback.onPreviewSizeChosen(previewSize, sensorOrientation);\n  }",
    "comment": "Sets up member variables related to camera."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/DefaultWagonManager.java",
    "type": "method",
    "name": "cleanupTemporaryFiles",
    "code": "private void cleanupTemporaryFiles(List<File> files) {\n        for (File file : files) {\n            if (!file.delete()) {\n                logger.warn(\"skip failed to delete temporary file : \" + file.getAbsolutePath());\n                file.deleteOnExit();\n            }\n        }\n    }",
    "comment": "really don't care if it failed here only log warning"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginNotFoundException.java",
    "type": "method",
    "name": "PluginNotFoundException",
    "code": "public PluginNotFoundException(Plugin plugin, ArtifactNotFoundException e) {\n        super(\n                \"Plugin could not be found - check that the goal name is correct: \" + e.getMessage(),\n                e.getGroupId(),\n                e.getArtifactId(),\n                e.getVersion(),\n                \"maven-plugin\",\n                null,\n                e.getRemoteRepositories(),\n                null,\n                e.getCause());\n        this.plugin = plugin;\n    }",
    "comment": "Exception occurring trying to resolve a plugin."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/LifecycleConfiguration.java",
    "type": "method",
    "name": "getModelEncoding",
    "code": "public String getModelEncoding() {\n        return this.modelEncoding;\n    } // -- String getModelEncoding()",
    "comment": "Get the modelEncoding field.\n\n@return String"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dirty-flag/src/main/java/com/iluwatar/dirtyflag/DataFetcher.java",
    "type": "method",
    "name": "fetch",
    "code": "public List<String> fetch() {\n    var classLoader = getClass().getClassLoader();\n    var file = new File(classLoader.getResource(FILENAME).getFile());\n\n    if (isDirty(file.lastModified())) {\n      LOGGER.info(FILENAME + \" is dirty! Re-fetching file content...\");\n      try (var br = new BufferedReader(new FileReader(file))) {\n        LOGGER.error(\"An error occurred: \", e);\n      }\n    }\n\n    return List.of();\n  }",
    "comment": "Fetches data/content from raw file.\n\n@return List of strings"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "test",
    "code": "public static Condition<Event> test(String uniqueIdSubstring, String displayName) {\n\t\treturn allOf(test(), uniqueIdSubstring(uniqueIdSubstring), displayName(displayName));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\na {@linkplain TestDescriptor#isTest() test}, its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the supplied\n{@link String}, and its {@linkplain TestDescriptor#getDisplayName()\ndisplay name} equals the supplied {@link String}.\n\n@see #test()\n@see #test(Condition)\n@see #uniqueIdSubstring(String)\n@see #displayName(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java",
    "type": "method",
    "name": "validateRawModel",
    "code": "public void validateRawModel(Model m, ModelBuildingRequest request, ModelProblemCollector problems) {\n        Parent parent = m.getParent();\n        if (parent != null) {\n            validateStringNotEmpty(\n                    \"parent.groupId\", problems, Severity.FATAL, Version.BASE, parent.getGroupId(), parent);\n\n            validateStringNotEmpty(\n                    \"parent.artifactId\", problems, Severity.FATAL, Version.BASE, parent.getArtifactId(), parent);\n\n            validateStringNotEmpty(\n                    \"parent.version\", problems, Severity.FATAL, Version.BASE, parent.getVersion(), parent);\n\n            if (equals(parent.getGroupId(), m.getGroupId()) && equals(parent.getArtifactId(), m.getArtifactId())) {\n                addViolation(\n                        problems,\n                        Severity.FATAL,\n                        Version.BASE,\n                        \"parent.artifactId\",\n                        null,\n                        \"must be changed\"\n                                + \", the parent element cannot have the same groupId:artifactId as the project.\",\n                        parent);\n            }\n\n            if (equals(\"LATEST\", parent.getVersion()) || equals(\"RELEASE\", parent.getVersion())) {\n                addViolation(\n                        problems,\n                        Severity.WARNING,\n                        Version.BASE,\n                        \"parent.version\",\n                        null,\n                        \"is either LATEST or RELEASE (both of them are being deprecated)\",\n                        parent);\n            }\n        }\n\n        if (request.getValidationLevel() == ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL) {\n            HashSet<String> minProfileIds = new HashSet<>();\n            for (Profile profile : m.getProfiles()) {\n                if (!minProfileIds.add(profile.getId())) {\n                    addViolation(\n                            problems,\n                            Severity.WARNING,\n                            Version.BASE,\n                            \"profiles.profile.id\",\n                            null,\n                            \"Duplicate activation for profile \" + profile.getId(),\n                            profile);\n                }\n            }\n        } else if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\n            Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);\n\n            validateStringNotEmpty(\"modelVersion\", problems, Severity.ERROR, Version.V20, m.getModelVersion(), m);\n\n            validateModelVersion(problems, m.getModelVersion(), m, \"4.0.0\");\n\n            validateStringNoExpression(\"groupId\", problems, Severity.WARNING, Version.V20, m.getGroupId(), m);\n            if (parent == null) {\n                validateStringNotEmpty(\"groupId\", problems, Severity.FATAL, Version.V20, m.getGroupId(), m);\n            }\n\n            validateStringNoExpression(\"artifactId\", problems, Severity.WARNING, Version.V20, m.getArtifactId(), m);\n            validateStringNotEmpty(\"artifactId\", problems, Severity.FATAL, Version.V20, m.getArtifactId(), m);\n\n            validateVersionNoExpression(\"version\", problems, Severity.WARNING, Version.V20, m.getVersion(), m);\n            if (parent == null) {\n                validateStringNotEmpty(\"version\", problems, Severity.FATAL, Version.V20, m.getVersion(), m);\n            }\n\n            validate20RawDependencies(problems, m.getDependencies(), \"dependencies.dependency.\", EMPTY, request);\n\n            validate20RawDependenciesSelfReferencing(\n                    problems, m, m.getDependencies(), \"dependencies.dependency\", request);\n\n            if (m.getDependencyManagement() != null) {\n                validate20RawDependencies(\n                        problems,\n                        m.getDependencyManagement().getDependencies(),\n                        \"dependencyManagement.dependencies.dependency.\",\n                        EMPTY,\n                        request);\n            }\n\n            validateRawRepositories(problems, m.getRepositories(), \"repositories.repository.\", EMPTY, request);\n\n            validateRawRepositories(\n                    problems, m.getPluginRepositories(), \"pluginRepositories.pluginRepository.\", EMPTY, request);\n\n            Build build = m.getBuild();\n            if (build != null) {\n                validate20RawPlugins(problems, build.getPlugins(), \"build.plugins.plugin.\", EMPTY, request);\n\n                PluginManagement mgmt = build.getPluginManagement();\n                if (mgmt != null) {\n                    validate20RawPlugins(\n                            problems, mgmt.getPlugins(), \"build.pluginManagement.plugins.plugin.\", EMPTY, request);\n                }\n            }\n\n            Set<String> profileIds = new HashSet<>();\n\n            for (Profile profile : m.getProfiles()) {\n                String prefix = \"profiles.profile[\" + profile.getId() + \"].\";\n\n                if (!profileIds.add(profile.getId())) {\n                    addViolation(\n                            problems,\n                            errOn30,\n                            Version.V20,\n                            \"profiles.profile.id\",\n                            null,\n                            \"must be unique but found duplicate profile with id \" + profile.getId(),\n                            profile);\n                }\n\n                validate30RawProfileActivation(problems, profile.getActivation(), prefix);\n\n                validate20RawDependencies(\n                        problems, profile.getDependencies(), prefix, \"dependencies.dependency.\", request);\n\n                if (profile.getDependencyManagement() != null) {\n                    validate20RawDependencies(\n                            problems,\n                            profile.getDependencyManagement().getDependencies(),\n                            prefix,\n                            \"dependencyManagement.dependencies.dependency.\",\n                            request);\n                }\n\n                validateRawRepositories(\n                        problems, profile.getRepositories(), prefix, \"repositories.repository.\", request);\n\n                validateRawRepositories(\n                        problems,\n                        profile.getPluginRepositories(),\n                        prefix,\n                        \"pluginRepositories.pluginRepository.\",\n                        request);\n\n                BuildBase buildBase = profile.getBuild();\n                if (buildBase != null) {\n                    validate20RawPlugins(problems, buildBase.getPlugins(), prefix, \"plugins.plugin.\", request);\n\n                    PluginManagement mgmt = buildBase.getPluginManagement();\n                    if (mgmt != null) {\n                        validate20RawPlugins(\n                                problems, mgmt.getPlugins(), prefix, \"pluginManagement.plugins.plugin.\", request);\n                    }\n                }\n            }\n        }\n    }",
    "comment": "profiles: they are essential for proper model building (may contribute profiles, dependencies...)\n[MNG-6074] Maven should produce an error if no model version has been set in a POM file used to build an\neffective model.\n\nAs of 3.4, the model version is mandatory even in raw models. The XML element still is optional in the\nXML schema and this will not change anytime soon. We do not want to build effective models based on\nmodels without a version starting with 3.4."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/NestedClassSelectorTests.java",
    "type": "method",
    "name": "equalsAndHashCode",
    "code": "void equalsAndHashCode() {\n\t\tvar selector1 = new NestedClassSelector(null, List.of(\"org.example.EnclosingTestClass\"),\n\t\t\t\"org.example.NestedTestClass\");\n\t\tvar selector2 = new NestedClassSelector(null, List.of(\"org.example.EnclosingTestClass\"),\n\t\t\t\"org.example.NestedTestClass\");\n\t\tvar selector3 = new NestedClassSelector(null, List.of(\"org.example.X\"), \"org.example.Y\");\n\n\t\tassertEqualsAndHashCode(selector1, selector2, selector3);\n\t}",
    "comment": "Unit tests for {@link NestedClassSelector}.\n\n@since 1.6\n@see DiscoverySelectorsTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/NumericHistogram.java",
    "type": "method",
    "name": "addBin",
    "code": "public void addBin(double x, double y, int b) {\n    Coord coord = new Coord();\n    coord.x = x;\n    coord.y = y;\n    bins.add(b, coord);\n  }",
    "comment": "Set a particular histogram bin with index."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaWord2VecExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaWord2VecExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(Arrays.asList(\"Hi I heard about Spark\".split(\" \"))),\n      RowFactory.create(Arrays.asList(\"I wish Java could use case classes\".split(\" \"))),\n      RowFactory.create(Arrays.asList(\"Logistic regression models are neat\".split(\" \")))\n    );\n    StructType schema = new StructType(new StructField[]{\n    Dataset<Row> documentDF = spark.createDataFrame(data, schema);\n\n    Word2Vec word2Vec = new Word2Vec()\n      .setInputCol(\"text\")\n      .setOutputCol(\"result\")\n      .setVectorSize(3)\n      .setMinCount(0);\n\n    Word2VecModel model = word2Vec.fit(documentDF);\n    Dataset<Row> result = model.transform(documentDF);\n\n    for (Row row : result.collectAsList()) {\n      List<String> text = row.getList(0);\n      Vector vector = (Vector) row.get(1);\n      System.out.println(\"Text: \" + text + \" => \\nVector: \" + vector + \"\\n\");\n    }\n\n    spark.stop();\n  }\n}",
    "comment": "$example on$\n$example off$\n$example on$\nInput data: Each row is a bag of words from a sentence or document.\nLearn a mapping from words to Vectors.\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/RemoteBlockPushResolverSuite.java",
    "type": "method",
    "name": "removeApplication",
    "code": "private void removeApplication(String appId) {\n    pushResolver.applicationRemoved(appId,  false);\n  }",
    "comment": "PushResolver cleans up the local dirs in a different thread which can conflict with the test\ndata of other tests, since they are using the same Application Id."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java",
    "type": "method",
    "name": "validateTestMethods",
    "code": "protected void validateTestMethods(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(Test.class, false, errors);\n    }",
    "comment": "Adds to {@code errors} for each method annotated with {@code @Test}that\nis not a public, void instance method with no arguments."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelCacheTag.java",
    "type": "method",
    "name": "getType",
    "code": "ModelCacheTag<ModelData> RAW = new ModelCacheTag<ModelData>() {\n\n        @Override\n        public Class<ModelData> getType() {\n            return ModelData.class;\n        }\n\n        @Override\n        public ModelData intoCache(ModelData data) {\n            Model model = (data.getModel() != null) ? data.getModel().clone() : null;\n            return new ModelData(data.getSource(), model, data.getGroupId(), data.getArtifactId(), data.getVersion());\n        }\n\n        @Override\n        public ModelData fromCache(ModelData data) {\n            return intoCache(data);\n        }\n    };",
    "comment": "The tag used to denote raw model data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/double-buffer/src/test/java/com/iluwatar/doublebuffer/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelBuilder.java",
    "type": "method",
    "name": "merge",
    "code": "List<Profile> merge(List<Profile> profiles, Map<String, String> userProperties) {\n            List<Profile> result = null;\n            for (int i = 0; i < profiles.size(); i++) {\n                Profile profile = profiles.get(i);\n                Map<String, String> props = merge(profile.getProperties(), userProperties);\n                if (props != null) {\n                    Profile merged = profile.withProperties(props);\n                    if (result == null) {\n                        result = new ArrayList<>(profiles);\n                    }\n                    result.set(i, merged);\n                }\n            }\n            return result != null ? result : profiles;\n        }",
    "comment": "Merges a list of model profiles with user-defined properties.\nFor each property defined in both the model and user properties, the user property value\ntakes precedence and overrides the model value.\n\n@param profiles list of profiles from the model\n@param userProperties map of user-defined properties that override model properties\n@return a new list containing profiles with overridden properties if changes were made,\nor the original list if no overrides were needed"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "create",
    "code": "public static <T> Tensor<T> create(Class<T> type, long[] shape, ByteBuffer data) {\n    @SuppressWarnings(\"unchecked\")\n    Tensor<T> ret = (Tensor<T>) create(DataType.fromClass(type), shape, data);\n    return ret;\n  }",
    "comment": "Create a Tensor of any type with data from the given buffer.\n\n<p>Creates a Tensor with the provided shape of any type where the tensor's data has been\nencoded into {@code data} as per the specification of the TensorFlow <a\nhref=\"https://www.tensorflow.org/code/tensorflow/c/c_api.h\">C\nAPI</a>.\n\n@param <T> the tensor element type\n@param type the tensor element type, represented as a class object.\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@throws IllegalArgumentException If the tensor datatype or shape is not compatible with the\nbuffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelData.java",
    "type": "method",
    "name": "setModel",
    "code": "public void setModel(Model model) {\n        this.model = model;\n    }",
    "comment": "Sets the model being wrapped.\n\n@param model The model, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/PackageUtils.java",
    "type": "method",
    "name": "getAttribute",
    "code": "public static Optional<String> getAttribute(Class<?> type, Function<Package, String> function) {\n\t\tPreconditions.notNull(type, \"type must not be null\");\n\t\tPreconditions.notNull(function, \"function must not be null\");\n\t\treturn Optional.ofNullable(type.getPackage()).map(function);\n\t}",
    "comment": "Get the package attribute for the supplied {@code type} using the\nsupplied {@code function}.\n\n<p>This method only returns a non-empty {@link Optional} value holder\nif the class loader for the supplied type created a {@link Package}\nobject and the supplied function does not return {@code null} when\napplied.\n\n@param type the type to get the package attribute for\n@param function a function that computes the package attribute value\n(e.g., {@code Package::getImplementationTitle}); never {@code null}\n@return an {@code Optional} containing the attribute value; never\n{@code null} but potentially empty\n@throws org.junit.platform.commons.PreconditionViolationException if the\nsupplied type or function is {@code null}\n@see Class#getPackage()\n@see Package#getImplementationTitle()\n@see Package#getImplementationVersion()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/AlbumListPage.java",
    "type": "method",
    "name": "selectAlbum",
    "code": "public AlbumPage selectAlbum(String albumTitle) {\n    // uses XPath to find list of html anchor tags with the class album in it\n    var albumLinks = (List<Object>) page.getByXPath(\"//tr[@class='album']//a\");\n    for (var anchor : albumLinks) {\n      if (((HtmlAnchor) anchor).getTextContent().equals(albumTitle)) {\n        try {\n          ((HtmlAnchor) anchor).click();\n          return new AlbumPage(webClient);\n        } catch (IOException e) {\n          LOGGER.error(\"An error occurred on selectAlbum\", e);\n        }\n      }\n    }\n    throw new IllegalArgumentException(\"No links with the album title: \" + albumTitle);\n  }",
    "comment": "Selects an album by the given album title.\n\n@param albumTitle the title of the album to click\n@return the album page"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "configureTransform",
    "code": "private void configureTransform(final int viewWidth, final int viewHeight) {\n    final Activity activity = getActivity();\n    if (null == textureView || null == previewSize || null == activity) {\n      return;\n    }\n    final int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\n    final Matrix matrix = new Matrix();\n    final RectF viewRect = new RectF(0, 0, viewWidth, viewHeight);\n    final RectF bufferRect = new RectF(0, 0, previewSize.getHeight(), previewSize.getWidth());\n    final float centerX = viewRect.centerX();\n    final float centerY = viewRect.centerY();\n    if (Surface.ROTATION_90 == rotation || Surface.ROTATION_270 == rotation) {\n      bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY());\n      matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);\n      final float scale =\n          Math.max(\n              (float) viewHeight / previewSize.getHeight(),\n              (float) viewWidth / previewSize.getWidth());\n      matrix.postScale(scale, scale, centerX, centerY);\n      matrix.postRotate(90 * (rotation - 2), centerX, centerY);\n    } else if (Surface.ROTATION_180 == rotation) {\n      matrix.postRotate(180, centerX, centerY);\n    }\n    textureView.setTransform(matrix);\n  }",
    "comment": "Configures the necessary {@link android.graphics.Matrix} transformation to `mTextureView`.\nThis method should be called after the camera preview size is determined in\nsetUpCameraOutputs and also the size of `mTextureView` is fixed.\n\n@param viewWidth  The width of `mTextureView`\n@param viewHeight The height of `mTextureView`"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom2/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "insertAndGetUser",
    "code": "public void insertAndGetUser() {\n        // When inserting a new user in the data source\n        mDataSource.insertOrUpdateUser(USER);\n\n        //The user can be retrieved\n        User dbUser = mDataSource.getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), USER.getUserName());\n        assertEquals(dbUser.getDate(), USER.getDate());\n    }",
    "comment": "Integration tests for the {@link LocalUserDataSource} implementation with Room."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/internal/runners/statements/FailOnTimeoutTest.java",
    "type": "method",
    "name": "notTheRealCauseOfTheTimeout",
    "code": "private void notTheRealCauseOfTheTimeout() {\n            for (long now = currentTimeMillis(), eta = now + 1000L; now < eta; now = currentTimeMillis()) {\n                atan(now);\n            }\n        }",
    "comment": "Must _not_ show up in stack trace\nDoesn't matter, just pretend to be busy"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "readFieldValue",
    "code": "public static <T> Optional<Object> readFieldValue(Class<T> clazz, String fieldName, T instance) {\n\t\treturn tryToReadFieldValue(clazz, fieldName, instance).toOptional();\n\t}",
    "comment": "Read the value of a potentially inaccessible or nonexistent field.\n\n<p>If the field does not exist or the value of the field is {@code null},\nan empty {@link Optional} will be returned.\n\n@param clazz the class where the field is declared; never {@code null}\n@param fieldName the name of the field; never {@code null} or empty\n@param instance the instance from where the value is to be read; may\nbe {@code null} for a static field\n@see #readFieldValue(Field)\n@see #readFieldValue(Field, Object)\n@deprecated Please use {@link #tryToReadFieldValue(Class, String, Object)}\ninstead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dependency-injection/src/test/java/com/iluwatar/dependency/injection/AdvancedSorceressTest.java",
    "type": "method",
    "name": "testSmokeEveryThing",
    "code": "void testSmokeEveryThing() {\n\n    List<Tobacco> tobaccos =\n        List.of(new OldTobyTobacco(), new RivendellTobacco(), new SecondBreakfastTobacco());\n\n    // Verify if the sorceress is smoking the correct tobacco ...\n    tobaccos.forEach(\n        tobacco -> {\n          final var advancedSorceress = new AdvancedSorceress();\n          advancedSorceress.setTobacco(tobacco);\n          advancedSorceress.smoke();\n          String lastMessage = appender.getLastMessage();\n          assertEquals(\n              \"AdvancedSorceress smoking \" + tobacco.getClass().getSimpleName(), lastMessage);\n        });\n\n    // ... and nothing else is happening.\n    assertEquals(tobaccos.size(), appender.getLogSize());\n  }",
    "comment": "Test if the {@link AdvancedSorceress} smokes whatever instance of {@link Tobacco} is passed to\nher through the setter's parameter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(byte expected, byte actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactStatus.java",
    "type": "method",
    "name": "ArtifactStatus",
    "code": "private ArtifactStatus(String key, int rank) {\n        this.rank = rank;\n        this.key = key;\n\n        if (map == null) {\n            map = new HashMap<>();\n        }\n        map.put(key, this);\n    }",
    "comment": "Trusted, as it has had its data verified by hand."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/ThreadPoolDispatcher.java",
    "type": "method",
    "name": "ThreadPoolDispatcher",
    "code": "public ThreadPoolDispatcher(int poolSize) {\n    this.executorService = Executors.newFixedThreadPool(poolSize);\n  }",
    "comment": "Creates a pooled dispatcher with tunable pool size.\n\n@param poolSize number of pooled threads"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "toStringWithoutVersion",
    "code": "public String toStringWithoutVersion() {\n      return String.format(\"%s.%s\", provider, name);\n    }",
    "comment": "Returns the identifier's string value without the version.\nThis is used for the table schema as the schema doesn't care about the version,\nonly the statistics do."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/org/apache/spark/streaming/JavaTimeSuite.java",
    "type": "method",
    "name": "testLess",
    "code": "public void testLess() {\n    Assertions.assertTrue(new Time(999).less(new Time(1000)));\n  }",
    "comment": "Just testing the methods that are specially exposed for Java.\nThis does not repeat all tests found in the Scala suite."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/client/TransportClient.java",
    "type": "method",
    "name": "sendRpcSync",
    "code": "public ByteBuffer sendRpcSync(ByteBuffer message, long timeoutMs) {\n    final SettableFuture<ByteBuffer> result = SettableFuture.create();\n\n    sendRpc(message, new RpcResponseCallback() {\n          logger.warn(\"Error in responding RPC callback\", t);\n          result.setException(t);\n        }\n      }",
    "comment": "Synchronously sends an opaque message to the RpcHandler on the server-side, waiting for up to\na specified timeout for a response."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/Checks.java",
    "type": "method",
    "name": "notNull",
    "code": "public static <T> T notNull(T value) {\n        if (value == null) {\n            throw new NullPointerException();\n        }\n        return value;\n    }",
    "comment": "Checks that the given value is not {@code null}.\n\n@param value object reference to check\n@return the passed-in value, if not {@code null}\n@throws NullPointerException if {@code value} is {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/CLIServiceUtils.java",
    "type": "method",
    "name": "patternToRegex",
    "code": "public static String patternToRegex(String pattern) {\n    if (pattern == null) {\n      return \".*\";\n    } else {\n      StringBuilder result = new StringBuilder(pattern.length());\n\n      boolean escaped = false;\n      for (int i = 0, len = pattern.length(); i < len; i++) {\n        char c = pattern.charAt(i);\n        if (escaped) {\n          if (c != SEARCH_STRING_ESCAPE) {\n            escaped = false;\n          }\n          result.append(c);\n        } else {\n          if (c == SEARCH_STRING_ESCAPE) {\n            escaped = true;\n            continue;\n          } else if (c == '%') {\n            result.append(\".*\");\n          } else if (c == '_') {\n            result.append('.');\n          } else {\n            result.append(Character.toLowerCase(c));\n          }\n        }\n      }\n      return result.toString();\n    }\n  }",
    "comment": "Convert a SQL search pattern into an equivalent Java Regex.\n\n@param pattern input which may contain '%' or '_' wildcard characters, or\nthese characters escaped using {@code getSearchStringEscape()}.\n@return replace %/_ with regex search characters, also handle escaped\ncharacters."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/OffHeapColumnVector.java",
    "type": "method",
    "name": "reserveInternal",
    "code": "protected void reserveInternal(int newCapacity) {\n    int oldCapacity = (nulls == 0L) ? 0 : capacity;\n    if (isArray() || type instanceof MapType) {\n      this.lengthData =\n          Platform.reallocateMemory(lengthData, oldCapacity * 4L, newCapacity * 4L);\n      this.offsetData =\n          Platform.reallocateMemory(offsetData, oldCapacity * 4L, newCapacity * 4L);\n    } else if (type instanceof ByteType || type instanceof BooleanType) {\n      this.data = Platform.reallocateMemory(data, oldCapacity, newCapacity);\n    } else if (type instanceof ShortType) {\n      this.data = Platform.reallocateMemory(data, oldCapacity * 2L, newCapacity * 2L);\n    } else if (type instanceof IntegerType || type instanceof FloatType ||\n        type instanceof DateType || DecimalType.is32BitDecimalType(type) ||\n        type instanceof YearMonthIntervalType) {\n      this.data = Platform.reallocateMemory(data, oldCapacity * 4L, newCapacity * 4L);\n    } else if (type instanceof LongType || type instanceof DoubleType ||\n        DecimalType.is64BitDecimalType(type) || type instanceof TimestampType ||\n        type instanceof TimestampNTZType || type instanceof DayTimeIntervalType ||\n        type instanceof TimeType) {\n      this.data = Platform.reallocateMemory(data, oldCapacity * 8L, newCapacity * 8L);\n    } else if (childColumns != null) {\n    } else {\n      throw new RuntimeException(\"Unhandled \" + type);\n    }\n    this.nulls = Platform.reallocateMemory(nulls, oldCapacity, newCapacity);\n    Platform.setMemory(nulls + oldCapacity, (byte)0, newCapacity - oldCapacity);\n    capacity = newCapacity;\n  }",
    "comment": "Split out the slow path.\nNothing to store."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/DefaultProblemCollectorTest.java",
    "type": "method",
    "name": "severityErrorDetection",
    "code": "void severityErrorDetection() {\n        ProblemCollector<BuilderProblem> collector = ProblemCollector.create(5);\n\n        assertFalse(collector.hasProblemsFor(BuilderProblem.Severity.WARNING));\n        assertFalse(collector.hasErrorProblems());\n        assertFalse(collector.hasFatalProblems());\n\n        collector.reportProblem(\n                new DefaultBuilderProblem(\"source\", 0, 0, null, \"message\", BuilderProblem.Severity.ERROR));\n\n        assertTrue(collector.hasProblemsFor(BuilderProblem.Severity.WARNING));\n        assertTrue(collector.hasErrorProblems());\n        assertFalse(collector.hasFatalProblems());\n    }",
    "comment": "error triggers error + warning"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/AlbumPage.java",
    "type": "method",
    "name": "saveChanges",
    "code": "public AlbumPage saveChanges() {\n    var saveButton = (HtmlSubmitInput) page.getElementById(\"saveButton\");\n    try {\n      saveButton.click();\n    } catch (IOException e) {\n      LOGGER.error(\"An error occurred on saveChanges.\", e);\n    }\n    return this;\n  }",
    "comment": "Saves changes made by clicking the save button.\n\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/ByteArrayWritableChannel.java",
    "type": "method",
    "name": "write",
    "code": "public int write(ByteBuffer src) {\n    int toTransfer = Math.min(src.remaining(), data.length - offset);\n    src.get(data, offset, toTransfer);\n    offset += toTransfer;\n    return toTransfer;\n  }",
    "comment": "Reads from the given buffer into the internal byte array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dependency-injection/src/test/java/com/iluwatar/dependency/injection/GuiceWizardTest.java",
    "type": "method",
    "name": "testSmokeEveryThingThroughConstructor",
    "code": "void testSmokeEveryThingThroughConstructor() {\n\n    List<Tobacco> tobaccos =\n        List.of(new OldTobyTobacco(), new RivendellTobacco(), new SecondBreakfastTobacco());\n\n    // Verify if the wizard is smoking the correct tobacco ...\n    tobaccos.forEach(\n        tobacco -> {\n          final GuiceWizard guiceWizard = new GuiceWizard(tobacco);\n          guiceWizard.smoke();\n          String lastMessage = appender.getLastMessage();\n          assertEquals(\"GuiceWizard smoking \" + tobacco.getClass().getSimpleName(), lastMessage);\n        });\n\n    // ... and nothing else is happening.\n    assertEquals(tobaccos.size(), appender.getLogSize());\n  }",
    "comment": "Test if the {@link GuiceWizard} smokes whatever instance of {@link Tobacco} is passed to him\nthrough the constructor parameter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "tryToReadFieldValue",
    "code": "public static Try<Object> tryToReadFieldValue(Field field, Object instance) {\n\t\treturn ReflectionUtils.tryToReadFieldValue(field, instance);\n\t}",
    "comment": "Try to read the value of a potentially inaccessible field.\n\n<p>If an exception occurs while reading the field, a failed {@link Try}\nis returned that contains the corresponding exception.\n\n@param field the field to read; never {@code null}\n@param instance the instance from which the value is to be read; may\nbe {@code null} for a static field\n@since 1.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Integer> create(Scope scope, int[][] data) {\n    return create(scope, data, Integer.class);\n  }",
    "comment": "Creates a rank-2 constant of {@code int} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Float expected, float actual) {\n\t\tAssertEquals.assertEquals(expected, (Float) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/sasl/SaslIntegrationSuite.java",
    "type": "method",
    "name": "testBadClient",
    "code": "public void testBadClient() {\n    SecretKeyHolder badKeyHolder = mock(SecretKeyHolder.class);\n    when(badKeyHolder.getSaslUser(anyString())).thenReturn(\"other-app\");\n    when(badKeyHolder.getSecretKey(anyString())).thenReturn(\"wrong-password\");\n    clientFactory = context.createClientFactory(\n        Arrays.asList(new SaslClientBootstrap(conf, \"unknown-app\", badKeyHolder)));\n\n    Exception e = assertThrows(Exception.class,\n      () -> clientFactory.createClient(TestUtils.getLocalHost(), server.getPort()));\n    assertTrue(e.getMessage().contains(\"Mismatched response\"), e.getMessage());\n  }",
    "comment": "Bootstrap should fail on startup."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/function/Try.java",
    "type": "method",
    "name": "andThenTry",
    "code": "public <U> Try<U> andThenTry(Transformer<V, U> transformer) {\n\t\t\treturn uncheckedCast();\n\t\t}",
    "comment": "don't call transformer because this Try is a failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/test/org/apache/spark/JavaTaskContextCompileCheck.java",
    "type": "method",
    "name": "test",
    "code": "public static void test() {\n    TaskContext tc = TaskContext.get();\n\n    tc.isCompleted();\n    tc.isInterrupted();\n\n    tc.addTaskCompletionListener(new JavaTaskCompletionListenerImpl());\n    tc.addTaskFailureListener(new JavaTaskFailureListenerImpl());\n\n    tc.attemptNumber();\n    tc.partitionId();\n    tc.stageId();\n    tc.stageAttemptNumber();\n    tc.taskAttemptId();\n    // this returns a scala Map, so make sure the JMap version give a java type back\n    tc.resources();\n    Map<String, ResourceInformation> resources = tc.resourcesJMap();\n    tc.taskMetrics();\n    tc.taskMemoryManager();\n    tc.getLocalProperties();\n  }",
    "comment": "Something to make sure that TaskContext can be used in Java."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/CollectionUtilsTests.java",
    "type": "method",
    "name": "nullCollection",
    "code": "void nullCollection() {\n\t\t\tvar exception = assertThrows(PreconditionViolationException.class,\n\t\t\t\t() -> CollectionUtils.getOnlyElement(null));\n\t\t\tassertEquals(\"collection must not be null\", exception.getMessage());\n\t\t}",
    "comment": "Unit tests for {@link CollectionUtils}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/AssumptionViolatedException.java",
    "type": "method",
    "name": "AssumptionViolatedException",
    "code": "public AssumptionViolatedException(String assumption, Throwable e) {\n        this(assumption, false, null, null);\n        initCause(e);\n    }",
    "comment": "An assumption exception with the given message and a cause.\n\n@deprecated Please use {@link org.junit.AssumptionViolatedException} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/AppsWithRecoveryDisabled.java",
    "type": "method",
    "name": "isRecoveryEnabledForApp",
    "code": "public static boolean isRecoveryEnabledForApp(String appId) {\n    Preconditions.checkNotNull(appId);\n    return !INSTANCE.appsWithRecoveryDisabled.contains(appId);\n  }",
    "comment": "Returns whether an application is enabled for recovery or not.\n@param appId application id\n@return true if the application is enabled for recovery; false otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/plugin/DefaultReportConfigurationExpander.java",
    "type": "method",
    "name": "expandPluginConfiguration",
    "code": "public void expandPluginConfiguration(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\n        Reporting reporting = model.getReporting();\n\n        if (reporting != null) {\n            for (ReportPlugin reportPlugin : reporting.getPlugins()) {\n                Xpp3Dom parentDom = (Xpp3Dom) reportPlugin.getConfiguration();\n\n                if (parentDom != null) {\n                    for (ReportSet execution : reportPlugin.getReportSets()) {\n                        Xpp3Dom childDom = (Xpp3Dom) execution.getConfiguration();\n                        childDom = Xpp3Dom.mergeXpp3Dom(childDom, new Xpp3Dom(parentDom));\n                        execution.setConfiguration(childDom);\n                    }\n                }\n            }\n        }\n    }",
    "comment": "Handles expansion of general report plugin configuration into individual report sets.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/transfer/ConsoleMavenTransferListener.java",
    "type": "method",
    "name": "ConsoleMavenTransferListener",
    "code": "public ConsoleMavenTransferListener(PrintStream out, boolean printResourceNames) {\n        super(out);\n        this.printResourceNames = printResourceNames;\n    }",
    "comment": "Console download progress meter.\n<p>\nThis listener is not thread-safe and should be wrapped in the {@link SimplexTransferListener} in a multi-threaded scenario."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dynamic-proxy/src/main/java/com/iluwatar/dynamicproxy/tinyrestclient/JsonUtil.java",
    "type": "method",
    "name": "objectToJson",
    "code": "public static <T> String objectToJson(T object) {\n    try {\n      return objectMapper.writeValueAsString(object);\n    } catch (JsonProcessingException e) {\n      LOGGER.error(\"Cannot convert the object \" + object + \" to Json.\", e);\n      return null;\n    }\n  }",
    "comment": "Convert an object to a Json string representation.\n\n@param object Object to convert.\n@param <T> Object's class.\n@return Json string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertNullAssertionsTests.java",
    "type": "method",
    "name": "assertNullWithNonNullObjectWithNullStringReturnedFromToString",
    "code": "private void assertNullWithNonNullObjectWithNullStringReturnedFromToString(Supplier<String> messageSupplier) {\n\t\tString actual = \"null\";\n\t\ttry {\n\t\t\tif (messageSupplier == null) {\n\t\t\t\tassertNull(actual);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertNull(actual, messageSupplier);\n\t\t\t}\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tString prefix = (messageSupplier != null ? messageSupplier.get() + \" ==> \" : \"\");\n\t\t\tassertMessageMatches(ex, prefix + \"expected: <null> but was: java\\\\.lang\\\\.String@.+<null>\");\n\t\t\tassertExpectedAndActualValues(ex, null, actual);\n\t\t}\n\t}",
    "comment": "Should look something like:\nexpected: <null> but was: java.lang.String@264b3504<null>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/iterator/src/main/java/com/iluwatar/iterator/bst/TreeNode.java",
    "type": "method",
    "name": "getParentNodeOfValueToBeInserted",
    "code": "private TreeNode<T> getParentNodeOfValueToBeInserted(T valToInsert) {\n    TreeNode<T> parent = null;\n    var curr = this;\n\n    while (curr != null) {\n      parent = curr;\n      curr = curr.traverseOneLevelDown(valToInsert);\n    }\n\n    return parent;\n  }",
    "comment": "Fetch the Parent TreeNode for a given value to insert into the BST.\n\n@param valToInsert Value of the new TreeNode to be inserted\n@return Parent TreeNode of `valToInsert`"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelData.java",
    "type": "method",
    "name": "setArtifactId",
    "code": "public void setArtifactId(String artifactId) {\n        this.artifactId = artifactId;\n    }",
    "comment": "Sets the effective artifact identifier of the model.\n\n@param artifactId The effective artifact identifier of the model, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "backLog",
    "code": "public int backLog() { return conf.getInt(SPARK_NETWORK_IO_BACKLOG_KEY, -1); }",
    "comment": "Requested maximum length of the queue of incoming connections. If  &lt; 1,\nthe default Netty value of {@link io.netty.util.NetUtil#SOMAXCONN} will be used.\nDefault to -1."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/test/java/org/apache/maven/cli/CLIManagerDocumentationTest.java",
    "type": "method",
    "name": "compare",
    "code": "public int compare(Option opt1, Option opt2) {\n            String s1 = opt1.getOpt() != null ? opt1.getOpt() : opt1.getLongOpt();\n            String s2 = opt2.getOpt() != null ? opt2.getOpt() : opt2.getLongOpt();\n            return s1.compareToIgnoreCase(s2);\n        }",
    "comment": "Pseudo test to generate documentation fragment about supported CLI options. TODO such documentation generation code\nshould not be necessary as unit test but should be run during site generation (Velocity? Doxia macro?)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/internal/AbstractMavenPluginParametersValidator.java",
    "type": "method",
    "name": "isValueSet",
    "code": "protected boolean isValueSet(PlexusConfiguration config, ExpressionEvaluator expressionEvaluator) {\n        if (config == null) {\n            return false;\n        }\n\n        if (config.getChildCount() > 0) {\n            return true;\n        }\n\n        String strValue = config.getValue();\n\n        if (strValue == null || strValue.isEmpty()) {\n            return false;\n        }\n\n        if (isIgnoredProperty(strValue)) {\n            return false;\n        }\n\n\n        try {\n            return expressionEvaluator.evaluate(strValue) != null;\n        } catch (ExpressionEvaluationException e) {\n        }\n\n        return false;\n    }",
    "comment": "there are sub items ... so configuration is declared\nfor declaration like @Parameter( property = \"config.property\" )\nthe value will contain ${config.property}\nnot important\nwill be reported during Mojo fields populate\nfallback - in case of error in expressionEvaluator"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/LoginPage.java",
    "type": "method",
    "name": "login",
    "code": "public AlbumListPage login() {\n    var loginButton = (HtmlSubmitInput) page.getElementById(\"loginButton\");\n    try {\n      loginButton.click();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return new AlbumListPage(webClient);\n  }",
    "comment": "Clicking on the login button to 'login'\n\n@return {@link AlbumListPage} - this is the page that user gets navigated to once successfully\nlogged in"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testBagSimpleAdd",
    "code": "public void testBagSimpleAdd() {\n        IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n        assertEquals(expected, fMB1.add(f14CHF));\n    }",
    "comment": "{[12 CHF][7 USD]} + [14 CHF] == {[26 CHF][7 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/results/PrintableResult.java",
    "type": "method",
    "name": "testResult",
    "code": "public static PrintableResult testResult(Request request) {\n        return new PrintableResult(new JUnitCore().run(request));\n    }",
    "comment": "The result of running JUnit on Request {@code request}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Short expected, short actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Short) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3394POMPluginVersionDominanceTest.java",
    "type": "method",
    "name": "MavenITmng3394POMPluginVersionDominanceTest",
    "code": "public MavenITmng3394POMPluginVersionDominanceTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3394\">MNG-3394</a>:\nit checks that plugin versions in the POM obey the correct order\nof precedence. Specifically, that mojos in the default lifecycle\nbindings can find plugin versions in the pluginManagement section\nwhen the build/plugins section is missing that plugin, and that\nplugin versions in build/plugins override those in build/pluginManagement."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, Float actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals((Float) expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Integer unexpected, Integer actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "getBytes",
    "code": "public byte[] getBytes() {\n    // avoid copy if `base` is `byte[]`\n    if (offset == BYTE_ARRAY_OFFSET && base instanceof byte[] bytes\n      && bytes.length == numBytes) {\n      return bytes;\n    } else {\n      byte[] bytes = new byte[numBytes];\n      copyMemory(base, offset, bytes, BYTE_ARRAY_OFFSET, numBytes);\n      return bytes;\n    }\n  }",
    "comment": "Returns the underline bytes, will be a copy of it if it's part of another array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/feature-toggle/src/main/java/com/iluwatar/featuretoggle/pattern/propertiesversion/PropertiesFeatureToggleVersion.java",
    "type": "method",
    "name": "getWelcomeMessage",
    "code": "public String getWelcomeMessage(final User user) {\n\n    if (isEnhanced()) {\n      return \"Welcome \" + user + \". You're using the enhanced welcome message.\";\n    }\n\n    return \"Welcome to the application.\";\n  }",
    "comment": "Generate a welcome message based on the user being passed and the status of the feature toggle.\nIf the enhanced version is enabled, then the message will be personalised with the name of the\npassed {@link User}. However, if disabled then a generic version fo the message is returned.\n\n@param user the {@link User} to be displayed in the message if the enhanced version is enabled\nsee {@link PropertiesFeatureToggleVersion#isEnhanced()}. If the enhanced version is\nenabled, then the message will be personalised with the name of the passed {@link User}.\nHowever, if disabled then a generic version fo the message is returned.\n@return Resulting welcome message.\n@see User"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/rules/RuleMemberValidator.java",
    "type": "method",
    "name": "validate",
    "code": "public void validate(FrameworkMember<?> member, Class<? extends Annotation> annotation, List<Throwable> errors) {\n            if (!isDeclaringClassPublic(member)) {\n                errors.add(new ValidationError(member, annotation,\n                        \"must be declared in a public class.\"));\n            }\n        }",
    "comment": "Requires the member's declaring class to be public"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java",
    "type": "method",
    "name": "getRequiredTestInstance",
    "code": "default Object getRequiredTestInstance() {\n\t\treturn Preconditions.notNull(getTestInstance().orElse(null),\n\t\t\t\"Illegal state: required test instance is not present in the current ExtensionContext\");\n\t}",
    "comment": "Get the <em>required</em> test instance associated with the current test\nor container.\n\n<p>Use this method as an alternative to {@link #getTestInstance()} for use\ncases in which the test instance is required to be present.\n\n@return the test instance; never {@code null}\n@throws PreconditionViolationException if the test instance is not present\nin this {@code ExtensionContext}\n\n@see #getRequiredTestInstances()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/ServiceUtils.java",
    "type": "method",
    "name": "cleanup",
    "code": "public static void cleanup(SparkLogger log, java.io.Closeable... closeables) {\n    for (java.io.Closeable c : closeables) {\n      if (c != null) {\n        try {\n          c.close();\n        } catch(IOException e) {\n          if (log != null && log.isDebugEnabled()) {\n            log.debug(\"Exception in closing \" + c, e);\n          }\n        }\n      }\n    }\n  }",
    "comment": "Close the Closeable objects and <b>ignore</b> any {@link IOException} or\nnull pointers. Must only be used for cleanup in exception handlers.\n\n@param log the log to record problems to at debug level. Can be null.\n@param closeables the objects to close"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/gpu/java/src/main/java/org/tensorflow/lite/gpu/GpuDelegate.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n    if (delegateHandle != INVALID_DELEGATE_HANDLE) {\n      deleteDelegate(delegateHandle);\n      delegateHandle = INVALID_DELEGATE_HANDLE;\n    }\n  }",
    "comment": "Frees TFLite resources in C runtime.\n\n<p>User is expected to call this method explicitly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, double actual, double delta) {\n\t\tAssertEquals.assertEquals(expected, actual, delta);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/poison-pill/src/test/java/com/iluwatar/poison/pill/ConsumerTest.java",
    "type": "method",
    "name": "createMessage",
    "code": "private static Message createMessage(final String sender, final String message) {\n    final var msg = new SimpleMessage();\n    msg.addHeader(Message.Headers.SENDER, sender);\n    msg.addHeader(Message.Headers.DATE, LocalDateTime.now().toString());\n    msg.setBody(message);\n    return msg;\n  }",
    "comment": "Create a new message from the given sender with the given message body\n\n@param sender The sender's name\n@param message The message body\n@return The message instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "Session",
    "code": "public Session(Graph g, byte[] config) {\n    graph = g;\n    Graph.Reference r = g.ref();\n    try {\n      nativeHandle =\n          (config == null) ? allocate(r.nativeHandle()) : allocate2(r.nativeHandle(), null, config);\n      graphRef = g.ref();\n    } finally {\n      r.close();\n    }\n  }",
    "comment": "Construct a new session with the associated {@link Graph} and configuration options.\n@param config Configuration parameters for the session specified as a serialized <a\nhref=\"https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto\">ConfigProto</a>\nprotocol buffer.\n@throws IllegalArgumentException if the config is not a valid serialization of the ConfigProto\nprotocol buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/partitioning/KeyGroupedPartitioning.java",
    "type": "method",
    "name": "KeyGroupedPartitioning",
    "code": "public KeyGroupedPartitioning(Expression[] keys, int numPartitions) {\n    this.keys = keys;\n    this.numPartitions = numPartitions;\n  }",
    "comment": "Represents a partitioning where rows are split across partitions based on the\npartition transform expressions returned by {@link KeyGroupedPartitioning#keys}.\n<p>\nNote: Data source implementations should make sure for a single partition, all of its rows\nmust be evaluated to the same partition value after being applied by\n{@link KeyGroupedPartitioning#keys} expressions. Different partitions can share the same\npartition value: Spark will group these into a single logical partition during planning phase.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/thrift/ThriftHttpServlet.java",
    "type": "method",
    "name": "getClientNameFromCookie",
    "code": "private String getClientNameFromCookie(Cookie[] cookies) {\n    // Current Cookie Name, Current Cookie Value\n    String currName, currValue;\n\n    // Following is the main loop which iterates through all the cookies send by the client.\n    // The HS2 generated cookies are of the format hive.server2.auth=<value>\n    // A cookie which is identified as a hiveserver2 generated cookie is validated\n    // by calling signer.verifyAndExtract(). If the validation passes, send the\n    // username for which the cookie is validated to the caller. If no client side\n    // cookie passes the validation, return null to the caller.\n    for (Cookie currCookie : cookies) {\n      // Get the cookie name\n      currName = currCookie.getName();\n      if (!currName.equals(AUTH_COOKIE)) {\n        // Not a HS2 generated cookie, continue.\n        continue;\n      }\n      // If we reached here, we have match for HS2 generated cookie\n      currValue = currCookie.getValue();\n      // Validate the value.\n      currValue = signer.verifyAndExtract(currValue);\n      // Retrieve the user name, do the final validation step.\n      if (currValue != null) {\n        String userName = HttpAuthUtils.getUserNameFromCookieToken(currValue);\n\n        if (userName == null) {\n          LOG.warn(\"Invalid cookie token {}\", MDC.of(LogKeys.TOKEN$.MODULE$, currValue));\n          continue;\n        }\n        //We have found a valid cookie in the client request.\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Validated the cookie for user \" + userName);\n        }\n        return userName;\n      }\n    }\n    // No valid HS2 generated cookies found, return null\n    return null;\n  }",
    "comment": "Retrieves the client name from cookieString. If the cookie does not\ncorrespond to a valid client, the function returns null.\n@param cookies HTTP Request cookies.\n@return Client Username if cookieString has a HS2 Generated cookie that is currently valid.\nElse, returns null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestReporter.java",
    "type": "method",
    "name": "publishDirectory",
    "code": "default void publishDirectory(Path directory) {\n\t\tPreconditions.condition(Files.exists(directory), () -> \"directory must exist: \" + directory);\n\t\tPreconditions.condition(Files.isDirectory(directory), () -> \"directory must be a directory: \" + directory);\n\t\tpublishDirectory(directory.getFileName().toString(), path -> {\n\t\t\ttry (Stream<Path> stream = Files.walk(directory)) {\n\t\t\t\tstream.forEach(source -> {\n\t\t\t\t\tPath destination = path.resolve(directory.relativize(source));\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (Files.isDirectory(source)) {\n\t\t\t\t\t\t\tFiles.createDirectories(destination);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tFiles.copy(source, destination, REPLACE_EXISTING);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t\tthrow new UncheckedIOException(\"Failed to copy files to the output directory\", e);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}",
    "comment": "Publish the supplied directory and attach it to the current test or\ncontainer.\n\n<p>The entire directory will be copied to the report output directory\nreplacing any potentially existing files with the same name.\n\n@param directory the file to be attached; never {@code null} or blank\n@since 5.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelBuilder.java",
    "type": "method",
    "name": "mergeRepositories",
    "code": "public void mergeRepositories(Model model, boolean replace) {\n            if (model.getRepositories().isEmpty()) {\n                return;\n            }\n            Model interpolatedModel = interpolateModel(\n                    Model.newBuilder()\n                            .pomFile(model.getPomFile())\n                            .repositories(model.getRepositories())\n                            .build(),\n                    request,\n                    this);\n            List<RemoteRepository> repos = interpolatedModel.getRepositories().stream()\n                    .map(session::createRemoteRepository)\n                    .toList();\n            if (replace) {\n                Set<String> ids = repos.stream().map(RemoteRepository::getId).collect(Collectors.toSet());\n                repositories = repositories.stream()\n                        .filter(r -> !ids.contains(r.getId()))\n                        .toList();\n                pomRepositories = pomRepositories.stream()\n                        .filter(r -> !ids.contains(r.getId()))\n                        .toList();\n            } else {\n                Set<String> ids =\n                        pomRepositories.stream().map(RemoteRepository::getId).collect(Collectors.toSet());\n                repos = repos.stream().filter(r -> !ids.contains(r.getId())).toList();\n            }\n\n            RepositoryFactory repositoryFactory = session.getService(RepositoryFactory.class);\n            if (request.getRepositoryMerging() == ModelBuilderRequest.RepositoryMerging.REQUEST_DOMINANT) {\n                repositories = repositoryFactory.aggregate(session, repositories, repos, true);\n                pomRepositories = repositories;\n            } else {\n                pomRepositories = repositoryFactory.aggregate(session, pomRepositories, repos, true);\n                repositories = repositoryFactory.aggregate(session, pomRepositories, externalRepositories, false);\n            }\n        }",
    "comment": "We need to interpolate the repositories before we can use them"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng2562Timestamp322Test.java",
    "type": "method",
    "name": "MavenITmng2562Timestamp322Test",
    "code": "public MavenITmng2562Timestamp322Test() {\n        super(\"[3.2.2,)\"); // 3.2.2+ only as we changed the timestamp format\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-2562\">MNG-2562</a>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "getLongs",
    "code": "public long[] getLongs(int rowId, int count) {\n    long[] res = new long[count];\n    for (int i = 0; i < count; i++) {\n      res[i] = getLong(rowId + i);\n    }\n    return res;\n  }",
    "comment": "Gets long type values from {@code [rowId, rowId + count)}. The return values for the null slots\nare undefined and can be anything."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "setPropertiesFile",
    "code": "public SparkLauncher setPropertiesFile(String path) {\n    return super.setPropertiesFile(path);\n  }",
    "comment": "The following methods just delegate to the parent class, but they are needed to keep\nbinary compatibility with previous versions of this class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/CLIService.java",
    "type": "method",
    "name": "start",
    "code": "public synchronized void start() {\n    super.start();\n    IMetaStoreClient metastoreClient = null;\n    try {\n      metastoreClient = new HiveMetaStoreClient(hiveConf);\n      metastoreClient.getDatabases(\"default\");\n    } catch (Exception e) {\n      throw new ServiceException(\"Unable to connect to MetaStore!\", e);\n    }\n    finally {\n      if (metastoreClient != null) {\n        metastoreClient.close();\n      }\n    }\n  }",
    "comment": "Initialize and test a connection to the metastore"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProjectActivation.java",
    "type": "method",
    "name": "addProjectActivation",
    "code": "public void addProjectActivation(String selector, boolean active, boolean optional) {\n        final ActivationSettings settings = ActivationSettings.of(active, optional);\n        this.activations.add(new ProjectActivationSettings(selector, settings));\n    }",
    "comment": "Adds a project activation to the request.\n@param selector The selector of the project.\n@param active Should the project be activated?\n@param optional Can the build continue if the project does not exist?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/BuildFailure.java",
    "type": "method",
    "name": "BuildFailure",
    "code": "public BuildFailure(MavenProject project, Duration execTime, Duration wallTime, Throwable cause) {\n        super(project, execTime, wallTime);\n        this.cause = cause;\n    }",
    "comment": "Creates a new build summary for the specified project.\n\n@param project The project being summarized, must not be {@code null}.\n@param execTime The exec time of the project in milliseconds.\n@param wallTime The wall time of the project in milliseconds.\n@param cause The cause of the build failure, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/monitor/src/main/java/com/iluwatar/monitor/Bank.java",
    "type": "method",
    "name": "getBalance",
    "code": "public synchronized int getBalance(int accountNumber) {\n    return accounts[accountNumber];\n  }",
    "comment": "Get the accountNumber balance.\n\n@param accountNumber - accountNumber number\n@return accounts[accountNumber]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/NumericHistogram.java",
    "type": "method",
    "name": "isReady",
    "code": "public boolean isReady() {\n    return nbins != 0;\n  }",
    "comment": "Returns true if this histogram object has been initialized by calling merge()\nor allocate()."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/throttling/src/main/java/com/iluwatar/throttling/CallsCount.java",
    "type": "method",
    "name": "addTenant",
    "code": "public void addTenant(String tenantName) {\n    tenantCallsCount.putIfAbsent(tenantName, new AtomicLong(0));\n  }",
    "comment": "Add a new tenant to the map.\n\n@param tenantName name of the tenant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fanout-fanin/src/main/java/com/iluwatar/fanout/fanin/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    final List<Long> numbers = Arrays.asList(1L, 3L, 4L, 7L, 8L);\n\n    LOGGER.info(\"Numbers to be squared and get sum --> {}\", numbers);\n\n    final List<SquareNumberRequest> requests =\n        numbers.stream().map(SquareNumberRequest::new).toList();\n\n    var consumer = new Consumer(0L);\n\n    // Pass the request and the consumer to fanOutFanIn or sometimes referred as Orchestrator\n    // function\n    final Long sumOfSquaredNumbers = FanOutFanIn.fanOutFanIn(requests, consumer);\n\n    LOGGER.info(\"Sum of all squared numbers --> {}\", sumOfSquaredNumbers);\n  }",
    "comment": "Entry point.\n\n<p>Implementation provided has a list of numbers that has to be squared and added. The list can\nbe chunked in any way and the \"activity function\" {@link\nSquareNumberRequest#delayedSquaring(Consumer)} i.e. squaring the number ca be done\nconcurrently. The \"fan in\" part is handled by the {@link Consumer} that takes in the result\nfrom each instance of activity and aggregates it whenever that particular activity function\ngets over."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithErrorCollectorStoringMultipleFailures.java",
    "type": "method",
    "name": "example",
    "code": "public void example() {\n\t\tcollector.addError(new Throwable(\"first thing went wrong\"));\n\t\tcollector.addError(new Throwable(\"second thing went wrong\"));\n\t\tcollector.checkThat(getResult(), not(containsString(\"ERROR!\")));\n\t}",
    "comment": "all lines will run, and then a combined failure logged at the end."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeOnSuccessFailingStaticField",
    "code": "void cleanupModeOnSuccessFailingStaticField() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectClass(OnSuccessFailingStaticFieldCase.class))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(onSuccessFailingFieldDir).exists();\n\t\t}",
    "comment": "Ensure that ON_SUCCESS cleanup modes are obeyed for static fields when tests are failing.\n<p/>\nExpect the TempDir not to be cleaned up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/runners/CustomBlockJUnit4ClassRunnerTest.java",
    "type": "method",
    "name": "shouldPass",
    "code": "@Test public void shouldPass() { /* no-op */ }\n\t\t@Test public void throwException() { /* no-op */ }",
    "comment": "Tests that verify proper behavior for custom runners that extend\n{@link BlockJUnit4ClassRunner}.\n\n@author Sam Brannen\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetColumnVector.java",
    "type": "method",
    "name": "getLeaves",
    "code": "List<ParquetColumnVector> getLeaves() {\n    List<ParquetColumnVector> result = new ArrayList<>();\n    getLeavesHelper(this, result);\n    return result;\n  }",
    "comment": "Returns all the leaf columns in depth-first order."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/scanning/ClassFilter.java",
    "type": "method",
    "name": "match",
    "code": "public boolean match(String name) {\n\t\treturn namePredicate.test(name);\n\t}",
    "comment": "Test the given name using the stored name predicate.\n\n@param name the name to test; never {@code null}\n@return {@code true} if the input name matches the predicate, otherwise\n{@code false}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeArrayWriter.java",
    "type": "method",
    "name": "setNull2Bytes",
    "code": "public void setNull2Bytes(int ordinal) {\n    setNullBit(ordinal);\n    writeShort(getElementOffset(ordinal), (short)0);\n  }",
    "comment": "put zero into the corresponding field when set null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/test/java/org/apache/maven/model/building/FileToRawModelMergerTest.java",
    "type": "method",
    "name": "testOverriddenMergeMethods",
    "code": "void testOverriddenMergeMethods() {\n        List<String> methodNames = Stream.of(MavenMerger.class.getDeclaredMethods())\n                .filter(m -> m.getName().startsWith(\"merge\"))\n                .filter(m -> {\n                    String baseName = m.getName().substring(5 /* merge */);\n                    String entity = baseName.substring(baseName.indexOf('_') + 1);\n                    try {\n                        Type returnType = m.getParameterTypes()[0]\n                                .getMethod(\"get\" + entity)\n                                .getGenericReturnType();\n                        if (returnType instanceof ParameterizedType parameterizedType) {\n                            return !parameterizedType.getActualTypeArguments()[0].equals(String.class);\n                        } else {\n                            return false;\n                        }\n                    } catch (ReflectiveOperationException | SecurityException e) {\n                        return false;\n                    }\n                })\n                .map(Method::getName)\n                .toList();\n\n        List<String> overriddenMethods = Stream.of(FileToRawModelMerger.class.getDeclaredMethods())\n                .map(Method::getName)\n                .filter(m -> m.startsWith(\"merge\"))\n                .collect(Collectors.toList());\n\n        assertThat(overriddenMethods, hasItems(methodNames.toArray(new String[0])));\n    }",
    "comment": "Ensures that all list-merge methods are overridden"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-builder-support/src/main/java/org/apache/maven/building/FileSource.java",
    "type": "method",
    "name": "FileSource",
    "code": "public FileSource(Path path) {\n        this.path = Objects.requireNonNull(path, \"path cannot be null\").toAbsolutePath();\n        this.hashCode = Objects.hash(path);\n    }",
    "comment": "Creates a new source backed by the specified file.\n\n@param path The file, must not be {@code null}.\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Long> create(long[][][][] data) {\n    return Tensor.create(data, Long.class);\n  }",
    "comment": "Creates a rank-4 tensor of {@code long} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/constraints/Constraint.java",
    "type": "method",
    "name": "unique",
    "code": "static Unique.Builder unique(String name, NamedReference[] columns) {\n    return new Unique.Builder(name, columns);\n  }",
    "comment": "Instantiates a builder for a UNIQUE constraint.\n\n@param name the constraint name\n@param columns columns that comprise the unique key\n@return a UNIQUE constraint builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertNotNull",
    "code": "public static void assertNotNull(String message, Object object) {\n        Assert.assertNotNull(message, object);\n    }",
    "comment": "Asserts that an object isn't null. If it is\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/component/src/main/java/com/iluwatar/component/component/inputcomponent/DemoInputComponent.java",
    "type": "method",
    "name": "update",
    "code": "public void update(GameObject gameObject, int e) {\n    gameObject.updateVelocity(WALK_ACCELERATION);\n    LOGGER.info(gameObject.getName() + \" has moved right.\");\n  }",
    "comment": "Redundant method in the demo mode.\n\n@param gameObject the gameObject instance\n@param e key event instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "PropertiesReader",
    "code": "public PropertiesReader(Reader reader, boolean maybeTyped) {\n            super(reader);\n            commentLines = new ArrayList<>();\n            valueLines = new ArrayList<>();\n            this.maybeTyped = maybeTyped;\n        }",
    "comment": "Creates a new instance of <code>PropertiesReader</code> and sets\nthe underlaying reader and the list delimiter.\n\n@param reader the reader"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarRow.java",
    "type": "method",
    "name": "ColumnarRow",
    "code": "public ColumnarRow(ColumnVector data, int rowId) {\n    assert (data.dataType() instanceof StructType);\n    this.data = data;\n    this.rowId = rowId;\n    this.numFields = ((StructType) data.dataType()).size();\n  }",
    "comment": "Row abstraction in {@link ColumnVector}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/prefix/DefaultPluginPrefixRequest.java",
    "type": "method",
    "name": "DefaultPluginPrefixRequest",
    "code": "public DefaultPluginPrefixRequest(String prefix, MavenSession session) {\n        setPrefix(prefix);\n\n        setRepositorySession(session.getRepositorySession());\n\n        MavenProject project = session.getCurrentProject();\n        if (project != null) {\n            setRepositories(project.getRemotePluginRepositories());\n            setPom(project.getModel());\n        }\n\n        setPluginGroups(session.getPluginGroups());\n    }",
    "comment": "Creates a request for the specified plugin prefix and build session. The provided build session will be used to\nconfigure repository settings. If the session has a current project, its plugin repositories and model will be\nused as well.\n\n@param prefix The plugin prefix to resolve, must not be {@code null}.\n@param session The build session from which to derive further settings, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertionTestUtils.java",
    "type": "method",
    "name": "runOutOfMemory",
    "code": "static void runOutOfMemory() {\n\t\tthrow new OutOfMemoryError(\"boom\");\n\t}",
    "comment": "simulate running out of memory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/front-controller/src/main/java/com/iluwatar/front/controller/FrontController.java",
    "type": "method",
    "name": "FrontController",
    "code": "public FrontController() {\n    this.dispatcher = new Dispatcher();\n  }",
    "comment": "The FrontController is responsible for handling all incoming requests. It delegates the\nprocessing of requests to the Dispatcher, which then determines the appropriate command and view\nto render the correct response."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/MavenRepositorySystemUtils.java",
    "type": "method",
    "name": "newSession",
    "code": "public static DefaultRepositorySystemSession newSession() {\n        DefaultRepositorySystemSession session = new DefaultRepositorySystemSession(h -> false); // no close handle\n        MavenSessionBuilderSupplier builder = new MavenSessionBuilderSupplier();\n        session.setDependencyTraverser(builder.getDependencyTraverser());\n        session.setDependencyManager(new ClassicDependencyManager()); // Maven 3 behavior\n        session.setDependencySelector(builder.getDependencySelector());\n        session.setDependencyGraphTransformer(builder.getDependencyGraphTransformer());\n        session.setArtifactTypeRegistry(builder.getArtifactTypeRegistry());\n        session.setArtifactDescriptorPolicy(builder.getArtifactDescriptorPolicy());\n        return session;\n    }",
    "comment": "This method is deprecated, nobody should use it.\n\n@deprecated This method is here only for legacy uses (like UTs), nothing else should use it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "fileEntryPublished",
    "code": "public static Event fileEntryPublished(TestDescriptor testDescriptor, FileEntry file) {\n\t\tPreconditions.notNull(file, \"FileEntry must not be null\");\n\t\treturn new Event(EventType.FILE_ENTRY_PUBLISHED, testDescriptor, file);\n\t}",
    "comment": "Create an {@code Event} for a published file for the supplied\n{@link TestDescriptor} and {@link FileEntry}.\n\n@param testDescriptor the {@code TestDescriptor} associated with the event;\nnever {@code null}\n@param file the {@code FileEntry} that was published; never {@code null}\n@return the newly created {@code Event}\n@since 1.12\n@see EventType#FILE_ENTRY_PUBLISHED"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/FileSelector.java",
    "type": "method",
    "name": "getFile",
    "code": "public File getFile() {\n\t\treturn new File(this.path);\n\t}",
    "comment": "Get the selected file as a {@link java.io.File}.\n\n@see #getPath()\n@see #getRawPath()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultSettingsBuilder.java",
    "type": "method",
    "name": "SettingsMerger",
    "code": "private final SettingsMerger settingsMerger = new SettingsMerger() {\n    };",
    "comment": "Builds the effective settings from a user settings file and/or a global settings file."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(short expected, short actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/AbstractExecutionListener.java",
    "type": "method",
    "name": "projectDiscoveryStarted",
    "code": "public void projectDiscoveryStarted(ExecutionEvent event) {\n        // default does nothing\n    }",
    "comment": "Provides a skeleton implementation for execution listeners. The methods of this class are empty."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toLowerCase",
    "code": "public UTF8String toLowerCase() {\n    if (numBytes == 0) {\n      return EMPTY_UTF8;\n    }\n\n    return isFullAscii() ? toLowerCaseAscii() : toLowerCaseSlow();\n  }",
    "comment": "Returns the lower case of this string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerOperationBuilder.java",
    "type": "method",
    "name": "build",
    "code": "public EagerOperation build() {\n    long[] tensorHandles = execute(nativeRef.opHandle);\n    EagerOperation operation =\n        new EagerOperation(session, nativeRef.opHandle, tensorHandles, type, name);\n    nativeRef.clear();\n    return operation;\n  }",
    "comment": "Release our reference to the native op handle now that we transferred its\nownership to the EagerOperation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "dynamicTestRegistered",
    "code": "public static Condition<Event> dynamicTestRegistered(Condition<Event> condition) {\n\t\treturn allOf(type(DYNAMIC_TEST_REGISTERED), condition);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link EventType#DYNAMIC_TEST_REGISTERED} and it matches the supplied\n{@code Condition}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Computer.java",
    "type": "method",
    "name": "serial",
    "code": "public static Computer serial() {\n        return new Computer();\n    }",
    "comment": "Returns a new default computer, which runs tests in serial order"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/ParquetAvroCompat.java",
    "type": "method",
    "name": "setStringsColumn",
    "code": "public void setStringsColumn(java.util.List<java.lang.String> value) {\n    this.strings_column = value;\n  }",
    "comment": "Sets the value of the 'strings_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "setPomFile",
    "code": "public void setPomFile(File file) {\n        this.file = file;\n    }",
    "comment": "Sets project {@code file} without changing project {@code basedir}.\n\n@since 3.2.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "encryptionEnabled",
    "code": "public boolean encryptionEnabled() {\n    return conf.getBoolean(\"spark.network.crypto.enabled\", false);\n  }",
    "comment": "Enables strong encryption. Also enables the new auth protocol, used to negotiate keys."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/test/java/org/apache/spark/sql/catalyst/expressions/XXH64Suite.java",
    "type": "method",
    "name": "randomizedStressTestBytes",
    "code": "public void randomizedStressTestBytes() {\n    int size = 65536;\n    Random rand = new Random();\n\n    Set<Long> hashcodes = new HashSet<>();\n    for (int i = 0; i < size; i++) {\n      int byteArrSize = rand.nextInt(100) * 8;\n      byte[] bytes = new byte[byteArrSize];\n      rand.nextBytes(bytes);\n\n      Assertions.assertEquals(\n              hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize),\n              hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n\n      hashcodes.add(hasher.hashUnsafeWords(\n              bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n    }\n\n    Assertions.assertTrue(hashcodes.size() > size * 0.95d);\n  }",
    "comment": "A set used to track collision rate.\nA very loose bound."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/App.java",
    "type": "method",
    "name": "isDbMongo",
    "code": "private static boolean isDbMongo(final String[] args) {\n    for (String arg : args) {\n      if (arg.equals(USE_MONGO_DB)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "Check the input parameters. if\n\n@param args input params\n@return true if there is \"--mongo\" parameter in arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/array/LongArray.java",
    "type": "method",
    "name": "LongArray",
    "code": "public LongArray(MemoryBlock memory) {\n    assert memory.size() < (long) Integer.MAX_VALUE * 8: \"Array size >= Integer.MAX_VALUE elements\";\n    this.memory = memory;\n    this.baseObj = memory.getBaseObject();\n    this.baseOffset = memory.getBaseOffset();\n    this.length = memory.size() / WIDTH;\n  }",
    "comment": "An array of long values. Compared with native JVM arrays, this:\n<ul>\n<li>supports using both on-heap and off-heap memory</li>\n<li>has no bound checking, and thus can crash the JVM process when assert is turned off</li>\n</ul>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultInheritanceAssembler.java",
    "type": "method",
    "name": "concatPath",
    "code": "private void concatPath(StringBuilder url, String path) {\n            if (!path.isEmpty()) {\n                boolean initialUrlEndsWithSlash = url.charAt(url.length() - 1) == '/';\n                boolean pathStartsWithSlash = path.charAt(0) == '/';\n\n                if (pathStartsWithSlash) {\n                    if (initialUrlEndsWithSlash) {\n                        url.setLength(url.length() - 1);\n                    }\n                } else if (!initialUrlEndsWithSlash) {\n                    url.append('/');\n                }\n\n                url.append(path);\n\n                if (initialUrlEndsWithSlash && !path.endsWith(\"/\")) {\n                    url.append('/');\n                }\n            }\n        }",
    "comment": "1 extra '/' to remove\nadd missing '/' between url and path\nensure resulting url ends with slash if initial url was"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertionFailureBuilder.java",
    "type": "method",
    "name": "includeValuesInMessage",
    "code": "public AssertionFailureBuilder includeValuesInMessage(boolean includeValuesInMessage) {\n\t\tthis.includeValuesInMessage = includeValuesInMessage;\n\t\treturn this;\n\t}",
    "comment": "Set whether to include the actual and expected values in the generated\nfailure message.\n\n@param includeValuesInMessage whether to include the actual and expected\nvalues\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaOneVsRestExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaOneVsRestExample\")\n      .getOrCreate();\n\n    // $example on$\n    // load data file.\n    Dataset<Row> inputData = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_multiclass_classification_data.txt\");\n\n    // generate the train/test split.\n    Dataset<Row>[] tmp = inputData.randomSplit(new double[]{0.8, 0.2});\n\n}",
    "comment": "An example of Multiclass to Binary Reduction with One Vs Rest,\nusing Logistic Regression as the base classifier.\nRun with\n<pre>\nbin/run-example ml.JavaOneVsRestExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java",
    "type": "method",
    "name": "orderAnnotationOnNestedTestClassesWithLocalConfig",
    "code": "void orderAnnotationOnNestedTestClassesWithLocalConfig(@TrackLogRecords LogRecordListener listener) {\n\t\texecuteTests(ClassOrderer.class, selectClass(OuterWithLocalConfig.class))//\n\t\t\t\t.assertStatistics(stats -> stats.succeeded(callSequence.size()));\n\n\t\tassertTrue(listener.stream(Level.WARNING)//\n\t\t\t\t.map(LogRecord::getMessage)//\n\t\t\t\t.anyMatch(m -> m.startsWith(\n\t\t\t\t\t\"Failed to load default class orderer class 'org.junit.jupiter.api.ClassOrderer'\")));\n\n\t\tassertThat(callSequence)//\n\t\t\t\t.containsExactly(\"Inner2\", \"Inner1\", \"Inner1Inner1\", \"Inner1Inner0\", \"Inner0\", \"Inner3\");\n\t}",
    "comment": "Ensure that supplying the ClassOrderer interface instead of an implementation\nclass results in a WARNING log message. This also lets us know the local\nconfig is used."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/active-object/src/main/java/com/iluwatar/activeobject/ActiveCreature.java",
    "type": "method",
    "name": "kill",
    "code": "public void kill(int status) {\n    this.status = status;\n    this.thread.interrupt();\n  }",
    "comment": "Kills the thread of execution.\n\n@param status of the thread of execution. 0 == OK, the rest is logging an error."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/app/LoggingHandler.java",
    "type": "method",
    "name": "if",
    "code": "if (readObject instanceof ByteBuffer) {\n      doLogging((ByteBuffer) readObject);\n      sendReply(channel, key);\n    } else if (readObject instanceof DatagramPacket datagram) {\n      doLogging(datagram.getData());\n      sendReply(channel, datagram, key);\n    } else {\n      throw new IllegalStateException(\"Unknown data received\");\n    }",
    "comment": "@Override\npublic void handleChannelRead(AbstractNioChannel channel, Object readObject, SelectionKey key) {\n/*\nAs this handler is attached with both TCP and UDP channels we need to check whether the data\nreceived is a ByteBuffer (from TCP channel) or a DatagramPacket (from UDP channel)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Float> create(float[] data) {\n    return Tensor.create(data, Float.class);\n  }",
    "comment": "Creates a rank-1 tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setInt",
    "code": "public void setInt(int value) {\n    intData = value;\n  }",
    "comment": "Sets the int `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java",
    "type": "method",
    "name": "getHeaders",
    "code": "static String[] getHeaders(CsvParser csvParser) {\n\t\treturn Arrays.stream(csvParser.getContext().parsedHeaders())//\n\t\t\t\t.map(String::trim)//\n\t\t\t\t.toArray(String[]::new);\n\t}",
    "comment": "Cannot get parsed headers until after parsing has started."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Integer unexpected, int actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Integer) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/component/src/main/java/com/iluwatar/component/GameObject.java",
    "type": "method",
    "name": "createNpc",
    "code": "public static GameObject createNpc() {\n    return new GameObject(\n        new DemoInputComponent(), new ObjectPhysicComponent(), new ObjectGraphicComponent(), \"npc\");\n  }",
    "comment": "Creates a NPC game object.\n\n@return npc object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/SupportsDeleteV2.java",
    "type": "method",
    "name": "truncateTable",
    "code": "default boolean truncateTable() {\n    Predicate[] predicates = new Predicate[] { new AlwaysTrue() };\n    return canDelete;\n  }",
    "comment": "Delete data from a data source table that matches filter expressions. Note that this method\nwill be invoked only if {@link #canDeleteWhere(Predicate[])} returns true.\n<p>\nRows are deleted from the data source iff all of the filter expressions match. That is, the\nexpressions must be interpreted as a set of filters that are ANDed together.\n<p>\nImplementations may reject a delete operation if the delete isn't possible without significant\neffort. For example, partitioned data sources may reject deletes that do not filter by\npartition columns because the filter may require rewriting files without deleted records.\nTo reject a delete implementations should throw {@link IllegalArgumentException} with a clear\nerror message that identifies which expression was rejected.\n\n@param predicates predicate expressions, used to select rows to delete when all expressions\nmatch\n@throws IllegalArgumentException If the delete is rejected due to required effort"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertAllAssertionsTests.java",
    "type": "method",
    "name": "assertAllWithNullExecutableArray",
    "code": "void assertAllWithNullExecutableArray() {\n\t\tassertPrecondition(\"executables array must not be null or empty\", () -> assertAll((Executable[]) null));\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/main/java/com/iluwatar/NotificationError.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n    return \"Error \" + errorId + \": \" + errorMessage;\n  }",
    "comment": "Error class for storing information on the error. Error ID is not necessary, but may be useful\nfor serialisation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/array/LongArray.java",
    "type": "method",
    "name": "get",
    "code": "public long get(int index) {\n    assert index >= 0 : \"index (\" + index + \") should >= 0\";\n    assert index < length : \"index (\" + index + \") should < length (\" + length + \")\";\n    return Platform.getLong(baseObj, baseOffset + index * WIDTH);\n  }",
    "comment": "Returns the value at position {@code index}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng7470ResolverTransportTest.java",
    "type": "method",
    "name": "isJdkTransportPresent",
    "code": "private boolean isJdkTransportPresent() {\n        return JDK_TRANSPORT_IN_MAVEN_SINCE.compareTo(getMavenVersion()) < 1;\n    }",
    "comment": "Returns {@code true} if JDK HttpClient transport is present in Maven (since 4.0.0-alpha-9, the Resolver 2.0.0\nupgrade)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "filters",
    "code": "public SuiteLauncherDiscoveryRequestBuilder filters(Filter<?>... filters) {\n\t\tthis.delegate.filters(filters);\n\t\treturn this;\n\t}",
    "comment": "Add all supplied {@code filters} to the request.\n\n<p>The {@code filters} are combined using AND semantics, i.e. all of them\nhave to include a resource for it to end up in the test plan.\n\n<p><strong>Warning</strong>: be cautious when registering multiple competing\n{@link EngineFilter#includeEngines include} {@code EngineFilters} or multiple\ncompeting {@link EngineFilter#excludeEngines exclude} {@code EngineFilters}\nfor the same discovery request since doing so will likely lead to\nundesirable results (i.e., zero engines being active).\n\n@param filters the {@code Filter}s to add; never {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/strangler/src/main/java/com/iluwatar/strangler/HalfArithmetic.java",
    "type": "method",
    "name": "HalfArithmetic",
    "code": "public HalfArithmetic(HalfSource newSource, OldSource oldSource) {\n    this.newSource = newSource;\n    this.oldSource = oldSource;\n  }",
    "comment": "System under migration. Depends on old version source ({@link OldSource}) and developing one\n({@link HalfSource})."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/types/UTF8StringSuite.java",
    "type": "method",
    "name": "split",
    "code": "public void split() {\n    UTF8String[] negativeAndZeroLimitCase =\n      new UTF8String[]{fromString(\"ab\"), fromString(\"def\"), fromString(\"ghi\"), fromString(\"\")};\n      new UTF8String[]{fromString(\"ab\"), fromString(\"def,ghi,\")},\n      new UTF8String[]{fromString(\"a\"), fromString(\"b\")},\n      new UTF8String[]{fromString(\"a\"), fromString(\"b\")},\n      new UTF8String[]{fromString(\"a\"), fromString(\"b\")},\n      new UTF8String[]{fromString(\"a\"), fromString(\"b\")},\n      new UTF8String[]{fromString(\"a\")},\n      new UTF8String[]{fromString(\"\")},\n\n  @Test\n  public void replace() {\n    assertEquals(\n      fromString(\"re123ace\"),\n      fromString(\"replace\").replace(fromString(\"pl\"), fromString(\"123\")));\n    assertEquals(\n      fromString(\"reace\"),\n      fromString(\"replace\").replace(fromString(\"pl\"), fromString(\"\")));\n    assertEquals(\n      fromString(\"replace\"),\n      fromString(\"replace\").replace(fromString(\"\"), fromString(\"123\")));\n    assertEquals(\n      fromString(\"a12ca12c\"),\n      fromString(\"abcabc\").replace(fromString(\"b\"), fromString(\"12\")));\n    assertEquals(\n      fromString(\"adad\"),\n      fromString(\"abcdabcd\").replace(fromString(\"bc\"), fromString(\"\")));\n    assertEquals(\n      fromString(\"AbcAbc\"),\n      fromString(\"abcabc\").replace(fromString(\"a\"), fromString(\"A\")));\n    assertEquals(\n      fromString(\"abcabc\"),\n      fromString(\"abcabc\").replace(fromString(\"Z\"), fromString(\"A\")));\n    assertEquals(\n      fromString(\"ab\"),\n      fromString(\"\").replace(fromString(\"\"), fromString(\"ab\")));\n    assertEquals(\n      fromString(\"ac\"),\n      fromString(\"ac\").replace(fromString(\"\"), fromString(\"\")));\n    assertEquals(\n      fromString(\"abcd\").repeat(17),\n      fromString(\"a\").repeat(17).replace(fromString(\"a\"), fromString(\"abcd\")));\n  }\n\n  @Test\n  public void levenshteinDistance() {\n    assertEquals(0, EMPTY_UTF8.levenshteinDistance(EMPTY_UTF8));\n    assertEquals(1, EMPTY_UTF8.levenshteinDistance(fromString(\"a\")));\n    assertEquals(7, fromString(\"aaapppp\").levenshteinDistance(EMPTY_UTF8));\n    assertEquals(1, fromString(\"frog\").levenshteinDistance(fromString(\"fog\")));\n    assertEquals(3, fromString(\"fly\").levenshteinDistance(fromString(\"ant\")));\n    assertEquals(7, fromString(\"elephant\").levenshteinDistance(fromString(\"hippo\")));\n    assertEquals(7, fromString(\"hippo\").levenshteinDistance(fromString(\"elephant\")));\n    assertEquals(8, fromString(\"hippo\").levenshteinDistance(fromString(\"zzzzzzzz\")));\n    assertEquals(1, fromString(\"hello\").levenshteinDistance(fromString(\"hallo\")));\n    assertEquals(4, fromString(\"\").levenshteinDistance(fromString(\"ab\")));\n  }\n\n  @Test\n  public void translate() {\n    assertEquals(\n      fromString(\"1a2s3ae\"),\n      fromString(\"translate\").translate(ImmutableMap.of(\n        \"r\", \"1\",\n        \"n\", \"2\",\n        \"l\", \"3\",\n        \"t\", \"\\0\"\n      )));\n    assertEquals(\n      fromString(\"translate\"),\n      fromString(\"translate\").translate(new HashMap<>()));\n    assertEquals(\n      fromString(\"asae\"),\n      fromString(\"translate\").translate(ImmutableMap.of(\n        \"r\", \"\\0\",\n        \"n\", \"\\0\",\n        \"l\", \"\\0\",\n        \"t\", \"\\0\"\n      )));\n    assertEquals(\n      fromString(\"aab\"),\n      fromString(\"\").translate(ImmutableMap.of(\n        \"\", \"a\",\n        \"\", \"b\"\n      )));\n  }\n\n  @Test\n  public void createBlankString() {\n    assertEquals(fromString(\" \"), blankString(1));\n    assertEquals(fromString(\"  \"), blankString(2));\n    assertEquals(fromString(\"   \"), blankString(3));\n    assertEquals(fromString(\"\"), blankString(0));\n  }\n\n  @Test\n  public void findInSet() {\n    assertEquals(1, fromString(\"ab\").findInSet(fromString(\"ab\")));\n    assertEquals(2, fromString(\"a,b\").findInSet(fromString(\"b\")));\n    assertEquals(3, fromString(\"abc,b,ab,c,def\").findInSet(fromString(\"ab\")));\n    assertEquals(1, fromString(\"ab,abc,b,ab,c,def\").findInSet(fromString(\"ab\")));\n    assertEquals(4, fromString(\",,,ab,abc,b,ab,c,def\").findInSet(fromString(\"ab\")));\n    assertEquals(1, fromString(\",ab,abc,b,ab,c,def\").findInSet(fromString(\"\")));\n    assertEquals(4, fromString(\",abc,b,ab,c,def\").findInSet(fromString(\"ab\")));\n    assertEquals(6, fromString(\",abc,b,ab,c,def\").findInSet(fromString(\"def\")));\n  }\n\n  @Test\n  public void soundex() {\n    assertEquals(fromString(\"R163\"), fromString(\"Robert\").soundex());\n    assertEquals(fromString(\"R163\"), fromString(\"Rupert\").soundex());\n    assertEquals(fromString(\"R150\"), fromString(\"Rubin\").soundex());\n    assertEquals(fromString(\"A261\"), fromString(\"Ashcraft\").soundex());\n    assertEquals(fromString(\"A261\"), fromString(\"Ashcroft\").soundex());\n    assertEquals(fromString(\"B620\"), fromString(\"Burroughs\").soundex());\n    assertEquals(fromString(\"B620\"), fromString(\"Burrows\").soundex());\n    assertEquals(fromString(\"E251\"), fromString(\"Ekzampul\").soundex());\n    assertEquals(fromString(\"E251\"), fromString(\"Example\").soundex());\n    assertEquals(fromString(\"E460\"), fromString(\"Ellery\").soundex());\n    assertEquals(fromString(\"E460\"), fromString(\"Euler\").soundex());\n    assertEquals(fromString(\"G200\"), fromString(\"Ghosh\").soundex());\n    assertEquals(fromString(\"G200\"), fromString(\"Gauss\").soundex());\n    assertEquals(fromString(\"G362\"), fromString(\"Gutierrez\").soundex());\n    assertEquals(fromString(\"H416\"), fromString(\"Heilbronn\").soundex());\n    assertEquals(fromString(\"H416\"), fromString(\"Hilbert\").soundex());\n    assertEquals(fromString(\"J250\"), fromString(\"Jackson\").soundex());\n    assertEquals(fromString(\"K530\"), fromString(\"Kant\").soundex());\n    assertEquals(fromString(\"K530\"), fromString(\"Knuth\").soundex());\n    assertEquals(fromString(\"L000\"), fromString(\"Lee\").soundex());\n    assertEquals(fromString(\"L222\"), fromString(\"Lukasiewicz\").soundex());\n    assertEquals(fromString(\"L222\"), fromString(\"Lissajous\").soundex());\n    assertEquals(fromString(\"L300\"), fromString(\"Ladd\").soundex());\n    assertEquals(fromString(\"L300\"), fromString(\"Lloyd\").soundex());\n    assertEquals(fromString(\"M220\"), fromString(\"Moses\").soundex());\n    assertEquals(fromString(\"O600\"), fromString(\"O'Hara\").soundex());\n    assertEquals(fromString(\"P236\"), fromString(\"Pfister\").soundex());\n    assertEquals(fromString(\"R150\"), fromString(\"Rubin\").soundex());\n    assertEquals(fromString(\"R163\"), fromString(\"Robert\").soundex());\n    assertEquals(fromString(\"R163\"), fromString(\"Rupert\").soundex());\n    assertEquals(fromString(\"S532\"), fromString(\"Soundex\").soundex());\n    assertEquals(fromString(\"S532\"), fromString(\"Sownteks\").soundex());\n    assertEquals(fromString(\"T522\"), fromString(\"Tymczak\").soundex());\n    assertEquals(fromString(\"V532\"), fromString(\"VanDeusen\").soundex());\n    assertEquals(fromString(\"W252\"), fromString(\"Washington\").soundex());\n    assertEquals(fromString(\"W350\"), fromString(\"Wheaton\").soundex());\n\n    assertEquals(fromString(\"A000\"), fromString(\"a\").soundex());\n    assertEquals(fromString(\"A100\"), fromString(\"ab\").soundex());\n    assertEquals(fromString(\"A120\"), fromString(\"abc\").soundex());\n    assertEquals(fromString(\"A123\"), fromString(\"abcd\").soundex());\n    assertEquals(fromString(\"\"), fromString(\"\").soundex());\n    assertEquals(fromString(\"123\"), fromString(\"123\").soundex());\n    assertEquals(fromString(\"\"), fromString(\"\").soundex());\n  }\n\n  @Test\n  public void writeToOutputStreamUnderflow() throws IOException {\n    final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    final byte[] test = \"01234567\".getBytes(StandardCharsets.UTF_8);\n\n    for (int i = 1; i <= Platform.BYTE_ARRAY_OFFSET; ++i) {\n      UTF8String.fromAddress(test, Platform.BYTE_ARRAY_OFFSET - i, test.length + i)\n          .writeTo(outputStream);\n      final ByteBuffer buffer = ByteBuffer.wrap(outputStream.toByteArray(), i, test.length);\n      assertEquals(\"01234567\", StandardCharsets.UTF_8.decode(buffer).toString());\n      outputStream.reset();\n    }\n  }\n\n  @Test\n  public void writeToOutputStreamSlice() throws IOException {\n    final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    final byte[] test = \"01234567\".getBytes(StandardCharsets.UTF_8);\n\n    for (int i = 0; i < test.length; ++i) {\n      for (int j = 0; j < test.length - i; ++j) {\n        UTF8String.fromAddress(test, Platform.BYTE_ARRAY_OFFSET + i, j)\n            .writeTo(outputStream);\n\n        assertArrayEquals(Arrays.copyOfRange(test, i, i + j), outputStream.toByteArray());\n        outputStream.reset();\n      }\n    }\n  }\n\n  @Test\n  public void writeToOutputStreamOverflow() throws IOException {\n    final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    final byte[] test = \"01234567\".getBytes(StandardCharsets.UTF_8);\n\n    final HashSet<Long> offsets = new HashSet<>();\n    for (int i = 0; i < 16; ++i) {\n      offsets.add((long) Integer.MAX_VALUE - i);\n      offsets.add(Long.MAX_VALUE - BYTE_ARRAY_OFFSET - i);\n    }\n\n    for (long i = 1; i > 0L; i <<= 1) {\n      for (long j = 0; j < 32L; ++j) {\n        offsets.add(i + j);\n      }\n    }\n\n    for (final long offset : offsets) {\n      try {\n        assertThrows(ArrayIndexOutOfBoundsException.class,\n          () -> fromAddress(test, BYTE_ARRAY_OFFSET + offset, test.length).writeTo(outputStream));\n      } finally {\n        outputStream.reset();\n      }\n    }\n  }\n\n  @Test\n  public void writeToOutputStream() throws IOException {\n    final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    EMPTY_UTF8.writeTo(outputStream);\n    assertEquals(\"\", outputStream.toString(StandardCharsets.UTF_8.name()));\n    outputStream.reset();\n\n    fromString(\"\").writeTo(outputStream);\n    assertEquals(\n        \"\",\n        outputStream.toString(StandardCharsets.UTF_8.name()));\n    outputStream.reset();\n  }\n\n  @Test\n  public void writeToOutputStreamIntArray() throws IOException {\n    final ByteBuffer buffer = StandardCharsets.UTF_8.encode(\"\");\n    buffer.position(0);\n    buffer.order(ByteOrder.nativeOrder());\n\n    final int length = buffer.limit();\n    assertEquals(12, length);\n\n    final int ints = length / 4;\n    final int[] array = new int[ints];\n\n    for (int i = 0; i < ints; ++i) {\n      array[i] = buffer.getInt();\n    }\n\n    final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    fromAddress(array, Platform.INT_ARRAY_OFFSET, length)\n        .writeTo(outputStream);\n    assertEquals(\"\", outputStream.toString(StandardCharsets.UTF_8.name()));\n  }\n\n  @Test\n  public void testToShort() {\n    Map<String, Short> inputToExpectedOutput = new HashMap<>();\n    inputToExpectedOutput.put(\"1\", (short) 1);\n    inputToExpectedOutput.put(\"+1\", (short) 1);\n    inputToExpectedOutput.put(\"-1\", (short) -1);\n    inputToExpectedOutput.put(\"0\", (short) 0);\n    inputToExpectedOutput.put(\"1111.12345678901234567890\", (short) 1111);\n    inputToExpectedOutput.put(String.valueOf(Short.MAX_VALUE), Short.MAX_VALUE);\n    inputToExpectedOutput.put(String.valueOf(Short.MIN_VALUE), Short.MIN_VALUE);\n\n    Random rand = new Random();\n    for (int i = 0; i < 10; i++) {\n      short value = (short) rand.nextInt();\n      inputToExpectedOutput.put(String.valueOf(value), value);\n    }\n\n    IntWrapper wrapper = new IntWrapper();\n    for (Map.Entry<String, Short> entry : inputToExpectedOutput.entrySet()) {\n      assertTrue(UTF8String.fromString(entry.getKey()).toShort(wrapper), entry.getKey());\n      assertEquals((short) entry.getValue(), wrapper.value);\n    }\n\n    List<String> negativeInputs =\n      Arrays.asList(\"\", \"  \", \"null\", \"NULL\", \"\\n\", \"~1212121\", \"3276700\");\n\n    for (String negativeInput : negativeInputs) {\n      assertFalse(UTF8String.fromString(negativeInput).toShort(wrapper), negativeInput);\n    }\n  }\n\n  @Test\n  public void testToByte() {\n    Map<String, Byte> inputToExpectedOutput = new HashMap<>();\n    inputToExpectedOutput.put(\"1\", (byte) 1);\n    inputToExpectedOutput.put(\"+1\",(byte)  1);\n    inputToExpectedOutput.put(\"-1\", (byte)  -1);\n    inputToExpectedOutput.put(\"0\", (byte)  0);\n    inputToExpectedOutput.put(\"111.12345678901234567890\", (byte) 111);\n    inputToExpectedOutput.put(String.valueOf(Byte.MAX_VALUE), Byte.MAX_VALUE);\n    inputToExpectedOutput.put(String.valueOf(Byte.MIN_VALUE), Byte.MIN_VALUE);\n\n    Random rand = new Random();\n    for (int i = 0; i < 10; i++) {\n      byte value = (byte) rand.nextInt();\n      inputToExpectedOutput.put(String.valueOf(value), value);\n    }\n\n    IntWrapper intWrapper = new IntWrapper();\n    for (Map.Entry<String, Byte> entry : inputToExpectedOutput.entrySet()) {\n      assertTrue(UTF8String.fromString(entry.getKey()).toByte(intWrapper), entry.getKey());\n      assertEquals((byte) entry.getValue(), intWrapper.value);\n    }\n\n    List<String> negativeInputs =\n      Arrays.asList(\"\", \"  \", \"null\", \"NULL\", \"\\n\", \"~1212121\", \"12345678901234567890\");\n\n    for (String negativeInput : negativeInputs) {\n      assertFalse(UTF8String.fromString(negativeInput).toByte(intWrapper), negativeInput);\n    }\n  }\n\n  @Test\n  public void testToInt() {\n    Map<String, Integer> inputToExpectedOutput = new HashMap<>();\n    inputToExpectedOutput.put(\"1\", 1);\n    inputToExpectedOutput.put(\"+1\", 1);\n    inputToExpectedOutput.put(\"-1\", -1);\n    inputToExpectedOutput.put(\"0\", 0);\n    inputToExpectedOutput.put(\"11111.1234567\", 11111);\n    inputToExpectedOutput.put(String.valueOf(Integer.MAX_VALUE), Integer.MAX_VALUE);\n    inputToExpectedOutput.put(String.valueOf(Integer.MIN_VALUE), Integer.MIN_VALUE);\n\n    Random rand = new Random();\n    for (int i = 0; i < 10; i++) {\n      int value = rand.nextInt();\n      inputToExpectedOutput.put(String.valueOf(value), value);\n    }\n\n    IntWrapper intWrapper = new IntWrapper();\n    for (Map.Entry<String, Integer> entry : inputToExpectedOutput.entrySet()) {\n      assertTrue(UTF8String.fromString(entry.getKey()).toInt(intWrapper), entry.getKey());\n      assertEquals((int) entry.getValue(), intWrapper.value);\n    }\n\n    List<String> negativeInputs =\n      Arrays.asList(\"\", \"  \", \"null\", \"NULL\", \"\\n\", \"~1212121\", \"12345678901234567890\");\n\n    for (String negativeInput : negativeInputs) {\n      assertFalse(UTF8String.fromString(negativeInput).toInt(intWrapper), negativeInput);\n    }\n  }\n\n  @Test\n  public void testToLong() {\n    Map<String, Long> inputToExpectedOutput = new HashMap<>();\n    inputToExpectedOutput.put(\"1\", 1L);\n    inputToExpectedOutput.put(\"+1\", 1L);\n    inputToExpectedOutput.put(\"-1\", -1L);\n    inputToExpectedOutput.put(\"0\", 0L);\n    inputToExpectedOutput.put(\"1076753423.12345678901234567890\", 1076753423L);\n    inputToExpectedOutput.put(String.valueOf(Long.MAX_VALUE), Long.MAX_VALUE);\n    inputToExpectedOutput.put(String.valueOf(Long.MIN_VALUE), Long.MIN_VALUE);\n\n    Random rand = new Random();\n    for (int i = 0; i < 10; i++) {\n      long value = rand.nextLong();\n      inputToExpectedOutput.put(String.valueOf(value), value);\n    }\n\n    LongWrapper wrapper = new LongWrapper();\n    for (Map.Entry<String, Long> entry : inputToExpectedOutput.entrySet()) {\n      assertTrue(UTF8String.fromString(entry.getKey()).toLong(wrapper), entry.getKey());\n      assertEquals((long) entry.getValue(), wrapper.value);\n    }\n\n    List<String> negativeInputs = Arrays.asList(\"\", \"  \", \"null\", \"NULL\", \"\\n\", \"~1212121\",\n        \"1234567890123456789012345678901234\");\n\n    for (String negativeInput : negativeInputs) {\n      assertFalse(UTF8String.fromString(negativeInput).toLong(wrapper), negativeInput);\n    }\n  }\n\n  @Test\n  public void trimBothWithTrimString() {\n    assertEquals(fromString(\"hello\"), fromString(\"  hello \").trim(fromString(\" \")));\n    assertEquals(fromString(\"o\"), fromString(\"  hello \").trim(fromString(\" hle\")));\n    assertEquals(fromString(\"h e\"), fromString(\"ooh e ooo\").trim(fromString(\"o \")));\n    assertEquals(fromString(\"\"), fromString(\"ooo...oooo\").trim(fromString(\"o.\")));\n    assertEquals(fromString(\"b\"), fromString(\"%^b[]@\").trim(fromString(\"][@^%\")));\n\n    assertEquals(EMPTY_UTF8, fromString(\"  \").trim(fromString(\" \")));\n\n    assertEquals(fromString(\"\"), fromString(\"   \").trim());\n    assertEquals(fromString(\"\"), fromString(\"ab\").trim(fromString(\"ab\")));\n    assertEquals(fromString(\"\"), fromString(\"a\").trim(fromString(\"ab\")));\n    assertEquals(fromString(\"\"), fromString(\" \").trim(fromString(\" \")));\n    assertEquals(fromString(\"\"), fromString(\"][#\").trim(fromString(\"[]#\")));\n    assertEquals(fromString(\" \"), fromString(\" \").trim(fromString(\"\")));\n  }\n\n  @Test\n  public void trimLeftWithTrimString() {\n    assertEquals(fromString(\"  hello \"), fromString(\"  hello \").trimLeft(fromString(\"\")));\n    assertEquals(fromString(\"\"), fromString(\"a\").trimLeft(fromString(\"a\")));\n    assertEquals(fromString(\"b\"), fromString(\"b\").trimLeft(fromString(\"a\")));\n    assertEquals(fromString(\"ba\"), fromString(\"ba\").trimLeft(fromString(\"a\")));\n    assertEquals(fromString(\"\"), fromString(\"aaaaaaa\").trimLeft(fromString(\"a\")));\n    assertEquals(fromString(\"trim\"), fromString(\"oabtrim\").trimLeft(fromString(\"bao\")));\n    assertEquals(fromString(\"rim \"), fromString(\"ooootrim \").trimLeft(fromString(\"otm\")));\n\n    assertEquals(EMPTY_UTF8, fromString(\"  \").trimLeft(fromString(\" \")));\n\n    assertEquals(fromString(\" \"), fromString(\"   \").trimLeft(fromString(\" \")));\n    assertEquals(fromString(\"\"), fromString(\"\").trimLeft(fromString(\"a\")));\n    assertEquals(fromString(\"a\"), fromString(\"a\").trimLeft(fromString(\"\")));\n    assertEquals(fromString(\"\"), fromString(\"\").trimLeft(fromString(\"\")));\n    assertEquals(fromString(\"\"), fromString(\" \").trimLeft(fromString(\" \")));\n    assertEquals(fromString(\"\"), fromString(\"aa\").trimLeft(fromString(\"a\")));\n    assertEquals(fromString(\"$S,.$BR\"), fromString(\",,,,%$S,.$BR\").trimLeft(fromString(\"%,\")));\n  }\n\n  @Test\n  public void trimRightWithTrimString() {\n    assertEquals(fromString(\"  hello \"), fromString(\"  hello \").trimRight(fromString(\"\")));\n    assertEquals(fromString(\"\"), fromString(\"a\").trimRight(fromString(\"a\")));\n    assertEquals(fromString(\"cc\"), fromString(\"ccbaaaa\").trimRight(fromString(\"ba\")));\n    assertEquals(fromString(\"\"), fromString(\"aabbbbaaa\").trimRight(fromString(\"ab\")));\n    assertEquals(fromString(\"  he\"), fromString(\"  hello \").trimRight(fromString(\" ol\")));\n    assertEquals(fromString(\"oohell\"),\n        fromString(\"oohellooo../*&\").trimRight(fromString(\"./,&%*o\")));\n\n    assertEquals(EMPTY_UTF8, fromString(\"  \").trimRight(fromString(\" \")));\n\n    assertEquals(fromString(\"  \"), fromString(\"   \").trimRight(fromString(\" \")));\n    assertEquals(fromString(\"\"), fromString(\"aa\").trimRight(fromString(\"a\")));\n    assertEquals(fromString(\"\"), fromString(\"ab\").trimRight(fromString(\"ab\")));\n    assertEquals(fromString(\"\"), fromString(\"a???/\").trimRight(fromString(\"?/*&^%a\")));\n    assertEquals(fromString(\"\"), fromString(\"b [\").trimRight(fromString(\" []b\")));\n  }\n\n  @Test\n  public void skipWrongFirstByte() {\n    int[] wrongFirstBytes = {\n      0x80, 0x9F, 0xBF, // Skip Continuation bytes\n      0xC0, 0xC2, // 0xC0..0xC1 - disallowed in UTF-8\n      0xF5, 0xF6, 0xF7, 0xF8, 0xF9,\n      0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n    };\n    byte[] c = new byte[1];\n\n    for (int wrongFirstByte : wrongFirstBytes) {\n      c[0] = (byte) wrongFirstByte;\n      assertEquals(1, fromBytes(c).numChars());\n    }\n  }\n\n  private void testMakeValid(String input, String expected) {\n    ByteArrayOutputStream exp = new ByteArrayOutputStream();\n    for (String hex : expected.split(\" \")) exp.write(Integer.parseInt(hex.substring(2), 16));\n    ByteArrayOutputStream inp = new ByteArrayOutputStream();\n    for (String hex : input.split(\" \")) inp.write(Integer.parseInt(hex.substring(2), 16));\n    UTF8String expUTF8String = fromBytes(exp.toByteArray());\n    UTF8String inpUTF8String = fromBytes(inp.toByteArray());\n    assertEquals(expUTF8String, inpUTF8String.makeValid());\n    assertEquals(inpUTF8String.toValidString(), inpUTF8String.toString());\n  }\n  @Test\n  public void makeValid() {\n    assertEquals(EMPTY_UTF8, EMPTY_UTF8.makeValid());\n    assertEquals(fromString(\"\"), fromString(\"\").makeValid());\n    assertEquals(fromString(\"abc\"), fromString(\"abc\").makeValid());\n    assertEquals(fromString(\"hello\"), fromString(\"hello\").makeValid());\n    assertEquals(fromString(\"\"), fromString(\"\").makeValid());\n    assertEquals(fromBytes(new byte[] {}), fromBytes(new byte[] {}).makeValid());\n    assertEquals(fromBytes(new byte[] {0x61}), fromBytes(new byte[] {0x61}).makeValid());\n    assertEquals(fromBytes(new byte[] {0x7F}), fromBytes(new byte[] {0x7F}).makeValid());\n    assertEquals(fromBytes(new byte[] {(byte) 0xEF, (byte) 0xBF, (byte) 0xBD}),\n      fromBytes(new byte[] {(byte) 0xFF}).makeValid());\n    assertEquals(fromBytes(new byte[] {(byte) 0xC2, (byte) 0x80}),\n      fromBytes(new byte[] {(byte) 0xC2, (byte) 0x80}).makeValid());\n    assertEquals(fromBytes(new byte[] {(byte) 0xDF, (byte) 0xBF}),\n      fromBytes(new byte[] {(byte) 0xDF, (byte) 0xBF}).makeValid());\n      fromBytes(new byte[] {(byte) 0xC0, (byte) 0x80}).makeValid());\n      fromBytes(new byte[] {(byte) 0xC1, (byte) 0xBF}).makeValid());\n      fromBytes(new byte[] {(byte) 0xDF, (byte) 0xC0}).makeValid());\n      fromBytes(new byte[] {(byte) 0xDF, (byte) 0xFF}).makeValid());\n      fromBytes(new byte[] {(byte) 0x80, (byte) 0x80}).makeValid());\n    assertEquals(fromBytes(new byte[] {(byte) 0xE0, (byte) 0xA0, (byte) 0x80}),\n      fromBytes(new byte[] {(byte) 0xE0, (byte) 0xA0, (byte) 0x80}).makeValid());\n    assertEquals(fromBytes(new byte[] {(byte) 0xEF, (byte) 0xBF, (byte) 0xBF}),\n      fromBytes(new byte[] {(byte) 0xEF, (byte) 0xBF, (byte) 0xBF}).makeValid());\n    assertEquals(fromBytes(new byte[] {(byte) 0xEF, (byte) 0xBF, (byte) 0xBF}),\n      fromBytes(new byte[] {(byte) 0xEF, (byte) 0xBF, (byte) 0xBF}).makeValid());\n      fromBytes(new byte[] {(byte) 0xE0, (byte) 0x9F, (byte) 0x80}).makeValid());\n      fromBytes(new byte[] {(byte) 0xE0, (byte) 0xC0, (byte) 0x80}).makeValid());\n      fromBytes(new byte[] {(byte) 0xEF, (byte) 0xBF, (byte) 0xC0}).makeValid());\n      fromBytes(new byte[] {(byte) 0x80, (byte) 0x80, (byte) 0x80}).makeValid());\n    assertEquals(fromBytes(new byte[] {(byte) 0xF0, (byte) 0x90, (byte) 0x80, (byte) 0x80}),\n      fromBytes(new byte[] {(byte) 0xF0, (byte) 0x90, (byte) 0x80, (byte) 0x80}).makeValid());\n    assertEquals(fromBytes(new byte[] {(byte) 0xF4, (byte) 0x8F, (byte) 0xBF, (byte) 0xBF}),\n      fromBytes(new byte[] {(byte) 0xF4, (byte) 0x8F, (byte) 0xBF, (byte) 0xBF}).makeValid());\n      fromBytes(new byte[] {(byte) 0xF0, (byte) 0x8F, (byte) 0x80, (byte) 0x80}).makeValid());\n    assertEquals(fromBytes(new byte[] {(byte) 0xEF, (byte) 0xBF, (byte) 0xBD, (byte) 0x7F}),\n      fromBytes(new byte[] {(byte) 0xF0, (byte) 0x90, (byte) 0x80, (byte) 0x7F}).makeValid());\n      fromBytes(new byte[] {(byte) 0xF4, (byte) 0x90, (byte) 0x80, (byte) 0x80}).makeValid());\n      fromBytes(new byte[] {(byte) 0xF4, (byte) 0x8F, (byte) 0xBF, (byte) 0xC0}).makeValid());\n    assertEquals(fromString(\"\"), fromBytes(new byte[]\n      {(byte) 0xF8, (byte) 0x90, (byte) 0x80, (byte) 0x80, (byte) 0x80}).makeValid());\n    assertEquals(fromString(\"\"), fromBytes(new byte[]\n      {(byte) 0xFB, (byte) 0x8F, (byte) 0xBF, (byte) 0xBF, (byte) 0xBF}).makeValid());\n    assertEquals(fromString(\"\"), fromBytes(new byte[]\n      {(byte) 0xFB, (byte) 0x90, (byte) 0x80, (byte) 0x80, (byte) 0x80}).makeValid());\n    testMakeValid(\"0x42\", \"0x42\");\n    testMakeValid(\"0x80\", \"0xEF 0xBF 0xBD\");\n    testMakeValid(\"0xF4 0x92 0x12\", \"0xEF 0xBF 0xBD 0xEF 0xBF 0xBD 0x12\");\n    testMakeValid(\"0x84 0xA5 0x63 0x64\", \"0xEF 0xBF 0xBD 0xEF 0xBF 0xBD 0x63 0x64\");\n    testMakeValid(\"0xF4 0x9B\", \"0xEF 0xBF 0xBD 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0xE2 0x0C\", \"0xEF 0xBF 0xBD 0x0C\");\n    testMakeValid(\"0xE8 0x3E\", \"0xEF 0xBF 0xBD 0x3E\");\n    testMakeValid(\"0x17 0x1B 0xC2\", \"0x17 0x1B 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x29 0xB2 0x7C 0xA0\", \"0x29 0xEF 0xBF 0xBD 0x7C 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x13 0x68 0x28 0x2A 0x83\", \"0x13 0x68 0x28 0x2A 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x3B 0xFE 0xC2 0xB7 0x9E\", \"0x3B 0xEF 0xBF 0xBD 0xC2 0xB7 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0xFC\", \"0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x8E 0xBD\", \"0xEF 0xBF 0xBD 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x6A 0x8B 0x5C 0x5A\", \"0x6A 0xEF 0xBF 0xBD 0x5C 0x5A\");\n    testMakeValid(\"0xB4 0xC0\", \"0xEF 0xBF 0xBD 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0xB0 0xD3\", \"0xEF 0xBF 0xBD 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0xAA\", \"0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x1A 0x66\", \"0x1A 0x66\");\n    testMakeValid(\"0x32 0xB5 0x5F\", \"0x32 0xEF 0xBF 0xBD 0x5F\");\n    testMakeValid(\"0x70 0xB6 0x69 0xBC\", \"0x70 0xEF 0xBF 0xBD 0x69 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0xDC 0x15 0x82\", \"0xEF 0xBF 0xBD 0x15 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x7F 0x3F 0x72 0xBB\", \"0x7F 0x3F 0x72 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x3C 0x3D 0x1F 0x6C 0x75\", \"0x3C 0x3D 0x1F 0x6C 0x75\");\n    testMakeValid(\"0xBF 0x10 0xF4\", \"0xEF 0xBF 0xBD 0x10 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0xBF 0xDD 0x89\", \"0xEF 0xBF 0xBD 0xDD 0x89\");\n    testMakeValid(\"0x85 0xD4 0x90 0x5E 0x6C\", \"0xEF 0xBF 0xBD 0xD4 0x90 0x5E 0x6C\");\n    testMakeValid(\"0x0A 0x92 0x3C 0x17 0x7D\", \"0x0A 0xEF 0xBF 0xBD 0x3C 0x17 0x7D\");\n    testMakeValid(\"0x49 0x4E 0x2C 0x7B 0x1C\", \"0x49 0x4E 0x2C 0x7B 0x1C\");\n    testMakeValid(\"0x2E 0x0C 0x3E 0x02 0x9D\", \"0x2E 0x0C 0x3E 0x02 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0xF9 0xF2 0x11\", \"0xEF 0xBF 0xBD 0xEF 0xBF 0xBD 0x11\");\n    testMakeValid(\"0xD1\", \"0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x74 0x35 0x56 0xC4\", \"0x74 0x35 0x56 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0xBE 0x45 0x7F\", \"0xEF 0xBF 0xBD 0x45 0x7F\");\n    testMakeValid(\"0x2E\", \"0x2E\");\n    testMakeValid(\"0x3B 0xC3\", \"0x3B 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0xF9 0x58 0xE0 0x84\", \"0xEF 0xBF 0xBD 0x58 0xEF 0xBF 0xBD 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x72 0xF9 0x4F\", \"0x72 0xEF 0xBF 0xBD 0x4F\");\n    testMakeValid(\"0xF2 0x2A 0x38\", \"0xEF 0xBF 0xBD 0x2A 0x38\");\n    testMakeValid(\"0x66 0xFC 0x8D 0x5F\", \"0x66 0xEF 0xBF 0xBD 0xEF 0xBF 0xBD 0x5F\");\n    testMakeValid(\"0x6D\", \"0x6D\");\n    testMakeValid(\"0x6E 0xDF 0xDD\", \"0x6E 0xEF 0xBF 0xBD 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x50 0xE8 0x45 0xDB\", \"0x50 0xEF 0xBF 0xBD 0x45 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x71 0x06 0x1F 0x87\", \"0x71 0x06 0x1F 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x02\", \"0x02\");\n    testMakeValid(\"0x20 0x2B 0x38 0xCB 0xDF\", \"0x20 0x2B 0x38 0xEF 0xBF 0xBD 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x10\", \"0x10\");\n    testMakeValid(\"0x15\", \"0x15\");\n    testMakeValid(\"0xC5 0xEA 0x2A\", \"0xEF 0xBF 0xBD 0xEF 0xBF 0xBD 0x2A\");\n    testMakeValid(\"0x72 0x2D 0xBB 0x06\", \"0x72 0x2D 0xEF 0xBF 0xBD 0x06\");\n    testMakeValid(\"0xB7\", \"0xEF 0xBF 0xBD\");\n    testMakeValid(\"0xB8 0xB5\", \"0xEF 0xBF 0xBD 0xEF 0xBF 0xBD\");\n    testMakeValid(\"0x9C 0x76 0x17\", \"0xEF 0xBF 0xBD 0x76 0x17\");\n  }\n\n  private void testIsValid(String input, String expected) {\n    ByteArrayOutputStream inp = new ByteArrayOutputStream();\n    for (String hex : input.split(\" \")) inp.write(Integer.parseInt(hex.substring(2), 16));\n    assertEquals(input.equals(expected), fromBytes(inp.toByteArray()).isValid());\n  }\n  @Test\n  public void isValid() {\n    assertTrue(EMPTY_UTF8.isValid());\n    assertTrue(fromString(\"\").isValid());\n    assertTrue(fromString(\"abc\").isValid());\n    assertTrue(fromString(\"hello\").isValid());\n    assertTrue(fromString(\"\").isValid());\n    assertTrue(fromString(\"\").isValid());\n    assertTrue(fromBytes(new byte[] {}).isValid());\n    assertTrue(fromBytes(new byte[] {0x61}).isValid());\n    assertTrue(fromBytes(new byte[] {0x7F}).isValid());\n    assertFalse(fromBytes(new byte[] {(byte) 0xFF}).isValid());\n    assertTrue(fromBytes(new byte[] {(byte) 0xC2, (byte) 0x80}).isValid());\n    assertTrue(fromBytes(new byte[] {(byte) 0xDF, (byte) 0xBF}).isValid());\n    assertFalse(fromBytes(new byte[] {(byte) 0xC0, (byte) 0x80}).isValid());\n    assertFalse(fromBytes(new byte[] {(byte) 0xC1, (byte) 0xBF}).isValid());\n    assertFalse(fromBytes(new byte[] {(byte) 0xDF, (byte) 0xC0}).isValid());\n    assertFalse(fromBytes(new byte[] {(byte) 0xDF, (byte) 0xFF}).isValid());\n    assertFalse(fromBytes(new byte[] {(byte) 0x80, (byte) 0x80}).isValid());\n    assertTrue(fromBytes(new byte[] {(byte) 0xE0, (byte) 0xA0, (byte) 0x80}).isValid());\n    assertTrue(fromBytes(new byte[] {(byte) 0xEF, (byte) 0xBF, (byte) 0xBF}).isValid());\n    assertTrue(fromBytes(new byte[] {(byte) 0xEF, (byte) 0xBF, (byte) 0xBF}).isValid());\n    assertFalse(fromBytes(new byte[] {(byte) 0xE0, (byte) 0x9F, (byte) 0x80}).isValid());\n    assertFalse(fromBytes(new byte[] {(byte) 0xE0, (byte) 0xC0, (byte) 0x80}).isValid());\n    assertFalse(fromBytes(new byte[] {(byte) 0xEF, (byte) 0xBF, (byte) 0xC0}).isValid());\n    assertFalse(fromBytes(new byte[] {(byte) 0x80, (byte) 0x80, (byte) 0x80}).isValid());\n      new byte[] {(byte) 0xF0, (byte) 0x90, (byte) 0x80, (byte) 0x80}).isValid());\n      new byte[] {(byte) 0xF4, (byte) 0x8F, (byte) 0xBF, (byte) 0xBF}).isValid());\n      new byte[] {(byte) 0xF0, (byte) 0x8F, (byte) 0x80, (byte) 0x80}).isValid());\n      new byte[] {(byte) 0xF0, (byte) 0x90, (byte) 0x80, (byte) 0x7F}).isValid());\n      new byte[] {(byte) 0xF4, (byte) 0x90, (byte) 0x80, (byte) 0x80}).isValid());\n      new byte[] {(byte) 0xF4, (byte) 0x8F, (byte) 0xBF, (byte) 0xC0}).isValid());\n      new byte[] {(byte) 0xF8, (byte) 0x8F, (byte) 0x80, (byte) 0x80, (byte) 0x80}).isValid());\n      new byte[] {(byte) 0xF8, (byte) 0x90, (byte) 0x80, (byte) 0x80, (byte) 0x80}).isValid());\n      new byte[] {(byte) 0xFB, (byte) 0x8F, (byte) 0xBF, (byte) 0xBF, (byte) 0xBF}).isValid());\n      new byte[] {(byte) 0xFB, (byte) 0x90, (byte) 0x80, (byte) 0x80, (byte) 0x80}).isValid());\n\n  @Test\n  public void testGetByte() {\n    String validString = \"abcde\";\n    UTF8String validUTF8String = fromString(validString);\n    for (int i = 0; i < validString.length(); ++i) {\n      assertEquals(validString.charAt(i), validUTF8String.getByte(i));\n    }\n    assertEquals(0, validUTF8String.getByte(-1));\n    assertEquals(0, validUTF8String.getByte(validString.length()));\n    assertEquals(0, validUTF8String.getByte(validString.length() + 1));\n\n    byte[] invalidString = new byte[] {(byte) 0x41, (byte) 0x42, (byte) 0x80};\n    assertEquals(0, invalidUTF8String.getByte(-1));\n    assertEquals(0, invalidUTF8String.getByte(invalidString.length));\n    assertEquals(0, invalidUTF8String.getByte(invalidString.length + 1));\n  }\n\n  @Test\n  public void testGetChar() {\n    String str = \"abcde\";\n    UTF8String s = fromString(str);\n    for (int i = 0; i < str.length(); ++i) {\n      assertEquals(str.charAt(i), s.getChar(i));\n    }\n    assertThrows(IndexOutOfBoundsException.class, () -> s.getChar(-1));\n    assertThrows(IndexOutOfBoundsException.class, () -> s.getChar(str.length()));\n    assertThrows(IndexOutOfBoundsException.class, () -> s.getChar(str.length() + 1));\n\n    byte[] invalidString = new byte[] {(byte) 0x41, (byte) 0x42, (byte) 0x80};\n        assertEquals(0, invalidUTF8String.getChar(i));\n      }\n    }\n    assertThrows(IndexOutOfBoundsException.class, () -> s.getChar(-1));\n    assertThrows(IndexOutOfBoundsException.class, () -> s.getChar(str.length()));\n    assertThrows(IndexOutOfBoundsException.class, () -> s.getChar(str.length() + 1));\n  }",
    "comment": "tests for multiple replacements\ntests for single character search and replacement strings\nTests with non-ASCII characters\nTests for a large number of replacements, triggering UTF8StringBuilder resize\noffset underflow is apparently supported?\ntouch more points around MAX_VALUE\nsubtract off BYTE_ARRAY_OFFSET to avoid wrapping around to a negative value,\nwhich will hit the slower copy path instead of the optimized one\nverify that writes work on objects that are not byte arrays\n0xF5..0xFF - disallowed in UTF-8\nBasic tests\nMore tests\nBasic tests\nValid UTF-8 string\nValid byte index handling\nInvalid byte index handling\nInvalid UTF-8 string\nInvalid byte index handling\nValid UTF-8 string\nValid character index handling\nInvalid character index handling\nInvalid UTF-8 string\nInvalid byte index handling"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "reverseRange",
    "code": "private void reverseRange(Buffer a, int lo, int hi) {\n    hi--;\n    while (lo < hi) {\n      s.swap(a, lo, hi);\n      lo++;\n      hi--;\n    }\n  }",
    "comment": "Reverse the specified range of the specified array.\n\n@param a the array in which a range is to be reversed\n@param lo the index of the first element in the range to be reversed\n@param hi the index after the last element in the range to be reversed"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/feature-toggle/src/main/java/com/iluwatar/featuretoggle/user/UserGroup.java",
    "type": "method",
    "name": "isPaid",
    "code": "public static boolean isPaid(User user) {\n    return paidGroup.contains(user);\n  }",
    "comment": "Method to take a {@link User} to determine if the user is in the {@link UserGroup#paidGroup}.\n\n@param user {@link User} to check if they are in the {@link UserGroup#paidGroup}\n@return true if the {@link User} is in {@link UserGroup#paidGroup}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Module.java",
    "type": "method",
    "name": "forward",
    "code": "public IValue forward(IValue... inputs) {\n    return mNativePeer.forward(inputs);\n  }",
    "comment": "Runs the 'forward' method of this module with the specified arguments.\n\n@param inputs arguments for the TorchScript module's 'forward' method.\n@return return value from the 'forward' method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/lazy/DecoratingIterator.java",
    "type": "method",
    "name": "hasNext",
    "code": "public final boolean hasNext() {\n    next = computeNext();\n    return next != null;\n  }",
    "comment": "Precomputes and saves the next element of the Iterable. null is considered as end of data.\n\n@return true if a next element is available"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/LauncherStoreFacadeTest.java",
    "type": "method",
    "name": "setUp",
    "code": "void setUp() {\n\t\tsessionLevelStore = new NamespacedHierarchicalStore<>(null);\n\t\trequestLevelStore = new NamespacedHierarchicalStore<>(sessionLevelStore);\n\t\textensionNamespace = ExtensionContext.Namespace.create(\"foo\", \"bar\");\n\t}",
    "comment": "Tests for {@link LauncherStoreFacade}.\n\n@since 5.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "assertEventsMatchLooselyInOrder",
    "code": "public final void assertEventsMatchLooselyInOrder(Condition<? super Event>... conditions) {\n\t\tPreconditions.notNull(conditions, \"conditions must not be null\");\n\t\tPreconditions.containsNoNullElements(conditions, \"conditions must not contain null elements\");\n\t\tassertEventsMatchLooselyInOrder(this.events, conditions);\n\t}",
    "comment": "Assert that all provided conditions are matched by an {@linkplain Event event}\ncontained in this {@code Events} object.\n\n<p>Note that this method performs a partial match. Thus, some events may\nnot match any of the provided conditions; however, the conditions provided\nmust be in the correct order.\n\n<p>Conditions can be imported statically from {@link EventConditions}\nand {@link TestExecutionResultConditions}.\n\n<h4>Example</h4>\n\n<pre class=\"code\">\nexecutionResults.testEvents().assertEventsMatchLooselyInOrder(\nevent(test(\"exampleTestMethod\"), started()),\nevent(test(\"exampleTestMethod\"), finishedSuccessfully())\n);\n</pre>\n\n@param conditions the conditions to match against; never {@code null}\n@since 1.7\n@see #assertEventsMatchExactly(Condition...)\n@see #assertEventsMatchLoosely(Condition...)\n@see EventConditions\n@see TestExecutionResultConditions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Float> create(Scope scope, float[][][] data) {\n    return create(scope, data, Float.class);\n  }",
    "comment": "Creates a rank-3 constant of {@code float} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelData.java",
    "type": "method",
    "name": "setGroupId",
    "code": "public void setGroupId(String groupId) {\n        this.groupId = groupId;\n    }",
    "comment": "Sets the effective group identifier of the model.\n\n@param groupId The effective group identifier of the model, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "execute",
    "code": "public static EngineExecutionResults execute(String engineId, EngineDiscoveryRequest discoveryRequest) {\n\t\tPreconditions.notBlank(engineId, \"TestEngine ID must not be null or blank\");\n\t\treturn execute(loadTestEngine(engineId.trim()), discoveryRequest);\n\t}",
    "comment": "Execute tests for the given {@link EngineDiscoveryRequest} using the\n{@link TestEngine} with the supplied ID.\n\n<p>The {@code TestEngine} will be loaded via Java's {@link ServiceLoader}\nmechanism, analogous to the manner in which test engines are loaded in\nthe JUnit Platform Launcher API.\n\n<p>Note that {@link org.junit.platform.launcher.LauncherDiscoveryRequest}\nfrom the {@code junit-platform-launcher} module is a subtype of\n{@code EngineDiscoveryRequest}. It is therefore quite convenient to make\nuse of the DSL provided in\n{@link org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder}\nto build an appropriate discovery request to supply to this method. As\nan alternative, consider using {@link #engine(String)} for a more fluent\nAPI.\n\n@param engineId the ID of the {@code TestEngine} to use; must not be\n{@code null} or <em>blank</em>\n@param discoveryRequest the {@code EngineDiscoveryRequest} to use\n@return the results of the execution\n@throws PreconditionViolationException for invalid arguments or if the\n{@code TestEngine} with the supplied ID cannot be loaded\n@see #execute(String, LauncherDiscoveryRequest)\n@see #engine(String)\n@see #engine(TestEngine)\n@deprecated Please use {@link #execute(String, LauncherDiscoveryRequest)}\ninstead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/monitor/src/main/java/com/iluwatar/monitor/Bank.java",
    "type": "method",
    "name": "getBalance",
    "code": "public synchronized int getBalance() {\n    int balance = 0;\n    for (int account : accounts) {\n      balance += account;\n    }\n    return balance;\n  }",
    "comment": "Calculates the total balance.\n\n@return balance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelPathTranslator.java",
    "type": "method",
    "name": "alignToBaseDirectory",
    "code": "private Source alignToBaseDirectory(Source source, Path basedir) {\n        if (source != null) {\n            String oldDir = source.getDirectory();\n            String newDir = alignToBaseDirectory(oldDir, basedir);\n            if (newDir != oldDir) {\n                source = source.withDirectory(newDir);\n            }\n            oldDir = source.getTargetPath();\n            newDir = alignToBaseDirectory(oldDir, basedir);\n            if (newDir != oldDir) {\n                source = source.withTargetPath(newDir);\n            }\n        }\n        return source;\n    }",
    "comment": "Returns a source with all properties identical to the given source, except the paths\nwhich are resolved according the given {@code basedir}. If the paths are unchanged,\nthen this method returns the previous instance.\n\n@param source the source to relocate, or {@code null}\n@param basedir the new base directory\n@return relocated source, or {@code null} if the given source was null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/client-session/src/main/java/com/iluwatar/client/session/Server.java",
    "type": "method",
    "name": "process",
    "code": "public void process(Request request) {\n    LOGGER.info(\n        \"Processing Request with client: \"\n            + request.getSession().getClientName()\n            + \" data: \"\n            + request.getData());\n  }",
    "comment": "Processes a request based on the session.\n\n@param request Request object with data and Session"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/AssertTest.java",
    "type": "method",
    "name": "testFail",
    "code": "public void testFail() {\n        try {\n            fail();\n        } catch (AssertionFailedError e) {\n            return;\n        }\n        throw new AssertionFailedError();\n    }",
    "comment": "Also, we are testing fail, so we can't rely on fail() working.\nWe have to throw the exception manually."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaDataFrameSuite.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n    spark = new TestSparkSession();\n    jsc = new JavaSparkContext(spark.sparkContext());\n    spark.loadTestData();\n  }",
    "comment": "Trigger static initializer of TestData"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java",
    "type": "method",
    "name": "getDisplayNameGenerator",
    "code": "static DisplayNameGenerator getDisplayNameGenerator(Class<?> generatorClass) {\n\t\tPreconditions.notNull(generatorClass, \"Class must not be null\");\n\t\tPreconditions.condition(DisplayNameGenerator.class.isAssignableFrom(generatorClass),\n\t\t\t\"Class must be a DisplayNameGenerator implementation\");\n\t\tif (generatorClass == Standard.class) {\n\t\t\treturn Standard.INSTANCE;\n\t\t}\n\t\tif (generatorClass == Simple.class) {\n\t\t\treturn Simple.INSTANCE;\n\t\t}\n\t\tif (generatorClass == ReplaceUnderscores.class) {\n\t\t\treturn ReplaceUnderscores.INSTANCE;\n\t\t}\n\t\tif (generatorClass == IndicativeSentences.class) {\n\t\t\treturn IndicativeSentences.INSTANCE;\n\t\t}\n\t\treturn (DisplayNameGenerator) ReflectionSupport.newInstance(generatorClass);\n\t}",
    "comment": "Return the {@code DisplayNameGenerator} instance corresponding to the\ngiven {@code Class}.\n\n@param generatorClass the generator's {@code Class}; never {@code null},\nhas to be a {@code DisplayNameGenerator} implementation\n@return a {@code DisplayNameGenerator} implementation instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/DefaultMethodTests.java",
    "type": "method",
    "name": "executeTestCaseWithOverriddenGenericDefaultMethodSelectedByClass",
    "code": "void executeTestCaseWithOverriddenGenericDefaultMethodSelectedByClass() {\n\t\tClass<?> clazz = GenericTestCaseWithOverriddenDefaultMethod.class;\n\t\tLauncherDiscoveryRequest request = request().selectors(selectClass(clazz)).build();\n\t\tEngineExecutionResults executionResults = executeTests(request);\n\n\t\tassertAll(\n\t\t\t\t() -> assertTrue(beforeAllInvoked, \"@BeforeAll default method invoked from interface\"),\n\t\t\t\t() -> assertTrue(afterAllInvoked, \"@AfterAll default method invoked from interface\"),\n\t\t\t\t() -> assertFalse(defaultMethodInvoked, \"default @Test method should not have been invoked from interface\"),\n\t\t\t\t() -> assertTrue(overriddenDefaultMethodInvoked, \"overridden default @Test method invoked from interface\"),\n\t\t\t\t() -> assertTrue(localMethodInvoked, \"local @Test method invoked from class\"),\n\t\t\t\t() -> assertEquals(2, executionResults.testEvents().started().count(), \"# tests started\"),\n\t\t\t\t() -> assertEquals(2, executionResults.testEvents().succeeded().count(), \"# tests succeeded\"),\n\t\t\t\t() -> assertEquals(0, executionResults.testEvents().failed().count(), \"# tests failed\")\n\t\t);\n\t}",
    "comment": "@formatter:off\nIf defaultMethodInvoked is false and the following ends up being\n3 instead of 2, that means that the overriding method gets invoked\ntwice: once as itself and a second time \"as\" the default method which\nshould not have been \"discovered\" since it is overridden.\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "semanticCompare",
    "code": "public int semanticCompare(final UTF8String other, int collationId) {\n    return CollationFactory.fetchCollation(collationId).comparator.compare(this, other);\n  }",
    "comment": "Collation-aware comparison of two UTF8String. The collation to use is specified by the\n`collationId` parameter."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/providers/packaging/AbstractLifecycleMappingProvider.java",
    "type": "method",
    "name": "AbstractLifecycleMappingProvider",
    "code": "protected AbstractLifecycleMappingProvider(String[] pluginBindings) {\n        requireNonNull(pluginBindings);\n        final int len = pluginBindings.length;\n        if (len < 2 || len % 2 != 0) {\n            throw new IllegalArgumentException(\"Plugin bindings must have more than 0, even count of elements\");\n        }\n\n        HashMap<String, LifecyclePhase> lifecyclePhaseBindings = new HashMap<>(len / 2);\n        for (int i = 0; i < len; i = i + 2) {\n            lifecyclePhaseBindings.put(pluginBindings[i], new LifecyclePhase(pluginBindings[i + 1]));\n        }\n\n        Lifecycle lifecycle = new Lifecycle();\n        lifecycle.setId(\"default\");\n        lifecycle.setLifecyclePhases(Collections.unmodifiableMap(lifecyclePhaseBindings));\n\n        this.lifecycleMapping = new DefaultLifecycleMapping(Collections.singletonList(lifecycle));\n    }",
    "comment": "Base lifecycle mapping provider, ie per-packaging plugin bindings for {@code default} lifecycle."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/ModelBenchmarkReport.java",
    "type": "method",
    "name": "if",
    "code": "Double referenceValue, Double testTargetValue, String metricName) {\n    boolean checkRegression = maxRegressionPercentageAllowed.containsKey(metricName);\n    String regression = \"N/A\";\n    BenchmarkResultType result =\n        checkRegression ? BenchmarkResultType.FAIL : BenchmarkResultType.NOT_APPLICABLE;\n    if (referenceValue == null || testTargetValue == null) {\n      return MetricsEntry.create(referenceValue, regression, result);\n    }\n    if (metricName.equals(\"ok\")) {\n      if (testTargetValue == AccuracyBenchmarkReport.PASS) {\n        result = BenchmarkResultType.PASS;\n      } else if (referenceValue == AccuracyBenchmarkReport.FAIL) {\n        result = BenchmarkResultType.PASS_WITH_WARNING;\n      }\n      return MetricsEntry.create(referenceValue, regression, result);\n    }\n\n    double regressionValue = 0.0;\n    if (!testTargetValue.equals(referenceValue)) {\n      regressionValue = (testTargetValue - referenceValue) / referenceValue;\n    }\n    if (checkRegression) {\n      if (regressionValue <= 0) {\n        result = BenchmarkResultType.PASS;\n      } else if (regressionValue <= maxRegressionPercentageAllowed.get(metricName) / 100f) {\n        result = BenchmarkResultType.PASS_WITH_WARNING;\n      }\n    }\n    regression = toPercentage(regressionValue);\n    return MetricsEntry.create(referenceValue, regression, result);\n  }",
    "comment": "Here is a mitigation to the lack of support for criteria operators. \"ok\" metric is handled\nspecifically for the accuracy benchmarking results.\nTODO(b/267313326): remove the mitigation after the criteria operators are added.\nThe test target delegate passed the accuracy checks.\nBoth the test target and the reference delegates failed the accuracy checks. Therefore,\nit is not considered as a regression.\nHere we assume that lower values of the metric are better, for all of our metrics.\nTODO(b/267313326): Remove the assumption with the criteria operator support."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "writeTo",
    "code": "public void writeTo(IntBuffer dst) {\n    if (dtype != DataType.INT32) {\n      throw incompatibleBuffer(dst, dtype);\n    }\n    ByteBuffer src = buffer();\n    dst.put(src.asIntBuffer());\n  }",
    "comment": "Write the data of a {@link Integer} tensor into the given buffer.\n\n<p>Copies {@code numElements()} elements to the buffer.\n\n@param dst the destination buffer\n@throws BufferOverflowException If there is insufficient space in the given buffer for the data\nin this tensor\n@throws IllegalArgumentException If the tensor data type is not {@link Integer}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/BuildSuccess.java",
    "type": "method",
    "name": "BuildSuccess",
    "code": "public BuildSuccess(MavenProject project, long time) {\n        this(project, Duration.ofMillis(time));\n    }",
    "comment": "Creates a new build summary for the specified project.\n\n@param project The project being summarized, must not be {@code null}.\n@param time The build time of the project in milliseconds."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/MonotonicClock.java",
    "type": "method",
    "name": "now",
    "code": "public static Instant now() {\n        return get().instant();\n    }",
    "comment": "Returns the current instant from the monotonic clock.\nThis is a convenience method equivalent to {@code get().instant()}.\n\n@return the current instant using monotonic timing"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "getIsValid",
    "code": "private UTF8StringValidity getIsValid() {\n    boolean isValid = true;\n    int byteIndex = 0, byteCount = 0;\n    while (byteIndex < numBytes) {\n      // Read the first byte.\n      byte firstByte = getByte(byteIndex);\n      int expectedLen = bytesOfCodePointInUTF8[firstByte & 0xFF];\n      int codePointLen = Math.min(expectedLen, numBytes - byteIndex);\n      // 0B UTF-8 sequence (invalid first byte).\n      if (codePointLen == 0) {\n        byteCount += UNICODE_REPLACEMENT_CHARACTER.length;\n        isValid = false;\n        ++byteIndex;\n        continue;\n      }\n      // 1B UTF-8 sequence (ASCII or truncated).\n      if (codePointLen == 1) {\n        if (firstByte >= 0) {\n          ++byteCount;\n        }\n        else {\n          byteCount += UNICODE_REPLACEMENT_CHARACTER.length;\n          isValid = false;\n        }\n        ++byteIndex;\n        continue;\n      }\n      // Read the second byte.\n      byte secondByte = getByte(byteIndex + 1);\n      if (!isValidSecondByte(secondByte, firstByte)) {\n        byteCount += UNICODE_REPLACEMENT_CHARACTER.length;\n        isValid = false;\n        ++byteIndex;\n        continue;\n      }\n      // Read remaining continuation bytes.\n      int continuationBytes = 2;\n      for (; continuationBytes < codePointLen; ++continuationBytes) {\n        byte nextByte = getByte(byteIndex + continuationBytes);\n        if (!isValidContinuationByte(nextByte)) {\n          break;\n        }\n      }\n      // Invalid UTF-8 sequence (not enough continuation bytes).\n      if (continuationBytes < expectedLen) {\n        byteCount += UNICODE_REPLACEMENT_CHARACTER.length;\n        isValid = false;\n        byteIndex += continuationBytes;\n        continue;\n      }\n      // Valid UTF-8 sequence.\n      for (int i = 0; i < codePointLen; ++i) {\n        ++byteCount;\n      }\n      byteIndex += codePointLen;\n    }\n    setNumBytesValid(byteCount);\n    return isValid ? UTF8StringValidity.IS_VALID : UTF8StringValidity.NOT_VALID;\n  }",
    "comment": "Private helper method to calculate whether the current UTF-8 string is valid. Checking\nall code points is a linear time operation, as we need to scan the entire UTF-8 string.\nHence, this method should generally only be called only once during UTF8String lifetime.\nUnlike `getNumBytesValid`, this method performs early exit as soon as an invalid byte\nsequence is found, and returns a boolean indicating the validity of the current string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/ShoppingCartService.java",
    "type": "method",
    "name": "addItemToCart",
    "code": "public void addItemToCart(final String userId, final String productId, final int quantity) {\n    Product product = productRepository.getProductById(productId);\n    if (product != null) {\n      cartRepository.addItemToCart(userId, product, quantity);\n    }\n  }",
    "comment": "Adds an item to the user's shopping cart.\n\n@param userId The ID of the user.\n@param productId The ID of the product to be added.\n@param quantity The quantity of the product."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java",
    "type": "method",
    "name": "IncludesArtifactFilter",
    "code": "public IncludesArtifactFilter(List<String> patterns) {\n        this.patterns = new LinkedHashSet<>(patterns);\n    }",
    "comment": "Filter to include from a list of artifact patterns."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/ReactorReader.java",
    "type": "method",
    "name": "determineBuildOutputDirectoryForArtifact",
    "code": "private File determineBuildOutputDirectoryForArtifact(final MavenProject project, final Artifact artifact) {\n        if (isTestArtifact(artifact)) {\n            if (project.hasLifecyclePhase(\"test-compile\")) {\n                return new File(project.getBuild().getTestOutputDirectory());\n            }\n        } else {\n            String type = artifact.getProperty(\"type\", \"\");\n            File outputDirectory = new File(project.getBuild().getOutputDirectory());\n\n            boolean projectCompiledDuringThisSession =\n                    project.hasLifecyclePhase(\"compile\") && COMPILE_PHASE_TYPES.contains(type);\n\n            boolean projectHasOutputFromPreviousSession =\n                    !session.getProjects().contains(project) && outputDirectory.exists();\n\n            if (projectHasOutputFromPreviousSession || projectCompiledDuringThisSession) {\n                return outputDirectory;\n            }\n        }\n\n        return null;\n    }",
    "comment": "Check if the project is being built during this session, and if we can expect any output.\nThere is no need to check if the build has created any outputs, see MNG-2222.\nCheck if the project is part of the session (not filtered by -pl, -rf, etc). If so, we check\nif a possible earlier Maven invocation produced some output for that project which we can use.\nThe fall-through indicates that the artifact cannot be found;\nfor instance if package produced nothing or classifier problems."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/LauncherServer.java",
    "type": "method",
    "name": "unregister",
    "code": "void unregister(AbstractAppHandle handle) {\n    for (Map.Entry<String, AbstractAppHandle> e : secretToPendingApps.entrySet()) {\n      if (e.getValue().equals(handle)) {\n        String secret = e.getKey();\n        secretToPendingApps.remove(secret);\n        break;\n      }\n    }\n\n    unref();\n  }",
    "comment": "Removes the client handle from the pending list (in case it's still there), and unrefs\nthe server."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/version/internal/DefaultPluginVersionResolver.java",
    "type": "method",
    "name": "isCompatible",
    "code": "private boolean isCompatible(PluginVersionRequest request, String version) {\n        Plugin plugin = new Plugin();\n        plugin.setGroupId(request.getGroupId());\n        plugin.setArtifactId(request.getArtifactId());\n        plugin.setVersion(version);\n\n        PluginDescriptor pluginDescriptor;\n\n        try {\n            pluginDescriptor = pluginManager.getPluginDescriptor(\n                    plugin, request.getRepositories(), request.getRepositorySession());\n        } catch (PluginResolutionException e) {\n            logger.debug(\"Ignoring unresolvable plugin version {}\", version, e);\n            return false;\n        } catch (Exception e) {\n            return true;\n        }\n\n        try {\n            pluginManager.checkPrerequisites(pluginDescriptor);\n        } catch (PluginIncompatibleException e) {\n            if (logger.isDebugEnabled()) {\n                logger.warn(\"Ignoring incompatible plugin version {}:\", version, e);\n            } else {\n                logger.warn(\"Ignoring incompatible plugin version {}: {}\", version, e.getMessage());\n            }\n            return false;\n        }\n\n        return true;\n    }",
    "comment": "ignore for now and delay failure to higher level processing"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/session/SessionManager.java",
    "type": "method",
    "name": "init",
    "code": "public synchronized void init(HiveConf hiveConf) {\n    this.hiveConf = hiveConf;\n    if (hiveConf.getBoolVar(ConfVars.HIVE_SERVER2_LOGGING_OPERATION_ENABLED)) {\n      initOperationLogRootDir();\n    }\n    createBackgroundOperationPool();\n    addService(operationManager);\n    super.init(hiveConf);\n  }",
    "comment": "Create operation log root directory, if operation logging is enabled"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java",
    "type": "method",
    "name": "doMain",
    "code": "public int doMain(String[] args, String workingDirectory, PrintStream stdout, PrintStream stderr) {\n        PrintStream oldout = System.out;\n        PrintStream olderr = System.err;\n\n        final Set<String> realms;\n        if (classWorld != null) {\n            realms = new HashSet<>();\n            for (ClassRealm realm : classWorld.getRealms()) {\n                realms.add(realm.getId());\n            }\n        } else {\n            realms = Collections.emptySet();\n        }\n\n        try {\n            if (stdout != null) {\n                System.setOut(stdout);\n            }\n            if (stderr != null) {\n                System.setErr(stderr);\n            }\n\n            CliRequest cliRequest = new CliRequest(args, classWorld);\n            cliRequest.workingDirectory = workingDirectory;\n\n            return doMain(cliRequest);\n        } finally {\n            if (classWorld != null) {\n                for (ClassRealm realm : new ArrayList<>(classWorld.getRealms())) {\n                            // can't happen\n                        }\n                    }\n                }\n            }",
    "comment": "This supports painless invocation by the Verifier during embedded execution of the core ITs.\nSee <a href=\"http://maven.apache.org/shared/maven-verifier/xref/org/apache/maven/it/Embedded3xLauncher.html\">\n<code>Embedded3xLauncher</code> in <code>maven-verifier</code></a>\n\n@param args CLI args\n@param workingDirectory working directory\n@param stdout stdout\n@param stderr stderr\n@return return code"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/CloseablePathTests.java",
    "type": "method",
    "name": "setUpExtensionContext",
    "code": "void setUpExtensionContext() {\n\t\tvar store = new NamespaceAwareStore(new NamespacedHierarchicalStore<>(null), Namespace.GLOBAL);\n\t\twhen(extensionContext.getStore(any())).thenReturn(store);\n\t}",
    "comment": "Integration tests for the creation and cleanup of the {@link TempDirectory}.\n\n@since 5.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(long[] expected, long[] actual) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} long arrays are equal.\n<p>If both are {@code null}, they are considered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/utils/Os.java",
    "type": "method",
    "name": "getOsFamily",
    "code": "private static String getOsFamily() {\n        return Stream.of(\n                        FAMILY_DOS,\n                        FAMILY_MAC,\n                        FAMILY_NETWARE,\n                        FAMILY_NT,\n                        FAMILY_OPENVMS,\n                        FAMILY_OS2,\n                        FAMILY_OS400,\n                        FAMILY_TANDEM,\n                        FAMILY_UNIX,\n                        FAMILY_WIN9X,\n                        FAMILY_WINDOWS,\n                        FAMILY_ZOS)\n                .filter(Os::isFamily)\n                .findFirst()\n                .orElse(null);\n    }",
    "comment": "Helper method to determine the current OS family.\n\n@return name of current OS family."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "fromString",
    "code": "public static UTF8String fromString(String str) {\n    return str == null ? null : fromBytes(str.getBytes(StandardCharsets.UTF_8));\n  }",
    "comment": "Creates an UTF8String from String."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/collecting-parameter/src/main/java/com/iluwatar/collectingparameter/PrinterQueue.java",
    "type": "method",
    "name": "getInstance",
    "code": "public static PrinterQueue getInstance() {\n    if (Objects.isNull(currentInstance)) {\n      currentInstance = new PrinterQueue();\n    }\n    return currentInstance;\n  }",
    "comment": "This class is a singleton. The getInstance method will ensure that only one instance exists at\na time."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/OneForOneBlockPusherSuite.java",
    "type": "method",
    "name": "if",
    "code": "Iterable<BlockTransferMessage> expectMessages) {\n    TransportClient client = mock(TransportClient.class);\n    BlockPushingListener listener = mock(BlockPushingListener.class);\n    OneForOneBlockPusher pusher =\n      new OneForOneBlockPusher(client, \"app-id\", 0, blockIds, listener, blocks);\n\n    Iterator<Map.Entry<String, ManagedBuffer>> blockIterator = blocks.entrySet().iterator();\n    Iterator<BlockTransferMessage> msgIterator = expectMessages.iterator();\n    doAnswer(invocation -> {\n      ByteBuffer header = ((ManagedBuffer) invocation.getArguments()[0]).nioByteBuffer();\n      BlockTransferMessage message = BlockTransferMessage.Decoder.fromByteBuffer(header);\n      RpcResponseCallback callback = (RpcResponseCallback) invocation.getArguments()[2];\n      Map.Entry<String, ManagedBuffer> entry = blockIterator.next();\n      String blockId = entry.getKey();\n      ManagedBuffer block = entry.getValue();\n      if (block != null && block.nioByteBuffer().capacity() > 0) {\n        callback.onSuccess(new BlockPushReturnCode(ReturnCode.SUCCESS.id(), \"\").toByteBuffer());\n      } else if (block != null) {\n        callback.onSuccess(new BlockPushReturnCode(\n          ReturnCode.BLOCK_APPEND_COLLISION_DETECTED.id(), blockId).toByteBuffer());\n      } else {\n        callback.onFailure(new BlockPushNonFatalFailure(\n          ReturnCode.TOO_LATE_BLOCK_PUSH, \"\"));\n      }\n      assertEquals(msgIterator.next(), message);\n      return null;\n    }).when(client).uploadStream(any(ManagedBuffer.class), any(), any(RpcResponseCallback.class));\n\n    pusher.start();\n    return listener;\n  }",
    "comment": "Begins a push on the given set of blocks by mocking the response from server side.\nIf a block is an empty byte, a server side retriable exception will be thrown.\nIf a block is null, a non-retriable exception will be thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectMethod",
    "code": "public static MethodSelector selectMethod(String className, String methodName, String parameterTypeNames) {\n\t\treturn selectMethod(null, className, methodName, parameterTypeNames);\n\t}",
    "comment": "Create a {@code MethodSelector} for the supplied class name, method name,\nand parameter type names.\n\n<p>The parameter type names {@code String} is typically a comma-separated\nlist of atomic types, fully qualified class names, or array types; however,\nthe exact syntax depends on the underlying test engine.\n\n@param className the fully qualified name of the class in which the method\nis declared, or a subclass thereof; never {@code null} or blank\n@param methodName the name of the method to select; never {@code null} or blank\n@param parameterTypeNames the parameter type names as a single string; never\n{@code null} though potentially an empty string if the method does not declare\nparameters\n@see MethodSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setBoolean",
    "code": "public void setBoolean(boolean value) {\n    byteData = (byte) ((value) ? 1 : 0);\n  }",
    "comment": "Sets the boolean `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/event/ExecutionEventLogger.java",
    "type": "method",
    "name": "forkStarted",
    "code": "public void forkStarted(ExecutionEvent event) {\n        if (logger.isInfoEnabled()) {\n            init();\n            logger.info(\"\");\n\n            MessageBuilder buffer = builder().strong(\">>> \");\n            append(buffer, event.getMojoExecution());\n            buffer.strong(\" > \");\n            appendForkInfo(buffer, event.getMojoExecution().getMojoDescriptor());\n            append(buffer, event.getProject());\n            buffer.strong(\" >>>\");\n\n            logger.info(buffer.toString());\n        }\n    }",
    "comment": "<pre>&gt;&gt;&gt; mojo-artifactId:version:goal (mojo-executionId) &gt; :forked-goal @ project-artifactId &gt;&gt;&gt;</pre>\n<pre>&gt;&gt;&gt; mojo-artifactId:version:goal (mojo-executionId) &gt; [lifecycle]phase @ project-artifactId &gt;&gt;&gt;</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/database/MongoDb.java",
    "type": "method",
    "name": "upsertDb",
    "code": "public UserAccount upsertDb(final UserAccount userAccount) {\n    String userId = userAccount.getUserId();\n    String userName = userAccount.getUserName();\n    String additionalInfo = userAccount.getAdditionalInfo();\n    db.getCollection(CachingConstants.USER_ACCOUNT)\n        .updateOne(\n            new Document(USER_ID, userId),\n            new Document(\n                \"$set\",\n                new Document(USER_ID, userId)\n                    .append(USER_NAME, userName)\n                    .append(ADD_INFO, additionalInfo)),\n            new UpdateOptions().upsert(true));\n    return userAccount;\n  }",
    "comment": "Update data if exists.\n\n@param userAccount {@link UserAccount}\n@return {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceContentProviderSample/app/src/main/java/com/example/android/contentprovidersample/data/SampleDatabase.java",
    "type": "method",
    "name": "getInstance",
    "code": "public static synchronized SampleDatabase getInstance(Context context) {\n        if (sInstance == null) {\n            sInstance = Room\n                    .databaseBuilder(context.getApplicationContext(), SampleDatabase.class, \"ex\")\n                    .build();\n            sInstance.populateInitialData();\n        }\n        return sInstance;\n    }",
    "comment": "Gets the singleton instance of SampleDatabase.\n\n@param context The context.\n@return The singleton instance of SampleDatabase."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/inference_interface/java/org/tensorflow/contrib/android/TensorFlowInferenceInterface.java",
    "type": "method",
    "name": "TensorFlowInferenceInterface",
    "code": "public TensorFlowInferenceInterface(AssetManager assetManager, String model) {\n    prepareNativeRuntime();\n\n    this.modelName = model;\n    this.g = new Graph();\n    this.sess = new Session(g);\n    this.runner = sess.runner();\n\n    final boolean hasAssetPrefix = model.startsWith(ASSET_FILE_PREFIX);\n    InputStream is = null;\n    try {\n      String aname = hasAssetPrefix ? model.split(ASSET_FILE_PREFIX)[1] : model;\n      is = assetManager.open(aname);\n    } catch (IOException e) {\n      if (hasAssetPrefix) {\n        throw new RuntimeException(\"Failed to load model from '\" + model + \"'\", e);\n      }\n      // Perhaps the model file is not an asset but is on disk.\n      try {\n        is = new FileInputStream(model);\n      } catch (IOException e2) {\n        throw new RuntimeException(\"Failed to load model from '\" + model + \"'\", e);\n      }\n    }\n\n    try {\n      if (VERSION.SDK_INT >= 18) {\n        Trace.beginSection(\"initializeTensorFlow\");\n        Trace.beginSection(\"readGraphDef\");\n      }\n\n      // TODO(ashankar): Can we somehow mmap the contents instead of copying them?\n      byte[] graphDef = new byte[is.available()];\n      final int numBytesRead = is.read(graphDef);\n      if (numBytesRead != graphDef.length) {\n        throw new IOException(\n            \"read error: read only \"\n                + numBytesRead\n                + \" of the graph, expected to read \"\n                + graphDef.length);\n      }\n\n      if (VERSION.SDK_INT >= 18) {\n        Trace.endSection(); // readGraphDef.\n      }\n\n      loadGraph(graphDef, g);\n      is.close();\n      Log.i(TAG, \"Successfully loaded model from '\" + model + \"'\");\n\n      if (VERSION.SDK_INT >= 18) {\n        Trace.endSection(); // initializeTensorFlow.\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Failed to load model from '\" + model + \"'\", e);\n    }\n  }",
    "comment": "Wrapper over the TensorFlow API ({@link Graph}, {@link Session}) providing a smaller API surface\nfor inference.\n\n<p>See tensorflow/tools/android/test/src/org/tensorflow/demo/TensorFlowImageClassifier.java for\nan example usage."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/flux/src/test/java/com/iluwatar/flux/dispatcher/DispatcherTest.java",
    "type": "method",
    "name": "testMenuItemSelected",
    "code": "void testMenuItemSelected() {\n    final var dispatcher = Dispatcher.getInstance();\n\n    final var store = mock(Store.class);\n    dispatcher.registerStore(store);\n    dispatcher.menuItemSelected(MenuItem.HOME);\n    dispatcher.menuItemSelected(MenuItem.COMPANY);\n\n    final var actionCaptor = ArgumentCaptor.forClass(Action.class);\n    verify(store, times(4)).onAction(actionCaptor.capture());\n    verifyNoMoreInteractions(store);\n\n    final var actions = actionCaptor.getAllValues();\n    final var menuActions =\n        actions.stream()\n            .filter(a -> a.getType().equals(ActionType.MENU_ITEM_SELECTED))\n            .map(a -> (MenuAction) a)\n            .toList();\n\n    final var contentActions =\n        actions.stream()\n            .filter(a -> a.getType().equals(ActionType.CONTENT_CHANGED))\n            .map(a -> (ContentAction) a)\n            .toList();\n\n    assertEquals(2, menuActions.size());\n    assertEquals(\n        1, menuActions.stream().map(MenuAction::getMenuItem).filter(MenuItem.HOME::equals).count());\n    assertEquals(\n        1,\n        menuActions.stream().map(MenuAction::getMenuItem).filter(MenuItem.COMPANY::equals).count());\n\n    assertEquals(2, contentActions.size());\n    assertEquals(\n        1,\n        contentActions.stream()\n            .map(ContentAction::getContent)\n            .filter(Content.PRODUCTS::equals)\n            .count());\n    assertEquals(\n        1,\n        contentActions.stream()\n            .map(ContentAction::getContent)\n            .filter(Content.COMPANY::equals)\n            .count());\n  }",
    "comment": "We expect 4 events, 2 menu selections and 2 content change actions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProjectBuilderRequest.java",
    "type": "method",
    "name": "source",
    "code": "public ProjectBuilderRequestBuilder source(Source source) {\n            this.source = source;\n            return this;\n        }",
    "comment": "Sets the source of the project to build.\nThis is an alternative to specifying a path, allowing the project to be built from\na model source such as a string or input stream.\n\n@param source the source of the project\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/DisabledCondition.java",
    "type": "method",
    "name": "evaluateExecutionCondition",
    "code": "public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {\n\t\tAnnotatedElement element = context.getElement().orElse(null);\n\t\treturn findAnnotation(element, Disabled.class) //\n\t\t\t\t.map(annotation -> toResult(element, annotation)) //\n\t\t\t\t.orElse(ENABLED);\n\t}",
    "comment": "Containers/tests are disabled if {@code @Disabled} is present on the test\nclass or method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "blankString",
    "code": "public static UTF8String blankString(int length) {\n    byte[] spaces = new byte[length];\n    Arrays.fill(spaces, (byte) ' ');\n    return fromBytes(spaces);\n  }",
    "comment": "Creates an UTF8String that contains `length` spaces."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "redirectOutput",
    "code": "public SparkLauncher redirectOutput(ProcessBuilder.Redirect to) {\n    outputStream = to;\n    return this;\n  }",
    "comment": "Redirects standard output to the specified Redirect.\n\n@param to The method of redirection.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExternalBlockStoreClient.java",
    "type": "method",
    "name": "removeShuffleMerge",
    "code": "public boolean removeShuffleMerge(String host, int port, int shuffleId, int shuffleMergeId) {\n    checkInit();\n    try {\n      TransportClient client = clientFactory.createClient(host, port);\n      client.send(\n          new RemoveShuffleMerge(appId, comparableAppAttemptId, shuffleId, shuffleMergeId)\n              .toByteBuffer());\n    } catch (Exception e) {\n      logger.debug(\"Exception while sending RemoveShuffleMerge request to {}:{}\",\n          host, port, e);\n      return false;\n    }\n    return true;\n  }",
    "comment": "TODO(SPARK-42025): Add some error logs for RemoveShuffleMerge RPC"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-model/src/main/java/org/apache/maven/api/model/InputLocation.java",
    "type": "method",
    "name": "InputLocation",
    "code": "public InputLocation(InputSource source) {\n        this.lineNumber = -1;\n        this.columnNumber = -1;\n        this.source = source;\n        this.locations = Collections.singletonMap(0, this);\n        this.importedFrom = null;\n    }",
    "comment": "Represents the location of an element within a model source file.\n<p>\nThis class tracks the line and column numbers of elements in source files like POM files.\nIt's used for error reporting and debugging to help identify where specific model elements\nare defined in the source files.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/MethodMap.java",
    "type": "method",
    "name": "isStrictMethodInvocationConvertible",
    "code": "private static boolean isStrictMethodInvocationConvertible(Class<?> formal, Class<?> actual) {\n        // we shouldn't get a null into, but if so\n        if (actual == null && !formal.isPrimitive()) {\n            return true;\n        }\n\n        // Check for identity or widening reference conversion\n        if (formal.isAssignableFrom(actual)) {\n            return true;\n        }\n\n        // Check for widening primitive conversion.\n        if (formal.isPrimitive()) {\n            if (formal == Short.TYPE && (actual == Byte.TYPE)) {\n                return true;\n            }\n            if (formal == Integer.TYPE && (actual == Short.TYPE || actual == Byte.TYPE)) {\n                return true;\n            }\n            if (formal == Long.TYPE && (actual == Integer.TYPE || actual == Short.TYPE || actual == Byte.TYPE)) {\n                return true;\n            }\n            if (formal == Float.TYPE\n                    && (actual == Long.TYPE || actual == Integer.TYPE || actual == Short.TYPE || actual == Byte.TYPE)) {\n                return true;\n            }\n            if (formal == Double.TYPE\n                    && (actual == Float.TYPE\n                            || actual == Long.TYPE\n                            || actual == Integer.TYPE\n                            || actual == Short.TYPE\n                            || actual == Byte.TYPE)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "comment": "Determines whether a type represented by a class object is\nconvertible to another type represented by a class object using a\nmethod invocation conversion, without matching object and primitive\ntypes. This method is used to determine the more specific type when\ncomparing signatures of methods.\n\n@param formal the formal parameter type to which the actual\nparameter type should be convertible\n@param actual the actual parameter type.\n@return true if either formal type is assignable from actual type,\nor formal and actual are both primitive types and actual can be\nsubject to widening conversion to formal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/ClassMap.java",
    "type": "method",
    "name": "getPublicMethod",
    "code": "private static Method getPublicMethod(Method method) {\n        Class<?> clazz = method.getDeclaringClass();\n\n        // Short circuit for (hopefully the majority of) cases where the declaring\n        // class is public.\n        if ((clazz.getModifiers() & Modifier.PUBLIC) != 0) {\n            return method;\n        }\n\n        return getPublicMethod(clazz, method.getName(), method.getParameterTypes());\n    }",
    "comment": "For a given method, retrieves its publicly accessible counterpart.\nThis method will look for a method with same name\nand signature declared in a public superclass or implemented interface of this\nmethod's declaring class. This counterpart method is publicly callable.\n\n@param method a method whose publicly callable counterpart is requested.\n@return the publicly callable counterpart method. Note that if the parameter\nmethod is itself declared by a public class, this method is an identity\nfunction."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/ClockSource.java",
    "type": "method",
    "name": "toNanos",
    "code": "static long toNanos(long time) {\n      return CLOCK.toNanos0(time);\n   }",
    "comment": "Convert an opaque time-stamp returned by currentTime() into\nnanoseconds.\n\n@param time an opaque time-stamp returned by an instance of this class\n@return the time-stamp in nanoseconds"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-di/src/main/java/org/apache/maven/di/Key.java",
    "type": "method",
    "name": "getDisplayString",
    "code": "public String getDisplayString() {\n        StringBuilder result = new StringBuilder();\n        if (qualifier instanceof String s) {\n            if (s.isEmpty()) {\n                result.append(\"@Named \");\n            } else {\n                result.append(\"@Named(\\\"\").append(s).append(\"\\\") \");\n            }\n        } else if (qualifier != null) {\n            ReflectionUtils.getDisplayString(result, qualifier);\n            result.append(\" \");\n        }\n        result.append(ReflectionUtils.getDisplayName(type));\n        return result.toString();\n    }",
    "comment": "Returns an underlying type with display string formatting (package names stripped)\nand prepended qualifier display string if this key has a qualifier."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(String message, boolean condition) {\n        if (!condition) {\n            fail(message);\n        }\n    }",
    "comment": "Asserts that a condition is true. If it isn't it throws\nan AssertionFailedError with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/VariableLengthRowBasedKeyValueBatch.java",
    "type": "method",
    "name": "getKeyRow",
    "code": "public UnsafeRow getKeyRow(int rowId) {\n    assert(rowId >= 0);\n    assert(rowId < numRows);\n    if (keyRowId != rowId) { // if keyRowId == rowId, desired keyRow is already cached\n      long offset = keyOffsets[rowId];\n      int klen = UnsafeAlignedOffset.getSize(base, offset - UnsafeAlignedOffset.getUaoSize());\n      keyRow.pointTo(base, offset, klen);\n      // set keyRowId so we can check if desired row is cached\n      keyRowId = rowId;\n    }\n    return keyRow;\n  }",
    "comment": "Returns the key row in this batch at `rowId`. Returned key row is reused across calls."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "binaryCompare",
    "code": "public int binaryCompare(final UTF8String other) {\n    return ByteArray.compareBinary(\n      base, offset, numBytes, other.base, other.offset, other.numBytes);\n  }",
    "comment": "Binary comparison of two UTF8String. Can only be used for default UTF8_BINARY collation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProblemCollector.java",
    "type": "method",
    "name": "problems",
    "code": "default Stream<P> problems() {\n        Stream<P> result = Stream.empty();\n        for (BuilderProblem.Severity severity : BuilderProblem.Severity.values()) {\n            result = Stream.concat(result, problems(severity));\n        }\n        return result;\n    }",
    "comment": "Returns all reported and preserved problems ordered by severity in decreasing order. Note: counters and\nelement count in this stream does not have to be equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Boolean> create(boolean[][] data) {\n    return Tensor.create(data, Boolean.class);\n  }",
    "comment": "Creates a rank-2 tensor of {@code boolean} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Timeout.java",
    "type": "method",
    "name": "Timeout",
    "code": "protected Timeout(Builder builder) {\n        timeout = builder.getTimeout();\n        timeUnit = builder.getTimeUnit();\n        lookForStuckThread = builder.getLookingForStuckThread();\n    }",
    "comment": "Create a {@code Timeout} instance initialized with values from\na builder.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeExternalSorter.java",
    "type": "method",
    "name": "getPeakMemoryUsedBytes",
    "code": "public long getPeakMemoryUsedBytes() {\n    updatePeakMemoryUsed();\n    return peakMemoryUsedBytes;\n  }",
    "comment": "Return the peak memory used so far, in bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/HikariConfig.java",
    "type": "method",
    "name": "setExceptionOverride",
    "code": "public void setExceptionOverride(SQLExceptionOverride exceptionOverride) {\n      checkIfSealed();\n      this.exceptionOverride = exceptionOverride;\n   }",
    "comment": "Set the user supplied SQLExceptionOverride instance.\n\n@param exceptionOverride the user supplied SQLExceptionOverride instance\n@see SQLExceptionOverride"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TerminationInfo.java",
    "type": "method",
    "name": "executed",
    "code": "public boolean executed() {\n\t\treturn (this.testExecutionResult != null);\n\t}",
    "comment": "Determine if this {@code TerminationInfo} represents a completed execution.\n\n@return {@code true} if this this {@code TerminationInfo} represents a\ncompleted execution"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RetryingBlockTransferor.java",
    "type": "method",
    "name": "transferAllOutstanding",
    "code": "private void transferAllOutstanding() {\n    // Start by retrieving our shared state within a synchronized block.\n    String[] blockIdsToTransfer;\n    int numRetries;\n    RetryingBlockTransferListener myListener;\n    synchronized (this) {\n      blockIdsToTransfer = outstandingBlocksIds.toArray(new String[outstandingBlocksIds.size()]);\n      numRetries = retryCount;\n      myListener = currentListener;\n    }\n\n    // Now initiate the transfer on all outstanding blocks, possibly initiating a retry if that\n    // fails.\n    try {\n      transferStarter.createAndStart(blockIdsToTransfer, myListener);\n    } catch (Exception e) {\n      if (numRetries > 0) {\n        logger.error(\"Exception while beginning {} of {} outstanding blocks (after {} retries)\", e,\n          MDC.of(LogKeys.TRANSFER_TYPE$.MODULE$, listener.getTransferType()),\n          MDC.of(LogKeys.NUM_BLOCKS$.MODULE$, blockIdsToTransfer.length),\n          MDC.of(LogKeys.NUM_RETRY$.MODULE$, numRetries));\n      } else {\n        logger.error(\"Exception while beginning {} of {} outstanding blocks\", e,\n          MDC.of(LogKeys.TRANSFER_TYPE$.MODULE$, listener.getTransferType()),\n          MDC.of(LogKeys.NUM_BLOCKS$.MODULE$, blockIdsToTransfer.length));\n      }\n      if (shouldRetry(e) && initiateRetry(e)) {\n        // successfully initiated a retry\n        return;\n      }\n\n      // retry is not possible, so fail remaining blocks\n      for (String bid : blockIdsToTransfer) {\n        listener.onBlockTransferFailure(bid, e);\n      }\n    }\n  }",
    "comment": "Fires off a request to transfer all blocks that have not been transferred successfully or\npermanently failed (i.e., by a non-IOException)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "toUpperCase",
    "code": "public static UTF8String toUpperCase(final UTF8String target, final int collationId) {\n    if (target.isFullAscii()) return target.toUpperCaseAscii();\n    return toUpperCaseSlow(target, collationId);\n  }",
    "comment": "Convert the input string to uppercase using the specified ICU collation rules.\n\n@param target the input string\n@return the uppercase string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Timeout.java",
    "type": "method",
    "name": "builder",
    "code": "public static Builder builder() {\n        return new Builder();\n    }",
    "comment": "Returns a new builder for building an instance.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/gpu/java/src/main/java/org/tensorflow/lite/gpu/GpuDelegateFactory.java",
    "type": "method",
    "name": "setInferencePreference",
    "code": "public Options setInferencePreference(int preference) {\n      this.inferencePreference = preference;\n      return this;\n    }",
    "comment": "Sets the inference preference for precision/compilation/runtime tradeoffs.\n\n@param preference One of `INFERENCE_PREFERENCE_FAST_SINGLE_ANSWER` (default),\n`INFERENCE_PREFERENCE_SUSTAINED_SPEED`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "appendNull",
    "code": "public final int appendNull() {\n    assert (!(dataType() instanceof StructType)); // Use appendStruct()\n    reserve(elementsAppended + 1);\n    putNull(elementsAppended);\n    return elementsAppended++;\n  }",
    "comment": "Append APIs. These APIs all behave similarly and will append data to the current vector.  It\nis not valid to mix the put and append APIs. The append APIs are slower and should only be\nused if the sizes are not known up front.\nIn all these cases, the return value is the rowId for the first appended element."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "execute",
    "code": "public static EngineExecutionResults execute(TestEngine testEngine, LauncherDiscoveryRequest discoveryRequest) {\n\t\tPreconditions.notNull(testEngine, \"TestEngine must not be null\");\n\t\tPreconditions.notNull(discoveryRequest, \"EngineDiscoveryRequest must not be null\");\n\n\t\tExecutionRecorder executionRecorder = new ExecutionRecorder();\n\t\texecuteUsingLauncherOrchestration(testEngine, discoveryRequest, executionRecorder);\n\t\treturn executionRecorder.getExecutionResults();\n\t}",
    "comment": "Execute tests for the given {@link LauncherDiscoveryRequest} using the\nsupplied {@link TestEngine}.\n\n<p>{@link org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder}\nprovides a convenient way to build an appropriate discovery request to\nsupply to this method. As an alternative, consider using\n{@link #engine(TestEngine)} for a more fluent API.\n\n@param testEngine the {@code TestEngine} to use; must not be {@code null}\n@param discoveryRequest the {@code LauncherDiscoveryRequest} to use; must\nnot be {@code null}\n@return the recorded {@code EngineExecutionResults}\n@throws PreconditionViolationException for invalid arguments\n@since 1.7\n@see #execute(String, LauncherDiscoveryRequest)\n@see #engine(String)\n@see #engine(TestEngine)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/ovic/src/main/java/org/tensorflow/ovic/OvicClassifierBenchmarker.java",
    "type": "method",
    "name": "convertBitmapToInput",
    "code": "private void convertBitmapToInput(Bitmap bitmap) {\n    // Perform transformations corresponding to evaluation mode.\n    float width = (float) bitmap.getWidth();\n    float height = (float) bitmap.getHeight();\n    int stWidth = Math.round((width - width * CENTRAL_FRACTION) / 2);\n    int stHeight = Math.round((height - height * CENTRAL_FRACTION) / 2);\n    int newWidth = Math.round(width - stWidth * 2);\n    int newHeight = Math.round(height - stHeight * 2);\n    bitmap = Bitmap.createBitmap(bitmap, stWidth, stHeight, newWidth, newHeight);\n    bitmap = Bitmap.createScaledBitmap(bitmap, imgWidth, imgHeight, true);\n    bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());\n    loadsInputToByteBuffer();\n  }",
    "comment": "Preprocess bitmap according to ImageNet protocol then writes result into a {@link ByteBuffer}.\n\n@param bitmap: a {@link Bitmap} source image."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "appendCodepointToTitleCase",
    "code": "private static void appendCodepointToTitleCase(UTF8StringBuilder sb, int codepoint) {\n    String toTitleCase = codepointOneToManyTitleCaseLookupTable.get(codepoint);\n    if (toTitleCase == null) {\n      sb.appendCodePoint(UCharacter.toTitleCase(codepoint));\n    } else {\n      sb.append(toTitleCase);\n    }\n  }",
    "comment": "Appends title-case of a single character to a 'StringBuilder' using the ICU root locale rules."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/ServiceOperations.java",
    "type": "method",
    "name": "start",
    "code": "public static void start(Service service) {\n    Service.STATE state = service.getServiceState();\n    ensureCurrentState(state, Service.STATE.INITED);\n    service.start();\n  }",
    "comment": "Start a service.\n\nThe service state is checked <i>before</i> the operation begins.\nThis process is <i>not</i> thread safe.\n@param service a service that must be in the state\n{@link Service.STATE#INITED}\n@throws RuntimeException on a state change failure\n@throws IllegalStateException if the service is in the wrong state"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, double actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/internal/MethodSorterTest.java",
    "type": "method",
    "name": "getDeclaredMethodNames",
    "code": "private List<String> getDeclaredMethodNames(Class<?> clazz) {\n        Method[] actualMethods = MethodSorter.getDeclaredMethods(clazz);\n\n        List<String> names = new ArrayList<String>();\n        for (Method m : actualMethods) {\n            if (!m.isSynthetic()) {\n                names.add(m.toString().replace(clazz.getName() + '.', \"\"));\n        \t}\n        }\n        \n        return names;\n    }",
    "comment": "Obtain just the names instead of the full methods.\nFilter out synthetic methods from, e.g., coverage tools."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/TextListener.java",
    "type": "method",
    "name": "elapsedTimeAsString",
    "code": "protected String elapsedTimeAsString(long runTime) {\n        return NumberFormat.getInstance().format((double) runTime / 1000);\n    }",
    "comment": "Returns the formatted string of the elapsed time. Duplicated from\nBaseTestRunner. Fix it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/memory/TaskMemoryManagerSuite.java",
    "type": "method",
    "name": "offHeapConfigurationBackwardsCompatibility",
    "code": "public void offHeapConfigurationBackwardsCompatibility() {\n    final SparkConf conf = new SparkConf()\n      .set(\"spark.unsafe.offHeap\", \"true\")\n      .set(package$.MODULE$.MEMORY_OFFHEAP_SIZE(), 1000L);\n    final TaskMemoryManager manager = new TaskMemoryManager(new TestMemoryManager(conf), 0);\n    Assertions.assertSame(MemoryMode.OFF_HEAP, manager.tungstenMemoryMode);\n  }",
    "comment": "Tests backwards-compatibility with the old `spark.unsafe.offHeap` configuration, which\nwas deprecated in Spark 1.6 and replaced by `spark.memory.offHeap.enabled` (see SPARK-12251)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "filters",
    "code": "public Builder filters(Filter<?>... filters) {\n\t\t\tthis.requestBuilder.filters(filters);\n\t\t\treturn this;\n\t\t}",
    "comment": "Add all of the supplied {@linkplain Filter filters}.\n\n<p>Built-in discovery filters can be created via the static factory\nmethods in {@link org.junit.platform.engine.discovery.ClassNameFilter}\nand {@link org.junit.platform.engine.discovery.PackageNameFilter}.\n\n<p>Built-in post-discovery filters can be created via the static\nfactory methods in {@link org.junit.platform.launcher.TagFilter}.\n\n@param filters the filters to add; never {@code null}\n@return this builder for method chaining\n@since 1.7\n@see #selectors(DiscoverySelector...)\n@see #configurationParameter(String, String)\n@see #configurationParameters(Map)\n@see #execute()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Byte unexpected, Byte actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/MonotonicClock.java",
    "type": "method",
    "name": "instant",
    "code": "public Instant instant() {\n        long elapsedNanos = System.nanoTime() - startNanos;\n        return startInstant.plusNanos(elapsedNanos);\n    }",
    "comment": "Returns a monotonically increasing instant.\n<p>\nThe returned instant is calculated by adding the elapsed nanoseconds\nsince clock creation to the initial wall clock time. This ensures that\nthe time never goes backwards and maintains a consistent relationship\nwith the wall clock time.\n\n@return the current instant using monotonic timing"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assumptions.java",
    "type": "method",
    "name": "abort",
    "code": "public static <V> V abort(String message) {\n\t\tthrow new TestAbortedException(message);\n\t}",
    "comment": "<em>Abort</em> the test with the given {@code message}.\n\n<p>The generic return type {@code V} allows this method to be used\ndirectly as a single-statement lambda expression, thereby avoiding the\nneed to implement a code block with an explicit return value. Since this\nmethod throws a {@link TestAbortedException} before its return statement,\nthis method never actually returns a value to its caller. The following\nexample demonstrates how this may be used in practice.\n\n<pre>{@code\nStream.of().map(entry -> abort(\"assumption not met\"));\n}</pre>\n\n@param message the message to be included in the {@code TestAbortedException}\n@throws TestAbortedException always\n@since 5.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/SupportsOverwrite.java",
    "type": "method",
    "name": "canOverwrite",
    "code": "default boolean canOverwrite(Predicate[] predicates) {\n    Filter[] v1Filters = PredicateUtils.toV1(predicates);\n    if (v1Filters.length < predicates.length) return false;\n    return this.canOverwrite(v1Filters);\n  }",
    "comment": "Configures a write to replace data matching the filters with data committed in the write.\n<p>\nRows must be deleted from the data source if and only if all of the filters match. That is,\nfilters must be interpreted as ANDed together.\n\n@param filters filters used to match data to overwrite\n@return this write builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTimeout",
    "code": "public static <T> T assertTimeout(Duration timeout, ThrowingSupplier<T> supplier) {\n\t\treturn AssertTimeout.assertTimeout(timeout, supplier);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code supplier}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>If the assertion passes then the {@code supplier}'s result is returned.\n\n<p>Note: the {@code supplier} will be executed in the same thread as that\nof the calling code. Consequently, execution of the {@code supplier} will\nnot be preemptively aborted if the timeout is exceeded.\n\n@see #assertTimeout(Duration, Executable)\n@see #assertTimeout(Duration, Executable, String)\n@see #assertTimeout(Duration, Executable, Supplier)\n@see #assertTimeout(Duration, ThrowingSupplier, String)\n@see #assertTimeout(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeoutPreemptively(Duration, Executable)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isNotPrivate",
    "code": "public static boolean isNotPrivate(Class<?> clazz) {\n\t\treturn ReflectionUtils.isNotPrivate(clazz);\n\t}",
    "comment": "Determine if the supplied class is not {@code private}.\n\n<p>In other words this method will return {@code true} for classes\ndeclared as {@code public}, {@code protected}, or\n<em>package private</em> and {@code false} for classes declared as\n{@code private}.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is not {@code private}\n@see java.lang.reflect.Modifier#isPublic(int)\n@see java.lang.reflect.Modifier#isProtected(int)\n@see java.lang.reflect.Modifier#isPrivate(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/logging/ProjectBuildLogAppender.java",
    "type": "method",
    "name": "getProjectId",
    "code": "public static String getProjectId() {\n        return PROJECT_ID.get();\n    }",
    "comment": "Forwards log messages to the client."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelProblemUtils.java",
    "type": "method",
    "name": "toSourceHint",
    "code": "static String toSourceHint(Model model) {\n        if (model == null) {\n            return \"\";\n        }\n\n        StringBuilder buffer = new StringBuilder(128);\n\n        buffer.append(toId(model));\n\n        File pomFile = model.getPomFile();\n        if (pomFile != null) {\n            buffer.append(\" (\").append(pomFile).append(')');\n        }\n\n        return buffer.toString();\n    }",
    "comment": "Creates a user-friendly source hint for the specified model.\n\n@param model The model to create a source hint for, may be {@code null}.\n@return The user-friendly source hint, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(String message, boolean condition) {\n        if (!condition) {\n            fail(message);\n        }\n    }",
    "comment": "Asserts that a condition is true. If it isn't it throws an\n{@link AssertionError} with the given message.\n\n@param message the identifying message for the {@link AssertionError} (<code>null</code>\nokay)\n@param condition condition to be checked"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room2/java/com/example/android/persistence/migrations/UsersDatabase.java",
    "type": "method",
    "name": "Migration",
    "code": "static final Migration MIGRATION_2_3 = new Migration(2, 3) {\n    };",
    "comment": "Migrate from:\nversion 2 - using Room\nto\nversion 3 - using Room where the {@link User} has an extra field: date"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "build",
    "code": "public XmlNode build() {\n            return new Impl(prefix, namespaceUri, name, value, attributes, children, inputLocation);\n        }",
    "comment": "Builds a new XmlNode instance with the current builder settings.\n\n@return a new immutable XmlNode instance\n@throws NullPointerException if name has not been set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, double actual, double delta) {\n        assertEquals(null, expected, actual, delta);\n    }",
    "comment": "Asserts that two doubles are equal concerning a delta. If the expected\nvalue is infinity then the delta value is ignored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/money/src/test/java/com/iluwater/money/MoneyTest.java",
    "type": "method",
    "name": "testExchangeCurrency",
    "code": "void testExchangeCurrency() {\n    Money money = new Money(100.00, \"USD\");\n\n    money.exchangeCurrency(\"EUR\", 0.85);\n\n    assertEquals(\"EUR\", money.getCurrency(), \"Currency after conversion should be EUR\");\n    assertEquals(85.00, money.getAmount(), \"Amount after conversion should be 85.00\");\n  }",
    "comment": "Test converting currency using an exchange rate"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/EngineDiscoveryResult.java",
    "type": "method",
    "name": "failed",
    "code": "public static EngineDiscoveryResult failed(Throwable throwable) {\n\t\treturn new EngineDiscoveryResult(Status.FAILED, throwable);\n\t}",
    "comment": "Create a {@code EngineDiscoveryResult} for a <em>failed</em> test\ndiscovery.\n\n@param throwable the throwable that caused the failed discovery; may be\n{@code null}\n@return the {@code EngineDiscoveryResult}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/lazy/DecoratingIterator.java",
    "type": "method",
    "name": "next",
    "code": "public final E next() {\n    if (next == null) {\n      return fromIterator.next();\n    } else {\n      final var result = next;\n      next = null;\n      return result;\n    }\n  }",
    "comment": "Returns the next element of the Iterable.\n\n@return the next element of the Iterable, or null if not present."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenBaseLogger.java",
    "type": "method",
    "name": "if",
    "code": "Level level, List<Marker> markers, String messagePattern, Object[] arguments, Throwable t) {\n\n        StringBuilder buf = new StringBuilder(32);\n\n        if (CONFIG_PARAMS.showDateTime) {\n            DateTimeFormatter formatter = CONFIG_PARAMS.dateFormatter;\n            if (formatter != null) {\n                ZonedDateTime zonedDateTime = MonotonicClock.now().atZone(ZoneId.systemDefault());\n                String dateText = formatter.format(zonedDateTime);\n                buf.append(dateText);\n                buf.append(SP);\n            } else {\n                buf.append(MonotonicClock.elapsed().toMillis());\n                buf.append(SP);\n            }\n        }\n\n        if (CONFIG_PARAMS.showThreadName) {\n            buf.append('[');\n            buf.append(Thread.currentThread().getName());\n            buf.append(\"] \");\n        }\n\n        if (CONFIG_PARAMS.showThreadId) {\n            buf.append(TID_PREFIX);\n            buf.append(Thread.currentThread().getId());\n            buf.append(SP);\n        }\n\n        if (CONFIG_PARAMS.levelInBrackets) {\n            buf.append('[');\n        }\n\n        String levelStr = renderLevel(level.toInt());\n        buf.append(levelStr);\n        if (CONFIG_PARAMS.levelInBrackets) {\n            buf.append(']');\n        }\n        buf.append(SP);\n\n        if (CONFIG_PARAMS.showShortLogName) {\n            if (shortLogName == null) {\n                shortLogName = computeShortName();\n            }\n            buf.append(shortLogName).append(\" - \");\n        } else if (CONFIG_PARAMS.showLogName) {\n            buf.append(name).append(\" - \");\n        }\n\n        if (markers != null) {\n            buf.append(SP);\n            for (Marker marker : markers) {\n                buf.append(marker.getName()).append(SP);\n            }\n        }\n\n        String formattedMessage = MessageFormatter.basicArrayFormat(messagePattern, arguments);\n\n        buf.append(formattedMessage);\n\n        write(buf, t);\n    }",
    "comment": "Append date-time if so configured\nAppend current thread name if so configured\nAppend a readable representation of the log level\nAppend the name of the log instance if so configured\nAppend the message"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Byte expected, byte actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Byte) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "withDMax",
    "code": "public Builder withDMax(int dMax) {\n            this.dMax = dMax;\n            return this;\n        }",
    "comment": "Use the given {@code dmax} value when announcing metrics.\n\n@param dMax the desired gmond {@code dmax} value\n@return {@code this}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/extensions/RandomNumberExtension.java",
    "type": "method",
    "name": "beforeAll",
    "code": "public void beforeAll(ExtensionContext context) {\n\t\tClass<?> testClass = context.getRequiredTestClass();\n\t\tinjectFields(testClass, null, ModifierSupport::isStatic);\n\t}",
    "comment": "Inject a random integer into static fields that are annotated with\n{@code @Random} and can be assigned an integer value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-expression/src/main/java/org/apache/maven/plugin/coreit/ExpressionUtil.java",
    "type": "method",
    "name": "getProperty",
    "code": "static Object getProperty(Object context, String property) {\n        Object value;\n\n        Class type = context.getClass();\n        if (context instanceof Collection) {\n            type = Collection.class;\n        } else if (context instanceof Map) {\n            type = Map.class;\n        }\n\n        try {\n            try {\n                Method method = type.getMethod(property, NO_PARAMS);\n                method.setAccessible(true);\n                value = method.invoke(context, NO_ARGS);\n            } catch (NoSuchMethodException e) {\n                try {\n                    String name = \"get\" + Character.toUpperCase(property.charAt(0)) + property.substring(1);\n                    Method method = type.getMethod(name, NO_PARAMS);\n                    method.setAccessible(true);\n                    value = method.invoke(context, NO_ARGS);\n                } catch (NoSuchMethodException e1) {\n                    try {\n                        String name = \"is\" + Character.toUpperCase(property.charAt(0)) + property.substring(1);\n                        Method method = type.getMethod(name, NO_PARAMS);\n                        method.setAccessible(true);\n                        value = method.invoke(context, NO_ARGS);\n                    } catch (NoSuchMethodException e2) {\n                        try {\n                            Method method;\n                            try {\n                                method = type.getMethod(\"get\", STRING_PARAM);\n                            } catch (NoSuchMethodException e3) {\n                                method = type.getMethod(\"get\", OBJECT_PARAM);\n                            }\n                            method.setAccessible(true);\n                            value = method.invoke(context, new Object[] {property});\n                            try {\n                                Field field = type.getField(property);\n                                field.setAccessible(true);\n                                value = field.get(context);\n                            } catch (NoSuchFieldException e4) {\n                                if (\"length\".equals(property) && type.isArray()) {\n                                    value = Array.getLength(context);\n                                } else {\n                                    throw e4;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            value = null;\n        }\n        return value;\n    }",
    "comment": "Gets the value of a (public) bean property from the specified object.\n\n@param context  The object whose bean property should be retrieved, must not be <code>null</code>.\n@param property The name of the bean property, must not be <code>null</code>.\n@return The value of the bean property or <code>null</code> if the property does not exist."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/AssertionsDemo.java",
    "type": "method",
    "name": "timeoutExceeded",
    "code": "void timeoutExceeded() {\n\t\tassertTimeout(ofMillis(10), () -> {\n\t\t\tThread.sleep(100);\n\t\t});\n\t}",
    "comment": "end::user_guide[]\ntag::user_guide[]\nThe following assertion fails with an error message similar to:\nexecution exceeded timeout of 10 ms by 91 ms\nSimulate task that takes more than 10 ms."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(short unexpected, short actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedRleValuesReader.java",
    "type": "method",
    "name": "init",
    "code": "private void init(int bitWidth) {\n    Preconditions.checkArgument(bitWidth >= 0 && bitWidth <= 32, \"bitWidth must be >= 0 and <= 32\");\n    this.bitWidth = bitWidth;\n    this.bytesWidth = BytesUtils.paddedByteCountFromBits(bitWidth);\n    this.packer = Packer.LITTLE_ENDIAN.newBytePacker(bitWidth);\n  }",
    "comment": "Initializes the internal state for decoding ints of `bitWidth`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Integer unexpected, int actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Integer) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/map-reduce/src/main/java/com/iluwatar/MapReduce.java",
    "type": "method",
    "name": "mapReduce",
    "code": "public static List<Map.Entry<String, Integer>> mapReduce(List<String> inputs) {\n    List<Map<String, Integer>> mapped = new ArrayList<>();\n    for (String input : inputs) {\n      mapped.add(Mapper.map(input));\n    }\n\n    Map<String, List<Integer>> grouped = Shuffler.shuffleAndSort(mapped);\n\n    return Reducer.reduce(grouped);\n  }",
    "comment": "Executes the MapReduce process on the given list of input strings.\n\n@param inputs List of input strings to be processed.\n@return A list of word counts sorted in descending order."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotSame",
    "code": "public static void assertNotSame(Object unexpected, Object actual, String message) {\n\t\tAssertNotSame.assertNotSame(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that the {@code unexpected} object and the {@code actual}\nobject are not the same object.\n<p>This method should only be used to compare the <em>identity</em> of two\nobjects. To assert that two objects or two primitive values are not\n<em>equal</em>, use one of the {@code assertNotEquals(...)} methods instead.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/kafka-0-10/src/test/java/org/apache/spark/streaming/kafka010/JavaKafkaRDDSuite.java",
    "type": "method",
    "name": "createTopicAndSendData",
    "code": "private  String[] createTopicAndSendData(String topic) {\n    String[] data = { topic + \"-1\", topic + \"-2\", topic + \"-3\"};\n    kafkaTestUtils.createTopic(topic);\n    kafkaTestUtils.sendMessages(topic, data);\n    return data;\n  }",
    "comment": "just making sure the java user APIs work; the scala tests handle logic corner cases"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/pool/ProxyLeakTaskFactory.java",
    "type": "method",
    "name": "scheduleNewTask",
    "code": "private ProxyLeakTask scheduleNewTask(PoolEntry poolEntry) {\n      var task = new ProxyLeakTask(poolEntry);\n      task.schedule(executorService, leakDetectionThreshold);\n\n      return task;\n   }",
    "comment": "A factory for {@link ProxyLeakTask} Runnables that are scheduled in the future to report leaks.\n\n@author Brett Wooldridge\n@author Andreas Brenk"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/DefaultResource.java",
    "type": "method",
    "name": "DefaultResource",
    "code": "public DefaultResource(String name, URI uri) {\n\t\tthis.name = Preconditions.notNull(name, \"name must not be null\");\n\t\tthis.uri = Preconditions.notNull(uri, \"uri must not be null\");\n\t}",
    "comment": "<h2>DISCLAIMER</h2>\n\n<p>These utilities are intended solely for usage within the JUnit framework\nitself. <strong>Any usage by external parties is not supported.</strong>\nUse at your own risk!\n\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java",
    "type": "method",
    "name": "instancePerMethodWithNestedTestClass",
    "code": "void instancePerMethodWithNestedTestClass() {\n\t\tClass<?> testClass = InstancePerMethodOuterTestCase.class;\n\t\tClass<?> nestedTestClass = InstancePerMethodOuterTestCase.NestedInstancePerMethodTestCase.class;\n\t\tint containers = 4;\n\t\tint tests = 4;\n\t\tMap.Entry<Class<?>, Integer>[] instances = instanceCounts(entry(testClass, 4), entry(nestedTestClass, 3));\n\t\tint allMethods = 1;\n\t\tint eachMethods = 3;\n\n\t\tperformAssertions(testClass, containers, tests, instances, allMethods, eachMethods);\n\n\t\tString containerExecutionConditionKey = executionConditionKey(testClass, null);\n\t\tString nestedContainerExecutionConditionKey = executionConditionKey(nestedTestClass, null);\n\t\tString nestedTestTemplateKey = testTemplateKey(nestedTestClass, \"singletonTest\");\n\t\tString postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);\n\t\tString nestedPostProcessTestInstanceKey = postProcessTestInstanceKey(nestedTestClass);\n\t\tString preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);\n\t\tString nestedPreDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(nestedTestClass);\n\t\tString beforeAllCallbackKey = beforeAllCallbackKey(testClass);\n\t\tString afterAllCallbackKey = afterAllCallbackKey(testClass);\n\t\tString outerTestExecutionConditionKey = executionConditionKey(testClass, \"outerTest\");\n\t\tString beforeEachCallbackKey = beforeEachCallbackKey(testClass, \"outerTest\");\n\t\tString afterEachCallbackKey = afterEachCallbackKey(testClass, \"outerTest\");\n\t\tString nestedBeforeAllCallbackKey = beforeAllCallbackKey(nestedTestClass);\n\t\tString nestedAfterAllCallbackKey = afterAllCallbackKey(nestedTestClass);\n\t\tString nestedExecutionConditionKey1 = executionConditionKey(nestedTestClass, testsInvoked.getFirst());\n\t\tString nestedBeforeEachCallbackKey1 = beforeEachCallbackKey(nestedTestClass, testsInvoked.get(0));\n\t\tString nestedAfterEachCallbackKey1 = afterEachCallbackKey(nestedTestClass, testsInvoked.get(0));\n\t\tString nestedExecutionConditionKey2 = executionConditionKey(nestedTestClass, testsInvoked.get(1));\n\t\tString nestedBeforeEachCallbackKey2 = beforeEachCallbackKey(nestedTestClass, testsInvoked.get(1));\n\t\tString nestedAfterEachCallbackKey2 = afterEachCallbackKey(nestedTestClass, testsInvoked.get(1));\n\t\tString nestedExecutionConditionKey3 = executionConditionKey(nestedTestClass, testsInvoked.get(2));\n\t\tString nestedBeforeEachCallbackKey3 = beforeEachCallbackKey(nestedTestClass, testsInvoked.get(2));\n\t\tString nestedAfterEachCallbackKey3 = afterEachCallbackKey(nestedTestClass, testsInvoked.get(2));\n\n\t\tassertThat(instanceMap.keySet()).containsExactlyInAnyOrder(\n\t\t\t\tcontainerExecutionConditionKey,\n\t\t\t\tnestedTestTemplateKey,\n\t\t\t\tnestedContainerExecutionConditionKey,\n\t\t\t\tpostProcessTestInstanceKey,\n\t\t\t\tnestedPostProcessTestInstanceKey,\n\t\t\t\tpreDestroyCallbackTestInstanceKey,\n\t\t\t\tnestedPreDestroyCallbackTestInstanceKey,\n\t\t\t\tbeforeAllCallbackKey,\n\t\t\t\tafterAllCallbackKey,\n\t\t\t\touterTestExecutionConditionKey,\n\t\t\t\tbeforeEachCallbackKey,\n\t\t\t\tafterEachCallbackKey,\n\t\t\t\tnestedBeforeAllCallbackKey,\n\t\t\t\tnestedAfterAllCallbackKey,\n\t\t\t\tnestedExecutionConditionKey1,\n\t\t\t\tnestedBeforeEachCallbackKey1,\n\t\t\t\tnestedAfterEachCallbackKey1,\n\t\t\t\tnestedExecutionConditionKey2,\n\t\t\t\tnestedBeforeEachCallbackKey2,\n\t\t\t\tnestedAfterEachCallbackKey2,\n\t\t\t\tnestedExecutionConditionKey3,\n\t\t\t\tnestedBeforeEachCallbackKey3,\n\t\t\t\tnestedAfterEachCallbackKey3\n\t\t);\n\n\t\tassertNull(instanceMap.get(containerExecutionConditionKey));\n\t\tassertNull(instanceMap.get(beforeAllCallbackKey));\n\t\tassertNull(instanceMap.get(afterAllCallbackKey));\n\t\tassertNull(instanceMap.get(nestedContainerExecutionConditionKey));\n\t\tassertNull(instanceMap.get(nestedBeforeAllCallbackKey));\n\t\tassertNull(instanceMap.get(nestedAfterAllCallbackKey));\n\n\t\tTestInstances outerInstances = instanceMap.get(beforeEachCallbackKey);\n\t\tassertNotNull(outerInstances.getInnermostInstance());\n\t\tassertSame(outerInstances, instanceMap.get(afterEachCallbackKey));\n\t\tassertSame(outerInstances, instanceMap.get(outerTestExecutionConditionKey));\n\n\t\tTestInstances nestedInstances1 = instanceMap.get(nestedBeforeEachCallbackKey1);\n\t\tassertNotNull(nestedInstances1.getInnermostInstance());\n\t\tassertNotSame(outerInstances.getInnermostInstance(), nestedInstances1.getInnermostInstance());\n\t\tassertSame(nestedInstances1, instanceMap.get(nestedAfterEachCallbackKey1));\n\t\tassertSame(nestedInstances1, instanceMap.get(nestedExecutionConditionKey1));\n\n\t\tTestInstances nestedInstances2 = instanceMap.get(nestedBeforeEachCallbackKey2);\n\t\tassertNotNull(nestedInstances2.getInnermostInstance());\n\t\tassertNotSame(outerInstances.getInnermostInstance(), nestedInstances2.getInnermostInstance());\n\t\tassertNotSame(nestedInstances1.getInnermostInstance(), nestedInstances2.getInnermostInstance());\n\t\tassertSame(nestedInstances2, instanceMap.get(nestedAfterEachCallbackKey2));\n\t\tassertSame(nestedInstances2, instanceMap.get(nestedExecutionConditionKey2));\n\n\t\tTestInstances nestedInstances3 = instanceMap.get(nestedPostProcessTestInstanceKey);\n\t\tassertNotNull(nestedInstances3.getInnermostInstance());\n\t\tassertNotSame(outerInstances.getInnermostInstance(), nestedInstances3.getInnermostInstance());\n\t\tassertNotSame(nestedInstances1.getInnermostInstance(), nestedInstances3.getInnermostInstance());\n\t\tassertSame(nestedInstances3.getInnermostInstance(),\n\t\t\tinstanceMap.get(nestedAfterEachCallbackKey3).getInnermostInstance());\n\t\tassertSame(nestedInstances3.getInnermostInstance(),\n\t\t\tinstanceMap.get(nestedExecutionConditionKey3).getInnermostInstance());\n\t\tassertSame(nestedInstances3.getInnermostInstance(),\n\t\t\tinstanceMap.get(nestedPreDestroyCallbackTestInstanceKey).getInnermostInstance());\n\n\t\tObject outerInstance1 = instanceMap.get(nestedExecutionConditionKey1).findInstance(testClass).get();\n\t\tObject outerInstance2 = instanceMap.get(nestedExecutionConditionKey2).findInstance(testClass).get();\n\t\tObject outerInstance3 = instanceMap.get(nestedExecutionConditionKey3).findInstance(testClass).get();\n\t\tassertNotSame(outerInstance1, outerInstance2);\n\t\tassertNotSame(outerInstance1, outerInstance3);\n\t\tassertThat(instanceMap.get(nestedExecutionConditionKey1).getAllInstances()).containsExactly(outerInstance1,\n\t\t\tnestedInstances1.getInnermostInstance());\n\t\tassertThat(instanceMap.get(nestedExecutionConditionKey2).getAllInstances()).containsExactly(outerInstance2,\n\t\t\tnestedInstances2.getInnermostInstance());\n\t\tassertThat(instanceMap.get(nestedExecutionConditionKey3).getAllInstances()).containsExactly(outerInstance3,\n\t\t\tnestedInstances3.getInnermostInstance());\n\n\t\tassertSame(outerInstance3, instanceMap.get(postProcessTestInstanceKey).getInnermostInstance());\n\n\t\tassertThat(lifecyclesMap.keySet()).containsExactly(testClass, nestedTestClass);\n\t\tassertThat(lifecyclesMap.get(testClass).stream()).allMatch(Lifecycle.PER_METHOD::equals);\n\t\tassertThat(lifecyclesMap.get(nestedTestClass).stream()).allMatch(Lifecycle.PER_METHOD::equals);\n\t}",
    "comment": "@formatter:off\n@formatter:on\nThe last tracked instance stored under postProcessTestInstanceKey\nis only created in order to instantiate the nested test class for\ntest2()."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/main/java/com/example/android/observability/ui/UserViewModel.java",
    "type": "method",
    "name": "UserViewModel",
    "code": "public UserViewModel(UserDataSource dataSource) {\n        mDataSource = dataSource;\n    }",
    "comment": "View Model for the {@link UserActivity}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyBag.java",
    "type": "method",
    "name": "create",
    "code": "public static IMoney create(IMoney m1, IMoney m2) {\n        MoneyBag result = new MoneyBag();\n        m1.appendTo(result);\n        m2.appendTo(result);\n        return result.simplify();\n    }",
    "comment": "A MoneyBag defers exchange rate conversions. For example adding\n12 Swiss Francs to 14 US Dollars is represented as a bag\ncontaining the two Monies 12 CHF and 14 USD. Adding another\n10 Swiss francs gives a bag with 22 CHF and 14 USD. Due to\nthe deferred exchange rate conversion we can later value a\nMoneyBag with different exchange rates.\n\nA MoneyBag is represented as a list of Monies and provides\ndifferent constructors to create a MoneyBag."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "redirectError",
    "code": "public SparkLauncher redirectError(ProcessBuilder.Redirect to) {\n    errorStream = to;\n    return this;\n  }",
    "comment": "Redirects error output to the specified Redirect.\n\n@param to The method of redirection.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "reset",
    "code": "public void reset() {\n    if (isConstant || isAllNull) return;\n\n    if (childColumns != null) {\n      for (WritableColumnVector c: childColumns) {\n        c.reset();\n      }\n    }\n    elementsAppended = 0;\n    if (numNulls > 0) {\n      putNotNulls(0, capacity);\n      numNulls = 0;\n    }\n\n    if (hugeVectorThreshold > -1 && capacity > hugeVectorThreshold) {\n      capacity = defaultCapacity;\n      releaseMemory();\n      reserveInternal(capacity);\n    }\n  }",
    "comment": "Resets this column for writing. The currently stored values are no longer accessible."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<String> create(Scope scope, byte[] data) {\n    return create(scope, data, String.class);\n  }",
    "comment": "Creates a constant containing a single {@code String} element, represented as an array of {@code byte}s.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-access-object/src/test/java/com/iluwatar/dao/AppTest.java",
    "type": "method",
    "name": "shouldExecuteDaoWithoutException",
    "code": "void shouldExecuteDaoWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/ClockSource.java",
    "type": "method",
    "name": "toMillis",
    "code": "static long toMillis(long time) {\n      return CLOCK.toMillis0(time);\n   }",
    "comment": "Convert an opaque time-stamp returned by currentTime() into\nmilliseconds.\n\n@param time an opaque time-stamp returned by an instance of this class\n@return the time-stamp in milliseconds"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "splitIntoTwo",
    "code": "public static TwoPartSplitResult splitIntoTwo(char separator, String value) {\n\t\tPreconditions.notNull(value, \"value must not be null\");\n\t\treturn splitIntoTwo(value, value.indexOf(separator), 1);\n\t}",
    "comment": "Split the supplied {@link String} into up to two parts using the supplied\nseparator character.\n\n@param separator the separator character\n@param value the value to split; never {@code null}\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/runner/ResultTest.java",
    "type": "method",
    "name": "ResultWithFixedRunTime",
    "code": "public ResultWithFixedRunTime(Result delegate) {\n            this.delegate = delegate;\n        }",
    "comment": "A version of {@code Result} that returns a hard-coded runtime.\nThis makes values returned by the methods deterministic."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/auth/HttpAuthUtils.java",
    "type": "method",
    "name": "createCookieToken",
    "code": "public static String createCookieToken(String clientUserName) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(COOKIE_CLIENT_USER_NAME).append(COOKIE_KEY_VALUE_SEPARATOR).append(clientUserName)\n      .append(COOKIE_ATTR_SEPARATOR);\n    sb.append(COOKIE_CLIENT_RAND_NUMBER).append(COOKIE_KEY_VALUE_SEPARATOR)\n      .append(random.nextLong());\n    return sb.toString();\n  }",
    "comment": "Creates and returns a HS2 cookie token.\n@param clientUserName Client User name.\n@return An unsigned cookie token generated from input parameters.\nThe final cookie generated is of the following format :\n{@code cu=<username>&rn=<randomNumber>&s=<cookieSignature>}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "applicationRemoved",
    "code": "public void applicationRemoved(String appId, boolean cleanupLocalDirs) {\n    logger.info(\"Application {} removed, cleanupLocalDirs = {}\",\n      MDC.of(LogKeys.APP_ID$.MODULE$, appId),\n      MDC.of(LogKeys.CLEANUP_LOCAL_DIRS$.MODULE$, cleanupLocalDirs));\n    AtomicReference<AppShuffleInfo> ref = new AtomicReference<>(null);\n    appsShuffleInfo.compute(appId, (id, info) -> {\n      if (null != info) {\n        removeAppAttemptPathInfoFromDB(info.appId, info.attemptId);\n        removeOldApplicationAttemptsFromDb(info);\n        ref.set(info);\n      }\n      return null;\n    });\n    AppShuffleInfo appShuffleInfo = ref.get();\n    if (null != appShuffleInfo) {\n      submitCleanupTask(\n        () -> closeAndDeletePartitionsIfNeeded(appShuffleInfo, cleanupLocalDirs));\n    }\n  }",
    "comment": "Cleanup the DB within critical section to gain the consistency between\nDB and in-memory hashmap.\nTry cleaning up this application attempt local paths information\nand also the local paths information from former attempts in DB.\nReturn null to remove the entry"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "feed",
    "code": "public Runner feed(String operation, int index, Tensor<?> t) {\n      Operation op = operationByName(operation);\n      if (op != null) {\n        inputs.add(op.output(index));\n        inputTensors.add(t);\n      }\n      return this;\n    }",
    "comment": "Avoid evaluating the {@code index}-th output of {@code operation} by substituting {@code t}\nfor the value it produces.\n\n<p>Operations in a {@link Graph} can have multiple outputs, {@code index} identifies which\none {@code t} is being provided for."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/testhelper/java/org/tensorflow/lite/TestHelper.java",
    "type": "method",
    "name": "getOutputDataType",
    "code": "public static String getOutputDataType(Interpreter interpreter, int index) {\n    if (interpreter != null && interpreter.wrapper != null) {\n      return DataTypeUtils.toStringName(interpreter.wrapper.getOutputTensor(index).dataType());\n    } else {\n      throw new IllegalArgumentException(\n          \"Interpreter has not initialized;\" + \" Failed to get output data type.\");\n    }\n  }",
    "comment": "Gets the string name of the data type of an output.\n\n@param interpreter an instance of {@code Interpreter}. If it is not initialized, an {@code\nIllegalArgumentException} will be thrown.\n@param index an integer index of the output. If it is invalid, an {@code\nIllegalArgumentException} will be thrown.\n@return string name of the data type. Possible values include \"float\", \"int\", \"byte\", and\n\"long\"."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/plugin/DefaultPluginConfigurationExpander.java",
    "type": "method",
    "name": "expandPluginConfiguration",
    "code": "public void expandPluginConfiguration(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\n        Build build = model.getBuild();\n\n        if (build != null) {\n            expand(build.getPlugins());\n\n            PluginManagement pluginManagement = build.getPluginManagement();\n\n            if (pluginManagement != null) {\n                expand(pluginManagement.getPlugins());\n            }\n        }\n    }",
    "comment": "Handles expansion of general build plugin configuration into individual executions.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ResourceUtils.java",
    "type": "method",
    "name": "stripQueryComponent",
    "code": "public static URI stripQueryComponent(URI uri) {\n\t\tPreconditions.notNull(uri, \"URI must not be null\");\n\n\t\tif (StringUtils.isBlank(uri.getQuery())) {\n\t\t\treturn uri;\n\t\t}\n\n\t\tString uriAsString = uri.toString();\n\t\treturn URI.create(uriAsString.substring(0, uriAsString.indexOf('?')));\n\t}",
    "comment": "Strip the {@link URI#getQuery() query} component from the supplied\n{@link URI}.\n\n@param uri the {@code URI} from which to strip the query component\n@return a new {@code URI} with the query component removed, or the\n\n@since 1.3"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/ByteArray.java",
    "type": "method",
    "name": "concatWS",
    "code": "public static byte[] concatWS(byte[] delimiter, byte[]... inputs) {\n    if (delimiter == null) {\n      return null;\n    }\n    // Compute the total length of the result\n    long totalLength = 0;\n    for (byte[] input : inputs) {\n      if (input != null) {\n        totalLength += input.length + delimiter.length;\n      } else {\n        return null;\n      }\n    }\n    if (totalLength > 0) totalLength -= delimiter.length;\n    // Allocate a new byte array, and copy the inputs one by one into it\n    final byte[] result = new byte[Ints.checkedCast(totalLength)];\n    int offset = 0;\n    for (int i = 0; i < inputs.length; i++) {\n      byte[] input = inputs[i];\n      int len = input.length;\n      Platform.copyMemory(\n        input, Platform.BYTE_ARRAY_OFFSET,\n        result, Platform.BYTE_ARRAY_OFFSET + offset,\n        len);\n      offset += len;\n      if (delimiter.length > 0 && i < inputs.length - 1) {\n        Platform.copyMemory(\n          delimiter, Platform.BYTE_ARRAY_OFFSET,\n          result, Platform.BYTE_ARRAY_OFFSET + offset,\n          delimiter.length);\n        offset += delimiter.length;\n      }\n    }\n    return result;\n  }",
    "comment": "Concatenate multiple byte arrays with a given delimiter.\nIf the delimiter or one of the inputs is null then null will be returned.\n\n@param delimiter byte array to be placed between each input\n@param inputs    byte arrays to concatenate\n@return the concatenated byte array or null if one of the arguments is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenFailOnSeverityLogger.java",
    "type": "method",
    "name": "error",
    "code": "public void error(String msg) {\n        super.error(msg);\n        logLevelRecorder.record(Level.ERROR);\n    }",
    "comment": "A simple implementation which always logs messages of level ERROR\naccording to the format outlined above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4348NoUnnecessaryRepositoryAccessTest.java",
    "type": "method",
    "name": "AbstractHandler",
    "code": "Handler repoHandler = new AbstractHandler() {\n\n                response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n\n                ((Request) request).setHandled(true);\n            }",
    "comment": "Test that the (remote) repos are not accessed during execution of a mojo that does not require dependency\nresolution. In detail, Maven should neither touch POMs, JARs nor metadata.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "setPropertiesFile",
    "code": "public T setPropertiesFile(String path) {\n    checkNotNull(path, \"path\");\n    builder.setPropertiesFile(path);\n    return self();\n  }",
    "comment": "Set a custom properties file with Spark configuration for the application.\n\n@param path Path to custom properties file to use.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuildingResult.java",
    "type": "method",
    "name": "addModelId",
    "code": "public DefaultModelBuildingResult addModelId(String modelId) {\n        Objects.requireNonNull(modelId, \"modelId cannot null\");\n\n        modelIds.add(modelId);\n\n        return this;\n    }",
    "comment": "Intentionally notNull because Super POM may not contain a modelId"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/ChildFirstURLClassLoader.java",
    "type": "method",
    "name": "ChildFirstURLClassLoader",
    "code": "public ChildFirstURLClassLoader(URL[] urls, ClassLoader parent, ClassLoader grandparent) {\n    super(urls, grandparent);\n    this.parent = new ParentClassLoader(parent);\n  }",
    "comment": "Specify the grandparent if there is a need to load in the order of\n`grandparent -&gt; urls (child) -&gt; parent`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/test/java/org/apache/spark/sql/catalyst/expressions/XXH64Suite.java",
    "type": "method",
    "name": "randomizedStressTest",
    "code": "public void randomizedStressTest() {\n    int size = 65536;\n    Random rand = new Random();\n\n    Set<Long> hashcodes = new HashSet<>();\n    for (int i = 0; i < size; i++) {\n      int vint = rand.nextInt();\n      long lint = rand.nextLong();\n      Assertions.assertEquals(hasher.hashInt(vint), hasher.hashInt(vint));\n      Assertions.assertEquals(hasher.hashLong(lint), hasher.hashLong(lint));\n\n      hashcodes.add(hasher.hashLong(lint));\n    }\n\n    Assertions.assertTrue(hashcodes.size() > size * 0.95d);\n  }",
    "comment": "A set used to track collision rate.\nA very loose bound."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3811ReportingPluginConfigurationInheritanceTest.java",
    "type": "method",
    "name": "MavenITmng3811ReportingPluginConfigurationInheritanceTest",
    "code": "public MavenITmng3811ReportingPluginConfigurationInheritanceTest() {\n        // TODO: fix for 3.0+\n        super(\"[2.0.11,2.1.0-M1),[2.1.0,)\");\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3811\">MNG-3811</a>.\n\n@author Brett Porter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java",
    "type": "method",
    "name": "compareTo",
    "code": "public int compareTo(Item item) {\n            if (item == null) {\n                return comparableQualifier(value).compareTo(RELEASE_VERSION_INDEX);\n            }\n            switch (item.getType()) {\n                case INT_ITEM:\n                case LONG_ITEM:\n                case BIGINTEGER_ITEM:\n                    return -1; // 1.any < 1.1 ?\n\n                case STRING_ITEM:\n                    return comparableQualifier(value).compareTo(comparableQualifier(((StringItem) item).value));\n\n                case COMBINATION_ITEM:\n                    int result = this.compareTo(((CombinationItem) item).getStringPart());\n                    if (result == 0) {\n                        return -1;\n                    }\n                    return result;\n\n                case LIST_ITEM:\n                    return -1; // 1.any < 1-1\n\n                default:\n                    throw new IllegalStateException(\"invalid item: \" + item.getClass());\n            }\n        }",
    "comment": "1-rc < 1, 1-ga > 1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/assertion/ComparisonFailureTest.java",
    "type": "method",
    "name": "data",
    "code": "public static Collection<Object[]> data() {\n\t\treturn Arrays.asList(new Object[][] {\n\t\t\t\t\n\t\t\t{ \"ba\", \"bc\", \"expected:<b[a]> but was:<b[c]>\" },\n\t\t\t\t\n\t\t\t{ \"ab\", \"cb\", \"expected:<[a]b> but was:<[c]b>\" },\n\t\t\t\t\n\t\t\t{ \"abc\", \"adc\", \"expected:<a[b]c> but was:<a[d]c>\" },\n\t\t\t\n\t\t\t{ \"ab\", \"abc\", \"expected:<ab[]> but was:<ab[c]>\" },\n\n\t\t\t{ \"abc\", \"ab\", \"expected:<ab[c]> but was:<ab[]>\" },\n\t\t\t\n\t\t\t{ \"abc\", \"abbc\", \"expected:<ab[]c> but was:<ab[b]c>\" },\n\n\t\t\t{ \"01234567890123456789PRE:hello:POST\", \n\t\t\t\t\"01234567890123456789PRE:world:POST\",\n\t\t\t\t\"expected:<...4567890123456789PRE:[hello]:POST> but was:<...4567890123456789PRE:[world]:POST>\" },\n\t\t\t\t\t\n\t\t\t{ \"PRE:hello:01234567890123456789POST\",\n\t\t\t\t\"PRE:world:01234567890123456789POST\",\n\t\t\t\t\"expected:<PRE:[hello]:0123456789012345678...> but was:<PRE:[world]:0123456789012345678...>\"\t\n\t\t\t},\n\t\t\t\t\t\n\t\t\t{ \"S&P500\", \"0\", \"expected:<[S&P50]0> but was:<[]0>\" },\n\t\t\t\n\t\t\t{ \"\", \"a\", \"expected:<[]> but was:<[a]>\" },\n\n\t\t\t{ \"a\", \"\", \"expected:<[a]> but was:<[]>\" }\n\n\t\t});\t\n\t}",
    "comment": "common prefix\ncommon suffix\ncommon pre and suffix\nexpected is subset of actual\nexpected is superset of actual\noverlapping matches.\nlong prefix yielding \"...\"\nlong suffix\tyielding \"...\"\nbug609972\nempty expected string\nempty actual string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/StringModelSource.java",
    "type": "method",
    "name": "StringModelSource",
    "code": "public StringModelSource(CharSequence pom, String location) {\n        super(pom, location);\n    }",
    "comment": "Creates a new model source backed by the specified string.\n\n@param pom The POM's string representation, may be empty or {@code null}.\n@param location The location to report for this use, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/session/HiveSessionImpl.java",
    "type": "method",
    "name": "release",
    "code": "protected synchronized void release(boolean userAccess) {\n    SessionState.detachSession();\n    if (ThreadWithGarbageCleanup.currentThread() instanceof ThreadWithGarbageCleanup) {\n      ThreadWithGarbageCleanup currentThread =\n          (ThreadWithGarbageCleanup) ThreadWithGarbageCleanup.currentThread();\n      currentThread.cacheThreadLocalRawStore();\n    }\n    if (userAccess) {\n      lastAccessTime = System.currentTimeMillis();\n    }\n    if (opHandleSet.isEmpty()) {\n      lastIdleTime = System.currentTimeMillis();\n    } else {\n      lastIdleTime = 0;\n    }\n  }",
    "comment": "1. We'll remove the ThreadLocal SessionState as this thread might now serve\nother requests.\n2. We'll cache the ThreadLocal RawStore object for this background thread for an orderly cleanup\nwhen this thread is garbage collected later.\n@see org.apache.hive.service.server.ThreadWithGarbageCleanup#finalize()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/DefaultMavenExecutionRequestPopulator.java",
    "type": "method",
    "name": "DefaultMavenExecutionRequestPopulator",
    "code": "public DefaultMavenExecutionRequestPopulator(MavenRepositorySystem repositorySystem) {\n        this.repositorySystem = repositorySystem;\n    }",
    "comment": "Assists in populating an execution request for invocation of Maven."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/session-facade/src/main/java/com/iluwatar/sessionfacade/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    ShoppingFacade shoppingFacade = new ShoppingFacade();\n\n    // Adding items to the shopping cart\n    shoppingFacade.addToCart(1);\n    shoppingFacade.addToCart(2);\n\n    // Processing the payment with the chosen method\n    shoppingFacade.processPayment(\"cash\");\n\n    // Finalizing the order\n    shoppingFacade.order();\n  }",
    "comment": "The entry point of the application. This method demonstrates how the ShoppingFacade, acting as\na Session Facade, is used to: - Add items to the shopping cart - Process a payment - Place the\norder The session facade manages the communication between the individual services and\nsimplifies the interactions for the client.\n\n@param args the input arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/plugin/testing/MojoExtension.java",
    "type": "method",
    "name": "getTestId",
    "code": "public static String getTestId() {\n        return context.getRequiredTestClass().getSimpleName() + \"-\"\n                + context.getRequiredTestMethod().getName();\n    }",
    "comment": "Gets the identifier for the current test method.\nThe format is \"TestClassName-testMethodName\".\n\n@return the test identifier"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/CustomHealthIndicatorTest.java",
    "type": "method",
    "name": "cacheManager",
    "code": "public CacheManager cacheManager() {\n      return new ConcurrentMapCacheManager(\"health-check\");\n    }",
    "comment": "Creates a concurrent map cache manager named \"health-check\".\n\n@return a new ConcurrentMapCacheManager instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnsh/CommonsCliShellOptions.java",
    "type": "method",
    "name": "CommonsCliShellOptions",
    "code": "protected CommonsCliShellOptions(String source, CLIManager cliManager, CommandLine commandLine) {\n        super(source, cliManager, commandLine);\n    }",
    "comment": "Implementation of {@link ShellOptions} (base + shell)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelBuilder.java",
    "type": "method",
    "name": "readParent",
    "code": "Model readParent(Model childModel, DefaultProfileActivationContext profileActivationContext) {\n            Model parentModel;\n\n            Parent parent = childModel.getParent();\n            if (parent != null) {\n                parentModel = resolveParent(childModel, profileActivationContext);\n\n                if (!\"pom\".equals(parentModel.getPackaging())) {\n                    add(\n                            Severity.ERROR,\n                            Version.BASE,\n                            \"Invalid packaging for parent POM \" + ModelProblemUtils.toSourceHint(parentModel)\n                                    + \", must be \\\"pom\\\" but is \\\"\" + parentModel.getPackaging() + \"\\\"\",\n                            parentModel.getLocation(\"packaging\"));\n                }\n                result.setParentModel(parentModel);\n            } else {\n                String superModelVersion = childModel.getModelVersion();\n                if (superModelVersion == null || !VALID_MODEL_VERSIONS.contains(superModelVersion)) {\n                    superModelVersion = MODEL_VERSION_4_0_0;\n                }\n                parentModel = getSuperModel(superModelVersion);\n            }\n\n            return parentModel;\n        }",
    "comment": "Maven 3.x is always using 4.0.0 version to load the supermodel, so\ndo the same when loading a dependency.  The model validator will also\ncheck that field later."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaLDAExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    // Creates a SparkSession\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaLDAExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Loads data.\n    Dataset<Row> dataset = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_lda_libsvm_data.txt\");\n\n    // Trains a LDA model.\n    LDA lda = new LDA().setK(10).setMaxIter(10);\n    LDAModel model = lda.fit(dataset);\n\n    double ll = model.logLikelihood(dataset);\n    double lp = model.logPerplexity(dataset);\n    System.out.println(\"The lower bound on the log likelihood of the entire corpus: \" + ll);\n    System.out.println(\"The upper bound on perplexity: \" + lp);\n\n    // Describe topics.\n    Dataset<Row> topics = model.describeTopics(3);\n    System.out.println(\"The topics described by their top-weighted terms:\");\n    topics.show(false);\n\n    // Shows the result.\n    Dataset<Row> transformed = model.transform(dataset);\n    transformed.show(false);\n    // $example off$\n\n    spark.stop();\n  }",
    "comment": "An example demonstrating LDA.\nRun with\n<pre>\nbin/run-example ml.JavaLDAExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "keyPassword",
    "code": "public Builder keyPassword(String keyPassword) {\n      this.keyPassword = keyPassword;\n      return this;\n    }",
    "comment": "Sets the key password\n\n@param keyPassword The password for the private key in the key store\n@return The builder object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/hexagonal-architecture/src/main/java/com/iluwatar/hexagonal/database/MongoTicketRepository.java",
    "type": "method",
    "name": "getNextId",
    "code": "public int getNextId() {\n    var find = new Document(\"_id\", TICKET_ID);\n    var increase = new Document(\"seq\", 1);\n    var update = new Document(\"$inc\", increase);\n    var result = countersCollection.findOneAndUpdate(find, update);\n    return result.getInteger(\"seq\");\n  }",
    "comment": "Get next ticket id.\n\n@return next ticket id"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/auth/HttpAuthUtils.java",
    "type": "method",
    "name": "HttpKerberosClientAction",
    "code": "public HttpKerberosClientAction(String serverPrincipal, String serverHttpUrl) {\n      this.serverPrincipal = serverPrincipal;\n      this.serverHttpUrl = serverHttpUrl;\n      base64codec = new Base64(0);\n      httpContext = new BasicHttpContext();\n      httpContext.setAttribute(SERVER_HTTP_URL, serverHttpUrl);\n    }",
    "comment": "We'll create an instance of this class within a doAs block so that the client's TGT credentials\ncan be read from the Subject"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLCli.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"Java Spark SQL Cli\")\n      .getOrCreate();\n\n    for (String a: args) {\n      spark.sql(a).show(false);\n    }\n\n    spark.stop();\n  }",
    "comment": "Example Usage:\n<pre>\nbin/run-example sql.JavaSparkSQLCli \"SELECT 'Spark SQL' col\"\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/filter/Or.java",
    "type": "method",
    "name": "Or",
    "code": "public Or(Predicate left, Predicate right) {\n    super(\"OR\", new Predicate[]{left, right});\n\n  public Predicate left() { return (Predicate) children()[0]; }\n  public Predicate right() { return (Predicate) children()[1]; }\n}",
    "comment": "A predicate that evaluates to {@code true} iff at least one of {@code left} or {@code right}\nevaluates to {@code true}.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/DefaultExtensionRealmCache.java",
    "type": "method",
    "name": "register",
    "code": "public void register(MavenProject project, Key key, CacheRecord record) {\n    }",
    "comment": "default cache does not track extension usage"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/ExecutionRequest.java",
    "type": "method",
    "name": "getStore",
    "code": "public NamespacedHierarchicalStore<Namespace> getStore() {\n\t\treturn Preconditions.notNull(this.requestLevelStore,\n\t\t\t\"No NamespacedHierarchicalStore was configured for this request\");\n\t}",
    "comment": "{@return the {@link NamespacedHierarchicalStore} for this request for\nstoring request-scoped data}\n\n<p>All stored values that implement {@link AutoCloseable} are notified by\ninvoking their {@code close()} methods when this request has been\nexecuted.\n\n@since 1.13\n@see NamespacedHierarchicalStore"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "createSuiteDescription",
    "code": "public static Description createSuiteDescription(Class<?> testClass) {\n        return new Description(testClass, testClass.getName(), testClass.getAnnotations());\n    }",
    "comment": "Create a <code>Description</code> named after <code>testClass</code>\n\n@param testClass A {@link Class} containing tests\n@return a <code>Description</code> of <code>testClass</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/CaseInsensitiveStringMap.java",
    "type": "method",
    "name": "asCaseSensitiveMap",
    "code": "public Map<String, String> asCaseSensitiveMap() {\n    return Collections.unmodifiableMap(original);\n  }",
    "comment": "Returns the original case-sensitive map."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/metadata/DefaultGraphConflictResolver.java",
    "type": "method",
    "name": "visit",
    "code": "private void visit(MetadataGraphVertex from, List<MetadataGraphVertex> visited, MetadataGraph graph) {\n        if (visited.contains(from)) {\n            return;\n        }\n\n        visited.add(from);\n\n        List<MetadataGraphEdge> exitList = graph.getExcidentEdges(from);\n        if (exitList != null && exitList.size() > 0) {\n            for (MetadataGraphEdge e : graph.getExcidentEdges(from)) {\n                visit(e.getTarget(), visited, graph);\n            }\n        }\n    }",
    "comment": "-------------------------------------------------------------------------------------\nString s = \"|---> \"+from.getMd().toString()+\" - \"+(exitList == null ? -1 : exitList.size()) + \" exit links\";"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNull",
    "code": "public static void assertNull(Object actual) {\n\t\tAssertNull.assertNull(actual);\n\t}",
    "comment": "<em>Assert</em> that {@code actual} is {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedRleValuesReader.java",
    "type": "method",
    "name": "switch",
    "code": "return switch (bytesWidth) {\n      case 0 -> 0;\n      case 1 -> in.read();\n      case 2 -> {\n        int ch2 = in.read();\n        int ch1 = in.read();\n        yield (ch1 << 8) + ch2;\n      }\n      case 3 -> {\n        int ch3 = in.read();\n        int ch2 = in.read();\n        int ch1 = in.read();\n        yield (ch1 << 16) + (ch2 << 8) + (ch3 << 0);\n      }\n      case 4 -> readIntLittleEndian();\n      default -> throw new RuntimeException(\"Unreachable\");\n    };",
    "comment": "Reads the next byteWidth little endian int."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room3/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "UserRepository",
    "code": "public UserRepository(AppExecutors appExecutors, UserDataSource userDataSource) {\n        mAppExecutors = appExecutors;\n        mUserDataSource = userDataSource;\n    }",
    "comment": "The repository is responsible of handling user data operations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/aether/ReverseTreeRepositoryListener.java",
    "type": "method",
    "name": "isLocalRepositoryArtifactOrMissing",
    "code": "static boolean isLocalRepositoryArtifactOrMissing(RepositorySystemSession session, Artifact artifact) {\n        return artifact.getFile() == null\n                || artifact.getFile()\n                        .getPath()\n                        .startsWith(session.getLocalRepository().getBasedir().getPath());\n    }",
    "comment": "Returns {@code true} if passed in artifact is originating from local repository. In other words, we want\nto process and store tracking information ONLY into local repository, not to any other place. This method\nfilters out currently built artifacts, as events are fired for them as well, but their resolved artifact\nfile would point to checked out source-tree, not the local repository.\n<p>\nVisible for testing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/resources/mng-7967-artifact-handler-language/src/main/java/org/apache/maven/its/mng7967/Sample.java",
    "type": "method",
    "name": "helloWorld",
    "code": "public String helloWorld(String who) {\n        return \"Hello!\";\n    }",
    "comment": "Hello world method, with intentionally broken javadoc, the params are off.\n\n@param where The where is not where but who, is here to fail Javadoc.\n@return The \"Hello\" string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(boolean condition) {\n\t\tAssertFalse.assertFalse(condition);\n\t}",
    "comment": "<em>Assert</em> that the supplied {@code condition} is {@code false}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/BypassMergeSortShuffleWriter.java",
    "type": "method",
    "name": "stop",
    "code": "public Option<MapStatus> stop(boolean success) {\n    if (stopping) {\n      return None$.empty();\n    } else {\n      stopping = true;\n      if (success) {\n        if (mapStatus == null) {\n          throw new IllegalStateException(\"Cannot call stop(true) without having called write()\");\n        }\n        return Option.apply(mapStatus);\n      } else {\n        if (partitionWriters != null) {\n          try {\n            for (DiskBlockObjectWriter writer : partitionWriters) {\n              writer.closeAndDelete();\n            }\n          } finally {\n            partitionWriters = null;\n          }\n        }\n        return None$.empty();\n      }\n    }\n  }",
    "comment": "The map task failed, so delete our output data.\nThis method explicitly does _not_ throw exceptions:"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng2695OfflinePluginSnapshotsTest.java",
    "type": "method",
    "name": "MavenITmng2695OfflinePluginSnapshotsTest",
    "code": "public MavenITmng2695OfflinePluginSnapshotsTest() {\n        super(\"(2.0.9,2.1.0-M1),(2.1.0-M1,)\"); // only test in 2.0.10+, and not in 2.1.0-M1\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-2695\">MNG-2695</a>.\n\nVerifies that offline mode functions correctly for snapshot plugins.\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TestWatcher.java",
    "type": "method",
    "name": "apply",
    "code": "public Statement apply(final Statement base, final Description description) {\n        return new Statement() {\n                    errors.add(e);\n                    skippedQuietly(e, description, errors);\n                } catch (Throwable e) {\n                    errors.add(e);\n                    failedQuietly(e, description, errors);\n                } finally {\n                    finishedQuietly(description, errors);\n                }\n\n                MultipleFailureException.assertEmpty(errors);\n            }",
    "comment": "TestWatcher is a base class for Rules that take note of the testing\naction, without modifying it. For example, this class will keep a log of each\npassing and failing test:\n\n<pre>\npublic static class WatchmanTest {\nprivate static String watchedLog;\n\n&#064;Rule(order = Integer.MIN_VALUE)\npublic TestWatcher watchman= new TestWatcher() {\n\n&#064;Override\nprotected void succeeded(Description description) {\nwatchedLog+= description + &quot; &quot; + &quot;success!\\n&quot;;\n}\n};\n\n&#064;Test\npublic void fails() {\nfail();\n}\n\n&#064;Test\npublic void succeeds() {\n}\n}\n</pre>\n<p>It is recommended to always set the {@link Rule#order() order} of the\n{@code TestWatcher} to {@code Integer.MIN_VALUE} so that it encloses all\nother rules. Otherwise it may see failed tests as successful and vice versa\nif some rule changes the result of a test (e.g. {@link ErrorCollector} or\n{@link ExpectedException}).\n\n@since 4.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeArrayWriter.java",
    "type": "method",
    "name": "setNull1Bytes",
    "code": "public void setNull1Bytes(int ordinal) {\n    setNullBit(ordinal);\n    writeByte(getElementOffset(ordinal), (byte)0);\n  }",
    "comment": "put zero into the corresponding field when set null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "runHelper",
    "code": "private Run runHelper(boolean wantMetadata) {\n      long[] inputTensorHandles = new long[inputTensors.size()];\n      long[] inputOpHandles = new long[inputs.size()];\n      int[] inputOpIndices = new int[inputs.size()];\n      long[] outputOpHandles = new long[outputs.size()];\n      int[] outputOpIndices = new int[outputs.size()];\n      long[] targetOpHandles = new long[targets.size()];\n      long[] outputTensorHandles = new long[outputs.size()];\n\n      int idx = 0;\n      for (Tensor<?> t : inputTensors) {\n        inputTensorHandles[idx++] = t.getNativeHandle();\n      }\n      idx = 0;\n      for (Output<?> o : inputs) {\n        inputOpHandles[idx] = o.getUnsafeNativeHandle();\n        inputOpIndices[idx] = o.index();\n        idx++;\n      }\n      idx = 0;\n      for (Output<?> o : outputs) {\n        outputOpHandles[idx] = o.getUnsafeNativeHandle();\n        outputOpIndices[idx] = o.index();\n        idx++;\n      }\n      idx = 0;\n      for (GraphOperation op : targets) {\n        targetOpHandles[idx++] = op.getUnsafeNativeHandle();\n      }\n      Reference runRef = new Reference();\n      byte[] metadata = null;\n      try {\n        metadata =\n            Session.run(\n                nativeHandle,\n                runOptions,\n                inputTensorHandles,\n                inputOpHandles,\n                inputOpIndices,\n                outputOpHandles,\n                outputOpIndices,\n                targetOpHandles,\n                wantMetadata,\n                outputTensorHandles);\n      } finally {\n        runRef.close();\n      }\n      List<Tensor<?>> outputs = new ArrayList<Tensor<?>>();\n      for (long h : outputTensorHandles) {\n        try {\n          outputs.add(Tensor.fromHandle(h));\n        } catch (Exception e) {\n          for (Tensor<?> t : outputs) {\n            t.close();\n          }\n          outputs.clear();\n          throw e;\n        }\n      }\n      Run ret = new Run();\n      ret.outputs = outputs;\n      ret.metadata = metadata;\n      return ret;\n    }",
    "comment": "It's okay to use Operation.getUnsafeNativeHandle() here since the safety depends on the\nvalidity of the Graph and graphRef ensures that."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/Namespace.java",
    "type": "method",
    "name": "create",
    "code": "public static Namespace create(List<Object> objects) {\n\t\tPreconditions.notEmpty(objects, \"objects list must not be null or empty\");\n\t\tPreconditions.containsNoNullElements(objects, \"individual objects must not be null\");\n\t\treturn new Namespace(objects);\n\t}",
    "comment": "Create a namespace which restricts access to data to all extensions\nwhich use the same sequence of {@code objects} for creating a namespace.\n\n<p>The order of the {@code objects} is significant.\n\n<p>Internally the {@code objects} are compared using {@link Object#equals(Object)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/PackageUtils.java",
    "type": "method",
    "name": "getAttribute",
    "code": "public static Optional<String> getAttribute(Class<?> type, String name) {\n\t\tPreconditions.notNull(type, \"type must not be null\");\n\t\tPreconditions.notBlank(name, \"name must not be blank\");\n\t\ttry {\n\t\t\tURL jarUrl = type.getProtectionDomain().getCodeSource().getLocation();\n\t\t\ttry (JarFile jarFile = new JarFile(new File(jarUrl.toURI()))) {\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t}\n\n\t@API(status = INTERNAL, since = \"1.11\")\n\tpublic static Optional<String> getModuleOrImplementationVersion(Class<?> type) {\n\t\tOptional<String> moduleVersion = ModuleUtils.getModuleVersion(type);\n\t\tif (moduleVersion.isPresent()) {\n\t\t\treturn moduleVersion;\n\t\t}\n\t\treturn getAttribute(type, Package::getImplementationVersion);\n\t}\n\n}",
    "comment": "Get the module or implementation version for the supplied {@code type}.\n\n<p>The former is only available if the type is part of a versioned module\non the module path; the latter only if the type is part of a JAR file with\na manifest that contains an {@code Implementation-Version} attribute.\n\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java",
    "type": "method",
    "name": "withLookingForStuckThread",
    "code": "public Builder withLookingForStuckThread(boolean enable) {\n            this.lookForStuckThread = enable;\n            return this;\n        }",
    "comment": "Specifies whether to look for a stuck thread.  If a timeout occurs and this\nfeature is enabled, the test will look for a thread that appears to be stuck\nand dump its backtrace.  This feature is experimental.  Behavior may change\nafter the 4.12 release in response to feedback.\n\n@param enable {@code true} to enable the feature\n@return {@code this} for method chaining."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/memory/MemoryConsumer.java",
    "type": "method",
    "name": "allocateArray",
    "code": "public LongArray allocateArray(long size) {\n    long required = size * 8L;\n    MemoryBlock page = taskMemoryManager.allocatePage(required, this);\n    if (page == null || page.size() < required) {\n      throwOom(page, required);\n    }\n    used += required;\n    return new LongArray(page);\n  }",
    "comment": "Allocates a LongArray of `size`. Note that this method may throw `SparkOutOfMemoryError`\nif Spark doesn't have enough memory for this allocation, or throw `TooLargePageException`\nif this `LongArray` is too large to fit in a single page. The caller side should take care of\nthese two exceptions, or make sure the `size` is small enough that won't trigger exceptions.\n\n@throws SparkOutOfMemoryError\n@throws TooLargePageException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4026ReactorDependenciesOrderTest.java",
    "type": "method",
    "name": "MavenITmng4026ReactorDependenciesOrderTest",
    "code": "public MavenITmng4026ReactorDependenciesOrderTest() {\n        // This feature depends on MNG-1412\n        super(\"(2.0.8,)\");\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-4026\">MNG-4026</a>.\n\n@author Benjamin Bentmann"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelProcessor.java",
    "type": "method",
    "name": "DefaultModelProcessor",
    "code": "public DefaultModelProcessor(ModelXmlFactory modelXmlFactory, @Nullable List<ModelParser> modelParsers) {\n        this.modelXmlFactory = modelXmlFactory;\n        this.modelParsers = modelParsers;\n    }",
    "comment": "Note: uses @Typed to limit the types it is available for injection to just ModelProcessor.\n\nThis is because the ModelProcessor interface extends ModelLocator and ModelReader. If we\nmade this component available under all its interfaces then it could end up being injected\ninto itself leading to a stack overflow.\n\nA side effect of using @Typed is that it translates to explicit bindings in the container.\nSo instead of binding the component under a 'wildcard' key it is now bound with an explicit\nkey. Since this is a default component; this will be a plain binding of ModelProcessor to\nthis implementation type; that is, no hint/name.\n\nThis leads to a second side effect in that any @Inject request for just ModelProcessor in\nthe same injector is immediately matched to this explicit binding, which means extensions\ncannot override this binding. This is because the lookup is always short-circuited in this\nspecific situation (plain @Inject request, and plain explicit binding for the same type.)\n\nThe simplest solution is to use a custom @Named here so it isn't bound under the plain key.\nThis is only necessary for default components using @Typed that want to support overriding.\n\nAs a non-default component this now gets a negative priority relative to other implementations\nof the same interface. Since we want to allow overriding this doesn't matter in this case.\n(if it did we could add @Priority of 0 to match the priority given to default components.)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, long expected, long actual) {\n        if (expected != actual) {\n            failNotEquals(message, Long.valueOf(expected), Long.valueOf(actual));\n        }\n    }",
    "comment": "Asserts that two longs are equal. If they are not, an\n{@link AssertionError} is thrown with the given message.\n\n@param message the identifying message for the {@link AssertionError} (<code>null</code>\nokay)\n@param expected long expected value.\n@param actual long actual value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/filterer/src/main/java/com/iluwatar/filterer/App.java",
    "type": "method",
    "name": "filteringSimpleThreats",
    "code": "private static void filteringSimpleThreats() {\n    LOGGER.info(\"### Filtering ThreatAwareSystem by ThreatType ###\");\n\n    var rootkit = new SimpleThreat(ThreatType.ROOTKIT, 1, \"Simple-Rootkit\");\n    var trojan = new SimpleThreat(ThreatType.TROJAN, 2, \"Simple-Trojan\");\n    List<Threat> threats = List.of(rootkit, trojan);\n\n    var threatAwareSystem = new SimpleThreatAwareSystem(\"Sys-1\", threats);\n\n    LOGGER.info(\"Filtering ThreatAwareSystem. Initial : \" + threatAwareSystem);\n\n    // Filtering using Filterer\n    var rootkitThreatAwareSystem =\n        threatAwareSystem.filtered().by(threat -> threat.type() == ThreatType.ROOTKIT);\n\n    LOGGER.info(\"Filtered by threatType = ROOTKIT : \" + rootkitThreatAwareSystem);\n  }",
    "comment": "Demonstrates how to filter {@link ThreatAwareSystem} based on startingOffset property of {@link\nSimpleThreat}. The @{@link com.iluwatar.filterer.domain.Filterer#by(Predicate)} method is able\nto use {@link Threat} as predicate argument."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/NameScope.java",
    "type": "method",
    "name": "withName",
    "code": "NameScope withName(String name) {\n    checkPattern(NAME_REGEX, name);\n    return new NameScope(opPrefix, name, ids);\n  }",
    "comment": "All context except for the opName is shared with the new scope."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/MethodRoadie.java",
    "type": "method",
    "name": "MethodRoadie",
    "code": "public MethodRoadie(Object test, TestMethod method, RunNotifier notifier, Description description) {\n        this.test = test;\n        this.notifier = notifier;\n        this.description = description;\n        testMethod = method;\n    }",
    "comment": "@deprecated Included for backwards compatibility with JUnit 4.4. Will be\nremoved in the next major release. Please use\n{@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/MemoryHealthIndicatorTest.java",
    "type": "method",
    "name": "whenMemoryUsageIsBelowThreshold_thenHealthIsUp",
    "code": "void whenMemoryUsageIsBelowThreshold_thenHealthIsUp() {\n    // Arrange\n    CompletableFuture<Health> future =\n        CompletableFuture.completedFuture(\n            Health.up().withDetail(\"memory usage\", \"50% of max\").build());\n    when(asynchronousHealthChecker.performCheck(any(Supplier.class), anyLong())).thenReturn(future);\n\n    // Act\n    Health health = memoryHealthIndicator.health();\n\n    // Assert\n    assertEquals(Status.UP, health.getStatus());\n    assertEquals(\"50% of max\", health.getDetails().get(\"memory usage\"));\n  }",
    "comment": "Test case for the `health()` method when memory usage is below the threshold.\n\n<p>Asserts that when the `health()` method is called and memory usage is below the threshold,\nit returns a Health object with Status.UP."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "setExecutionPreference",
    "code": "public Options setExecutionPreference(int preference) {\n      this.executionPreference = preference;\n      return this;\n    }",
    "comment": "Sets the inference preference for precision/compilation/runtime tradeoffs.\n\n@param preference One of EXECUTION_PREFERENCE_LOW_POWER,\nEXECUTION_PREFERENCE_FAST_SINGLE_ANSWER, or EXECUTION_PREFERENCE_SUSTAINED_SPEED."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Double unexpected, double actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Double) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Float unexpected, Float actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/parameter-object/src/test/java/com/iluwatar/parameter/object/ParameterObjectTest.java",
    "type": "method",
    "name": "testForDefaultSortOrder",
    "code": "void testForDefaultSortOrder() {\n    ParameterObject params =\n        ParameterObject.newBuilder().withType(\"sneakers\").sortBy(\"brand\").build();\n\n    assertEquals(\n        ParameterObject.DEFAULT_SORT_ORDER, params.getSortOrder(), \"Default SortOrder is not set.\");\n    LOGGER.info(\n        \"{} Default parameter value is set during object creation as no value is passed.\",\n        \"SortOrder\");\n  }",
    "comment": "Creating parameter object with default value for SortOrder set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/util/Os.java",
    "type": "method",
    "name": "isFamily",
    "code": "public static boolean isFamily(String family) {\n        return isFamily(family, OS_NAME);\n    }",
    "comment": "Determines if the OS on which Maven is executing matches the\ngiven OS family.\n\n@param family the family to check for\n@return true if the OS matches"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/Utility.java",
    "type": "method",
    "name": "characterFrequency",
    "code": "public static Map<Character, Long> characterFrequency(String fileLocation) {\n    try (var bufferedReader = new BufferedReader(new FileReader(fileLocation))) {\n      LOGGER.error(\"An error occurred: \", ex);\n    }\n    return Collections.emptyMap();\n  }",
    "comment": "Calculates character frequency of the file provided.\n\n@param fileLocation location of the file.\n@return a map of character to its frequency, an empty map if file does not exist."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/version-number/src/test/java/com/iluwatar/versionnumber/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/SupportsNamespaces.java",
    "type": "method",
    "name": "namespaceExists",
    "code": "default boolean namespaceExists(String[] namespace) {\n    try {\n      loadNamespaceMetadata(namespace);\n      return true;\n    } catch (NoSuchNamespaceException e) {\n      return false;\n    }\n  }",
    "comment": "Test whether a namespace exists.\n<p>\nIf an object such as a table, view, or function exists, its parent namespaces must also exist.\nFor example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\nnamespaceExists([\"a\", \"b\"]) must return true.\n\n@param namespace a multi-part namespace\n@return true if the namespace exists, false otherwise"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(double unexpected, double actual, double delta) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, delta);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal\nwithin the given {@code delta}.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createStructField",
    "code": "public static StructField createStructField(String name, DataType dataType, boolean nullable) {\n    return createStructField(name, dataType, nullable, (new MetadataBuilder()).build());\n  }",
    "comment": "Creates a StructField with empty metadata.\n\n@see #createStructField(String, DataType, boolean, Metadata)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3747PrefixedPathExpressionTest.java",
    "type": "method",
    "name": "MavenITmng3747PrefixedPathExpressionTest",
    "code": "public MavenITmng3747PrefixedPathExpressionTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3747\">MNG-3747</a>.\n\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/rules/RuleMemberValidator.java",
    "type": "method",
    "name": "validate",
    "code": "public void validate(FrameworkMember<?> member, Class<? extends Annotation> annotation, List<Throwable> errors) {\n            if (!member.isPublic()) {\n                errors.add(new ValidationError(member, annotation,\n                        \"must be public.\"));\n            }\n        }",
    "comment": "Requires the member to be public"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/manipulation/ComparatorBasedOrdering.java",
    "type": "method",
    "name": "ComparatorBasedOrdering",
    "code": "protected ComparatorBasedOrdering(Comparator<Description> comparator) {\n        this.comparator = comparator;\n    }",
    "comment": "An ordering that internally uses a {@link Comparator}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java",
    "type": "method",
    "name": "runCsvDatasetExample",
    "code": "private static void runCsvDatasetExample(SparkSession spark) {\n    String path = \"examples/src/main/resources/people.csv\";\n\n    Dataset<Row> df = spark.read().csv(path);\n    df.show();\n\n    Dataset<Row> df2 = spark.read().option(\"delimiter\", \";\").csv(path);\n    df2.show();\n\n    Dataset<Row> df3 = spark.read().option(\"delimiter\", \";\").option(\"header\", \"true\").csv(path);\n    df3.show();\n\n    java.util.Map<String, String> optionsMap = new java.util.HashMap<String, String>();\n    optionsMap.put(\"delimiter\",\";\");\n    optionsMap.put(\"header\",\"true\");\n    Dataset<Row> df4 = spark.read().options(optionsMap).csv(path);\n\n    df3.write().csv(\"output\");\n\n    String folderPath = \"examples/src/main/resources\";\n    Dataset<Row> df5 = spark.read().csv(folderPath);\n    df5.show();\n\n  }",
    "comment": "$example on:csv_dataset$\nA CSV dataset is pointed to by path.\nThe path can be either a single CSV file or a directory of CSV files\n+------------------+\n|               _c0|\n+------------------+\n|      name;age;job|\n|Jorge;30;Developer|\n|  Bob;32;Developer|\n+------------------+\nRead a csv with delimiter, the default delimiter is \",\"\n+-----+---+---------+\n|  _c0|_c1|      _c2|\n+-----+---+---------+\n| name|age|      job|\n|Jorge| 30|Developer|\n|  Bob| 32|Developer|\n+-----+---+---------+\nRead a csv with delimiter and a header\n+-----+---+---------+\n| name|age|      job|\n+-----+---+---------+\n|Jorge| 30|Developer|\n|  Bob| 32|Developer|\n+-----+---+---------+\nYou can also use options() to use multiple options\n\"output\" is a folder which contains multiple csv files and a _SUCCESS file.\nRead all files in a folder, please make sure only CSV files should present in the folder.\nWrong schema because non-CSV files are read\n+-----------+\n|        _c0|\n+-----------+\n|238val_238|\n|  86val_86|\n|311val_311|\n|  27val_27|\n|165val_165|\n+-----------+\n$example off:csv_dataset$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ModuleUtilsTests.java",
    "type": "method",
    "name": "isJavaPlatformModuleSystemAvailable",
    "code": "void isJavaPlatformModuleSystemAvailable() {\n\t\tboolean expected;\n\t\ttry {\n\t\t\tClass.forName(\"java.lang.Module\");\n\t\t\texpected = true;\n\t\t}\n\t\tcatch (ClassNotFoundException e) {\n\t\t\texpected = false;\n\t\t}\n\t\tassertEquals(expected, ModuleUtils.isJavaPlatformModuleSystemAvailable());\n\t}",
    "comment": "Unit tests for {@link ModuleUtils}.\n\n@since 1.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/running/core/SystemExitTest.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n            System.exit(EXIT_CODE);\n        }",
    "comment": "Make sure System.exit works as expected. We've had problems with this on some platforms."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/RocksDBTypeInfo.java",
    "type": "method",
    "name": "toKey",
    "code": "byte[] toKey(Object value, byte prefix) {\n      final byte[] result;\n\n      if (value instanceof String str) {\n        byte[] bytes = str.getBytes(UTF_8);\n        result = new byte[bytes.length + 1];\n        result[0] = prefix;\n        System.arraycopy(bytes, 0, result, 1, bytes.length);\n      } else if (value instanceof Boolean bool) {\n        result = new byte[] { prefix, bool ? TRUE : FALSE };\n        int length = Array.getLength(value);\n        byte[][] components = new byte[length][];\n        for (int i = 0; i < length; i++) {\n          components[i] = toKey(Array.get(value, i));\n        }\n        result = buildKey(false, components);\n      } else {\n        int bytes;\n\n        if (value instanceof Integer) {\n          bytes = Integer.SIZE;\n        } else if (value instanceof Long) {\n          bytes = Long.SIZE;\n        } else if (value instanceof Short) {\n          bytes = Short.SIZE;\n        } else if (value instanceof Byte) {\n          bytes = Byte.SIZE;\n        } else {\n          throw new IllegalArgumentException(String.format(\"Type %s not allowed as key.\",\n            value.getClass().getName()));\n        }\n\n        bytes = bytes / Byte.SIZE;\n\n        byte[] key = new byte[bytes * 2 + 2];\n        long longValue = ((Number) value).longValue();\n        key[0] = prefix;\n        key[1] = longValue >= 0 ? POSITIVE_MARKER : NEGATIVE_MARKER;\n\n        for (int i = 0; i < key.length - 2; i++) {\n          int masked = (int) ((longValue >>> (4 * i)) & 0xF);\n          key[key.length - i - 1] = HEX_BYTES[masked];\n        }\n\n        result = key;\n      }\n\n      return result;\n    }",
    "comment": "Translates a value to be used as part of the store key.\n\nIntegral numbers are encoded as a string in a way that preserves lexicographical\nordering. The string is prepended with a marker telling whether the number is negative\nor positive (\"*\" for negative and \"=\" for positive are used since \"-\" and \"+\" have the\nopposite of the desired order), and then the number is encoded into a hex string (so\nit occupies twice the number of bytes as the original type).\n\nArrays are encoded by encoding each element separately, separated by KEY_SEPARATOR."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/ring/RingMessageManager.java",
    "type": "method",
    "name": "sendLeaderMessage",
    "code": "public boolean sendLeaderMessage(int currentId, int leaderId) {\n    var nextInstance = this.findNextInstance(currentId);\n    var leaderMessage = new Message(MessageType.LEADER, String.valueOf(leaderId));\n    nextInstance.onMessage(leaderMessage);\n    return true;\n  }",
    "comment": "Send leader message to the next instance.\n\n@param currentId Instance ID of which sends this message.\n@param leaderId Leader message content.\n@return {@code true} if the leader message is accepted by the target instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaModelSelectionViaTrainValidationSplitExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaModelSelectionViaTrainValidationSplitExample\")\n      .getOrCreate();\n\n    // $example on$\n    Dataset<Row> data = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_linear_regression_data.txt\");\n\n    // Prepare training and test data.\n    Dataset<Row>[] splits = data.randomSplit(new double[] {0.9, 0.1}, 12345);\n      .addGrid(lr.regParam(), new double[] {0.1, 0.01})\n      .addGrid(lr.elasticNetParam(), new double[] {0.0, 0.5, 1.0})\n}",
    "comment": "Java example demonstrating model selection using TrainValidationSplit.\n\nRun with\n{{{\nbin/run-example ml.JavaModelSelectionViaTrainValidationSplitExample\n}}}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/distributions/Distributions.java",
    "type": "method",
    "name": "clustered",
    "code": "public static ClusteredDistribution clustered(Expression[] clustering) {\n    return LogicalDistributions.clustered(clustering);\n  }",
    "comment": "Creates a distribution where tuples that share the same values for clustering expressions are\nco-located in the same partition."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/InMemoryStore.java",
    "type": "method",
    "name": "getMetadata",
    "code": "public <T> T getMetadata(Class<T> klass) {\n    return klass.cast(metadata);\n  }",
    "comment": "Implementation of KVStore that keeps data deserialized in memory. This store does not index\ndata; instead, whenever iterating over an indexed field, the stored data is copied and sorted\naccording to the index. This saves memory but makes iteration more expensive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/NameScope.java",
    "type": "method",
    "name": "makeUnique",
    "code": "private String makeUnique(String id) {\n    if (!ids.containsKey(id)) {\n      ids.put(id, 1);\n      return id;\n    } else {\n      int cur = ids.get(id);\n      ids.put(id, cur + 1);\n      return String.format(\"%s_%d\", id, cur);\n    }\n  }",
    "comment": "Generate a unique name, different from existing ids.\n\nids is a map from id to integer, representing a counter of the\nnumber of previous requests to generate a unique name for the\ngiven id.\n\nFor instance, the first use of makeUnique(\"a\") adds \"a\" -> 1\nto ids and returns \"a\".\n\nThe second use of makeUnique(\"a\") updates ids to \"a\" -> 2\nand returns \"a_1\", and so on."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/ModelData.java",
    "type": "method",
    "name": "ModelData",
    "code": "record ModelData(ModelSource source, Model model) {\n\n    public String id() {\n        // TODO: this should be model.getId() but it fails for some reason\n        // if source is null, it is the super model, which can be accessed via empty string\n        return source != null ? source.getLocation() : \"\";\n    }\n\n    @Override\n    public String toString() {\n        return String.valueOf(model);\n    }\n}",
    "comment": "Gets unique identifier of the model\n\n@return The effective identifier of the model, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeSorterSpillWriter.java",
    "type": "method",
    "name": "writeLongToBuffer",
    "code": "private void writeLongToBuffer(long v, int offset) {\n    writeBuffer[offset + 0] = (byte)(v >>> 56);\n    writeBuffer[offset + 1] = (byte)(v >>> 48);\n    writeBuffer[offset + 2] = (byte)(v >>> 40);\n    writeBuffer[offset + 3] = (byte)(v >>> 32);\n    writeBuffer[offset + 4] = (byte)(v >>> 24);\n    writeBuffer[offset + 5] = (byte)(v >>> 16);\n    writeBuffer[offset + 6] = (byte)(v >>>  8);\n    writeBuffer[offset + 7] = (byte)(v >>>  0);\n  }",
    "comment": "The buffer size to use when writing the sorted records to an on-disk file, and\nthis space used by prefix + len + recordLength must be greater than 4 + 8 bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/sasl/ShuffleSecretManager.java",
    "type": "method",
    "name": "registerApp",
    "code": "public void registerApp(String appId, String shuffleSecret) {\n    // Always put the new secret information to make sure it's the most up to date.\n    // Otherwise we have to specifically look at the application attempt in addition\n    // to the applicationId since the secrets change between application attempts on yarn.\n    shuffleSecretMap.put(appId, shuffleSecret);\n    logger.info(\"Registered shuffle secret for application {}\",\n      MDC.of(LogKeys.APP_ID$.MODULE$, appId));\n  }",
    "comment": "Register an application with its secret.\nExecutors need to first authenticate themselves with the same secret before\nfetching shuffle files written by other executors in this application."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaBeanDeserializationSuite.java",
    "type": "method",
    "name": "testSpark22000FailToUpcast",
    "code": "public void testSpark22000FailToUpcast() {\n    List<Row> inputRows = new ArrayList<>();\n    for (long idx = 0 ; idx < 5 ; idx++) {\n      Row row = createRecordSpark22000FailToUpcastRow(idx);\n      inputRows.add(row);\n    }\n\n    Encoder<RecordSpark22000FailToUpcast> encoder =\n            Encoders.bean(RecordSpark22000FailToUpcast.class);\n\n    StructType schema = new StructType().add(\"id\", DataTypes.StringType);\n\n    Dataset<Row> dataFrame = spark.createDataFrame(inputRows, schema);\n\n    AnalysisException e = Assertions.assertThrows(AnalysisException.class,\n      () -> dataFrame.as(encoder).collect());\n    Assertions.assertTrue(e.getMessage().contains(\"Cannot up cast \"));\n  }",
    "comment": "Here we try to convert the fields, from string type to int, which upcast doesn't help."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(char unexpected, Character actual) {\n\t\tAssertNotEquals.assertNotEquals((Character) unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/OrderWithValidator.java",
    "type": "method",
    "name": "validateAnnotatedClass",
    "code": "public List<Exception> validateAnnotatedClass(TestClass testClass) {\n        if (testClass.getAnnotation(FixMethodOrder.class) != null) {\n            return singletonList(\n                    new Exception(\"@FixMethodOrder cannot be combined with @OrderWith\"));\n        }\n        return emptyList();\n    }",
    "comment": "Adds to {@code errors} a throwable for each problem detected. Looks for\n{@code FixMethodOrder} annotations.\n\n@param testClass that is being validated\n@return A list of exceptions detected\n\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/streaming/ContinuousPartitionReaderFactory.java",
    "type": "method",
    "name": "createColumnarReader",
    "code": "default ContinuousPartitionReader<ColumnarBatch> createColumnarReader(InputPartition partition) {\n    throw new SparkUnsupportedOperationException(\"_LEGACY_ERROR_TEMP_3150\");\n  }",
    "comment": "A variation on {@link PartitionReaderFactory} that returns {@link ContinuousPartitionReader}\ninstead of {@link PartitionReader}. It's used for continuous streaming processing.\n\n@since 3.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/FilterResult.java",
    "type": "method",
    "name": "excluded",
    "code": "public static FilterResult excluded(String reason) {\n\t\treturn new FilterResult(false, reason);\n\t}",
    "comment": "Factory for creating <em>excluded</em> results.\n\n@param reason the reason why the filtered object was excluded\n@return an excluded {@code FilterResult} with the given reason"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/NativeLibrary.java",
    "type": "method",
    "name": "getVersionedLibraryName",
    "code": "private static String getVersionedLibraryName(String libFilename) {\n    final String versionName = getMajorVersionNumber();\n\n    final String darwinSuffix = \".dylib\";\n    if (libFilename.endsWith(darwinSuffix)) {\n      final String prefix = libFilename.substring(0, libFilename.length() - darwinSuffix.length());\n      if (versionName != null) {\n        final String darwinVersionedLibrary = prefix + \".\" + versionName + darwinSuffix;\n        if (resourceExists(darwinVersionedLibrary)) {\n          return darwinVersionedLibrary;\n        }\n      } else {\n        final String darwinSoName = prefix + \".so\";\n        if (resourceExists(darwinSoName)) {\n          return darwinSoName;\n        }\n      }\n    } else if (libFilename.endsWith(\".so\")) {\n      final String versionedSoName = libFilename + \".\" + versionName;\n      if (versionName != null && resourceExists(versionedSoName)) {\n        return versionedSoName;\n      }\n    }\n\n    return libFilename;\n  }",
    "comment": "If we're on darwin, the versioned libraries look like blah.1.dylib.\nIf we're here, we're on darwin, but we couldn't figure out the major version number. We\nalready tried the library name without any changes, but let's do one final try for the\nlibrary with a .so suffix.\nLibraries ending in \".so\" are versioned like \"libfoo.so.1\", so try that.\nOtherwise, we've got no idea."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaRandomForestRegressionExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf sparkConf = new SparkConf().setAppName(\"JavaRandomForestRegressionExample\");\n    JavaSparkContext jsc = new JavaSparkContext(sparkConf);\n    String datapath = \"data/mllib/sample_libsvm_data.txt\";\n    JavaRDD<LabeledPoint> data = MLUtils.loadLibSVMFile(jsc.sc(), datapath).toJavaRDD();\n    JavaRDD<LabeledPoint>[] splits = data.randomSplit(new double[]{0.7, 0.3});\n    System.out.println(\"Test Mean Squared Error: \" + testMSE);\n    System.out.println(\"Learned regression forest model:\\n\" + model.toDebugString());\n\n    model.save(jsc.sc(), \"target/tmp/myRandomForestRegressionModel\");\n    RandomForestModel sameModel = RandomForestModel.load(jsc.sc(),\n      \"target/tmp/myRandomForestRegressionModel\");\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file.\nSplit the data into training and test sets (30% held out for testing)\nSave and load model\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(Object[] expected, Object[] actual, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} object arrays are deeply equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Nested float arrays are checked as in {@link #assertEquals(float, float)}.\n<p>Nested double arrays are checked as in {@link #assertEquals(double, double)}.\n<p>Fails with the supplied failure {@code message}.\n\n@see Objects#equals(Object, Object)\n@see Arrays#deepEquals(Object[], Object[])"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/ssl/SslSampleConfigs.java",
    "type": "method",
    "name": "createDefaultConfigMapForRpcNamespace",
    "code": "public static Map<String, String> createDefaultConfigMapForRpcNamespace() {\n    Map<String, String> confMap = new HashMap<String, String>();\n    confMap.put(\"spark.ssl.rpc.enabled\", \"true\");\n    confMap.put(\"spark.ssl.rpc.trustStoreReloadingEnabled\", \"false\");\n    confMap.put(\"spark.ssl.rpc.openSslEnabled\", \"false\");\n    confMap.put(\"spark.ssl.rpc.trustStoreReloadIntervalMs\", \"10000\");\n    confMap.put(\"spark.ssl.rpc.keyStore\", SslSampleConfigs.keyStorePath);\n    confMap.put(\"spark.ssl.rpc.keyStorePassword\", \"password\");\n    confMap.put(\"spark.ssl.rpc.privateKey\", SslSampleConfigs.privateKeyPath);\n    confMap.put(\"spark.ssl.rpc.keyPassword\", \"password\");\n    confMap.put(\"spark.ssl.rpc.privateKeyPassword\", \"password\");\n    confMap.put(\"spark.ssl.rpc.certChain\", SslSampleConfigs.certChainPath);\n    confMap.put(\"spark.ssl.rpc.trustStore\", SslSampleConfigs.trustStorePath);\n    confMap.put(\"spark.ssl.rpc.trustStorePassword\", \"password\");\n    return confMap;\n  }",
    "comment": "Similar to the above, but sets the settings directly in the spark.ssl.rpc namespace\nThis is needed for testing in the lower level modules (like network-common) where inheritance\ndoes not work as there is no access to SSLOptions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Integer> create(int[][][][] data) {\n    return Tensor.create(data, Integer.class);\n  }",
    "comment": "Creates a rank-4 tensor of {@code int} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/bridge/src/test/java/com/iluwatar/bridge/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/ByteUnit.java",
    "type": "method",
    "name": "convertFrom",
    "code": "public long convertFrom(long d, ByteUnit u) {\n    return u.convertTo(d, this);\n  }",
    "comment": "Interpret the provided number (d) with suffix (u) as this unit type.\nE.g. KiB.interpret(1, MiB) interprets 1MiB as its KiB representation = 1024k"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "SSLFactory",
    "code": "private SSLFactory(final Builder b) {\n    this.requestedProtocol = b.requestedProtocol;\n    this.requestedCiphers = b.requestedCiphers;\n    try {\n      if (b.certChain != null && b.privateKey != null) {\n        initNettySslContexts(b);\n      } else {\n        initJdkSslContext(b);\n      }\n    } catch (Exception e) {\n      throw new RuntimeException(\"SSLFactory creation failed\", e);\n    }\n  }",
    "comment": "For a configuration specifying a PEM cert chain, and a PEM private key"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "semanticEquals",
    "code": "public boolean semanticEquals(final UTF8String other, int collationId) {\n    return CollationFactory.fetchCollation(collationId).equalsFunction.apply(this, other);\n  }",
    "comment": "Collation-aware equality comparison of two UTF8String."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-executor/src/main/java/org/apache/maven/api/cli/ExecutorRequest.java",
    "type": "method",
    "name": "mavenBuilder",
    "code": "static Builder mavenBuilder(@Nullable Path installationDirectory) {\n        return new Builder(\n                MVN,\n                null,\n                getCanonicalPath(Paths.get(System.getProperty(\"user.dir\"))),\n                installationDirectory != null\n                        ? getCanonicalPath(installationDirectory)\n                        : discoverInstallationDirectory(),\n                getCanonicalPath(Paths.get(System.getProperty(\"user.home\"))),\n                null,\n                null,\n                null,\n                null,\n                null,\n                null);\n    }",
    "comment": "Returns new builder pre-set to run Maven. The discovery of maven home is attempted, user cwd and home are\nalso discovered by standard means."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/StylizeActivity.java",
    "type": "method",
    "name": "onDraw",
    "code": "public void onDraw(final Canvas canvas) {\n      super.onDraw(canvas);\n      final float y = (1.0f - value) * canvas.getHeight();\n\n      if (!allZero) {\n        canvas.drawRect(0, 0, canvas.getWidth(), y, boxPaint);\n      }\n\n      if (value > 0.0f) {\n        canvas.drawLine(0, y, canvas.getWidth(), y, linePaint);\n      }\n\n      if (hilighted) {\n        canvas.drawRect(0, 0, getWidth(), getHeight(), linePaint);\n      }\n    }",
    "comment": "If all sliders are zero, don't bother shading anything."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room2/java/com/example/android/persistence/migrations/User.java",
    "type": "method",
    "name": "User",
    "code": "public User(String userName) {\n        // DO NOT USE Integer Random values for primary keys.\n        // This is using an Integer to showcase a WRONG implementation that has to be fixed\n        // afterwards by updating the schema.\n        // The ID is updated to a UUID String in the room3 flavor.\n        mId = new Random(Integer.MAX_VALUE).nextInt();\n        mUserName = userName;\n        mDate = new Date(System.currentTimeMillis());\n    }",
    "comment": "Immutable model class for a User and entity in the Room database."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptor.java",
    "type": "method",
    "name": "getGoalPrefixFromArtifactId",
    "code": "public static String getGoalPrefixFromArtifactId(String artifactId) {\n        if (\"maven-plugin-plugin\".equals(artifactId)) {\n            return \"plugin\";\n        } else {\n            return PATTERN_FILTER_1.matcher(artifactId).replaceAll(\"\");\n        }\n    }",
    "comment": "Parse maven-...-plugin.\n\nTODO move to plugin-tools-api as a default only"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/constraints/Constraint.java",
    "type": "method",
    "name": "check",
    "code": "static Check.Builder check(String name) {\n    return new Check.Builder(name);\n  }",
    "comment": "Instantiates a builder for a CHECK constraint.\n\n@param name the constraint name\n@return a CHECK constraint builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/Filter.java",
    "type": "method",
    "name": "composeFilters",
    "code": "static <T> Filter<T> composeFilters(Collection<? extends Filter<T>> filters) {\n\t\tPreconditions.notNull(filters, \"Filters must not be null\");\n\n\t\tif (filters.isEmpty()) {\n\t\t\treturn alwaysIncluded();\n\t\t}\n\t\tif (filters.size() == 1) {\n\t\t\treturn getOnlyElement(filters);\n\t\t}\n\t\treturn new CompositeFilter<>(filters);\n\t}",
    "comment": "Return a filter that will include elements if and only if all of the\nfilters in the supplied collection of {@link Filter filters} include it.\n\n<p>If the collection is empty, the returned filter will include all\nelements it is asked to filter.\n\n@param filters the collection of filters to compose; never {@code null}\n@see #composeFilters(Filter...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/parameter-object/src/test/java/com/iluwatar/parameter/object/ParameterObjectTest.java",
    "type": "method",
    "name": "testForDefaultSortBy",
    "code": "void testForDefaultSortBy() {\n    ParameterObject params =\n        ParameterObject.newBuilder().withType(\"sneakers\").sortOrder(SortOrder.DESC).build();\n\n    assertEquals(ParameterObject.DEFAULT_SORT_BY, params.getSortBy(), \"Default SortBy is not set.\");\n    LOGGER.info(\n        \"{} Default parameter value is set during object creation as no value is passed.\",\n        \"SortBy\");\n  }",
    "comment": "Creating parameter object with default value for SortBy set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "split",
    "code": "public UTF8String[] split(UTF8String pattern, int limit) {\n    if (numBytes() != 0 && pattern.numBytes() == 0) {\n      int newLimit = limit > numChars() || limit <= 0 ? numChars() : limit;\n      byte[] input = getBytes();\n      int byteIndex = 0;\n      int charIndex = 0;\n      UTF8String[] result = new UTF8String[newLimit];\n      while (charIndex < newLimit) {\n        int currCharNumBytes = numBytesForFirstByte(input[byteIndex]);\n        result[charIndex++] = UTF8String.fromBytes(input, byteIndex, currCharNumBytes);\n        byteIndex += currCharNumBytes;\n      }\n      return result;\n    }\n    return split(pattern.toString(), limit);\n  }",
    "comment": "For the empty `pattern` a `split` function ignores trailing empty strings unless original\nstring is empty."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/visitor/src/test/java/com/iluwatar/visitor/VisitorTest.java",
    "type": "method",
    "name": "setUp",
    "code": "void setUp() {\n    appender = new InMemoryAppender();\n  }",
    "comment": "Test case for Visitor Pattern\n\n@param <V> Type of UnitVisitor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestDescriptor.java",
    "type": "method",
    "name": "composite",
    "code": "static Visitor composite(Visitor... visitors) {\n\t\t\treturn CompositeTestDescriptorVisitor.from(visitors);\n\t\t}",
    "comment": "Combine the supplied {@code visitors} into a single {@code Visitor}.\n\n<p>If the supplied array contains only a single {@code Visitor}, that\n{@code Visitor} is returned as is.\n\n@param visitors the {@code Visitor}s to combine; never {@code null}\nor empty\n@return the combined {@code Visitor}\n@throws org.junit.platform.commons.PreconditionViolationException if\n{@code visitors} is {@code null}, contains {@code null} elements, or\nis empty\n@since 1.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "skippedWithReason",
    "code": "public static Condition<Event> skippedWithReason(Predicate<String> predicate) {\n\t\treturn allOf(type(SKIPPED), reason(predicate));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link EventType#SKIPPED} and the\n{@linkplain Event#getPayload() reason} matches the supplied\n{@link Predicate}.\n\n@see #reason(Predicate)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-idempotent-consumer/src/main/java/com/iluwatar/idempotentconsumer/RequestService.java",
    "type": "method",
    "name": "create",
    "code": "public Request create(UUID uuid) {\n    Optional<Request> optReq = requestRepository.findById(uuid);\n    return optReq.orElseGet(() -> requestRepository.save(new Request(uuid)));\n  }",
    "comment": "Creates a new Request or returns an existing one by its UUID. This operation is idempotent:\nperforming it once or several times successively leads to an equivalent result.\n\n@param uuid The unique identifier for the Request.\n@return Return existing Request or save and return a new Request."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java",
    "type": "method",
    "name": "discoverTestClass",
    "code": "void discoverTestClass() {\n\t\tLauncherDiscoveryRequest request = request().selectors(selectClass(LocalTestCase.class)).build();\n\t\tTestDescriptor engineDescriptor = discoverTests(request).getEngineDescriptor();\n\t\tassertEquals(7, engineDescriptor.getDescendants().size(), \"# resolved test descriptors\");\n\t}",
    "comment": "Test correct test discovery in simple test classes for the {@link JupiterTestEngine}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectPackage",
    "code": "public static PackageSelector selectPackage(String packageName) {\n\t\tPreconditions.notNull(packageName, \"Package name must not be null\");\n\t\tPreconditions.condition(packageName.isEmpty() || !packageName.trim().isEmpty(),\n\t\t\t\"Package name must not contain only whitespace\");\n\t\treturn new PackageSelector(packageName.trim());\n\t}",
    "comment": "Create a {@code PackageSelector} for the supplied package name.\n\n<p>The default package is represented by an empty string ({@code \"\"}).\n\n@param packageName the package name to select; never {@code null} and\nnever containing whitespace only\n@see PackageSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Boolean> create(boolean[] data) {\n    return Tensor.create(data, Boolean.class);\n  }",
    "comment": "Creates a rank-1 tensor of {@code boolean} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/templateview/src/test/java/com/iluwatar/templateview/TemplateViewTest.java",
    "type": "method",
    "name": "testRenderContactPage",
    "code": "void testRenderContactPage() {\n    TemplateView contactPage = spy(ContactPageView.class);\n\n    contactPage.render();\n\n    verify(contactPage).printHeader(); // Header is printed\n    verify(contactPage).renderDynamicContent(); // Dynamic content specific to contact page\n    verify(contactPage).printFooter(); // Footer is printed\n  }",
    "comment": "Create a spy for ContactPageView\nCall the render method\nVerify that the steps of rendering are executed in the correct order"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-expression/src/main/java/org/apache/maven/plugin/coreit/PropertyUtil.java",
    "type": "method",
    "name": "store",
    "code": "private static void store(Properties props, String key, Object obj, Collection visited) {\n        if (obj != null && !visited.contains(obj)) {\n            visited.add(obj);\n            if ((obj instanceof String)\n                    || (obj instanceof Number)\n                    || (obj instanceof Boolean)\n                    || (obj instanceof File)\n                    || (obj instanceof Path)) {\n                props.put(key, obj.toString());\n            } else if (obj instanceof Collection) {\n                Collection coll = (Collection) obj;\n                props.put(key, Integer.toString(coll.size()));\n                int index = 0;\n                for (Iterator it = coll.iterator(); it.hasNext(); index++) {\n                    Object elem = it.next();\n                    store(props, key + \".\" + index, elem, visited);\n                }\n            } else if (obj instanceof Map) {\n                Map map = (Map) obj;\n                props.put(key, Integer.toString(map.size()));\n                @SuppressWarnings(\"checkstyle:UnusedLocalVariable\")\n                int index = 0;\n                for (Iterator it = map.entrySet().iterator(); it.hasNext(); index++) {\n                    Map.Entry entry = (Map.Entry) it.next();\n                    store(props, key + \".\" + entry.getKey(), entry.getValue(), visited);\n                }\n            } else if (obj.getClass().isArray()) {\n                int length = Array.getLength(obj);\n                props.put(key, Integer.toString(length));\n                for (int index = 0; index < length; index++) {\n                    Object elem = Array.get(obj, index);\n                    store(props, key + \".\" + index, elem, visited);\n                }\n            } else if (obj.getClass().getName().endsWith(\"Xpp3Dom\")) {\n                Class type = obj.getClass();\n                try {\n                    Method getValue = type.getMethod(\"getValue\", NO_PARAMS);\n                    String value = (String) getValue.invoke(obj, NO_ARGS);\n\n                    if (value != null) {\n                        props.put(key + \".value\", value);\n                    }\n\n                    Method getName = type.getMethod(\"getName\", NO_PARAMS);\n\n                    Method getChildren = type.getMethod(\"getChildren\", NO_PARAMS);\n                    Object[] children = (Object[]) getChildren.invoke(obj, NO_ARGS);\n\n                    props.put(key + \".children\", Integer.toString(children.length));\n\n                    Map indices = new HashMap();\n                    for (Object child : children) {\n                        String name = (String) getName.invoke(child, NO_ARGS);\n\n                        Integer index = (Integer) indices.get(name);\n                        if (index == null) {\n                            index = 0;\n                        }\n\n                        store(props, key + \".children.\" + name + \".\" + index, child, visited);\n\n                        indices.put(name, index + 1);\n                    }\n                } catch (Exception e) {\n                    // can't happen\n                }\n            } else {\n                Class type = obj.getClass();\n                Method[] methods = type.getMethods();\n                for (Method method : methods) {\n                    if (Modifier.isStatic(method.getModifiers())\n                            || method.getParameterTypes().length > 0\n                            || !method.getName().matches(\"(get|is)\\\\p{Lu}.*\")\n                            || method.getName().endsWith(\"AsMap\")\n                            || Class.class.isAssignableFrom(method.getReturnType())\n                            || Object.class.equals(method.getReturnType())) {\n                        continue;\n                    }\n\n                    try {\n                        Object value = method.invoke(obj, NO_ARGS);\n                        store(props, key + \".\" + getPropertyName(method.getName()), value, visited);\n                    } catch (Exception e) {\n                        // just ignore\n                    }\n                }\n            }\n            visited.remove(obj);\n        }\n    }",
    "comment": "Serializes the specified object into the given properties, using the provided key. The object may be a scalar\nvalue like a string or some array/collection/map or a bean.\n\n@param props   The properties to serialize into, must not be <code>null</code>.\n@param key     The key to use for serialization of the object data, must not be <code>null</code>.\n@param obj     The object to serialize, may be <code>null</code>.\n@param visited The set/stack of already visited objects, used to detect back references in the object graph, must\nnot be <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/project/EmptyLifecycleExecutor.java",
    "type": "method",
    "name": "calculateExecutionPlan",
    "code": "public MavenExecutionPlan calculateExecutionPlan(MavenSession session, String... tasks) {\n        return new MavenExecutionPlan(null, null);\n    }",
    "comment": "A stub implementation that assumes an empty lifecycle to bypass interaction with the plugin manager and to avoid\nplugin artifact resolution from repositories."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/ExpectedException.java",
    "type": "method",
    "name": "expect",
    "code": "public void expect(Class<? extends Throwable> type) {\n        expect(instanceOf(type));\n    }",
    "comment": "Verify that your code throws an exception that is an\ninstance of specific {@code type}.\n<pre> &#064;Test\npublic void throwsExceptionWithSpecificType() {\nthrown.expect(NullPointerException.class);\nthrow new NullPointerException();\n}</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaFPGrowthExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaFPGrowthExample\")\n      .getOrCreate();\n\n    // $example on$\n    List<Row> data = Arrays.asList(\n      RowFactory.create(Arrays.asList(\"1 2 5\".split(\" \"))),\n      RowFactory.create(Arrays.asList(\"1 2 3 5\".split(\" \"))),\n      RowFactory.create(Arrays.asList(\"1 2\".split(\" \")))\n    );\n    StructType schema = new StructType(new StructField[]{ new StructField(\n    Dataset<Row> itemsDF = spark.createDataFrame(data, schema);\n\n    FPGrowthModel model = new FPGrowth()\n      .setItemsCol(\"items\")\n      .setMinSupport(0.5)\n      .setMinConfidence(0.6)\n      .fit(itemsDF);\n\n    // Display frequent itemsets.\n    model.freqItemsets().show();\n\n    // Display generated association rules.\n    model.associationRules().show();\n\n    // transform examines the input items against all the association rules and summarize the\n    // consequents as prediction\n    model.transform(itemsDF).show();\n    // $example off$\n\n    spark.stop();\n  }\n}",
    "comment": "An example demonstrating FPGrowth.\nRun with\n<pre>\nbin/run-example ml.JavaFPGrowthExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/support/OpenTest4JAndJUnit4AwareThrowableCollectorTests.java",
    "type": "method",
    "name": "TestClassLoader",
    "code": "public TestClassLoader(boolean simulateJUnit4Missing, boolean simulateHamcrestMissing) {\n\t\t\tsuper(CLASSPATH_URLS, getSystemClassLoader());\n\t\t\tthis.simulateJUnit4Missing = simulateJUnit4Missing;\n\t\t\tthis.simulateHamcrestMissing = simulateHamcrestMissing;\n\t\t}",
    "comment": "Unit tests for {@link OpenTest4JAndJUnit4AwareThrowableCollector}.\n\n@since 5.5.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/delegation/src/test/java/com/iluwatar/delegation/simple/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "isPublic",
    "code": "public static boolean isPublic(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t}",
    "comment": "Internal cache of primitive types mapped to their wrapper types."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/util/PhasingExecutor.java",
    "type": "method",
    "name": "PhasingExecutor",
    "code": "public PhasingExecutor(ExecutorService executor) {\n        this.executor = executor;\n        log(\"[{}][general] PhasingExecutor created.\");\n    }",
    "comment": "The phasing executor allows executing tasks in parallel and waiting for all tasks\nto be executed before fully closing the executor. Tasks can be submitted even after\nthe close method has been called, allowing for use with try-with-resources.\nThe {@link #phase()} method can be used to submit tasks and wait for them to be\nexecuted without closing the executor.\n\n<p>Example usage:\n<pre>\ntry (PhasingExecutor executor = createExecutor()) {\ntry (var phase = executor.phase()) {\nexecutor.execute(() -> { /* task 1 *&#47; });\nexecutor.execute(() -> { /* task 2 *&#47; });\nMore tasks...\n} This will wait for all tasks in this phase to complete\n\nYou can have multiple phases\ntry (var anotherPhase = executor.phase()) {\nexecutor.execute(() -> { /* another task *&#47; });\n}\n} The executor will wait for all tasks to complete before shutting down\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/TensorFlowLite.java",
    "type": "method",
    "name": "version",
    "code": "public static String version() {\n    return schemaVersion();\n  }",
    "comment": "Returns the version of the underlying TensorFlowLite model schema.\n\n@deprecated Prefer using {@link #runtimeVersion() or #schemaVersion()}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng0553SettingsAuthzEncryptionTest.java",
    "type": "method",
    "name": "findPassword",
    "code": "private String findPassword(List<String> log) {\n        for (String line : log) {\n            if (line.matches(\".*\\\\{[A-Za-z0-9+/=]+\\\\}.*\")) {\n                return line;\n            }\n        }\n\n        return null;\n    }",
    "comment": "Test that the CLI supports generation of encrypted (master) passwords.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng2305MultipleProxiesTest.java",
    "type": "method",
    "name": "addHttpsConnector",
    "code": "private void addHttpsConnector(Server server, String keyStorePath, String keyStorePassword, String keyPassword) {\n        SslContextFactory sslContextFactory = new SslContextFactory(keyStorePath);\n        sslContextFactory.setKeyStorePassword(keyStorePassword);\n        sslContextFactory.setKeyManagerPassword(keyPassword);\n        HttpConfiguration httpConfiguration = new HttpConfiguration();\n        httpConfiguration.setSecureScheme(\"https\");\n        HttpConfiguration httpsConfiguration = new HttpConfiguration(httpConfiguration);\n        httpsConfiguration.addCustomizer(new SecureRequestCustomizer());\n        ServerConnector httpsConnector = new ServerConnector(\n                server,\n                new SslConnectionFactory(sslContextFactory, HTTP_1_1.asString()),\n                new HttpConnectionFactory(httpsConfiguration));\n        server.addConnector(httpsConnector);\n    }",
    "comment": "disable concurrent downloading as not all wagons (e.g. wagon-lightweight-http) are thread-safe regarding\nproxy settings"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/validator/AnnotationValidator.java",
    "type": "method",
    "name": "validateAnnotatedMethod",
    "code": "public List<Exception> validateAnnotatedMethod(FrameworkMethod method) {\n        return NO_VALIDATION_ERRORS;\n    }",
    "comment": "Validates annotation on the given method.\n\n@param method that is being validated\n@return A list of exceptions. Default behavior is to return an empty list.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/rules/RuleMemberValidator.java",
    "type": "method",
    "name": "validate",
    "code": "public void validate(FrameworkMember<?> member, Class<? extends Annotation> annotation, List<Throwable> errors) {\n            boolean isMethodRuleMember = isMethodRule(member);\n            boolean isClassRuleAnnotated = (member.getAnnotation(ClassRule.class) != null);\n\n            // We disallow:\n            //  - static MethodRule members\n            //  - static @Rule annotated members\n            //    - UNLESS they're also @ClassRule annotated\n            // Note that MethodRule cannot be annotated with @ClassRule\n            if (member.isStatic() && (isMethodRuleMember || !isClassRuleAnnotated)) {\n                String message;\n                if (isMethodRule(member)) {\n                    message = \"must not be static.\";\n                } else {\n                    message = \"must not be static or it must be annotated with @ClassRule.\";\n                }\n                errors.add(new ValidationError(member, annotation, message));\n            }\n        }",
    "comment": "Requires the validated member to be non-static"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/Truck.java",
    "type": "method",
    "name": "Truck",
    "code": "public Truck(int year, String make, String model, double loadCapacity, int id) {\n    super(year, make, model, id);\n    if (loadCapacity <= 0) {\n      throw new IllegalArgumentException(\"Load capacity must be positive.\");\n    }\n    this.loadCapacity = loadCapacity;\n  }",
    "comment": "Constructs a Truck object with the given parameters.\n\n@param year the year of manufacture\n@param make the make of the truck\n@param model the model of the truck\n@param loadCapacity the load capacity of the truck\n@param id the unique ID of the truck"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "skipped",
    "code": "public Executions skipped() {\n\t\treturn new Executions(executionsByTerminationInfo(TerminationInfo::skipped), this.category + \" Skipped\");\n\t}",
    "comment": "Get the skipped {@link Executions} contained in this {@code Executions} object.\n\n@return the filtered {@code Executions}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/BeforeAndAfterAllTests.java",
    "type": "method",
    "name": "beforeAllAndAfterAllCallbacks",
    "code": "void beforeAllAndAfterAllCallbacks() {\n\t\t// @formatter:off\n\t\tassertBeforeAllAndAfterAllCallbacks(TopLevelTestCase.class,\n\t\t\t\"fooBeforeAllCallback\",\n\t\t\t\"barBeforeAllCallback\",\n\t\t\t\t\"beforeAllMethod-1\",\n\t\t\t\t\t\"test-1\",\n\t\t\t\t\"afterAllMethod-1\",\n\t\t\t\"barAfterAllCallback\",\n\t\t\t\"fooAfterAllCallback\"\n\t\t);\n\t\t// @formatter:on\n\n\t\tassertThat(actualExceptionInAfterAllCallback).isEmpty();\n\t}",
    "comment": "Integration tests that verify support for {@link BeforeAll}, {@link AfterAll},\n{@link BeforeAllCallback}, and {@link AfterAllCallback} in the {@link JupiterTestEngine}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/EnabledOnOsConditionTests.java",
    "type": "method",
    "name": "getExecutionCondition",
    "code": "protected ExecutionCondition getExecutionCondition() {\n\t\treturn new EnabledOnOsCondition();\n\t}",
    "comment": "Unit tests for {@link EnabledOnOsCondition}.\n\n<p>Note that test method names MUST match the test method names in\n{@link EnabledOnOsIntegrationTests}.\n\n@since 5.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/AbstractInstance.java",
    "type": "method",
    "name": "processMessage",
    "code": "private void processMessage(Message message) {\n    switch (message.getType()) {\n      case ELECTION -> {\n        LOGGER.info(INSTANCE + localId + \" - Election Message handling...\");\n        handleElectionMessage(message);\n      }\n      case LEADER -> {\n        LOGGER.info(INSTANCE + localId + \" - Leader Message handling...\");\n        handleLeaderMessage(message);\n      }\n      case HEARTBEAT -> {\n        LOGGER.info(INSTANCE + localId + \" - Heartbeat Message handling...\");\n        handleHeartbeatMessage(message);\n      }\n      case ELECTION_INVOKE -> {\n        LOGGER.info(INSTANCE + localId + \" - Election Invoke Message handling...\");\n        handleElectionInvokeMessage();\n      }\n      case LEADER_INVOKE -> {\n        LOGGER.info(INSTANCE + localId + \" - Leader Invoke Message handling...\");\n        handleLeaderInvokeMessage();\n      }\n      case HEARTBEAT_INVOKE -> {\n        LOGGER.info(INSTANCE + localId + \" - Heartbeat Invoke Message handling...\");\n        handleHeartbeatInvokeMessage();\n      }\n      default -> {}\n    }\n  }",
    "comment": "Process the message according to its type.\n\n@param message Message polled from queue."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaPCAExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf conf = new SparkConf().setAppName(\"PCA Example\");\n    SparkContext sc = new SparkContext(conf);\n    JavaSparkContext jsc = JavaSparkContext.fromSparkContext(sc);\n\n    // $example on$\n    List<Vector> data = Arrays.asList(\n            Vectors.sparse(5, new int[] {1, 3}, new double[] {1.0, 7.0}),\n    jsc.stop();\n  }",
    "comment": "Example for compute principal components on a 'RowMatrix'."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expressions.java",
    "type": "method",
    "name": "days",
    "code": "public static Transform days(String column) {\n    return LogicalExpressions.days(Expressions.column(column));\n  }",
    "comment": "Create a daily transform for a timestamp or date column.\n<p>\nThis transform represents a logical mapping from a timestamp or date to a date, such as\n2018-05-13.\n<p>\nThe name reported by transforms created with this method is \"days\".\n\n@param column an input timestamp or date column\n@return a logical daily transform with name \"days\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, Object expected, Object actual) {\n        Assert.assertEquals(message, expected, actual);\n    }",
    "comment": "Asserts that two objects are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/test/java/com/iluwatar/async/method/invocation/ThreadAsyncExecutorTest.java",
    "type": "method",
    "name": "testNullTask",
    "code": "void testNullTask() {\n    assertTimeout(\n        ofMillis(3000),\n        () -> {\n          // Instantiate a new executor and start a new 'null' task ...\n          final var executor = new ThreadAsyncExecutor();\n          final var asyncResult = executor.startProcess(null);\n\n          assertNotNull(\n              asyncResult,\n              \"The AsyncResult should not be 'null', even though the task was 'null'.\");\n          asyncResult.await(); // Prevent timing issues, and wait until the result is available\n          assertTrue(asyncResult.isCompleted());\n\n          try {\n            asyncResult.getValue();\n            fail(\"Expected ExecutionException with NPE as cause\");\n          } catch (final ExecutionException e) {\n            assertNotNull(e.getMessage());\n            assertNotNull(e.getCause());\n            assertEquals(NullPointerException.class, e.getCause().getClass());\n          }\n        });\n  }",
    "comment": "Test used to verify the behaviour of {@link ThreadAsyncExecutor#startProcess(Callable)} when\nthe callable is 'null'"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceContentProviderSample/app/src/main/java/com/example/android/contentprovidersample/data/Cheese.java",
    "type": "method",
    "name": "fromContentValues",
    "code": "public static Cheese fromContentValues(@Nullable ContentValues values) {\n        final Cheese cheese = new Cheese();\n        if (values != null && values.containsKey(COLUMN_ID)) {\n            cheese.id = values.getAsLong(COLUMN_ID);\n        }\n        if (values != null && values.containsKey(COLUMN_NAME)) {\n            cheese.name = values.getAsString(COLUMN_NAME);\n        }\n        return cheese;\n    }",
    "comment": "Create a new {@link Cheese} from the specified {@link ContentValues}.\n@return A newly created {@link Cheese} instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProjectExecutionEvent.java",
    "type": "method",
    "name": "ProjectExecutionEvent",
    "code": "public ProjectExecutionEvent(MavenSession session, MavenProject project) {\n        this(session, project, null, null);\n    }",
    "comment": "<p>\nEncapsulates parameters of ProjectExecutionListener callback methods and is meant to provide API evolution path\nshould it become necessary to introduce new parameters in the existing callbacks in the future.\n</p>\n<strong>Note:</strong> This class is part of work in progress and can be changed or removed without notice.\n\n@see ProjectExecutionListener\n@since 3.1.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/utils/Os.java",
    "type": "method",
    "name": "isFamily",
    "code": "public static boolean isFamily(String family, String actualOsName) {\n        // windows probing logic relies on the word 'windows' in the OS\n        boolean isWindows = actualOsName.contains(FAMILY_WINDOWS);\n        boolean is9x = false;\n        boolean isNT = false;\n        if (isWindows) {\n            // there are only four 9x platforms that we look for\n            is9x = (actualOsName.contains(\"95\")\n                    || actualOsName.contains(\"98\")\n                    || actualOsName.contains(\"me\")\n                    // wince isn't really 9x, but crippled enough to\n                    // be a muchness. Maven doesnt run on CE, anyway.\n                    || actualOsName.contains(\"ce\"));\n            isNT = !is9x;\n        }\n        return switch (family) {\n            case FAMILY_WINDOWS -> isWindows;\n            case FAMILY_WIN9X -> isWindows && is9x;\n            case FAMILY_NT -> isWindows && isNT;\n            case FAMILY_OS2 -> actualOsName.contains(FAMILY_OS2);\n            case FAMILY_NETWARE -> actualOsName.contains(FAMILY_NETWARE);\n            case FAMILY_DOS -> File.pathSeparatorChar == ';' && !isFamily(FAMILY_NETWARE, actualOsName) && !isWindows;\n            case FAMILY_MAC -> actualOsName.contains(FAMILY_MAC) || actualOsName.contains(DARWIN);\n            case FAMILY_TANDEM -> actualOsName.contains(\"nonstop_kernel\");\n            case FAMILY_UNIX -> File.pathSeparatorChar == ':'\n                    && !isFamily(FAMILY_OPENVMS, actualOsName)\n                    && (!isFamily(FAMILY_MAC, actualOsName) || actualOsName.endsWith(\"x\"));\n            case FAMILY_ZOS -> actualOsName.contains(FAMILY_ZOS) || actualOsName.contains(FAMILY_OS390);\n            case FAMILY_OS400 -> actualOsName.contains(FAMILY_OS400);\n            case FAMILY_OPENVMS -> actualOsName.contains(FAMILY_OPENVMS);\n            default -> actualOsName.contains(family.toLowerCase(Locale.US));\n        };\n    }",
    "comment": "Determines if the OS on which Maven is executing matches the\ngiven OS family derived from the given OS name\n\n@param family the family to check for\n@param actualOsName the OS name to check against\n@return true if the OS matches"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/ReactorReader.java",
    "type": "method",
    "name": "findMatchingArtifact",
    "code": "private Artifact findMatchingArtifact(MavenProject project, Artifact requestedArtifact) {\n        String requestedRepositoryConflictId = ArtifactIdUtils.toVersionlessId(requestedArtifact);\n        return getProjectArtifacts(project)\n                .filter(artifact ->\n                        Objects.equals(requestedRepositoryConflictId, ArtifactIdUtils.toVersionlessId(artifact)))\n                .findFirst()\n                .orElse(null);\n    }",
    "comment": "Tries to resolve the specified artifact from the artifacts of the given project.\n\n@param project The project to try to resolve the artifact from, must not be <code>null</code>.\n@param requestedArtifact The artifact to resolve, must not be <code>null</code>.\n@return The matching artifact from the project or <code>null</code> if not found. Note that this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/artifact/resolver/TestFileWagon.java",
    "type": "method",
    "name": "addTransfer",
    "code": "private void addTransfer(String resourceName) {\n        if (testTransferListener != null) {\n            testTransferListener.addTransfer(resourceName);\n        }\n    }",
    "comment": "Wagon used for test cases that annotate some methods. Note that this is not a thread-safe implementation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenFailOnSeverityLogger.java",
    "type": "method",
    "name": "warn",
    "code": "public void warn(String msg) {\n        super.warn(msg);\n        logLevelRecorder.record(Level.WARN);\n    }",
    "comment": "A simple implementation which always logs messages of level WARN\naccording to the format outlined above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/JUnitCore.java",
    "type": "method",
    "name": "runClasses",
    "code": "public static Result runClasses(Computer computer, Class<?>... classes) {\n        return new JUnitCore().run(computer, classes);\n    }",
    "comment": "Run the tests contained in <code>classes</code>. Write feedback while the tests\nare running and write stack traces for all failed tests after all tests complete. This is\nsimilar to {@link #main(String[])}, but intended to be used programmatically.\n\n@param computer Helps construct Runners from classes\n@param classes  Classes in which to find tests\n@return a {@link Result} describing the details of the test run and the failed tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/test/java/com/iluwatar/RegisterWorkerFormTest.java",
    "type": "method",
    "name": "submitSuccessfully",
    "code": "void submitSuccessfully() {\n    registerWorkerForm = new RegisterWorkerForm(\"John Doe\", \"Engineer\", LocalDate.of(1990, 1, 1));\n\n    assertNull(registerWorkerForm.worker);\n\n    registerWorkerForm.submit();\n\n    assertNotNull(registerWorkerForm.worker);\n\n    assertEquals(\"John Doe\", registerWorkerForm.worker.getName());\n    assertEquals(\"Engineer\", registerWorkerForm.worker.getOccupation());\n    assertEquals(LocalDate.of(1990, 1, 1), registerWorkerForm.worker.getDateOfBirth());\n  }",
    "comment": "Ensure the worker is null initially\nSubmit the form\nVerify that the worker is not null after submission\nVerify that the worker's properties are set correctly"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ResolverFacade.java",
    "type": "method",
    "name": "determineConsumedArgumentLength",
    "code": "int determineConsumedArgumentLength(int totalLength) {\n\t\tNavigableMap<Integer, ? extends ParameterDeclaration> declarationsByIndex = this.indexedParameterDeclarations.declarationsByIndex;\n\t\treturn this.aggregatorParameters.isEmpty() //\n\t\t\t\t? Math.min(totalLength, declarationsByIndex.isEmpty() ? 0 : declarationsByIndex.lastKey() + 1) //\n\t\t\t\t: totalLength;\n\t}",
    "comment": "Determine the length of the arguments array that is considered consumed\nby the parameter declarations in this resolver.\n\n<p>If an aggregator is present, all arguments are considered consumed.\nOtherwise, the consumed argument length is the minimum of the total\nlength and the number of indexed parameter declarations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-controller/src/main/java/com/iluwatar/page/controller/UserView.java",
    "type": "method",
    "name": "display",
    "code": "public String display(SignupModel user) {\n    LOGGER.info(\"display user html\" + \" name \" + user.getName() + \" email \" + user.getEmail());\n    return \"/user\";\n  }",
    "comment": "displaying command to generate html.\n\n@param user model content."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "children",
    "code": "public Builder children(List<XmlNode> children) {\n            this.children = children;\n            return this;\n        }",
    "comment": "Sets the child nodes of the XML node.\n<p>\nThe provided list will be copied to ensure immutability.\n\n@param children the list of child nodes\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/exception/DefaultExceptionHandlerTest.java",
    "type": "method",
    "name": "testJdk7ipv6",
    "code": "void testJdk7ipv6() {\n        ConnectException connEx = new ConnectException(\"Connection refused: connect\");\n        IOException ioEx = new IOException(\"Unable to establish loopback connection\", connEx);\n        MojoExecutionException mojoEx =\n                new MojoExecutionException(\"Error executing Jetty: Unable to establish loopback connection\", ioEx);\n\n        ExceptionHandler exceptionHandler = new DefaultExceptionHandler();\n        ExceptionSummary exceptionSummary = exceptionHandler.handleException(mojoEx);\n\n        String expectedReference = \"http://cwiki.apache.org/confluence/display/MAVEN/ConnectException\";\n        assertEquals(expectedReference, exceptionSummary.getReference());\n    }",
    "comment": "Running Maven under JDK7 may cause connection issues because IPv6 is used by default.\n<p>\ne.g running mvn site:run will cause Jetty to fail.\n</p>\n<p>\nThe resolution is to add -Djava.net.preferIPv4Stack=true to the command line as documented in\nhttp://cwiki.apache.org/confluence/display/MAVEN/ConnectException\n</p>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/ArtifactUtils.java",
    "type": "method",
    "name": "copyArtifact",
    "code": "public static Artifact copyArtifact(Artifact artifact) {\n        VersionRange range = artifact.getVersionRange();\n\n\n        if (range == null) {\n            range = VersionRange.createFromVersion(artifact.getVersion());\n        }\n\n        DefaultArtifact clone = new DefaultArtifact(\n                artifact.getGroupId(),\n                artifact.getArtifactId(),\n                range,\n                artifact.getScope(),\n                artifact.getType(),\n                artifact.getClassifier(),\n                artifact.getArtifactHandler(),\n                artifact.isOptional());\n        clone.setRelease(artifact.isRelease());\n        clone.setResolvedVersion(artifact.getVersion());\n        clone.setResolved(artifact.isResolved());\n        clone.setFile(artifact.getFile());\n\n        clone.setAvailableVersions(copyList(artifact.getAvailableVersions()));\n        if (artifact.getVersion() != null) {\n            clone.setBaseVersion(artifact.getBaseVersion());\n        }\n        clone.setDependencyFilter(artifact.getDependencyFilter());\n        clone.setDependencyTrail(copyList(artifact.getDependencyTrail()));\n        clone.setDownloadUrl(artifact.getDownloadUrl());\n        clone.setRepository(artifact.getRepository());\n\n        return clone;\n    }",
    "comment": "For some reason with the introduction of MNG-1577 we have the case in Yoko where a depMan section has\nsomething like the following:\n\n<dependencyManagement>\n<dependencies>\n<!--  Yoko modules -->\n<dependency>\n<groupId>org.apache.yoko</groupId>\n<artifactId>yoko-core</artifactId>\n<version>${version}</version>\n</dependency>\n...\n\nAnd the range is not set so we'll check here and set it. jvz."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "removeAppShuffleInfoFromDB",
    "code": "void removeAppShuffleInfoFromDB(AppShuffleInfo appShuffleInfo) {\n    if (db != null) {\n      appShuffleInfo.shuffles.forEach((shuffleId, shuffleInfo) ->\n          removeAppShufflePartitionInfoFromDB(\n              new AppAttemptShuffleMergeId(\n                  appShuffleInfo.appId, appShuffleInfo.attemptId,\n                  shuffleId, shuffleInfo.shuffleMergeId)));\n    }\n  }",
    "comment": "Remove the finalized shuffle partitions information for an application attempt from the DB"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "getArtifactMetadataPath",
    "code": "public String getArtifactMetadataPath(String gid, String aid, String version) {\n        return getArtifactMetadataPath(gid, aid, version, \"maven-metadata.xml\");\n    }",
    "comment": "Gets the path to the local artifact metadata. Note that the method does not check whether the returned path\nactually points to existing metadata.\n\n@param gid     The group id, must not be <code>null</code>.\n@param aid     The artifact id, must not be <code>null</code>.\n@param version The artifact version, may be <code>null</code>.\n@return The (absolute) path to the local artifact metadata, never <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/NettyUtils.java",
    "type": "method",
    "name": "preferDirectBufs",
    "code": "public static boolean preferDirectBufs(TransportConf conf) {\n    boolean allowDirectBufs;\n    if (conf.sharedByteBufAllocators()) {\n      allowDirectBufs = conf.preferDirectBufsForSharedByteBufAllocators();\n    } else {\n      allowDirectBufs = conf.preferDirectBufs();\n    }\n    return allowDirectBufs && PlatformDependent.directBufferPreferred();\n  }",
    "comment": "ByteBuf allocator prefers to allocate direct ByteBuf if both Spark allows to create direct\nByteBuf and Netty enables directBufferPreferred."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "findMethod",
    "code": "public static Optional<Method> findMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\treturn ReflectionUtils.findMethod(clazz, methodName, parameterTypes);\n\t}",
    "comment": "Find the first {@link Method} of the supplied class or interface that\nmeets the specified criteria, beginning with the specified class or\ninterface and traversing up the type hierarchy until such a method is\nfound or the type hierarchy is exhausted.\n\n<p>The algorithm does not search for methods in {@link java.lang.Object}.\n\n@param clazz the class or interface in which to find the method; never {@code null}\n@param methodName the name of the method to find; never {@code null} or empty\n@param parameterTypes the types of parameters accepted by the method, if any;\nnever {@code null}\n@return an {@code Optional} containing the method found; never {@code null}\nbut potentially empty if no such method could be found\n@see #findMethod(Class, String, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "separateFinalizeShuffleMerge",
    "code": "public boolean separateFinalizeShuffleMerge() {\n    return conf.getInt(\"spark.shuffle.server.finalizeShuffleMergeThreadsPercent\", 0) > 0;\n  }",
    "comment": "Whether to use a separate EventLoopGroup to process FinalizeShuffleMerge messages, it is\ndecided by the config `spark.shuffle.server.finalizeShuffleMergeThreadsPercent` is set or not."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getReportConfiguration",
    "code": "public Xpp3Dom getReportConfiguration(String pluginGroupId, String pluginArtifactId, String reportSetId) {\n        Xpp3Dom dom = null;\n\n\n        if (getReportPlugins() != null) {\n            for (ReportPlugin plugin : getReportPlugins()) {\n                if (pluginGroupId.equals(plugin.getGroupId()) && pluginArtifactId.equals(plugin.getArtifactId())) {\n                    dom = (Xpp3Dom) plugin.getConfiguration();\n\n                    if (reportSetId != null) {\n                        ReportSet reportSet = plugin.getReportSetsAsMap().get(reportSetId);\n                        if (reportSet != null) {\n                            Xpp3Dom executionConfiguration = (Xpp3Dom) reportSet.getConfiguration();\n                            if (executionConfiguration != null) {\n                                Xpp3Dom newDom = new Xpp3Dom(executionConfiguration);\n                                dom = Xpp3Dom.mergeXpp3Dom(newDom, dom);\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n\n        if (dom != null) {\n            dom = new Xpp3Dom(dom);\n        }\n\n        return dom;\n    }",
    "comment": "----------------------------------------------------------------------\nI would like to be able to look up the Mojo object using a key but\nwe have a limitation in modello that will be remedied shortly. So\nfor now I have to iterate through and see what we have.\n----------------------------------------------------------------------\nmake a copy so the original in the POM doesn't get messed with"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/UniqueIdTrackingListener.java",
    "type": "method",
    "name": "executionSkipped",
    "code": "public void executionSkipped(TestIdentifier testIdentifier, String reason) {\n\t\tif (this.enabled) {\n\t\t\ttrackTestUidRecursively(testIdentifier);\n\t\t}\n\t}",
    "comment": "When a container is skipped, there are no events for its children.\nTherefore, in order to track them, we need to traverse the subtree."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/ComparisonFailureTest.java",
    "type": "method",
    "name": "testConnection",
    "code": "public void testConnection() {\n        ComparisonFailure failure = new ComparisonFailure(\"warning\", \"Mary had a little lamb\", \"Mary had the little lamb\");\n        assertEquals(\"warning expected:<Mary had [a] little lamb> but was:<Mary had [the] little lamb>\", failure.getMessage());\n    }",
    "comment": "Most of the tests are in ComparisonCompactorTest"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelInterpolator.java",
    "type": "method",
    "name": "projectProperty",
    "code": "String projectProperty(Model model, Path projectDir, String subExpr, boolean prefixed) {\n        if (projectDir != null) {\n            if (subExpr.equals(\"basedir\")) {\n                return projectDir.toAbsolutePath().toString();\n            } else if (subExpr.startsWith(\"basedir.\")) {\n                try {\n                    Object value = ReflectionValueExtractor.evaluate(subExpr, projectDir.toAbsolutePath(), true);\n                    if (value != null) {\n                        return value.toString();\n                    }\n                } catch (Exception e) {\n                }\n            } else if (prefixed && subExpr.equals(\"baseUri\")) {\n                return projectDir.toAbsolutePath().toUri().toASCIIString();\n            } else if (prefixed && subExpr.startsWith(\"baseUri.\")) {\n                try {\n                    Object value = ReflectionValueExtractor.evaluate(\n                            subExpr, projectDir.toAbsolutePath().toUri(), true);\n                    if (value != null) {\n                        return value.toString();\n                    }\n                } catch (Exception e) {\n                }\n            } else if (prefixed && subExpr.equals(\"rootDirectory\")) {\n                return rootLocator.findMandatoryRoot(projectDir).toString();\n            } else if (prefixed && subExpr.startsWith(\"rootDirectory.\")) {\n                try {\n                    Object value =\n                            ReflectionValueExtractor.evaluate(subExpr, rootLocator.findMandatoryRoot(projectDir), true);\n                    if (value != null) {\n                        return value.toString();\n                    }\n                } catch (Exception e) {\n                }\n            }\n        }\n        try {\n            Object value = ReflectionValueExtractor.evaluate(subExpr, model, false);\n            if (value != null) {\n                return value.toString();\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }",
    "comment": "addFeedback(\"Failed to extract \\'\" + expression + \"\\' from: \" + root, e);\naddFeedback(\"Failed to extract \\'\" + expression + \"\\' from: \" + root, e);\naddFeedback(\"Failed to extract \\'\" + expression + \"\\' from: \" + root, e);\naddFeedback(\"Failed to extract \\'\" + expression + \"\\' from: \" + root, e);"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/factory-kit/src/test/java/com/iluwatar/factorykit/factorykit/FactoryKitTest.java",
    "type": "method",
    "name": "testAxeWeapon",
    "code": "void testAxeWeapon() {\n    var weapon = factory.create(WeaponType.AXE);\n    verifyWeapon(weapon, Axe.class);\n  }",
    "comment": "Testing {@link WeaponFactory} to produce a AXE asserting that the Weapon is an instance of\n{@link Axe}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaFMRegressorExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n        .builder()\n        .appName(\"JavaFMRegressorExample\")\n        .getOrCreate();\n\n    Dataset<Row> data = spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    MinMaxScalerModel featureScaler = new MinMaxScaler()\n        .setInputCol(\"features\")\n        .setOutputCol(\"scaledFeatures\")\n        .fit(data);\n\n    Dataset<Row>[] splits = data.randomSplit(new double[] {0.7, 0.3});\n    Pipeline pipeline = new Pipeline().setStages(new PipelineStage[] {featureScaler, fm});\n}",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file, converting it to a DataFrame.\nScale features.\nSplit the data into training and test sets (30% held out for testing)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(char expected, char actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/test/java/com/example/android/observability/UserViewModelTest.java",
    "type": "method",
    "name": "updateUserName_updatesNameInDataSource",
    "code": "public void updateUserName_updatesNameInDataSource() {\n        when(mDataSource.insertOrUpdateUser(any())).thenReturn(Completable.complete());\n\n        mViewModel.updateUserName(\"new user name\")\n                .test()\n                .assertComplete();\n\n        verify(mDataSource).insertOrUpdateUser(mUserArgumentCaptor.capture());\n        assertThat(mUserArgumentCaptor.getValue().getUserName(), Matchers.is(\"new user name\"));\n    }",
    "comment": "Given that a completable is returned when inserting a user\nWhen updating the user name\nThe user name is updated in the data source"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestWatcher.java",
    "type": "method",
    "name": "testFailed",
    "code": "default void testFailed(ExtensionContext context, Throwable cause) {\n\t\t/* no-op */\n\t}",
    "comment": "Invoked after a test has failed.\n\n<p>The default implementation does nothing. Concrete implementations can\noverride this method as appropriate.\n\n@param context the current extension context; never {@code null}\n@param cause the throwable that caused test failure; may be {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/FixedLengthRowBasedKeyValueBatch.java",
    "type": "method",
    "name": "getKeyRow",
    "code": "public UnsafeRow getKeyRow(int rowId) {\n    assert(rowId >= 0);\n    assert(rowId < numRows);\n    if (keyRowId != rowId) { // if keyRowId == rowId, desired keyRow is already cached\n      long offset = getKeyOffsetForFixedLengthRecords(rowId);\n      keyRow.pointTo(base, offset, klen);\n      // set keyRowId so we can check if desired row is cached\n      keyRowId = rowId;\n    }\n    return keyRow;\n  }",
    "comment": "Returns the key row in this batch at `rowId`. Returned key row is reused across calls."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/Interpreter.java",
    "type": "method",
    "name": "Interpreter",
    "code": "public Interpreter(@NonNull File modelFile) {\n    this(modelFile, /*options = */ null);\n  }",
    "comment": "Initializes an {@code Interpreter}.\n\n@param modelFile a File of a pre-trained TF Lite model.\n@throws IllegalArgumentException if {@code modelFile} does not encode a valid TensorFlow Lite\nmodel."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/standalone/ApiRunner.java",
    "type": "method",
    "name": "newSession",
    "code": "static Session newSession(RepositorySystem system, Lookup lookup, @Nullable LocalRepoProvider localRepoProvider) {\n        Map<String, String> properties = new HashMap<>();\n        System.getenv().forEach((k, v) -> properties.put(\"env.\" + k, v));\n        System.getProperties().forEach((k, v) -> properties.put(k.toString(), v.toString()));\n\n        properties.put(\"user.home\", \"target\");\n\n        Path userHome = Paths.get(properties.get(\"user.home\"));\n        Path mavenUserHome = userHome.resolve(\".m2\");\n        Path mavenSystemHome = properties.containsKey(\"maven.home\")\n                ? Paths.get(properties.get(\"maven.home\"))\n                : properties.containsKey(\"env.MAVEN_HOME\") ? Paths.get(properties.get(\"env.MAVEN_HOME\")) : null;\n\n        DefaultRepositorySystemSession rsession = new DefaultRepositorySystemSession(h -> false);\n        rsession.setScopeManager(new ScopeManagerImpl(Maven4ScopeManagerConfiguration.INSTANCE));\n        rsession.setSystemProperties(properties);\n        rsession.setConfigProperties(properties);\n\n        DefaultSession session = new DefaultSession(\n                rsession,\n                system,\n                List.of(lookup.lookup(RepositoryFactory.class)\n                        .createRemote(\"central\", \"https://repo.maven.apache.org/maven2\")),\n                null,\n                lookup);\n\n        Settings settings = session.getService(SettingsBuilder.class)\n                .build(\n                        session,\n                        mavenSystemHome != null ? mavenSystemHome.resolve(\"settings.xml\") : null,\n                        mavenUserHome.resolve(\"settings.xml\"))\n                .getEffectiveSettings();\n\n        settings.getProfiles();\n\n        String localRepository = settings.getLocalRepository() != null\n                        && !settings.getLocalRepository().isEmpty()\n                ? settings.getLocalRepository()\n                : localRepoProvider != null && localRepoProvider.getLocalRepo() != null\n                        ? localRepoProvider.getLocalRepo().toString()\n                        : mavenUserHome.resolve(\"repository\").toString();\n        LocalRepositoryManager llm = system.newLocalRepositoryManager(rsession, new LocalRepository(localRepository));\n        rsession.setLocalRepositoryManager(llm);\n\n        Profile profile = session.getService(SettingsBuilder.class)\n                .convert(org.apache.maven.api.settings.Profile.newBuilder()\n                        .repositories(settings.getRepositories())\n                        .pluginRepositories(settings.getPluginRepositories())\n                        .build());\n        RepositoryFactory repositoryFactory = session.getService(RepositoryFactory.class);\n        List<RemoteRepository> repositories = profile.getRepositories().stream()\n                .map(repositoryFactory::createRemote)\n                .toList();\n        InternalSession s = (InternalSession) session.withRemoteRepositories(repositories);\n        InternalSession.associate(rsession, s);\n        return s;\n\n\n\n    }",
    "comment": "Env variables prefixed with \"env.\"\nJava System properties\nDo not allow user settings to interfere with our unit tests\nTODO: remove that when this go more public\nlocal repository\nactive proxies\nTODO\nactive profiles\nList<RemoteRepository> repositories = repositoryFactory.createRemote();\nsession.getService(SettingsBuilder.class).convert()\nsettings.getDelegate().getRepositories().stream()\n.map(r -> SettingsUtilsV4.)\ndefaultSession.getService(RepositoryFactory.class).createRemote()\nreturn defaultSession;"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/normalization/DefaultModelNormalizer.java",
    "type": "method",
    "name": "mergeDuplicates",
    "code": "public void mergeDuplicates(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\n        Build build = model.getBuild();\n        if (build != null) {\n            List<Plugin> plugins = build.getPlugins();\n            Map<Object, Plugin> normalized = new LinkedHashMap<>(plugins.size() * 2);\n\n            for (Plugin plugin : plugins) {\n                Object key = plugin.getKey();\n                Plugin first = normalized.get(key);\n                if (first != null) {\n                    merger.mergePlugin(plugin, first);\n                }\n                normalized.put(key, plugin);\n            }\n\n            if (plugins.size() != normalized.size()) {\n                build.setPlugins(new ArrayList<>(normalized.values()));\n            }\n        }\n\n        /*\n         * NOTE: This is primarily to keep backward-compat with Maven 2.x which did not validate that dependencies are\n         * unique within a single POM. Upon multiple declarations, 2.x just kept the last one but retained the order of\n         * the first occurrence. So when we're in lenient/compat mode, we have to deal with such broken POMs and mimic\n         * the way 2.x works. When we're in strict mode, the removal of duplicates just saves other merging steps from\n         * aftereffects and bogus error messages.\n         */\n        List<Dependency> dependencies = model.getDependencies();\n        Map<String, Dependency> normalized = new LinkedHashMap<>(dependencies.size() * 2);\n\n        for (Dependency dependency : dependencies) {\n            normalized.put(dependency.getManagementKey(), dependency);\n        }\n\n        if (dependencies.size() != normalized.size()) {\n            model.setDependencies(new ArrayList<>(normalized.values()));\n        }\n    }",
    "comment": "Handles normalization of a model.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/TransportContext.java",
    "type": "method",
    "name": "TransportContext",
    "code": "public TransportContext(TransportConf conf, RpcHandler rpcHandler) {\n    this(conf, rpcHandler, false, false);\n  }",
    "comment": "Force to create MessageEncoder and MessageDecoder so that we can make sure they will be created\nbefore switching the current context class loader to ExecutorClassLoader.\n\nNetty's MessageToMessageEncoder uses Javassist to generate a matcher class and the\nimplementation calls \"Class.forName\" to check if this calls is already generated. If the\nfollowing two objects are created in \"ExecutorClassLoader.findClass\", it will cause\n\"ClassCircularityError\". This is because loading this Netty generated class will call\n\"ExecutorClassLoader.findClass\" to search this class, and \"ExecutorClassLoader\" will try to use\nRPC to load it and cause to load the non-exist matcher class again. JVM will report\n`ClassCircularityError` to prevent such infinite recursion. (See SPARK-17714)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/RocksDBTypeInfo.java",
    "type": "method",
    "name": "start",
    "code": "byte[] start(byte[] prefix, Object value) {\n      checkParent(prefix);\n      return (parent != null) ? buildKey(false, prefix, name, toKey(value))\n        : buildKey(name, toKey(value));\n    }",
    "comment": "The key where to start ascending iteration for entities whose value for the indexed field\nmatch the given value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "Description",
    "code": "private Description(Class<?> clazz, String displayName, Annotation... annotations) {\n        this(clazz, displayName, displayName, annotations);\n    }",
    "comment": "Describes a step in the test-running mechanism that goes so wrong no\nother description can be used (for example, an exception thrown from a Runner's\nconstructor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/sharding/src/main/java/com/iluwatar/sharding/ShardManager.java",
    "type": "method",
    "name": "removeShardById",
    "code": "public boolean removeShardById(final int shardId) {\n    if (shardMap.containsKey(shardId)) {\n      shardMap.remove(shardId);\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": "Remove a shard instance by provided Id.\n\n@param shardId Id of shard instance to remove.\n@return {@code true} if removed. {@code false} if the shardId is not existed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/sharding/src/main/java/com/iluwatar/sharding/Data.java",
    "type": "method",
    "name": "Data",
    "code": "public Data(final int key, final String value, final DataType type) {\n    this.key = key;\n    this.value = value;\n    this.type = type;\n  }",
    "comment": "Constructor of Data class.\n\n@param key data key\n@param value data value\n@param type data type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/Scope.java",
    "type": "method",
    "name": "withControlDependencies",
    "code": "public Scope withControlDependencies(Iterable<Operand<?>> controls) {\n    return new Scope(env, nameScope, controls);\n  }",
    "comment": "Returns a new scope where added operations will have the provided control dependencies.\n\n<p>Ops created with this scope will have a control edge from each of the provided controls. All\nother properties are inherited from the current scope.\n\n@param controls control dependencies for ops created with the returned scope\n@return a new scope with the provided control dependencies"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/FilePosition.java",
    "type": "method",
    "name": "from",
    "code": "public static FilePosition from(int line, int column) {\n\t\treturn new FilePosition(line, column);\n\t}",
    "comment": "Create a new {@code FilePosition} using the supplied {@code line} and\n\n@param line the line number; must be greater than zero\n@param column the column number; must be greater than zero\n@return a {@link FilePosition} with the given line and column numbers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/commander/src/main/java/com/iluwatar/commander/Service.java",
    "type": "method",
    "name": "Service",
    "code": "protected Service(Database db, Exception... exc) {\n    this.database = db;\n    this.exceptionsList = new ArrayList<>(List.of(exc));\n  }",
    "comment": "Service class is an abstract class extended by all services in this example. They all have a\npublic receiveRequest method to receive requests, which could also contain details of the user\nother than the implementation details (though we are not doing that here) and updateDb method\nwhich adds to their respective databases. There is a method to generate transaction/request id\nfor the transactions/requests, which are then sent back. These could be stored by the {@link\nCommander} class in a separate database for reference (though we are not doing that here)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "unescapeJava",
    "code": "protected static String unescapeJava(String str) {\n        if (str == null) {\n            return null;\n        }\n        int sz = str.length();\n        StringBuilder out = new StringBuilder(sz);\n        StringBuilder unicode = new StringBuilder(UNICODE_LEN);\n        boolean hadSlash = false;\n        boolean inUnicode = false;\n        for (int i = 0; i < sz; i++) {\n            char ch = str.charAt(i);\n            if (inUnicode) {\n                // if in unicode, then we're reading unicode\n                // values in somehow\n                unicode.append(ch);\n                if (unicode.length() == UNICODE_LEN) {\n                    // unicode now contains the four hex digits\n                    // which represents our unicode character\n                    try {\n                        int value = Integer.parseInt(unicode.toString(), HEX_RADIX);\n                        out.append((char) value);\n                        unicode.setLength(0);\n                        inUnicode = false;\n                        hadSlash = false;\n                    } catch (NumberFormatException nfe) {\n                        throw new IllegalArgumentException(\"Unable to parse unicode value: \" + unicode, nfe);\n                    }\n                }\n                continue;\n            }\n\n            if (hadSlash) {\n                // handle an escaped value\n                hadSlash = false;\n                switch (ch) {\n                    case '\\\\':\n                        out.append('\\\\');\n                        break;\n                    case '\\'':\n                        out.append('\\'');\n                        break;\n                    case '\\\"':\n                        out.append('\"');\n                        break;\n                    case 'r':\n                        out.append('\\r');\n                        break;\n                    case 'f':\n                        out.append('\\f');\n                        break;\n                    case 't':\n                        out.append('\\t');\n                        break;\n                    case 'n':\n                        out.append('\\n');\n                        break;\n                    case 'b':\n                        out.append('\\b');\n                        break;\n                    case 'u':\n                        // uh-oh, we're in unicode country....\n                        inUnicode = true;\n                        break;\n                    default:\n                        out.append(ch);\n                        break;\n                }\n                continue;\n            } else if (ch == '\\\\') {\n                hadSlash = true;\n                continue;\n            }\n            out.append(ch);\n        }\n\n        if (hadSlash) {\n            // then we're in the weird case of a \\ at the end of the\n            // string, let's output it anyway.\n            out.append('\\\\');\n        }\n\n        return out.toString();\n    }",
    "comment": "<p>Unescapes any Java literals found in the <code>String</code> to a\n<code>Writer</code>.</p> This is a slightly modified version of the\nStringEscapeUtils.unescapeJava() function in commons-lang that doesn't\ndrop escaped separators (i.e '\\,').\n\n@param str  the <code>String</code> to unescape, may be null\n@return the processed string\n@throws IllegalArgumentException if the Writer is <code>null</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/ClockSource.java",
    "type": "method",
    "name": "elapsedNanos",
    "code": "static long elapsedNanos(long startTime) {\n      return CLOCK.elapsedNanos0(startTime);\n   }",
    "comment": "Convert an opaque time-stamp returned by currentTime() into an\nelapsed time in milliseconds, based on the current instant in time.\n\n@param startTime an opaque time-stamp returned by an instance of this class\n@return the elapsed time between startTime and now in milliseconds"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "UpdateColumnPosition",
    "code": "private UpdateColumnPosition(String[] fieldNames, ColumnPosition position) {\n      this.fieldNames = fieldNames;\n      this.position = position;\n    }",
    "comment": "A TableChange to update the position of a field.\n<p>\nThe field names are used to find the field to update.\n<p>\nIf the field does not exist, the change must result in an {@link IllegalArgumentException}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/JUnitCore.java",
    "type": "method",
    "name": "run",
    "code": "public Result run(Request request) {\n        return run(request.getRunner());\n    }",
    "comment": "Run all the tests contained in <code>request</code>.\n\n@param request the request describing tests\n@return a {@link Result} describing the details of the test run and the failed tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/arrange-act-assert/src/main/java/com/iluwatar/arrangeactassert/Cash.java",
    "type": "method",
    "name": "plus",
    "code": "void plus(int addend) {\n    amount += addend;\n  }",
    "comment": "Arrange/Act/Assert (AAA) is a unit test pattern. In this simple example, we have a ({@link Cash})\nobject for plus, minus and counting amount."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/project/ProjectSorterTest.java",
    "type": "method",
    "name": "createParent",
    "code": "private Parent createParent(MavenProject project) {\n        return createParent(project.getGroupId(), project.getArtifactId(), project.getVersion());\n    }",
    "comment": "Test sorting projects by dependencies."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/MojoExecutionException.java",
    "type": "method",
    "name": "MojoExecutionException",
    "code": "public MojoExecutionException(String message, Exception cause) {\n        super(message, cause);\n    }",
    "comment": "Construct a new <code>MojoExecutionException</code> exception wrapping an underlying <code>Exception</code>\nand providing a <code>message</code>.\n\n@param message\n@param cause"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/event/ExecutionEventLogger.java",
    "type": "method",
    "name": "forkSucceeded",
    "code": "public void forkSucceeded(ExecutionEvent event) {\n        if (logger.isInfoEnabled()) {\n            init();\n            logger.info(\"\");\n\n            MessageBuilder buffer = builder().strong(\"<<< \");\n            append(buffer, event.getMojoExecution());\n            buffer.strong(\" < \");\n            appendForkInfo(buffer, event.getMojoExecution().getMojoDescriptor());\n            append(buffer, event.getProject());\n            buffer.strong(\" <<<\");\n\n            logger.info(buffer.toString());\n\n            logger.info(\"\");\n        }\n    }",
    "comment": "<pre>&lt;&lt;&lt; mojo-artifactId:version:goal (mojo-executionId) &lt; :forked-goal @ project-artifactId &lt;&lt;&lt;</pre>\n<pre>&lt;&lt;&lt; mojo-artifactId:version:goal (mojo-executionId) &lt; [lifecycle]phase @ project-artifactId &lt;&lt;&lt;</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4666CoreRealmImportTest.java",
    "type": "method",
    "name": "getTypes",
    "code": "private List<String> getTypes(Properties props) {\n        List<String> types = new ArrayList<>();\n        for (Object o : props.keySet()) {\n            String key = o.toString();\n            if (key.startsWith(\"core.\")) {\n                String type = key.substring(5);\n                if (props.getProperty(key, \"\").length() > 0) {\n                    types.add(type);\n                }\n            }\n        }\n        return types;\n    }",
    "comment": "types not in the core realm can't be exported/shared, so ignore those"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/simple/SimpleFluentIterable.java",
    "type": "method",
    "name": "last",
    "code": "public final FluentIterable<E> last(int count) {\n    var remainingElementsCount = getRemainingElementsCount();\n    var iterator = iterator();\n    var currentIndex = 0;\n    while (iterator.hasNext()) {\n      iterator.next();\n      if (currentIndex < remainingElementsCount - count) {\n        iterator.remove();\n      }\n      currentIndex++;\n    }\n\n    return this;\n  }",
    "comment": "Can be used to collect objects from the Iterable. Is a terminating operation.\n\n@param count defines the number of objects to return\n@return the same FluentIterable with a collection decimated to a maximum of 'count' last\nobjects"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java",
    "type": "method",
    "name": "constructFromClassWithInvalidBeforeEachDeclaration",
    "code": "void constructFromClassWithInvalidBeforeEachDeclaration() {\n\t\tClassTestDescriptor descriptor = new ClassTestDescriptor(uniqueId, TestCaseWithInvalidBeforeEachMethod.class,\n\t\t\tconfiguration);\n\n\t\tassertEquals(TestCaseWithInvalidBeforeEachMethod.class, descriptor.getTestClass());\n\t}",
    "comment": "Note: if we can instantiate the descriptor, then the invalid configuration\nwill not be reported during the test engine discovery phase."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/SingleTestExecutor.java",
    "type": "method",
    "name": "executeSafely",
    "code": "public TestExecutionResult executeSafely(Executable executable) {\n\t\ttry {\n\t\t\texecutable.execute();\n\t\t\treturn successful();\n\t\t}\n\t\tcatch (TestAbortedException e) {\n\t\t\treturn aborted(e);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(t);\n\t\t\treturn failed(t);\n\t\t}\n\t}",
    "comment": "Execute the supplied {@link Executable} and return a\n{@link TestExecutionResult} based on the outcome.\n\n<p>If the {@code Executable} throws an <em>unrecoverable</em> exception\n&mdash; for example, an {@link OutOfMemoryError} &mdash; this method will\nrethrow it.\n\n@param executable the test to be executed\n@return {@linkplain TestExecutionResult#aborted aborted} if the\n{@code Executable} throws a {@link TestAbortedException};\n{@linkplain TestExecutionResult#failed failed} if any other\n{@link Throwable} is thrown; and {@linkplain TestExecutionResult#successful\nsuccessful} otherwise"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/MultipleFailureException.java",
    "type": "method",
    "name": "MultipleFailureException",
    "code": "public MultipleFailureException(List<Throwable> errors) {\n        if (errors.isEmpty()) {\n            throw new IllegalArgumentException(\n                    \"List of Throwables must not be empty\");\n        }\n        this.fErrors = new ArrayList<Throwable>(errors.size());\n        for (Throwable error : errors) {\n            if (error instanceof AssumptionViolatedException) {\n                error = new TestCouldNotBeSkippedException((AssumptionViolatedException) error);\n            }\n            fErrors.add(error);\n        }\n    }",
    "comment": "Collects multiple {@code Throwable}s into one exception.\n\n@since 4.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "attributes",
    "code": "public Builder attributes(Map<String, String> attributes) {\n            this.attributes = attributes;\n            return this;\n        }",
    "comment": "Sets the attributes of the XML node.\n<p>\nThe provided map will be copied to ensure immutability.\n\n@param attributes the map of attribute names to values\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/layered-architecture/src/test/java/com/iluwatar/layers/view/CakeViewImplTest.java",
    "type": "method",
    "name": "setUp",
    "code": "void setUp() {\n    appender = new InMemoryAppender(CakeViewImpl.class);\n  }",
    "comment": "This class contains unit tests for the CakeViewImpl class. It tests the functionality of\nrendering cakes using the CakeViewImpl class. It also tests the logging functionality of the\nCakeViewImpl class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/composite/src/test/java/com/iluwatar/composite/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    Assertions.assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaChiSquareTestExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaChiSquareTestExample\")\n      .getOrCreate();\n\n    // $example on$\n    List<Row> data = Arrays.asList(\n      RowFactory.create(0.0, Vectors.dense(0.5, 10.0)),\n      RowFactory.create(0.0, Vectors.dense(1.5, 20.0)),\n      RowFactory.create(1.0, Vectors.dense(1.5, 30.0)),\n      RowFactory.create(0.0, Vectors.dense(3.5, 30.0)),\n      RowFactory.create(0.0, Vectors.dense(3.5, 40.0)),\n      RowFactory.create(1.0, Vectors.dense(3.5, 40.0))\n    );\n\n    StructType schema = new StructType(new StructField[]{\n\n    Dataset<Row> df = spark.createDataFrame(data, schema);\n    Row r = ChiSquareTest.test(df, \"features\", \"label\").head();\n    System.out.println(\"pValues: \" + r.get(0).toString());\n    System.out.println(\"degreesOfFreedom: \" + r.getList(1).toString());\n    System.out.println(\"statistics: \" + r.get(2).toString());\n\n    // $example off$\n\n    spark.stop();\n  }\n}",
    "comment": "An example for Chi-square hypothesis testing.\nRun with\n<pre>\nbin/run-example ml.JavaChiSquareTestExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/matchers/StacktracePrintingMatcher.java",
    "type": "method",
    "name": "StacktracePrintingMatcher",
    "code": "public StacktracePrintingMatcher(Matcher<T> throwableMatcher) {\n        this.throwableMatcher = throwableMatcher;\n    }",
    "comment": "A matcher that delegates to throwableMatcher and in addition appends the\nstacktrace of the actual Throwable in case of a mismatch."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "getInputTensor",
    "code": "TensorImpl getInputTensor(String inputName, String signatureKey) {\n    if (inputName == null) {\n      throw new IllegalArgumentException(\"Invalid input tensor name provided (null)\");\n    }\n    NativeSignatureRunnerWrapper signatureRunnerWrapper = getSignatureRunnerWrapper(signatureKey);\n    int subgraphIndex = signatureRunnerWrapper.getSubgraphIndex();\n    if (subgraphIndex == 0) {\n      int inputIndex = signatureRunnerWrapper.getInputIndex(inputName);\n      return getInputTensor(inputIndex);\n    }\n    return signatureRunnerWrapper.getInputTensor(inputName);\n  }",
    "comment": "Gets the input {@link TensorImpl} given the tensor name and method in the signature.\n\n@throws IllegalArgumentException if the input name is invalid."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelBuilder.java",
    "type": "method",
    "name": "loadDependencyManagement",
    "code": "private DependencyManagement loadDependencyManagement(Dependency dependency, Collection<String> importIds) {\n            String groupId = dependency.getGroupId();\n            String artifactId = dependency.getArtifactId();\n            String version = dependency.getVersion();\n\n            if (groupId == null || groupId.isEmpty()) {\n                add(\n                        Severity.ERROR,\n                        Version.BASE,\n                        \"'dependencyManagement.dependencies.dependency.groupId' for \" + dependency.getManagementKey()\n                                + \" is missing.\",\n                        dependency.getLocation(\"\"));\n                return null;\n            }\n            if (artifactId == null || artifactId.isEmpty()) {\n                add(\n                        Severity.ERROR,\n                        Version.BASE,\n                        \"'dependencyManagement.dependencies.dependency.artifactId' for \" + dependency.getManagementKey()\n                                + \" is missing.\",\n                        dependency.getLocation(\"\"));\n                return null;\n            }\n            if (version == null || version.isEmpty()) {\n                add(\n                        Severity.ERROR,\n                        Version.BASE,\n                        \"'dependencyManagement.dependencies.dependency.version' for \" + dependency.getManagementKey()\n                                + \" is missing.\",\n                        dependency.getLocation(\"\"));\n                return null;\n            }\n\n            String imported = groupId + ':' + artifactId + ':' + version;\n\n            if (importIds.contains(imported)) {\n                StringBuilder message =\n                        new StringBuilder(\"The dependencies of type=pom and with scope=import form a cycle: \");\n                for (String modelId : importIds) {\n                    message.append(modelId).append(\" -> \");\n                }\n                message.append(imported);\n                add(Severity.ERROR, Version.BASE, message.toString());\n                return null;\n            }\n\n            Model importModel = cache(\n                    repositories,\n                    groupId,\n                    artifactId,\n                    version,\n                    null,\n                    IMPORT,\n                    () -> doLoadDependencyManagement(dependency, groupId, artifactId, version, importIds));\n            DependencyManagement importMgmt = importModel != null ? importModel.getDependencyManagement() : null;\n            if (importMgmt == null) {\n                importMgmt = DependencyManagement.newInstance();\n            }\n\n            List<Exclusion> exclusions = dependency.getExclusions();\n            if (importMgmt != null && !exclusions.isEmpty()) {\n                List<Dependency> dependencies = importMgmt.getDependencies().stream()\n                        .filter(candidate -> exclusions.stream().noneMatch(exclusion -> match(exclusion, candidate)))\n                        .map(candidate -> addExclusions(candidate, exclusions))\n                        .collect(Collectors.toList());\n                importMgmt = importMgmt.withDependencies(dependencies);\n            }\n\n            return importMgmt;\n        }",
    "comment": "[MNG-5600] Dependency management import should support exclusions.\nDependency excluded from import."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/Encoders.java",
    "type": "method",
    "name": "encodedLength",
    "code": "public static int encodedLength(RoaringBitmap[] bitmaps) {\n      int totalLength = 4;\n      for (RoaringBitmap b : bitmaps) {\n        totalLength += Bitmaps.encodedLength(b);\n      }\n      return totalLength;\n    }",
    "comment": "Bitmap arrays are encoded with the number of bitmaps followed by per-Bitmap encoding.\n\n@since 3.1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/NumericHistogram.java",
    "type": "method",
    "name": "NumericHistogram",
    "code": "public NumericHistogram() {\n    nbins = 0;\n    nusedbins = 0;\n    bins = null;\n\n    // init the RNG for breaking ties in histogram merging. A fixed seed is specified here\n    // to aid testing, but can be eliminated to use a time-based seed (which would\n    // make the algorithm non-deterministic).\n    prng = new Random(31183);\n  }",
    "comment": "Creates a new histogram object. Note that the allocate() or merge()\nmethod must be called before the histogram can be used."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroPrimitives.java",
    "type": "method",
    "name": "setLongColumn",
    "code": "public void setLongColumn(java.lang.Long value) {\n    this.long_column = value;\n  }",
    "comment": "Sets the value of the 'long_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "setConf",
    "code": "public T setConf(String key, String value) {\n    checkNotNull(key, \"key\");\n    checkNotNull(value, \"value\");\n    checkArgument(key.startsWith(\"spark.\"), \"'key' must start with 'spark.'\");\n    builder.conf.put(key, value);\n    return self();\n  }",
    "comment": "Set a single configuration value for the application.\n\n@param key Configuration key.\n@param value The value to use.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroOptionalPrimitives.java",
    "type": "method",
    "name": "setMaybeBoolColumn",
    "code": "public void setMaybeBoolColumn(java.lang.Boolean value) {\n    this.maybe_bool_column = value;\n  }",
    "comment": "Sets the value of the 'maybe_bool_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcEnabled",
    "code": "public boolean sslRpcEnabled() {\n    return conf.getBoolean(\"spark.ssl.rpc.enabled\", false);\n  }",
    "comment": "Whether Secure (SSL/TLS) RPC (including Block Transfer Service) is enabled"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(short expected, short actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/NioDatagramChannel.java",
    "type": "method",
    "name": "DatagramPacket",
    "code": "public DatagramPacket(ByteBuffer data) {\n      this.data = data;\n    }",
    "comment": "Creates a container with underlying data.\n\n@param data the underlying message to be written on channel."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-distributed-tracing/order-microservice/src/main/java/com/iluwatar/order/microservice/OrderService.java",
    "type": "method",
    "name": "processOrder",
    "code": "public String processOrder() {\n    if (validateProduct() && processPayment()) {\n      return \"Order processed successfully\";\n    }\n    return \"Order processing failed\";\n  }",
    "comment": "Processes an order by calling {@link OrderService#validateProduct()} and {@link\nOrderService#processPayment()}.\n\n@return A string indicating whether the order was processed successfully or failed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaMaxAbsScalerExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaMaxAbsScalerExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n        RowFactory.create(0, Vectors.dense(1.0, 0.1, -8.0)),\n        RowFactory.create(1, Vectors.dense(2.0, 1.0, -4.0)),\n        RowFactory.create(2, Vectors.dense(4.0, 10.0, 8.0))\n    );\n    StructType schema = new StructType(new StructField[]{\n    Dataset<Row> dataFrame = spark.createDataFrame(data, schema);\n\n    MaxAbsScaler scaler = new MaxAbsScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\");\n\n    MaxAbsScalerModel scalerModel = scaler.fit(dataFrame);\n\n    Dataset<Row> scaledData = scalerModel.transform(dataFrame);\n    scaledData.select(\"features\", \"scaledFeatures\").show();\n\n    spark.stop();\n  }\n\n}",
    "comment": "$example on$\n$example off$\n$example on$\nCompute summary statistics and generate MaxAbsScalerModel\nrescale each feature to range [-1, 1].\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/types/CollationSupportSuite.java",
    "type": "method",
    "name": "buildDict",
    "code": "private Map<String, String> buildDict(String matching, String replace) {\n    Map<String, String> dict = new HashMap<>();\n    int i = 0, j = 0;\n    while (i < matching.length()) {\n      String rep = \"\\u0000\";\n      if (j < replace.length()) {\n        int repCharCount = Character.charCount(replace.codePointAt(j));\n        rep = replace.substring(j, j + repCharCount);\n        j += repCharCount;\n      }\n      int matchCharCount = Character.charCount(matching.codePointAt(i));\n      String matchStr = matching.substring(i, i + matchCharCount);\n      dict.putIfAbsent(matchStr, rep);\n      i += matchCharCount;\n    }\n    return dict;\n  }",
    "comment": "Verify the behaviour of the `StringTranslate` collation support class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "doesNotContainIsoControlCharacter",
    "code": "public static boolean doesNotContainIsoControlCharacter(String str) {\n\t\treturn !containsIsoControlCharacter(str);\n\t}",
    "comment": "Determine if the supplied {@link String} does not contain any ISO control\ncharacters.\n\n@param str the string to check; may be {@code null}\n@return {@code true} if the string does not contain an ISO control character\n@see #containsIsoControlCharacter(String)\n@see #containsWhitespace(String)\n@see Character#isISOControl(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/sharding/src/main/java/com/iluwatar/sharding/RangeShardManager.java",
    "type": "method",
    "name": "storeData",
    "code": "public int storeData(Data data) {\n    var shardId = allocateShard(data);\n    var shard = shardMap.get(shardId);\n    shard.storeData(data);\n    LOGGER.info(data + \" is stored in Shard \" + shardId);\n    return shardId;\n  }",
    "comment": "ShardManager with range strategy. This strategy groups related items together in the same shard,\nand orders them by shard key."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ArtifactInstaller.java",
    "type": "method",
    "name": "install",
    "code": "default void install(Session session, ProducedArtifact artifact) {\n        install(session, Collections.singletonList(artifact));\n    }",
    "comment": "@param session the repository session\n@param artifact the {@link ProducedArtifact} to install\n@throws ArtifactInstallerException in case of an error which can be a given artifact cannot be found or the\ninstallation has failed\n@throws IllegalArgumentException if a parameter {@code session} is {@code null} or\n{@code artifact} is {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/service/VehicleService.java",
    "type": "method",
    "name": "saveVehicle",
    "code": "public Vehicle saveVehicle(Vehicle vehicle) {\n    return vehicleRepository.save(vehicle);\n  }",
    "comment": "A method to save all the vehicles to the database.\n\n@param vehicle Vehicle bbject\n@see Vehicle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/collector/RequestPomCollectionStrategy.java",
    "type": "method",
    "name": "RequestPomCollectionStrategy",
    "code": "public RequestPomCollectionStrategy(ProjectsSelector projectsSelector) {\n        this.projectsSelector = projectsSelector;\n    }",
    "comment": "Strategy to collect projects based on the <code>-f</code> CLI parameter or the pom.xml in the working directory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java",
    "type": "method",
    "name": "merge",
    "code": "public void merge(Model target, Model source, boolean sourceDominant, Map<?, ?> hints) {\n        Objects.requireNonNull(target, \"target cannot be null\");\n\n        if (source == null) {\n            return;\n        }\n\n        Map<Object, Object> context = new HashMap<>();\n        if (hints != null) {\n            context.putAll(hints);\n        }\n\n        mergeModel(target, source, sourceDominant, context);\n    }",
    "comment": "Merges the specified source object into the given target object.\n\n@param target The target object whose existing contents should be merged with the source, must not be\n<code>null</code>.\n@param source The (read-only) source object that should be merged into the target object, may be\n<code>null</code>.\n@param sourceDominant A flag indicating whether either the target object or the source object provides the\ndominant data.\n@param hints A set of key-value pairs that customized merger implementations can use to carry domain-specific\ninformation along, may be <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-client-side-ui-composition/src/main/java/com/iluwatar/clientsideuicomposition/FrontendComponent.java",
    "type": "method",
    "name": "fetchData",
    "code": "public String fetchData(Map<String, String> params) {\n    try {\n      // Simulate delay in fetching data (e.g., network latency)\n      Thread.sleep(random.nextInt(1000));\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n    // Fetch and return the data based on the given parameters\n    return getData(params);\n  }",
    "comment": "Simulates asynchronous data fetching by introducing a random delay and then fetching the data\nbased on dynamic input.\n\n@param params a map of parameters that may affect the data fetching logic\n@return the data fetched by the frontend component"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/reporting/ReportEntry.java",
    "type": "method",
    "name": "from",
    "code": "public static ReportEntry from(String key, String value) {\n\t\tReportEntry reportEntry = new ReportEntry();\n\t\treportEntry.add(key, value);\n\t\treturn reportEntry;\n\t}",
    "comment": "Factory for creating a new {@code ReportEntry} from a key-value pair.\n@param value the value to publish; never {@code null} or blank"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/BlockStoreClient.java",
    "type": "method",
    "name": "RpcResponseCallback",
    "code": "CompletableFuture<Map<String, String[]>> hostLocalDirsCompletable) {\n    checkInit();\n    GetLocalDirsForExecutors getLocalDirsMessage = new GetLocalDirsForExecutors(appId, execIds);\n    try {\n      TransportClient client = clientFactory.createClient(host, port);\n      client.sendRpc(getLocalDirsMessage.toByteBuffer(), new RpcResponseCallback() {\n            logger.warn(\"Error while trying to get the host local dirs for {}\", t.getCause(),\n              MDC.of(LogKeys.EXECUTOR_IDS$.MODULE$, Arrays.toString(getLocalDirsMessage.execIds)));\n            hostLocalDirsCompletable.completeExceptionally(t);\n          }\n        }\n\n        @Override\n        public void onFailure(Throwable t) {\n          logger.warn(\"Error while trying to get the host local dirs for {}\", t.getCause(),\n            MDC.of(LogKeys.EXECUTOR_IDS$.MODULE$, Arrays.toString(getLocalDirsMessage.execIds)));\n          hostLocalDirsCompletable.completeExceptionally(t);\n        }\n      });",
    "comment": "Request the local disk directories for executors which are located at the same host with\nthe current BlockStoreClient(it can be ExternalBlockStoreClient or NettyBlockTransferService).\n\n@param host the host of BlockManager or ExternalShuffleService. It should be the same host\nwith current BlockStoreClient.\n@param port the port of BlockManager or ExternalShuffleService.\n@param execIds a collection of executor Ids, which specifies the target executors that we\nwant to get their local directories. There could be multiple executor Ids if\nBlockStoreClient is implemented by ExternalBlockStoreClient since the request\nhandler, ExternalShuffleService, can serve multiple executors on the same node.\nOr, only one executor Id if BlockStoreClient is implemented by\nNettyBlockTransferService.\n@param hostLocalDirsCompletable a CompletableFuture which contains a map from executor Id\nto its local directories if the request handler replies\nsuccessfully. Otherwise, it contains a specific error."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/tasks/TreePrinter.java",
    "type": "method",
    "name": "tab",
    "code": "private String tab(TreeNode node, boolean continuous) {\n\t\tif (node.children.size() > 0) {\n\t\t\treturn theme.blank() + theme.vertical();\n\t\t}\n\t\treturn (continuous ? theme.vertical() : theme.blank()) + theme.blank();\n\t}",
    "comment": "We might be the \"last\" node in this level, that means\n`continuous == false`, but still need to include a vertical\nbar for printing stack traces, messages and reports.\nSee https://github.com/junit-team/junit5/issues/1531"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/resources/mng-6071/src/test/java/com/mycompany/app/AppTest.java",
    "type": "method",
    "name": "shouldAnswerWithTrue",
    "code": "public void shouldAnswerWithTrue() {\n        URL resource = getClass().getResource(\"/\");\n        System.out.println(resource);\n        assertNotNull(resource);\n    }",
    "comment": "Unit test for simple App."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/StreamResponse.java",
    "type": "method",
    "name": "StreamResponse",
    "code": "public StreamResponse(String streamId, long byteCount, ManagedBuffer buffer) {\n    super(buffer, false);\n    this.streamId = streamId;\n    this.byteCount = byteCount;\n  }",
    "comment": "Response to {@link StreamRequest} when the stream has been successfully opened.\n<p>\nNote the message itself does not contain the stream data. That is written separately by the\nsender. The receiver is expected to set a temporary channel handler that will consume the\nnumber of bytes this message says the stream has."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/DynamicTestsDemo.java",
    "type": "method",
    "name": "dummy",
    "code": "DynamicTest dummy() { return null; }\n\tList<String> dynamicTestsWithInvalidReturnType() {\n\t\treturn Arrays.asList(\"Hello\");\n\t}",
    "comment": "tag::user_guide[]\nend::user_guide[]\n@formatter:off\ntag::user_guide[]\nThis method will not be executed but produce a warning\nend::user_guide[]\ntag::user_guide[]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/acyclic-visitor/src/main/java/com/iluwatar/acyclicvisitor/ConfigureForDosVisitor.java",
    "type": "method",
    "name": "visit",
    "code": "public void visit(Hayes hayes) {\n    LOGGER.info(hayes + \" used with Dos configurator.\");\n  }",
    "comment": "ConfigureForDosVisitor class implements both zoom's and hayes' visit method for Dos manufacturer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Float expected, Float actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java",
    "type": "method",
    "name": "methodBlock",
    "code": "protected Statement methodBlock(final FrameworkMethod method) {\n        Object test;\n        try {\n            test = new ReflectiveCallable() {\n            }.run();\n        } catch (Throwable e) {\n            return new Fail(e);\n        }\n\n        Statement statement = methodInvoker(method, test);\n        statement = possiblyExpectingExceptions(method, test, statement);\n        statement = withPotentialTimeout(method, test, statement);\n        statement = withBefores(method, test, statement);\n        statement = withAfters(method, test, statement);\n        statement = withRules(method, test, statement);\n        statement = withInterruptIsolation(statement);\n        return statement;\n    }",
    "comment": "Returns a Statement that, when executed, either returns normally if\n{@code method} passes, or throws an exception if {@code method} fails.\n\nHere is an outline of the default implementation:\n\n<ul>\n<li>Invoke {@code method} on the result of {@link #createTest(org.junit.runners.model.FrameworkMethod)}, and\nthrow any exceptions thrown by either operation.\n<li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@link Test#expected()}\nattribute, return normally only if the previous step threw an\nexception of the correct type, and throw an exception otherwise.\n<li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\ntimeout} attribute, throw an exception if the previous step takes more\nthan the specified number of milliseconds.\n<li>ALWAYS run all non-overridden {@code @Before} methods on this class\nand superclasses before any of the previous steps; if any throws an\nException, stop execution and pass the exception on.\n<li>ALWAYS run all non-overridden {@code @After} methods on this class\nand superclasses after any of the previous steps; all After methods are\nalways executed: exceptions thrown by previous steps are combined, if\nnecessary, with exceptions from After methods into a\n{@link MultipleFailureException}.\n<li>ALWAYS allow {@code @Rule} fields to modify the execution of the\nabove steps. A {@code Rule} may prevent all execution of the above steps,\nor add additional behavior before and after, or modify thrown exceptions.\nFor more information, see {@link TestRule}\n</ul>\n\nThis can be overridden in subclasses, either by overriding this method,\nor the implementations creating each sub-statement."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/Logger.java",
    "type": "method",
    "name": "warn",
    "code": "default void warn(@Nonnull String message, @Nullable Throwable error) {\n        log(Level.WARN, message, error);\n    }",
    "comment": "Logs a warning message with an associated exception.\n\n@param message the warning message to be logged\n@param error the associated exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/TensorImpl.java",
    "type": "method",
    "name": "copyTo",
    "code": "void copyTo(Object dst) {\n    if (dst == null) {\n      if (hasDelegateBufferHandle(nativeHandle)) {\n        return;\n      }\n      throw new IllegalArgumentException(\n          \"Null outputs are allowed only if the Tensor is bound to a buffer handle.\");\n    }\n    throwIfTypeIsIncompatible(dst);\n    throwIfDstShapeIsIncompatible(dst);\n    if (isBuffer(dst)) {\n      copyTo((Buffer) dst);\n    } else {\n      readMultiDimensionalArray(nativeHandle, dst);\n    }\n  }",
    "comment": "Copies the contents of the tensor to {@code dst}.\n\n@param dst the destination buffer, either an explicitly-typed array, a compatible {@link\nBuffer} or {@code null} iff the tensor has an underlying delegate buffer handle. If\nproviding a (multi-dimensional) array, its shape must match the tensor shape *exactly*. If\nproviding a {@link Buffer}, its capacity must be at least as large as the source tensor's\ncapacity.\n@throws IllegalArgumentException if {@code dst} is not compatible with the tensor (for example,\nmismatched data types or shapes)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/Car.java",
    "type": "method",
    "name": "Car",
    "code": "public Car(int year, String make, String model, int numDoors, int id) {\n    super(year, make, model, id);\n    if (numDoors <= 0) {\n      throw new IllegalArgumentException(\"Number of doors must be positive.\");\n    }\n    this.numDoors = numDoors;\n  }",
    "comment": "Constructs a Car object.\n\n@param year the manufacturing year\n@param make the make of the car\n@param model the model of the car\n@param numDoors the number of doors\n@param id the unique identifier for the car"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/DisableOnDebug.java",
    "type": "method",
    "name": "DisableOnDebug",
    "code": "public DisableOnDebug(TestRule rule) {\n        this(rule, ManagementFactory.getRuntimeMXBean()\n                .getInputArguments());\n    }",
    "comment": "Create a {@code DisableOnDebug} instance with the timeout specified in\nmilliseconds.\n\n@param rule to disable during debugging"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaDecisionTreeClassificationExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf sparkConf = new SparkConf().setAppName(\"JavaDecisionTreeClassificationExample\");\n    JavaSparkContext jsc = new JavaSparkContext(sparkConf);\n\n    String datapath = \"data/mllib/sample_libsvm_data.txt\";\n    JavaRDD<LabeledPoint> data = MLUtils.loadLibSVMFile(jsc.sc(), datapath).toJavaRDD();\n    JavaRDD<LabeledPoint>[] splits = data.randomSplit(new double[]{0.7, 0.3});\n}",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file.\nSplit the data into training and test sets (30% held out for testing)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeInMemorySorter.java",
    "type": "method",
    "name": "getUsableCapacity",
    "code": "private int getUsableCapacity() {\n    return (int) (array.size() / (radixSortSupport != null ? 2 : 1.5));\n  }",
    "comment": "Radix sort requires same amount of used memory as buffer, Tim sort requires\nhalf of the used memory as buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "buildCollation",
    "code": "protected Collation buildCollation() {\n        ULocale.Builder builder = new ULocale.Builder();\n        builder.setLocale(ICULocaleMap.get(locale));\n        if (caseSensitivity == CaseSensitivity.CS &&\n            accentSensitivity == AccentSensitivity.AS) {\n          builder.setUnicodeLocaleKeyword(\"ks\", \"level3\");\n        } else if (caseSensitivity == CaseSensitivity.CS &&\n            accentSensitivity == AccentSensitivity.AI) {\n          builder\n            .setUnicodeLocaleKeyword(\"ks\", \"level1\")\n            .setUnicodeLocaleKeyword(\"kc\", \"true\");\n        } else if (caseSensitivity == CaseSensitivity.CI &&\n            accentSensitivity == AccentSensitivity.AS) {\n          builder.setUnicodeLocaleKeyword(\"ks\", \"level2\");\n        } else if (caseSensitivity == CaseSensitivity.CI &&\n            accentSensitivity == AccentSensitivity.AI) {\n          builder.setUnicodeLocaleKeyword(\"ks\", \"level1\");\n        }\n        ULocale resultLocale = builder.build();\n        Collator collator = Collator.getInstance(resultLocale);\n        collator.freeze();\n\n        Comparator<UTF8String> comparator;\n        ToLongFunction<UTF8String> hashFunction;\n\n        if (spaceTrimming == SpaceTrimming.NONE) {\n          hashFunction = s -> (long) collator.getCollationKey(\n            s.toValidString()).hashCode();\n          comparator = (s1, s2) ->\n            collator.compare(s1.toValidString(), s2.toValidString());\n        } else {\n          comparator = (s1, s2) -> collator.compare(\n            applyTrimmingPolicy(s1, spaceTrimming).toValidString(),\n            applyTrimmingPolicy(s2, spaceTrimming).toValidString());\n          hashFunction = s -> (long) collator.getCollationKey(\n            applyTrimmingPolicy(s, spaceTrimming).toValidString()).hashCode();\n        }\n\n        return new Collation(\n          normalizedCollationName(),\n          PROVIDER_ICU,\n          collator,\n          comparator,\n          ICU_VERSION,\n          hashFunction,\n          (s1, s2) -> comparator.compare(s1, s2) == 0,\n          /* isUtf8BinaryType = */ false,\n          /* isUtf8LcaseType = */ false,\n          spaceTrimming != SpaceTrimming.NONE);\n      }",
    "comment": "Compute unicode locale keyword for all combinations of case/accent sensitivity.\nFreeze ICU collator to ensure thread safety."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java",
    "type": "method",
    "name": "executeTestsForClass",
    "code": "protected EngineExecutionResults executeTestsForClass(Class<?> testClass) {\n\t\treturn executeTests(selectClass(testClass));\n\t}",
    "comment": "Abstract base class for tests involving the {@link JupiterTestEngine}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java",
    "type": "method",
    "name": "rejectsModificationAfterClose",
    "code": "void rejectsModificationAfterClose() {\n\t\t\tstore.close();\n\t\t\tassertClosed();\n\n\t\t\tassertThrows(NamespacedHierarchicalStoreException.class, () -> store.put(namespace, key, value));\n\t\t\tassertThrows(NamespacedHierarchicalStoreException.class, () -> store.remove(namespace, key));\n\t\t\tassertThrows(NamespacedHierarchicalStoreException.class, () -> store.remove(namespace, key, int.class));\n\n\t\t\tassertThrows(NamespacedHierarchicalStoreException.class,\n\t\t\t\t() -> store.getOrComputeIfAbsent(namespace, key, k -> \"new\"));\n\t\t\tassertThrows(NamespacedHierarchicalStoreException.class,\n\t\t\t\t() -> store.getOrComputeIfAbsent(namespace, key, k -> \"new\", String.class));\n\t\t}",
    "comment": "Since key does not exist, an invocation of getOrComputeIfAbsent(...) will attempt to compute a new value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeOnSuccessFailingParameter",
    "code": "void cleanupModeOnSuccessFailingParameter() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(OnSuccessFailingParameterCase.class, \"testOnSuccessFailingParameter\",\n\t\t\t\t\t\t\"java.nio.file.Path\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(onSuccessFailingParameterDir).exists();\n\t\t}",
    "comment": "Ensure that ON_SUCCESS cleanup modes are obeyed for failing parameter tests.\n<p/>\nExpect the TempDir not to be cleaned up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuildingRequest.java",
    "type": "method",
    "name": "DefaultModelBuildingRequest",
    "code": "public DefaultModelBuildingRequest(ModelBuildingRequest request) {\n        setPomFile(request.getPomFile());\n        setModelSource(request.getModelSource());\n        setValidationLevel(request.getValidationLevel());\n        setProcessPlugins(request.isProcessPlugins());\n        setTwoPhaseBuilding(request.isTwoPhaseBuilding());\n        setLocationTracking(request.isLocationTracking());\n        setProfiles(request.getProfiles());\n        setActiveProfileIds(request.getActiveProfileIds());\n        setInactiveProfileIds(request.getInactiveProfileIds());\n        setSystemProperties(request.getSystemProperties());\n        setUserProperties(request.getUserProperties());\n        setBuildStartTime(request.getBuildStartTime());\n        setModelResolver(request.getModelResolver());\n        setModelBuildingListener(request.getModelBuildingListener());\n        setModelCache(request.getModelCache());\n    }",
    "comment": "Creates a shallow copy of the specified request.\n\n@param request The request to copy, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/tasks/StandardStreamsHandler.java",
    "type": "method",
    "name": "redirectStandardStreams",
    "code": "public void redirectStandardStreams(Path stdoutPath, Path stderrPath) {\n\t\tif (isSameFile(stdoutPath, stderrPath)) {\n\t\t\ttry {\n\t\t\t\tPrintStream commonStream = new PrintStream(Files.newOutputStream(stdoutPath), true);\n\t\t\t\tthis.stdout = commonStream;\n\t\t\t\tthis.stderr = commonStream;\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new JUnitException(\"Error redirecting stdout and stderr to file: \" + stdoutPath, ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (stdoutPath != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.stdout = new PrintStream(Files.newOutputStream(stdoutPath), true);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tthrow new JUnitException(\"Error redirecting stdout to file: \" + stdoutPath, ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (stderrPath != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.stderr = new PrintStream(Files.newOutputStream(stderrPath), true);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tthrow new JUnitException(\"Error redirecting stderr to file: \" + stderrPath, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.stdout != null) {\n\t\t\tSystem.setOut(this.stdout);\n\t\t}\n\t\tif (this.stderr != null) {\n\t\t\tSystem.setErr(this.stderr);\n\t\t}\n\t}",
    "comment": "Redirect standard output (stdout) and standard error (stderr) to the specified\nfile paths.\n\n<p>If the paths are the same, both streams are redirected to the same file.\n\n<p>The default charset is used for writing to the files.\n\n@param stdoutPath the file path for standard output, or {@code null} to\nindicate no redirection\n@param stderrPath the file path for standard error, or {@code null} to\nindicate no redirection"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DirectorySelector.java",
    "type": "method",
    "name": "getDirectory",
    "code": "public File getDirectory() {\n\t\treturn new File(this.path);\n\t}",
    "comment": "Get the selected directory as a {@link java.io.File}.\n\n@see #getPath()\n@see #getRawPath()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "addAppArgs",
    "code": "public T addAppArgs(String... args) {\n    for (String arg : args) {\n      checkNotNull(arg, \"arg\");\n      builder.appArgs.add(arg);\n    }\n    return self();\n  }",
    "comment": "Adds command line arguments for the application.\n\n@param args Arguments to pass to the application's main class.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertNull",
    "code": "public static void assertNull(Object object) {\n        Assert.assertNull(object);\n    }",
    "comment": "Asserts that an object is null. If it isn't an {@link AssertionError} is\nthrown.\nMessage contains: Expected: <null> but was: object\n\n@param object Object to check or <code>null</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/utils/src/main/java/org/apache/spark/network/util/JavaUtils.java",
    "type": "method",
    "name": "timeStringAsSec",
    "code": "public static long timeStringAsSec(String str) {\n    return timeStringAs(str, TimeUnit.SECONDS);\n  }",
    "comment": "Convert a time parameter such as (50s, 100ms, or 250us) to seconds for internal use. If\nno suffix is provided, the passed number is assumed to be in seconds."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/bitset/BitSetMethods.java",
    "type": "method",
    "name": "anySet",
    "code": "public static boolean anySet(Object baseObject, long baseOffset, long bitSetWidthInWords) {\n    long addr = baseOffset;\n    for (int i = 0; i < bitSetWidthInWords; i++, addr += WORD_SIZE) {\n      if (Platform.getLong(baseObject, addr) != 0) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "Returns {@code true} if any bit is set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/HiveSQLException.java",
    "type": "method",
    "name": "toCause",
    "code": "public static Throwable toCause(List<String> details) {\n    return toStackTrace(details, null, 0);\n  }",
    "comment": "Converts a flattened list of texts including the stack trace and the stack\ntraces of the nested causes into a {@link Throwable} object.\n@param details a flattened list of texts including the stack trace and the stack\ntraces of the nested causes\n@return        a {@link Throwable} object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/feature/JavaNormalizerSuite.java",
    "type": "method",
    "name": "normalizer",
    "code": "public void normalizer() {\n    JavaRDD<VectorIndexerSuite.FeatureData> points = jsc.parallelize(Arrays.asList(\n      new VectorIndexerSuite.FeatureData(Vectors.dense(0.0, -2.0)),\n      new VectorIndexerSuite.FeatureData(Vectors.dense(1.0, 3.0)),\n      new VectorIndexerSuite.FeatureData(Vectors.dense(1.0, 4.0))\n    ));\n    Dataset<Row> dataFrame = spark.createDataFrame(points, VectorIndexerSuite.FeatureData.class);\n    Normalizer normalizer = new Normalizer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"normFeatures\");\n\n    Dataset<Row> l2NormData = normalizer.transform(dataFrame, normalizer.p().w(2));\n    l2NormData.count();\n\n    Dataset<Row> lInfNormData =\n      normalizer.transform(dataFrame, normalizer.p().w(Double.POSITIVE_INFINITY));\n    lInfNormData.count();\n  }",
    "comment": "The tests are to check Java compatibility.\nNormalize each Vector using $L^2$ norm.\nNormalize each Vector using $L^\\infty$ norm."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Integer expected, Integer actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/component/src/main/java/com/iluwatar/component/GameObject.java",
    "type": "method",
    "name": "update",
    "code": "public void update(int e) {\n    inputComponent.update(this, e);\n    physicComponent.update(this);\n    graphicComponent.update(this);\n  }",
    "comment": "Updates the three components for objects based on key events.\n\n@param e key event from the player."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/MetricsEntry.java",
    "type": "method",
    "name": "MetricsEntry",
    "code": "private MetricsEntry(double value, String regression, BenchmarkResultType result) {\n    this.value = value;\n    this.regression = regression;\n    this.result = result;\n  }",
    "comment": "Helper class to store the metric value, the test target delegate regression compared with the\nreference delegate and the metric-level results based on the criteria.\n\n<p>An instance of {@link MetricsEntry} corresponds with each tested model metric and each pair of\ntest target delegate and reference delegate.\n\n<p>TODO(b/267429312): use AutoValue here to simplify the source code."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createDecimalType",
    "code": "public static DecimalType createDecimalType(int precision, int scale) {\n    return DecimalType$.MODULE$.apply(precision, scale);\n  }",
    "comment": "Creates a DecimalType by specifying the precision and scale."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoverySelectorIdentifier.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n\t\treturn String.format(\"%s:%s\", this.prefix, this.value);\n\t}",
    "comment": "Get the string representation of this identifier in the format\n{@code prefix:value}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/ClassSourceTests.java",
    "type": "method",
    "name": "createSerializableInstances",
    "code": "Stream<Serializable> createSerializableInstances() {\n\t\treturn Stream.of( //\n\t\t\tClassSource.from(\"class.source\"), //\n\t\t\tClassSource.from(\"class.and.position\", FilePosition.from(1, 2)), //\n\t\t\tClassSource.from(getClass()), //\n\t\t\tClassSource.from(getClass(), FilePosition.from(1, 2)) //\n\t\t);\n\t}",
    "comment": "Unit tests for {@link ClassSource}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "configurationParameters",
    "code": "public LauncherDiscoveryRequestBuilder configurationParameters(Map<String, String> configurationParameters) {\n\t\tPreconditions.notNull(configurationParameters, \"configuration parameters map must not be null\");\n\t\tconfigurationParameters.forEach(this::configurationParameter);\n\t\treturn this;\n\t}",
    "comment": "Add all supplied configuration parameters to the request.\n\n@param configurationParameters the map of configuration parameters to add;\nnever {@code null}\n@return this builder for method chaining\n@see #configurationParameter(String, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/ParameterResolutionUtilsTests.java",
    "type": "method",
    "name": "resolveConstructorArguments",
    "code": "void resolveConstructorArguments() {\n\t\tregister(new StringParameterResolver());\n\n\t\tClass<ConstructorInjectionTestCase> topLevelClass = ConstructorInjectionTestCase.class;\n\t\tObject[] arguments = resolveConstructorParameters(topLevelClass, null);\n\n\t\tassertThat(arguments).containsExactly(ENIGMA);\n\t}",
    "comment": "Unit tests for {@link ParameterResolutionUtils}.\n\n@since 5.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "setAppResource",
    "code": "public T setAppResource(String resource) {\n    checkNotNull(resource, \"resource\");\n    builder.appResource = resource;\n    return self();\n  }",
    "comment": "Set the main application resource. This should be the location of a jar file for Scala/Java\napplications, or a python script for PySpark applications.\n\n@param resource Path to the main application resource.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestExecutionListener.java",
    "type": "method",
    "name": "executionFinished",
    "code": "default void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {\n\t}",
    "comment": "Called when the execution of a leaf or subtree of the {@link TestPlan}\nhas finished, regardless of the outcome.\n\n<p>The {@link TestIdentifier} may represent a test or a container.\n\n<p>This method will only be called if the test or container has not\nbeen {@linkplain #executionSkipped skipped}.\n\n<p>This method will be called for a container {@code TestIdentifier}\n<em>after</em> all of its children have been\n{@linkplain #executionSkipped skipped} or have\n{@linkplain #executionFinished finished}.\n\n<p>The {@link TestExecutionResult} describes the result of the execution\nfor the supplied {@code TestIdentifier}. The result does not include or\naggregate the results of its children. For example, a container with a\nfailing test will be reported as {@link Status#SUCCESSFUL SUCCESSFUL} even\nif one or more of its children are reported as {@link Status#FAILED FAILED}.\n\n@param testIdentifier the identifier of the finished test or container\n@param testExecutionResult the (unaggregated) result of the execution for\nthe supplied {@code TestIdentifier}\n\n@see TestExecutionResult"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeRowWriter.java",
    "type": "method",
    "name": "zeroOutNullBytes",
    "code": "public void zeroOutNullBytes() {\n    for (int i = 0; i < nullBitsSize; i += 8) {\n      Platform.putLong(getBuffer(), startingOffset + i, 0L);\n    }\n  }",
    "comment": "Clears out null bits.  This should be called before we write a new row to row buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/MavenSessionBuilderSupplier.java",
    "type": "method",
    "name": "getArtifactTypeRegistry",
    "code": "protected ArtifactTypeRegistry getArtifactTypeRegistry() {\n        DefaultArtifactTypeRegistry stereotypes = new DefaultArtifactTypeRegistry();\n        new DefaultTypeProvider().types().forEach(stereotypes::add);\n        return stereotypes;\n    }",
    "comment": "This method produces \"surrogate\" type registry that is static: it aims users that want to use\nMaven-Resolver without involving Maven Core and related things.\n<p>\nThis type registry is NOT used by Maven Core: Maven replaces it during Session creation with a type registry\nthat supports extending it (i.e. via Maven Extensions).\n<p>\nImportant: this \"static\" list of types should be in-sync with core provided types."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "setSystemProperties",
    "code": "public DefaultProfileActivationContext setSystemProperties(Map<String, String> systemProperties) {\n        this.systemProperties = unmodifiable(systemProperties);\n        return this;\n    }",
    "comment": "Sets the system properties to use for interpolation and profile activation. The system properties are collected\nfrom the runtime environment like {@link System#getProperties()} and environment variables.\n\n@param systemProperties The system properties, may be {@code null}.\n@return This context, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationContextProvider.java",
    "type": "method",
    "name": "mayReturnZeroClassTemplateInvocationContexts",
    "code": "default boolean mayReturnZeroClassTemplateInvocationContexts(ExtensionContext context) {\n\t\treturn false;\n\t}",
    "comment": "Signal that this provider may provide zero\n{@linkplain ClassTemplateInvocationContext invocation contexts} for\nthe class template represented by the supplied {@code context}.\n\n<p>If this method returns {@code false} (which is the default) and the\nprovider returns an empty stream from\n{@link #provideClassTemplateInvocationContexts}, this will be considered\nan execution error. Override this method to return {@code true} to ignore\nthe absence of invocation contexts for this provider.\n\n@param context the extension context for the class template\nabout to be invoked; never {@code null}\n@return {@code true} to allow zero contexts, {@code false} to fail\nexecution in case of zero contexts"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "createResult",
    "code": "protected TestResult createResult() {\n        return new TestResult();\n    }",
    "comment": "Creates a default TestResult object.\n\n@see TestResult"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-idempotent-consumer/src/main/java/com/iluwatar/idempotentconsumer/RequestService.java",
    "type": "method",
    "name": "start",
    "code": "public Request start(UUID uuid) {\n    Optional<Request> optReq = requestRepository.findById(uuid);\n    if (optReq.isEmpty()) {\n      throw new RequestNotFoundException(uuid);\n    }\n    return requestRepository.save(requestStateMachine.next(optReq.get(), Request.Status.STARTED));\n  }",
    "comment": "Starts the Request assigned with the given UUID.\n\n@param uuid The unique identifier for the Request.\n@return The started Request.\n@throws RequestNotFoundException if a Request with the given UUID is not found."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/ArtifactResolutionRequest.java",
    "type": "method",
    "name": "setCache",
    "code": "public ArtifactResolutionRequest setCache(RepositoryCache cache) {\n        return this;\n    }",
    "comment": "Used by Tycho and will break users and force them to upgrade to Maven 3.1 so we should really leave\nthis here, possibly indefinitely."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/CollectionUtils.java",
    "type": "method",
    "name": "isConvertibleToStream",
    "code": "public static boolean isConvertibleToStream(Class<?> type) {\n\t\tif (type == null || type == void.class) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (Stream.class.isAssignableFrom(type)//\n\t\t\t\t|| DoubleStream.class.isAssignableFrom(type)//\n\t\t\t\t|| IntStream.class.isAssignableFrom(type)//\n\t\t\t\t|| LongStream.class.isAssignableFrom(type)//\n\t\t\t\t|| Iterable.class.isAssignableFrom(type)//\n\t\t\t\t|| Iterator.class.isAssignableFrom(type)//\n\t\t\t\t|| Object[].class.isAssignableFrom(type)//\n\t\t\t\t|| (type.isArray() && type.getComponentType().isPrimitive()));\n\t}",
    "comment": "Determine if an instance of the supplied type can be converted into a\n{@code Stream}.\n\n<p>If this method returns {@code true}, {@link #toStream(Object)} can\nsuccessfully convert an object of the specified type into a stream. See\n{@link #toStream(Object)} for supported types.\n\n@param type the type to check; may be {@code null}\n@return {@code true} if an instance of the type can be converted into a stream\n@since 1.9.1\n@see #toStream(Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionConfiguration.java",
    "type": "method",
    "name": "getSaturatePredicate",
    "code": "default Predicate<? super ForkJoinPool> getSaturatePredicate() {\n\t\treturn null;\n\t}",
    "comment": "Get the saturate predicate to be used for the execution's {@link ForkJoinPool}.\n@return the saturate predicate to be passed to the {@code ForkJoinPool} constructor; may be {@code null}\n@since 1.9\n@see ForkJoinPool#ForkJoinPool(int, ForkJoinPool.ForkJoinWorkerThreadFactory, Thread.UncaughtExceptionHandler,\nboolean, int, int, int, Predicate, long, TimeUnit)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/BenchmarkAccuracyImpl.java",
    "type": "method",
    "name": "benchmark",
    "code": "public void benchmark(Context context, String[] tfliteSettingsJsonFiles) {\n    Activity activity = (Activity) context;\n    if (!benchmarkInternal(context.getApplicationContext(), tfliteSettingsJsonFiles)) {\n      Log.e(TAG, \"Failed to complete accuracy benchmark.\");\n    }\n    activity.finish();\n  }",
    "comment": "Impl class for Delegate Performance Accuracy Benchmark.\n\n<p>It performs accuracy benchmark tests via TFLite MiniBenchmark based on the input arguments.\nPlease check the test example in\ntensorflow/lite/tools/benchmark/experimental/delegate_performance/android/README.md.\n\n<p>Generates a PASS/PASS_WITH_WARNING/FAIL result.\n\n<ul>\n<li>PASS: The test target delegate passed the embedded metric thresholds in all models.\n<li>PASS_WITH_WARNING: Both the test target delegate and the reference delegates breached the\nembedded metric thresholds.\n<li>FAIL: The test target delegate failed at least 1 embedded metric threshold in the models,\nand at least 1 reference delegate passed the embedded metric thresholds in all models.\n</ul>\n\n<p>Generates below list of files to describe the benchmark results under\ndelegate_performance_result/accuracy folder in the app files directory.\n\n<ul>\n<li>1. delegate_performance_result/accuracy/report.csv: the performance of each acceleration\nconfiguration and relative performance differences as percentages in CSV.\n<li>2. delegate_performance_result/accuracy/report.json: detailed performance results. The file\ncontains the metric-level, delegate-level and model-level results and the raw metric\noutputs from the native layer in JSON.\n<li>3. delegate_performance_result/accuracy/report.html: the performance of each acceleration\nconfiguration and relative performance differences as percentages in HTML.\n</ul>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/AlbumPage.java",
    "type": "method",
    "name": "navigateToPage",
    "code": "public AlbumPage navigateToPage() {\n    try {\n      page = this.webClient.getPage(PAGE_URL);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return this;\n  }",
    "comment": "Navigates to the album page\n\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "create",
    "code": "public static <T> Tensor<T> create(Object obj, Class<T> type) {\n    DataType dtype = DataType.fromClass(type);\n    if (!objectCompatWithType(obj, dtype)) {\n      throw new IllegalArgumentException(\n          \"DataType of object does not match T (expected \"\n              + dtype\n              + \", got \"\n              + dataTypeOf(obj)\n              + \")\");\n    }\n    return (Tensor<T>) create(obj, dtype);\n  }",
    "comment": "Creates a Tensor from a Java object.\n\n<p>A {@code Tensor} is a multi-dimensional array of elements of a limited set of types. Not all\nJava objects can be converted to a {@code Tensor}. In particular, the argument {@code obj} must\nbe either a primitive (float, double, int, long, boolean, byte) or a multi-dimensional array of\none of those primitives. The argument {@code type} specifies how to interpret the first\nargument as a TensorFlow type. For example:\n\n<pre>{@code\n// Valid: A 64-bit integer scalar.\nTensor<Long> s = Tensor.create(42L, Long.class);\n\n// Valid: A 3x2 matrix of floats.\nfloat[][] matrix = new float[3][2];\nTensor<Float> m = Tensor.create(matrix, Float.class);\n\n// Invalid: Will throw an IllegalArgumentException as an arbitrary Object\n// does not fit into the TensorFlow type system.\nTensor<?> o = Tensor.create(new Object())\n\n// Invalid: Will throw an IllegalArgumentException since there are\n// a differing number of elements in each row of this 2-D array.\nint[][] twoD = new int[2][];\ntwoD[0] = new int[1];\ntwoD[1] = new int[2];\nTensor<Integer> x = Tensor.create(twoD, Integer.class);\n}</pre>\n\n{@link String}-typed Tensors are multi-dimensional arrays of arbitrary byte sequences, so can\nbe initialized from arrays of {@code byte[]} elements. For example:\n\n<pre>{@code\n// Valid: A String tensor.\nTensor<String> s = Tensor.create(new byte[]{1, 2, 3}, String.class);\n\n@param obj The object to convert to a {@code Tensor<T>}. Note that whether it is compatible\nwith the type T is not checked by the type system. For type-safe creation of tensors, use\n{@link Tensors}.\n@param type The class object representing the type T.\n@throws IllegalArgumentException if {@code obj} is not compatible with the TensorFlow type\nsystem."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Long unexpected, Long actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/AssumptionsDemo.java",
    "type": "method",
    "name": "testInAllEnvironments",
    "code": "void testInAllEnvironments() {\n\t\tassumingThat(\"CI\".equals(System.getenv(\"ENV\")),\n\t\t\t() -> {\n\t\t\t\tassertEquals(2, calculator.divide(4, 2));\n\t\t\t});\n\n\t\tassertEquals(42, calculator.multiply(6, 7));\n\t}",
    "comment": "perform these assertions only on the CI server\nperform these assertions in all environments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "error",
    "code": "default MessageBuilder error(Object message) {\n        return style(\".\" + Constants.MAVEN_STYLE_ERROR_NAME + \":-\" + Constants.MAVEN_STYLE_ERROR_DEFAULT, message);\n    }",
    "comment": "Append message content in error style.\nBy default, bold red\n\n@param message the message to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-di/src/main/java/org/apache/maven/di/Key.java",
    "type": "method",
    "name": "getTypeParameter",
    "code": "private Type getTypeParameter() {\n        Type typeArgument = ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n        Object outerInstance = ReflectionUtils.getOuterClassInstance(this);\n        return outerInstance != null\n                ? Types.bind(typeArgument, Types.getAllTypeBindings(outerInstance.getClass()))\n                : typeArgument;\n    }",
    "comment": "this cannot possibly fail so not even a check here\n\t\t// the outer instance is null in static context"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "maxChunksBeingTransferred",
    "code": "public long maxChunksBeingTransferred() {\n    return conf.getLong(\"spark.shuffle.maxChunksBeingTransferred\", Long.MAX_VALUE);\n  }",
    "comment": "The max number of chunks allowed to be transferred at the same time on shuffle service.\nNote that new incoming connections will be closed when the max number is hit. The client will\nretry according to the shuffle retry configs (see `spark.shuffle.io.maxRetries` and\n`spark.shuffle.io.retryWait`), if those limits are reached the task will fail with fetch\nfailure."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "split",
    "code": "private UTF8String[] split(String delimiter, int limit) {\n    if (limit == 0) {\n      limit = -1;\n    }\n    String[] splits = toString().split(delimiter, limit);\n    UTF8String[] res = new UTF8String[splits.length];\n    for (int i = 0; i < res.length; i++) {\n      res[i] = fromString(splits[i]);\n    }\n    return res;\n  }",
    "comment": "Java String's split method supports \"ignore empty string\" behavior when the limit is 0\nwhereas other languages do not. To avoid this java specific behavior, we fall back to\n-1 when the limit is 0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-log-aggregation/src/main/java/com/iluwatar/logaggregation/CentralLogStore.java",
    "type": "method",
    "name": "storeLog",
    "code": "public void storeLog(LogEntry logEntry) {\n    if (logEntry == null) {\n      LOGGER.error(\"Received null log entry. Skipping.\");\n      return;\n    }\n    logs.offer(logEntry);\n  }",
    "comment": "Stores the given log entry into the central log store.\n\n@param logEntry The log entry to store."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/layered-architecture/src/test/java/com/iluwatar/layers/exception/CakeBakingExceptionTest.java",
    "type": "method",
    "name": "testConstructor",
    "code": "void testConstructor() {\n    final var exception = new CakeBakingException();\n    assertNull(exception.getMessage(), \"The message should be null for the default constructor.\");\n    assertNull(exception.getCause(), \"The cause should be null for the default constructor.\");\n  }",
    "comment": "Tests the default constructor of {@link CakeBakingException}. Ensures that an exception created\nwith the default constructor has {@code null} as its message and cause."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaDatasetSuite.java",
    "type": "method",
    "name": "testTypedFilterPreservingSchema",
    "code": "public void testTypedFilterPreservingSchema() {\n    Dataset<Long> ds = spark.range(10);\n    Dataset<Long> ds2 = ds.filter((FilterFunction<Long>) value -> value > 3);\n    Assertions.assertEquals(ds.schema(), ds2.schema());\n  }",
    "comment": "SPARK-15632: typed filter should preserve the underlying logical schema"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(char[] expected, char[] actual, Supplier<String> messageSupplier) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} char arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/converter/src/test/java/com/iluwatar/converter/ConverterTest.java",
    "type": "method",
    "name": "testCustomConverter",
    "code": "void testCustomConverter() {\n    var converter =\n        new Converter<UserDto, User>(\n            userDto ->\n                new User(\n                    userDto.firstName(),\n                    userDto.lastName(),\n                    userDto.active(),\n                    String.valueOf(new Random().nextInt())),\n            user ->\n                new UserDto(\n                    user.firstName(),\n                    user.lastName(),\n                    user.active(),\n                    user.firstName().toLowerCase()\n                        + user.lastName().toLowerCase()\n                        + \"@whatever.com\"));\n    var u1 = new User(\"John\", \"Doe\", false, \"12324\");\n    var userDto = converter.convertFromEntity(u1);\n    assertEquals(\"johndoe@whatever.com\", userDto.email());\n  }",
    "comment": "Tests the custom users converter. Thanks to Java8 lambdas, converter can be easily and cleanly\ninstantiated allowing various different conversion strategies to be implemented."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room/java/com/example/android/persistence/migrations/User.java",
    "type": "method",
    "name": "User",
    "code": "public User(String userName) {\n        // DO NOT USE Integer Random values for primary keys.\n        // This is using an Integer to showcase a WRONG implementation that has to be fixed\n        // afterwards by updating the schema.\n        // The ID is updated to a UUID String in the room3 flavor.\n        mId = new Random(Integer.MAX_VALUE).nextInt();\n        mUserName = userName;\n    }",
    "comment": "Immutable model class for a User and entity in the Room database."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/actor-model/src/main/java/com/iluwatar/actormodel/Actor.java",
    "type": "method",
    "name": "send",
    "code": "public void send(Message message) {\n    mailbox.add(message); // Add message to queue\n  }",
    "comment": "rather than being cached in a thread's local memory. To make it consistent to all Actors"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/test/java/org/apache/maven/api/MonotonicClockTest.java",
    "type": "method",
    "name": "testRapidCalls",
    "code": "void testRapidCalls() {\n        Instant[] instants = new Instant[1000];\n        for (int i = 0; i < instants.length; i++) {\n            instants[i] = MonotonicClock.now();\n        }\n\n        for (int i = 1; i < instants.length; i++) {\n            assertTrue(\n                    instants[i].compareTo(instants[i - 1]) >= 0,\n                    \"Time should never go backwards even with rapid successive calls\");\n        }\n    }",
    "comment": "Verify monotonic behavior across all measurements"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/DiscoveryIssueReporter.java",
    "type": "method",
    "name": "alwaysSatisfied",
    "code": "static <T> Condition<T> alwaysSatisfied() {\n\t\t\treturn __ -> true;\n\t\t}",
    "comment": "Create a {@link Condition} that is always satisfied."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/DebugResolutionListener.java",
    "type": "method",
    "name": "manageArtifactVersion",
    "code": "public void manageArtifactVersion(Artifact artifact, Artifact replacement) {\n        if (!replacement.getVersion().equals(artifact.getVersion())) {\n            String msg = indent + artifact + \" (applying version: \" + replacement.getVersion() + \")\";\n            logger.debug(msg);\n        }\n    }",
    "comment": "only show msg if a change is actually taking place"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-distributed-tracing/order-microservice/src/main/java/com/iluwatar/order/microservice/OrderController.java",
    "type": "method",
    "name": "OrderController",
    "code": "public OrderController(final OrderService orderService) {\n    this.orderService = orderService;\n  }",
    "comment": "Constructor to inject OrderService.\n\n@param orderService the service to process orders"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/server/HiveServer2.java",
    "type": "method",
    "name": "init",
    "code": "public synchronized void init(HiveConf hiveConf) {\n    cliService = new CLIService(this);\n    addService(cliService);\n    if (isHTTPTransportMode(hiveConf)) {\n      thriftCLIService = new ThriftHttpCLIService(cliService);\n    } else {\n      thriftCLIService = new ThriftBinaryCLIService(cliService);\n    }\n    addService(thriftCLIService);\n    super.init(hiveConf);\n\n    ShutdownHookManager.addShutdownHook(\n        new AbstractFunction0<BoxedUnit>() {\n              LOG.warn(\"Ignoring Exception while stopping Hive Server from shutdown hook\",\n                  e);\n            }\n            return BoxedUnit.UNIT;\n          }",
    "comment": "Add a shutdown hook for catching SIGTERM & SIGINT\nthis must be higher than the Hadoop Filesystem priority of 10,\nwhich the default priority is.\nThe signature of the callback must match that of a scala () -> Unit\nfunction"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/regression/JavaRidgeRegressionSuite.java",
    "type": "method",
    "name": "generateRidgeData",
    "code": "private static List<LabeledPoint> generateRidgeData(int numPoints, int numFeatures, double std) {\n    Random random = new Random(42);\n    double[] w = new double[numFeatures];\n    for (int i = 0; i < w.length; i++) {\n      w[i] = random.nextDouble() - 0.5;\n    }\n    return LinearDataGenerator.generateLinearInputAsList(0.0, w, numPoints, 42, std);\n  }",
    "comment": "Pick weights as random values distributed uniformly in [-0.5, 0.5]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/DependencyResolverRequest.java",
    "type": "method",
    "name": "managedDependency",
    "code": "public DependencyResolverRequestBuilder managedDependency(@Nullable DependencyCoordinates managedDependency) {\n            if (managedDependency != null) {\n                if (this.managedDependencies.isEmpty()) {\n                    this.managedDependencies = new ArrayList<>();\n                }\n                this.managedDependencies.add(managedDependency);\n            }\n            return this;\n        }",
    "comment": "Adds the specified managed dependency.\n\n@param managedDependency The managed dependency to add, may be {@code null} in which case the call\nwill have no effect.\n@return this request for chaining, never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/rules/RuleMemberValidator.java",
    "type": "method",
    "name": "validate",
    "code": "public void validate(TestClass target, List<Throwable> errors) {\n        List<? extends FrameworkMember<?>> members = methods ? target.getAnnotatedMethods(annotation)\n                : target.getAnnotatedFields(annotation);\n\n        for (FrameworkMember<?> each : members) {\n            validateMember(each, errors);\n        }\n    }",
    "comment": "Validate the {@link org.junit.runners.model.TestClass} and adds reasons\nfor rejecting the class to a list of errors.\n\n@param target the {@code TestClass} to validate.\n@param errors the list of errors."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "appendStruct",
    "code": "public final int appendStruct(boolean isNull) {\n    if (isNull) {\n      // This is the same as appendNull but without the assertion for struct types\n      reserve(elementsAppended + 1);\n      putNull(elementsAppended);\n      elementsAppended++;\n      for (WritableColumnVector c: childColumns) {\n        if (c.type instanceof StructType || c.type instanceof VariantType) {\n          c.appendStruct(true);\n        } else {\n          c.appendNull();\n        }\n      }\n    } else {\n      appendNotNull();\n    }\n    return elementsAppended;\n  }",
    "comment": "Appends a NULL struct. This *has* to be used for structs instead of appendNull() as this\nrecursively appends a NULL to its children.\nWe don't have this logic as the general appendNull implementation to optimize the more\ncommon non-struct case."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom/java/com/example/android/persistence/migrations/UserDaoTest.java",
    "type": "method",
    "name": "updateAndGetUser",
    "code": "public void updateAndGetUser() {\n        mDatabase.userDao().insertUser(USER);\n\n        User updatedUser = new User(USER.getId(), \"new username\");\n        mDatabase.userDao().insertUser(updatedUser);\n\n        User dbUser = mDatabase.userDao().getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), \"new username\");\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are updating the name of the user\nThe retrieved user has the updated username"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/DisabledIfSystemPropertyConditionTests.java",
    "type": "method",
    "name": "getExecutionCondition",
    "code": "protected ExecutionCondition getExecutionCondition() {\n\t\treturn new DisabledIfSystemPropertyCondition();\n\t}",
    "comment": "Unit tests for {@link DisabledIfSystemPropertyCondition}.\n\n<p>Note that test method names MUST match the test method names in\n{@link DisabledIfSystemPropertyIntegrationTests}.\n\n@since 5.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/OutputMode.java",
    "type": "method",
    "name": "Append",
    "code": "public static OutputMode Append() {\n    return InternalOutputModes.Append$.MODULE$;\n  }",
    "comment": "OutputMode in which only the new rows in the streaming DataFrame/Dataset will be\nwritten to the sink. This output mode can be only be used in queries that do not\ncontain any aggregation.\n\n@since 2.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/subpackage/SubclassedAssumptionsTests.java",
    "type": "method",
    "name": "assumeTrueWithBooleanTrue",
    "code": "void assumeTrueWithBooleanTrue() {\n\t\tString foo = null;\n\t\ttry {\n\t\t\tassumeTrue(true);\n\t\t\tfoo = \"foo\";\n\t\t}\n\t\tfinally {\n\t\t\tassertEquals(\"foo\", foo);\n\t\t}\n\t}",
    "comment": "Tests which verify that {@link Assumptions} can be subclassed.\n\n@since 5.3"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/NumericHistogram.java",
    "type": "method",
    "name": "getBin",
    "code": "public Coord getBin(int b) {\n    return bins.get(b);\n  }",
    "comment": "Returns a particular histogram bin."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/streaming/JavaStructuredComplexSessionization.java",
    "type": "method",
    "name": "setEvents",
    "code": "public void setEvents(List<SessionEvent> events) {\n      if (events.isEmpty()) {\n        throw new IllegalArgumentException(\"events should not be empty!\");\n      }\n\n      List<SessionEvent> sorted = new ArrayList<>(events);\n      sorted.sort(Comparator.comparingLong(event -> event.startTimestamp.getTime()));\n\n      boolean eventCloseSessionExistBeforeLastEvent = sorted\n          .stream()\n          .limit(sorted.size() - 1)\n          .anyMatch(e -> e.eventType == EventTypes.CLOSE_SESSION);\n\n      if (eventCloseSessionExistBeforeLastEvent) {\n        throw new IllegalStateException(\"CLOSE_SESSION event cannot be placed except \" +\n            \"the last event!\");\n      }\n\n      this.events = sorted;\n    }",
    "comment": "`events` should not be empty, and be sorted by start time"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "allocateIntBuffer",
    "code": "public static IntBuffer allocateIntBuffer(int numElements) {\n    return ByteBuffer.allocateDirect(numElements * INT_SIZE_BYTES)\n        .order(ByteOrder.nativeOrder())\n        .asIntBuffer();\n  }",
    "comment": "Allocates a new direct {@link java.nio.IntBuffer} with native byte order with specified\n\n@param numElements capacity (number of elements) of result buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineIdValidator.java",
    "type": "method",
    "name": "getLogger",
    "code": "private static Logger getLogger() {\n\t\treturn LoggerFactory.getLogger(EngineIdValidator.class);\n\t}",
    "comment": "Not a constant to avoid problems with building GraalVM native images"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkSubmitCommandBuilder.java",
    "type": "method",
    "name": "findExamplesAppJar",
    "code": "private String findExamplesAppJar() {\n    boolean isTesting = \"1\".equals(getenv(\"SPARK_TESTING\"));\n    if (isTesting) {\n      return SparkLauncher.NO_RESOURCE;\n    } else {\n      for (String exampleJar : findExamplesJars()) {\n        if (new File(exampleJar).getName().startsWith(\"spark-examples\")) {\n      }\n      throw new IllegalStateException(\"Failed to find examples' main app jar.\");\n    }\n  }\n\n  private List<String> findExamplesJars() {\n    boolean isTesting = \"1\".equals(getenv(\"SPARK_TESTING\"));\n    List<String> examplesJars = new ArrayList<>();\n    String sparkHome = getSparkHome();\n\n    File jarsDir;\n    if (new File(sparkHome, \"RELEASE\").isFile()) {\n      jarsDir = new File(sparkHome,\n        String.format(\"examples/target/scala-%s/jars\", getScalaVersion()));\n    }\n\n    boolean foundDir = jarsDir.isDirectory();\n    checkState(isTesting || foundDir, \"Examples jars directory '%s' does not exist.\",\n        jarsDir.getAbsolutePath());\n\n    if (foundDir) {\n      for (File f: jarsDir.listFiles()) {\n        examplesJars.add(f.getAbsolutePath());\n      }\n    }\n    return examplesJars;\n  }\n\n  private class OptionParser extends SparkSubmitOptionParser {\n\n    boolean isSpecialCommand = false;\n    private final boolean errorOnUnknownArgs;\n\n    OptionParser(boolean errorOnUnknownArgs) {\n      this.errorOnUnknownArgs = errorOnUnknownArgs;\n    }\n\n    @Override\n    protected boolean handle(String opt, String value) {\n      switch (opt) {\n        case MASTER -> master = value;\n        case REMOTE -> {\n          isRemote = true;\n          remote = value;\n        }\n        case DEPLOY_MODE -> deployMode = value;\n        case PROPERTIES_FILE -> propertiesFile = value;\n        case DRIVER_MEMORY -> conf.put(SparkLauncher.DRIVER_MEMORY, value);\n        case DRIVER_JAVA_OPTIONS -> conf.put(SparkLauncher.DRIVER_EXTRA_JAVA_OPTIONS, value);\n        case DRIVER_LIBRARY_PATH -> conf.put(SparkLauncher.DRIVER_EXTRA_LIBRARY_PATH, value);\n        case DRIVER_DEFAULT_CLASS_PATH ->\n          conf.put(SparkLauncher.DRIVER_DEFAULT_EXTRA_CLASS_PATH, value);\n        case DRIVER_CLASS_PATH -> conf.put(SparkLauncher.DRIVER_EXTRA_CLASSPATH, value);\n        case CONF -> {\n          checkArgument(value != null, \"Missing argument to %s\", CONF);\n          String[] setConf = value.split(\"=\", 2);\n          checkArgument(setConf.length == 2, \"Invalid argument to %s: %s\", CONF, value);\n          conf.put(setConf[0], setConf[1]);\n          isRemote |= conf.containsKey(\"spark.remote\");\n          isRemote |= \"connect\".equalsIgnoreCase(getApiMode(conf));\n        }\n        case CLASS -> {\n          mainClass = value;\n          if (specialClasses.containsKey(value)) {\n            allowsMixedArguments = true;\n            appResource = specialClasses.get(value);\n          }\n        }\n        case KILL_SUBMISSION, STATUS -> {\n          isSpecialCommand = true;\n          parsedArgs.add(opt);\n          parsedArgs.add(value);\n        }\n        case HELP, USAGE_ERROR, VERSION -> {\n          isSpecialCommand = true;\n          parsedArgs.add(opt);\n        }\n        default -> {\n          parsedArgs.add(opt);\n          if (value != null) {\n            parsedArgs.add(value);\n          }\n        }\n      }\n      return true;\n    }\n\n    @Override\n    protected boolean handleUnknown(String opt) {\n      if (allowsMixedArguments) {\n        appArgs.add(opt);\n        return true;\n      } else if (isExample) {\n        String className = opt;\n        if (!className.startsWith(EXAMPLE_CLASS_PREFIX)) {\n          className = EXAMPLE_CLASS_PREFIX + className;\n        }\n        mainClass = className;\n        appResource = findExamplesAppJar();\n        return false;\n      } else if (errorOnUnknownArgs) {\n        checkArgument(!opt.startsWith(\"-\"), \"Unrecognized option: %s\", opt);\n        checkState(appResource == null, \"Found unrecognized argument but resource is already set.\");\n        appResource = opt;\n        return false;\n      }\n      return true;\n    }\n\n    @Override\n    protected void handleExtraArgs(List<String> extra) {\n      appArgs.addAll(extra);\n    }\n\n  }\n\n}",
    "comment": "If both spark.remote and spark.mater are set, the error will be thrown later when\nthe application is started.\nThe special classes require some special command line handling, since they allow\nmixing spark-submit arguments with arguments that should be propagated to the shell\nitself. Note that for this to work, the \"--class\" argument must come before any\nnon-spark-submit arguments.\nWhen mixing arguments, add unrecognized parameters directly to the user arguments list. In\nnormal mode, any unrecognized parameter triggers the end of command line parsing, and the\nparameter itself will be interpreted by SparkSubmit as the application resource. The\nremaining params will be appended to the list of SparkSubmit arguments."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlanExecutor.java",
    "type": "method",
    "name": "executePlan",
    "code": "private void executePlan() {\n            Clock global = getClock(GLOBAL);\n            global.start();\n            lock.readLock().lock();\n            try {\n                plan.sortedNodes().stream()\n                        .filter(BuildStep::isCreated)\n                        .filter(step -> step.predecessors.stream().allMatch(BuildStep::isDone))\n                        .forEach(this::processStep);\n            } finally {\n                lock.readLock().unlock();\n            }\n        }",
    "comment": "Even if the build is halted, we still want to execute TEARDOWN and after:* steps\nfor proper cleanup, so we don't return early here\nProcess build steps in a logical order:\n1. Find steps that are not yet started (CREATED status)\n2. Check if all their predecessors have completed (in a terminal state)\n3. Process each step (schedule or skip based on reactor failure behavior)\n1. Filter steps that are in CREATED state\n2. Check if all predecessors are in a terminal state\n3. Process each step"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/max/MaxCore.java",
    "type": "method",
    "name": "buildRunner",
    "code": "private Runner buildRunner(Description each) {\n        if (each.toString().equals(\"TestSuite with 0 tests\")) {\n            return Suite.emptySuite();\n        }\n        if (each.toString().startsWith(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX)) {\n            return new JUnit38ClassRunner(new TestSuite(getMalformedTestClass(each)));\n        }\n        Class<?> type = each.getTestClass();\n        if (type == null) {\n            throw new RuntimeException(\"Can't build a runner from description [\" + each + \"]\");\n        }\n        String methodName = each.getMethodName();\n        if (methodName == null) {\n            return Request.aClass(type).getRunner();\n        }\n        return Request.method(type, methodName).getRunner();\n    }",
    "comment": "This is cheating, because it runs the whole class\nto get the warning for this method, but we can't do better,\nbecause JUnit 3.8's\nthrown away which method the warning is for."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/connector/catalog/functions/JavaStrLen.java",
    "type": "method",
    "name": "invoke",
    "code": "public static int invoke(String str) {\n      return str.length();\n    }",
    "comment": "even though the static magic method is present, it has incorrect parameter type and so Spark\nshould fallback to the non-static magic method"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createDecimalType",
    "code": "public static DecimalType createDecimalType() {\n    return DecimalType$.MODULE$.USER_DEFAULT();\n  }",
    "comment": "Creates a DecimalType with default precision and scale, which are 10 and 0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "finished",
    "code": "public Events finished() {\n\t\treturn new Events(eventsByType(EventType.FINISHED), this.category + \" Finished\");\n\t}",
    "comment": "Get the finished {@link Events} contained in this {@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestWatcherTests.java",
    "type": "method",
    "name": "testWatcherIsNotInvokedForTestFactoryMethods",
    "code": "void testWatcherIsNotInvokedForTestFactoryMethods() {\n\t\tEngineExecutionResults results = executeTestsForClass(TrackingTestWatcherTestFactoryMethodsTestCase.class);\n\n\t\tresults.containerEvents().assertStatistics(\n\t\t\tstats -> stats.skipped(1).started(5).succeeded(5).aborted(0).failed(0));\n\t\tresults.testEvents().assertStatistics(\n\t\t\tstats -> stats.dynamicallyRegistered(6).skipped(0).started(6).succeeded(2).aborted(2).failed(2));\n\n\t\tassertThat(TrackingTestWatcher.results).isEmpty();\n\t}",
    "comment": "There should be zero results, since the TestWatcher API is not supported for @TestFactory containers."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlan.java",
    "type": "method",
    "name": "visitNode",
    "code": "private static void visitNode(BuildStep node, Set<BuildStep> visited, List<BuildStep> sortedNodes) {\n        if (visited.add(node)) {\n            node.successors.forEach(successor -> visitNode(successor, visited, sortedNodes));\n            sortedNodes.add(node);\n        }\n    }",
    "comment": "Helper method to visit a node\nFor each successor of the current node, visit unvisited successors"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "tryToReadFieldValue",
    "code": "public static Try<Object> tryToReadFieldValue(Field field) {\n\t\treturn tryToReadFieldValue(field, null);\n\t}",
    "comment": "Try to read the value of a potentially inaccessible static field.\n\n<p>If an exception occurs while reading the field, a failed {@link Try}\nis returned that contains the corresponding exception.\n\n@param field the field to read; never {@code null}\n@since 1.4\n@see #tryToReadFieldValue(Field, Object)\n@see #tryToReadFieldValue(Class, String, Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/decorator/src/test/java/com/iluwatar/decorator/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterApi.java",
    "type": "method",
    "name": "getUseNNAPI",
    "code": "public boolean getUseNNAPI() {\n      return useNNAPI != null && useNNAPI;\n    }",
    "comment": "Returns whether to use NN API (if available) for op execution. Default value is false\n(disabled)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/DefaultMaven.java",
    "type": "method",
    "name": "validateOptionalProjects",
    "code": "private void validateOptionalProjects(MavenExecutionRequest request, MavenSession session) {\n        final ProjectActivation projectActivation = request.getProjectActivation();\n        final Set<String> allOptionalSelectors = new HashSet<>();\n        allOptionalSelectors.addAll(projectActivation.getOptionalActiveProjectSelectors());\n        allOptionalSelectors.addAll(projectActivation.getRequiredActiveProjectSelectors());\n        // We intentionally ignore the results of this method.\n        // As a side effect it will log the optional projects that could not be resolved.\n        projectSelector.getOptionalProjectsBySelectors(request, session.getAllProjects(), allOptionalSelectors);\n    }",
    "comment": "Check whether any of the requested optional projects were not activated or deactivated.\n@param request the {@link MavenExecutionRequest}.\n@param session the {@link MavenSession}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/AlbumPage.java",
    "type": "method",
    "name": "navigateToPage",
    "code": "public AlbumPage navigateToPage() {\n    try {\n      page = this.webClient.getPage(PAGE_URL);\n    } catch (IOException e) {\n      LOGGER.error(\"An error occurred on navigateToPage.\", e);\n    }\n    return this;\n  }",
    "comment": "Navigates to the album page.\n\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Boolean> create(Scope scope, boolean[][][] data) {\n    return create(scope, data, Boolean.class);\n  }",
    "comment": "Creates a rank-3 constant of {@code boolean} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/matchers/ThrowableCauseMatcher.java",
    "type": "method",
    "name": "hasCause",
    "code": "public static <T extends Throwable> Matcher<T> hasCause(final Matcher<?> matcher) {\n        return new ThrowableCauseMatcher<T>(matcher);\n    }",
    "comment": "Returns a matcher that verifies that the outer exception has a cause for which the supplied matcher\nevaluates to true.\n\n@param matcher to apply to the cause of the outer exception\n@param <T> type of the outer exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TestWatchman.java",
    "type": "method",
    "name": "failed",
    "code": "public void failed(Throwable e, FrameworkMethod method) {\n    }",
    "comment": "Invoked when a test method fails"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/injection/sample/PrimitiveIntegerParameterResolver.java",
    "type": "method",
    "name": "supportsParameter",
    "code": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn int.class == parameterContext.getParameter().getType();\n\t}",
    "comment": "Example {@link ParameterResolver} that resolves primitive integers.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/JupiterEngineExecutionContext.java",
    "type": "method",
    "name": "beforeAllCallbacksExecuted",
    "code": "public void beforeAllCallbacksExecuted(boolean beforeAllCallbacksExecuted) {\n\t\tthis.beforeAllCallbacksExecuted = beforeAllCallbacksExecuted;\n\t}",
    "comment": "Track that an attempt was made to execute {@code BeforeAllCallback} extensions.\n\n@since 5.3"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/Promise.java",
    "type": "method",
    "name": "TransformAction",
    "code": "private TransformAction(Promise<T> src, Promise<V> dest, Function<? super T, V> func) {\n      this.src = src;\n      this.dest = dest;\n      this.func = func;\n    }",
    "comment": "Accesses the value from source promise, then fulfills the destination promise using the\ntransformed value. The source value is transformed using the transformation function."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-di/src/main/java/org/apache/maven/di/Key.java",
    "type": "method",
    "name": "getRawType",
    "code": "public Class<T> getRawType() {\n        return (Class<T>) Types.getRawType(type);\n    }",
    "comment": "A shortcut for <code>{@link Types#getRawType(Type)}(key.getType())</code>.\nAlso casts the result to a properly parameterized class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/standalone/UnsupportedInStandaloneModeException.java",
    "type": "method",
    "name": "UnsupportedInStandaloneModeException",
    "code": "public UnsupportedInStandaloneModeException() {\n        super(\"This operation is not supported in standalone mode\");\n    }",
    "comment": "Constructs a new exception with a default message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/ChunkFetchRequest.java",
    "type": "method",
    "name": "ChunkFetchRequest",
    "code": "public ChunkFetchRequest(StreamChunkId streamChunkId) {\n    this.streamChunkId = streamChunkId;\n  }",
    "comment": "Request to fetch a sequence of a single chunk of a stream. This will correspond to a single\n{@link org.apache.spark.network.protocol.ResponseMessage} (either success or failure)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng2045testJarDependenciesBrokenInReactorTest.java",
    "type": "method",
    "name": "assertNotMainClasses",
    "code": "private void assertNotMainClasses(List<String> classpath) {\n        assertFalse(classpath.contains(\"main\"), \"main classes present in \" + classpath);\n    }",
    "comment": "When depending on the test JAR of some module, we shouldn't get its main classes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/InMemoryStore.java",
    "type": "method",
    "name": "get",
    "code": "public <T> InstanceList<T> get(Class<T> type) {\n      return (InstanceList<T>) data.get(type);\n    }",
    "comment": "Encapsulates ConcurrentHashMap so that the typing in and out of the map strictly maps a\nclass of type T to an InstanceList of type T."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistryTests.java",
    "type": "method",
    "name": "newRegistryWithoutParentHasDefaultExtensions",
    "code": "void newRegistryWithoutParentHasDefaultExtensions() {\n\t\tList<Extension> extensions = registry.getExtensions(Extension.class);\n\n\t\tassertEquals(NUM_CORE_EXTENSIONS, extensions.size());\n\t\tassertDefaultGlobalExtensionsAreRegistered();\n\t}",
    "comment": "Tests for the {@link MutableExtensionRegistry}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/ShuffleInMemorySorter.java",
    "type": "method",
    "name": "insertRecord",
    "code": "public void insertRecord(long recordPointer, int partitionId) {\n    if (!hasSpaceForAnotherRecord()) {\n      throw new IllegalStateException(\"There is no space for new record\");\n    }\n    array.set(pos, PackedRecordPointer.packPointer(recordPointer, partitionId));\n    pos++;\n  }",
    "comment": "Inserts a record to be sorted.\n\n@param recordPointer a pointer to the record, encoded by the task memory manager. Due to\ncertain pointer compression techniques used by the sorter, the sort can\nonly operate on pointers that point to locations in the first\n{@link PackedRecordPointer#MAXIMUM_PAGE_SIZE_BYTES} bytes of a data page.\n@param partitionId the partition id, which must be less than or equal to\n{@link PackedRecordPointer#MAXIMUM_PARTITION_ID}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/component/src/test/java/com/iluwatar/component/AppTest.java",
    "type": "method",
    "name": "shouldExecuteComponentWithoutException",
    "code": "void shouldExecuteComponentWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Tests App class : src/main/java/com/iluwatar/component/App.java General execution test of the\napplication."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/config/CachingJupiterConfigurationTests.java",
    "type": "method",
    "name": "cachesDefaultExecutionMode",
    "code": "void cachesDefaultExecutionMode() {\n\t\twhen(delegate.getDefaultExecutionMode()).thenReturn(ExecutionMode.CONCURRENT);\n\n\t\tassertThat(cache.getDefaultExecutionMode()).isEqualTo(ExecutionMode.CONCURRENT);\n\t\tassertThat(cache.getDefaultExecutionMode()).isEqualTo(ExecutionMode.CONCURRENT);\n\n\t\tverify(delegate, only()).getDefaultExecutionMode();\n\t}",
    "comment": "Unit tests for {@link CachingJupiterConfiguration}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/BloomFilterImpl.java",
    "type": "method",
    "name": "putBinary",
    "code": "public boolean putBinary(byte[] item) {\n    int h1 = Murmur3_x86_32.hashUnsafeBytes(item, Platform.BYTE_ARRAY_OFFSET, item.length, 0);\n    int h2 = Murmur3_x86_32.hashUnsafeBytes(item, Platform.BYTE_ARRAY_OFFSET, item.length, h1);\n\n    long bitSize = bits.bitSize();\n    boolean bitsChanged = false;\n    for (int i = 1; i <= numHashFunctions; i++) {\n      int combinedHash = h1 + (i * h2);\n      if (combinedHash < 0) {\n        combinedHash = ~combinedHash;\n      }\n      bitsChanged |= bits.set(combinedHash % bitSize);\n    }\n    return bitsChanged;\n  }",
    "comment": "Flip all the bits if it's negative (guaranteed positive number)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/builder/multithreaded/ConcurrencyDependencyGraph.java",
    "type": "method",
    "name": "ConcurrencyDependencyGraph",
    "code": "public ConcurrencyDependencyGraph(ProjectBuildList projectBuilds, ProjectDependencyGraph projectDependencyGraph) {\n        this.projectDependencyGraph = projectDependencyGraph;\n        this.projectBuilds = projectBuilds;\n    }",
    "comment": "<p>\nPresents a view of the Dependency Graph that is suited for concurrent building.\n</p>\n<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/role-object/src/main/java/com/iluwatar/roleobject/Customer.java",
    "type": "method",
    "name": "newCustomer",
    "code": "public static Customer newCustomer(Role... role) {\n    var customer = newCustomer();\n    Arrays.stream(role).forEach(customer::addRole);\n    return customer;\n  }",
    "comment": "Create {@link Customer} with given roles.\n\n@param role roles\n@return Customer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/validator/AnnotationValidator.java",
    "type": "method",
    "name": "validateAnnotatedField",
    "code": "public List<Exception> validateAnnotatedField(FrameworkField field) {\n        return NO_VALIDATION_ERRORS;\n\n    }",
    "comment": "Validates annotation on the given field.\n\n@param field that is being validated\n@return A list of exceptions. Default behavior is to return an empty list.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/support/conversion/ConversionSupportTests.java",
    "type": "method",
    "name": "convertsStringToCharset",
    "code": "void convertsStringToCharset() {\n\t\tassertConverts(\"ISO-8859-1\", Charset.class, StandardCharsets.ISO_8859_1);\n\t\tassertConverts(\"UTF-8\", Charset.class, StandardCharsets.UTF_8);\n\t}",
    "comment": "--- java.io and java.nio ------------------------------------------------"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "failureCount",
    "code": "public synchronized int failureCount() {\n        return fFailures.size();\n    }",
    "comment": "Gets the number of detected failures."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/test/java/com/example/android/observability/UserViewModelTest.java",
    "type": "method",
    "name": "getUserName_whenNoUserSaved",
    "code": "public void getUserName_whenNoUserSaved() {\n        when(mDataSource.getUser()).thenReturn(Flowable.empty());\n\n        mViewModel.getUserName()\n                .test()\n                .assertNoValues();\n    }",
    "comment": "Given that the UserDataSource returns an empty list of users\nWhen getting the user name\nThe user name is empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "setInactiveProfileIds",
    "code": "public DefaultProfileActivationContext setInactiveProfileIds(List<String> inactiveProfileIds) {\n        this.inactiveProfileIds = unmodifiable(inactiveProfileIds);\n        return this;\n    }",
    "comment": "Sets the identifiers of those profiles that should be deactivated by explicit demand.\n\n@param inactiveProfileIds The identifiers of those profiles to deactivate, may be {@code null}.\n@return This context, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/CacheStore.java",
    "type": "method",
    "name": "writeAround",
    "code": "public void writeAround(final UserAccount userAccount) {\n    if (cache.contains(userAccount.getUserId())) {\n      dbManager.updateDb(userAccount);\n      // Cache data has been updated -- remove older\n      cache.invalidate(userAccount.getUserId());\n      // version from cache.\n    } else {\n      dbManager.writeToDb(userAccount);\n    }\n  }",
    "comment": "Get user account using write-around cache.\n\n@param userAccount {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/VersionTest.java",
    "type": "method",
    "name": "testCompareUuidVersionStringStream",
    "code": "void testCompareUuidVersionStringStream() {\n        // this operation below fails with IAEx if comparison is unstable\n        uuidVersionStringStream().map(this::newVersion).sorted().toList();\n    }",
    "comment": "UT for <a href=\"https://issues.apache.org/jira/browse/MRESOLVER-314\">MRESOLVER-314</a>.\n\nWorks on known set that failed before fix, provided by {@link #uuidVersionStringStream()}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultSourceRoot.java",
    "type": "method",
    "name": "DefaultSourceRoot",
    "code": "public DefaultSourceRoot(final Path baseDir, ProjectScope scope, Resource resource) {\n        String value = nonBlank(resource.getDirectory());\n        if (value == null) {\n            throw new IllegalArgumentException(\"Source declaration without directory value.\");\n        }\n        directory = baseDir.resolve(value).normalize();\n        includes = resource.getIncludes();\n        excludes = resource.getExcludes();\n        stringFiltering = Boolean.parseBoolean(resource.getFiltering());\n        enabled = true;\n        moduleName = null;\n        this.scope = scope;\n        language = Language.RESOURCES;\n        targetVersion = null;\n        targetPath = null;\n    }",
    "comment": "Creates a new instance from the given resource.\nThis is used for migration from the previous way of declaring resources.\n\n@param baseDir the base directory for resolving relative paths\n@param scope the scope of the resource (main or test)\n@param resource a resource element from the model"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Boolean> create(boolean[][][] data) {\n    return Tensor.create(data, Boolean.class);\n  }",
    "comment": "Creates a rank-3 tensor of {@code boolean} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "warning",
    "code": "default MessageBuilder warning(Object message) {\n        return style(\".\" + Constants.MAVEN_STYLE_WARNING_NAME + \":-\" + Constants.MAVEN_STYLE_WARNING_DEFAULT, message);\n    }",
    "comment": "Append message content in warning style.\nBy default, bold yellow\n\n@param message the message to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(long unexpected, Long actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Long) unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/matchers/ThrowableCauseMatcher.java",
    "type": "method",
    "name": "ThrowableCauseMatcher",
    "code": "public ThrowableCauseMatcher(Matcher<?> causeMatcher) {\n        this.causeMatcher = causeMatcher;\n    }",
    "comment": "A matcher that applies a delegate matcher to the cause of the current Throwable, returning the result of that\nmatch.\n\n@param <T> the type of the throwable being matched"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "tryToGetResources",
    "code": "public static Try<Set<Resource>> tryToGetResources(String classpathResourceName) {\n\t\treturn ReflectionUtils.tryToGetResources(classpathResourceName);\n\t}",
    "comment": "Try to get the {@linkplain Resource resources} for the supplied classpath\nresource name.\n\n<p>The name of a <em>classpath resource</em> must follow the semantics\nfor resource paths as defined in {@link ClassLoader#getResource(String)}.\n\n<p>If the supplied classpath resource name is prefixed with a slash\n({@code /}), the slash will be removed.\n\n@param classpathResourceName the name of the resource to load; never\n{@code null} or blank\n@return a successful {@code Try} containing the loaded resources or a failed\n{@code Try} containing the exception if no such resources could be loaded;\nnever {@code null}\n@since 1.12\n@see #tryToGetResources(String, ClassLoader)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/ShuffleExternalSorter.java",
    "type": "method",
    "name": "writeSortedFile",
    "code": "private void writeSortedFile(boolean isFinalFile) {\n    // Only emit the log if this is an actual spilling.\n    if (!isFinalFile) {\n      logger.info(\n        \"Task {} on Thread {} spilling sort data of {} to disk ({} {} so far)\",\n        MDC.of(LogKeys.TASK_ATTEMPT_ID$.MODULE$, taskContext.taskAttemptId()),\n        MDC.of(LogKeys.THREAD_ID$.MODULE$, Thread.currentThread().getId()),\n        MDC.of(LogKeys.MEMORY_SIZE$.MODULE$, Utils.bytesToString(getMemoryUsage())),\n        MDC.of(LogKeys.NUM_SPILLS$.MODULE$, spills.size()),\n        MDC.of(LogKeys.SPILL_TIMES$.MODULE$, spills.size() != 1 ? \"times\" : \"time\"));\n    }\n\n    // This call performs the actual sort.\n    final ShuffleInMemorySorter.ShuffleSorterIterator sortedRecords =\n      inMemSorter.getSortedIterator();\n\n    // If there are no sorted records, so we don't need to create an empty spill file.\n    if (!sortedRecords.hasNext()) {\n      return;\n    }\n\n    final ShuffleWriteMetricsReporter writeMetricsToUse;\n\n    if (isFinalFile) {\n      // We're writing the final non-spill file, so we _do_ want to count this as shuffle bytes.\n      writeMetricsToUse = writeMetrics;\n    } else {\n      // We're spilling, so bytes written should be counted towards spill rather than write.\n      // Create a dummy WriteMetrics object to absorb these metrics, since we don't want to count\n      // them towards shuffle bytes written.\n      // The actual shuffle bytes written will be counted when we merge the spill files.\n      writeMetricsToUse = new ShuffleWriteMetrics();\n    }\n\n    // Small writes to DiskBlockObjectWriter will be fairly inefficient. Since there doesn't seem to\n    // be an API to directly transfer bytes from managed memory to the disk writer, we buffer\n    // data through a byte array. This array does not need to be large enough to hold a single\n    // record;\n    final byte[] writeBuffer = new byte[diskWriteBufferSize];\n\n    // Because this output will be read during shuffle, its compression codec must be controlled by\n    // spark.shuffle.compress instead of spark.shuffle.spill.compress, so we need to use\n    // createTempShuffleBlock here; see SPARK-3426 for more details.\n    final Tuple2<TempShuffleBlockId, File> spilledFileInfo =\n      blockManager.diskBlockManager().createTempShuffleBlock();\n    final File file = spilledFileInfo._2();\n    final TempShuffleBlockId blockId = spilledFileInfo._1();\n    final SpillInfo spillInfo = new SpillInfo(numPartitions, file, blockId);\n\n    // Unfortunately, we need a serializer instance in order to construct a DiskBlockObjectWriter.\n    // Our write path doesn't actually use this serializer (since we end up calling the `write()`\n    // OutputStream methods), but DiskBlockObjectWriter still calls some methods on it. To work\n    // around this, we pass a dummy no-op serializer.\n    final SerializerInstance ser = DummySerializerInstance.INSTANCE;\n\n    int currentPartition = -1;\n    final FileSegment committedSegment;\n    try (DiskBlockObjectWriter writer =\n        blockManager.getDiskWriter(blockId, file, ser, fileBufferSizeBytes, writeMetricsToUse)) {\n\n      final int uaoSize = UnsafeAlignedOffset.getUaoSize();\n      while (sortedRecords.hasNext()) {\n        sortedRecords.loadNext();\n        final int partition = sortedRecords.packedRecordPointer.getPartitionId();\n        assert (partition >= currentPartition);\n        if (partition != currentPartition) {\n          // Switch to the new partition\n          if (currentPartition != -1) {\n            final FileSegment fileSegment = writer.commitAndGet();\n            spillInfo.partitionLengths[currentPartition] = fileSegment.length();\n          }\n          currentPartition = partition;\n          if (partitionChecksums.length > 0) {\n            writer.setChecksum(partitionChecksums[currentPartition]);\n          }\n        }\n\n        final long recordPointer = sortedRecords.packedRecordPointer.getRecordPointer();\n        final Object recordPage = taskMemoryManager.getPage(recordPointer);\n        final long recordOffsetInPage = taskMemoryManager.getOffsetInPage(recordPointer);\n        int dataRemaining = UnsafeAlignedOffset.getSize(recordPage, recordOffsetInPage);\n        long recordReadPosition = recordOffsetInPage + uaoSize; // skip over record length\n        while (dataRemaining > 0) {\n          final int toTransfer = Math.min(diskWriteBufferSize, dataRemaining);\n          Platform.copyMemory(\n            recordPage, recordReadPosition, writeBuffer, Platform.BYTE_ARRAY_OFFSET, toTransfer);\n          writer.write(writeBuffer, 0, toTransfer);\n          recordReadPosition += toTransfer;\n          dataRemaining -= toTransfer;\n        }\n        writer.recordWritten();\n      }\n\n      committedSegment = writer.commitAndGet();\n    }\n    // If `writeSortedFile()` was called from `closeAndGetSpills()` and no records were inserted,\n    // then the file might be empty. Note that it might be better to avoid calling\n    // writeSortedFile() in that case.\n    if (currentPartition != -1) {\n      spillInfo.partitionLengths[currentPartition] = committedSegment.length();\n      spills.add(spillInfo);\n    }\n\n    if (!isFinalFile) {  // i.e. this is a spill file\n      // The current semantics of `shuffleRecordsWritten` seem to be that it's updated when records\n      // are written to disk, not when they enter the shuffle sorting code. DiskBlockObjectWriter\n      // relies on its `recordWritten()` method being called in order to trigger periodic updates to\n      // `shuffleBytesWritten`. If we were to remove the `recordWritten()` call and increment that\n      // counter at a higher-level, then the in-progress metrics for records written and bytes\n      // written would get out of sync.\n      //\n      // When writing the last file, we pass `writeMetrics` directly to the DiskBlockObjectWriter;\n      // in all other cases, we pass in a dummy write metrics to capture metrics, then copy those\n      // metrics to the true write metrics here. The reason for performing this copying is so that\n      // we can avoid reporting spilled bytes as shuffle write bytes.\n      //\n      // Note that we intentionally ignore the value of `writeMetricsToUse.shuffleWriteTime()`.\n      // Consistent with ExternalSorter, we do not count this IO towards shuffle write time.\n      // SPARK-3577 tracks the spill time separately.\n\n      // This is guaranteed to be a ShuffleWriteMetrics based on the if check in the beginning\n      // of this method.\n      writeMetrics.incRecordsWritten(\n        ((ShuffleWriteMetrics)writeMetricsToUse).recordsWritten());\n      taskContext.taskMetrics().incDiskBytesSpilled(\n        ((ShuffleWriteMetrics)writeMetricsToUse).bytesWritten());\n    }\n  }",
    "comment": "Sorts the in-memory records and writes the sorted records to an on-disk file.\nThis method does not free the sort data structures.\n\n@param isFinalFile if true, this indicates that we're writing the final output file and that\nthe bytes written should be counted towards shuffle write metrics rather\nthan shuffle spill metrics."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/BenchmarkAccuracyImpl.java",
    "type": "method",
    "name": "initialize",
    "code": "private boolean initialize(Context context, String[] tfliteSettingsJsonFiles) {\n    if (tfliteSettingsJsonFiles == null || tfliteSettingsJsonFiles.length == 0) {\n      Log.e(TAG, \"No TFLiteSettings file provided.\");\n      return false;\n    }\n    this.context = context;\n    this.tfliteSettingsJsonFiles = tfliteSettingsJsonFiles;\n    report = BenchmarkReport.create();\n\n    try {\n      // Creates root result folder.\n      String resultFolderPath =\n          DelegatePerformanceBenchmark.createResultFolder(\n              context.getFilesDir(), ACCURACY_FOLDER_NAME);\n      report.addWriter(JsonWriter.create(resultFolderPath));\n      report.addWriter(CsvWriter.create(resultFolderPath));\n      report.addWriter(HtmlWriter.create(resultFolderPath));\n    } catch (IOException e) {\n      Log.e(TAG, \"Failed to create result folder\", e);\n      return false;\n    }\n    return true;\n  }",
    "comment": "Initializes the test environment. Checks the validity of input arguments and creates the result\nfolder.\n\n@return {@code true} if the initialization was successful. Otherwise, returns {@code false}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "isExact",
    "code": "public boolean isExact() {\n\t\t\treturn type == Type.EXACT;\n\t\t}",
    "comment": "Whether this match is exact.\n\n@return {@code true} if this match is exact; {@code false} if it's\npartial"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/commander/src/main/java/com/iluwatar/commander/Commander.java",
    "type": "method",
    "name": "sendShippingRequest",
    "code": "private void sendShippingRequest(Order order) {\n    var list = shippingService.exceptionsList;\n    Retry.Operation op =\n        l -> {\n          if (!l.isEmpty()) {\n            if (DatabaseUnavailableException.class.isAssignableFrom(l.get(0).getClass())) {\n              LOG.debug(\n                  ORDER_ID + \": Error in connecting to shipping service, \" + \"trying again..\",\n                  order.id);\n            } else {\n              LOG.debug(ORDER_ID + \": Error in creating shipping request..\", order.id);\n            }\n            throw l.remove(0);\n          }\n          String transactionId = shippingService.receiveRequest(order.item, order.user.address);\n          LOG.info(\n              ORDER_ID + \": Shipping placed successfully, transaction id: {}\",\n              order.id,\n              transactionId);\n          LOG.info(\n              \"Order has been placed and will be shipped to you. Please wait while we make your\"\n                  + \" payment... \");\n          sendPaymentRequest(order);\n        };\n    Retry.HandleErrorIssue<Order> handleError =\n        (o, err) -> {\n          if (ShippingNotPossibleException.class.isAssignableFrom(err.getClass())) {\n            LOG.info(\n                \"Shipping is currently not possible to your address. We are working on the problem\"\n                    + \" and will get back to you asap.\");\n            finalSiteMsgShown = true;\n            LOG.info(\n                ORDER_ID\n                    + \": Shipping not possible to address, trying to add problem \"\n                    + \"to employee db..\",\n                order.id);\n            employeeHandleIssue(o);\n          } else if (ItemUnavailableException.class.isAssignableFrom(err.getClass())) {\n            LOG.info(\n                \"This item is currently unavailable. We will inform you as soon as the item \"\n                    + \"becomes available again.\");\n            finalSiteMsgShown = true;\n            LOG.info(\n                ORDER_ID\n                    + \": Item {}\"\n                    + \" unavailable, trying to add \"\n                    + \"problem to employee handle..\",\n                order.id,\n                order.item);\n            employeeHandleIssue(o);\n          } else {\n            LOG.info(\"Sorry, there was a problem in creating your order. Please try later.\");\n            LOG.error(ORDER_ID + \": Shipping service unavailable, order not placed..\", order.id);\n            finalSiteMsgShown = true;\n          }\n        };\n    var r =\n        new Retry<>(\n            op,\n            handleError,\n            numOfRetries,\n            retryDuration,\n            e -> DatabaseUnavailableException.class.isAssignableFrom(e.getClass()));\n    r.perform(list, order);\n  }",
    "comment": "could save this transaction id in a db too"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/ClassMap.java",
    "type": "method",
    "name": "populateMethodCache",
    "code": "private void populateMethodCache() {\n        // get all publicly accessible methods\n        Method[] methods = getAccessibleMethods(clazz);\n\n        // map and cache them\n        for (Method method : methods) {\n            // now get the 'public method', the method declared by a\n            // public interface or class (because the actual implementing\n            // class may be a facade...)\n\n            Method publicMethod = getPublicMethod(method);\n\n            // it is entirely possible that there is no public method for\n            // the methods of this class; i.e., in the facade, a method\n            // that isn't on any of the interfaces or superclass\n            // in which case, ignore it. Otherwise, map and cache.\n            if (publicMethod != null) {\n                methodMap.add(publicMethod);\n                methodCache.put(makeMethodKey(publicMethod), publicMethod);\n            }\n        }\n    }",
    "comment": "Populate the Map of direct hits. These\nare taken from all the public methods\nthat our class provides."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/sample-application/src/main/java/com/iluwatar/pageobject/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    try {\n      var classLoader = App.class.getClassLoader();\n      var applicationFile = new File(classLoader.getResource(\"sample-ui/login.html\").getPath());\n\n      // should work for unix like OS (mac, unix etc...)\n      if (Desktop.isDesktopSupported()) {\n        Desktop.getDesktop().open(applicationFile);\n\n      } else {\n        // java Desktop not supported - above unlikely to work for Windows so try instead...\n        Runtime.getRuntime().exec(\"cmd.exe start \" + applicationFile);\n      }\n\n    } catch (IOException ex) {\n      LOGGER.error(\"An error occurred.\", ex);\n    }\n  }",
    "comment": "Application entry point\n\n<p>The application under development is a web application. Normally you would probably have a\nbackend that is probably implemented in an object-oriented language (e.g. Java) that serves the\nfrontend which comprises of a series of HTML, CSS, JS etc...\n\n<p>For illustrations purposes only, a very simple static html app is used here. This main\nmethod just fires up this simple web app in a default browser.\n\n@param args arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "indexOf",
    "code": "public Object indexOf(List<Object> args) {\n        if (args.size() != 2) {\n            throw new IllegalArgumentException(\"indexOf function requires exactly two arguments\");\n        }\n        String s = ConditionParser.toString(args.get(0));\n        String substring = ConditionParser.toString(args.get(1));\n        return s.indexOf(substring);\n    }",
    "comment": "Finds the index of a substring within a string.\n\n@param args A list containing two strings: the main string and the substring to find\n@return The index of the substring, or -1 if not found\n@throws IllegalArgumentException if the number of arguments is not exactly two"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/NewestConflictResolverTest.java",
    "type": "method",
    "name": "testEqualReversed",
    "code": "void testEqualReversed() {\n        ResolutionNode a2n = createResolutionNode(a2);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a2n, a2n, a1n);\n    }",
    "comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\na:2.0\na:1.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(int expected, int actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "abortedWithReason",
    "code": "public static Condition<Event> abortedWithReason(Condition<Throwable>... conditions) {\n\t\treturn finishedWithCause(ABORTED, conditions);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link EventType#FINISHED} and its\n{@linkplain Event#getPayload() result} has a\n{@linkplain TestExecutionResult#getStatus() status} of\n{@link TestExecutionResult.Status#ABORTED ABORTED} as well as a\n{@linkplain TestExecutionResult#getThrowable() cause} that matches all of\nthe supplied conditions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "cursorToColumn",
    "code": "public Ansi cursorToColumn(final int x) {\n        return appendEscapeSequence('G', Math.max(1, x));\n    }",
    "comment": "Moves the cursor to column n. The parameter n is 1-based.\nIf n is less than 1 it is moved to the first column.\n\n@param x the index (1-based) of the column to move to\n@return this Ansi instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/regression/JavaLinearRegressionSuite.java",
    "type": "method",
    "name": "testPredictJavaRDD",
    "code": "public void testPredictJavaRDD() {\n    int nPoints = 100;\n    double A = 0.0;\n    double[] weights = {10, 10};\n    JavaRDD<LabeledPoint> testRDD = jsc.parallelize(\n      LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache();\n    LinearRegressionWithSGD linSGDImpl = new LinearRegressionWithSGD(1.0, 100, 0.0, 1.0);\n    LinearRegressionModel model = linSGDImpl.run(testRDD.rdd());\n    JavaRDD<Vector> vectors = testRDD.map(LabeledPoint::features);\n    JavaRDD<Double> predictions = model.predict(vectors);\n    predictions.first();\n  }",
    "comment": "Should be able to get the first prediction."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/AlbumListPage.java",
    "type": "method",
    "name": "navigateToPage",
    "code": "public AlbumListPage navigateToPage() {\n    try {\n      page = this.webClient.getPage(PAGE_URL);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return this;\n  }",
    "comment": "Navigates to the Album List Page\n\n@return {@link AlbumListPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/OverloadedTestMethodTests.java",
    "type": "method",
    "name": "executeTestCaseWithOverloadedMethodsAndThenRerunOnlyOneOfTheMethodsSelectedByUniqueId",
    "code": "void executeTestCaseWithOverloadedMethodsAndThenRerunOnlyOneOfTheMethodsSelectedByUniqueId() {\n\t\tEvents tests = executeTestsForClass(TestCase.class).testEvents();\n\n\t\ttests.assertStatistics(stats -> stats.started(2).succeeded(2).failed(0));\n\n\t\tOptional<Event> first = tests.succeeded().filter(\n\t\t\tevent -> event.getTestDescriptor().getUniqueId().toString().contains(TestInfo.class.getName())).findFirst();\n\t\tassertTrue(first.isPresent());\n\t\tTestIdentifier testIdentifier = TestIdentifier.from(first.get().getTestDescriptor());\n\t\tUniqueId uniqueId = testIdentifier.getUniqueIdObject();\n\n\t\ttests = executeTests(selectUniqueId(uniqueId)).testEvents();\n\n\t\ttests.assertStatistics(stats -> stats.started(1).succeeded(1).failed(0));\n\n\t\tfirst = tests.succeeded().filter(\n\t\t\tevent -> event.getTestDescriptor().getUniqueId().toString().contains(TestInfo.class.getName())).findFirst();\n\t\tassertTrue(first.isPresent());\n\t}",
    "comment": "Integration tests for support of overloaded test methods in conjunction with\nthe {@link JupiterTestEngine}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/LoginPage.java",
    "type": "method",
    "name": "enterPassword",
    "code": "public LoginPage enterPassword(String password) {\n    var passwordInputPasswordField = (HtmlPasswordInput) page.getElementById(\"password\");\n    passwordInputPasswordField.setText(password);\n    return this;\n  }",
    "comment": "Enters the password into the password input password field\n\n@param password the password to enter\n@return {@link LoginPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/server/ThreadWithGarbageCleanup.java",
    "type": "method",
    "name": "cacheThreadLocalRawStore",
    "code": "public void cacheThreadLocalRawStore() {\n    Long threadId = this.getId();\n    RawStore threadLocalRawStore = HiveMetaStore.HMSHandler.getRawStore();\n    if (threadLocalRawStore != null && !threadRawStoreMap.containsKey(threadId)) {\n      LOG.debug(\"Adding RawStore: \" + threadLocalRawStore + \", for the thread: \" +\n          this.getName() + \" to threadRawStoreMap for future cleanup.\");\n      threadRawStoreMap.put(threadId, threadLocalRawStore);\n    }\n  }",
    "comment": "Cache the ThreadLocal RawStore object. Called from the corresponding thread."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toLong",
    "code": "private boolean toLong(LongWrapper toLongResult, boolean allowDecimal) {\n    int offset = 0;\n    while (offset < this.numBytes && isWhitespaceOrISOControl(getByte(offset))) offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && isWhitespaceOrISOControl(getByte(end))) end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final long stopValue = Long.MIN_VALUE / radix;\n    long result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator && allowDecimal) {\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n\n    toLongResult.value = result;\n    return true;\n  }",
    "comment": "We allow decimals and will return a truncated integral in that case.\nTherefore we won't throw an exception here (checking the fractional\npart happens below.)\nWe are going to process the new digit and accumulate the result. However, before doing\nthis, if the result is already smaller than the stopValue(Long.MIN_VALUE / radix), then\nresult * 10 will definitely be smaller than minValue, and we can stop.\nSince the previous result is less than or equal to stopValue(Long.MIN_VALUE / radix), we\ncan just use `result > 0` to check overflow. If result overflows, we should stop.\nThis is the case when we've encountered a decimal separator. The fractional\npart will not change the number, but we will verify that the fractional part\nis well formed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "cipherTransformation",
    "code": "public String cipherTransformation() {\n    return conf.get(\"spark.network.crypto.cipher\", \"AES/CTR/NoPadding\");\n  }",
    "comment": "The cipher transformation to use for encrypting session data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-api-gateway/api-gateway-service/src/main/java/com/iluwatar/api/gateway/PriceClientImpl.java",
    "type": "method",
    "name": "getPrice",
    "code": "public String getPrice() {\n    var httpClient = HttpClient.newHttpClient();\n    var httpGet =\n        HttpRequest.newBuilder().GET().uri(URI.create(\"http://localhost:50006/price\")).build();\n\n    try {\n      LOGGER.info(\"Sending request to fetch price info\");\n      var httpResponse = httpClient.send(httpGet, BodyHandlers.ofString());\n      logResponse(httpResponse);\n      return httpResponse.body();\n    } catch (IOException e) {\n      LOGGER.error(\"Failure occurred while getting price info\", e);\n    } catch (InterruptedException e) {\n      LOGGER.error(\"Failure occurred while getting price info\", e);\n      Thread.currentThread().interrupt();\n    }\n\n    return null;\n  }",
    "comment": "Makes a simple HTTP Get request to the Price microservice.\n\n@return The price of the product"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetReadState.java",
    "type": "method",
    "name": "resetForNewBatch",
    "code": "void resetForNewBatch(int batchSize) {\n    this.valueOffset = 0;\n    this.levelOffset = 0;\n    this.rowsToReadInBatch = batchSize;\n    this.lastListCompleted = this.maxRepetitionLevel == 0; // always true for non-repeated column\n    this.numBatchedDefLevels = 0;\n    this.shouldSkip = false;\n  }",
    "comment": "Must be called at the beginning of reading a new batch."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-yarn/src/main/java/org/apache/spark/network/yarn/YarnShuffleService.java",
    "type": "method",
    "name": "serviceStop",
    "code": "protected void serviceStop() {\n    try {\n      if (shuffleServer != null) {\n        shuffleServer.close();\n      }\n      if (transportContext != null) {\n        transportContext.close();\n      }\n      if (blockHandler != null) {\n        blockHandler.close();\n      }\n      if (db != null) {\n        db.close();\n      }\n    } catch (Exception e) {\n      logger.error(\"Exception when stopping service\", e);\n    }\n  }",
    "comment": "Close the shuffle server to clean up any associated state."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "container",
    "code": "public static Condition<Event> container() {\n\t\treturn new Condition<>(byTestDescriptor(TestDescriptor::isContainer), \"is a container\");\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\na {@linkplain TestDescriptor#isContainer() container}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "withTMax",
    "code": "public Builder withTMax(int tMax) {\n            this.tMax = tMax;\n            return this;\n        }",
    "comment": "Use the given {@code tmax} value when announcing metrics.\n\n@param tMax the desired gmond {@code tmax} value\n@return {@code this}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "initDelegatesWithInterpreterFactory",
    "code": "private void initDelegatesWithInterpreterFactory() {\n    InterpreterFactoryApi interpreterFactoryApi = new InterpreterFactoryImpl();\n    for (Delegate delegate : delegates) {\n      if (delegate instanceof NnApiDelegate) {\n        ((NnApiDelegate) delegate).initWithInterpreterFactoryApi(interpreterFactoryApi);\n      }\n    }\n  }",
    "comment": "Complete the initialization of any delegates that require an InterpreterFactoryApi instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/DetectorActivity.java",
    "type": "method",
    "name": "onPreviewSizeChosen",
    "code": "public void onPreviewSizeChosen(final Size size, final int rotation) {\n    final float textSizePx =\n        TypedValue.applyDimension(\n            TypedValue.COMPLEX_UNIT_DIP, TEXT_SIZE_DIP, getResources().getDisplayMetrics());\n    borderedText = new BorderedText(textSizePx);\n    borderedText.setTypeface(Typeface.MONOSPACE);\n\n    tracker = new MultiBoxTracker(this);\n\n    int cropSize = TF_OD_API_INPUT_SIZE;\n    if (MODE == DetectorMode.YOLO) {\n      detector =\n          TensorFlowYoloDetector.create(\n              getAssets(),\n              YOLO_MODEL_FILE,\n              YOLO_INPUT_SIZE,\n              YOLO_INPUT_NAME,\n              YOLO_OUTPUT_NAMES,\n              YOLO_BLOCK_SIZE);\n      cropSize = YOLO_INPUT_SIZE;\n    } else if (MODE == DetectorMode.MULTIBOX) {\n      detector =\n          TensorFlowMultiBoxDetector.create(\n              getAssets(),\n              MB_MODEL_FILE,\n              MB_LOCATION_FILE,\n              MB_IMAGE_MEAN,\n              MB_IMAGE_STD,\n              MB_INPUT_NAME,\n              MB_OUTPUT_LOCATIONS_NAME,\n              MB_OUTPUT_SCORES_NAME);\n      cropSize = MB_INPUT_SIZE;\n    } else {\n      try {\n        detector = TensorFlowObjectDetectionAPIModel.create(\n            getAssets(), TF_OD_API_MODEL_FILE, TF_OD_API_LABELS_FILE, TF_OD_API_INPUT_SIZE);\n        cropSize = TF_OD_API_INPUT_SIZE;\n      } catch (final IOException e) {\n        LOGGER.e(e, \"Exception initializing classifier!\");\n        Toast toast =\n            Toast.makeText(\n                getApplicationContext(), \"Classifier could not be initialized\", Toast.LENGTH_SHORT);\n        toast.show();\n        finish();\n      }\n    }\n\n    previewWidth = size.getWidth();\n    previewHeight = size.getHeight();\n\n    sensorOrientation = rotation - getScreenOrientation();\n    LOGGER.i(\"Camera orientation relative to screen canvas: %d\", sensorOrientation);\n\n    LOGGER.i(\"Initializing at size %dx%d\", previewWidth, previewHeight);\n    rgbFrameBitmap = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);\n    croppedBitmap = Bitmap.createBitmap(cropSize, cropSize, Config.ARGB_8888);\n\n    frameToCropTransform =\n        ImageUtils.getTransformationMatrix(\n            previewWidth, previewHeight,\n            cropSize, cropSize,\n            sensorOrientation, MAINTAIN_ASPECT);\n\n    cropToFrameTransform = new Matrix();\n    frameToCropTransform.invert(cropToFrameTransform);\n\n    trackingOverlay = (OverlayView) findViewById(R.id.tracking_overlay);\n    trackingOverlay.addCallback(\n        new DrawCallback() {\n          }\n        });",
    "comment": "An activity that uses a TensorFlowMultiBoxDetector and ObjectTracker to detect and then track\nobjects."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(long[] expecteds, long[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }",
    "comment": "Asserts that two long arrays are equal. If they are not, an\n{@link AssertionError} is thrown.\n\n@param expecteds long array with expected values.\n@param actuals long array with actual values"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/NearestConflictResolverTest.java",
    "type": "method",
    "name": "testDepthReversed",
    "code": "void testDepthReversed() {\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a1n, a2n, a1n);\n    }",
    "comment": "Tests that <code>a:1.0</code> wins in the scenario:\n<pre>\nb:1.0 -&gt; a:2.0\na:1.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/converter/src/test/java/com/iluwatar/converter/ConverterTest.java",
    "type": "method",
    "name": "testCollectionConversion",
    "code": "void testCollectionConversion() {\n    var users =\n        List.of(\n            new User(\"Camile\", \"Tough\", false, \"124sad\"),\n            new User(\"Marti\", \"Luther\", true, \"42309fd\"),\n            new User(\"Kate\", \"Smith\", true, \"if0243\"));\n    var fromDtos = userConverter.createFromDtos(userConverter.createFromEntities(users));\n    assertEquals(users, fromDtos);\n  }",
    "comment": "Test whether converting a collection of Users to DTO Users and then converting them back to\ndomain users returns an equal collection."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/param/JavaTestParams.java",
    "type": "method",
    "name": "JavaTestParams",
    "code": "public JavaTestParams() {\n    this.uid_ = Identifiable$.MODULE$.randomUID(\"javaTestParams\");\n    init();\n  }",
    "comment": "A subclass of Params for testing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssumptionsTests.java",
    "type": "method",
    "name": "assumeTrueWithBooleanTrue",
    "code": "void assumeTrueWithBooleanTrue() {\n\t\tString foo = null;\n\t\ttry {\n\t\t\tassumeTrue(true);\n\t\t\tassumeTrue(true, \"message\");\n\t\t\tassumeTrue(true, () -> \"message\");\n\t\t\tfoo = \"foo\";\n\t\t}\n\t\tfinally {\n\t\t\tassertNotNull(foo);\n\t\t}\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assumptions}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/PackageSource.java",
    "type": "method",
    "name": "from",
    "code": "public static PackageSource from(Package javaPackage) {\n\t\treturn new PackageSource(javaPackage);\n\t}",
    "comment": "Create a new {@code PackageSource} using the supplied Java {@link Package}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java",
    "type": "method",
    "name": "findMethodsDoesNotReturnOverriddenDefaultMethods",
    "code": "void findMethodsDoesNotReturnOverriddenDefaultMethods() {\n\t\t\tClass<?> clazz = InterfaceWithOverriddenGenericDefaultMethodImpl.class;\n\n\t\t\tvar methods = findMethods(clazz, isFooMethod);\n\t\t\tvar signatures = signaturesOf(methods);\n\n\t\t\tassertThat(signatures).as(\"overridden default method should not be in results\").doesNotContain(\n\t\t\t\t\"foo(java.lang.Number)\");\n\t\t\tassertThat(signatures).containsExactly(\"foo(java.lang.Long)\", \"foo(java.lang.Double)\");\n\t\t}",
    "comment": "Search for all foo(*) methods.\nAlthough the subsequent assertion covers this case as well, this\nassertion is in place to provide a more informative failure message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertThrows",
    "code": "public static <T extends Throwable> T assertThrows(Class<T> expectedType, Executable executable, String message) {\n\t\treturn AssertThrows.assertThrows(expectedType, executable, message);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code executable} throws\nan exception of the {@code expectedType} and return the exception.\n\n<p>The assertion passes if the thrown exception type is the same as\n{@code expectedType} or a subtype thereof. To check for the exact thrown\ntype use {@link #assertThrowsExactly(Class, Executable, String) assertThrowsExactly}.\nIf no exception is thrown, or if an exception of a different type is thrown,\nthis method will fail.\n\n<p>If you do not want to perform additional checks on the exception instance,\nignore the return value.\n\n<p>Fails with the supplied failure {@code message}. Note that the supplied\n{@code message} is <strong>not</strong> the expected message of the thrown\nexception. To assert the expected message of the thrown exception, you must\nuse a separate, subsequent assertion against the exception returned from\nthis method.\n\n@see #assertThrowsExactly(Class, Executable, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-client-side-ui-composition/src/main/java/com/iluwatar/clientsideuicomposition/ApiGateway.java",
    "type": "method",
    "name": "registerRoute",
    "code": "public void registerRoute(String path, FrontendComponent component) {\n    routes.put(path, component);\n  }",
    "comment": "Registers a route dynamically at runtime.\n\n@param path the path to access the component (e.g., \"/products\")\n@param component the frontend component to be accessed at the given path"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryOrchestrator.java",
    "type": "method",
    "name": "prune",
    "code": "private void prune(Map<TestEngine, EngineResultInfo> testEngineResults) {\n\t\tacceptInAllTestEngines(testEngineResults, TestDescriptor::prune);\n\t}",
    "comment": "Prune all branches in the tree of {@link TestDescriptor TestDescriptors}\nthat do not have executable tests.\n\n<p>If a {@link TestEngine} ends up with no {@code TestDescriptors} after\npruning, it will <strong>not</strong> be removed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarBatch.java",
    "type": "method",
    "name": "setNumRows",
    "code": "public void setNumRows(int numRows) {\n    this.numRows = numRows;\n  }",
    "comment": "Sets the number of rows in this batch."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/memory/MemoryConsumer.java",
    "type": "method",
    "name": "allocatePage",
    "code": "protected MemoryBlock allocatePage(long required) {\n    MemoryBlock page = taskMemoryManager.allocatePage(Math.max(pageSize, required), this);\n    if (page == null || page.size() < required) {\n      throwOom(page, required);\n    }\n    used += page.size();\n    return page;\n  }",
    "comment": "Allocate a memory block with at least `required` bytes.\n\n@throws SparkOutOfMemoryError"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng8347TransitiveDependencyManagerTest.java",
    "type": "method",
    "name": "a",
    "code": "protected void a(List<String> logLines, String string) {\n        assertTrue(logLines.contains(string), \"missing \" + string);\n    }",
    "comment": "Assert true, log lines contains string..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-idempotent-consumer/src/main/java/com/iluwatar/idempotentconsumer/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SpringApplication.run(App.class, args);\n  }",
    "comment": "The main entry point for the idempotent-consumer application. This application demonstrates the\nuse of the Idempotent Consumer pattern which ensures that a message is processed exactly once in\nscenarios where the same message can be delivered multiple times.\n\n@see <a href=\"https://en.wikipedia.org/wiki/Idempotence\">Idempotence (Wikipedia)</a>\n@see <a\nhref=\"https://camel.apache.org/components/latest/eips/idempotentConsumer-eip.html\">Idempotent\nConsumer Pattern (Apache Camel)</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaBinaryClassificationMetricsExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf conf = new SparkConf().setAppName(\"Java Binary Classification Metrics Example\");\n    SparkContext sc = new SparkContext(conf);\n    String path = \"data/mllib/sample_binary_classification_data.txt\";\n    JavaRDD<LabeledPoint> data = MLUtils.loadLibSVMFile(sc, path).toJavaRDD();\n\n    JavaRDD<LabeledPoint>[] splits =\n      data.randomSplit(new double[]{0.6, 0.4}, 11L);\n}",
    "comment": "$example on$\n$example off$\n$example on$\nSplit initial RDD into two... [60% training data, 40% testing data]."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/DirectorySource.java",
    "type": "method",
    "name": "getFile",
    "code": "public final File getFile() {\n\t\treturn this.directory;\n\t}",
    "comment": "Get the source {@linkplain File directory}.\n\n@return the source directory; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java",
    "type": "method",
    "name": "individualMethodsWithinRecursiveNestedTestClassHierarchiesAreExecuted",
    "code": "void individualMethodsWithinRecursiveNestedTestClassHierarchiesAreExecuted() {\n\t\tEngineExecutionResults executionResults = executeTests(selectMethod(OuterClass.class, \"outer\"));\n\t\texecutionResults.containerEvents().assertStatistics(stats -> stats.started(2).succeeded(2));\n\t\texecutionResults.testEvents().assertStatistics(stats -> stats.started(1).succeeded(1));\n\n\t\texecutionResults = executeTests(selectMethod(NestedClass.class, \"nested\"));\n\t\texecutionResults.containerEvents().assertStatistics(stats -> stats.started(3).succeeded(3));\n\t\texecutionResults.testEvents().assertStatistics(stats -> stats.started(1).succeeded(1));\n\n\t\texecutionResults = executeTests(selectMethod(RecursiveNestedClass.class, \"nested\"));\n\t\texecutionResults.containerEvents().assertStatistics(stats -> stats.started(4).succeeded(4));\n\t\texecutionResults.testEvents().assertStatistics(stats -> stats.started(1).succeeded(1));\n\n\t\texecutionResults = executeTests(selectMethod(RecursiveNestedSiblingClass.class, \"nested\"));\n\t\texecutionResults.containerEvents().assertStatistics(stats -> stats.started(4).succeeded(4));\n\t\texecutionResults.testEvents().assertStatistics(stats -> stats.started(1).succeeded(1));\n\t}",
    "comment": "NOTE: We do not actually support this as a feature, but we currently only\ncheck for cycles if a class is selected. Thus, the tests in this method\npass, since the selection of a particular method does not result in a\nlookup for nested test classes.\n\n@since 1.6"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Verifier.java",
    "type": "method",
    "name": "apply",
    "code": "public Statement apply(final Statement base, Description description) {\n        return new Statement() {\n        };\n    }",
    "comment": "Verifier is a base class for Rules like ErrorCollector, which can turn\notherwise passing test methods into failing tests if a verification check is\nfailed\n\n<pre>\npublic static class ErrorLogVerifier {\nprivate ErrorLog errorLog = new ErrorLog();\n\n&#064;Rule\npublic Verifier verifier = new Verifier() {\n}\n\n&#064;Test public void testThatMightWriteErrorLog() {\n// ...\n}\n}\n</pre>\n\n@since 4.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isNotStatic",
    "code": "public static boolean isNotStatic(Class<?> clazz) {\n\t\treturn ReflectionUtils.isNotStatic(clazz);\n\t}",
    "comment": "Determine if the supplied class is not {@code static}.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is not {@code static}\n@see java.lang.reflect.Modifier#isStatic(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/NumericHistogram.java",
    "type": "method",
    "name": "add",
    "code": "public void add(double v) {\n    // Binary search to find the closest bucket that v should go into.\n    // 'bin' should be interpreted as the bin to shift right in order to accomodate\n    // v. As a result, bin is in the range [0,N], where N means that the value v is\n    // greater than all the N bins currently in the histogram. It is also possible that\n    // a bucket centered at 'v' already exists, so this must be checked in the next step.\n    int bin = 0;\n    for (int l = 0, r = nusedbins; l < r; ) {\n      bin = (l + r) / 2;\n      if (bins.get(bin).x > v) {\n        r = bin;\n      } else {\n        if (bins.get(bin).x < v) {\n          l = ++bin;\n        } else {\n          break; // break loop on equal comparator\n        }\n      }\n    }\n\n    // If we found an exact bin match for value v, then just increment that bin's count.\n    // Otherwise, we need to insert a new bin and trim the resulting histogram back to size.\n    // A possible optimization here might be to set some threshold under which 'v' is just\n    // assumed to be equal to the closest bin -- if fabs(v-bins[bin].x) < THRESHOLD, then\n    // just increment 'bin'. This is not done now because we don't want to make any\n    // assumptions about the range of numeric data being analyzed.\n    if (bin < nusedbins && bins.get(bin).x == v) {\n      bins.get(bin).y++;\n    } else {\n      Coord newBin = new Coord();\n      newBin.x = v;\n      newBin.y = 1;\n      bins.add(bin, newBin);\n\n      // Trim the bins down to the correct number of bins.\n      if (++nusedbins > nbins) {\n        trim();\n      }\n    }\n\n  }",
    "comment": "Adds a new data point to the histogram approximation. Make sure you have\ncalled either allocate() or merge() first. This method implements Algorithm #1\nfrom Ben-Haim and Tom-Tov, \"A Streaming Parallel Decision Tree Algorithm\", JMLR 2010.\n\n@param v The data point to add to the histogram approximation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/subclass-sandbox/src/main/java/com/iluwatar/subclasssandbox/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    LOGGER.info(\"Use superpower: sky launch\");\n    var skyLaunch = new SkyLaunch();\n    skyLaunch.activate();\n    LOGGER.info(\"Use superpower: ground dive\");\n    var groundDive = new GroundDive();\n    groundDive.activate();\n  }",
    "comment": "Entry point of the main program.\n\n@param args Program runtime arguments."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "newInstance",
    "code": "public static ErrorDialog newInstance(final String message) {\n      final ErrorDialog dialog = new ErrorDialog();\n      final Bundle args = new Bundle();\n      args.putString(ARG_MESSAGE, message);\n      dialog.setArguments(args);\n      return dialog;\n    }",
    "comment": "Shows an error message dialog."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/auth/HttpAuthUtils.java",
    "type": "method",
    "name": "getUserNameFromCookieToken",
    "code": "public static String getUserNameFromCookieToken(String tokenStr) {\n    Map<String, String> map = splitCookieToken(tokenStr);\n\n    if (!map.keySet().equals(COOKIE_ATTRIBUTES)) {\n      LOG.error(\"Invalid token with missing attributes {}\",\n        MDC.of(LogKeys.TOKEN$.MODULE$, tokenStr));\n      return null;\n    }\n    return map.get(COOKIE_CLIENT_USER_NAME);\n  }",
    "comment": "Parses a cookie token to retrieve client user name.\n@param tokenStr Token String.\n@return A valid user name if input is of valid format, else returns null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProjectActivation.java",
    "type": "method",
    "name": "overwriteInactiveProjects",
    "code": "public void overwriteInactiveProjects(List<String> inactiveProjectSelectors) {\n        List<ProjectActivationSettings> projects =\n                getProjects(pa -> !pa.active()).toList();\n        this.activations.removeAll(projects);\n        inactiveProjectSelectors.forEach(this::deactivateOptionalProject);\n    }",
    "comment": "Overwrites the inactive projects based on a pre-Maven 4 \"inactive projects\" list.\n@param inactiveProjectSelectors A {@link List} of project selectors that must be deactivated.\n@deprecated Use {@link #deactivateOptionalProject(String)} or {@link #deactivateRequiredProject(String)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/spatial-partition/src/main/java/com/iluwatar/spatialpartition/QuadTree.java",
    "type": "method",
    "name": "query",
    "code": "Collection<Point> query(Rect r, Collection<Point> relevantPoints) {\n    if (this.boundary.intersects(r)) {\n      this.points.values().stream().filter(r::contains).forEach(relevantPoints::add);\n      if (this.divided) {\n        this.northwest.query(r, relevantPoints);\n        this.northeast.query(r, relevantPoints);\n        this.southwest.query(r, relevantPoints);\n        this.southeast.query(r, relevantPoints);\n      }\n    }\n    return relevantPoints;\n  }",
    "comment": "could also be a circle instead of a rectangle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setDouble",
    "code": "public void setDouble(double value) {\n    doubleData = value;\n  }",
    "comment": "Sets the double `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/protocol/AbstractFetchShuffleBlocks.java",
    "type": "method",
    "name": "equals",
    "code": "public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    AbstractFetchShuffleBlocks that = (AbstractFetchShuffleBlocks) o;\n    return shuffleId == that.shuffleId\n      && Objects.equal(appId, that.appId) && Objects.equal(execId, that.execId);\n  }",
    "comment": "Returns number of blocks in the request."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "aborted",
    "code": "public Executions aborted() {\n\t\treturn new Executions(finishedExecutionsByStatus(Status.ABORTED), this.category + \" Aborted\");\n\t}",
    "comment": "Get the aborted {@link Executions} contained in this {@code Executions} object.\n\n@return the filtered {@code Executions}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/TestMethod.java",
    "type": "method",
    "name": "TestMethod",
    "code": "public TestMethod(Method method, TestClass testClass) {\n        this.method = method;\n        this.testClass = testClass;\n    }",
    "comment": "@deprecated Included for backwards compatibility with JUnit 4.4. Will be\nremoved in the next major release. Please use\n{@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/Transport.java",
    "type": "method",
    "name": "putString",
    "code": "default void putString(@Nonnull String source, @Nonnull URI relativeTarget) {\n        putString(source, StandardCharsets.UTF_8, relativeTarget);\n    }",
    "comment": "PUTs the source string using UTF8 charset to target URI. The target MUST BE relative from the\n{@link RemoteRepository#getUrl()} root.\n\n@throws RuntimeException If PUT fails for any reason."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isNotPrivate",
    "code": "public static boolean isNotPrivate(Member member) {\n\t\treturn ReflectionUtils.isNotPrivate(member);\n\t}",
    "comment": "Determine if the supplied member is not {@code private}.\n\n<p>In other words this method will return {@code true} for members\ndeclared as {@code public}, {@code protected}, or\n<em>package private</em> and {@code false} for members declared as\n{@code private}.\n\n@param member the member to check; never {@code null}\n@return {@code true} if the member is not {@code private}\n@see java.lang.reflect.Modifier#isPublic(int)\n@see java.lang.reflect.Modifier#isProtected(int)\n@see java.lang.reflect.Modifier#isPrivate(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SaslServerBootstrap.java",
    "type": "method",
    "name": "doBootstrap",
    "code": "public RpcHandler doBootstrap(Channel channel, RpcHandler rpcHandler) {\n    return new SaslRpcHandler(conf, channel, rpcHandler, secretKeyHolder);\n  }",
    "comment": "Wrap the given application handler in a SaslRpcHandler that will handle the initial SASL\nnegotiation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/Filter.java",
    "type": "method",
    "name": "adaptFilter",
    "code": "static <T, V> Filter<T> adaptFilter(Filter<V> adaptee, Function<T, V> converter) {\n\t\treturn input -> adaptee.apply(converter.apply(input));\n\t}",
    "comment": "Return a filter that will include elements if and only if the adapted\n{@code Filter} includes the value converted using the supplied\n{@link Function}.\n\n@param adaptee the filter to be adapted\n@param converter the converter function to apply"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-client-side-ui-composition/src/main/java/com/iluwatar/clientsideuicomposition/ProductFrontend.java",
    "type": "method",
    "name": "getData",
    "code": "protected String getData(Map<String, String> params) {\n    String category = params.getOrDefault(\"category\", \"all\");\n    return \"Product List for category '\" + category + \"': [Product 1, Product 2, Product 3]\";\n  }",
    "comment": "Fetches a list of products based on dynamic parameters such as category.\n\n@param params parameters that influence the data fetched, e.g., \"category\"\n@return a string representing a filtered list of products"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java",
    "type": "method",
    "name": "registerExtensionsFromInstanceFields",
    "code": "static void registerExtensionsFromInstanceFields(ExtensionRegistrar registrar, Class<?> clazz) {\n\t\tstreamExtensionRegisteringFields(clazz, ReflectionUtils::isNotStatic) //\n\t\t\t\t.forEach(field -> {\n\t\t\t\t\tList<Class<? extends Extension>> extensionTypes = streamDeclarativeExtensionTypes(field).collect(\n\t\t\t\t\t\ttoList());\n\t\t\t\t\tboolean isExtendWithPresent = !extensionTypes.isEmpty();\n\n\t\t\t\t\tif (isExtendWithPresent) {\n\t\t\t\t\t\textensionTypes.forEach(registrar::registerExtension);\n\t\t\t\t\t}\n\t\t\t\t\tif (isAnnotated(field, RegisterExtension.class)) {\n\t\t\t\t\t\tregistrar.registerUninitializedExtension(clazz, field,\n\t\t\t\t\t\t\tinstance -> readAndValidateExtensionFromField(field, instance, extensionTypes));\n\t\t\t\t\t}\n\t\t\t\t});\n\t}",
    "comment": "Register extensions using the supplied registrar from instance fields in\nthe supplied class that are annotated with {@link ExtendWith @ExtendWith}\nor {@link RegisterExtension @RegisterExtension}.\n\n<p>The extensions will be sorted according to {@link Order @Order} semantics\nprior to registration.\n\n@param registrar the registrar with which to register the extensions; never {@code null}\n@param clazz the class or interface in which to find the fields; never {@code null}\n@since 5.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelPathTranslator.java",
    "type": "method",
    "name": "map",
    "code": "private <T> List<T> map(List<T> resources, BiFunction<T, Path, T> mapper, Path basedir) {\n        List<T> newResources = null;\n        if (resources != null) {\n            for (int i = 0; i < resources.size(); i++) {\n                T resource = resources.get(i);\n                T newResource = mapper.apply(resource, basedir);\n                if (newResource != resource) {\n                    if (newResources == null) {\n                        newResources = new ArrayList<>(resources);\n                    }\n                    newResources.set(i, newResource);\n                }\n            }\n        }\n        return newResources;\n    }",
    "comment": "Replaces in a new list all elements of the given list using the given function.\nIf no list element has changed, then this method returns the previous list instance.\nThe given list is never modified.\n\n@param resource the list for which to replace elements\n@param mapper one of the {@code this::alignToBaseDirectory} methods\n@param basedir the new base directory\n@return list with modified elements, or {@code resources} if there is no change"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "finished",
    "code": "public static Condition<Event> finished(Condition<TestExecutionResult> resultCondition) {\n\t\treturn allOf(type(FINISHED), result(resultCondition));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link EventType#FINISHED} and its\n{@linkplain Event#getPayload() payload} is an instance of\n{@link TestExecutionResult} that matches the supplied {@code Condition}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstantiationAwareExtension.java",
    "type": "method",
    "name": "getTestInstantiationExtensionContextScope",
    "code": "default ExtensionContextScope getTestInstantiationExtensionContextScope(ExtensionContext rootContext) {\n\t\treturn ExtensionContextScope.DEFAULT;\n\t}",
    "comment": "Whether this extension should receive a test-scoped\n{@link ExtensionContext} during the instantiation of test instances.\n\n<p>If an extension returns\n{@link ExtensionContextScope#TEST_METHOD TEST_METHOD} from this method,\nthe following extension methods will be called with a test-scoped\n{@link ExtensionContext} instead of a class-scoped one, unless the\n{@link TestInstance.Lifecycle#PER_CLASS PER_CLASS} lifecycle is used:\n\n<ul>\n<li>{@link InvocationInterceptor#interceptTestClassConstructor}</li>\n<li>{@link ParameterResolver} when resolving constructor parameters</li>\n<li>{@link TestInstancePreConstructCallback}</li>\n<li>{@link TestInstancePostProcessor}</li>\n<li>{@link TestInstanceFactory}</li>\n</ul>\n\n<p>In such cases, implementations of these extension callbacks can\nobserve the following differences:\n\n<ul>\n<li>{@link ExtensionContext#getElement() getElement()} may refer to the\ntest method and {@link ExtensionContext#getTestClass() getTestClass()}\nmay refer to a nested test class.\nUse {@link TestInstanceFactoryContext#getTestClass()} to get the class\nunder construction.</li>\n<li>{@link ExtensionContext#getTestMethod() getTestMethod()} is no longer\nempty, unless the {@link TestInstance.Lifecycle#PER_CLASS PER_CLASS}\nlifecycle is used.</li>\n<li>If the callback adds a new {@link Store.CloseableResource} or\n{@code junit.jupiter.extensions.store.close.autocloseable.enabled}\nconfiguration parameter is set to {@code false}), then\nthe resource is closed just after the instance is destroyed.</li>\n<li>The callbacks can now access data previously stored by\n{@link TestTemplateInvocationContext}, unless the\n{@link TestInstance.Lifecycle#PER_CLASS PER_CLASS} lifecycle is used.</li>\n</ul>\n\n<p><strong>Note</strong>: The behavior which is enabled by returning\n{@link ExtensionContextScope#TEST_METHOD TEST_METHOD} from this method\nwill become the default in future versions of JUnit. To ensure forward\ncompatibility, extension implementors are therefore advised to opt in,\neven if they don't require the new functionality.\n\n@implNote There are no guarantees about how often this method is called.\nTherefore, implementations should be idempotent and avoid side\neffects. They may, however, cache the result for performance in\nthe {@link Store Store} of the supplied\n{@link ExtensionContext}, if necessary.\n@param rootContext the root extension context to allow inspection of\nconfiguration parameters; never {@code null}\n@since 5.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ParameterResolverTests.java",
    "type": "method",
    "name": "setUpAndTearDown",
    "code": "void setUpAndTearDown(CustomType customType, @CustomAnnotation String value) {\n\t\t\tassertNotNull(customType);\n\t\t\tassertNotNull(value);\n\t\t}",
    "comment": "This set-up / tear-down method is here to verify that {@code @BeforeEach}\nand {@code @AfterEach} methods are properly invoked using the same\n{@code ExtensionRegistry} as the one used for the corresponding\n{@code @Test} method.\n\n@see <a href=\"https://github.com/junit-team/junit5/issues/523\">#523</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Integer unexpected, int actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Integer) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(double unexpected, double actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java",
    "type": "method",
    "name": "compareTo",
    "code": "public int compareTo(Item item) {\n            if (item == null) {\n                return stringPart.compareTo(item);\n            }\n            int result = 0;\n            switch (item.getType()) {\n                case INT_ITEM:\n                case LONG_ITEM:\n                case BIGINTEGER_ITEM:\n                    return -1;\n\n                case STRING_ITEM:\n                    result = stringPart.compareTo(item);\n                    if (result == 0) {\n                        return 1;\n                    }\n                    return result;\n\n                case LIST_ITEM:\n                    return -1;\n\n                case COMBINATION_ITEM:\n                    result = stringPart.compareTo(((CombinationItem) item).getStringPart());\n                    if (result == 0) {\n                        return digitPart.compareTo(((CombinationItem) item).getDigitPart());\n                    }\n                    return result;\n                default:\n                    return 0;\n            }\n        }",
    "comment": "1-rc1 < 1, 1-ga1 > 1\nX1 > X"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/max/MaxCore.java",
    "type": "method",
    "name": "forFolder",
    "code": "public static MaxCore forFolder(String folderName) {\n        return storedLocally(new File(folderName));\n    }",
    "comment": "Create a new MaxCore from a serialized file stored at storedResults\n\n@deprecated use storedLocally()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "mergeAt",
    "code": "private void mergeAt(int i) {\n      assert stackSize >= 2;\n      assert i >= 0;\n      assert i == stackSize - 2 || i == stackSize - 3;\n\n      int base1 = runBase[i];\n      int len1 = runLen[i];\n      int base2 = runBase[i + 1];\n      int len2 = runLen[i + 1];\n      assert len1 > 0 && len2 > 0;\n      assert base1 + len1 == base2;\n\n      /*\n       * Record the length of the combined runs; if i is the 3rd-last\n       * run now, also slide over the last run (which isn't involved\n       * in this merge).  The current run (i+1) goes away in any case.\n       */\n      runLen[i] = len1 + len2;\n      if (i == stackSize - 3) {\n        runBase[i + 1] = runBase[i + 2];\n        runLen[i + 1] = runLen[i + 2];\n      }\n      stackSize--;\n\n      K key0 = s.newKey();\n\n      /*\n       * Find where the first element of run2 goes in run1. Prior elements\n       * in run1 can be ignored (because they're already in place).\n       */\n      int k = gallopRight(s.getKey(a, base2, key0), a, base1, len1, 0, c);\n      assert k >= 0;\n      base1 += k;\n      len1 -= k;\n      if (len1 == 0)\n        return;\n\n      /*\n       * Find where the last element of run1 goes in run2. Subsequent elements\n       * in run2 can be ignored (because they're already in place).\n       */\n      len2 = gallopLeft(s.getKey(a, base1 + len1 - 1, key0), a, base2, len2, len2 - 1, c);\n      assert len2 >= 0;\n      if (len2 == 0)\n        return;\n\n      // Merge remaining runs, using tmp array with min(len1, len2) elements\n      if (len1 <= len2)\n        mergeLo(base1, len1, base2, len2);\n      else\n        mergeHi(base1, len1, base2, len2);\n    }",
    "comment": "Merges the two runs at stack indices i and i+1.  Run i must be\nthe penultimate or antepenultimate run on the stack.  In other words,\ni must be equal to stackSize-2 or stackSize-3.\n\n@param i stack index of the first of the two runs to merge"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createYearMonthIntervalType",
    "code": "public static YearMonthIntervalType createYearMonthIntervalType(byte startField, byte endField) {\n    return YearMonthIntervalType$.MODULE$.apply(startField, endField);\n  }",
    "comment": "Creates a YearMonthIntervalType by specifying the start and end fields."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/ExecutionRecorder.java",
    "type": "method",
    "name": "getExecutionResults",
    "code": "public EngineExecutionResults getExecutionResults() {\n\t\treturn new EngineExecutionResults(this.events);\n\t}",
    "comment": "Get the state of the engine's execution in the form of {@link EngineExecutionResults}.\n\n@return the {@code EngineExecutionResults} containing all current state information"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/ChildFirstURLClassLoader.java",
    "type": "method",
    "name": "ChildFirstURLClassLoader",
    "code": "public ChildFirstURLClassLoader(URL[] urls, ClassLoader parent) {\n    super(urls, null);\n    this.parent = new ParentClassLoader(parent);\n  }",
    "comment": "A mutable class loader that gives preference to its own URLs over the parent class loader\nwhen loading classes and resources."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlob",
    "code": "public static Tensor fromBlob(int[] data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_ARRAY_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.length, shape);\n    final IntBuffer intBuffer = allocateIntBuffer((int) numel(shape));\n    intBuffer.put(data);\n    return new Tensor_int32(intBuffer, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.int32 with specified shape and data as array of\nints.\n\n@param data Tensor elements\n@param shape Tensor shape"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/TestTagTests.java",
    "type": "method",
    "name": "validSyntax",
    "code": "void validSyntax() {\n\t\t// @formatter:off\n\t\tassertAll(\"Valid Tag Syntax\",\n\t\t\t() -> yep(\"fast\"),\n\t\t\t() -> yep(\"super_fast\"),\n\t\t\t() -> yep(\"unit-test\"),\n\t\t\t() -> yep(\"integration.test\"),\n\t\t\t() -> yep(\"org.example.CustomTagClass\"),\n\t\t\t() -> yep(\"  surrounded-by-whitespace\\t\\n\"),\n\t\t\t() -> nope(null),\n\t\t\t() -> nope(\"\"),\n\t\t\t() -> nope(\"     \"),\n\t\t\t() -> nope(\"\\t\"),\n\t\t\t() -> nope(\"\\f\"),\n\t\t\t() -> nope(\"\\r\"),\n\t\t\t() -> nope(\"\\n\"),\n\t\t\t() -> nope(\"custom tag\"), // internal space\n\t\t\t() -> nope(\",\"),          // comma\n\t\t\t() -> nope(\"(\"),          // opening parenthesis\n\t\t\t() -> nope(\")\"),          // closing parenthesis\n\t\t\t() -> nope(\"&\"),          // boolean AND\n\t\t\t() -> nope(\"|\"),          // boolean OR\n\t\t\t() -> nope(\"!\")           // boolean NOT\n\t\t);\n\t\t// @formatter:on\n\t}",
    "comment": "Unit tests for {@link TestTag}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/categories/Categories.java",
    "type": "method",
    "name": "toString",
    "code": "@Override public String toString() {\n            StringBuilder description= new StringBuilder(\"categories \")\n                .append(included.isEmpty() ? \"[all]\" : included);\n            if (!excluded.isEmpty()) {\n                description.append(\" - \").append(excluded);\n            }\n            return description.toString();\n        }",
    "comment": "Returns string in the form <tt>&quot;[included categories] - [excluded categories]&quot;</tt>, where both\nsets have comma separated names of categories.\n\n@return string representation for the relative complement of excluded categories set\nin the set of included categories. Examples:\n<ul>\n<li> <tt>&quot;categories [all]&quot;</tt> for all included categories and no excluded ones;\n<li> <tt>&quot;categories [all] - [A, B]&quot;</tt> for all included categories and given excluded ones;\n<li> <tt>&quot;categories [A, B] - [C, D]&quot;</tt> for given included categories and given excluded ones.\n</ul>\n@see Class#toString() name of category"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptor.java",
    "type": "method",
    "name": "setRequiredMavenVersion",
    "code": "public void setRequiredMavenVersion(String requiredMavenVersion) {\n        this.requiredMavenVersion = requiredMavenVersion;\n    }",
    "comment": "Set required Maven version, as defined in plugin's pom.xml since 3.0.2,\nas defined in plugin.xml since 4.0.0-alpha-3.\n\n@param requiredMavenVersion Maven version required by the plugin\n@since 3.0.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/AssertionsDemo.java",
    "type": "method",
    "name": "groupedAssertions",
    "code": "void groupedAssertions() {\n\t\tassertAll(\"person\",\n\t\t\t() -> assertEquals(\"Jane\", person.getFirstName()),\n\t\t\t() -> assertEquals(\"Doe\", person.getLastName())\n\t\t);\n\t}",
    "comment": "In a grouped assertion all assertions are executed, and all\nfailures will be reported together."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroPrimitives.java",
    "type": "method",
    "name": "setIntColumn",
    "code": "public void setIntColumn(java.lang.Integer value) {\n    this.int_column = value;\n  }",
    "comment": "Sets the value of the 'int_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/gateway/src/test/java/com/iluwatar/gateway/AppTest.java",
    "type": "method",
    "name": "testServiceCError",
    "code": "void testServiceCError() {\n    try {\n      ExternalServiceC serviceC = (ExternalServiceC) gatewayFactory.getGateway(\"ServiceC\");\n      serviceC.error();\n      fail(\"Service C should throw an exception.\");\n    } catch (Exception e) {\n      assertEquals(\"Service C encountered an error\", e.getMessage());\n    }\n  }",
    "comment": "Wait for Service C to complete"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/metadata/DefaultMetadataResolutionRequest.java",
    "type": "method",
    "name": "DefaultMetadataResolutionRequest",
    "code": "public DefaultMetadataResolutionRequest() {\n        repositoryRequest = new DefaultRepositoryRequest();\n    }",
    "comment": "Forms a request to retrieve artifact metadata."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkSubmitOptionParser.java",
    "type": "method",
    "name": "handleExtraArgs",
    "code": "protected void handleExtraArgs(List<String> extra) {\n    throw new UnsupportedOperationException();\n  }",
    "comment": "Callback for remaining command line arguments after either {@link #handle(String, String)} or\n{@link #handleUnknown(String)} return \"false\". This will be called at the end of parsing even\nwhen there are no remaining arguments.\n\n@param extra List of remaining arguments."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TemporaryFolder.java",
    "type": "method",
    "name": "recursiveDelete",
    "code": "private boolean recursiveDelete(File file) {\n        if (file.delete()) {\n            return true;\n        }\n        File[] files = file.listFiles();\n        if (files != null) {\n            for (File each : files) {\n                if (!recursiveDelete(each)) {\n                    return false;\n                }\n            }\n        }\n        return file.delete();\n    }",
    "comment": "Try deleting file before assuming file is a directory\nto prevent following symbolic links."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/CustomHealthIndicatorTest.java",
    "type": "method",
    "name": "whenDatabaseIsUp_thenHealthIsUp",
    "code": "void whenDatabaseIsUp_thenHealthIsUp() {\n    CompletableFuture<Health> future =\n        CompletableFuture.completedFuture(Health.up().withDetail(\"database\", \"reachable\").build());\n    when(healthChecker.performCheck(any(), anyLong())).thenReturn(future);\n    when(healthCheckRepository.checkHealth()).thenReturn(1);\n\n    Health health = customHealthIndicator.health();\n\n    assertEquals(Status.UP, health.getStatus());\n  }",
    "comment": "Test case for the `health()` method when the database is up.\n\n<p>Asserts that when the `health()` method is called and the database is up, it returns a\nHealth object with Status.UP."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/main/java/com/example/android/observability/ui/UserActivity.java",
    "type": "method",
    "name": "onStart",
    "code": "protected void onStart() {\n        super.onStart();\n        mDisposable.add(mViewModel.getUserName()\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(userName -> mUserName.setText(userName),\n                        throwable -> Log.e(TAG, \"Unable to get username\", throwable)));\n    }",
    "comment": "Subscribe to the emissions of the user name from the view model.\nUpdate the user name text view, at every onNext emission.\nIn case of error, log the exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertIterableEquals",
    "code": "public static void assertIterableEquals(Iterable<?> expected, Iterable<?> actual) {\n\t\tAssertIterableEquals.assertIterableEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} iterables are deeply equal.\n<p>Similarly to the check for deep equality in {@link #assertArrayEquals(Object[], Object[])},\nif two iterables are encountered (including {@code expected} and {@code actual}) then their\niterators must return equal elements in the same order as each other. <strong>Note:</strong>\nthis means that the iterables <em>do not</em> need to be of the same type. Example: <pre>{@code\nimport static java.util.Arrays.asList;\n...\nIterable<Integer> i0 = new ArrayList<>(asList(1, 2, 3));\nIterable<Integer> i1 = new LinkedList<>(asList(1, 2, 3));\nassertIterableEquals(i0, i1); // Passes\n}</pre>\n<p>If both {@code expected} and {@code actual} are {@code null}, they are considered equal.\n\n@see Objects#equals(Object, Object)\n@see Arrays#deepEquals(Object[], Object[])\n@see #assertArrayEquals(Object[], Object[])"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Double expected, Double actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/RequestTraceHelper.java",
    "type": "method",
    "name": "exit",
    "code": "public static void exit(ResolverTrace trace) {\n        InternalSession iSession = InternalSession.from(trace.session());\n        iSession.setCurrentTrace(trace.mvnTrace().parent());\n    }",
    "comment": "Restores the parent trace as the current trace in the session\n@param trace The current resolver trace to exit from"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/OnHeapColumnVector.java",
    "type": "method",
    "name": "getDictId",
    "code": "public int getDictId(int rowId) {\n    assert(dictionary == null)\n            : \"A ColumnVector dictionary should not have a dictionary for itself.\";\n    return intData[rowId];\n  }",
    "comment": "Returns the dictionary Id for rowId.\nThis should only be called when the ColumnVector is dictionaryIds.\nWe have this separate method for dictionaryIds as per SPARK-16928."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/RunListenerAdapter.java",
    "type": "method",
    "name": "testSuiteFinished",
    "code": "public void testSuiteFinished(Description description) {\n\t\tRunnerTestDescriptor runnerTestDescriptor = testRun.getRunnerTestDescriptor();\n\t\tif (!runnerTestDescriptor.getDescription().equals(description)) {\n\t\t\treportContainerFinished(lookupOrRegisterCurrentTestDescriptor(description));\n\t\t}\n\t}",
    "comment": "runnerTestDescriptor is reported in testRunFinished"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "concatWs",
    "code": "public static UTF8String concatWs(UTF8String separator, UTF8String... inputs) {\n    if (separator == null) {\n      return null;\n    }\n\n    long numInputBytes = 0L;  // total number of bytes from the inputs\n    int numInputs = 0;      // number of non-null inputs\n    for (UTF8String input : inputs) {\n      if (input != null) {\n        numInputBytes += input.numBytes;\n        numInputs++;\n      }\n    }\n\n    if (numInputs == 0) {\n      // Return an empty string if there is no input, or all the inputs are null.\n      return EMPTY_UTF8;\n    }\n\n    // Allocate a new byte array, and copy the inputs one by one into it.\n    // The size of the new array is the size of all inputs, plus the separators.\n    int resultSize = Math.toIntExact(numInputBytes + (numInputs - 1) * (long)separator.numBytes);\n    final byte[] result = new byte[resultSize];\n    int offset = 0;\n\n    for (int i = 0, j = 0; i < inputs.length; i++) {\n      if (inputs[i] != null) {\n        int len = inputs[i].numBytes;\n        copyMemory(\n          inputs[i].base, inputs[i].offset,\n          result, BYTE_ARRAY_OFFSET + offset,\n          len);\n        offset += len;\n\n        j++;\n        // Add separator if this is not the last input.\n        if (j < numInputs) {\n          copyMemory(\n            separator.base, separator.offset,\n            result, BYTE_ARRAY_OFFSET + offset,\n            separator.numBytes);\n          offset += separator.numBytes;\n        }\n      }\n    }\n    return fromBytes(result);\n  }",
    "comment": "Concatenates input strings together into a single string using the separator.\nA null input is skipped. For example, concat(\",\", \"a\", null, \"c\") would yield \"a,c\"."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "fail",
    "code": "public static void fail(String message) {\n        if (message == null) {\n            throw new AssertionError();\n        }\n        throw new AssertionError(message);\n    }",
    "comment": "Fails a test with the given message.\n\n@param message the identifying message for the {@link AssertionError} (<code>null</code>\nokay)\n@see AssertionError"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/internal/runners/statements/FailOnTimeoutTest.java",
    "type": "method",
    "name": "stackTraceContainsRealCauseOfTimeout",
    "code": "public void stackTraceContainsRealCauseOfTimeout() {\n        TestTimedOutException timedOutException = assertThrows(\n                TestTimedOutException.class,\n                run(failAfter50Ms(new StuckStatement())));\n\n        StackTraceElement[] stackTrace = timedOutException.getStackTrace();\n        boolean stackTraceContainsTheRealCauseOfTheTimeout = false;\n        boolean stackTraceContainsOtherThanTheRealCauseOfTheTimeout = false;\n        for (StackTraceElement element : stackTrace) {\n            String methodName = element.getMethodName();\n            if (\"theRealCauseOfTheTimeout\".equals(methodName)) {\n                stackTraceContainsTheRealCauseOfTheTimeout = true;\n            }\n            if (\"notTheRealCauseOfTheTimeout\".equals(methodName)) {\n                stackTraceContainsOtherThanTheRealCauseOfTheTimeout = true;\n            }\n        }\n        assertTrue(\n                \"Stack trace does not contain the real cause of the timeout\",\n                stackTraceContainsTheRealCauseOfTheTimeout);\n        assertFalse(\n                \"Stack trace contains other than the real cause of the timeout, which can be very misleading\",\n                stackTraceContainsOtherThanTheRealCauseOfTheTimeout);\n    }",
    "comment": "RunForASecond can be interrupted because it checks the Thread's\ninterrupted flag.\nThread is explicitly stopped if it finishes faster than its\npre-defined execution time of one second."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/StreamFailure.java",
    "type": "method",
    "name": "StreamFailure",
    "code": "public StreamFailure(String streamId, String error) {\n    this.streamId = streamId;\n    this.error = error;\n  }",
    "comment": "Message indicating an error when transferring a stream."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "equals",
    "code": "public boolean equals(final Object other) {\n    if (other instanceof UTF8String o) {\n      return binaryEquals(o);\n    } else {\n      return false;\n    }\n  }",
    "comment": "Binary equality check of two UTF8String. Note that binary equality is not the same as\nequality under given collation. E.g. if string is collated in case-insensitive two strings\nare considered equal even if they are different in binary comparison."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/MethodMap.java",
    "type": "method",
    "name": "isMethodInvocationConvertible",
    "code": "private static boolean isMethodInvocationConvertible(Class<?> formal, Class<?> actual) {\n        // if it's a null, it means the arg was null\n        if (actual == null && !formal.isPrimitive()) {\n            return true;\n        }\n\n        // Check for identity or widening reference conversion\n        if (actual != null && formal.isAssignableFrom(actual)) {\n            return true;\n        }\n\n        // Check for boxing with widening primitive conversion. Note that\n        // actual parameters are never primitives.\n        if (formal.isPrimitive()) {\n            if (formal == Boolean.TYPE && actual == Boolean.class) {\n                return true;\n            }\n            if (formal == Character.TYPE && actual == Character.class) {\n                return true;\n            }\n            if (formal == Byte.TYPE && actual == Byte.class) {\n                return true;\n            }\n            if (formal == Short.TYPE && (actual == Short.class || actual == Byte.class)) {\n                return true;\n            }\n            if (formal == Integer.TYPE && (actual == Integer.class || actual == Short.class || actual == Byte.class)) {\n                return true;\n            }\n            if (formal == Long.TYPE\n                    && (actual == Long.class\n                            || actual == Integer.class\n                            || actual == Short.class\n                            || actual == Byte.class)) {\n                return true;\n            }\n            if (formal == Float.TYPE\n                    && (actual == Float.class\n                            || actual == Long.class\n                            || actual == Integer.class\n                            || actual == Short.class\n                            || actual == Byte.class)) {\n                return true;\n            }\n            if (formal == Double.TYPE\n                    && (actual == Double.class\n                            || actual == Float.class\n                            || actual == Long.class\n                            || actual == Integer.class\n                            || actual == Short.class\n                            || actual == Byte.class)) {\n                return true;\n            }\n        }\n\n        return false;\n    }",
    "comment": "Determines whether a type represented by a class object is\nconvertible to another type represented by a class object using a\nmethod invocation conversion, treating object types of primitive\ntypes as if they were primitive types (that is, a Boolean actual\nparameter type matches boolean primitive formal type). This behavior\nis because this method is used to determine applicable methods for\nan actual parameter list, and primitive types are represented by\ntheir object duals in reflective method calls.\n\n@param formal the formal parameter type to which the actual\nparameter type should be convertible\n@param actual the actual parameter type.\n@return true if either formal type is assignable from actual type,\nor formal is a primitive type and actual is its corresponding object\ntype or an object type of a primitive type that can be converted to\nthe formal type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/game-loop/src/main/java/com/iluwatar/gameloop/GameLoop.java",
    "type": "method",
    "name": "isGameRunning",
    "code": "public boolean isGameRunning() {\n    return status == GameStatus.RUNNING;\n  }",
    "comment": "Check if game is running or not.\n\n@return {@code true} if the game is running."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "findInSet",
    "code": "public static int findInSet(final UTF8String match, final UTF8String set, int collationId) {\n    if (match.contains(UTF8String.fromString(\",\"))) {\n      return 0;\n    }\n    int byteIndex = 0, charIndex = 0, wordCount = 1, lastComma = -1;\n    while (byteIndex < set.numBytes()) {\n      byte nextByte = set.getByte(byteIndex);\n      if (nextByte == (byte) ',') {\n        if (set.substring(lastComma + 1, charIndex).semanticEquals(match, collationId)) {\n          return wordCount;\n        }\n        lastComma = charIndex;\n        ++wordCount;\n      }\n      byteIndex += UTF8String.numBytesForFirstByte(nextByte);\n      ++charIndex;\n    }\n    if (set.substring(lastComma + 1, set.numBytes()).semanticEquals(match, collationId)) {\n      return wordCount;\n    }\n    return 0;\n  }",
    "comment": "If the \"word\" string contains a comma, FindInSet should return 0.\nOtherwise, search for commas in \"set\" and compare each substring with \"word\".\nIf no match is found, return 0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/metadata/DefaultGraphConflictResolver.java",
    "type": "method",
    "name": "findLinkedSubgraph",
    "code": "private MetadataGraph findLinkedSubgraph(MetadataGraph g) {\n        if (g.getVertices().size() == 1) {\n            return g;\n        }\n\n        List<MetadataGraphVertex> visited = new ArrayList<>(g.getVertices().size());\n        visit(g.getEntry(), visited, g);\n\n        List<MetadataGraphVertex> dropList = new ArrayList<>(g.getVertices().size());\n\n        for (MetadataGraphVertex v : g.getVertices()) {\n            if (!visited.contains(v)) {\n                dropList.add(v);\n            }\n        }\n\n        if (dropList.size() < 1) {\n            return g;\n        }\n\n        TreeSet<MetadataGraphVertex> vertices = g.getVertices();\n        for (MetadataGraphVertex v : dropList) {\n            vertices.remove(v);\n        }\n\n        return g;\n    }",
    "comment": "-------------------------------------------------------------------------------------\ncollect drop list\nnow - drop vertices"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/ovic/src/main/java/org/tensorflow/ovic/OvicClassifier.java",
    "type": "method",
    "name": "getLastNativeInferenceLatencyMilliseconds",
    "code": "public Long getLastNativeInferenceLatencyMilliseconds() {\n    if (tflite == null) {\n      throw new RuntimeException(TAG + \": ImageNet classifier has not been initialized; Failed.\");\n    }\n    Long latency = tflite.getLastNativeInferenceDurationNanoseconds();\n    return (latency == null) ? null : (Long) (latency / 1000000);\n  }",
    "comment": "public int[] getInputDims() {\nreturn inputDims;\n}\n\n/*\nGet native inference latency of last image classification run.\n@throws RuntimeException if model is uninitialized."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/PluginsMetadataGenerator.java",
    "type": "method",
    "name": "extractPluginInfo",
    "code": "private PluginInfo extractPluginInfo(Artifact artifact) {\n        if (artifact != null\n                && \"jar\".equals(artifact.getExtension())\n                && \"\".equals(artifact.getClassifier())\n                && artifact.getPath() != null) {\n            Path artifactPath = artifact.getPath();\n            if (Files.isRegularFile(artifactPath)) {\n                try (JarFile artifactJar = new JarFile(artifactPath.toFile(), false)) {\n                                logger.warn(\n                                        \"Artifact {}:{}\"\n                                                + \" JAR (about to be installed/deployed) contains Maven Plugin metadata for\"\n                                                + \" conflicting coordinates: {}:{}.\"\n                                                + \" Your JAR contains rogue Maven Plugin metadata.\"\n                                                + \" Possible causes may be: shaded into this JAR some Maven Plugin or some rogue resource.\",\n                                        artifact.getGroupId(),\n                                        artifact.getArtifactId(),\n                                        groupId,\n                                        artifactId);\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                }",
    "comment": "sanity: jar, no classifier and file exists\nhere we can have: IO. ZIP or Plexus Conf Ex: but we should not interfere with user intent"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/ExternalResource.java",
    "type": "method",
    "name": "apply",
    "code": "public Statement apply(Statement base, Description description) {\n        return statement(base);\n    }",
    "comment": "A base class for Rules (like TemporaryFolder) that set up an external\nresource before a test (a file, socket, server, database connection, etc.),\nand guarantee to tear it down afterward:\n\n<pre>\npublic static class UsesExternalResource {\nServer myServer= new Server();\n\n&#064;Rule\npublic ExternalResource resource= new ExternalResource() {\n\n&#064;Override\nprotected void after() {\nmyServer.disconnect();\n};\n};\n\n&#064;Test\npublic void testFoo() {\nnew Client().run(myServer);\n}\n}\n</pre>\n\n@since 4.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "invokeMethod",
    "code": "public static Object invokeMethod(Method method, Object target, Object... args) {\n\t\treturn ReflectionUtils.invokeMethod(method, target, args);\n\t}",
    "comment": "Invoke the supplied method, making it accessible if necessary and\n{@linkplain ExceptionUtils#throwAsUncheckedException masking} any\nchecked exception as an unchecked exception.\n\n@param method the method to invoke; never {@code null}\n@param target the object on which to invoke the method; may be\n{@code null} if the method is {@code static}\n@param args the arguments to pass to the method\n@return the value returned by the method invocation or {@code null}\nif the return type is {@code void}\n@see ExceptionUtils#throwAsUncheckedException(Throwable)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java",
    "type": "method",
    "name": "methodName",
    "code": "void methodName() {\n\t\tClass<?> testClass = MethodNameTestCase.class;\n\n\t\tassertThat(testClass.getSuperclass().getName()).isLessThan(testClass.getName());\n\n\t\tvar tests = executeTestsInParallel(testClass, Random.class);\n\n\t\ttests.assertStatistics(stats -> stats.succeeded(callSequence.size()));\n\n\t\tassertThat(callSequence).containsExactly(\"$()\", \"AAA()\", \"AAA(org.junit.jupiter.api.TestInfo)\",\n\t\t\t\"AAA(org.junit.jupiter.api.TestReporter)\", \"ZZ_Top()\", \"___()\", \"a1()\", \"a2()\", \"b()\", \"c()\", \"zzz()\");\n\t\tassertThat(threadNames).hasSize(1);\n\t}",
    "comment": "The name of the base class MUST start with a letter alphanumerically\ngreater than \"A\" so that BaseTestCase comes after AlphanumericTestCase\nif methods are sorted by class name for the fallback ordering if two\nmethods have the same name but different parameter lists. Note, however,\nthat Alphanumeric actually does not order methods like that, but we want\nthis check to remain in place to ensure that the ordering does not rely\non the class names."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "arraySize",
    "code": "public int arraySize() {\n    return handleArray(value, pos, (size, offsetSize, offsetStart, dataStart) -> size);\n  }",
    "comment": "Get the number of array elements in the variant.\nIt is only legal to call it when `getType()` is `Type.ARRAY`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-based-asynchronous/src/main/java/com/iluwatar/event/asynchronous/EventManager.java",
    "type": "method",
    "name": "completedEventHandler",
    "code": "public void completedEventHandler(int eventId) {\n    eventPool.get(eventId).status();\n    if (eventPool.get(eventId).isSynchronous()) {\n      currentlyRunningSyncEvent = -1;\n    }\n    eventPool.remove(eventId);\n  }",
    "comment": "Callback from an {@link AsyncEvent} (once it is complete). The Event is then removed from the\npool."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/money/src/main/java/com/iluwatar/Money.java",
    "type": "method",
    "name": "exchangeCurrency",
    "code": "public void exchangeCurrency(String currencyToChangeTo, double exchangeRate) {\n    if (exchangeRate < 0) {\n      throw new IllegalArgumentException(\"Exchange rate must be non-negative\");\n    }\n    this.amount = roundToTwoDecimals(this.amount * exchangeRate);\n    this.currency = currencyToChangeTo;\n  }",
    "comment": "Converts the current amount of money to another currency using the provided exchange rate.\n\n@param currencyToChangeTo the new currency to convert to.\n@param exchangeRate the exchange rate to convert from the current currency to the new currency.\n@throws IllegalArgumentException if the exchange rate is negative."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expressions.java",
    "type": "method",
    "name": "sort",
    "code": "public static SortOrder sort(Expression expr, SortDirection direction) {\n    return LogicalExpressions.sort(expr, direction, direction.defaultNullOrdering());\n  }",
    "comment": "Create a sort expression.\n\n@param expr an expression to produce values to sort\n@param direction direction of the sort\n@return a SortOrder\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedPlainValuesReader.java",
    "type": "method",
    "name": "readBytes",
    "code": "public final void readBytes(int total, WritableColumnVector c, int rowId) {\n    int requiredBytes = total * 4;\n    ByteBuffer buffer = getBuffer(requiredBytes);\n\n    for (int i = 0; i < total; i += 1) {\n      c.putByte(rowId + i, buffer.get());\n      buffer.position(buffer.position() + 3);\n    }\n  }",
    "comment": "Bytes are stored as a 4-byte little endian int. Just read the first byte.\nTODO: consider pushing this in ColumnVector by adding a readBytes with a stride.\nskip the next 3 bytes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "writeTo",
    "code": "public void writeTo(LongBuffer dst) {\n    if (dtype != DataType.INT64) {\n      throw incompatibleBuffer(dst, dtype);\n    }\n    ByteBuffer src = buffer();\n    dst.put(src.asLongBuffer());\n  }",
    "comment": "Write the data of a {@link Long} tensor into the given buffer.\n\n<p>Copies {@code numElements()} elements to the buffer.\n\n@param dst the destination buffer\n@throws BufferOverflowException If there is insufficient space in the given buffer for the data\nin this tensor\n@throws IllegalArgumentException If the tensor datatype is not {@link Long}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Double> create(double[][] data) {\n    return Tensor.create(data, Double.class);\n  }",
    "comment": "Creates a rank-2 tensor of {@code double} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "growAndRehash",
    "code": "void growAndRehash() {\n    assert(longArray != null);\n\n    // Store references to the old data structures to be used when we re-hash\n    final LongArray oldLongArray = longArray;\n    final int oldCapacity = (int) oldLongArray.size() / 2;\n\n    // Allocate the new data structures\n    allocate(Math.min(growthStrategy.nextCapacity(oldCapacity), MAX_CAPACITY));\n\n    // Re-mask (we don't recompute the hashcode because we stored all 32 bits of it)\n    for (int i = 0; i < oldLongArray.size(); i += 2) {\n      final long keyPointer = oldLongArray.get(i);\n      if (keyPointer == 0) {\n        continue;\n      }\n      final int hashcode = (int) oldLongArray.get(i + 1);\n      int newPos = hashcode & mask;\n      int step = 1;\n      while (longArray.get(newPos * 2) != 0) {\n        newPos = (newPos + step) & mask;\n        step++;\n      }\n      longArray.set(newPos * 2, keyPointer);\n      longArray.set(newPos * 2 + 1, hashcode);\n    }\n    freeArray(oldLongArray);\n  }",
    "comment": "Grows the size of the hash table and re-hash everything."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "fetch",
    "code": "public Runner fetch(Output<?> output) {\n      outputs.add(output);\n      return this;\n    }",
    "comment": "Makes {@link #run()} return the Tensor referred to by {@code output}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/hash/Murmur3_x86_32.java",
    "type": "method",
    "name": "Murmur3_x86_32",
    "code": "public Murmur3_x86_32(int seed) {\n    this.seed = seed;\n  }",
    "comment": "32-bit Murmur3 hasher.  This is based on Guava's Murmur3_32HashFunction."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/gpu/java/src/main/java/org/tensorflow/lite/gpu/GpuDelegateFactory.java",
    "type": "method",
    "name": "setSerializationParams",
    "code": "public Options setSerializationParams(String serializationDir, String modelToken) {\n      this.serializationDir = serializationDir;\n      this.modelToken = modelToken;\n      return this;\n    }",
    "comment": "Enables serialization on the delegate. Note non-null {@code serializationDir} and {@code\nmodelToken} are required for serialization.\n\n<p>WARNING: This is an experimental API and subject to change.\n\n@param serializationDir The directory to use for storing data. Caller is responsible to\nensure the model is not stored in a public directory. It's recommended to use {@link\nandroid.content.Context#getCodeCacheDir()} to provide a private location for the\napplication on Android.\n@param modelToken The token to be used to identify the model. Caller is responsible to ensure\nthe token is unique to the model graph and data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java9/org/junit/platform/commons/util/PackageNameUtils.java",
    "type": "method",
    "name": "getPackageName",
    "code": "static String getPackageName(Class<?> clazz) {\n\t\treturn clazz.getPackageName();\n\t}",
    "comment": "Collection of utilities for working with package names.\n\n<h2>DISCLAIMER</h2>\n\n<p>These utilities are intended solely for usage within the JUnit framework\nitself. <strong>Any usage by external parties is not supported.</strong>\nUse at your own risk!\n\n@since 1.11.3"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/test/java/org/apache/maven/cling/transfer/FileSizeFormatTest.java",
    "type": "method",
    "name": "testFormatRateLargeValues",
    "code": "void testFormatRateLargeValues() {\n        FileSizeFormat format = new FileSizeFormat();\n\n        MessageBuilder builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 5e12); // 5 TB/s\n        assertEquals(\"5000.0 GB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1e15); // 1 PB/s\n        assertEquals(\"1000000.0 GB/s\", builder.build());\n    }",
    "comment": "Test large but valid rates\nTest very large rate"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testNormalize3",
    "code": "public void testNormalize3() {\n        IMoney ms1 = MoneyBag.create(new Money(12, \"CHF\"), new Money(3, \"USD\"));\n        Money expected = new Money(4, \"USD\");\n        assertEquals(expected, fMB1.subtract(ms1));\n    }",
    "comment": "{[12 CHF][7 USD]} - {[12 CHF][3 USD]} == [4 USD]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultVersionParser.java",
    "type": "method",
    "name": "DefaultVersionParser",
    "code": "public DefaultVersionParser(ModelVersionParser modelVersionParser) {\n        this.modelVersionParser = nonNull(modelVersionParser, \"modelVersionParser\");\n    }",
    "comment": "A wrapper class around a resolver version that works as model version parser as well."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java",
    "type": "method",
    "name": "runJdbcDatasetExample",
    "code": "private static void runJdbcDatasetExample(SparkSession spark) {\n    Dataset<Row> jdbcDF = spark.read()\n      .format(\"jdbc\")\n      .option(\"url\", \"jdbc:postgresql:dbserver\")\n      .option(\"dbtable\", \"schema.tablename\")\n      .option(\"user\", \"username\")\n      .option(\"password\", \"password\")\n      .load();\n\n    Properties connectionProperties = new Properties();\n    connectionProperties.put(\"user\", \"username\");\n    connectionProperties.put(\"password\", \"password\");\n    Dataset<Row> jdbcDF2 = spark.read()\n      .jdbc(\"jdbc:postgresql:dbserver\", \"schema.tablename\", connectionProperties);\n\n    jdbcDF.write()\n      .format(\"jdbc\")\n      .option(\"url\", \"jdbc:postgresql:dbserver\")\n      .option(\"dbtable\", \"schema.tablename\")\n      .option(\"user\", \"username\")\n      .option(\"password\", \"password\")\n      .save();\n\n    jdbcDF2.write()\n      .jdbc(\"jdbc:postgresql:dbserver\", \"schema.tablename\", connectionProperties);\n\n    jdbcDF.write()\n      .option(\"createTableColumnTypes\", \"name CHAR(64), comments VARCHAR(1024)\")\n      .jdbc(\"jdbc:postgresql:dbserver\", \"schema.tablename\", connectionProperties);\n  }",
    "comment": "$example on:jdbc_dataset$\nNote: JDBC loading and saving can be achieved via either the load/save or jdbc methods\nLoading data from a JDBC source\nSaving data to a JDBC source\nSpecifying create table column data types on write\n$example off:jdbc_dataset$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-aggregator/src/test/java/com/iluwatar/event/aggregator/EventEmitterTest.java",
    "type": "method",
    "name": "for",
    "code": "final EventObserver... observers) {\n\n    for (final var weekday : Weekday.values()) {\n      // Pass each week of the day, day by day to the event emitter\n      emitter.timePasses(weekday);\n\n      if (weekday == specialDay) {\n        // On a special day, every observer should have received the event\n        for (final var observer : observers) {\n          verify(observer, times(1)).onEvent(eq(event));\n        }\n      } else {\n        // On any other normal day, the observers should have received nothing at all\n        verifyNoMoreInteractions(observers);\n      }\n    }\n\n    // The observers should not have received any additional events after the week\n    verifyNoMoreInteractions(observers);\n  }",
    "comment": "Pass each week of the day, day by day to the event emitter and verify of the given observers\nreceived the correct event on the special day.\n\n@param specialDay The special day on which an event is emitted\n@param event The expected event emitted by the test object\n@param emitter The event emitter\n@param observers The registered observer mocks"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestEngine.java",
    "type": "method",
    "name": "execute",
    "code": "public final void execute(ExecutionRequest request) {\n\t\ttry (HierarchicalTestExecutorService executorService = createExecutorService(request)) {\n\t\t\tC executionContext = createExecutionContext(request);\n\t\t\tThrowableCollector.Factory throwableCollectorFactory = createThrowableCollectorFactory(request);\n\t\t\tnew HierarchicalTestExecutor<>(request, executionContext, executorService,\n\t\t\t\tthrowableCollectorFactory).execute().get();\n\t\t}\n\t\tcatch (Exception exception) {\n\t\t\tthrow new JUnitException(\"Error executing tests for engine \" + getId(), exception);\n\t\t}\n\t}",
    "comment": "Create an {@linkplain #createExecutorService(ExecutionRequest) executor\nservice}; create an initial {@linkplain #createExecutionContext execution\ncontext}; execute the behavior of all {@linkplain Node nodes} in the\nhierarchy starting with the supplied {@code request}'s\n{@linkplain ExecutionRequest#getRootTestDescriptor() root} and notify\nits {@linkplain ExecutionRequest#getEngineExecutionListener() execution\nlistener} of test execution events.\n\n@see Node\n@see #createExecutorService\n@see #createExecutionContext"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/utils/CLIReportingUtils.java",
    "type": "method",
    "name": "showVersion",
    "code": "public static String showVersion() {\n        return showVersion(null, null);\n    }",
    "comment": "Utility class used to report errors, statistics, application version info, etc."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "debug",
    "code": "public Executions debug(Writer writer) {\n\t\tPreconditions.notNull(writer, \"Writer must not be null\");\n\t\tdebug(new PrintWriter(writer, true));\n\t\treturn this;\n\t}",
    "comment": "Print all executions to the supplied {@link Writer}.\n\n@param writer the {@code Writer} to print to; never {@code null}\n@return this {@code Executions} object for method chaining; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Boolean> create(Scope scope, boolean[][] data) {\n    return create(scope, data, Boolean.class);\n  }",
    "comment": "Creates a rank-2 constant of {@code boolean} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/aether/DefaultRepositorySystemSessionFactory.java",
    "type": "method",
    "name": "resolve",
    "code": "private Path resolve(String string) {\n        if (string.startsWith(\"~/\") || string.startsWith(\"~\\\\\")) {\n            return Paths.get(System.getProperty(\"user.home\"))\n                    .resolve(string.substring(2))\n                    .normalize()\n                    .toAbsolutePath();\n        } else {\n            return Paths.get(string).normalize().toAbsolutePath();\n        }\n    }",
    "comment": "resolve based on $HOME\nresolve based on $CWD"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toValidString",
    "code": "public String toValidString() {\n    if (isValid()) return toString();\n    return new String(makeValidBytes(), StandardCharsets.UTF_8);\n  }",
    "comment": "Returns a string representation of this UTF8String object, but uses our custom implementation\nfor invalid UTF-8 byte sequence replacement, as per the specification defined in the Unicode\nstandard 15, Section 3.9, Paragraph D86, Table 3-7. Hence, the result of this method is\nalways a valid UTF-8 string. This is the recommended method to use with invalid UTF8Strings."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ResolverFacade.java",
    "type": "method",
    "name": "getParameterName",
    "code": "Optional<String> getParameterName(int parameterIndex) {\n\t\treturn this.indexedParameterDeclarations.get(parameterIndex) //\n\t\t\t\t.flatMap(ParameterDeclaration::getParameterName);\n\t}",
    "comment": "Get the name of the parameter with the supplied index, if it is present\nand declared before the aggregators.\n\n@return an {@code Optional} containing the name of the parameter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/MojoExecutor.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n            acquiredProjectLock.unlock();\n            acquiredAggregatorLock.unlock();\n            mojos.remove(Thread.currentThread());\n        }",
    "comment": "release the lock in the reverse order of the acquisition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "isRecordClass",
    "code": "public static boolean isRecordClass(Class<?> clazz) {\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\treturn superclass != null && \"java.lang.Record\".equals(superclass.getName());\n\t}",
    "comment": "{@return whether the supplied {@code clazz} is a record class}\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/NamespaceChange.java",
    "type": "method",
    "name": "removeProperty",
    "code": "static NamespaceChange removeProperty(String property) {\n    return new RemoveProperty(property);\n  }",
    "comment": "Create a NamespaceChange for removing a namespace property.\n<p>\nIf the property does not exist, the change will succeed.\n\n@param property the property name\n@return a NamespaceChange for the addition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(int[] expected, int[] actual, Supplier<String> messageSupplier) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} int arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/bridge/src/test/java/com/iluwatar/bridge/HammerTest.java",
    "type": "method",
    "name": "testHammer",
    "code": "void testHammer() {\n    final var hammer = spy(new Hammer(mock(FlyingEnchantment.class)));\n    testBasicWeaponActions(hammer);\n  }",
    "comment": "Invoke all possible actions on the weapon and check if the actions are executed on the actual\nunderlying weapon implementation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/AbstractInstance.java",
    "type": "method",
    "name": "setAlive",
    "code": "public void setAlive(boolean alive) {\n    this.alive = alive;\n  }",
    "comment": "Set the health status of the certain instance.\n\n@param alive {@code true} for alive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java",
    "type": "method",
    "name": "chopLeadingFileSeparator",
    "code": "private String chopLeadingFileSeparator(String path) {\n        if (path != null) {\n            if (path.startsWith(\"/\") || path.startsWith(\"\\\\\")) {\n                path = path.substring(1);\n            }\n        }\n        return path;\n    }",
    "comment": "Removes the leading directory separator from the specified filesystem path (if any). For platform-independent\nbehavior, this method accepts both the forward slash and the backward slash as separator.\n\n@param path The filesystem path, may be <code>null</code>.\n@return The altered filesystem path or <code>null</code> if the input path was <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/resolution/InvalidRepositoryException.java",
    "type": "method",
    "name": "InvalidRepositoryException",
    "code": "public InvalidRepositoryException(String message, Repository repository) {\n        super(message);\n        this.repository = repository;\n    }",
    "comment": "Creates a new exception with specified detail message for the given repository.\n\n@param message The detail message, may be {@code null}.\n@param repository The repository that caused the error, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/CollectionUtils.java",
    "type": "method",
    "name": "toUnmodifiableList",
    "code": "public static <T> Collector<T, ?, List<T>> toUnmodifiableList() {\n\t\treturn collectingAndThen(toList(), Collections::unmodifiableList);\n\t}",
    "comment": "Return a {@code Collector} that accumulates the input elements into a\nnew unmodifiable list, in encounter order.\n\n<p>There are no guarantees on the type or serializability of the list\nreturned, so if more control over the returned list is required,\nconsider creating a new {@code Collector} implementation like the\n\n@param <T> the type of the input elements\n@return a {@code Collector} which collects all the input elements into\nan unmodifiable list, in encounter order"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/update-method/src/main/java/com/iluwatar/updatemethod/World.java",
    "type": "method",
    "name": "processInput",
    "code": "private void processInput() {\n    try {\n      int lag = new SecureRandom().nextInt(200) + 50;\n      Thread.sleep(lag);\n    } catch (InterruptedException e) {\n      LOGGER.error(e.getMessage());\n      Thread.currentThread().interrupt();\n    }\n  }",
    "comment": "Handle any user input that has happened since the last call. In order to simulate the situation\nin real-life game, here we add a random time lag. The time lag ranges from 50 ms to 250 ms."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/CleanupNonShuffleServiceServedFilesSuite.java",
    "type": "method",
    "name": "getConf",
    "code": "private TransportConf getConf(boolean isFetchRddEnabled) {\n    return new TransportConf(\n      \"shuffle\",\n      new MapConfigProvider(ImmutableMap.of(\n        Constants.SHUFFLE_SERVICE_FETCH_RDD_ENABLED,\n        Boolean.toString(isFetchRddEnabled))));\n  }",
    "comment": "Same-thread Executor used to ensure cleanup happens synchronously in test thread."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestDescriptor.java",
    "type": "method",
    "name": "accept",
    "code": "default void accept(Visitor visitor) {\n\t\tPreconditions.notNull(visitor, \"Visitor must not be null\");\n\t\tvisitor.visit(this);\n\t\t// Create a copy of the set in order to avoid a ConcurrentModificationException\n\t\tnew LinkedHashSet<>(this.getChildren()).forEach(child -> child.accept(visitor));\n\t}",
    "comment": "Accept a {@link Visitor} to the subtree starting with this descriptor.\n\n@param visitor the {@code Visitor} to accept; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/Graph.java",
    "type": "method",
    "name": "if",
    "code": "LinkedList<String> cycle) {\n        if (children != null) {\n            for (String v : children) {\n                DfsState state = stateMap.putIfAbsent(v, DfsState.VISITING);\n                if (state == null) {\n                    cycle.addLast(v);\n                    List<String> ret = visitCycle(graph, graph.get(v), stateMap, cycle);\n                    if (ret != null) {\n                        return ret;\n                    }\n                    cycle.removeLast();\n                    stateMap.put(v, DfsState.VISITED);\n                } else if (state == DfsState.VISITING) {\n                    int pos = cycle.lastIndexOf(v);\n                    List<String> ret = cycle.subList(pos, cycle.size());\n                    ret.add(v);\n                    return ret;\n                }\n            }\n        }\n        return null;\n    }",
    "comment": "we are already visiting this vertex, this mean we have a cycle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaLinearSVCExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaLinearSVCExample\")\n      .getOrCreate();\n\n    Dataset<Row> training = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_libsvm_data.txt\");\n\n    LinearSVC lsvc = new LinearSVC()\n      .setMaxIter(10)\n      .setRegParam(0.1);\n\n    LinearSVCModel lsvcModel = lsvc.fit(training);\n\n    System.out.println(\"Coefficients: \"\n      + lsvcModel.coefficients() + \" Intercept: \" + lsvcModel.intercept());\n\n    spark.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nLoad training data\nFit the model\nPrint the coefficients and intercept for LinearSVC\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetColumnVector.java",
    "type": "method",
    "name": "getCollectionSize",
    "code": "private int getCollectionSize(int maxRepetitionLevel, int idx) {\n    int size = 1;\n    for (idx += 1; idx < repetitionLevels.getElementsAppended(); idx++) {\n      if (repetitionLevels.getInt(idx) <= maxRepetitionLevel) {\n        break;\n      } else if (repetitionLevels.getInt(idx) <= maxRepetitionLevel + 1) {\n        // Only count elements which belong to the current collection\n        // For instance, suppose we have the following Parquet schema:\n        //\n        // message schema {                        max rl   max dl\n        //   optional group col (LIST) {              0        1\n        //     repeated group list {                  1        2\n        //       optional group element (LIST) {      1        3\n        //         repeated group list {              2        4\n        //           required int32 element;          2        4\n        //         }\n        //       }\n        //     }\n        //   }\n        // }\n        //\n        // For a list such as: [[[0, 1], [2, 3]], [[4, 5], [6, 7]]], the repetition & definition\n        // levels would be:\n        //\n        // repetition levels: [0, 2, 1, 2, 0, 2, 1, 2]\n        // definition levels: [2, 2, 2, 2, 2, 2, 2, 2]\n        //\n        // When calculating collection size for the outer array, we should only count repetition\n        // levels whose value is <= 1 (which is the max repetition level for the inner array)\n        size++;\n      }\n    }\n    return size;\n  }",
    "comment": "Gets the size of a collection (i.e., array or map) element, starting at 'idx'.\n\n@param maxRepetitionLevel the maximum repetition level for the elements in this collection\n@param idx the index of this collection in the Parquet column\n@return the size of this collection"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/results/ResultMatchers.java",
    "type": "method",
    "name": "hasFailureContaining",
    "code": "public static Matcher<PrintableResult> hasFailureContaining(final String string) {\n        return new TypeSafeMatcher<PrintableResult>() {\n\n            public void describeTo(Description description) {\n                description.appendText(\"has failure containing \" + string);\n            }\n        };\n    }",
    "comment": "Matches if the result has one or more failures, and at least one of them\ncontains {@code string}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/support/OpenTest4JAndJUnit4AwareThrowableCollector.java",
    "type": "method",
    "name": "createAbortedExecutionPredicate",
    "code": "private static Predicate<? super Throwable> createAbortedExecutionPredicate() {\n\t\tPredicate<Throwable> otaPredicate = TestAbortedException.class::isInstance;\n\n\t\ttry {\n\t\t\tClass<?> clazz = ReflectionSupport.tryToLoadClass(ASSUMPTION_VIOLATED_EXCEPTION).get();\n\t\t\tif (clazz != null) {\n\t\t\t\treturn otaPredicate.or(clazz::isInstance);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(throwable);\n\t\t\tSupplier<String> messageSupplier = (throwable instanceof NoClassDefFoundError)\n\t\t\t\t\t? () -> COMMON_FAILURE_MESSAGE + \" Note that \" + ASSUMPTION_VIOLATED_EXCEPTION\n\t\t\t\t\t\t\t+ \" requires that Hamcrest is on the classpath.\"\n\t\t\t\t\t: () -> COMMON_FAILURE_MESSAGE;\n\t\t\tlogger.debug(throwable, messageSupplier);\n\t\t}\n\n\t\treturn otaPredicate;\n\t}",
    "comment": "Additionally support JUnit 4's AssumptionViolatedException?\nElse just OTA's TestAbortedException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertSame",
    "code": "public static void assertSame(String message, Object expected, Object actual) {\n        Assert.assertSame(message, expected, actual);\n    }",
    "comment": "Asserts that two objects refer to the same object. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/DefaultMirrorSelector.java",
    "type": "method",
    "name": "matchPattern",
    "code": "static boolean matchPattern(ArtifactRepository originalRepository, String pattern) {\n        boolean result = false;\n        String originalId = originalRepository.getId();\n\n        // simple checks first to short circuit processing below.\n        if (WILDCARD.equals(pattern) || pattern.equals(originalId)) {\n            result = true;\n        } else {\n            // process the list\n            String[] repos = pattern.split(\",\");\n            for (String repo : repos) {\n                repo = repo.trim();\n                // see if this is a negative match\n                if (repo.length() > 1 && repo.startsWith(\"!\")) {\n                    if (repo.substring(1).equals(originalId)) {\n                        // explicitly exclude. Set result and stop processing.\n                        result = false;\n                        break;\n                    }\n                }\n                // check for exact match\n                else if (repo.equals(originalId)) {\n                    result = true;\n                    break;\n                }\n                // check for external:*\n                else if (EXTERNAL_WILDCARD.equals(repo) && isExternalRepo(originalRepository)) {\n                    result = true;\n                    // don't stop processing in case a future segment explicitly excludes this repo\n                }\n                // check for external:http:*\n                else if (EXTERNAL_HTTP_WILDCARD.equals(repo) && isExternalHttpRepo(originalRepository)) {\n                    result = true;\n                    // don't stop processing in case a future segment explicitly excludes this repo\n                } else if (WILDCARD.equals(repo)) {\n                    result = true;\n                    // don't stop processing in case a future segment explicitly excludes this repo\n                }\n            }\n        }\n        return result;\n    }",
    "comment": "This method checks if the pattern matches the originalRepository. Valid patterns:\n<ul>\n<li>{@code *} = everything,</li>\n<li>{@code external:*} = everything not on the localhost and not file based,</li>\n<li>{@code external:http:*} = any repository not on the localhost using HTTP,</li>\n<li>{@code repo,repo1} = {@code repo} or {@code repo1},</li>\n<li>{@code *,!repo1} = everything except {@code repo1}.</li>\n</ul>\n\n@param originalRepository to compare for a match.\n@param pattern used for match.\n@return true if the repository is a match to this pattern."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Long> create(long[] data) {\n    return Tensor.create(data, Long.class);\n  }",
    "comment": "Creates a rank-1 tensor of {@code long} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-transfer-object/src/main/java/com/iluwatar/datatransfer/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    // Example 1: Customer DTO\n    var customerOne = new CustomerDto(\"1\", \"Kelly\", \"Brown\");\n    var customerTwo = new CustomerDto(\"2\", \"Alfonso\", \"Bass\");\n    var customers = new ArrayList<>(List.of(customerOne, customerTwo));\n\n    var customerResource = new CustomerResource(customers);\n\n    LOGGER.info(\"All customers:\");\n    var allCustomers = customerResource.customers();\n    printCustomerDetails(allCustomers);\n\n    LOGGER.info(\"----------------------------------------------------------\");\n\n    LOGGER.info(\"Deleting customer with id {1}\");\n    customerResource.delete(customerOne.id());\n    allCustomers = customerResource.customers();\n    printCustomerDetails(allCustomers);\n\n    LOGGER.info(\"----------------------------------------------------------\");\n\n    LOGGER.info(\"Adding customer three}\");",
    "comment": "Method as act client and request to server for details.\n\n@param args program argument."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/AutoCloseTests.java",
    "type": "method",
    "name": "fieldsAreProperlyClosedWithNestedTestClassesWithInstancePerClass",
    "code": "void fieldsAreProperlyClosedWithNestedTestClassesWithInstancePerClass() {\n\t\tString[] expected = { //\n\t\t\t\t\"NestedTestCase.nestedStaticClosable.close()\", //\n\t\t\t\t\"NestedTestCase.nestedClosable.close()\", //\n\t\t\t\t\"InstancePerClassEnclosingTestCase.enclosingStaticClosable.close()\", //\n\t\t\t\t\"InstancePerClassEnclosingTestCase.enclosingClosable.close()\" //\n\t\t};\n\n\t\tEvents tests = executeTestsForClass(InstancePerClassEnclosingTestCase.NestedTestCase.class).testEvents();\n\t\ttests.assertStatistics(stats -> stats.succeeded(1));\n\t\tassertThat(recorder).containsExactly(expected);\n\n\t\tresetTracking();\n\n\t\ttests = executeTestsForClass(InstancePerClassEnclosingTestCase.class).testEvents();\n\t\ttests.assertStatistics(stats -> stats.succeeded(2));\n\t\tassertThat(recorder).containsExactly(expected);\n\t}",
    "comment": "With test instance lifecycle \"per class\" mode, we actually expect the\nsame behavior for the closing of all fields when the nested test class\nis run standalone AND when it's run along with its enclosing class.\nReset tracking"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultSourceRoot.java",
    "type": "method",
    "name": "DefaultSourceRoot",
    "code": "public DefaultSourceRoot(final ProjectScope scope, final Language language, final Path directory) {\n        this.scope = Objects.requireNonNull(scope);\n        this.language = Objects.requireNonNull(language);\n        this.directory = Objects.requireNonNull(directory);\n        includes = List.of();\n        excludes = List.of();\n        moduleName = null;\n        targetVersion = null;\n        targetPath = null;\n        stringFiltering = false;\n        enabled = true;\n    }",
    "comment": "Creates a new instance for the given directory and scope.\n\n@param scope scope of source code (main or test)\n@param language language of the source code\n@param directory directory of the source code"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/InputLocation.java",
    "type": "method",
    "name": "setImportedFrom",
    "code": "public void setImportedFrom(InputLocation importedFrom) {\n        this.importedFrom = importedFrom;\n    }",
    "comment": "Set the imported from location.\n\n@param importedFrom"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-expression/src/main/java/org/apache/maven/plugin/coreit/PropertyUtil.java",
    "type": "method",
    "name": "getPropertyName",
    "code": "static String getPropertyName(String methodName) {\n        String propertyName = methodName;\n        if (methodName.startsWith(\"get\") && methodName.length() > 3) {\n            propertyName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n        } else if (methodName.startsWith(\"is\") && methodName.length() > 2) {\n            propertyName = Character.toLowerCase(methodName.charAt(2)) + methodName.substring(3);\n        }\n        return propertyName;\n    }",
    "comment": "Derives the bean property name from the specified method for its getter.\n\n@param methodName The method name of the property's getter, must not be <code>null</code>.\n@return The property name, never <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutorTests.java",
    "type": "method",
    "name": "init",
    "code": "void init() {\n\t\texecutor = createExecutor(new SameThreadHierarchicalTestExecutorService());\n\t}",
    "comment": "Micro-tests that verify behavior of {@link HierarchicalTestExecutor}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/SavedModelBundle.java",
    "type": "method",
    "name": "withRunOptions",
    "code": "public Loader withRunOptions(byte[] options) {\n      this.runOptions = options;\n      return this;\n    }",
    "comment": "Sets options to use when executing model initialization operations.\n\n@param options Serialized <a\nhref=\"https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto\">RunOptions\nprotocol buffer</a>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Long expected, Long actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/ColumnValue.java",
    "type": "method",
    "name": "booleanValue",
    "code": "private static TColumnValue booleanValue(Boolean value) {\n    TBoolValue tBoolValue = new TBoolValue();\n    if (value != null) {\n      tBoolValue.setValue(value);\n    }\n    return TColumnValue.boolVal(tBoolValue);\n  }",
    "comment": "Protocols before HIVE_CLI_SERVICE_PROTOCOL_V6 (used by RowBasedSet)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/test/java/org/apache/spark/sql/hive/test/Complex.java",
    "type": "method",
    "name": "findByThriftId",
    "code": "public static _Fields findByThriftId(int fieldId) {\n      switch(fieldId) {\n        case 1: // AINT\n          return AINT;\n        case 2: // A_STRING\n          return A_STRING;\n        case 3: // LINT\n          return LINT;\n        case 4: // L_STRING\n          return L_STRING;\n        case 5: // LINT_STRING\n          return LINT_STRING;\n        case 6: // M_STRING_STRING\n          return M_STRING_STRING;\n        default:\n          return null;\n      }\n    }",
    "comment": "Find the _Fields constant that matches fieldId, or null if its not found."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "compileIsoControlPattern",
    "code": "static Pattern compileIsoControlPattern() {\n\t\t// https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#posix\n\t\ttry {\n\t\t\t// All of the characters that Unicode refers to as 'control characters'\n\t\t\treturn Pattern.compile(\"\\\\p{Cntrl}\", UNICODE_CHARACTER_CLASS);\n\t\t}\n\t\tcatch (IllegalArgumentException e) {\n\t\t\t// Fall-back to ASCII control characters only: [\\x00-\\x1F\\x7F]\n\t\t\treturn Pattern.compile(\"\\\\p{Cntrl}\");\n\t\t}\n\t}",
    "comment": "Guard against \"IllegalArgumentException: Unsupported flags: 256\" errors.\n@see <a href=\"https://github.com/junit-team/junit5/issues/1800\">#1800</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/orc/OrcColumnVectorUtils.java",
    "type": "method",
    "name": "toOrcColumnVector",
    "code": "static OrcColumnVector toOrcColumnVector(DataType type, ColumnVector vector) {\n    if (vector instanceof LongColumnVector ||\n      vector instanceof DoubleColumnVector ||\n      vector instanceof BytesColumnVector ||\n      vector instanceof DecimalColumnVector ||\n      vector instanceof TimestampColumnVector) {\n      return new OrcAtomicColumnVector(type, vector);\n    } else if (vector instanceof StructColumnVector structVector) {\n      OrcColumnVector[] fields = new OrcColumnVector[structVector.fields.length];\n      int ordinal = 0;\n      for (StructField f : ((StructType) type).fields()) {\n        fields[ordinal] = toOrcColumnVector(f.dataType(), structVector.fields[ordinal]);\n        ordinal++;\n      }\n      return new OrcStructColumnVector(type, vector, fields);\n    } else if (vector instanceof ListColumnVector listVector) {\n      OrcColumnVector dataVector = toOrcColumnVector(\n        ((ArrayType) type).elementType(), listVector.child);\n      return new OrcArrayColumnVector(type, vector, dataVector);\n    } else if (vector instanceof MapColumnVector mapVector) {\n      MapType mapType = (MapType) type;\n      OrcColumnVector keysVector = toOrcColumnVector(mapType.keyType(), mapVector.keys);\n      OrcColumnVector valuesVector = toOrcColumnVector(mapType.valueType(), mapVector.values);\n      return new OrcMapColumnVector(type, vector, keysVector, valuesVector);\n    } else {\n      throw new IllegalArgumentException(\n        String.format(\"OrcColumnVectorUtils.toOrcColumnVector should not take %s as type \" +\n          \"and %s as vector\", type, vector));\n    }\n  }",
    "comment": "Convert a Hive's {@link ColumnVector} to a Spark's {@link OrcColumnVector}.\n\n@param type The data type of column vector\n@param vector Hive's column vector\n@return Spark's column vector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/sasl/SaslIntegrationSuite.java",
    "type": "method",
    "name": "afterAll",
    "code": "public static void afterAll() {\n    server.close();\n    context.close();\n  }",
    "comment": "Use a long timeout to account for slow / overloaded build machines. In the normal case,\ntests should finish way before the timeout expires."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "toJson",
    "code": "public String toJson(ZoneId zoneId) {\n    StringBuilder sb = new StringBuilder();\n    toJsonImpl(value, metadata, pos, sb, zoneId);\n    return sb.toString();\n  }",
    "comment": "Stringify the variant in JSON format.\nThrow `MALFORMED_VARIANT` if the variant is malformed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaRankingMetricsExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf conf = new SparkConf().setAppName(\"Java Ranking Metrics Example\");\n    JavaSparkContext sc = new JavaSparkContext(conf);\n    String path = \"data/mllib/sample_movielens_data.txt\";\n    JavaRDD<String> data = sc.textFile(path);\n    JavaRDD<Rating> ratings = data.map(line -> {\n        String[] parts = line.split(\"::\");\n        return new Rating(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]), Double\n            .parseDouble(parts[2]) - 2.5);\n      });\n    ratings.cache();\n\n    MatrixFactorizationModel model = ALS.train(JavaRDD.toRDD(ratings), 10, 10, 0.01);\n\n    JavaRDD<Tuple2<Object, Rating[]>> userRecs = model.recommendProductsForUsers(10).toJavaRDD();\n    JavaRDD<Tuple2<Object, Rating[]>> userRecsScaled = userRecs.map(t -> {\n        Rating[] scaledRatings = new Rating[t._2().length];\n        for (int i = 0; i < scaledRatings.length; i++) {\n          double newRating = Math.max(Math.min(t._2()[i].rating(), 1.0), 0.0);\n          scaledRatings[i] = new Rating(t._2()[i].user(), t._2()[i].product(), newRating);\n        }\n        return new Tuple2<>(t._1(), scaledRatings);\n      });\n    JavaPairRDD<Object, Rating[]> userRecommended = JavaPairRDD.fromJavaRDD(userRecsScaled);\n\n    JavaRDD<Rating> binarizedRatings = ratings.map(r -> {\n        double binaryRating;\n        if (r.rating() > 0.0) {\n          binaryRating = 1.0;\n        } else {\n          binaryRating = 0.0;\n        }\n        return new Rating(r.user(), r.product(), binaryRating);\n      });\n\n    JavaPairRDD<Object, Iterable<Rating>> userMovies = binarizedRatings.groupBy(Rating::user);\n\n    JavaPairRDD<Object, List<Integer>> userMoviesList = userMovies.mapValues(docs -> {\n        List<Integer> products = new ArrayList<>();\n        for (Rating r : docs) {\n          if (r.rating() > 0.0) {\n            products.add(r.product());\n          }\n        }\n        return products;\n      });\n\n    JavaPairRDD<Object, List<Integer>> userRecommendedList = userRecommended.mapValues(docs -> {\n        List<Integer> products = new ArrayList<>();\n        for (Rating r : docs) {\n          products.add(r.product());\n        }\n        return products;\n      });\n    JavaRDD<Tuple2<List<Integer>, List<Integer>>> relevantDocs = userMoviesList.join(\n      userRecommendedList).values();\n\n    RankingMetrics<Integer> metrics = RankingMetrics.of(relevantDocs);\n\n    Integer[] kVector = {1, 3, 5};\n    for (Integer k : kVector) {\n      System.out.format(\"Precision at %d = %f\\n\", k, metrics.precisionAt(k));\n      System.out.format(\"NDCG at %d = %f\\n\", k, metrics.ndcgAt(k));\n      System.out.format(\"Recall at %d = %f\\n\", k, metrics.recallAt(k));\n    }\n\n    System.out.format(\"Mean average precision = %f\\n\", metrics.meanAveragePrecision());\n\n    System.out.format(\"Mean average precision at 2 = %f\\n\", metrics.meanAveragePrecisionAt(2));\n\n    JavaRDD<Tuple2<Object, Object>> userProducts =\n        ratings.map(r -> new Tuple2<>(r.user(), r.product()));\n\n    JavaPairRDD<Tuple2<Integer, Integer>, Object> predictions = JavaPairRDD.fromJavaRDD(\n      model.predict(JavaRDD.toRDD(userProducts)).toJavaRDD().map(r ->\n        new Tuple2<>(new Tuple2<>(r.user(), r.product()), r.rating())));\n    JavaRDD<Tuple2<Object, Object>> ratesAndPreds =\n      JavaPairRDD.fromJavaRDD(ratings.map(r ->\n        new Tuple2<Tuple2<Integer, Integer>, Object>(\n          new Tuple2<>(r.user(), r.product()),\n          r.rating())\n      )).join(predictions).values();\n\n    RegressionMetrics regressionMetrics = new RegressionMetrics(ratesAndPreds.rdd());\n\n    System.out.format(\"RMSE = %f\\n\", regressionMetrics.rootMeanSquaredError());\n\n    System.out.format(\"R-squared = %f\\n\", regressionMetrics.r2());\n\n    sc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nTrain an ALS model\nGet top 10 recommendations for every user and scale ratings from 0 to 1\nMap ratings to 1 or 0, 1 indicating a movie that should be recommended\nGroup ratings by common user\nGet true relevant documents from all user ratings\nExtract the product id from each recommendation\nInstantiate the metrics object\nPrecision, NDCG and Recall at k\nMean average precision\nMean average precision at k\nEvaluate the model using numerical ratings and regression metrics\nCreate regression metrics object\nRoot mean squared error\nR-squared\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/commander/src/main/java/com/iluwatar/commander/Retry.java",
    "type": "method",
    "name": "perform",
    "code": "public void perform(List<Exception> list, T obj) {\n    do {\n      try {\n        op.operation(list);\n        return;\n      } catch (Exception e) {\n        this.errors.add(e);\n        if (this.attempts.incrementAndGet() >= this.maxAttempts || !this.test.test(e)) {\n          this.handleError.handleIssue(obj, e);\n          return; // return here... don't go further\n        }\n        try {\n          long testDelay =\n              (long) Math.pow(2, this.attempts.intValue()) * 1000 + RANDOM.nextInt(1000);\n          long delay = Math.min(testDelay, this.maxDelay);\n          Thread.sleep(delay);\n        } catch (InterruptedException f) {\n          // ignore\n        }\n      }\n    } while (true);\n  }",
    "comment": "Performing the operation with retries.\n\n@param list is the exception list\n@param obj is the parameter to be passed into handleIsuue method"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroArrayOfArray.java",
    "type": "method",
    "name": "getSchema",
    "code": "public org.apache.avro.Schema getSchema() { return SCHEMA$; }\n  public java.lang.Object get(int field$) {\n    switch (field$) {\n    case 0: return int_arrays_column;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumWriter.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaDataFrameSuite.java",
    "type": "method",
    "name": "testVarargMethods",
    "code": "public void testVarargMethods() {\n    Dataset<Row> df = spark.table(\"testData\");\n\n    df.toDF(\"key1\", \"value1\");\n\n    df.select(\"key\", \"value\");\n    df.select(col(\"key\"), col(\"value\"));\n    df.selectExpr(\"key\", \"value + 1\");\n\n    df.sort(\"key\", \"value\");\n    df.sort(col(\"key\"), col(\"value\"));\n    df.orderBy(\"key\", \"value\");\n    df.orderBy(col(\"key\"), col(\"value\"));\n\n    df.groupBy(\"key\", \"value\").agg(col(\"key\"), col(\"value\"), sum(\"value\"));\n    df.groupBy(col(\"key\"), col(\"value\")).agg(col(\"key\"), col(\"value\"), sum(\"value\"));\n    df.agg(first(\"key\"), sum(\"value\"));\n\n    df.groupBy().avg(\"key\");\n    df.groupBy().mean(\"key\");\n    df.groupBy().max(\"key\");\n    df.groupBy().min(\"key\");\n    df.groupBy().sum(\"key\");\n\n    // Varargs in column expressions\n    df.groupBy().agg(countDistinct(\"key\", \"value\"));\n    df.groupBy().agg(count_distinct(col(\"key\"), col(\"value\")));\n    df.select(coalesce(col(\"key\")));\n\n    // Varargs with mathfunctions\n    Dataset<Row> df2 = spark.table(\"testData2\");\n    df2.select(exp(\"a\"), exp(\"b\"));\n    df2.select(exp(log(\"a\")));\n    df2.select(pow(\"a\", \"a\"), pow(\"b\", 2.0));\n    df2.select(pow(col(\"a\"), col(\"b\")), exp(\"b\"));\n    df2.select(sin(\"a\"), acos(\"b\"));\n\n    df2.select(rand(), acos(\"b\"));\n    df2.select(col(\"*\"), randn(5L));\n  }",
    "comment": "See SPARK-5904. Abstract vararg methods defined in Scala do not work in Java."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ArtifactInstaller.java",
    "type": "method",
    "name": "install",
    "code": "default void install(Session session, Collection<ProducedArtifact> artifacts) {\n        install(ArtifactInstallerRequest.build(session, artifacts));\n    }",
    "comment": "@param session the repository session\n@param artifacts Collection of {@link ProducedArtifact MavenArtifacts}\n@throws ArtifactInstallerException if the given artifact cannot be found or the\ninstallation has failed\n@throws IllegalArgumentException if {@code request} is {@code null} or parameter\n{@code localRepository} is {@code null} or {@code localRepository} is not a directory\nor parameter {@code mavenArtifacts} is {@code null} or\n{@code mavenArtifacts.isEmpty()} is {@code true}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/MavenExecutionPlan.java",
    "type": "method",
    "name": "findLastInPhase",
    "code": "public ExecutionPlanItem findLastInPhase(String requestedPhase) {\n        return lastMojoExecutionForAllPhases.get(requestedPhase);\n    }",
    "comment": "Returns the last ExecutionPlanItem in the supplied phase. If no items are in the specified phase,\nthe closest executionPlanItem from an earlier phase item will be returned.\n\n@param requestedPhase the requested phase\nThe execution plan item\n@return The ExecutionPlanItem or null if none can be found"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/tasks/CustomContextClassLoaderExecutor.java",
    "type": "method",
    "name": "invoke",
    "code": "<T> T invoke(Supplier<T> supplier) {\n\t\tif (customClassLoader.isPresent()) {\n\t\t\treturn replaceThreadContextClassLoaderAndInvoke(customClassLoader.get(), supplier);\n\t\t}\n\t\treturn supplier.get();\n\t}",
    "comment": "Only get/set context class loader when necessary to prevent problems with\nsecurity managers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/simple/SimpleFluentIterable.java",
    "type": "method",
    "name": "filter",
    "code": "public final FluentIterable<E> filter(Predicate<? super E> predicate) {\n    var iterator = iterator();\n    while (iterator.hasNext()) {\n      var nextElement = iterator.next();\n      if (!predicate.test(nextElement)) {\n        iterator.remove();\n      }\n    }\n    return this;\n  }",
    "comment": "Filters the contents of Iterable using the given predicate, leaving only the ones which satisfy\nthe predicate.\n\n@param predicate the condition to test with for the filtering. If the test is negative, the\ntested object is removed by the iterator.\n@return the same FluentIterable with a filtered collection"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "SparkLauncher",
    "code": "public SparkLauncher(Map<String, String> env) {\n    if (env != null) {\n      this.builder.childEnv.putAll(env);\n    }\n  }",
    "comment": "Creates a launcher that will set the given environment variables in the child.\n\n@param env Environment variables to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, long expected, long actual) {\n        Assert.assertEquals(message, expected, actual);\n    }",
    "comment": "Asserts that two longs are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/manipulation/Sorter.java",
    "type": "method",
    "name": "Sorter",
    "code": "public Sorter(Comparator<Description> comparator) {\n        this.comparator = comparator;\n    }",
    "comment": "Creates a <code>Sorter</code> that uses <code>comparator</code>\nto sort tests\n\n@param comparator the {@link Comparator} to use when sorting tests\n@since 4.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetColumnVector.java",
    "type": "method",
    "name": "assembleCollection",
    "code": "private void assembleCollection() {\n    int maxDefinitionLevel = column.definitionLevel();\n    int maxElementRepetitionLevel = column.repetitionLevel();\n\n    // There are 4 cases when calculating definition levels:\n    //   1. definitionLevel == maxDefinitionLevel\n    //     ==> value is defined and not null\n    //   2. definitionLevel == maxDefinitionLevel - 1\n    //     ==> value is null\n    //   3. definitionLevel < maxDefinitionLevel - 1\n    //     ==> value doesn't exist since one of its optional parents is null\n    //   4. definitionLevel > maxDefinitionLevel\n    //     ==> value is a nested element within an array or map\n    //\n    // `i` is the index over all leaf elements of this array, while `offset` is the index over\n    // all top-level elements of this array.\n    int rowId = 0;\n    for (int i = 0, offset = 0; i < definitionLevels.getElementsAppended();\n         i = getNextCollectionStart(maxElementRepetitionLevel, i)) {\n      vector.reserve(rowId + 1);\n      int definitionLevel = definitionLevels.getInt(i);\n      if (definitionLevel <= maxDefinitionLevel) {\n        // This means the value is not an array element, but a collection that is either null or\n        // empty. In this case, we should increase offset to skip it when returning an array\n        // starting from the offset.\n        //\n        // For instance, considering an array of strings with 3 elements like the following:\n        //  null, [], [a, b, c]\n        // the child array (which is of String type) in this case will be:\n        //  null:   1 1 0 0 0\n        //  length: 0 0 1 1 1\n        //  offset: 0 0 0 1 2\n        // and the array itself will be:\n        //  null:   1 0 0\n        //  length: 0 0 3\n        //  offset: 0 1 2\n        //\n        // It's important that for the third element `[a, b, c]`, the offset in the array\n        // (not the elements) starts from 2 since otherwise we'd include the first & second null\n        // element from child array in the result.\n        offset += 1;\n      }\n      if (definitionLevel <= maxDefinitionLevel - 1) {\n        // Collection is null or one of its optional parents is null\n        vector.putNull(rowId++);\n      } else if (definitionLevel == maxDefinitionLevel) {\n        // Collection is defined but empty\n        vector.putNotNull(rowId);\n        vector.putArray(rowId, offset, 0);\n        rowId++;\n      } else if (definitionLevel > maxDefinitionLevel) {\n        // Collection is defined and non-empty: find out how many top elements are there until the\n        // start of the next array.\n        vector.putNotNull(rowId);\n        int length = getCollectionSize(maxElementRepetitionLevel, i);\n        vector.putArray(rowId, offset, length);\n        offset += length;\n        rowId++;\n      }\n    }\n    vector.addElementsAppended(rowId);\n  }",
    "comment": "Assemble collections, e.g., array, map."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/sasl/ShuffleSecretManager.java",
    "type": "method",
    "name": "registerApp",
    "code": "public void registerApp(String appId, ByteBuffer shuffleSecret) {\n    registerApp(appId, JavaUtils.bytesToString(shuffleSecret));\n  }",
    "comment": "Register an application with its secret specified as a byte buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "checkHeaderComment",
    "code": "private int checkHeaderComment(List<String> commentLines) {\n        if (getHeader() == null && layout.isEmpty()) {\n            // This is the first comment. Search for blank lines.\n            int index = commentLines.size() - 1;\n            while (index >= 0 && !commentLines.get(index).isEmpty()) {\n                index--;\n            }\n            setHeader(new ArrayList<String>(commentLines.subList(0, index + 1)));\n            return index + 1;\n        } else {\n            return 0;\n        }\n    }",
    "comment": "Checks if parts of the passed in comment can be used as header comment.\nThis method checks whether a header comment can be defined (i.e. whether\nthis is the first comment in the loaded file). If this is the case, it is\nsearched for the lates blank line. This line will mark the end of the\nheader comment. The return value is the index of the first line in the\npassed in list, which does not belong to the header comment.\n\n@param commentLines the comment lines\n@return the index of the next line after the header comment"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expressions.java",
    "type": "method",
    "name": "column",
    "code": "public static NamedReference column(String name) {\n    return LogicalExpressions.parseReference(name);\n  }",
    "comment": "Create a named reference expression for a (nested) column.\n\n@param name The column name. It refers to nested column if name contains dot.\n@return a named reference for the column"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getBoolean",
    "code": "public boolean getBoolean() {\n    return VariantUtil.getBoolean(value, pos);\n  }",
    "comment": "Get a boolean value from the variant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertNotSame",
    "code": "public static void assertNotSame(String message, Object expected, Object actual) {\n        if (expected == actual) {\n            failSame(message);\n        }\n    }",
    "comment": "Asserts that two objects do not refer to the same object. If they do\nrefer to the same object an AssertionFailedError is thrown with the\ngiven message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/CalendarInterval.java",
    "type": "method",
    "name": "compareTo",
    "code": "public int compareTo(CalendarInterval o) {\n    if (this.months != o.months) {\n      return Integer.compare(this.months, o.months);\n    } else if (this.days != o.days) {\n      return Integer.compare(this.days, o.days);\n    } else {\n      return Long.compare(this.microseconds, o.microseconds);\n    }\n  }",
    "comment": "This method is not used to order CalendarInterval instances, as they are not orderable and\ncannot be used in a ORDER BY statement.\nInstead, it is used to find identical interval instances for aggregation purposes.\nIt compares the 'months', 'days', and 'microseconds' fields of this CalendarInterval\nwith another instance. The comparison is done first on the 'months', then on the 'days',\nand finally on the 'microseconds'.\n\n@param o The CalendarInterval instance to compare with.\n@return Zero if this object is equal to the specified object, and non-zero otherwise"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(byte expected, Byte actual) {\n\t\tAssertEquals.assertEquals((Byte) expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectUri",
    "code": "public static UriSelector selectUri(String uri) {\n\t\tPreconditions.notBlank(uri, \"URI must not be null or blank\");\n\t\ttry {\n\t\t\treturn new UriSelector(new URI(uri));\n\t\t}\n\t\tcatch (URISyntaxException ex) {\n\t\t\tthrow new PreconditionViolationException(\"Failed to create a java.net.URI from: \" + uri, ex);\n\t\t}\n\t}",
    "comment": "Create a {@code UriSelector} for the supplied URI.\n\n@param uri the URI to select; never {@code null} or blank\n@see UriSelector\n@see #selectUri(URI)\n@see #selectFile(String)\n@see #selectFile(File)\n@see #selectDirectory(String)\n@see #selectDirectory(File)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "enableImplicitConfigurationParameters",
    "code": "public Builder enableImplicitConfigurationParameters(boolean enabled) {\n\t\t\tthis.requestBuilder.enableImplicitConfigurationParameters(enabled);\n\t\t\treturn this;\n\t\t}",
    "comment": "Configure whether implicit configuration parameters should be\nconsidered.\n\n<p>By default, only configuration parameters that are passed\nexplicitly to this builder are taken into account. Passing\n{@code true} to this method, enables additionally reading\nconfiguration parameters from implicit sources, i.e. system\nproperties and the {@code junit-platform.properties} classpath\nresource.\n\n@see #configurationParameter(String, String)\n@see #configurationParameters(Map)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Long> create(long[] shape, LongBuffer data) {\n    Tensor<Long> t = allocateForBuffer(DataType.INT64, shape, data.remaining());\n    t.buffer().asLongBuffer().put(data);\n    return t;\n  }",
    "comment": "Create an {@link Long} Tensor with data from the given buffer.\n\n<p>Creates a Tensor with the given shape by copying elements from the buffer (starting from its\ncurrent position) into the tensor. For example, if {@code shape = {2,3} } (which represents a\n2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/array/LongArray.java",
    "type": "method",
    "name": "set",
    "code": "public void set(int index, long value) {\n    assert index >= 0 : \"index (\" + index + \") should >= 0\";\n    assert index < length : \"index (\" + index + \") should < length (\" + length + \")\";\n    Platform.putLong(baseObj, baseOffset + index * WIDTH, value);\n  }",
    "comment": "Sets the value at position {@code index}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/command-query-responsibility-segregation/src/main/java/com/iluwatar/cqrs/commandes/CommandServiceImpl.java",
    "type": "method",
    "name": "getAuthorByUsername",
    "code": "private Author getAuthorByUsername(String username) {\n    Author author;\n    try (var session = sessionFactory.openSession()) {\n      var query = session.createQuery(\"from Author where username=:username\");\n      query.setParameter(\"username\", username);\n      author = (Author) query.uniqueResult();\n    }\n    if (author == null) {\n      HibernateUtil.getSessionFactory().close();\n      throw new NullPointerException(\"Author \" + username + \" doesn't exist!\");\n    }\n    return author;\n  }",
    "comment": "This class is an implementation of {@link CommandService} interface. It uses Hibernate as an api\nfor persistence."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/MyDoubleAvg.java",
    "type": "method",
    "name": "merge",
    "code": "@Override public void merge(MutableAggregationBuffer buffer1, Row buffer2) {\n    if (!buffer2.isNullAt(0)) {\n      if (buffer1.isNullAt(0)) {\n        buffer1.update(0, buffer2.getDouble(0));\n        buffer1.update(1, buffer2.getLong(1));\n      } else {\n        Double newValue = buffer2.getDouble(0) + buffer1.getDouble(0);\n        buffer1.update(0, newValue);\n        buffer1.update(1, buffer1.getLong(1) + buffer2.getLong(1));\n      }\n    }\n  }",
    "comment": "buffer1 and buffer2 have the same structure.\nWe only update the buffer1 when the input buffer2's sum value is not null.\nIf the buffer value (intermediate result of the sum) is still null,\nwe set the it as the input buffer's value.\nOtherwise, we update the bufferSum and bufferCount."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-di/src/main/java/org/apache/maven/di/impl/Types.java",
    "type": "method",
    "name": "if",
    "code": "public static Class<?> getRawType(Type type) {\n        if (type instanceof Class<?> clazz) {\n            return clazz;\n        } else if (type instanceof ParameterizedType parameterizedType) {\n            return (Class<?>) parameterizedType.getRawType();\n        } else if (type instanceof WildcardType wildcardType) {\n            Type[] upperBounds = wildcardType.getUpperBounds();\n            return getRawType(getUppermostType(upperBounds));\n        } else if (type instanceof GenericArrayType genericArrayType) {\n            Class<?> rawComponentType = getRawType(genericArrayType.getGenericComponentType());\n            try {\n                return Class.forName(\"[L\" + rawComponentType.getName() + \";\");\n            } catch (ClassNotFoundException e) {\n                throw new RuntimeException(e);\n            }\n        } else if (type instanceof TypeVariable<?> typeVariable) {\n            return getRawType(getUppermostType(typeVariable.getBounds()));\n        } else {\n            throw new IllegalArgumentException(\"Unsupported type: \" + type);\n        }\n    }",
    "comment": "Various helper methods for type processing"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/test/java/com/example/android/persistence/migrations/UserRepositoryTest.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n        MockitoAnnotations.initMocks(this);\n\n        mUserRepository = new UserRepository(new SingleExecutors(), mUserDataSource);\n    }",
    "comment": "Unit tests for the UserRepository."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/ShoppingCartService.java",
    "type": "method",
    "name": "calculateTotal",
    "code": "public double calculateTotal(final String userId) {\n    return cartRepository.calculateTotal(userId);\n  }",
    "comment": "Calculates the total cost of items in the user's shopping cart.\n\n@param userId The ID of the user.\n@return The total price of all items in the cart."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/UnrecoverableExceptions.java",
    "type": "method",
    "name": "rethrowIfUnrecoverable",
    "code": "public static void rethrowIfUnrecoverable(Throwable exception) {\n\t\tif (exception instanceof OutOfMemoryError) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(exception);\n\t\t}\n\t}",
    "comment": "Rethrow the supplied {@link Throwable exception} if it is\n<em>unrecoverable</em>.\n\n<p>If the supplied {@code exception} is not <em>unrecoverable</em>, this\nmethod does nothing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/resolution/InvalidRepositoryException.java",
    "type": "method",
    "name": "InvalidRepositoryException",
    "code": "public InvalidRepositoryException(String message, Repository repository, Throwable cause) {\n        super(message, cause);\n        this.repository = repository;\n    }",
    "comment": "Creates a new exception with specified detail message and cause for the given repository.\n\n@param message The detail message, may be {@code null}.\n@param repository The repository that caused the error, may be {@code null}.\n@param cause The cause, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-dependency-resolution/src/main/java/org/apache/maven/plugin/coreit/AbstractDependencyMojo.java",
    "type": "method",
    "name": "resolveFile",
    "code": "private File resolveFile(String pathname) {\n        File file = null;\n\n        if (pathname != null) {\n            if (pathname.contains(\"@idx@\")) {\n                pathname = pathname.replaceAll(\"@idx@\", String.valueOf(nextCounter()));\n            }\n\n            file = new File(pathname);\n\n            if (!file.isAbsolute()) {\n                file = new File(project.getBasedir(), pathname);\n            }\n        }\n\n        return file;\n    }",
    "comment": "NOTE: We don't want to test path translation here so resolve relative path manually for robustness\nhelps to distinguished forked executions of the same mojo"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/AlbumPage.java",
    "type": "method",
    "name": "changeAlbumTitle",
    "code": "public AlbumPage changeAlbumTitle(String albumTitle) {\n    var albumTitleInputTextField = (HtmlTextInput) page.getElementById(\"albumTitle\");\n    albumTitleInputTextField.setText(albumTitle);\n    return this;\n  }",
    "comment": "Sets the album title input text field\n\n@param albumTitle the new album title value to set\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, char expected, char actual) {\n        Assert.assertEquals(message, expected, actual);\n    }",
    "comment": "Asserts that two chars are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/TestWatcherTest.java",
    "type": "method",
    "name": "test",
    "code": "public void test() {\n                collector.addError(new RuntimeException(\"expected exception\"));\n            }",
    "comment": "the field name must be alphabetically lower than \"collector\" in\norder to make the test failing if order is not set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/memory/MemoryConsumer.java",
    "type": "method",
    "name": "freeMemory",
    "code": "public void freeMemory(long size) {\n    taskMemoryManager.releaseExecutionMemory(size, this);\n    used -= size;\n  }",
    "comment": "Release N bytes of memory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/runner/RequestTest.java",
    "type": "method",
    "name": "createsADescriptionWithANameForClasses",
    "code": "public void createsADescriptionWithANameForClasses() {\n        Description description = Request\n                .classes(RequestTest.class, RequestTest.class).getRunner()\n                .getDescription();\n        assertThat(description.toString(), is(\"classes\"));\n    }",
    "comment": "#1320 A root of a {@link Description} produced by\n{@link Request#classes(Class...)} should be named \"classes\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/DefaultBuildResumptionDataRepository.java",
    "type": "method",
    "name": "applyResumptionProperties",
    "code": "void applyResumptionProperties(MavenExecutionRequest request, Properties properties) {\n        String str1 = request.getResumeFrom();\n        if (properties.containsKey(REMAINING_PROJECTS) && !(str1 != null && !str1.isEmpty())) {\n            String propertyValue = properties.getProperty(REMAINING_PROJECTS);\n            Stream.of(propertyValue.split(PROPERTY_DELIMITER))\n                    .filter(str -> !str.isEmpty())\n                    .forEach(request.getProjectActivation()::activateOptionalProjectNonRecursive);\n            LOGGER.info(\"Resuming from {} due to the --resume / -r feature.\", propertyValue);\n        }\n    }",
    "comment": "This method is made package-private for testing purposes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, float actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerSession.java",
    "type": "method",
    "name": "options",
    "code": "public static EagerSession.Options options() {\n    return new Options();\n  }",
    "comment": "Returns an object that configures and builds a {@code EagerSession} with custom options.\n\n<p><b>WARNING:</b>Instances of {@code EagerSession} returned by this method must be explicitly\nfreed by invoking {@link #close()} when they are no longer needed. This could be achieve using\nthe `try-with-resources` technique.\n\n<p>Example usage:\n\n<pre>{@code\ntry (EagerSession session = EagerSession.options().async(true).build()) {\nOps tf = Ops.create(session);\n// build execute operations eagerly and asynchronously...\n}\n}</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/thrift/ThriftHttpServlet.java",
    "type": "method",
    "name": "toCookieStr",
    "code": "private String toCookieStr(Cookie[] cookies) {\n    String cookieStr = \"\";\n\n    for (Cookie c : cookies) {\n     cookieStr += c.getName() + \"=\" + c.getValue() + \" ;\\n\";\n    }\n    return cookieStr;\n  }",
    "comment": "Convert cookie array to human readable cookie string\n@param cookies Cookie Array\n@return String containing all the cookies separated by a newline character.\nEach cookie is of the format [key]=[value]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java9/org/junit/platform/commons/util/ModuleUtils.java",
    "type": "method",
    "name": "scan",
    "code": "List<Resource> scan(ModuleReference reference) {\n\t\t\ttry (ModuleReader reader = reference.open()) {\n\t\t\t\ttry (Stream<String> names = reader.list()) {\n\t\t\t\t\t// @formatter:off\n\t\t\t\t\treturn names.filter(name -> !name.endsWith(\".class\"))\n\t\t\t\t\t\t\t.map(this::loadResourceUnchecked)\n\t\t\t\t\t\t\t.filter(resourceFilter)\n\t\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\t\t// @formatter:on\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new JUnitException(\"Failed to read contents of \" + reference + \".\", e);\n\t\t\t}\n\t\t}",
    "comment": "Scan module reference for resources that potentially contain testable resources."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "dynamicallyRegistered",
    "code": "public Events dynamicallyRegistered() {\n\t\treturn new Events(eventsByType(EventType.DYNAMIC_TEST_REGISTERED), this.category + \" Dynamically Registered\");\n\t}",
    "comment": "Get the dynamic registration {@link Events} contained in this\n{@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/legacy/LegacyRepositorySystem.java",
    "type": "method",
    "name": "createDependencyArtifact",
    "code": "public Artifact createDependencyArtifact(Dependency d) {\n        VersionRange versionRange;\n        try {\n            versionRange = VersionRange.createFromVersionSpec(d.getVersion());\n        } catch (InvalidVersionSpecificationException e) {\n            this.logger.error(\n                    String.format(\n                            \"Invalid version specification '%s' creating dependency artifact '%s'.\", d.getVersion(), d),\n                    e);\n            return null;\n        }\n\n        Artifact artifact = artifactFactory.createDependencyArtifact(\n                d.getGroupId(),\n                d.getArtifactId(),\n                versionRange,\n                d.getType(),\n                d.getClassifier(),\n                d.getScope(),\n                d.isOptional());\n\n        if (Artifact.SCOPE_SYSTEM.equals(d.getScope()) && d.getSystemPath() != null) {\n            artifact.setFile(new File(d.getSystemPath()));\n        }\n\n        if (!d.getExclusions().isEmpty()) {\n            List<String> exclusions = new ArrayList<>();\n\n            for (Exclusion exclusion : d.getExclusions()) {\n                exclusions.add(exclusion.getGroupId() + ':' + exclusion.getArtifactId());\n            }\n\n            artifact.setDependencyFilter(new ExcludesArtifactFilter(exclusions));\n        }\n\n        return artifact;\n    }",
    "comment": "MNG-5368: Log a message instead of returning 'null' silently."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProfileActivation.java",
    "type": "method",
    "name": "overwriteActiveProfiles",
    "code": "public void overwriteActiveProfiles(List<String> activeProfileIds) {\n        getActiveProfiles().forEach(this.activations::remove);\n        activeProfileIds.forEach(this::activateOptionalProfile);\n    }",
    "comment": "Overwrites the active profiles based on a pre-Maven 4 \"active profiles\" list.\n@param activeProfileIds A {@link List} of profile IDs that must be activated.\n@deprecated Use {@link #activateOptionalProfile(String)} or {@link #activateRequiredProfile(String)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaGaussianMixtureExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    // Creates a SparkSession\n    SparkSession spark = SparkSession\n            .builder()\n            .appName(\"JavaGaussianMixtureExample\")\n            .getOrCreate();\n\n    // $example on$\n    // Loads data\n    Dataset<Row> dataset = spark.read().format(\"libsvm\").load(\"data/mllib/sample_kmeans_data.txt\");\n\n    // Trains a GaussianMixture model\n    GaussianMixture gmm = new GaussianMixture()\n      .setK(2);\n    GaussianMixtureModel model = gmm.fit(dataset);\n\n    // Output the parameters of the mixture model\n    for (int i = 0; i < model.getK(); i++) {\n      System.out.printf(\"Gaussian %d:\\nweight=%f\\nmu=%s\\nsigma=\\n%s\\n\\n\",\n              i, model.weights()[i], model.gaussians()[i].mean(), model.gaussians()[i].cov());\n    }\n    // $example off$\n\n    spark.stop();\n  }",
    "comment": "An example demonstrating Gaussian Mixture Model.\nRun with\n<pre>\nbin/run-example ml.JavaGaussianMixtureExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "public Resolution resolve(ClassSelector selector, Context context) {\n\t\tClass<?> testClass = selector.getJavaClass();\n\n\t\tif (this.predicates.isAnnotatedWithNested.test(testClass)) {\n\t\t\tif (this.predicates.isValidNestedTestClass(testClass)) {\n\t\t\t\treturn toResolution(\n\t\t\t\t\tcontext.addToParent(() -> DiscoverySelectors.selectClass(testClass.getEnclosingClass()),\n\t\t\t\t\t\tparent -> Optional.of(newMemberClassTestDescriptor(parent, testClass))));\n\t\t\t}\n\t\t}\n\t\telse if (isAcceptedStandaloneTestClass(testClass)) {\n\t\t\treturn toResolution(\n\t\t\t\tcontext.addToParent(parent -> Optional.of(newStandaloneClassTestDescriptor(parent, testClass))));\n\t\t}\n\t\treturn unresolved();\n\t}",
    "comment": "Class name filter is not applied to nested test classes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "escapeKey",
    "code": "private static String escapeKey(String key) {\n        StringBuilder newkey = new StringBuilder();\n\n        for (int i = 0; i < key.length(); i++) {\n            char c = key.charAt(i);\n\n            if (contains(SEPARATORS, c) || contains(WHITE_SPACE, c)) {\n                // escape the separator\n                newkey.append('\\\\');\n                newkey.append(c);\n            } else {\n                newkey.append(c);\n            }\n        }\n\n        return newkey.toString();\n    }",
    "comment": "Escape the separators in the key.\n\n@param key the key\n@return the escaped key"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TimerWithCustomTimeUnit.java",
    "type": "method",
    "name": "toUnit",
    "code": "private double toUnit(double nanos) {\n    return nanos / nanosPerUnit;\n  }",
    "comment": "TimeUnit.convert() truncates (loses precision), so floating-point division is used instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/bridge/src/test/java/com/iluwatar/bridge/SwordTest.java",
    "type": "method",
    "name": "testSword",
    "code": "void testSword() {\n    final var sword = spy(new Sword(mock(FlyingEnchantment.class)));\n    testBasicWeaponActions(sword);\n  }",
    "comment": "Invoke all possible actions on the weapon and check if the actions are executed on the actual\nunderlying weapon implementation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "objectSize",
    "code": "public int objectSize() {\n    return handleObject(value, pos,\n        (size, idSize, offsetSize, idStart, offsetStart, dataStart) -> size);\n  }",
    "comment": "Get the number of object fields in the variant.\nIt is only legal to call it when `getType()` is `Type.OBJECT`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelPathTranslator.java",
    "type": "method",
    "name": "alignToBaseDirectory",
    "code": "private Resource alignToBaseDirectory(Resource resource, Path basedir) {\n        if (resource != null) {\n            String oldDir = resource.getDirectory();\n            String newDir = alignToBaseDirectory(oldDir, basedir);\n            if (newDir != oldDir) {\n                return resource.withDirectory(newDir);\n            }\n        }\n        return resource;\n    }",
    "comment": "Returns a resource with all properties identical to the given resource, except the paths\nwhich are resolved according the given {@code basedir}. If the paths are unchanged, then\nthis method returns the previous instance.\n\n@param resource the resource to relocate, or {@code null}\n@param basedir the new base directory\n@return relocated resource, or {@code null} if the given resource was null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcKeyPassword",
    "code": "public String sslRpcKeyPassword() {\n    return conf.get(\"spark.ssl.rpc.keyPassword\", null);\n  }",
    "comment": "The password to the private key in the key store"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedParquetRecordReader.java",
    "type": "method",
    "name": "resultBatch",
    "code": "public ColumnarBatch resultBatch() {\n    if (columnarBatch == null) initBatch();\n    return columnarBatch;\n  }",
    "comment": "Returns the ColumnarBatch object that will be used for all rows returned by this reader.\nThis object is reused. Calling this enables the vectorized reader. This should be called\nbefore any calls to nextKeyValue/nextBatch."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/params/provider/FieldArgumentsProviderTests.java",
    "type": "method",
    "name": "providesArgumentsUsingStreamSupplier",
    "code": "void providesArgumentsUsingStreamSupplier() {\n\t\tvar arguments = provideArguments(\"stringStreamSupplier\");\n\n\t\tassertThat(arguments).containsExactly(array(\"foo\"), array(\"bar\"));\n\t}",
    "comment": "Unit tests for {@link FieldArgumentsProvider}.\n\n@since 5.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultModelCacheFactory.java",
    "type": "method",
    "name": "createCache",
    "code": "public ModelCache createCache(RepositorySystemSession session) {\n        return DefaultModelCache.newInstance(session);\n    }",
    "comment": "Default implementation of {@link ModelCacheFactory}.\n\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/graph/FilteredProjectDependencyGraph.java",
    "type": "method",
    "name": "Key",
    "code": "private record Key(MavenProject project, boolean transitive, boolean upstream) {}",
    "comment": "Provides a sub view of another dependency graph."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaUserDefinedUntypedAggregation.java",
    "type": "method",
    "name": "reduce",
    "code": "public Average reduce(Average buffer, Long data) {\n      long newSum = buffer.getSum() + data;\n      long newCount = buffer.getCount() + 1;\n      buffer.setSum(newSum);\n      buffer.setCount(newCount);\n      return buffer;\n    }",
    "comment": "Combine two values to produce a new value. For performance, the function may modify `buffer`\nand return it instead of constructing a new object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/protocol/UploadBlockStream.java",
    "type": "method",
    "name": "UploadBlockStream",
    "code": "public UploadBlockStream(String blockId, byte[] metadata) {\n    this.blockId = blockId;\n    this.metadata = metadata;\n  }",
    "comment": "A request to Upload a block, which the destination should receive as a stream.\n\nThe actual block data is not contained here.  It will be passed to the StreamCallbackWithID\nthat is returned from RpcHandler.receiveStream()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/utils/CLIReportingUtils.java",
    "type": "method",
    "name": "createMavenVersionString",
    "code": "public static String createMavenVersionString(Properties buildProperties) {\n        String version = reduce(buildProperties.getProperty(BUILD_VERSION_PROPERTY));\n        String rev = reduce(buildProperties.getProperty(\"buildNumber\"));\n        String distributionName = reduce(buildProperties.getProperty(\"distributionName\"));\n\n        return distributionName + \" \"\n                + (version != null ? version : \"<version unknown>\")\n                + (rev != null ? \" (\" + rev + \")\" : \"\");\n    }",
    "comment": "Create a human-readable string containing the Maven version, buildnumber, and time of build\n\n@param buildProperties The build properties\n@return Readable build info"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "PropertiesReader",
    "code": "public PropertiesReader(Reader reader, boolean maybeTyped) {\n            super(reader);\n            commentLines = new ArrayList<>();\n            valueLines = new ArrayList<>();\n            this.maybeTyped = maybeTyped;\n        }",
    "comment": "Creates a new instance of <code>PropertiesReader</code> and sets\nthe underlaying reader and the list delimiter.\n\n@param reader the reader"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/Utility.java",
    "type": "method",
    "name": "lowestFrequencyChar",
    "code": "public static Character lowestFrequencyChar(Map<Character, Long> charFrequency) {\n    return charFrequency.entrySet().stream()\n        .min(Comparator.comparingLong(Entry::getValue))\n        .map(Entry::getKey)\n        .orElseThrow();\n  }",
    "comment": "Return the character with the lowest frequency, if exists.\n\n@return the character, {@code Optional.empty()} otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeOnSuccessPassingParameter",
    "code": "void cleanupModeOnSuccessPassingParameter() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(OnSuccessPassingParameterCase.class, \"testOnSuccessPassingParameter\",\n\t\t\t\t\t\t\"java.nio.file.Path\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(onSuccessPassingParameterDir).doesNotExist();\n\t\t}",
    "comment": "Ensure that ON_SUCCESS cleanup modes are obeyed for passing parameter tests.\n<p/>\nExpect the TempDir to be cleaned up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/Scope.java",
    "type": "method",
    "name": "Scope",
    "code": "public Scope(ExecutionEnvironment env) {\n    this(env, new NameScope(), new ArrayList<Operand<?>>());\n  }",
    "comment": "Create a new top-level scope.\n\n@param env The execution environment used by the scope."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/ReactorReader.java",
    "type": "method",
    "name": "findArtifact",
    "code": "private File findArtifact(MavenProject project, Artifact artifact, boolean checkUptodate) {\n        if (\"pom\".equals(artifact.getExtension())) {\n            return project.getFile();\n        }\n\n        Artifact projectArtifact = findMatchingArtifact(project, artifact);\n        if (projectArtifact != null) {\n            File packagedArtifactFile = projectArtifact.getFile();\n            if (packagedArtifactFile != null && packagedArtifactFile.exists()) {\n                return packagedArtifactFile;\n            }\n        }\n\n        File packagedArtifactFile = findInProjectLocalRepository(artifact);\n        if (packagedArtifactFile != null\n                && packagedArtifactFile.exists()\n                && (!checkUptodate || isPackagedArtifactUpToDate(project, packagedArtifactFile))) {\n            return packagedArtifactFile;\n        }\n\n        if (!hasBeenPackagedDuringThisSession(project)) {\n            return determineBuildOutputDirectoryForArtifact(project, artifact);\n        }\n\n        return null;\n    }",
    "comment": "Implementation\n\nPOMs are always returned from the file system\nGet the matching artifact from the project\nIf the artifact has been associated to a file, use it\nCheck in the project local repository\nfallback to loose class files only if artifacts haven't been packaged yet\nand only for plain old jars. Not war files, not ear files, not anything else.\nThe fall-through indicates that the artifact cannot be found;\nfor instance if package produced nothing or classifier problems."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "setCacheDir",
    "code": "public Options setCacheDir(String cacheDir) {\n      this.cacheDir = cacheDir;\n      return this;\n    }",
    "comment": "Configure the location to be used to store model compilation cache entries. If either {@code\ncacheDir} or {@code modelToken} parameters are unset NNAPI caching will be disabled.\n\n<p>Only effective on Android 10 (API level 29) and above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "getLastNativeInferenceDurationNanoseconds",
    "code": "Long getLastNativeInferenceDurationNanoseconds() {\n    return (inferenceDurationNanoseconds < 0) ? null : inferenceDurationNanoseconds;\n  }",
    "comment": "Gets the last inference duration in nanoseconds. It returns null if there is no previous\ninference run or the last inference run failed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectMethod",
    "code": "public static MethodSelector selectMethod(String className, String methodName) {\n\t\treturn selectMethod((ClassLoader) null, className, methodName);\n\t}",
    "comment": "Create a {@code MethodSelector} for the supplied class name and method name\nusing the default class loader.\n\n@param className the fully qualified name of the class in which the method\nis declared, or a subclass thereof; never {@code null} or blank\n@param methodName the name of the method to select; never {@code null} or blank\n@see MethodSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/BloomFilter.java",
    "type": "method",
    "name": "optimalNumOfBits",
    "code": "public static long optimalNumOfBits(long n, double p) {\n    return (long) (-n * Math.log(p) / (Math.log(2) * Math.log(2)));\n  }",
    "comment": "Computes m (total bits of Bloom filter) which is expected to achieve, for the specified\nexpected insertions, the required false positive probability.\n\nSee http://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives for the formula.\n\n@param n expected insertions (must be positive)\n@param p false positive rate (must be 0 &lt; p &lt; 1)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "lowercaseContains",
    "code": "public static boolean lowercaseContains(final UTF8String target, final UTF8String pattern) {\n    // Fast path for ASCII-only strings.\n    if (target.isFullAscii() && pattern.isFullAscii()) {\n      return target.toLowerCase().contains(pattern.toLowerCase());\n    }\n    // Slow path for non-ASCII strings.\n    return CollationAwareUTF8String.lowercaseIndexOfSlow(target, pattern, 0) >= 0;\n  }",
    "comment": "Checks whether the target string contains the pattern string, with respect to the UTF8_LCASE\ncollation. This method generally works with respect to code-point based comparison logic.\n\n@param target the string to be searched in\n@param pattern the string to be searched for\n@return whether the target string contains the pattern string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SparkSaslClient.java",
    "type": "method",
    "name": "if",
    "code": "for (Callback callback : callbacks) {\n        if (callback instanceof NameCallback nc) {\n          logger.trace(\"SASL client callback: setting username\");\n          nc.setName(encodeIdentifier(secretKeyHolder.getSaslUser(secretKeyId)));\n        } else if (callback instanceof PasswordCallback pc) {\n          logger.trace(\"SASL client callback: setting password\");\n          pc.setPassword(encodePassword(secretKeyHolder.getSecretKey(secretKeyId)));\n        } else if (callback instanceof RealmCallback rc) {\n          logger.trace(\"SASL client callback: setting realm\");\n          rc.setText(rc.getDefaultText());\n        } else if (callback instanceof RealmChoiceCallback) {\n          // ignore (?)\n        } else {\n          throw new UnsupportedCallbackException(callback, \"Unrecognized SASL DIGEST-MD5 Callback\");\n        }\n      }",
    "comment": "Implementation of javax.security.auth.callback.CallbackHandler\nthat works with share secrets."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/conversion/ConversionSupport.java",
    "type": "method",
    "name": "convert",
    "code": "public static <T> T convert(String source, Class<T> targetType, ClassLoader classLoader) {\n\t\tif (source == null) {\n\t\t\tif (targetType.isPrimitive()) {\n\t\t\t\tthrow new ConversionException(\n\t\t\t\t\t\"Cannot convert null to primitive value of type \" + targetType.getTypeName());\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tif (String.class.equals(targetType)) {\n\t\t\treturn (T) source;\n\t\t}\n\n\t\tClass<?> targetTypeToUse = toWrapperType(targetType);\n\t\tOptional<StringToObjectConverter> converter = stringToObjectConverters.stream().filter(\n\t\t\tcandidate -> candidate.canConvertTo(targetTypeToUse)).findFirst();\n\t\tif (converter.isPresent()) {\n\t\t\ttry {\n\t\t\t\tClassLoader classLoaderToUse = classLoader != null ? classLoader\n\t\t\t\t\t\t: ClassLoaderUtils.getDefaultClassLoader();\n\t\t\t\treturn (T) converter.get().convert(source, targetTypeToUse, classLoaderToUse);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (ex instanceof ConversionException) {\n\t\t\t\t\t// simply rethrow it\n\t\t\t\t\tthrow (ConversionException) ex;\n\t\t\t\t}\n\t\t\t\t// else\n\t\t\t\tthrow new ConversionException(\n\t\t\t\t\tString.format(\"Failed to convert String \\\"%s\\\" to type %s\", source, targetType.getTypeName()), ex);\n\t\t\t}\n\t\t}\n\n\t\tthrow new ConversionException(\n\t\t\t\"No built-in converter for source type java.lang.String and target type \" + targetType.getTypeName());\n\t}",
    "comment": "Convert the supplied source {@code String} into an instance of the specified\ntarget type.\n\n<p>If the target type is {@code String}, the source {@code String} will not\nbe modified.\n\n<p>Some forms of conversion require a {@link ClassLoader}. If none is\nprovided, the {@linkplain ClassLoaderUtils#getDefaultClassLoader() default\nClassLoader} will be used.\n\n<p>This method is able to convert strings into primitive types and their\ncorresponding wrapper types ({@link Boolean}, {@link Character}, {@link Byte},\n{@link Short}, {@link Integer}, {@link Long}, {@link Float}, and\n{@link Double}), enum constants, date and time types from the\n{@code java.time} package, as well as common Java types such as {@link Class},\n{@link java.io.File}, {@link java.nio.file.Path}, {@link java.nio.charset.Charset},\n{@link java.math.BigDecimal}, {@link java.math.BigInteger},\n{@link java.util.Currency}, {@link java.util.Locale}, {@link java.util.UUID},\n{@link java.net.URI}, and {@link java.net.URL}.\n\n<p>If the target type is not covered by any of the above, a convention-based\nconversion strategy will be used to convert the source {@code String} into the\ngiven target type by invoking a static factory method or factory constructor\ndefined in the target type. The search algorithm used in this strategy is\noutlined below.\n\n<h4>Search Algorithm</h4>\n\n<ol>\n<li>Search for a single, non-private static factory method in the target\ntype that converts from a String to the target type. Use the factory method\nif present.</li>\n<li>Search for a single, non-private constructor in the target type that\naccepts a String. Use the constructor if present.</li>\n</ol>\n\n<p>If multiple suitable factory methods are discovered they will be ignored.\nIf neither a single factory method nor a single constructor is found, the\nconvention-based conversion strategy will not apply.\n\n@param source the source {@code String} to convert; may be {@code null}\nbut only if the target type is a reference type\n@param targetType the target type the source should be converted into;\nnever {@code null}\n@param classLoader the {@code ClassLoader} to use; may be {@code null} to\nuse the default {@code ClassLoader}\n@param <T> the type of the target\n@return the converted object; may be {@code null} but only if the target\ntype is a reference type\n\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicContainer.java",
    "type": "method",
    "name": "dynamicContainer",
    "code": "public static DynamicContainer dynamicContainer(String displayName, Stream<? extends DynamicNode> dynamicNodes) {\n\t\treturn dynamicContainer(displayName, null, dynamicNodes);\n\t}",
    "comment": "Factory for creating a new {@code DynamicContainer} for the supplied display\n\n@param displayName the display name for the dynamic container; never\n{@code null} or blank\n@param dynamicNodes stream of dynamic nodes to execute;\nnever {@code null}\n@see #dynamicContainer(String, Iterable)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistrationViaParametersAndFieldsTests.java",
    "type": "method",
    "name": "test",
    "code": "void test(TestInfo testInfo, String text) {\n\t\t\tassertThat(testInfo).isNotNull();\n\t\t\tassertThat(text).isEqualTo(\"test-1-enigma\");\n\t\t}",
    "comment": "The {@link MagicParameter.Extension} is first registered for the {@code @AfterAll}\nmethod, but that registration occurs before the test method is invoked, which\nallows the string parameters in the after-each and test methods to be resolved\nby the {@link MagicParameter.Extension} as well."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "getOutputTensor",
    "code": "TensorImpl getOutputTensor(int index) {\n    if (index < 0 || index >= outputTensors.length) {\n      throw new IllegalArgumentException(\"Invalid output Tensor index: \" + index);\n    }\n    TensorImpl outputTensor = outputTensors[index];\n    if (outputTensor == null) {\n      outputTensor =\n          outputTensors[index] =\n              TensorImpl.fromIndex(\n                  interpreterHandle, getOutputTensorIndex(interpreterHandle, index));\n    }\n    return outputTensor;\n  }",
    "comment": "Gets the output {@link TensorImpl} for the provided output index.\n\n@throws IllegalArgumentException if the output index is invalid."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/MonotonicClock.java",
    "type": "method",
    "name": "elapsedTime",
    "code": "public Duration elapsedTime() {\n        long elapsedNanos = System.nanoTime() - startNanos;\n        return Duration.ofNanos(elapsedNanos);\n    }",
    "comment": "Returns the duration elapsed since this clock was initialized.\n<p>\nThe returned duration is calculated using {@link System#nanoTime()}\nto ensure monotonic behavior. This duration represents the exact time\nspan between clock initialization and the current instant.\n\n@return the duration since clock initialization\n@see #startInstant()\n@see #instant()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, double actual, double delta, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, delta, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/command/src/test/java/com/iluwatar/command/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/SuspendResumeLock.java",
    "type": "method",
    "name": "SuspendResumeLock",
    "code": "public static final SuspendResumeLock FAUX_LOCK = new SuspendResumeLock(false) {\n\n      @Override\n      public void release() {}\n\n      @Override\n      public void suspend() {}\n\n      @Override\n      public void resume() {}\n   };",
    "comment": "This class implements a lock that can be used to suspend and resume the pool.  It\nalso provides a faux implementation that is used when the feature is disabled that\nhopefully gets fully \"optimized away\" by the JIT.\n\n@author Brett Wooldridge"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/RemoteSnapshotMetadataGenerator.java",
    "type": "method",
    "name": "if",
    "code": "RemoteSnapshotMetadataGenerator(RepositorySystemSession session, DeployRequest request) {\n        timestamp = (Date) ConfigUtils.getObject(session, new Date(), \"maven.startTime\");\n        Object bn = ConfigUtils.getObject(session, null, \"maven.buildNumber\");\n        if (bn instanceof Integer integer) {\n            this.buildNumber = integer;\n        } else if (bn instanceof String string) {\n            this.buildNumber = Integer.valueOf(string);\n        } else {\n            this.buildNumber = null;\n        }\n\n        snapshots = new LinkedHashMap<>();\n\n        /*\n         * NOTE: This should be considered a quirk to support interop with Maven's legacy ArtifactDeployer which\n         * processes one artifact at a time and hence cannot associate the artifacts from the same project to use the\n         * same timestamp+buildno for the snapshot versions. Allowing the caller to pass in metadata from a previous\n         * deployment allows to re-establish the association between the artifacts of the same project.\n         */\n        for (Metadata metadata : request.getMetadata()) {\n            if (metadata instanceof RemoteSnapshotMetadata snapshotMetadata) {\n                snapshots.put(snapshotMetadata.getKey(), snapshotMetadata);\n            }\n        }\n    }",
    "comment": "Maven remote GAV level metadata generator.\n<p>\nRemote snapshot metadata converts artifact on-the-fly to use timestamped snapshot version, and enlist it accordingly.\n\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "directory",
    "code": "public SparkLauncher directory(File dir) {\n    workingDir = dir;\n    return this;\n  }",
    "comment": "Sets the working directory of spark-submit.\n\n@param dir The directory to set as spark-submit's working directory.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Object unexpected, Object actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails if both are {@code null}.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@see Object#equals(Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java",
    "type": "method",
    "name": "provideForClass",
    "code": "default Set<Lock> provideForClass(Class<?> testClass) {\n\t\treturn emptySet();\n\t}",
    "comment": "Add shared resources for a test class.\n\n<p>Invoked in case a test class or its parent class is annotated with\n{@code @ResourceLock(providers)}.\n\n@apiNote Adding {@linkplain Lock a shared resource} via this method has\nthe same semantics as annotating a test class with an analogous\n{@code @ResourceLock(value, mode)} declaration.\n\n@param testClass a test class for which to add shared resources\n@return a set of {@link Lock}; may be empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(boolean condition) {\n        assertTrue(null, condition);\n    }",
    "comment": "Asserts that a condition is true. If it isn't it throws\nan AssertionFailedError."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginValidationManager.java",
    "type": "method",
    "name": "onEvent",
    "code": "public void onEvent(Object event) {\n        if (event instanceof ExecutionEvent executionEvent) {\n            if (executionEvent.getType() == ExecutionEvent.Type.SessionStarted) {\n                RepositorySystemSession repositorySystemSession =\n                        executionEvent.getSession().getRepositorySession();\n                validationReportLevel(repositorySystemSession); // this will parse and store it in session.data\n                validationPluginExcludes(repositorySystemSession);\n            } else if (executionEvent.getType() == ExecutionEvent.Type.SessionEnded) {\n                reportSessionCollectedValidationIssues(executionEvent.getSession());\n            }\n        }\n    }",
    "comment": "The collection of \"G:A\" combinations that do NOT belong to Maven Core, hence, should be excluded from\n\"expected in provided scope\" type of checks."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/reporting/FileEntry.java",
    "type": "method",
    "name": "from",
    "code": "public static FileEntry from(Path path, String mediaType) {\n\t\treturn new FileEntry(path, mediaType);\n\t}",
    "comment": "Factory for creating a new {@code FileEntry} from the supplied path and\n@param mediaType the media type of the path to publish; may be\n{@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/Inventory.java",
    "type": "method",
    "name": "getItems",
    "code": "public final List<Item> getItems() {\n    return List.copyOf(items);\n  }",
    "comment": "Get all the items in the inventory.\n\n@return All the items of the inventory, as an unmodifiable list"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "substring",
    "code": "public Object substring(List<Object> args) {\n        if (args.size() < 2 || args.size() > 3) {\n            throw new IllegalArgumentException(\"substring function requires 2 or 3 arguments\");\n        }\n        String s = ConditionParser.toString(args.get(0));\n        int start = toInt(args.get(1));\n        int end = args.size() == 3 ? toInt(args.get(2)) : s.length();\n        return s.substring(start, end);\n    }",
    "comment": "Returns a substring of the given string.\n\n@param args A list containing 2 or 3 arguments: the string, start index, and optionally end index\n@return The substring\n@throws IllegalArgumentException if the number of arguments is not 2 or 3"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProjectActivation.java",
    "type": "method",
    "name": "activateOptionalProject",
    "code": "public void activateOptionalProject(String selector) {\n        this.activations.add(new ProjectActivationSettings(selector, ActivationSettings.activatedOpt()));\n    }",
    "comment": "Mark a project as optional and activated.\n@param selector The selector of the project."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/ModelBenchmarkReport.java",
    "type": "method",
    "name": "computeModelReport",
    "code": "protected void computeModelReport(List<RawDelegateMetricsEntry> rawDelegateMetrics) {\n    if (!processedDelegateMetrics.isEmpty()) {\n      // Metrics are computed.\n      Log.i(TAG, \"Delegate metrics are already computed. Skips the computation.\");\n      return;\n    }\n    // At least 2 delegates (the default delegate and the test target delegate) are tested.\n    checkState(rawDelegateMetrics.size() >= 2);\n    // The test target delegate is the last delegate to benchmark. The order will be guaranteed by\n    // DelegatePerformanceBenchmark#loadTfLiteSettingsList().\n    RawDelegateMetricsEntry testTarget = rawDelegateMetrics.get(rawDelegateMetrics.size() - 1);\n    checkState(testTarget.isTestTarget());\n    // Use {@code LinkedHashMap} to keep the insertion order.\n    Map<String, MetricsEntry> metrics = new LinkedHashMap<>();\n    for (String metricName : testTarget.metrics().keySet()) {\n      metrics.put(\n          metricName,\n          MetricsEntry.create(\n              testTarget.metrics().get(metricName), \"N/A\", BenchmarkResultType.NOT_APPLICABLE));\n    }\n    processedDelegateMetrics.add(\n        DelegateMetricsEntry.create(\n            testTarget.delegateIdentifier(),\n            metrics,\n            BenchmarkResultType.NOT_APPLICABLE,\n            testTarget.isTestTarget(),\n            /* isStrictCriteria= */ false));\n\n    // Processes the reference delegate results. Compute the performance regressions by comparing\n    // them with the results from the test target delegate.\n    List<BenchmarkResultType> referenceResults = new ArrayList<>();\n    // Traverses the list in reverse order, so that the exported order of items matches with the\n    // input delegate setting files order.\n    for (int reference = rawDelegateMetrics.size() - 2; reference >= 0; reference--) {\n      RawDelegateMetricsEntry entry = rawDelegateMetrics.get(reference);\n      Map<String, MetricsEntry> referenceMetrics = new LinkedHashMap<>();\n      List<BenchmarkResultType> metricResults = new ArrayList<>();\n      for (String metricName : testTarget.metrics().keySet()) {\n        MetricsEntry metricEntry =\n            computeReferenceMetricEntry(\n                entry.metrics().get(metricName), testTarget.metrics().get(metricName), metricName);\n        referenceMetrics.put(metricName, metricEntry);\n        // Filters for the metrics that are involved in the Pass/Pass with Warning/Fail result\n        // generation.\n        if (metricEntry.result() != BenchmarkResultType.NOT_APPLICABLE) {\n          metricResults.add(metricEntry.result());\n        }\n      }\n      // TODO(b/267488243): Load the delegate name from the native layer.\n      boolean sameDelegateType = entry.delegateName().equals(testTarget.delegateName());\n      BenchmarkResultType referenceDelegateResult =\n          DelegatePerformanceBenchmark.aggregateResults(sameDelegateType, metricResults);\n      referenceResults.add(referenceDelegateResult);\n      processedDelegateMetrics.add(\n          DelegateMetricsEntry.create(\n              entry.delegateIdentifier(),\n              referenceMetrics,\n              referenceDelegateResult,\n              entry.isTestTarget(),\n              sameDelegateType));\n    }\n    result = DelegatePerformanceBenchmark.aggregateResults(/* strict= */ true, referenceResults);\n  }",
    "comment": "Converts the prepopulated list of {@link RawDelegateMetricsEntry}, the raw performance results\ncollected from the native layer, into a list of {@link DelegateMetricsEntry}.\n\n<p>The computation compares the test target delegate with every reference delegate by computing\nthe regression of the raw performance results. The list of {@link DelegateMetricsEntry} stores\nthe calculated results for all pairs. {@link ModelBenchmarkReport} stores both the raw\nperformance results and the processed performance results."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/Trigger.java",
    "type": "method",
    "name": "Once",
    "code": "public static Trigger Once() {\n    return OneTimeTrigger$.MODULE$;\n  }",
    "comment": "A trigger that processes all available data in a single batch then terminates the query.\n\n@since 2.2.0\n@deprecated This is deprecated as of Spark 3.4.0. Use {@link #AvailableNow()} to leverage\nbetter guarantee of processing, fine-grained scale of batches, and better gradual\nprocessing of watermark advancement including no-data batch.\nSee the NOTES in {@link #AvailableNow()} for details."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/test/org/apache/spark/JavaAPISuite.java",
    "type": "method",
    "name": "tearDown",
    "code": "public void tearDown() {\n    sc.stop();\n    sc = null;\n  }",
    "comment": "The test suite itself is Serializable so that anonymous Function implementations can be\nserialized, as an alternative to converting these anonymous classes to static inner classes;\nsee http://stackoverflow.com/questions/758570/."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/BaseRequest.java",
    "type": "method",
    "name": "BaseRequest",
    "code": "protected BaseRequest(@Nonnull S session) {\n        this(session, null);\n    }",
    "comment": "Base class for requests.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/FluentIterable.java",
    "type": "method",
    "name": "copyToList",
    "code": "static <E> List<E> copyToList(Iterable<E> iterable) {\n    var copy = new ArrayList<E>();\n    iterable.forEach(copy::add);\n    return copy;\n  }",
    "comment": "Utility method that iterates over iterable and adds the contents to a list.\n\n@param iterable the iterable to collect\n@param <E> the type of the objects to iterate\n@return a list with all objects of the given iterator"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isPublic",
    "code": "public static boolean isPublic(Member member) {\n\t\treturn ReflectionUtils.isPublic(member);\n\t}",
    "comment": "Determine if the supplied member is {@code public}.\n\n@param member the member to check; never {@code null}\n@return {@code true} if the member is {@code public}\n@see java.lang.reflect.Modifier#isPublic(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-di/src/main/java/org/apache/maven/di/Key.java",
    "type": "method",
    "name": "of",
    "code": "public static <T> Key<T> of(Class<T> type, @Nullable Object qualifier) {\n        return new KeyImpl<>(type, qualifier);\n    }",
    "comment": "Creates a new Key instance for the specified type with a qualifier.\n\n@param <T> the type parameter\n@param type the Class object representing the type\n@param qualifier the qualifier object (typically an annotation instance)\n@return a new Key instance\n@throws NullPointerException if type is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/bully/BullyMessageManager.java",
    "type": "method",
    "name": "sendElectionMessage",
    "code": "public boolean sendElectionMessage(int currentId, String content) {\n    var candidateList = findElectionCandidateInstanceList(currentId);\n    if (candidateList.isEmpty()) {\n      return true;\n    } else {\n      var electionMessage = new Message(MessageType.ELECTION_INVOKE, \"\");\n      candidateList.forEach((i) -> instanceMap.get(i).onMessage(electionMessage));\n      return false;\n    }\n  }",
    "comment": "Send election message to all the instances with smaller ID.\n\n@param currentId Instance ID of which sends this message.\n@param content Election message content.\n@return {@code true} if no alive instance has smaller ID, so that the election is accepted."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProfileActivation.java",
    "type": "method",
    "name": "deactivateRequiredProfile",
    "code": "public void deactivateRequiredProfile(String id) {\n        this.activations.put(id, ActivationSettings.deactivated());\n    }",
    "comment": "Mark a profile as required and deactivated.\n@param id The identifier of the profile."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setDecimal",
    "code": "public void setDecimal(Decimal value, int precision) {\n    // copy and modify from WritableColumnVector\n    if (precision <= Decimal.MAX_INT_DIGITS()) {\n      setInt((int) value.toUnscaledLong());\n    } else if (precision <= Decimal.MAX_LONG_DIGITS()) {\n      setLong(value.toUnscaledLong());\n    } else {\n      BigInteger bigInteger = value.toJavaBigDecimal().unscaledValue();\n      setByteArray(bigInteger.toByteArray());\n    }\n  }",
    "comment": "Sets the `Decimal` `value` with the precision for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaMulticlassClassificationMetricsExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf conf = new SparkConf().setAppName(\"Multi class Classification Metrics Example\");\n    SparkContext sc = new SparkContext(conf);\n    String path = \"data/mllib/sample_multiclass_classification_data.txt\";\n    JavaRDD<LabeledPoint> data = MLUtils.loadLibSVMFile(sc, path).toJavaRDD();\n\n    JavaRDD<LabeledPoint>[] splits = data.randomSplit(new double[]{0.6, 0.4}, 11L);\n\n    System.out.format(\"Weighted precision = %f\\n\", metrics.weightedPrecision());\n    System.out.format(\"Weighted recall = %f\\n\", metrics.weightedRecall());\n    System.out.format(\"Weighted F1 score = %f\\n\", metrics.weightedFMeasure());\n    System.out.format(\"Weighted false positive rate = %f\\n\", metrics.weightedFalsePositiveRate());\n\n    model.save(sc, \"target/tmp/LogisticRegressionModel\");\n    LogisticRegressionModel sameModel = LogisticRegressionModel.load(sc,\n      \"target/tmp/LogisticRegressionModel\");\n\n    sc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nSplit initial RDD into two... [60% training data, 40% testing data].\nWeighted stats\nSave and load model\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/MutableURLClassLoader.java",
    "type": "method",
    "name": "MutableURLClassLoader",
    "code": "public MutableURLClassLoader(URL[] urls, ClassLoader parent) {\n    super(urls, parent);\n  }",
    "comment": "URL class loader that exposes the `addURL` method in URLClassLoader."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "a",
    "code": "default MessageBuilder a(char[] value) {\n        return append(String.valueOf(value));\n    }",
    "comment": "Append content to the message buffer.\n\n@param value the content to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/reporting/legacy/xml/LegacyXmlReportGeneratingListenerTests.java",
    "type": "method",
    "name": "DemoHierarchicalContainerDescriptor",
    "code": "uniqueId -> new DemoHierarchicalContainerDescriptor(uniqueId, \"failingContainer\", null, null) {\n\t\t\t}, \"child\");",
    "comment": "Tests for {@link LegacyXmlReportGeneratingListener}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "fail",
    "code": "public static void fail(String message) {\n        if (message == null) {\n            throw new AssertionFailedError();\n        }\n        throw new AssertionFailedError(message);\n    }",
    "comment": "Fails a test with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertSame",
    "code": "public static void assertSame(Object expected, Object actual, String message) {\n\t\tAssertSame.assertSame(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that the {@code expected} object and the {@code actual} object\nare the same object.\n<p>This method should only be used to assert <em>identity</em> between objects.\nTo assert <em>equality</em> between two objects or two primitive values,\nuse one of the {@code assertEquals(...)} methods instead &mdash; for example,\nuse {@code assertEquals(999, 999)} instead of {@code assertSame(999, 999)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testBagSubtract",
    "code": "public void testBagSubtract() {\n        IMoney expected = MoneyBag.create(new Money(-2, \"CHF\"), new Money(-14, \"USD\"));\n        assertEquals(expected, fMB1.subtract(fMB2));\n    }",
    "comment": "{[12 CHF][7 USD]} - {[14 CHF][21 USD] == {[-2 CHF][-14 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "compareTo",
    "code": "public int compareTo(@Nonnull final UTF8String other) {\n    if (SparkEnvUtils$.MODULE$.isTesting()) {\n      throw new UnsupportedOperationException(\n        \"compareTo should not be used in spark code base. Use binaryCompare or semanticCompare.\");\n    } else {\n      return binaryCompare(other);\n    }\n  }",
    "comment": "Implementation of Comparable interface. This method is kept for backwards compatibility.\nIt should not be used in spark code base, given that string comparison requires passing\ncollation id. Either explicitly use `binaryCompare` or use `semanticCompare`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantBuilder.java",
    "type": "method",
    "name": "valueWithoutMetadata",
    "code": "public byte[] valueWithoutMetadata() {\n    return Arrays.copyOfRange(writeBuffer, 0, writePos);\n  }",
    "comment": "Return the variant value only, without metadata.\nUsed in shredding to produce a final value, where all shredded values refer to a common\nmetadata. It is expected to be called instead of `result()`, although it is valid to call both\nmethods, in any order."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/DefaultNodeTest.java",
    "type": "method",
    "name": "testAsString",
    "code": "void testAsString() {\n        InternalSession session = Mockito.mock(InternalSession.class);\n\n        DefaultArtifact artifact = new DefaultArtifact(\"org.example:myapp:1.0\");\n        Dependency dependency = new Dependency(artifact, \"compile\");\n        DefaultDependencyNode node = new DefaultDependencyNode(dependency);\n\n        DefaultNode defaultNode = new DefaultNode(session, node, false);\n        assertEquals(\"org.example:myapp:jar:1.0:compile\", defaultNode.asString());\n\n        node.setData(DependencyManagerUtils.NODE_DATA_PREMANAGED_VERSION, \"0.9\");\n        node.setManagedBits(DependencyNode.MANAGED_VERSION);\n        defaultNode = new DefaultNode(session, node, true);\n        assertEquals(\"org.example:myapp:jar:1.0:compile (version managed from 0.9)\", defaultNode.asString());\n\n        node.setData(DependencyManagerUtils.NODE_DATA_PREMANAGED_SCOPE, \"runtime\");\n        node.setManagedBits(DependencyNode.MANAGED_VERSION | DependencyNode.MANAGED_SCOPE);\n        defaultNode = new DefaultNode(session, node, true);\n        assertEquals(\n                \"org.example:myapp:jar:1.0:compile (version managed from 0.9; scope managed from runtime)\",\n                defaultNode.asString());\n\n        DefaultDependencyNode winner =\n                new DefaultDependencyNode(new Dependency(new DefaultArtifact(\"org.example:myapp:2.0\"), \"compile\"));\n        node.setData(ConflictResolver.NODE_DATA_WINNER, winner);\n        node.setManagedBits(0);\n        defaultNode = new DefaultNode(session, node, true);\n        assertEquals(\"(org.example:myapp:jar:1.0:compile - omitted for conflict with 2.0)\", defaultNode.asString());\n    }",
    "comment": "Create a basic dependency node\nTest non-verbose mode\nTest verbose mode with managed version\nTest verbose mode with managed scope\nTest verbose mode with conflict resolution"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassExtension.java",
    "type": "method",
    "name": "supportsClassTemplate",
    "code": "public boolean supportsClassTemplate(ExtensionContext extensionContext) {\n\t\treturn validateAndStoreClassContext(extensionContext);\n\t}",
    "comment": "Should never be called (see comment above)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createStructType",
    "code": "public static StructType createStructType(StructField[] fields) {\n    if (fields == null) {\n      throw new IllegalArgumentException(\"fields should not be null.\");\n    }\n    Set<String> distinctNames = new HashSet<>();\n    for (StructField field : fields) {\n      if (field == null) {\n        throw new IllegalArgumentException(\n          \"fields should not contain any null.\");\n      }\n\n      distinctNames.add(field.name());\n    }\n    if (distinctNames.size() != fields.length) {\n      throw new IllegalArgumentException(\"fields should have distinct names.\");\n    }\n\n    return StructType$.MODULE$.apply(fields);\n  }",
    "comment": "Creates a StructType with the given StructField array ({@code fields})."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/MonotonicClock.java",
    "type": "method",
    "name": "MonotonicClock",
    "code": "private MonotonicClock() {\n        this.startNanos = System.nanoTime();\n        this.startInstant = Clock.systemUTC().instant();\n    }",
    "comment": "Private constructor to enforce singleton pattern.\nInitializes the clock with the current system time and nanoTime."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/buffer/NioManagedBuffer.java",
    "type": "method",
    "name": "NioManagedBuffer",
    "code": "public NioManagedBuffer(ByteBuffer buf) {\n    this.buf = buf;\n  }",
    "comment": "A {@link ManagedBuffer} backed by {@link ByteBuffer}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java",
    "type": "method",
    "name": "doMain",
    "code": "public static int doMain(String[] args, ClassWorld classWorld) {\n        MavenCli cli = new MavenCli();\n        return cli.doMain(new CliRequest(args, classWorld));\n    }",
    "comment": "TODO need to externalize CliRequest"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/AsynchronousHealthCheckerTest.java",
    "type": "method",
    "name": "whenShutdownExecutorDoesNotTerminateAfterCanceling_LogsErrorMessage",
    "code": "void whenShutdownExecutorDoesNotTerminateAfterCanceling_LogsErrorMessage() {\n    // Given\n    healthChecker.shutdown(); // To trigger the scenario\n\n    // When/Then\n    boolean containsMessage = doesLogContainMessage(healthChecker::shutdown);\n    if (!containsMessage) {\n      List<ch.qos.logback.classic.spi.ILoggingEvent> events = listAppender.list;\n      LOGGER.info(\"Logged events:\");\n      for (ch.qos.logback.classic.spi.ILoggingEvent event : events) {\n        LOGGER.info(event.getMessage());\n      }\n    }\n    assertTrue(containsMessage, \"Expected log message not found\");\n  }",
    "comment": "Tests that the {@link AsynchronousHealthChecker#shutdown()} method logs an error message when\nthe executor does not terminate after attempting to cancel tasks."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/test/java/org/apache/maven/api/services/RequestImplementationTest.java",
    "type": "method",
    "name": "testArtifactResolverRequestEquality",
    "code": "void testArtifactResolverRequestEquality() {\n        Session session = mock(Session.class);\n        ArtifactCoordinates coords1 = mock(ArtifactCoordinates.class);\n        ArtifactCoordinates coords2 = mock(ArtifactCoordinates.class);\n        RemoteRepository repo1 = mock(RemoteRepository.class);\n        RemoteRepository repo2 = mock(RemoteRepository.class);\n\n        List<RemoteRepository> repositories1 = Arrays.asList(repo1, repo2);\n        List<RemoteRepository> repositories2 = Arrays.asList(repo1, repo2);\n\n        ArtifactResolverRequest.ArtifactResolverRequestBuilder builder = ArtifactResolverRequest.builder();\n\n        ArtifactResolverRequest request1 = builder.session(session)\n                .coordinates(Arrays.asList(coords1, coords2))\n                .repositories(repositories1)\n                .build();\n\n        ArtifactResolverRequest request2 = builder.session(session)\n                .coordinates(Arrays.asList(coords1, coords2))\n                .repositories(repositories2)\n                .build();\n\n        ArtifactResolverRequest request3 = builder.session(session)\n                .coordinates(Arrays.asList(coords2, coords1)) // Different order\n                .repositories(repositories1)\n                .build();\n\n        assertEquals(request1, request2);\n        assertEquals(request1.hashCode(), request2.hashCode());\n        assertNotEquals(request1, request3);\n\n        String toString = request1.toString();\n        assertTrue(toString.contains(\"coordinates=\"));\n        assertTrue(toString.contains(\"repositories=\"));\n    }",
    "comment": "Test equals and hashCode\nTest toString"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Double> create(long[] shape, DoubleBuffer data) {\n    Tensor<Double> t = allocateForBuffer(DataType.DOUBLE, shape, data.remaining());\n    t.buffer().asDoubleBuffer().put(data);\n    return t;\n  }",
    "comment": "Create a {@link Double} Tensor with data from the given buffer.\n\n<p>Creates a Tensor with the given shape by copying elements from the buffer (starting from its\ncurrent position) into the tensor. For example, if {@code shape = {2,3} } (which represents a\n2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "prefixedWith",
    "code": "public Builder prefixedWith(String prefix) {\n            this.prefix = prefix;\n            return this;\n        }",
    "comment": "Prefix all metric names with the given string.\n\n@param prefix the prefix for all metric names\n@return {@code this}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "doesNotContainWhitespace",
    "code": "public static boolean doesNotContainWhitespace(String str) {\n\t\treturn !containsWhitespace(str);\n\t}",
    "comment": "Determine if the supplied {@link String} does not contain any whitespace\ncharacters.\n\n@param str the string to check; may be {@code null}\n@return {@code true} if the string does not contain whitespace\n@see #containsWhitespace(String)\n@see #containsIsoControlCharacter(String)\n@see Character#isWhitespace(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/InProcessAppHandle.java",
    "type": "method",
    "name": "kill",
    "code": "public synchronized void kill() {\n    if (!isDisposed()) {\n      LOG.warning(\"kill() may leave the underlying app running in in-process mode.\");\n      setState(State.KILLED);\n      disconnect();\n\n      if (app != null) {\n        app.interrupt();\n      }\n    }\n  }",
    "comment": "Interrupt the thread. This is not guaranteed to kill the app, though."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/FetchOrientation.java",
    "type": "method",
    "name": "getFetchOrientation",
    "code": "public static FetchOrientation getFetchOrientation(TFetchOrientation tFetchOrientation) {\n    for (FetchOrientation fetchOrientation : values()) {\n      if (tFetchOrientation.equals(fetchOrientation.toTFetchOrientation())) {\n        return fetchOrientation;\n      }\n    }\n    return FETCH_NEXT;\n  }",
    "comment": "TODO: Should this really default to FETCH_NEXT?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultDependencyManagementImporter.java",
    "type": "method",
    "name": "updateWithImportedFrom",
    "code": "static Dependency updateWithImportedFrom(Dependency dependency, DependencyManagement bom) {\n        InputLocation dependencyLocation = dependency.getLocation(\"\");\n        InputLocation bomLocation = bom.getLocation(\"\");\n\n        if (dependencyLocation == null || bomLocation == null) {\n            return dependency;\n        }\n\n        InputSource dependencySource = dependencyLocation.getSource();\n        InputSource bomSource = bomLocation.getSource();\n\n        if (dependencySource == null\n                || bomSource == null\n                || Objects.equals(dependencySource.getModelId(), bomSource.getModelId())) {\n            return Dependency.newBuilder(dependency, true)\n                    .importedFrom(bomLocation)\n                    .build();\n        }\n\n        while (dependencySource.getImportedFrom() != null) {\n            InputLocation importedFrom = dependencySource.getImportedFrom();\n\n            if (Objects.equals(importedFrom.getSource().getModelId(), bomSource.getModelId())) {\n                return dependency;\n            }\n\n            dependencySource = importedFrom.getSource();\n        }\n\n        return Dependency.newBuilder(dependency, true)\n                .importedFrom(new InputLocation(bomLocation))\n                .build();\n    }",
    "comment": "We are only interested in the InputSource, so the location of the <dependency> element is sufficient\nIf the dependency and BOM have the same source, it means we found the root where the dependency is declared.\nStop if the BOM is already in the list, no update necessary\nWe modify the input location that is used for the whole file.\nThis is likely correct because the POM hierarchy applies to the whole POM, not just one dependency."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(BooleanSupplier booleanSupplier) {\n\t\tAssertFalse.assertFalse(booleanSupplier);\n\t}",
    "comment": "<em>Assert</em> that the boolean condition supplied by {@code booleanSupplier} is {@code false}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "info",
    "code": "default MessageBuilder info(Object message) {\n        return style(\".\" + Constants.MAVEN_STYLE_INFO_NAME + \":-\" + Constants.MAVEN_STYLE_INFO_DEFAULT, message);\n    }",
    "comment": "Append message content in info style.\nBy default, bold blue\n\n@param message the message to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectMethod",
    "code": "public static MethodSelector selectMethod(String className, String methodName, Class<?>... parameterTypes) {\n\t\tPreconditions.notBlank(className, \"Class name must not be null or blank\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\t\tPreconditions.notNull(parameterTypes, \"Parameter types array must not be null\");\n\t\tPreconditions.containsNoNullElements(parameterTypes, \"Parameter types array must not contain null elements\");\n\t\treturn new MethodSelector(null, className, methodName, parameterTypes);\n\t}",
    "comment": "Create a {@code MethodSelector} for the supplied class name, method name,\nand parameter types.\n\n@param className the fully qualified name of the class in which the method\nis declared, or a subclass thereof; never {@code null} or blank\n@param methodName the name of the method to select; never {@code null} or blank\n@param parameterTypes the formal parameter types of the method; never\n{@code null} though potentially empty if the method does not declare parameters\n@since 1.10\n@see MethodSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultExecutionEventCatapult.java",
    "type": "method",
    "name": "fire",
    "code": "public void fire(ExecutionEvent.Type eventType, MavenSession session, MojoExecution mojoExecution) {\n        fire(eventType, session, mojoExecution, null);\n    }",
    "comment": "Assists in firing execution events. <strong>Warning:</strong> This is an internal utility class that is only public\nfor technical reasons, it is not part of the public API. In particular, this class can be changed or deleted without\nprior notice."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java",
    "type": "method",
    "name": "validate",
    "code": "public void validate(DiscoveryIssueReporter reporter) {\n\t\tValidatable.reportAndClear(this.methodInfo.discoveryIssues, reporter);\n\t\tDisplayNameUtils.validateAnnotation(getTestMethod(), //\n\t\t\t() -> String.format(\"method '%s'\", getTestMethod().toGenericString()), //\n\t\t\t() -> MethodSource.from(getTestMethod()), //\n\t\t\treporter);\n\t}",
    "comment": "--- Validatable ---------------------------------------------------------\nUse _declaring_ class here because that's where the `@DisplayName` annotation is declared"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/role-object/src/main/java/com/iluwatar/roleobject/CustomerCore.java",
    "type": "method",
    "name": "CustomerCore",
    "code": "public CustomerCore() {\n    roles = new HashMap<>();\n  }",
    "comment": "Core class to store different customer roles.\n\n@see CustomerRole Note: not thread safe"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ModuleUtils.java",
    "type": "method",
    "name": "getModuleName",
    "code": "public static Optional<String> getModuleName(Class<?> type) {\n\t\treturn Optional.empty();\n\t}",
    "comment": "Return the name of the module that the class or interface is a member of.\n\n@param type class or interface to analyze\n@return the module name; never {@code null} but potentially empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/ArrayExpressionUtils.java",
    "type": "method",
    "name": "if",
    "code": "if (o1 == null && o2 == null) {\n      return 0;\n    } else if (o1 == null) {\n      return -1;\n    } else if (o2 == null) {\n      return 1;\n    }",
    "comment": "comparator\nBoolean ascending nullable comparator"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/sharding/src/main/java/com/iluwatar/sharding/HashShardManager.java",
    "type": "method",
    "name": "storeData",
    "code": "public int storeData(Data data) {\n    var shardId = allocateShard(data);\n    var shard = shardMap.get(shardId);\n    shard.storeData(data);\n    LOGGER.info(data + \" is stored in Shard \" + shardId);\n    return shardId;\n  }",
    "comment": "ShardManager with hash strategy. The purpose of this strategy is to reduce the chance of\nhot-spots in the data. It aims to distribute the data across the shards in a way that achieves a\nbalance between the size of each shard and the average load that each shard will encounter."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/Vehicle.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n    return \"Vehicle{\"\n        + \"id=\"\n        + id\n        + \", make='\"\n        + make\n        + '\\''\n        + \", model='\"\n        + model\n        + '\\''\n        + \", year=\"\n        + year\n        + '}';\n  }",
    "comment": "Returns a string representation of the vehicle.\n\n@return a string with the vehicle's details"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/test/java/org/apache/maven/api/MonotonicClockTest.java",
    "type": "method",
    "name": "testElapsedTimeConsistency",
    "code": "void testElapsedTimeConsistency() {\n            MonotonicClock clock = MonotonicClock.get();\n            Instant now = clock.instant();\n            Duration elapsed = clock.elapsedTime();\n            Duration calculated = Duration.between(clock.startInstant(), now);\n\n            assertTrue(\n                    Math.abs(elapsed.toMillis() - calculated.toMillis()) <= 1,\n                    \"Elapsed time should match calculated duration between start and now\");\n        }",
    "comment": "Allow for small timing differences (1ms) due to execution time between measurements"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/Execution.java",
    "type": "method",
    "name": "setConfiguration",
    "code": "public void setConfiguration(Object configuration) {\n        this.configuration = configuration;\n    } // -- void setConfiguration( Object )",
    "comment": "Set configuration to pass to the goals.\n\n@param configuration a configuration object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/metadata/DefaultClasspathTransformation.java",
    "type": "method",
    "name": "ClasspathGraphVisitor",
    "code": "protected ClasspathGraphVisitor(MetadataGraph cleanGraph, ClasspathContainer cpc) {\n            this.cpc = cpc;\n            this.graph = cleanGraph;\n\n            visited = new ArrayList<>(cleanGraph.getVertices().size());\n        }",
    "comment": "Helper class to traverse graph. Required to make the containing method thread-safe\nand yet use class level data to lessen stack usage in recursion"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/Phase.java",
    "type": "method",
    "name": "getId",
    "code": "public String getId() {\n        return this.id;\n    } // -- String getId()",
    "comment": "Get the ID of this phase, e.g.,\n<code>generate-sources</code>.\n\n@return String"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Graph.java",
    "type": "method",
    "name": "buildSubgraph",
    "code": "public Output<?>[] addGradients(Output<?> y, Output<?>[] x) {\n    return addGradients(null, new Output<?>[] {y}, x, null);\n\n  public interface WhileSubgraphBuilder {\n    public void buildSubgraph(Graph g, Output<?>[] inputs, Output<?>[] outputs);\n  }\n\n  // called by while loop code in graph_jni.cc to construct conditional/body subgraphs\n  private static long[] buildSubgraph(\n      WhileSubgraphBuilder subgraphBuilder,\n      long subgraphHandle,\n      long[] inputHandles,\n      int[] inputIndices,\n      long[] outputHandles,\n      int[] outputIndices) {\n    Graph subgraph = new Graph(subgraphHandle);\n\n    int ninputs = inputHandles.length;\n    int noutputs = outputHandles.length;\n    Output<?>[] inputs = new Output<?>[ninputs];\n    Output<?>[] outputs = new Output<?>[noutputs];\n    long[] outputHandlesAndIndices = new long[noutputs * 2];\n\n    synchronized (subgraph.nativeHandleLock) {\n      try (Reference ref = subgraph.ref()) {\n\n        for (int i = 0; i < ninputs; i++) {\n          Operation op = new GraphOperation(subgraph, inputHandles[i]);\n          inputs[i] = op.output(inputIndices[i]);\n        }\n\n        for (int i = 0; i < noutputs; i++) {\n          Operation op = new GraphOperation(subgraph, outputHandles[i]);\n          outputs[i] = op.output(outputIndices[i]);\n        }\n\n        subgraphBuilder.buildSubgraph(subgraph, inputs, outputs);\n\n        for (int i = 0, j = noutputs; i < noutputs; i++, j++) {\n          outputHandlesAndIndices[i] = outputs[i].getUnsafeNativeHandle();\n          outputHandlesAndIndices[j] = (long) outputs[i].index();\n        }\n      }\n      return outputHandlesAndIndices;\n    }\n  }\n\n  public Output<?>[] whileLoop(\n      Output<?>[] inputs,\n      WhileSubgraphBuilder cgBuilder,\n      WhileSubgraphBuilder bgBuilder,\n      String name) {\n    int ninputs = inputs.length;\n    long[] inputHandles = new long[ninputs];\n    int[] inputIndices = new int[ninputs];\n    Output<?>[] outputs = new Output<?>[ninputs];\n\n    synchronized (nativeHandleLock) {\n      try (Reference ref = ref()) {\n\n        for (int i = 0; i < ninputs; i++) {\n          inputHandles[i] = inputs[i].getUnsafeNativeHandle();\n          inputIndices[i] = inputs[i].index();\n        }\n\n        long[] outputHandlesAndIndices =\n            whileLoop(nativeHandle, inputHandles, inputIndices, name, cgBuilder, bgBuilder);\n\n        for (int i = 0, j = ninputs; i < ninputs; ++i, ++j) {\n          Operation op = new GraphOperation(this, outputHandlesAndIndices[i]);\n          outputs[i] = op.output((int) outputHandlesAndIndices[j]);\n        }\n      }\n      return outputs;\n    }\n  }\n\n  private final Object nativeHandleLock = new Object();\n  private long nativeHandle;\n  private int refcount = 0;\n\n  // Related native objects (such as the TF_Operation object backing an Operation instance)\n  // have a validity tied to that of the Graph. The handles to those native objects are not\n  // valid after Graph.close() has been invoked.\n  //\n  // Instances of the Reference class should be used to ensure the Graph has not been closed\n  // while dependent handles are in use.\n  class Reference implements AutoCloseable {\n    private Reference() {\n      synchronized (Graph.this.nativeHandleLock) {\n        active = Graph.this.nativeHandle != 0;\n        if (!active) {\n          throw new IllegalStateException(\"close() has been called on the Graph\");\n        }\n        active = true;\n        Graph.this.refcount++;\n      }\n    }\n\n    @Override\n    public void close() {\n      synchronized (Graph.this.nativeHandleLock) {\n        if (!active) {\n          return;\n        }\n        active = false;\n        if (--Graph.this.refcount == 0) {\n          Graph.this.nativeHandleLock.notifyAll();\n        }\n      }\n    }\n\n    public long nativeHandle() {\n      synchronized (Graph.this.nativeHandleLock) {\n        return active ? Graph.this.nativeHandle : 0;\n      }\n    }\n\n    private boolean active;\n  }\n\n  Reference ref() {\n    return new Reference();\n  }\n\n  private static final class OperationIterator implements Iterator<Operation> {\n\n    OperationIterator(Graph g) {\n      this.graph = g;\n      this.operation = null;\n      this.position = 0;\n      this.advance();\n    }\n\n    private final void advance() {\n      Graph.Reference reference = this.graph.ref();\n\n      this.operation = null;\n\n      try {\n        long[] nativeReturn = nextOperation(reference.nativeHandle(), this.position);\n\n        if ((nativeReturn != null) && (nativeReturn[0] != 0)) {\n          this.operation = new GraphOperation(this.graph, nativeReturn[0]);\n          this.position = (int) nativeReturn[1];\n        }\n      } finally {\n        reference.close();\n      }\n    }\n\n    @Override\n    public boolean hasNext() {\n      return (this.operation != null);\n    }\n\n    @Override\n    public Operation next() {\n      Operation rhett = this.operation;\n      this.advance();\n      return rhett;\n    }\n\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException(\"remove() is unsupported.\");\n    }\n\n    private final Graph graph;\n    private Operation operation;\n    private int position;\n  }\n\n  private static native long allocate();\n\n  private static native void delete(long handle);\n\n  private static native long operation(long handle, String name);\n\n  // This method returns the Operation native handle at index 0 and the new value for pos at index 1\n  // (see TF_GraphNextOperation)\n  private static native long[] nextOperation(long handle, int position);\n\n  private static native void importGraphDef(long handle, byte[] graphDef, String prefix)\n      throws IllegalArgumentException;\n\n  private static native byte[] toGraphDef(long handle);\n\n  private static native long[] addGradients(\n      long handle,\n      String prefix,\n      long[] inputHandles,\n      int[] inputIndices,\n      long[] outputHandles,\n      int[] outputIndices,\n      long[] gradInputHandles,\n      int[] gradInputIndices);\n\n  private static native long[] whileLoop(\n      long handle,\n      long[] inputHandles,\n      int[] inputIndices,\n      String name,\n      WhileSubgraphBuilder condGraphBuilder,\n      WhileSubgraphBuilder bodyGraphBuilder);\n\n  static {\n    TensorFlow.init();\n  }\n}",
    "comment": "Builds a while loop.\n\n@param inputs the loop inputs\n@param cgBuilder WhileSubgraphBuilder to build the conditional subgraph\n@param bgBuilder WhileSubgraphBuilder to build the body subgraph\n@param name name for the loop\n@return list of loop outputs, of the same length as {@code inputs}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/ReflectionValueExtractor.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n            return idx < expression.length() ? expression.substring(idx) : \"<EOF>\";\n        }",
    "comment": "to make tokenizer look pretty in debugger"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Character expected, Character actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "createExecutions",
    "code": "private static List<Execution> createExecutions(List<Event> events) {\n\t\tList<Execution> executions = new ArrayList<>();\n\t\tMap<TestDescriptor, Instant> executionStarts = new HashMap<>();\n\n\t\tfor (Event event : events) {\n\t\t\tswitch (event.getType()) {\n\t\t\t\tcase STARTED: {\n\t\t\t\t\texecutionStarts.put(event.getTestDescriptor(), event.getTimestamp());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SKIPPED: {\n\t\t\t\t\t// Based on the Javadoc for EngineExecutionListener.executionSkipped(...),\n\t\t\t\t\t// a skipped descriptor must never be reported as started or finished,\n\t\t\t\t\t// but just in case a TestEngine does not adhere to that contract, we\n\t\t\t\t\t// make an attempt to remove any tracked \"started\" event.\n\t\t\t\t\texecutionStarts.remove(event.getTestDescriptor());\n\n\t\t\t\t\t// Use the same timestamp for both the start and end Instant values.\n\t\t\t\t\tInstant timestamp = event.getTimestamp();\n\n\t\t\t\t\tExecution skippedEvent = Execution.skipped(event.getTestDescriptor(), timestamp, timestamp,\n\t\t\t\t\t\tevent.getRequiredPayload(String.class));\n\t\t\t\t\texecutions.add(skippedEvent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase FINISHED: {\n\t\t\t\t\tInstant startInstant = executionStarts.remove(event.getTestDescriptor());\n\t\t\t\t\tInstant endInstant = event.getTimestamp();\n\n\t\t\t\t\t// If \"started\" events have already been filtered out, it is no\n\t\t\t\t\t// longer possible to create a legitimate Execution for the current\n\t\t\t\t\t// descriptor. So we effectively ignore it in that case.\n\t\t\t\t\tif (startInstant != null) {\n\t\t\t\t\t\tExecution finishedEvent = Execution.finished(event.getTestDescriptor(), startInstant,\n\t\t\t\t\t\t\tendInstant, event.getRequiredPayload(TestExecutionResult.class));\n\t\t\t\t\t\texecutions.add(finishedEvent);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\t// Ignore other events\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn executions;\n\t}",
    "comment": "Create executions from the supplied list of events."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "writeToMemory",
    "code": "public void writeToMemory(Object target, long targetOffset) {\n    Platform.copyMemory(baseObject, baseOffset, target, targetOffset, sizeInBytes);\n  }",
    "comment": "Writes the content of this row into a memory address, identified by an object and an offset.\nThe target memory address must already been allocated, and have enough space to hold all the\nbytes in this string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/deployer/DefaultArtifactDeployer.java",
    "type": "method",
    "name": "if",
    "code": "for (ArtifactMetadata metadata : artifact.getMetadataList()) {\n            if (metadata instanceof ProjectArtifactMetadata projectArtifactMetadata) {\n                org.eclipse.aether.artifact.Artifact pomArtifact = new SubArtifact(mainArtifact, \"\", \"pom\");\n                pomArtifact = pomArtifact.setFile(projectArtifactMetadata.getFile());\n                request.addArtifact(pomArtifact);\n            } else if (metadata instanceof SnapshotArtifactRepositoryMetadata\n                    || metadata instanceof ArtifactRepositoryMetadata) {\n            } else {\n                request.addMetadata(new MetadataBridge(metadata));\n            }\n        }",
    "comment": "eaten, handled by repo system"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/orc/OrcColumnarBatchReader.java",
    "type": "method",
    "name": "OrcColumnarBatchReader",
    "code": "public OrcColumnarBatchReader(int capacity, MemoryMode memoryMode) {\n    this.capacity = capacity;\n    this.memoryMode = memoryMode;\n  }",
    "comment": "The column IDs of the physical ORC file schema which are required by this reader.\n-1 means this required column is partition column, or it doesn't exist in the ORC file.\nIdeally partition column should never appear in the physical file, and should only appear\nin the directory name. However, Spark allows partition columns inside physical file,\nbut Spark will discard the values from the file, and use the partition value got from\ndirectory name. The column order will be reserved though."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/ParentRunner.java",
    "type": "method",
    "name": "isIgnored",
    "code": "protected boolean isIgnored(T child) {\n        return false;\n    }",
    "comment": "Evaluates whether a child is ignored. The default implementation always\nreturns <code>false</code>.\n\n<p>{@link BlockJUnit4ClassRunner}, for example, overrides this method to\nfilter tests based on the {@link Ignore} annotation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/BenchmarkReport.java",
    "type": "method",
    "name": "export",
    "code": "void export() {\n    if (result == BenchmarkResultType.UNKNOWN) {\n      computeBenchmarkReport();\n    }\n    for (ReportWriter writer : writers) {\n      writer.writeReport(this);\n    }\n  }",
    "comment": "The result is not computed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, double actual) {\n        assertEquals(null, expected, actual);\n    }",
    "comment": "@deprecated Use\n<code>assertEquals(double expected, double actual, double delta)</code>\ninstead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "put",
    "code": "public String put(String key, List<String> commentLines, List<String> valueLines) {\n        commentLines = new ArrayList<>(commentLines);\n        valueLines = new ArrayList<>(valueLines);\n        String escapedKey = escapeKey(key);\n        StringBuilder sb = new StringBuilder();\n        if (valueLines.isEmpty()) {\n            valueLines.add(escapedKey + \"=\");\n            sb.append(escapedKey).append(\"=\");\n        } else {\n            String val0 = valueLines.get(0);\n            String rv0 = typed ? val0 : escapeJava(val0);\n            if (!val0.trim().startsWith(escapedKey)) {\n                valueLines.set(0, escapedKey + \" = \" + rv0 /*+ (0 < lastLine? \"\\\\\": \"\")*/);\n                sb.append(escapedKey).append(\" = \").append(rv0);\n            } else {\n                valueLines.set(0, rv0 /*+ (0 < lastLine? \"\\\\\": \"\")*/);\n                sb.append(rv0);\n            }\n        }\n        for (int i = 1; i < valueLines.size(); i++) {\n            String val = valueLines.get(i);\n            valueLines.set(i, typed ? val : escapeJava(val) /*+ (i < lastLine? \"\\\\\": \"\")*/);\n            while (!val.isEmpty() && Character.isWhitespace(val.charAt(0))) {\n                val = val.substring(1);\n            }\n            sb.append(val);\n        }\n        String[] property = PropertiesReader.parseProperty(sb.toString());\n        this.layout.put(key, new Layout(commentLines, valueLines));\n        return storage.put(key, property[1]);\n    }",
    "comment": "int lastLine = valueLines.size() - 1;"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/validator/PublicClassValidator.java",
    "type": "method",
    "name": "validateTestClass",
    "code": "public List<Exception> validateTestClass(TestClass testClass) {\n        if (testClass.isPublic()) {\n            return NO_VALIDATION_ERRORS;\n        } else {\n            return singletonList(new Exception(\"The class \"\n                    + testClass.getName() + \" is not public.\"));\n        }\n    }",
    "comment": "Validate that the specified {@link TestClass} is public.\n\n@param testClass the {@link TestClass} that is validated.\n@return an empty list if the class is public or a list with a single\nexception otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/DefaultLifecycles.java",
    "type": "method",
    "name": "get",
    "code": "public Lifecycle get(String phase) {\n        return getPhaseToLifecycleMap().get(phase);\n    }",
    "comment": "Get lifecycle based on phase\n\n@param phase\n@return"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/ByteArray.java",
    "type": "method",
    "name": "rpad",
    "code": "public static byte[] rpad(byte[] bytes, int len, byte[] pad) {\n    if (bytes == null || pad == null) return null;\n    if (len == 0) return EMPTY_BYTE;\n    if (pad.length == 0) return padWithEmptyPattern(bytes, len);\n    final byte[] result = new byte[len];\n    Platform.copyMemory(\n      bytes, Platform.BYTE_ARRAY_OFFSET,\n      result, Platform.BYTE_ARRAY_OFFSET,\n      Math.min(len, bytes.length));\n    if (bytes.length < len) {\n      fillWithPattern(result, bytes.length, len, pad);\n    }\n    return result;\n  }",
    "comment": "Right-pads the input byte sequence using the provided padding pattern.\nIn the special case that the padding pattern is empty, the resulting byte sequence\ncontains the first `len` bytes of the input if they exist, or is a copy of the input\nbyte sequence otherwise.\nFor padding patterns with positive byte length, the resulting byte sequence's byte length is\nequal to `len`. If the input byte sequence is not less than `len` bytes, its first `len` bytes\nare returned. Otherwise, the remaining missing bytes are filled in with the provided pattern.\nIf the input length is 0, return the empty byte sequence.\nThe padding pattern is empty.\nThe general case.\n1. Copy the first `len` bytes of the input sequence into the output if they exist.\n2. If the input has less than `len` bytes, fill in the rest using the provided pattern."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-model/src/main/java/org/apache/maven/api/model/InputLocation.java",
    "type": "method",
    "name": "merge",
    "code": "public static InputLocation merge(InputLocation target, InputLocation source, boolean sourceDominant) {\n        if (source == null) {\n            return target;\n        } else if (target == null) {\n            return source;\n        }\n\n        Map<Object, InputLocation> locations;\n        Map<Object, InputLocation> sourceLocations = source.locations;\n        Map<Object, InputLocation> targetLocations = target.locations;\n        if (sourceLocations == null) {\n            locations = targetLocations;\n        } else if (targetLocations == null) {\n            locations = sourceLocations;\n        } else {\n            locations = new LinkedHashMap<>();\n            locations.putAll(sourceDominant ? targetLocations : sourceLocations);\n            locations.putAll(sourceDominant ? sourceLocations : targetLocations);\n        }\n\n        return new InputLocation(-1, -1, InputSource.merge(source.getSource(), target.getSource()), locations);\n    } // -- InputLocation merge( InputLocation, InputLocation, boolean )",
    "comment": "Merges the {@code source} location into the {@code target} location.\n\n@param target the target location\n@param source the source location\n@param sourceDominant the boolean indicating of {@code source} is dominant compared to {@code target}\n@return the merged location"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/RowLevelOperation.java",
    "type": "method",
    "name": "requiredMetadataAttributes",
    "code": "default NamedReference[] requiredMetadataAttributes() {\n    return new NamedReference[0];\n  }",
    "comment": "Returns metadata attributes that are required to perform this row-level operation.\n<p>\nData sources that can use this method to project metadata columns needed for writing\nthe data back (e.g. metadata columns for grouping data)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/ImageUtils.java",
    "type": "method",
    "name": "saveBitmap",
    "code": "public static void saveBitmap(final Bitmap bitmap, final String filename) {\n    final String root =\n        Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + \"tensorflow\";\n    LOGGER.i(\"Saving %dx%d bitmap to %s.\", bitmap.getWidth(), bitmap.getHeight(), root);\n    final File myDir = new File(root);\n\n    if (!myDir.mkdirs()) {\n      LOGGER.i(\"Make dir failed\");\n    }\n\n    final String fname = filename;\n    final File file = new File(myDir, fname);\n    if (file.exists()) {\n      file.delete();\n    }\n    try {\n      final FileOutputStream out = new FileOutputStream(file);\n      bitmap.compress(Bitmap.CompressFormat.PNG, 99, out);\n      out.flush();\n      out.close();\n    } catch (final Exception e) {\n      LOGGER.e(e, \"Exception!\");\n    }\n  }",
    "comment": "Saves a Bitmap object to disk for analysis.\n\n@param bitmap The bitmap to save.\n@param filename The location to save the bitmap to."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/rules/RuleMemberValidator.java",
    "type": "method",
    "name": "validate",
    "code": "public void validate(FrameworkMember<?> member, Class<? extends Annotation> annotation, List<Throwable> errors) {\n            if (!isRuleType(member)) {\n                errors.add(new ValidationError(member, annotation,\n                        \"must implement MethodRule or TestRule.\"));\n            }\n        }",
    "comment": "Requires the member is a field implementing {@link org.junit.rules.MethodRule} or {@link org.junit.rules.TestRule}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/InvalidArtifactRTException.java",
    "type": "method",
    "name": "InvalidArtifactRTException",
    "code": "public InvalidArtifactRTException(String groupId, String artifactId, String version, String type, String message) {\n        this.groupId = groupId;\n        this.artifactId = artifactId;\n        this.version = version;\n        this.type = type;\n        this.baseMessage = message;\n    }",
    "comment": "Exception thrown when the identity of an artifact can not be established,\ne.g. one of groupId, artifactId, version or type is null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/main/java/com/iluwatar/async/method/invocation/ThreadAsyncExecutor.java",
    "type": "method",
    "name": "setValue",
    "code": "void setValue(T value) {\n      this.value = value;\n      this.state = COMPLETED;\n      if (hasCallback()) {\n        callback.onComplete(value);\n      }\n      synchronized (lock) {\n        lock.notifyAll();\n      }\n    }",
    "comment": "Sets the value from successful execution and executes callback if available. Notifies any\nthread waiting for completion.\n\n@param value value of the evaluated task"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "cryptoConf",
    "code": "public Properties cryptoConf() {\n    return CryptoUtils.toCryptoConf(\"spark.network.crypto.config.\", conf.getAll());\n  }",
    "comment": "The commons-crypto configuration for the module."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "RemoveProperty",
    "code": "private RemoveProperty(String property) {\n      this.property = property;\n    }",
    "comment": "A TableChange to remove a table property.\n<p>\nIf the property does not exist, the change should succeed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SaslEncryption.java",
    "type": "method",
    "name": "count",
    "code": "public long count() {\n      return isByteBuf ? buf.readableBytes() : region.count();\n    }",
    "comment": "Returns the size of the original (unencrypted) message.\n\nThis makes assumptions about how netty treats FileRegion instances, because there's no way\nto know beforehand what will be the size of the encrypted message. Namely, it assumes\nthat netty will try to transfer data from this message while\n<code>transferred() < count()</code>. So these two methods return, technically, wrong data,\nbut netty doesn't know better."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "execute",
    "code": "public static EngineExecutionResults execute(TestEngine testEngine, EngineDiscoveryRequest discoveryRequest) {\n\t\tPreconditions.notNull(testEngine, \"TestEngine must not be null\");\n\t\tPreconditions.notNull(discoveryRequest, \"EngineDiscoveryRequest must not be null\");\n\n\t\tExecutionRecorder executionRecorder = new ExecutionRecorder();\n\t\texecuteDirectly(testEngine, discoveryRequest, executionRecorder);\n\t\treturn executionRecorder.getExecutionResults();\n\t}",
    "comment": "Execute tests for the given {@link EngineDiscoveryRequest} using the\nsupplied {@link TestEngine}.\n\n<p>Note that {@link org.junit.platform.launcher.LauncherDiscoveryRequest}\nfrom the {@code junit-platform-launcher} module is a subtype of\n{@code EngineDiscoveryRequest}. It is therefore quite convenient to make\nuse of the DSL provided in\n{@link org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder}\nto build an appropriate discovery request to supply to this method. As\nan alternative, consider using {@link #engine(TestEngine)} for a more fluent\nAPI.\n\n@param testEngine the {@code TestEngine} to use; must not be {@code null}\n@param discoveryRequest the {@code EngineDiscoveryRequest} to use; must\nnot be {@code null}\n@return the recorded {@code EngineExecutionResults}\n@throws PreconditionViolationException for invalid arguments\n@see #execute(TestEngine, LauncherDiscoveryRequest)\n@see #engine(String)\n@see #engine(TestEngine)\n@deprecated Please use {@link #execute(TestEngine, LauncherDiscoveryRequest)}\ninstead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/Result.java",
    "type": "method",
    "name": "addProblem",
    "code": "public static <T> Result<T> addProblem(Result<T> result, ModelProblem problem) {\n        return addProblems(result, singleton(problem));\n    }",
    "comment": "New result consisting of given result and new problem. Convenience for newResult(result.get(),\nconcat(result.getProblems(),problems)).\n\n@param result\n@param problem"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/eclipse/sisu/plexus/PlexusXmlBeanConverter.java",
    "type": "method",
    "name": "parseImplementation",
    "code": "private static String parseImplementation(final XmlPullParser parser) {\n        return parser.getAttributeValue(null, \"implementation\");\n    }",
    "comment": "Parses an XML element looking for the name of a custom implementation.\n\n@param parser The XML parser\n@return Name of the custom implementation; otherwise {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "checkHeaderComment",
    "code": "private int checkHeaderComment(List<String> commentLines) {\n        if (getHeader() == null && layout.isEmpty()) {\n            // This is the first comment. Search for blank lines.\n            int index = commentLines.size() - 1;\n            while (index >= 0 && !commentLines.get(index).isEmpty()) {\n                index--;\n            }\n            setHeader(new ArrayList<String>(commentLines.subList(0, index + 1)));\n            return index + 1;\n        } else {\n            return 0;\n        }\n    }",
    "comment": "Checks if parts of the passed in comment can be used as header comment.\nThis method checks whether a header comment can be defined (i.e. whether\nthis is the first comment in the loaded file). If this is the case, it is\nsearched for the lates blank line. This line will mark the end of the\nheader comment. The return value is the index of the first line in the\npassed in list, which does not belong to the header comment.\n\n@param commentLines the comment lines\n@return the index of the next line after the header comment"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "dataTypeOf",
    "code": "private static DataType dataTypeOf(Object o) {\n    Class<?> c = baseObjType(o);\n    return dataTypeFromClass(c);\n  }",
    "comment": "The default TensorFlow data type to which Java object o corresponds. Some Java objects\nrepresent more than one TensorFlow data type; for example, 'byte' can represent both {@code\nuint8} and {@code string}, with the latter being the default interpretation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestEngine.java",
    "type": "method",
    "name": "getArtifactId",
    "code": "default Optional<String> getArtifactId() {\n\t\tOptional<String> moduleName = ModuleUtils.getModuleName(getClass());\n\t\tif (moduleName.isPresent()) {\n\t\t\treturn moduleName;\n\t\t}\n\t\treturn PackageUtils.getAttribute(getClass(), Package::getImplementationTitle);\n\t}",
    "comment": "Get the <em>Artifact ID</em> of the JAR in which this test engine is packaged.\n\n<p>This information is used solely for debugging and reporting purposes.\n\n<p>The default implementation assumes the implementation title is equivalent\nto the artifact ID and therefore attempts to query the\n{@linkplain Package#getImplementationTitle() implementation title}\nfrom the package attributes for the {@link Package} in which the engine\nresides. Note that a package only has attributes if the information is\ndefined in the {@link java.util.jar.Manifest Manifest} of the JAR\ncontaining that package, and if the class loader created the\n{@link Package} instance with the attributes from the manifest.\n\n<p>If the implementation title cannot be queried from the package\nattributes, the default implementation returns an empty\n{@link Optional}.\n\n<p>Concrete test engine implementations may override this method in\norder to determine the artifact ID by some other means.\n\n@implNote Since JUnit Platform version 1.1 this default implementation\nreturns the \"module name\" stored in the module (modular jar on the\nmodule-path) of this test engine.\n\n@return an {@code Optional} containing the artifact ID; never\n{@code null} but potentially empty if the artifact ID is unknown\n@see Class#getPackage()\n@see Package#getImplementationTitle()\n@see #getGroupId()\n@see #getVersion()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java",
    "type": "method",
    "name": "builder",
    "code": "public static Builder builder() {\n        return new Builder();\n    }",
    "comment": "Returns a new builder for building an instance.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java",
    "type": "method",
    "name": "delete",
    "code": "private void delete(Path path) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfileOperations.delete(path);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchFileException ignore) {\n\t\t\t\t\t}\n\t\t\t\t\tcatch (DirectoryNotEmptyException exception) {\n\t\t\t\t\t\tfailures.put(path, exception);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException exception) {\n\t\t\t\t\t\tresetPermissionsAndTryToDeleteAgain(path, exception);\n\t\t\t\t\t}\n\t\t\t\t}",
    "comment": "ignore\nIOException includes `AccessDeniedException` thrown by non-readable or non-executable flags"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java",
    "type": "method",
    "name": "prune",
    "code": "public void prune() {\n\t\tsuper.prune();\n\t\tif (this.children.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tnew LinkedHashSet<>(this.children).forEach(child -> child.accept(TestDescriptor::prune));\n\t\tthis.children.forEach(child -> {\n\t\t\tif (child instanceof ClassTemplateInvocationTestDescriptor) {\n\t\t\t\tint index = ((ClassTemplateInvocationTestDescriptor) child).getIndex();\n\t\t\t\tthis.dynamicDescendantFilter.allowIndex(index - 1);\n\t\t\t\tthis.childrenPrototypesByIndex.put(index, child.getChildren());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.childrenPrototypes.add(child);\n\t\t\t}\n\t\t});\n\t\tthis.children.clear();\n\t}",
    "comment": "--- TestDescriptor ------------------------------------------------------\nCreate copy to avoid ConcurrentModificationException\nSecond iteration to avoid processing children that were pruned in the first iteration"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/Order.java",
    "type": "method",
    "name": "Order",
    "code": "public Order(final String id, final List<Cart> item) {\n    this.orderId = id;\n    this.items = item;\n    this.totalPrice = items.stream().mapToDouble(Cart::getTotalPrice).sum();\n  }",
    "comment": "Constructs an {@code Order} with the given order ID and list of cart items. The total price is\nbased on the individual item prices in the cart.\n\n@param id The unique identifier for the order.\n@param item The list of cart items included in the order."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java",
    "type": "method",
    "name": "prepare",
    "code": "public final JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {\n\t\tMutableExtensionRegistry registry = populateNewExtensionRegistryFromExtendWithAnnotation(\n\t\t\tcontext.getExtensionRegistry(), getTestClass());\n\n\t\tregisterExtensionsFromStaticFields(registry, getTestClass());\n\n\t\tthis.testInstanceFactory = resolveTestInstanceFactory(registry);\n\n\t\tif (this.testInstanceFactory == null) {\n\t\t\tregisterExtensionsFromConstructorParameters(registry, getTestClass());\n\t\t}\n\n\t\tthis.lifecycleMethods.beforeAll.forEach(method -> registerExtensionsFromExecutableParameters(registry, method));\n\t\tregisterBeforeEachMethodAdapters(registry);\n\t\tregisterAfterEachMethodAdapters(registry);\n\t\tthis.lifecycleMethods.afterAll.forEach(method -> registerExtensionsFromExecutableParameters(registry, method));\n\t\tregisterExtensionsFromInstanceFields(registry, getTestClass());\n\n\t\tThrowableCollector throwableCollector = createThrowableCollector();\n\t\tClassExtensionContext extensionContext = new ClassExtensionContext(context.getExtensionContext(),\n\t\t\tcontext.getExecutionListener(), this, this.classInfo.lifecycle, context.getConfiguration(), registry,\n\t\t\tcontext.getLauncherStoreFacade(), throwableCollector);\n\n\t\treturn context.extend()\n\t\t\t\t.withTestInstancesProvider(testInstancesProvider(context, extensionContext))\n\t\t\t\t.withExtensionRegistry(registry)\n\t\t\t\t.withExtensionContext(extensionContext)\n\t\t\t\t.withThrowableCollector(throwableCollector)\n\t\t\t\t.build();\n\t}",
    "comment": "Register extensions from static fields here, at the class level but\nafter extensions registered via @ExtendWith.\nResolve the TestInstanceFactory at the class level in order to fail\nthe entire class in case of configuration errors (e.g., more than\none factory registered per class).\nSince registerBeforeEachMethodAdapters() and registerAfterEachMethodAdapters() also\ninvoke registerExtensionsFromExecutableParameters(), we invoke those methods before\ninvoking registerExtensionsFromExecutableParameters() for @AfterAll methods,\nthereby ensuring proper registration order for extensions registered via @ExtendWith\non parameters in lifecycle methods.\n@formatter:off\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/InvalidTestClassError.java",
    "type": "method",
    "name": "InvalidTestClassError",
    "code": "public InvalidTestClassError(Class<?> offendingTestClass, List<Throwable> validationErrors) {\n        super(validationErrors);\n        this.message = createMessage(offendingTestClass, validationErrors);\n    }",
    "comment": "Thrown by {@link org.junit.runner.Runner}s in case the class under test is not valid.\n<p>\nIts message conveniently lists all of the validation errors.\n\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/inference_interface/java/org/tensorflow/contrib/android/TensorFlowInferenceInterface.java",
    "type": "method",
    "name": "TensorFlowInferenceInterface",
    "code": "public TensorFlowInferenceInterface(Graph g) {\n    prepareNativeRuntime();\n\n    this.modelName = \"\";\n    this.g = g;\n    this.sess = new Session(g);\n    this.runner = sess.runner();\n  }",
    "comment": "modelName is redundant here, here is for\navoiding error in initialization as modelName is marked final."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/DefaultMirrorSelector.java",
    "type": "method",
    "name": "matchesLayout",
    "code": "static boolean matchesLayout(String repoLayout, String mirrorLayout) {\n        boolean result = false;\n\n        // simple checks first to short circuit processing below.\n        if ((mirrorLayout == null || mirrorLayout.isEmpty()) || WILDCARD.equals(mirrorLayout)) {\n            result = true;\n        } else if (mirrorLayout.equals(repoLayout)) {\n            result = true;\n        } else {\n            // process the list\n            String[] layouts = mirrorLayout.split(\",\");\n            for (String layout : layouts) {\n                // see if this is a negative match\n                if (layout.length() > 1 && layout.startsWith(\"!\")) {\n                    if (layout.substring(1).equals(repoLayout)) {\n                        // explicitly exclude. Set result and stop processing.\n                        result = false;\n                        break;\n                    }\n                }\n                // check for exact match\n                else if (layout.equals(repoLayout)) {\n                    result = true;\n                    break;\n                } else if (WILDCARD.equals(layout)) {\n                    result = true;\n                    // don't stop processing in case a future segment explicitly excludes this repo\n                }\n            }\n        }\n\n        return result;\n    }",
    "comment": "Checks whether the layouts configured for a mirror match with the layout of the repository.\n\n@param repoLayout The layout of the repository, may be {@code null}.\n@param mirrorLayout The layouts supported by the mirror, may be {@code null}.\n@return {@code true} if the layouts associated with the mirror match the layout of the original repository,\n{@code false} otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/CommandBuilderUtils.java",
    "type": "method",
    "name": "redactCommandLineArgs",
    "code": "static List<String> redactCommandLineArgs(List<String> args) {\n    return args.stream().map(CommandBuilderUtils::redact).collect(Collectors.toList());\n  }",
    "comment": "Redact a command-line argument's value part which matches `-Dkey=value` pattern.\nNote that this should be consistent with `org.apache.spark.util.Utils.redactCommandLineArgs`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-settings-builder/src/main/java/org/apache/maven/settings/crypto/DefaultSettingsDecryptionRequest.java",
    "type": "method",
    "name": "DefaultSettingsDecryptionRequest",
    "code": "public DefaultSettingsDecryptionRequest(Server server) {\n        this.servers = new ArrayList<>(Arrays.asList(server));\n    }",
    "comment": "Creates a new request to decrypt the specified server.\n\n@param server The server to decrypt, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultJavaToolchainFactory.java",
    "type": "method",
    "name": "createToolchain",
    "code": "public JavaToolchain createToolchain(@Nonnull ToolchainModel model) {\n        Map<String, Predicate<String>> matchers = model.getProvides().entrySet().stream()\n                .collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, entry -> {\n                    String key = entry.getKey();\n                    String value = entry.getValue();\n                    if (value == null) {\n                        throw new ToolchainFactoryException(\n                                \"Provides token '\" + key + \"' doesn't have any value configured.\");\n                    }\n                    return \"version\".equals(key) ? new VersionMatcher(versionParser, value) : new ExactMatcher(value);\n                }));\n\n        XmlNode dom = model.getConfiguration();\n        XmlNode javahome = dom != null ? dom.child(KEY_JAVAHOME) : null;\n        if (javahome == null || javahome.value() == null) {\n            throw new ToolchainFactoryException(\n                    \"Java toolchain without the \" + KEY_JAVAHOME + \" configuration element.\");\n        }\n        Path normal = Paths.get(javahome.value()).normalize();\n        if (!Files.exists(normal)) {\n            throw new ToolchainFactoryException(\"Non-existing JDK home configuration at \" + normal.toAbsolutePath());\n        }\n        String javaHome = normal.toString();\n\n        return new DefaultJavaToolchain(model, javaHome, matchers);\n    }",
    "comment": "populate the provides section\ncompute and normalize the java home"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "free",
    "code": "public void free() {\n    updatePeakMemoryUsed();\n    if (longArray != null) {\n      freeArray(longArray);\n      longArray = null;\n    }\n    Iterator<MemoryBlock> dataPagesIterator = dataPages.iterator();\n    while (dataPagesIterator.hasNext()) {\n      MemoryBlock dataPage = dataPagesIterator.next();\n      dataPagesIterator.remove();\n      freePage(dataPage);\n    }\n    assert(dataPages.isEmpty());\n\n    while (!spillWriters.isEmpty()) {\n      File file = spillWriters.removeFirst().getFile();\n      if (file != null && file.exists()) {\n        if (!file.delete()) {\n          logger.error(\"Was unable to delete spill file {}\",\n            MDC.of(LogKeys.PATH$.MODULE$, file.getAbsolutePath()));\n        }\n      }\n    }\n  }",
    "comment": "Free all allocated memory associated with this map, including the storage for keys and values\nas well as the hash map array itself.\n\nThis method is idempotent and can be called multiple times."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/LookupInvoker.java",
    "type": "method",
    "name": "determineBuildEventListener",
    "code": "protected BuildEventListener determineBuildEventListener(C context) {\n        if (context.buildEventListener == null) {\n            context.buildEventListener = doDetermineBuildEventListener(context);\n        }\n        return context.buildEventListener;\n    }",
    "comment": "else fall back to default log level specified in conf\nsee https://issues.apache.org/jira/browse/MNG-2570"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/Logger.java",
    "type": "method",
    "name": "debug",
    "code": "default void debug(String message) {\n        log(Level.DEBUG, message);\n    }",
    "comment": "Logs a debug message without an associated exception.\n\n@param message the debug message to be logged"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Integer expected, int actual) {\n\t\tAssertEquals.assertEquals(expected, (Integer) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/tasks/CustomClassLoaderCloseStrategy.java",
    "type": "method",
    "name": "handle",
    "code": "public void handle(ClassLoader customClassLoader) {\n\t\t\t// do nothing\n\t\t}",
    "comment": "Rely on the JVM to release resources held by the custom class loader when\nit terminates.\n\n<p>This mode is only safe to use when calling {@link System#exit(int)}\nafterward."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/DebugResolutionListener.java",
    "type": "method",
    "name": "manageArtifactScope",
    "code": "public void manageArtifactScope(Artifact artifact, Artifact replacement) {\n        if (!replacement.getScope().equals(artifact.getScope())) {\n            String msg = indent + artifact + \" (applying artifactScope: \" + replacement.getScope() + \")\";\n            logger.debug(msg);\n        }\n    }",
    "comment": "only show msg if a change is actually taking place"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaKernelDensityEstimationExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaKernelDensityEstimationExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    JavaRDD<Double> data = jsc.parallelize(\n      Arrays.asList(1.0, 1.0, 1.0, 2.0, 3.0, 4.0, 5.0, 5.0, 6.0, 7.0, 8.0, 9.0, 9.0));\n\n    KernelDensity kd = new KernelDensity().setSample(data).setBandwidth(3.0);\n\n    double[] densities = kd.estimate(new double[]{-1.0, 2.0, 5.0});\n}",
    "comment": "$example on$\n$example off$\n$example on$\nan RDD of sample data\nConstruct the density estimator with the sample data\nand a standard deviation for the Gaussian kernels\nFind density estimates for the given values"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Timeout.java",
    "type": "method",
    "name": "withLookingForStuckThread",
    "code": "public Builder withLookingForStuckThread(boolean enable) {\n            this.lookForStuckThread = enable;\n            return this;\n        }",
    "comment": "Specifies whether to look for a stuck thread.  If a timeout occurs and this\nfeature is enabled, the rule will look for a thread that appears to be stuck\nand dump its backtrace.  This feature is experimental.  Behavior may change\nafter the 4.12 release in response to feedback.\n\n@param enable {@code true} to enable the feature\n@return {@code this} for method chaining."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-log-aggregation/src/main/java/com/iluwatar/logaggregation/LogProducer.java",
    "type": "method",
    "name": "generateLog",
    "code": "public void generateLog(LogLevel level, String message) {\n    final LogEntry logEntry = new LogEntry(serviceName, level, message, LocalDateTime.now());\n    LOGGER.info(\"Producing log: \" + logEntry.getMessage());\n    aggregator.collectLog(logEntry);\n  }",
    "comment": "Generates a log entry with the given log level and message.\n\n@param level The level of the log.\n@param message The message of the log."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/repository/metadata/io/MetadataParseException.java",
    "type": "method",
    "name": "MetadataParseException",
    "code": "public MetadataParseException(String message, int lineNumber, int columnNumber, Throwable cause) {\n        super(message);\n        initCause(cause);\n        this.lineNumber = lineNumber;\n        this.columnNumber = columnNumber;\n    }",
    "comment": "Creates a new parser exception with the specified details.\n\n@param message The error message, may be {@code null}.\n@param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.\n@param columnNumber The one-based index of the column containing the error or {@code -1} if unknown.\n@param cause The nested cause of this error, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaLabeledDocument.java",
    "type": "method",
    "name": "JavaLabeledDocument",
    "code": "public JavaLabeledDocument(long id, String text, double label) {\n    super(id, text);\n    this.label = label;\n  }",
    "comment": "Labeled instance type, Spark SQL can infer schema from Java Beans."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/JavaHdfsLR.java",
    "type": "method",
    "name": "showWarning",
    "code": "static void showWarning() {\n    String warning = \"WARN: This is a naive implementation of Logistic Regression \" +\n            \"and is given as an example!\\n\" +\n            \"Please use org.apache.spark.ml.classification.LogisticRegression \" +\n            \"for more conventional use.\";\n    System.err.println(warning);\n  }",
    "comment": "Logistic regression based classification.\n\nThis is an example implementation for learning how to use Spark. For more conventional use,\nplease refer to org.apache.spark.ml.classification.LogisticRegression."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "upper",
    "code": "public Object upper(List<Object> args) {\n        if (args.size() != 1) {\n            throw new IllegalArgumentException(\"upper function requires exactly one argument\");\n        }\n        String s = ConditionParser.toString(args.get(0));\n        return s.toUpperCase();\n    }",
    "comment": "Converts the given string to uppercase.\n\n@param args A list containing a single string argument\n@return The uppercase version of the input string\n@throws IllegalArgumentException if the number of arguments is not exactly one"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/TestShuffleDataContext.java",
    "type": "method",
    "name": "TestShuffleDataContext",
    "code": "public TestShuffleDataContext(int numLocalDirs, int subDirsPerLocalDir) {\n    this.localDirs = new String[numLocalDirs];\n    this.subDirsPerLocalDir = subDirsPerLocalDir;\n  }",
    "comment": "Manages some sort-shuffle data, including the creation\nand cleanup of directories that can be read by the {@link ExternalShuffleBlockResolver}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/array/LongArray.java",
    "type": "method",
    "name": "zeroOut",
    "code": "public void zeroOut() {\n    for (long off = baseOffset; off < baseOffset + length * WIDTH; off += WIDTH) {\n      Platform.putLong(baseObj, off, 0);\n    }\n  }",
    "comment": "Fill this all with 0L."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(short unexpected, Short actual) {\n\t\tAssertNotEquals.assertNotEquals((Short) unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java",
    "type": "method",
    "name": "getOrComputeIfAbsentWithTypeSafety",
    "code": "void getOrComputeIfAbsentWithTypeSafety() {\n\t\t\tInteger key = 42;\n\t\t\tString value = \"enigma\";\n\n\t\t\tString computedValue = store.getOrComputeIfAbsent(namespace, key, k -> value, String.class);\n\t\t\tassertEquals(value, computedValue);\n\t\t}",
    "comment": "The fact that we can declare this as a String suffices for testing the required type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Float> create(float[][][][] data) {\n    return Tensor.create(data, Float.class);\n  }",
    "comment": "Creates a rank-4 tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/model-view-presenter/src/main/java/com/iluwatar/model/view/presenter/FileSelectorJframe.java",
    "type": "method",
    "name": "actionPerformed",
    "code": "public void actionPerformed(ActionEvent e) {\n    if (this.ok.equals(e.getSource())) {\n      this.fileName = this.input.getText();\n      presenter.fileNameChanged();\n      presenter.confirmed();\n    } else if (this.cancel.equals(e.getSource())) {\n      presenter.cancelled();\n    }\n  }",
    "comment": "public FileSelectorJframe() {\nsuper(\"File Loader\");\nthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\nthis.setLayout(null);\nthis.setBounds(100, 100, 500, 200);\n\n/*\nAdd the panel."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "fetch",
    "code": "public Runner fetch(String operation) {\n      return fetch(parseOutput(operation));\n    }",
    "comment": "Make {@link #run()} return the output of {@code operation}.\n\n@param operation Is either the string name of the operation, in which case this method is a\nshorthand for {@code fetch(operation, 0)}, or it is a string of the form\n<tt>operation_name:output_index</tt> , in which case this method acts like {@code\nfetch(operation_name, output_index)}. These colon-separated names are commonly used in\nthe {@code SignatureDef} protocol buffer messages that are included in {@link\nSavedModelBundle#metaGraphDef()}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/org/apache/spark/streaming/JavaMapWithStateSuite.java",
    "type": "method",
    "name": "testAPI",
    "code": "public void testAPI() {\n    JavaPairRDD<String, Boolean> initialRDD = null;\n    JavaPairDStream<String, Integer> wordsDstream = null;\n\n    Function4<Time, String, Optional<Integer>, State<Boolean>, Optional<Double>> mappingFunc =\n        (time, word, one, state) -> {\n          // Use all State's methods here\n          state.exists();\n          state.get();\n          state.isTimingOut();\n          state.remove();\n          state.update(true);\n          return Optional.of(2.0);\n        };\n\n    JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream =\n        wordsDstream.mapWithState(\n            StateSpec.function(mappingFunc)\n                .initialState(initialRDD)\n                .numPartitions(10)\n                .partitioner(new HashPartitioner(10))\n                .timeout(Durations.seconds(10)));\n\n    stateDstream.stateSnapshots();\n\n    Function3<String, Optional<Integer>, State<Boolean>, Double> mappingFunc2 =\n        (key, one, state) -> {\n          // Use all State's methods here\n          state.exists();\n          state.get();\n          state.isTimingOut();\n          state.remove();\n          state.update(true);\n          return 2.0;\n        };\n\n    JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream2 =\n        wordsDstream.mapWithState(\n            StateSpec.function(mappingFunc2)\n                .initialState(initialRDD)\n                .numPartitions(10)\n                .partitioner(new HashPartitioner(10))\n                .timeout(Durations.seconds(10)));\n\n    stateDstream2.stateSnapshots();\n  }",
    "comment": "This test is only for testing the APIs. It's not necessary to run it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/discovery/ResourceContainerSelectorResolverTest.java",
    "type": "method",
    "name": "getTestClasspathResourceRoot",
    "code": "private Set<Path> getTestClasspathResourceRoot() {\n\t\tvar defaultPackageResource = \"/default-package.resource\";\n\t\tvar resourceUri = getClass().getResource(defaultPackageResource).toString();\n\t\tvar uri = URI.create(resourceUri.substring(0, resourceUri.length() - defaultPackageResource.length()));\n\t\treturn Collections.singleton(Path.of(uri));\n\t}",
    "comment": "Gradle puts classes and resources in different roots."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(long expected, long actual) {\n        assertEquals(null, expected, actual);\n    }",
    "comment": "Asserts that two longs are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "maybeCreateFlexDelegate",
    "code": "private static Delegate maybeCreateFlexDelegate(List<Delegate> delegates) {\n    try {\n      Class<?> clazz = Class.forName(\"org.tensorflow.lite.flex.FlexDelegate\");\n      for (Delegate delegate : delegates) {\n        if (clazz.isInstance(delegate)) {\n          return null;\n        }\n      }\n      return (Delegate) clazz.getConstructor().newInstance();\n    } catch (ClassNotFoundException\n        | IllegalAccessException\n        | IllegalArgumentException\n        | InstantiationException\n        | InvocationTargetException\n        | NoSuchMethodException\n        | SecurityException e) {\n      return null;\n    }\n  }",
    "comment": "No need to create the Flex delegate if one has already been provided.\nThe error will propagate when tensors are allocated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/DisableOnDebugTest.java",
    "type": "method",
    "name": "Statement",
    "code": "Description description) {\n            return new Statement() {\n            };\n        }",
    "comment": "Nasty rule that always fails"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/test/java/org/apache/spark/launcher/LauncherServerSuite.java",
    "type": "method",
    "name": "close",
    "code": "private void close(Closeable c) {\n    if (c != null) {\n      try {\n        c.close();\n      } catch (Exception e) {\n      }\n    }\n  }",
    "comment": "Wait until we know the server has received the messages and matched the handle to the\nconnection before disconnecting.\nno-op."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "disabledMetricAttributes",
    "code": "public Builder disabledMetricAttributes(Set<MetricAttribute> disabledMetricAttributes) {\n            this.disabledMetricAttributes = disabledMetricAttributes;\n            return this;\n        }",
    "comment": "Don't report the passed metric attributes for all metrics (e.g. \"p999\", \"stddev\" or \"m15\").\nSee {@link MetricAttribute}.\n\n@param disabledMetricAttributes a {@link MetricFilter}\n@return {@code this}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "outputDirectoryProvider",
    "code": "public LauncherDiscoveryRequestBuilder outputDirectoryProvider(OutputDirectoryProvider outputDirectoryProvider) {\n\t\tthis.outputDirectoryProvider = Preconditions.notNull(outputDirectoryProvider,\n\t\t\t\"outputDirectoryProvider must not be null\");\n\t\treturn this;\n\t}",
    "comment": "Set the {@link OutputDirectoryProvider} to use for the request.\n\n<p>If not specified, a default provider will be used that can be\nconfigured via the {@value LauncherConstants#OUTPUT_DIR_PROPERTY_NAME}\nconfiguration parameter.\n\n@param outputDirectoryProvider the output directory provider to use;\nnever {@code null}\n@return this builder for method chaining\n@since 1.12\n@see OutputDirectoryProvider\n@see LauncherConstants#OUTPUT_DIR_PROPERTY_NAME"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/DefaultArtifactFilterManager.java",
    "type": "method",
    "name": "getArtifactFilter",
    "code": "public ArtifactFilter getArtifactFilter() {\n        Set<String> excludes = new LinkedHashSet<>(getExcludedArtifacts());\n\n        for (ArtifactFilterManagerDelegate delegate : delegates) {\n            delegate.addExcludes(excludes);\n        }\n\n        return new ExclusionSetFilter(excludes);\n    }",
    "comment": "Returns the artifact filter for the core + extension artifacts.\n\n@see org.apache.maven.ArtifactFilterManager#getArtifactFilter()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlanExecutor.java",
    "type": "method",
    "name": "finalizeMojoConfiguration",
    "code": "private void finalizeMojoConfiguration(MojoExecution mojoExecution) {\n        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();\n\n        XmlNode executionConfiguration = mojoExecution.getConfiguration() != null\n                ? mojoExecution.getConfiguration().getDom()\n                : null;\n        if (executionConfiguration == null) {\n            executionConfiguration = XmlNode.newInstance(\"configuration\");\n        }\n\n        XmlNode defaultConfiguration = getMojoConfiguration(mojoDescriptor);\n\n        List<XmlNode> children = new ArrayList<>();\n        if (mojoDescriptor.getParameters() != null) {\n            for (Parameter parameter : mojoDescriptor.getParameters()) {\n                XmlNode parameterConfiguration = executionConfiguration.child(parameter.getName());\n\n                if (parameterConfiguration == null) {\n                    parameterConfiguration = executionConfiguration.child(parameter.getAlias());\n                }\n\n                XmlNode parameterDefaults = defaultConfiguration.child(parameter.getName());\n\n                if (parameterConfiguration != null) {\n                    parameterConfiguration = XmlService.merge(parameterConfiguration, parameterDefaults, Boolean.TRUE);\n                } else {\n                    parameterConfiguration = parameterDefaults;\n                }\n\n                if (parameterConfiguration != null) {\n                    Map<String, String> attributes = new HashMap<>(parameterConfiguration.attributes());\n\n                    String attributeForImplementation = parameterConfiguration.attribute(\"implementation\");\n                    String parameterForImplementation = parameter.getImplementation();\n                    if ((attributeForImplementation == null || attributeForImplementation.isEmpty())\n                            && ((parameterForImplementation != null) && !parameterForImplementation.isEmpty())) {\n                        attributes.put(\"implementation\", parameter.getImplementation());\n                    }\n\n                    parameterConfiguration = XmlNode.newInstance(\n                            parameter.getName(),\n                            parameterConfiguration.value(),\n                            attributes,\n                            parameterConfiguration.children(),\n                            parameterConfiguration.inputLocation());\n\n                    children.add(parameterConfiguration);\n                }\n            }\n        }\n        XmlNode finalConfiguration = XmlNode.newInstance(\"configuration\", children);\n\n        mojoExecution.setConfiguration(finalConfiguration);\n    }",
    "comment": "Post-processes the effective configuration for the specified mojo execution. This step discards all parameters\nfrom the configuration that are not applicable to the mojo and injects the default values for any missing\nparameters.\n\n@param mojoExecution The mojo execution whose configuration should be finalized, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tooling-support-tests/src/main/java/platform/tooling/support/ProcessStarters.java",
    "type": "method",
    "name": "currentJdkHome",
    "code": "public static Path currentJdkHome() {\n\t\tvar executable = ProcessHandle.current().info().command().map(Path::of).orElseThrow();\n\t\treturn executable.getParent().getParent().toAbsolutePath();\n\t}",
    "comment": "path element count is 3 or higher: \"<JAVA_HOME>/bin/java[.exe]\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPreconditionTests.java",
    "type": "method",
    "name": "parameterTypes",
    "code": "void parameterTypes() {\n\t\tEngineExecutionResults executionResults = executeTestsForClass(ParameterTypeTestCase.class);\n\t\tEvents tests = executionResults.testEvents();\n\t\ttests.assertStatistics(stats -> stats.started(2).failed(1).succeeded(1));\n\t\ttests.succeeded().assertEventsMatchExactly(event(test(\"validTempDirType\"), finishedSuccessfully()));\n\t\t// @formatter:off\n\t\ttests.failed().assertEventsMatchExactly(event(test(\"invalidTempDirType\"),\n\t\t\tfinishedWithFailure(instanceOf(ParameterResolutionException.class), message(\"\"\"\n\t\t\t\t\tFailed to resolve parameter [java.lang.String text] in method \\\n\t\t\t\t\t[void org.junit.jupiter.engine.extension.TempDirectoryPreconditionTests$ParameterTypeTestCase.invalidTempDirType(java.lang.String)]: \\\n\t\t\t\t\tCan only resolve @TempDir parameter of type java.nio.file.Path or java.io.File but was: java.lang.String\\\n\t\t\t\t\t\"\"\"))));\n\t\t// @formatter:on\n\t}",
    "comment": "Integration tests for preconditions and assertions in the {@link TempDirectory}\nextension.\n\n@since 5.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/test/java/org/apache/spark/util/kvstore/RocksDBTypeInfoSuite.java",
    "type": "method",
    "name": "assertBefore",
    "code": "private void assertBefore(byte[] key1, byte[] key2) {\n    assertBefore(new String(key1, UTF_8), new String(key2, UTF_8));\n  }",
    "comment": "Make sure entries with conflicting names are sorted correctly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "setNullAt",
    "code": "public void setNullAt(int i) {\n    assertIndexIsValid(i);\n    BitSetMethods.set(baseObject, baseOffset, i);\n    Platform.putLong(baseObject, getFieldOffset(i), 0);\n  }",
    "comment": "To preserve row equality, zero out the value when setting the column to null.\nSince this row does not currently support updates to variable-length values, we don't\nhave to worry about zeroing out that data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/BloomFilter.java",
    "type": "method",
    "name": "optimalNumOfBits",
    "code": "public static long optimalNumOfBits(long expectedNumItems, long maxNumItems, long maxNumOfBits) {\n    double fpp = Math.min(expectedNumItems / (maxNumItems / DEFAULT_FPP), DEFAULT_FPP);\n    return Math.min(optimalNumOfBits(expectedNumItems, fpp), maxNumOfBits);\n  }",
    "comment": "Computes m (total bits of Bloom filter) which is expected to achieve.\nThe smaller the expectedNumItems, the smaller the fpp."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(FileSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link FileSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/streaming/JavaStructuredComplexSessionization.java",
    "type": "method",
    "name": "setSessions",
    "code": "public void setSessions(List<SessionAcc> sessions) {\n      if (sessions.isEmpty()) {\n        throw new IllegalArgumentException(\"events should not be empty!\");\n      }\n\n      List<SessionAcc> sorted = new ArrayList<>(sessions);\n      sorted.sort(Comparator.comparingLong(session -> session.startTime().getTime()));\n\n      this.sessions = sorted;\n    }",
    "comment": "`sessions` should not be empty, and be sorted by start time"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Boolean> create(Scope scope, boolean[][][][][][] data) {\n    return create(scope, data, Boolean.class);\n  }",
    "comment": "Creates a rank-6 constant of {@code boolean} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-model/src/main/java/org/apache/maven/api/model/InputLocation.java",
    "type": "method",
    "name": "merge",
    "code": "public static InputLocation merge(InputLocation target, InputLocation source, Collection<Integer> indices) {\n        if (source == null) {\n            return target;\n        } else if (target == null) {\n            return source;\n        }\n\n        Map<Object, InputLocation> locations;\n        Map<Object, InputLocation> sourceLocations = source.locations;\n        Map<Object, InputLocation> targetLocations = target.locations;\n        if (sourceLocations == null) {\n            locations = targetLocations;\n        } else if (targetLocations == null) {\n            locations = sourceLocations;\n        } else {\n            locations = new LinkedHashMap<>();\n            for (int index : indices) {\n                InputLocation location;\n                if (index < 0) {\n                    location = sourceLocations.get(~index);\n                } else {\n                    location = targetLocations.get(index);\n                }\n                locations.put(locations.size(), location);\n            }\n        }\n\n        return new InputLocation(-1, -1, InputSource.merge(source.getSource(), target.getSource()), locations);\n    } // -- InputLocation merge( InputLocation, InputLocation, java.util.Collection )",
    "comment": "Merges the {@code source} location into the {@code target} location.\nThis method is used when the locations refer to lists and also merges the indices.\n\n@param target the target location\n@param source the source location\n@param indices the list of integers for the indices\n@return the merged location"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ModelBuilderException.java",
    "type": "method",
    "name": "ModelBuilderException",
    "code": "public ModelBuilderException(ModelBuilderResult result) {\n        super(result.toString());\n        this.result = result;\n    }",
    "comment": "Creates a new exception from the specified interim result and its associated problems.\n\n@param result The interim result, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/AppsWithRecoveryDisabled.java",
    "type": "method",
    "name": "removeApp",
    "code": "public static void removeApp(String appId) {\n    Preconditions.checkNotNull(appId);\n    INSTANCE.appsWithRecoveryDisabled.remove(appId);\n  }",
    "comment": "Removes the application from the store.\n@param appId application id"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/runner/JUnitPlatformRunnerTests.java",
    "type": "method",
    "name": "updatesIncludeClassNameFilterWhenSelectClassesAnnotationIsPresent",
    "code": "void updatesIncludeClassNameFilterWhenSelectClassesAnnotationIsPresent() {\n\n\t\t\t@SelectClasses({ Short.class, Byte.class })\n\t\t\tclass TestCase {\n\t\t\t}\n\n\t\t\tvar request = instantiateRunnerAndCaptureGeneratedRequest(TestCase.class);\n\n\t\t\tvar filters = request.getFiltersByType(ClassNameFilter.class);\n\t\t\tassertThat(filters).hasSize(1);\n\n\t\t\tvar filter = filters.getFirst();\n\n\t\t\tassertExcludes(filter, \"example.MyClass\");\n\t\t\tassertExcludes(filter, \"example.MyTestClass\");\n\t\t\tassertExcludes(filter, \"example.Short\");\n\t\t\tassertExcludes(filter, \"example.Byte\");\n\n\t\t\tassertIncludes(filter, \"TestClass\");\n\t\t\tassertIncludes(filter, \"example.TestClass\");\n\t\t\tassertIncludes(filter, \"example.MyTests\");\n\t\t\tassertIncludes(filter, \"example.MyTest\");\n\n\t\t\tassertIncludes(filter, Short.class.getName());\n\t\t\tassertIncludes(filter, Byte.class.getName());\n\t\t}",
    "comment": "Excluded by default\nIncluded due to ClassNameFilter.STANDARD_INCLUDE_PATTERN\nIncluded due to @SelectClasses({ Short.class, Byte.class })"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "getDoubles",
    "code": "public double[] getDoubles(int rowId, int count) {\n    double[] res = new double[count];\n    for (int i = 0; i < count; i++) {\n      res[i] = getDouble(rowId + i);\n    }\n    return res;\n  }",
    "comment": "Gets double type values from {@code [rowId, rowId + count)}. The return values for the null\nslots are undefined and can be anything."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/NettyMemoryMetrics.java",
    "type": "method",
    "name": "registerArenaMetric",
    "code": "private void registerArenaMetric(PoolArenaMetric arenaMetric, String arenaName) {\n    for (String methodName : VERBOSE_METRICS) {\n      Method m;\n      try {\n        m = PoolArenaMetric.class.getMethod(methodName);\n      } catch (Exception e) {\n        continue;\n      }\n\n      if (!Modifier.isPublic(m.getModifiers())) {\n        continue;\n      }\n\n      Class<?> returnType = m.getReturnType();\n      String metricName = MetricRegistry.name(metricPrefix, arenaName, m.getName());\n      if (returnType.equals(int.class)) {\n        allMetrics.put(metricName, (Gauge<Integer>) () -> {\n          try {\n            return (Integer) m.invoke(arenaMetric);\n          } catch (Exception e) {\n            return -1; // Swallow the exceptions.\n          }\n        });\n\n      } else if (returnType.equals(long.class)) {\n        allMetrics.put(metricName, (Gauge<Long>) () -> {\n          try {\n            return (Long) m.invoke(arenaMetric);\n          } catch (Exception e) {\n            return -1L; // Swallow the exceptions.\n          }\n        });\n      }\n    }\n  }",
    "comment": "Failed to find metric related method, ignore this metric.\nIgnore non-public methods."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaDecisionTreeRegressionExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf sparkConf = new SparkConf().setAppName(\"JavaDecisionTreeRegressionExample\");\n    JavaSparkContext jsc = new JavaSparkContext(sparkConf);\n\n    String datapath = \"data/mllib/sample_libsvm_data.txt\";\n    JavaRDD<LabeledPoint> data = MLUtils.loadLibSVMFile(jsc.sc(), datapath).toJavaRDD();\n    JavaRDD<LabeledPoint>[] splits = data.randomSplit(new double[]{0.7, 0.3});\n    System.out.println(\"Test Mean Squared Error: \" + testMSE);\n    System.out.println(\"Learned regression tree model:\\n\" + model.toDebugString());\n\n    model.save(jsc.sc(), \"target/tmp/myDecisionTreeRegressionModel\");\n    DecisionTreeModel sameModel = DecisionTreeModel\n      .load(jsc.sc(), \"target/tmp/myDecisionTreeRegressionModel\");\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file.\nSplit the data into training and test sets (30% held out for testing)\nSave and load model\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "writeTo",
    "code": "public void writeTo(ByteBuffer dst) {\n    ByteBuffer src = buffer();\n    dst.put(src);\n  }",
    "comment": "Write the tensor data into the given buffer.\n\n<p>Copies {@code numBytes()} bytes to the buffer in native byte order for primitive types.\n\n@param dst the destination buffer\n@throws BufferOverflowException If there is insufficient space in the given buffer for the data\nin this tensor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "fromCollationId",
    "code": "private static CollationSpecICU fromCollationId(int collationId) {\n        int spaceTrimmingOrdinal = SpecifierUtils.getSpecValue(collationId,\n          SPACE_TRIMMING_OFFSET, SPACE_TRIMMING_MASK);\n        int caseSensitivityOrdinal = SpecifierUtils.getSpecValue(collationId,\n          CASE_SENSITIVITY_OFFSET, CASE_SENSITIVITY_MASK);\n        int accentSensitivityOrdinal = SpecifierUtils.getSpecValue(collationId,\n          ACCENT_SENSITIVITY_OFFSET, ACCENT_SENSITIVITY_MASK);\n        collationId = SpecifierUtils.removeSpec(collationId,\n          IMPLEMENTATION_PROVIDER_OFFSET, IMPLEMENTATION_PROVIDER_MASK);\n        collationId = SpecifierUtils.removeSpec(collationId,\n          SPACE_TRIMMING_OFFSET, SPACE_TRIMMING_MASK);\n        collationId = SpecifierUtils.removeSpec(collationId,\n          CASE_SENSITIVITY_OFFSET, CASE_SENSITIVITY_MASK);\n        collationId = SpecifierUtils.removeSpec(collationId,\n          ACCENT_SENSITIVITY_OFFSET, ACCENT_SENSITIVITY_MASK);\n        int localeId = collationId;\n        assert(localeId >= 0 && localeId < ICULocaleNames.length);\n        CaseSensitivity caseSensitivity = CaseSensitivity.values()[caseSensitivityOrdinal];\n        AccentSensitivity accentSensitivity = AccentSensitivity.values()[accentSensitivityOrdinal];\n        SpaceTrimming spaceTrimming = SpaceTrimming.values()[spaceTrimmingOrdinal];\n        String locale = ICULocaleNames[localeId];\n        return new CollationSpecICU(locale, caseSensitivity, accentSensitivity, spaceTrimming);\n      }",
    "comment": "Build collation ID from computed specifiers.\nParse specifiers from collation ID.\nLocale ID remains after removing all other specifiers.\nVerify locale ID is valid against `ICULocaleNames` array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "isWhitespaceOrISOControl",
    "code": "public static boolean isWhitespaceOrISOControl(int codePoint) {\n    return Character.isWhitespace(codePoint) || Character.isISOControl(codePoint);\n  }",
    "comment": "Determines if the specified character (Unicode code point) is white space or an ISO control\ncharacter according to Java."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "addTarget",
    "code": "public Runner addTarget(Operand<?> operand) {\n      return addTarget(operand.asOutput().op());\n    }",
    "comment": "Make {@link #run} execute {@code operand}, but not return any evaluated {@link Tensor\nTensors}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "forEngine",
    "code": "public static UniqueId forEngine(String engineId) {\n\t\tPreconditions.notBlank(engineId, \"engineId must not be null or blank\");\n\t\treturn root(ENGINE_SEGMENT_TYPE, engineId);\n\t}",
    "comment": "Create an engine's unique ID from its {@code engineId} using the default\nformat.\n\n<p>The engine ID will be stored in a {@link Segment} with\n{@link Segment#getType type} {@code \"engine\"}.\n\n@param engineId the engine ID; never {@code null} or blank\n@see #root(String, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicSample/app/src/main/java/com/example/android/persistence/ui/ProductListFragment.java",
    "type": "method",
    "name": "subscribeUi",
    "code": "private void subscribeUi(LiveData<List<ProductEntity>> liveData) {\n        liveData.observe(getViewLifecycleOwner(), myProducts -> {\n            if (myProducts != null) {\n                mBinding.setIsLoading(false);\n                mProductAdapter.setProductList(myProducts);\n            } else {\n                mBinding.setIsLoading(true);\n            }\n            mBinding.executePendingBindings();\n        });\n    }",
    "comment": "Update the list when the data changes\nespresso does not know how to wait for data binding's loop so we execute changes\nsync."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/business-delegate/src/test/java/com/iluwatar/business/delegate/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaRandomForestRegressorExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaRandomForestRegressorExample\")\n      .getOrCreate();\n\n    Dataset<Row> data = spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    VectorIndexerModel featureIndexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexedFeatures\")\n      .setMaxCategories(4)\n      .fit(data);\n\n    Dataset<Row>[] splits = data.randomSplit(new double[] {0.7, 0.3});\n      .setStages(new PipelineStage[] {featureIndexer, rf});\n}",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file, converting it to a DataFrame.\nAutomatically identify categorical features, and index them.\nSet maxCategories so features with > 4 distinct values are treated as continuous.\nSplit the data into training and test sets (30% held out for testing)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnVector.java",
    "type": "method",
    "name": "getFloats",
    "code": "public float[] getFloats(int rowId, int count) {\n    float[] res = new float[count];\n    for (int i = 0; i < count; i++) {\n      res[i] = getFloat(rowId + i);\n    }\n    return res;\n  }",
    "comment": "Gets float type values from {@code [rowId, rowId + count)}. The return values for the null\nslots are undefined and can be anything."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SparkSaslClient.java",
    "type": "method",
    "name": "SparkSaslClient",
    "code": "public SparkSaslClient(String secretKeyId, SecretKeyHolder secretKeyHolder, boolean encrypt) {\n    this.secretKeyId = secretKeyId;\n    this.secretKeyHolder = secretKeyHolder;\n    this.expectedQop = encrypt ? QOP_AUTH_CONF : QOP_AUTH;\n\n    Map<String, String> saslProps = ImmutableMap.<String, String>builder()\n      .put(Sasl.QOP, expectedQop)\n      .build();\n    try {\n      this.saslClient = Sasl.createSaslClient(new String[] { DIGEST }, null, null, DEFAULT_REALM,\n      throw new RuntimeException(e);\n    }\n  }",
    "comment": "A SASL Client for Spark which simply keeps track of the state of a single SASL session, from the\ninitial state to the \"authenticated\" state. This client initializes the protocol via a\nfirstToken, which is then followed by a set of challenges and responses."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/repository/metadata/MetadataRetrievalException.java",
    "type": "method",
    "name": "MetadataRetrievalException",
    "code": "public MetadataRetrievalException(String message) {\n        this(message, null, null);\n    }",
    "comment": "Error while retrieving repository metadata from the repository."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/session/SessionManager.java",
    "type": "method",
    "name": "createBackgroundOperationPool",
    "code": "private void createBackgroundOperationPool() {\n    int poolSize = hiveConf.getIntVar(ConfVars.HIVE_SERVER2_ASYNC_EXEC_THREADS);\n    LOG.info(\"HiveServer2: Background operation thread pool size: {}\",\n      MDC.of(LogKeys.THREAD_POOL_SIZE$.MODULE$, poolSize));\n    int poolQueueSize = hiveConf.getIntVar(ConfVars.HIVE_SERVER2_ASYNC_EXEC_WAIT_QUEUE_SIZE);\n    LOG.info(\"HiveServer2: Background operation thread wait queue size: {}\",\n      MDC.of(LogKeys.THREAD_POOL_WAIT_QUEUE_SIZE$.MODULE$, poolQueueSize));\n    long keepAliveTime = HiveConf.getTimeVar(\n        hiveConf, ConfVars.HIVE_SERVER2_ASYNC_EXEC_KEEPALIVE_TIME, TimeUnit.SECONDS);\n    LOG.info(\"HiveServer2: Background operation thread keepalive time: {} ms\",\n      MDC.of(LogKeys.THREAD_POOL_KEEPALIVE_TIME$.MODULE$, keepAliveTime * 1000L));\n\n    String threadPoolName = \"HiveServer2-Background-Pool\";\n    backgroundOperationPool = new ThreadPoolExecutor(poolSize, poolSize,\n        keepAliveTime, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(poolQueueSize),\n        new ThreadFactoryWithGarbageCleanup(threadPoolName));\n    backgroundOperationPool.allowCoreThreadTimeOut(true);\n\n    checkInterval = HiveConf.getTimeVar(\n        hiveConf, ConfVars.HIVE_SERVER2_SESSION_CHECK_INTERVAL, TimeUnit.MILLISECONDS);\n    sessionTimeout = HiveConf.getTimeVar(\n        hiveConf, ConfVars.HIVE_SERVER2_IDLE_SESSION_TIMEOUT, TimeUnit.MILLISECONDS);\n    checkOperation = HiveConf.getBoolVar(hiveConf,\n        ConfVars.HIVE_SERVER2_IDLE_SESSION_CHECK_OPERATION);\n  }",
    "comment": "Create a thread pool with #poolSize threads\nThreads terminate when they are idle for more than the keepAliveTime\nA bounded blocking queue is used to queue incoming operations, if #operations > poolSize"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/RpcIntegrationSuite.java",
    "type": "method",
    "name": "assertErrorsContain",
    "code": "private void assertErrorsContain(Set<String> errors, Set<String> contains) {\n    assertEquals(contains.size(), errors.size(),\n      \"Expected \" + contains.size() + \" errors, got \" + errors.size() + \"errors: \" + errors);\n\n    Pair<Set<String>, Set<String>> r = checkErrorsContain(errors, contains);\n    assertTrue(r.getRight().isEmpty(),\n      \"Could not find error containing \" + r.getRight() + \"; errors: \" + errors);\n\n    assertTrue(r.getLeft().isEmpty());\n  }",
    "comment": "when there is a failure reading stream data, we don't try to keep the channel usable,\njust send back a decent error msg.\nOTOH, if there is a failure during onComplete, the channel should still be fine"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/orc/OrcColumnStatistics.java",
    "type": "method",
    "name": "OrcColumnStatistics",
    "code": "public OrcColumnStatistics(ColumnStatistics statistics) {\n    this.statistics = statistics;\n    this.children = new ArrayList<>();\n  }",
    "comment": "Columns statistics interface wrapping ORC {@link ColumnStatistics}s.\n\nBecause ORC {@link ColumnStatistics}s are stored as an flatten array in ORC file footer,\nthis class is used to convert ORC {@link ColumnStatistics}s from array to nested tree structure,\naccording to data types. The flatten array stores all data types (including nested types) in\ntree pre-ordering. This is used for aggregate push down in ORC.\n\nFor nested data types (array, map and struct), the sub-field statistics are stored recursively\ninside parent column's children field. Here is an example of {@link OrcColumnStatistics}:\n\nData schema:\nc1: int\nc2: struct<f1: int, f2: float>\nc3: map<key: int, value: string>\nc4: array<int>\n\nOrcColumnStatistics\n| (children)\n---------------------------------------------\n/         |                 \\                 \\\nc1        c2                 c3                c4\n(integer)    (struct)            (map)             (array)\n(min:1,        | (children)       | (children)      | (children)\nmax:10)      -----              -----             element\n/     \\            /     \\           (integer)\nc2.f1    c2.f2      key     value\n(integer) (float)  (integer) (string)\n(min:0.1,           (min:\"a\",\nmax:100.5)          max:\"zzz\")"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/ObjectBasedValueSource.java",
    "type": "method",
    "name": "getValue",
    "code": "public Object getValue(String expression) {\n        if (expression == null || expression.trim().isEmpty()) {\n            return null;\n        }\n\n        try {\n            return ReflectionValueExtractor.evaluate(expression, root, false);\n        } catch (Exception e) {\n            addFeedback(\"Failed to extract \\'\" + expression + \"\\' from: \" + root, e);\n        }\n\n        return null;\n    }",
    "comment": "<p>Split the expression into parts, tokenized on the dot ('.') character. Then,\nstarting at the root object contained in this value source, apply each part\nto the object graph below this root, using either 'getXXX()' or 'isXXX()'\naccessor types to resolve the value for each successive expression part.\nFinally, return the result of the last expression part's resolution.</p>\n\n<p><b>NOTE:</b> The object-graph navigation actually takes place via the\n{@link ReflectionValueExtractor} class.</p>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/transfer/AbstractMavenTransferListener.java",
    "type": "method",
    "name": "transferSucceeded",
    "code": "public void transferSucceeded(TransferEvent event) {\n        String action = (event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\");\n        String direction = event.getRequestType() == TransferEvent.RequestType.PUT ? \"to\" : \"from\";\n\n        TransferResource resource = event.getResource();\n        long contentLength = event.getTransferredBytes();\n        FileSizeFormat format = new FileSizeFormat();\n\n        MessageBuilder message = messageBuilderFactory.builder();\n        message.append(action).style(STYLE).append(' ').append(direction).append(' ');\n        message.resetStyle().append(resource.getRepositoryId());\n        message.style(STYLE).append(\": \").append(resource.getRepositoryUrl());\n        message.resetStyle().append(resource.getResourceName());\n        message.style(STYLE).append(\" (\").append(format.format(contentLength));\n\n        Duration duration = Duration.between(resource.getStartTime(), MonotonicClock.now());\n        long nanos = duration.toNanos();\n        if (nanos > 0) {\n            double seconds = nanos / (double) TimeUnit.SECONDS.toNanos(1); // Convert to fractional seconds\n            double bytesPerSecond = contentLength / seconds;\n            message.append(\" at \");\n            format.formatRate(message, bytesPerSecond);\n        }\n\n        message.append(')').resetStyle();\n        out.println(message);\n    }",
    "comment": "TODO This needs to be colorized"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/saga/src/main/java/com/iluwatar/saga/choreography/Saga.java",
    "type": "method",
    "name": "getResult",
    "code": "public SagaResult getResult() {\n    if (finished) {\n      return forward ? SagaResult.FINISHED : SagaResult.ROLLBACKED;\n    }\n\n    return SagaResult.PROGRESS;\n  }",
    "comment": "get resuzlt of saga.\n\n@return result of saga @see {@link SagaResult}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/MavenSessionBuilderSupplier.java",
    "type": "method",
    "name": "get",
    "code": "public SessionBuilder get() {\n        requireNonNull(repositorySystem, \"repositorySystem\");\n        SessionBuilder builder = repositorySystem.createSessionBuilder();\n        configureSessionBuilder(builder);\n        return builder;\n    }",
    "comment": "Creates a new Maven-like repository system session by initializing the session with values typical for\nMaven-based resolution. In more detail, this method configures settings relevant for the processing of dependency\ngraphs, most other settings remain at their generic default value. Use the various setters to further configure\nthe session with authentication, mirror, proxy and other information required for your environment. At least,\nlocal repository manager needs to be configured to make session be able to create session instance.\n\n@return SessionBuilder configured with minimally required things for \"Maven-based resolution\". At least LRM must\nbe set on builder to make it able to create session instances."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Object expected, Object actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If both are {@code null}, they are considered equal.\n\n@see Object#equals(Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "container",
    "code": "public static Condition<Event> container(Condition<Event> condition) {\n\t\treturn allOf(container(), condition);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@linkplain Event#getTestDescriptor() test descriptor} is a\n{@linkplain TestDescriptor#isContainer() container}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultLifecycleExecutionPlanCalculator.java",
    "type": "method",
    "name": "mojoExecutionConfigurator",
    "code": "private MojoExecutionConfigurator mojoExecutionConfigurator(MojoExecution mojoExecution) {\n        String configuratorId = mojoExecution.getMojoDescriptor().getComponentConfigurator();\n        if (configuratorId == null) {\n            configuratorId = \"default\";\n        }\n\n        MojoExecutionConfigurator mojoExecutionConfigurator = mojoExecutionConfigurators.get(configuratorId);\n\n        if (mojoExecutionConfigurator == null) {\n            mojoExecutionConfigurator = mojoExecutionConfigurators.get(\"default\");\n        }\n        return mojoExecutionConfigurator;\n    }",
    "comment": "The plugin has a custom component configurator but does not have a custom mojo execution configurator\nso fall back to the default mojo execution configurator."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/MirrorProcessorTest.java",
    "type": "method",
    "name": "getRepo",
    "code": "private ArtifactRepository getRepo(String id, String url) {\n        return repositorySystem.createArtifactRepository(id, url, new DefaultRepositoryLayout(), null, null);\n    }",
    "comment": "Build an ArtifactRepository object.\n\n@param id\n@param url\n@return"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/GeneralScalarExpression.java",
    "type": "method",
    "name": "GeneralScalarExpression",
    "code": "public GeneralScalarExpression(String name, Expression[] children) {\n    this.name = name;\n    this.children = children;\n  }",
    "comment": "The general representation of SQL scalar expressions, which contains the upper-cased\nexpression name and all the children expressions. Please also see {@link Predicate}\nfor the supported predicate expressions.\n<p>\nThe currently supported SQL scalar expressions:\n<ol>\n<li>Name: <code>+</code>\n<ul>\n<li>SQL semantic: <code>expr1 + expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>-</code>\n<ul>\n<li>SQL semantic: <code>expr1 - expr2</code> or <code>- expr</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>*</code>\n<ul>\n<li>SQL semantic: <code>expr1 * expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>/</code>\n<ul>\n<li>SQL semantic: <code>expr1 / expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>%</code>\n<ul>\n<li>SQL semantic: <code>expr1 % expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>&amp;</code>\n<ul>\n<li>SQL semantic: <code>expr1 &amp; expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>|</code>\n<ul>\n<li>SQL semantic: <code>expr1 | expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>^</code>\n<ul>\n<li>SQL semantic: <code>expr1 ^ expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>~</code>\n<ul>\n<li>SQL semantic: <code>~ expr</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>CASE_WHEN</code>\n<ul>\n<li>SQL semantic:\n<code>CASE WHEN expr1 THEN expr2 [WHEN expr3 THEN expr4]* [ELSE expr5] END</code>\n</li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>ABS</code>\n<ul>\n<li>SQL semantic: <code>ABS(expr)</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>COALESCE</code>\n<ul>\n<li>SQL semantic: <code>COALESCE(expr1, expr2)</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>GREATEST</code>\n<ul>\n<li>SQL semantic: <code>GREATEST(expr, ...)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>LEAST</code>\n<ul>\n<li>SQL semantic: <code>LEAST(expr, ...)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>RAND</code>\n<ul>\n<li>SQL semantic: <code>RAND([seed])</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>LOG</code>\n<ul>\n<li>SQL semantic: <code>LOG(base, expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>LOG10</code>\n<ul>\n<li>SQL semantic: <code>LOG10(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>LOG2</code>\n<ul>\n<li>SQL semantic: <code>LOG2(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>LN</code>\n<ul>\n<li>SQL semantic: <code>LN(expr)</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>EXP</code>\n<ul>\n<li>SQL semantic: <code>EXP(expr)</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>POWER</code>\n<ul>\n<li>SQL semantic: <code>POWER(expr, number)</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>SQRT</code>\n<ul>\n<li>SQL semantic: <code>SQRT(expr)</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>FLOOR</code>\n<ul>\n<li>SQL semantic: <code>FLOOR(expr)</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>CEIL</code>\n<ul>\n<li>SQL semantic: <code>CEIL(expr)</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>ROUND</code>\n<ul>\n<li>SQL semantic: <code>ROUND(expr, [scale])</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>SIN</code>\n<ul>\n<li>SQL semantic: <code>SIN(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>SINH</code>\n<ul>\n<li>SQL semantic: <code>SINH(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>COS</code>\n<ul>\n<li>SQL semantic: <code>COS(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>COSH</code>\n<ul>\n<li>SQL semantic: <code>COSH(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>TAN</code>\n<ul>\n<li>SQL semantic: <code>TAN(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>TANH</code>\n<ul>\n<li>SQL semantic: <code>TANH(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>COT</code>\n<ul>\n<li>SQL semantic: <code>COT(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>ASIN</code>\n<ul>\n<li>SQL semantic: <code>ASIN(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>ASINH</code>\n<ul>\n<li>SQL semantic: <code>ASINH(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>ACOS</code>\n<ul>\n<li>SQL semantic: <code>ACOS(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>ACOSH</code>\n<ul>\n<li>SQL semantic: <code>ACOSH(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>ATAN</code>\n<ul>\n<li>SQL semantic: <code>ATAN(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>ATANH</code>\n<ul>\n<li>SQL semantic: <code>ATANH(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>ATAN2</code>\n<ul>\n<li>SQL semantic: <code>ATAN2(exprY, exprX)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>CBRT</code>\n<ul>\n<li>SQL semantic: <code>CBRT(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>DEGREES</code>\n<ul>\n<li>SQL semantic: <code>DEGREES(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>RADIANS</code>\n<ul>\n<li>SQL semantic: <code>RADIANS(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>SIGN</code>\n<ul>\n<li>SQL semantic: <code>SIGN(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>WIDTH_BUCKET</code>\n<ul>\n<li>SQL semantic: <code>WIDTH_BUCKET(expr)</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>SUBSTRING</code>\n<ul>\n<li>SQL semantic: <code>SUBSTRING(str, pos[, len])</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>UPPER</code>\n<ul>\n<li>SQL semantic: <code>UPPER(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>LOWER</code>\n<ul>\n<li>SQL semantic: <code>LOWER(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>TRANSLATE</code>\n<ul>\n<li>SQL semantic: <code>TRANSLATE(input, from, to)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>TRIM</code>\n<ul>\n<li>SQL semantic: <code>TRIM(src, trim)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>LTRIM</code>\n<ul>\n<li>SQL semantic: <code>LTRIM(src, trim)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>RTRIM</code>\n<ul>\n<li>SQL semantic: <code>RTRIM(src, trim)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>BIT_LENGTH</code>\n<ul>\n<li>SQL semantic: <code>BIT_LENGTH(src)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>CHAR_LENGTH</code>\n<ul>\n<li>SQL semantic: <code>CHAR_LENGTH(src)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>CONCAT</code>\n<ul>\n<li>SQL semantic: <code>CONCAT(col1, col2, ..., colN)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>OVERLAY</code>\n<ul>\n<li>SQL semantic: <code>OVERLAY(string, replace, position[, length])</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>DATE_ADD</code>\n<ul>\n<li>SQL semantic: <code>DATE_ADD(start_date, num_days)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>DATE_DIFF</code>\n<ul>\n<li>SQL semantic: <code>DATE_DIFF(end_date, start_date)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>TRUNC</code>\n<ul>\n<li>SQL semantic: <code>TRUNC(date, format)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>AES_ENCRYPT</code>\n<ul>\n<li>SQL semantic: <code>AES_ENCRYPT(expr, key[, mode[, padding]])</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>AES_DECRYPT</code>\n<ul>\n<li>SQL semantic: <code>AES_DECRYPT(expr, key[, mode[, padding]])</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>SHA1</code>\n<ul>\n<li>SQL semantic: <code>SHA1(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>SHA2</code>\n<ul>\n<li>SQL semantic: <code>SHA2(expr, bitLength)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>MD5</code>\n<ul>\n<li>SQL semantic: <code>MD5(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>CRC32</code>\n<ul>\n<li>SQL semantic: <code>CRC32(expr)</code></li>\n<li>Since version: 3.4.0</li>\n</ul>\n</li>\n<li>Name: <code>LPAD</code>\n<ul>\n<li>SQL semantic: <code>LPAD(str, len[, pad])</code></li>\n<li>Since version: 4.0.0</li>\n</ul>\n</li>\n<li>Name: <code>RPAD</code>\n<ul>\n<li>SQL semantic: <code>RPAD(str, len[, pad])</code></li>\n<li>Since version: 4.0.0</li>\n</ul>\n</li>\n</ol>\nNote: SQL semantic conforms ANSI standard, so some expressions are not supported when ANSI off,\nincluding: add, subtract, multiply, divide, remainder, pmod.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelData.java",
    "type": "method",
    "name": "getId",
    "code": "public String getId() {\n        StringBuilder buffer = new StringBuilder(128);\n\n        buffer.append(getGroupId())\n                .append(':')\n                .append(getArtifactId())\n                .append(':')\n                .append(getVersion());\n\n        return buffer.toString();\n    }",
    "comment": "Gets the effective identifier of the model in the form {@code <groupId>:<artifactId>:<version>}.\n\n@return The effective identifier of the model, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertThrowsExactlyAssertionsTests.java",
    "type": "method",
    "name": "assertThrowsExactlyTheSpecifiedExceptionClass",
    "code": "void assertThrowsExactlyTheSpecifiedExceptionClass() {\n\t\tvar actual = assertThrowsExactly(EnigmaThrowable.class, () -> {\n\t\t\tthrow new EnigmaThrowable();\n\t\t});\n\t\tassertNotNull(actual);\n\t}",
    "comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetReadState.java",
    "type": "method",
    "name": "nextRange",
    "code": "void nextRange() {\n    if (rowRanges == null) {\n      currentRange = MAX_ROW_RANGE;\n    } else if (!rowRanges.hasNext()) {\n      currentRange = END_ROW_RANGE;\n    } else {\n      currentRange = rowRanges.next();\n    }\n  }",
    "comment": "Advance to the next range."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/resources/mng-3724/maven-mng3724-plugin/src/main/java/jar/AbstractMng2734Mojo.java",
    "type": "method",
    "name": "getGeneratorTargetDir",
    "code": "protected final File getGeneratorTargetDir() {\n        return generatorTargetDir;\n    }",
    "comment": "Location of the file.\n@parameter expression=\"${project.build.directory}/generated/src/main/java\"\n@required"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/PackageNameFilter.java",
    "type": "method",
    "name": "includePackageNames",
    "code": "static PackageNameFilter includePackageNames(String... names) {\n\t\treturn new IncludePackageNameFilter(names);\n\t}",
    "comment": "Create a new <em>include</em> {@link PackageNameFilter} based on the\n@see Package#getName()\n@see #includePackageNames(List)\n@see #excludePackageNames(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-stub/src/main/java/com/iluwatar/servicestub/StubSentimentAnalysisServer.java",
    "type": "method",
    "name": "analyzeSentiment",
    "code": "public String analyzeSentiment(String text) {\n    if (text.toLowerCase().contains(\"good\")) {\n      return \"Positive\";\n    } else if (text.toLowerCase().contains(\"bad\")) {\n      return \"Negative\";\n    } else {\n      return \"Neutral\";\n    }\n  }",
    "comment": "Fake sentiment analyzer, always returns \"Positive\" if input string contains the word \"good\",\n\"Negative\" if the string contains \"bad\" and \"Neutral\" otherwise.\n\n@param text the input string to analyze\n@return sentiment classification result (Positive, Negative, or Neutral)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/LifecycleConfiguration.java",
    "type": "method",
    "name": "setModelEncoding",
    "code": "public void setModelEncoding(String modelEncoding) {\n        this.modelEncoding = modelEncoding;\n    } // -- void setModelEncoding( String )",
    "comment": "Set the modelEncoding field.\n\n@param modelEncoding a modelEncoding object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/execution/sort/RecordBinaryComparatorSuite.java",
    "type": "method",
    "name": "computeSizeInBytes",
    "code": "private int computeSizeInBytes(int originalSize) {\n    return 8 + (originalSize + 7) / 8 * 8;\n  }",
    "comment": "Compute the most compact size for UnsafeRow's backing data.\nAll the UnsafeRows in this suite contains less than 64 columns, so the bitSetSize shall\nalways be 8."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/test/java/com/iluwatar/RegisterWorkerTest.java",
    "type": "method",
    "name": "runSuccessfully",
    "code": "void runSuccessfully() {\n    RegisterWorkerDto validWorkerDto = createValidWorkerDto();\n    validWorkerDto.setupWorkerDto(\"name\", \"occupation\", LocalDate.of(2000, 12, 1));\n    RegisterWorker registerWorker = new RegisterWorker(validWorkerDto);\n\n    registerWorker.run();\n\n    assertFalse(registerWorker.getNotification().hasErrors());\n  }",
    "comment": "Run the registration process\nVerify that there are no errors in the notification"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/test/java/org/apache/maven/slf4j/MavenBaseLoggerTimestampTest.java",
    "type": "method",
    "name": "setUp",
    "code": "void setUp() {\n        System.clearProperty(Constants.MAVEN_LOGGER_SHOW_DATE_TIME);\n        System.clearProperty(Constants.MAVEN_LOGGER_DATE_TIME_FORMAT);\n\n        MavenBaseLogger.initialized = false;\n\n        logOutput = new ByteArrayOutputStream();\n        originalErr = System.err;\n        System.setErr(new PrintStream(logOutput));\n    }",
    "comment": "Reset configuration before each test\nReset static initialization flag\nCapture System.err"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/SimpleTest.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n        fValue1 = 2;\n        fValue2 = 3;\n    }",
    "comment": "Some simple tests.\n\n<p>This test is expected to fail."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/PartitionReaderFactory.java",
    "type": "method",
    "name": "supportColumnarReads",
    "code": "default boolean supportColumnarReads(InputPartition partition) {\n    return false;\n  }",
    "comment": "Returns true if the given {@link InputPartition} should be read by Spark in a columnar way.\nThis means, implementations must also implement {@link #createColumnarReader(InputPartition)}\nfor the input partitions that this method returns true.\n<p>\nAs of Spark 2.4, Spark can only read all input partition in a columnar way, or none of them.\nData source can't mix columnar and row-based partitions. This may be relaxed in future\nversions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "tryToGetResources",
    "code": "public static Try<Set<Resource>> tryToGetResources(String classpathResourceName) {\n\t\treturn tryToGetResources(classpathResourceName, ClassLoaderUtils.getDefaultClassLoader());\n\t}",
    "comment": "Try to get {@linkplain Resource resources} by their name, using the\n{@link ClassLoaderUtils#getDefaultClassLoader()}.\n\n<p>See {@link org.junit.platform.commons.support.ReflectionSupport#tryToGetResources(String)}\nfor details.\n\n@param classpathResourceName the name of the resources to load; never {@code null} or blank\n@since 1.12\n@see org.junit.platform.commons.support.ReflectionSupport#tryToGetResources(String, ClassLoader)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/api/services/model/ModelResolverException.java",
    "type": "method",
    "name": "ModelResolverException",
    "code": "public ModelResolverException(Throwable cause, String groupId, String artifactId, String version) {\n        super(cause);\n        this.groupId = groupId;\n        this.artifactId = artifactId;\n        this.version = version;\n    }",
    "comment": "Creates a new exception with specified cause\n\n@param cause\n@param groupId\n@param artifactId\n@param version"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertNotNull",
    "code": "public static void assertNotNull(Object object) {\n        Assert.assertNotNull(object);\n    }",
    "comment": "Asserts that an object isn't null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/ServiceOperations.java",
    "type": "method",
    "name": "stop",
    "code": "public static void stop(Service service) {\n    if (service != null) {\n      Service.STATE state = service.getServiceState();\n      if (state == Service.STATE.STARTED) {\n        service.stop();\n      }\n    }\n  }",
    "comment": "Stop a service.\n\nDo nothing if the service is null or not in a state in which it can be/needs to be stopped.\n\nThe service state is checked <i>before</i> the operation begins.\nThis process is <i>not</i> thread safe.\n@param service a service or null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProblemCollector.java",
    "type": "method",
    "name": "create",
    "code": "static <P extends BuilderProblem> ProblemCollector<P> create(int maxCountLimit) {\n        return new Impl<>(maxCountLimit);\n    }",
    "comment": "Creates new instance of problem collector with the specified maximum problem count limit.\nVisible for testing only.\n\n@param <P> the type of problem\n@param maxCountLimit the maximum number of problems to preserve\n@return a new problem collector instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setMap",
    "code": "public void setMap(ColumnarMap value) {\n    mapData = value;\n  }",
    "comment": "Sets the `ColumnarMap` `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/AnnotationSupport.java",
    "type": "method",
    "name": "findAnnotatedFields",
    "code": "public static List<Field> findAnnotatedFields(Class<?> clazz, Class<? extends Annotation> annotationType) {\n\t\treturn findAnnotatedFields(clazz, annotationType, field -> true);\n\t}",
    "comment": "Find all distinct {@linkplain Field fields} of the supplied class or\ninterface that are annotated or <em>meta-annotated</em> with the specified\n{@code annotationType}, using top-down search semantics within the type\nhierarchy.\n\n<p>Fields declared in the same class or interface will be ordered using\nan algorithm that is deterministic but intentionally nonobvious.\n\n<p>The results will not contain fields that are <em>hidden</em> or\n{@linkplain Field#isSynthetic() synthetic}.\n\n@param clazz the class or interface in which to find the fields; never {@code null}\n@param annotationType the annotation type to search for; never {@code null}\n@return the list of all such fields found; neither {@code null} nor mutable\n@since 1.4\n@see Class#getDeclaredFields()\n@see #findPublicAnnotatedFields(Class, Class, Class)\n@see #findAnnotatedFields(Class, Class, Predicate, HierarchyTraversalMode)\n@see ReflectionSupport#findFields(Class, Predicate, HierarchyTraversalMode)\n@see ReflectionSupport#tryToReadFieldValue(Field, Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java",
    "type": "method",
    "name": "resolveParameter",
    "code": "public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tClass<?> parameterType = parameterContext.getParameter().getType();\n\t\tassertSupportedType(\"parameter\", parameterType);\n\t\tCleanupMode cleanupMode = determineCleanupModeForParameter(parameterContext);\n\t\tScope scope = getScope(extensionContext);\n\t\tTempDirFactory factory = determineTempDirFactoryForParameter(parameterContext, scope);\n\t\treturn getPathOrFile(parameterType, parameterContext, factory, cleanupMode, scope, extensionContext);\n\t}",
    "comment": "Resolve the current temporary directory for the {@link Parameter} in the\nsupplied {@link ParameterContext}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/main/java/com/iluwatar/circuitbreaker/MonitoringService.java",
    "type": "method",
    "name": "localResourceResponse",
    "code": "public String localResourceResponse() {\n    return \"Local Service is working\";\n  }",
    "comment": "Assumption: Local service won't fail, no need to wrap it in a circuit breaker logic"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcPrivateKeyPassword",
    "code": "public String sslRpcPrivateKeyPassword() {\n    return conf.get(\"spark.ssl.rpc.privateKeyPassword\", null);\n  }",
    "comment": "The password to the private key"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertDoesNotThrow",
    "code": "public static <T> T assertDoesNotThrow(ThrowingSupplier<T> supplier, Supplier<String> messageSupplier) {\n\t\treturn AssertDoesNotThrow.assertDoesNotThrow(supplier, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code supplier} does\n<em>not</em> throw any kind of {@linkplain Throwable exception}.\n\n<p>If the assertion passes, the {@code supplier}'s result will be returned.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n<h4>Usage Note</h4>\n<p>Although any exception thrown from a test method will cause the test\nto <em>fail</em>, there are certain use cases where it can be beneficial\nto explicitly assert that an exception is not thrown for a given code\nblock within a test method.\n\n@since 5.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaALS.java",
    "type": "method",
    "name": "call",
    "code": "public Rating call(String line) {\n      String[] tok = COMMA.split(line);\n      int x = Integer.parseInt(tok[0]);\n      int y = Integer.parseInt(tok[1]);\n      double rating = Double.parseDouble(tok[2]);\n      return new Rating(x, y, rating);\n    }",
    "comment": "Example using MLlib ALS from Java."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/OrderController.java",
    "type": "method",
    "name": "checkout",
    "code": "public Order checkout(final String userId) {\n    return shoppingCartUseCase.checkout(userId);\n  }",
    "comment": "Processes the checkout for a given user and creates an order.\n\n@param userId The ID of the user checking out.\n@return The created {@link Order} after checkout."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/UnsafeAlignedOffset.java",
    "type": "method",
    "name": "setUaoSize",
    "code": "public static void setUaoSize(int size) {\n    assert size == 0 || size == 4 || size == 8;\n    TEST_UAO_SIZE = size;\n  }",
    "comment": "Class to make changes to record length offsets uniform through out\nvarious areas of Apache Spark core and unsafe.  The SPARC platform\nrequires this because using a 4 byte Int for record lengths causes\nthe entire record of 8 byte Items to become misaligned by 4 bytes.\nUsing a 8 byte long for record length keeps things 8 byte aligned."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "nullSafeToString",
    "code": "public static String nullSafeToString(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn \"null\";\n\t\t}\n\n\t\ttry {\n\t\t\tif (obj.getClass().isArray()) {\n\t\t\t\tif (obj.getClass().getComponentType().isPrimitive()) {\n\t\t\t\t\tif (obj instanceof boolean[]) {\n\t\t\t\t\t\treturn Arrays.toString((boolean[]) obj);\n\t\t\t\t\t}\n\t\t\t\t\tif (obj instanceof char[]) {\n\t\t\t\t\t\treturn Arrays.toString((char[]) obj);\n\t\t\t\t\t}\n\t\t\t\t\tif (obj instanceof short[]) {\n\t\t\t\t\t\treturn Arrays.toString((short[]) obj);\n\t\t\t\t\t}\n\t\t\t\t\tif (obj instanceof byte[]) {\n\t\t\t\t\t\treturn Arrays.toString((byte[]) obj);\n\t\t\t\t\t}\n\t\t\t\t\tif (obj instanceof int[]) {\n\t\t\t\t\t\treturn Arrays.toString((int[]) obj);\n\t\t\t\t\t}\n\t\t\t\t\tif (obj instanceof long[]) {\n\t\t\t\t\t\treturn Arrays.toString((long[]) obj);\n\t\t\t\t\t}\n\t\t\t\t\tif (obj instanceof float[]) {\n\t\t\t\t\t\treturn Arrays.toString((float[]) obj);\n\t\t\t\t\t}\n\t\t\t\t\tif (obj instanceof double[]) {\n\t\t\t\t\t\treturn Arrays.toString((double[]) obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Arrays.deepToString((Object[]) obj);\n\t\t\t}\n\n\t\t\t// else\n\t\t\tString result = obj.toString();\n\t\t\treturn result != null ? result : \"null\";\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(throwable);\n\n\t\t\treturn defaultToString(obj);\n\t\t}\n\t}",
    "comment": "Convert the supplied {@code Object} to a {@code String} using the\nfollowing algorithm.\n\n<ul>\n<li>If the supplied object is {@code null}, this method returns {@code \"null\"}.</li>\n<li>If the supplied object is a primitive array, the appropriate\n{@code Arrays#toString(...)} variant will be used to convert it to a String.</li>\n<li>If the supplied object is an object array, {@code Arrays#deepToString(Object[])}\nwill be used to convert it to a String.</li>\n<li>Otherwise, {@code toString()} will be invoked on the object. If the\nresult is non-null, that result will be returned. If the result is\n{@code null}, {@code \"null\"} will be returned.</li>\n<li>If any of the above results in an exception, this method delegates to\n{@link #defaultToString(Object)}</li>\n</ul>\n\n@param obj the object to convert to a String; may be {@code null}\n@return a String representation of the supplied object; never {@code null}\n@see Arrays#deepToString(Object[])\n@see ClassUtils#nullSafeToString(Class...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-builder-support/src/test/java/org/apache/maven/building/DefaultProblemTest.java",
    "type": "method",
    "name": "testGetLineNumber",
    "code": "void testGetLineNumber() {\n        DefaultProblem problem = new DefaultProblem(null, null, null, -1, -1, null);\n        assertEquals(-1, problem.getLineNumber());\n\n        problem = new DefaultProblem(null, null, null, 42, -1, null);\n        assertEquals(42, problem.getLineNumber());\n\n        problem = new DefaultProblem(null, null, null, Integer.MAX_VALUE, -1, null);\n        assertEquals(Integer.MAX_VALUE, problem.getLineNumber());\n\n        problem = new DefaultProblem(null, null, null, Integer.MIN_VALUE, -1, null);\n        assertEquals(Integer.MIN_VALUE, problem.getLineNumber());\n    }",
    "comment": "this case is not specified, might also return -1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/types/UTF8StringSuite.java",
    "type": "method",
    "name": "substring_index",
    "code": "public void substring_index() {\n    assertEquals(fromString(\"www.apache.org\"),\n      fromString(\"www.apache.org\").subStringIndex(fromString(\".\"), 3));\n    assertEquals(fromString(\"www.apache\"),\n      fromString(\"www.apache.org\").subStringIndex(fromString(\".\"), 2));\n    assertEquals(fromString(\"www\"),\n      fromString(\"www.apache.org\").subStringIndex(fromString(\".\"), 1));\n    assertEquals(fromString(\"\"),\n      fromString(\"www.apache.org\").subStringIndex(fromString(\".\"), 0));\n    assertEquals(fromString(\"org\"),\n      fromString(\"www.apache.org\").subStringIndex(fromString(\".\"), -1));\n    assertEquals(fromString(\"apache.org\"),\n      fromString(\"www.apache.org\").subStringIndex(fromString(\".\"), -2));\n    assertEquals(fromString(\"www.apache.org\"),\n      fromString(\"www.apache.org\").subStringIndex(fromString(\".\"), -3));\n    assertEquals(fromString(\"\"),\n      fromString(\"\").subStringIndex(fromString(\".\"), 1));\n    assertEquals(fromString(\"\"),\n      fromString(\"www.apache.org\").subStringIndex(fromString(\"\"), 1));\n    assertEquals(fromString(\"www.apache.org\"),\n      fromString(\"www.apache.org\").subStringIndex(fromString(\"#\"), 2));\n    assertEquals(fromString(\"www||apache\"),\n      fromString(\"www||apache||org\").subStringIndex(fromString(\"||\"), 2));\n    assertEquals(fromString(\"apache||org\"),\n      fromString(\"www||apache||org\").subStringIndex(fromString(\"||\"), -2));\n    assertEquals(fromString(\"\"),\n      fromString(\"\").subStringIndex(fromString(\"\"), 2));\n    assertEquals(fromString(\"||\"), fromString(\"||||||\").subStringIndex(fromString(\"|||\"), 3));\n    assertEquals(fromString(\"|||\"), fromString(\"||||||\").subStringIndex(fromString(\"|||\"), -4));\n  }",
    "comment": "str is empty string\nempty string delim\ndelim does not exist in str\ndelim is 2 chars\nnon ascii chars\noverlapped delim"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelData.java",
    "type": "method",
    "name": "getArtifactId",
    "code": "public String getArtifactId() {\n        return (artifactId != null) ? artifactId : \"\";\n    }",
    "comment": "Gets the effective artifact identifier of the model.\n\n@return The effective artifact identifier of the model or an empty string if unknown, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java",
    "type": "method",
    "name": "populateRequest",
    "code": "private MavenExecutionRequest populateRequest(CliRequest cliRequest, MavenExecutionRequest request) {\n        slf4jLoggerFactory = LoggerFactory.getILoggerFactory();\n        CommandLine commandLine = cliRequest.commandLine;\n        String workingDirectory = cliRequest.workingDirectory;\n        boolean quiet = cliRequest.quiet;\n        boolean verbose = cliRequest.verbose;\n        request.setShowErrors(cliRequest.showErrors); // default: false\n        File baseDirectory = new File(workingDirectory, \"\").getAbsoluteFile();\n\n        disableInteractiveModeIfNeeded(cliRequest, request);\n        enableOnPresentOption(commandLine, CLIManager.SUPPRESS_SNAPSHOT_UPDATES, request::setNoSnapshotUpdates);\n        request.setGoals(commandLine.getArgList());\n        request.setReactorFailureBehavior(determineReactorFailureBehaviour(commandLine));\n        disableOnPresentOption(commandLine, CLIManager.NON_RECURSIVE, request::setRecursive);\n        enableOnPresentOption(commandLine, CLIManager.OFFLINE, request::setOffline);\n        enableOnPresentOption(commandLine, CLIManager.UPDATE_SNAPSHOTS, request::setUpdateSnapshots);\n        request.setGlobalChecksumPolicy(determineGlobalCheckPolicy(commandLine));\n        request.setBaseDirectory(baseDirectory);\n        request.setSystemProperties(cliRequest.systemProperties);\n        request.setUserProperties(cliRequest.userProperties);\n        request.setMultiModuleProjectDirectory(cliRequest.multiModuleProjectDirectory);\n        request.setRootDirectory(cliRequest.rootDirectory);\n        request.setTopDirectory(cliRequest.topDirectory);\n        request.setPom(determinePom(commandLine, workingDirectory, baseDirectory));\n        request.setTransferListener(determineTransferListener(quiet, verbose, commandLine, request));\n        request.setExecutionListener(determineExecutionListener());\n\n        if ((request.getPom() != null) && (request.getPom().getParentFile() != null)) {\n            request.setBaseDirectory(request.getPom().getParentFile());\n        }\n\n        request.setResumeFrom(commandLine.getOptionValue(CLIManager.RESUME_FROM));\n        enableOnPresentOption(commandLine, CLIManager.RESUME, request::setResume);\n        request.setMakeBehavior(determineMakeBehavior(commandLine));\n        boolean cacheNotFound = !commandLine.hasOption(CLIManager.CACHE_ARTIFACT_NOT_FOUND)\n                || Boolean.parseBoolean(commandLine.getOptionValue(CLIManager.CACHE_ARTIFACT_NOT_FOUND));\n        request.setCacheNotFound(cacheNotFound);\n        request.setCacheTransferError(false);\n        boolean strictArtifactDescriptorPolicy = commandLine.hasOption(CLIManager.STRICT_ARTIFACT_DESCRIPTOR_POLICY)\n                && Boolean.parseBoolean(commandLine.getOptionValue(CLIManager.STRICT_ARTIFACT_DESCRIPTOR_POLICY));\n        if (strictArtifactDescriptorPolicy) {\n            request.setIgnoreMissingArtifactDescriptor(false);\n            request.setIgnoreInvalidArtifactDescriptor(false);\n        } else {\n            request.setIgnoreMissingArtifactDescriptor(true);\n            request.setIgnoreInvalidArtifactDescriptor(true);\n        }\n        enableOnPresentOption(\n                commandLine, CLIManager.IGNORE_TRANSITIVE_REPOSITORIES, request::setIgnoreTransitiveRepositories);\n\n        performProjectActivation(commandLine, request.getProjectActivation());\n        performProfileActivation(commandLine, request.getProfileActivation());\n\n        final String localRepositoryPath = determineLocalRepositoryPath(request);\n        if (localRepositoryPath != null) {\n            request.setLocalRepositoryPath(localRepositoryPath);\n        }\n\n        final String threadConfiguration = commandLine.getOptionValue(CLIManager.THREADS);\n\n        if (threadConfiguration != null) {\n            int degreeOfConcurrency = calculateDegreeOfConcurrency(threadConfiguration);\n            if (degreeOfConcurrency > 1) {\n                request.setBuilderId(\"multithreaded\");\n                request.setDegreeOfConcurrency(degreeOfConcurrency);\n            }\n        }\n\n        request.setBuilderId(commandLine.getOptionValue(CLIManager.BUILDER, request.getBuilderId()));\n\n        return request;\n    }",
    "comment": "Builder, concurrency and parallelism\n\nWe preserve the existing methods for builder selection which is to look for various inputs in the threading\nconfiguration. We don't have an easy way to allow a pluggable builder to provide its own configuration\nparameters but this is sufficient for now. Ultimately we want components like Builders to provide a way to\nextend the command line to accept its own configuration parameters.\n\n\nAllow the builder to be overridden by the user if requested. The builders are now pluggable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/commander/src/main/java/com/iluwatar/commander/employeehandle/EmployeeHandle.java",
    "type": "method",
    "name": "EmployeeHandle",
    "code": "public EmployeeHandle(EmployeeDatabase db, Exception... exc) {\n    super(db, exc);\n  }",
    "comment": "The EmployeeHandle class is the middle-man between {@link com.iluwatar.commander.Commander} and\n{@link EmployeeDatabase}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/RepeatedTestsDemo.java",
    "type": "method",
    "name": "beforeEach",
    "code": "void beforeEach(TestInfo testInfo, RepetitionInfo repetitionInfo) {\n\t\tint currentRepetition = repetitionInfo.getCurrentRepetition();\n\t\tint totalRepetitions = repetitionInfo.getTotalRepetitions();\n\t\tString methodName = testInfo.getTestMethod().get().getName();\n\t\tlogger.info(String.format(\"About to execute repetition %d of %d for %s\", //\n\t\t\tcurrentRepetition, totalRepetitions, methodName));\n\t}",
    "comment": "tag::user_guide[]\nend::user_guide[]\nUse fully qualified names to avoid having them show up in the imports.\ntag::user_guide[]\nend::user_guide[]\ntag::user_guide[]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "escapeJava",
    "code": "protected static String escapeJava(String str) {\n        if (str == null) {\n            return null;\n        }\n        int sz = str.length();\n        StringBuilder out = new StringBuilder(sz * 2);\n        for (int i = 0; i < sz; i++) {\n            char ch = str.charAt(i);\n            // handle unicode\n            if (ch > 0xfff) {\n                out.append(\"\\\\u\").append(hex(ch));\n            } else if (ch > 0xff) {\n                out.append(\"\\\\u0\").append(hex(ch));\n            } else if (ch > 0x7f) {\n                out.append(\"\\\\u00\").append(hex(ch));\n            } else if (ch < 32) {\n                switch (ch) {\n                    case '\\b':\n                        out.append('\\\\');\n                        out.append('b');\n                        break;\n                    case '\\n':\n                        out.append('\\\\');\n                        out.append('n');\n                        break;\n                    case '\\t':\n                        out.append('\\\\');\n                        out.append('t');\n                        break;\n                    case '\\f':\n                        out.append('\\\\');\n                        out.append('f');\n                        break;\n                    case '\\r':\n                        out.append('\\\\');\n                        out.append('r');\n                        break;\n                    default:\n                        if (ch > 0xf) {\n                            out.append(\"\\\\u00\").append(hex(ch));\n                        } else {\n                            out.append(\"\\\\u000\").append(hex(ch));\n                        }\n                        break;\n                }\n            } else {\n                switch (ch) {\n                    case '\"':\n                        out.append('\\\\');\n                        out.append('\"');\n                        break;\n                    case '\\\\':\n                        out.append('\\\\');\n                        out.append('\\\\');\n                        break;\n                    default:\n                        out.append(ch);\n                        break;\n                }\n            }\n        }\n        return out.toString();\n    }",
    "comment": "<p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n\n<p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n\n<p>So a tab becomes the characters <code>'\\\\'</code> and\n<code>'t'</code>.</p>\n\n<p>The only difference between Java strings and JavaScript strings\nis that in JavaScript, a single quote must be escaped.</p>\n\n<p>Example:</p>\n<pre>\ninput string: He didn't say, \"Stop!\"\noutput string: He didn't say, \\\"Stop!\\\"\n</pre>\n\n\n@param str  String to escape values in, may be null\n@return String with escaped values, <code>null</code> if null string input"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "rpad",
    "code": "public UTF8String rpad(int len, UTF8String pad) {\n    int spaces = len - this.numChars(); // number of char need to pad\n    if (spaces <= 0 || pad.numBytes() == 0) {\n      // no padding at all, return the substring of the current string\n      return substring(0, len);\n    } else {\n      int padChars = pad.numChars();\n      int count = spaces / padChars; // how many padding string needed\n      // the partial string of the padding\n      UTF8String remain = pad.substring(0, spaces - padChars * count);\n\n      int resultSize =\n        Math.toIntExact((long) numBytes + (long) pad.numBytes * count + remain.numBytes);\n      byte[] data = new byte[resultSize];\n      copyMemory(this.base, this.offset, data, BYTE_ARRAY_OFFSET, this.numBytes);\n      int offset = this.numBytes;\n      int idx = 0;\n      while (idx < count) {\n        copyMemory(pad.base, pad.offset, data, BYTE_ARRAY_OFFSET + offset, pad.numBytes);\n        ++ idx;\n        offset += pad.numBytes;\n      }\n      copyMemory(remain.base, remain.offset, data, BYTE_ARRAY_OFFSET + offset, remain.numBytes);\n\n      return UTF8String.fromBytes(data);\n    }\n  }",
    "comment": "Returns str, right-padded with pad to a length of len\nFor example:\n('hi', 5, '??') =&gt; 'hi???'\n('hi', 1, '??') =&gt; 'h'"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "replace",
    "code": "public UTF8String replace(UTF8String search, UTF8String replace) {\n    if (numBytes == 0 || search.numBytes == 0) {\n      return this;\n    }\n    int start = 0;\n    int end = this.find(search, start);\n    if (end == -1) {\n      return this;\n    }\n    int increase = Math.max(0, replace.numBytes - search.numBytes) * 16;\n    final UTF8StringBuilder buf = new UTF8StringBuilder(numBytes + increase);\n    while (end != -1) {\n      buf.appendBytes(this.base, this.offset + start, end - start);\n      buf.append(replace);\n      start = end + search.numBytes;\n      end = this.find(search, start);\n    }\n    buf.appendBytes(this.base, this.offset + start, numBytes - start);\n    return buf.build();\n  }",
    "comment": "This implementation is loosely based on commons-lang3's StringUtils.replace().\nFind the first occurrence of the search string.\nSearch string was not found, so string is unchanged.\nAt least one match was found. Estimate space needed for result.\nThe 16x multiplier here is chosen to match commons-lang3's implementation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/BlockJUnit4ClassRunnerOverrideTest.java",
    "type": "method",
    "name": "createTest",
    "code": "protected Object createTest(FrameworkMethod method) {\n            final OverrideCreateTest obj = new OverrideCreateTest();\n\n            obj.method = method;\n\n            return obj;\n        }",
    "comment": "Runner for testing override of {@link org.junit.runners.BlockJUnit4ClassRunner#createTest(org.junit.runners.model.FrameworkMethod)}\nby setting the {@link org.junit.runners.model.FrameworkMethod} in a field\nof the test class so it can be compared with the test method that is being\nexecuted."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/ByteArrayWritableChannel.java",
    "type": "method",
    "name": "ByteArrayWritableChannel",
    "code": "public ByteArrayWritableChannel(int size) {\n    this.data = new byte[size];\n  }",
    "comment": "A writable channel that stores the written data in a byte array in memory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java",
    "type": "method",
    "name": "getLastSegment",
    "code": "public Segment getLastSegment() {\n\t\treturn this.segments.get(this.segments.size() - 1);\n\t}",
    "comment": "Get the last {@link Segment} of this {@code UniqueId}.\n\n@return the last {@code Segment}; never {@code null}\n@since 1.5"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/LegacyXmlReportGeneratingListener.java",
    "type": "method",
    "name": "LegacyXmlReportGeneratingListener",
    "code": "public LegacyXmlReportGeneratingListener(Path reportsDir, PrintWriter out) {\n\t\tthis(reportsDir, out, Clock.systemDefaultZone());\n\t}",
    "comment": "{@code LegacyXmlReportGeneratingListener} is a {@link TestExecutionListener} that\ngenerates a separate XML report for each {@linkplain TestPlan#getRoots() root}\nin the {@link TestPlan}.\n\n<p>Note that the generated XML format is compatible with the <em>legacy</em>\nde facto standard for JUnit 4 based test reports that was made popular by the\nAnt build system.\n\n@since 1.4\n@see org.junit.platform.launcher.listeners.LoggingListener\n@see org.junit.platform.launcher.listeners.SummaryGeneratingListener"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java",
    "type": "method",
    "name": "validateOnlyOneConstructor",
    "code": "protected void validateOnlyOneConstructor(List<Throwable> errors) {\n        if (!hasOneConstructor()) {\n            String gripe = \"Test class should have exactly one public constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }",
    "comment": "Adds to {@code errors} if the test class has more than one constructor\n(do not override)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/handler/manager/DefaultArtifactHandlerManager.java",
    "type": "method",
    "name": "getArtifactHandler",
    "code": "public ArtifactHandler getArtifactHandler(String id) {\n        return allHandlers.computeIfAbsent(id, k -> {\n            Type type = typeRegistry.require(id);\n            return new DefaultArtifactHandler(\n                    id,\n                    type.getExtension(),\n                    type.getClassifier(),\n                    null,\n                    null,\n                    type.isIncludesDependencies(),\n                    type.getLanguage().id(),\n                    type.getPathTypes().contains(JavaPathType.CLASSES));\n        });\n\n    }",
    "comment": "TODO: watch out for module path\nNote: here, type decides is artifact added to \"build path\" (for example during resolution)\nand \"build path\" is intermediate data that is used to create actual Java classpath/modulepath\nbut to create those, proper filtering should happen via Type properties."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<String> create(Scope scope, byte[][][][][] data) {\n    return create(scope, data, String.class);\n  }",
    "comment": "Creates a rank-4 constant of {@code String} elements, each represented as an array of {@code byte}s.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "legacyReportingName",
    "code": "public static Condition<Event> legacyReportingName(String legacyReportingName) {\n\t\treturn new Condition<>(\n\t\t\tbyTestDescriptor(where(TestDescriptor::getLegacyReportingName, isEqual(legacyReportingName))),\n\t\t\t\"descriptor with legacy reporting name '%s'\", legacyReportingName);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if the\nof an {@link Event}'s {@linkplain Event#getTestDescriptor() test descriptor}\nis equal to the supplied {@link String}.\n\n@since 1.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/NioServerSocketChannel.java",
    "type": "method",
    "name": "getJavaChannel",
    "code": "public ServerSocketChannel getJavaChannel() {\n    return (ServerSocketChannel) super.getJavaChannel();\n  }",
    "comment": "Get server socket channel.\n\n@return the underlying {@link ServerSocketChannel}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/graph/DefaultGraphBuilderTest.java",
    "type": "method",
    "name": "getMavenProject",
    "code": "private MavenProject getMavenProject(String artifactId, MavenProject parentProject) {\n        MavenProject project = getMavenProject(artifactId);\n        Parent parent = new Parent();\n        parent.setGroupId(parentProject.getGroupId());\n        parent.setArtifactId(parentProject.getArtifactId());\n        project.getModel().setParent(parent);\n        return project;\n    }",
    "comment": "Create projects\nSet up needed mocks\nCreate projects\nSet dependencies and modules\nSet up needed mocks"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-layer/src/test/java/com/iluwatar/servicelayer/common/BaseDaoTest.java",
    "type": "method",
    "name": "BaseDaoTest",
    "code": "public BaseDaoTest(final Function<String, E> factory, final D dao) {\n    this.factory = factory;\n    this.dao = dao;\n  }",
    "comment": "Create a new test using the given factory and dao\n\n@param factory The factory, used to create new entity instances with the given name\n@param dao The tested data access object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "byType",
    "code": "public static Predicate<Event> byType(EventType type) {\n\t\treturn event -> event.type.equals(type);\n\t}",
    "comment": "Create a {@link Predicate} for {@linkplain Event events} whose\n{@linkplain EventType event types} match the supplied {@code type}.\n\n@param type the type to match against\n@return the resulting {@code Predicate}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/sharding/src/main/java/com/iluwatar/sharding/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    var data1 = new Data(1, \"data1\", Data.DataType.TYPE_1);\n    var data2 = new Data(2, \"data2\", Data.DataType.TYPE_2);\n    var data3 = new Data(3, \"data3\", Data.DataType.TYPE_3);\n    var data4 = new Data(4, \"data4\", Data.DataType.TYPE_1);\n\n    var shard1 = new Shard(1);\n    var shard2 = new Shard(2);\n    var shard3 = new Shard(3);\n\n    var manager = new LookupShardManager();\n    manager.addNewShard(shard1);\n    manager.addNewShard(shard2);\n    manager.addNewShard(shard3);\n    manager.storeData(data1);\n    manager.storeData(data2);\n    manager.storeData(data3);\n    manager.storeData(data4);\n\n    shard1.clearData();\n    shard2.clearData();\n    shard3.clearData();\n\n    var rangeShardManager = new RangeShardManager();\n    rangeShardManager.addNewShard(shard1);\n    rangeShardManager.addNewShard(shard2);\n    rangeShardManager.addNewShard(shard3);\n    rangeShardManager.storeData(data1);\n    rangeShardManager.storeData(data2);\n    rangeShardManager.storeData(data3);\n    rangeShardManager.storeData(data4);\n\n    shard1.clearData();\n    shard2.clearData();\n    shard3.clearData();\n\n    var hashShardManager = new HashShardManager();\n    hashShardManager.addNewShard(shard1);\n    hashShardManager.addNewShard(shard2);\n    hashShardManager.addNewShard(shard3);\n    hashShardManager.storeData(data1);\n    hashShardManager.storeData(data2);\n    hashShardManager.storeData(data3);\n    hashShardManager.storeData(data4);\n\n    shard1.clearData();\n    shard2.clearData();\n    shard3.clearData();\n  }",
    "comment": "Program main entry point.\n\n@param args program runtime arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/regression/JavaGBTRegressorSuite.java",
    "type": "method",
    "name": "runDT",
    "code": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 0);\n\n    GBTRegressor rf = new GBTRegressor()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setSubsamplingRate(1.0)\n      .setSeed(1234)\n      .setMaxIter(3)\n      .setStepSize(0.1)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String lossType : GBTRegressor.supportedLossTypes()) {\n      rf.setLossType(lossType);\n    }\n    GBTRegressionModel model = rf.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.totalNumNodes();\n    model.toDebugString();\n    model.trees();\n    model.treeWeights();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model2.save(sc.sc(), path);\n      GBTRegressionModel sameModel = GBTRegressionModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model2, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
    "comment": "TODO: Add test once save/load are implemented.  SPARK-6725"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "getByte",
    "code": "public byte getByte(int byteIndex) {\n    return Platform.getByte(base, offset + byteIndex);\n  }",
    "comment": "Returns the byte at (byte) position `byteIndex`. If byte index is invalid, returns 0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "splitSQL",
    "code": "public UTF8String[] splitSQL(UTF8String delimiter, int limit) {\n    if (delimiter.numBytes() == 0) {\n      return new UTF8String[]{this};\n      return split(Pattern.quote(delimiter.toString()), limit);\n    }\n  }",
    "comment": "if delimiter is empty string, skip the regex based splitting directly as regex\ntreats empty string as matching anything, thus use the input directly.\nwe do not treat delimiter as a regex but consider the whole string of delimiter\nas the separator to split string. Java String's split, however, only accept\nregex as the pattern to split, thus we can quote the delimiter to escape special\ncharacters in the string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/Logger.java",
    "type": "method",
    "name": "getCallerSimpleName",
    "code": "private static String getCallerSimpleName() {\n    // Get the current callstack so we can pull the class of the caller off of it.\n    final StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n\n    for (final StackTraceElement elem : stackTrace) {\n      final String className = elem.getClassName();\n      if (!IGNORED_CLASS_NAMES.contains(className)) {\n        // We're only interested in the simple name of the class, not the complete package.\n        final String[] classParts = className.split(\"\\\\.\");\n        return classParts[classParts.length - 1];\n      }\n    }\n\n    return Logger.class.getSimpleName();\n  }",
    "comment": "Return caller's simple name.\n\nAndroid getStackTrace() returns an array that looks like this:\nstackTrace[0]: dalvik.system.VMStack\nstackTrace[1]: java.lang.Thread\nstackTrace[2]: com.google.android.apps.unveil.env.UnveilLogger\nstackTrace[3]: com.google.android.apps.unveil.BaseApplication\n\nThis function returns the simple version of the first non-filtered name.\n\n@return caller's simple name"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java",
    "type": "method",
    "name": "findMethodsReturnsAllOverloadedMethodsInGenericTypeHieararchy",
    "code": "void findMethodsReturnsAllOverloadedMethodsInGenericTypeHieararchy() {\n\t\t\tClass<?> clazz = InterfaceWithGenericDefaultMethodImpl.class;\n\n\t\t\tvar methods = findMethods(clazz, isFooMethod);\n\n\t\t\tassertThat(signaturesOf(methods)).containsExactly(\"foo(java.lang.Number)\", \"foo(java.lang.Double)\");\n\t\t}",
    "comment": "Search for all foo(*) methods.\nOne might expect or desire that the signature for the generic foo(N)\ndefault method would be \"foo(java.lang.Long)\" when looked up via the\nconcrete parameterized class, but it apparently is only _visible_ as\n\"foo(java.lang.Number)\" via reflection."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/DefaultArtifactVersion.java",
    "type": "method",
    "name": "tryParseInt",
    "code": "private static Integer tryParseInt(String s) {\n        if (!isDigits(s)) {\n            return null;\n        }\n\n        try {\n            long longValue = Long.parseLong(s);\n            if (longValue > Integer.MAX_VALUE) {\n                return null;\n            }\n            return (int) longValue;\n        } catch (NumberFormatException e) {\n            return null;\n        }\n    }",
    "comment": "for performance, check digits instead of relying later on catching NumberFormatException\nshould never happen since checked isDigits(s) before"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/AlbumPage.java",
    "type": "method",
    "name": "changeAlbumTitle",
    "code": "public AlbumPage changeAlbumTitle(String albumTitle) {\n    var albumTitleInputTextField = (HtmlTextInput) page.getElementById(\"albumTitle\");\n    albumTitleInputTextField.setText(albumTitle);\n    return this;\n  }",
    "comment": "Sets the album title input text field.\n\n@param albumTitle the new album title value to set\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/HealthCheckRepositoryTest.java",
    "type": "method",
    "name": "whenCheckHealth_thenReturnsOne",
    "code": "void whenCheckHealth_thenReturnsOne() {\n    // Arrange\n    Query mockedQuery = mock(Query.class);\n    when(entityManager.createNativeQuery(\"SELECT 1\")).thenReturn(mockedQuery);\n    when(mockedQuery.getSingleResult()).thenReturn(1);\n\n    // Act\n    Integer healthCheckResult = healthCheckRepository.checkHealth();\n\n    // Assert\n    assertNotNull(healthCheckResult);\n    assertEquals(1, healthCheckResult);\n  }",
    "comment": "Test case for the `performTestTransaction()` method.\n\n<p>Asserts that when the `performTestTransaction()` method is called, it successfully executes\na test transaction."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Integer> create(Scope scope, int[][][][][] data) {\n    return create(scope, data, Integer.class);\n  }",
    "comment": "Creates a rank-5 constant of {@code int} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/RuntimeUtilsTests.java",
    "type": "method",
    "name": "jmxIsAvailableAndInputArgumentsAreReturned",
    "code": "void jmxIsAvailableAndInputArgumentsAreReturned() {\n\t\tvar optionalArguments = RuntimeUtils.getInputArguments();\n\t\tassertTrue(optionalArguments.isPresent(), \"JMX not available or something else happened...\");\n\t\tvar arguments = optionalArguments.get();\n\t\tassertNotNull(arguments);\n\t}",
    "comment": "Unit tests for {@link RuntimeUtils}.\n\n@since 1.6"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/UTF8StringBuilder.java",
    "type": "method",
    "name": "grow",
    "code": "private void grow(int neededSize) {\n    if (neededSize > ARRAY_MAX - totalSize()) {\n      throw new UnsupportedOperationException(\n        \"Cannot grow internal buffer by size \" + neededSize + \" because the size after growing \" +\n          \"exceeds size limitation \" + ARRAY_MAX);\n    }\n    final int length = totalSize() + neededSize;\n    if (buffer.length < length) {\n      int newLength = length < ARRAY_MAX / 2 ? length * 2 : ARRAY_MAX;\n      final byte[] tmp = new byte[newLength];\n      Platform.copyMemory(\n        buffer,\n        Platform.BYTE_ARRAY_OFFSET,\n        tmp,\n        Platform.BYTE_ARRAY_OFFSET,\n        totalSize());\n      buffer = tmp;\n    }\n  }",
    "comment": "Grows the buffer by at least `neededSize`"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "addColumn",
    "code": "static TableChange addColumn(String[] fieldNames, DataType dataType) {\n    return new AddColumn(fieldNames, dataType, true, null, null, null);\n  }",
    "comment": "Create a TableChange for adding an optional column.\n<p>\nIf the field already exists, the change will result in an {@link IllegalArgumentException}.\nIf the new field is nested and its parent does not exist or is not a struct, the change will\nresult in an {@link IllegalArgumentException}.\n\n@param fieldNames field names of the new column\n@param dataType the new column's data type\n@return a TableChange for the addition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/ColumnDescriptor.java",
    "type": "method",
    "name": "newPrimitiveColumnDescriptor",
    "code": "public static ColumnDescriptor newPrimitiveColumnDescriptor(String name, String comment, Type type, int position) {\n    return new ColumnDescriptor(name, comment, new TypeDescriptor(type), position);\n  }",
    "comment": "Current usage looks like it's only for metadata columns, but if that changes then\nthis method may need to require a type qualifiers arguments."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenFailOnSeverityLogger.java",
    "type": "method",
    "name": "warn",
    "code": "public void warn(String format, Object arg) {\n        super.warn(format, arg);\n        logLevelRecorder.record(Level.WARN);\n    }",
    "comment": "Perform single parameter substitution before logging the message of level\nWARN according to the format outlined above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/pipeline/src/main/java/com/iluwatar/pipeline/RemoveDigitsHandler.java",
    "type": "method",
    "name": "process",
    "code": "public String process(String input) {\n    var inputWithoutDigits = new StringBuilder();\n    var isDigit = (IntPredicate) Character::isDigit;\n    input\n        .chars()\n        .filter(isDigit.negate())\n        .mapToObj(x -> (char) x)\n        .forEachOrdered(inputWithoutDigits::append);\n\n    var inputWithoutDigitsStr = inputWithoutDigits.toString();\n    LOGGER.info(\n        String.format(\n            \"Current handler: %s, input is %s of type %s, output is %s, of type %s\",\n            RemoveDigitsHandler.class, input, String.class, inputWithoutDigitsStr, String.class));\n\n    return inputWithoutDigitsStr;\n  }",
    "comment": "Stage handler that returns a new instance of String without the digit characters of the input\nstring."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/Nested.java",
    "type": "method",
    "name": "getSchema",
    "code": "public org.apache.avro.Schema getSchema() { return SCHEMA$; }\n  public java.lang.Object get(int field$) {\n    switch (field$) {\n    case 0: return nested_ints_column;\n    case 1: return nested_string_column;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumWriter.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/RequestTraceHelper.java",
    "type": "method",
    "name": "interpretTrace",
    "code": "public static String interpretTrace(boolean detailed, RequestTrace requestTrace) {\n        while (requestTrace != null) {\n            Object data = requestTrace.getData();\n            if (data instanceof DependencyRequest request) {\n                return \"dependency resolution for \" + request;\n            } else if (data instanceof CollectRequest request) {\n                return \"dependency collection for \" + request;\n            } else if (data instanceof CollectStepData stepData) {\n                String msg = \"dependency collection step for \" + stepData.getContext();\n                if (detailed) {\n                    msg += \". Path to offending node from root:\\n\";\n                    msg += stepData.getPath().stream()\n                            .map(n -> \" -> \" + n.toString())\n                            .collect(Collectors.joining(\"\\n\"));\n                    msg += \"\\n => \" + stepData.getNode();\n                }\n                return msg;\n            } else if (data instanceof ArtifactDescriptorRequest request) {\n                return \"artifact descriptor request for \" + request.getArtifact();\n            } else if (data instanceof ArtifactRequest request) {\n                return \"artifact request for \" + request.getArtifact();\n            } else if (data instanceof Plugin plugin) {\n                return \"plugin request \" + plugin.getId();\n            }\n            requestTrace = requestTrace.getParent();\n        }\n\n        return \"n/a\";\n    }",
    "comment": "Method that creates some informational string based on passed in {@link RequestTrace}. The contents of request\ntrace can literally be anything, but this class tries to cover \"most common\" cases that are happening in Maven."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Long unexpected, long actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Long) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/ReactorReader.java",
    "type": "method",
    "name": "findArtifact",
    "code": "public File findArtifact(Artifact artifact) {\n        MavenProject project = getProject(artifact);\n\n        if (project != null) {\n            File file = findArtifact(project, artifact, true);\n            if (file == null && project != project.getExecutionProject()) {\n                file = findArtifact(project.getExecutionProject(), artifact, true);\n            }\n            return file;\n        }\n\n        File packagedArtifactFile = findInProjectLocalRepository(artifact);\n        if (packagedArtifactFile != null && packagedArtifactFile.exists()) {\n            project = getProject(artifact, getAllProjects());\n            if (project != null) {\n                isPackagedArtifactUpToDate(project, packagedArtifactFile);\n            }\n            return packagedArtifactFile;\n        }\n\n        return null;\n    }",
    "comment": "No project, but most certainly a dependency which has been built previously\nCheck if artifact is up-to-date"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventStatistics.java",
    "type": "method",
    "name": "aborted",
    "code": "public EventStatistics aborted(long expected) {\n\t\tthis.executables.add(() -> assertEquals(expected, this.events.aborted().count(), \"aborted\"));\n\t\treturn this;\n\t}",
    "comment": "Specify the number of expected <em>aborted</em> events.\n\n@param expected the expected number of events\n@return this {@code EventStatistics} for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/notification/RunNotifier.java",
    "type": "method",
    "name": "fireTestIgnored",
    "code": "public void fireTestIgnored(final Description description) {\n        new SafeNotifier() {\n        }.run();\n    }",
    "comment": "Invoke to tell listeners that an atomic test was ignored.\n\n@param description the description of the ignored test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/model-view-presenter/src/test/java/com/iluwatar/model/view/presenter/FileSelectorPresenterTest.java",
    "type": "method",
    "name": "fileConfirmationWhenNameIsNull",
    "code": "void fileConfirmationWhenNameIsNull() {\n    stub.setFileName(null);\n\n    presenter.start();\n    presenter.fileNameChanged();\n    presenter.confirmed();\n\n    assertFalse(loader.isLoaded());\n    assertEquals(1, stub.getMessagesSent());\n  }",
    "comment": "Tests if we receive a confirmation when we attempt to open a file that it's name is null or an\nempty string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java",
    "type": "method",
    "name": "getOrComputeIfAbsentWithTypeSafetyAndPrimitiveValueType",
    "code": "void getOrComputeIfAbsentWithTypeSafetyAndPrimitiveValueType() {\n\t\t\tString key = \"enigma\";\n\t\t\tint value = 42;\n\n\t\t\tint computedInt = store.getOrComputeIfAbsent(namespace, key, k -> value, int.class);\n\t\t\tInteger computedInteger = store.getOrComputeIfAbsent(namespace, key, k -> value, Integer.class);\n\t\t\tassertEquals(value, computedInt);\n\t\t\tassertEquals(value, computedInteger.intValue());\n\t\t}",
    "comment": "The fact that we can declare this as an int/Integer suffices for testing the required type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/client/TransportClient.java",
    "type": "method",
    "name": "sendRpc",
    "code": "public long sendRpc(ByteBuffer message, RpcResponseCallback callback) {\n    if (logger.isTraceEnabled()) {\n      logger.trace(\"Sending RPC to {}\", getRemoteAddress(channel));\n    }\n\n    long requestId = requestId();\n    handler.addRpcRequest(requestId, callback);\n\n    RpcChannelListener listener = new RpcChannelListener(requestId, callback);\n    channel.writeAndFlush(new RpcRequest(requestId, new NioManagedBuffer(message)))\n      .addListener(listener);\n\n    return requestId;\n  }",
    "comment": "Sends an opaque message to the RpcHandler on the server-side. The callback will be invoked\nwith the server's response or upon any failure.\n\n@param message The message to send.\n@param callback Callback to handle the RPC's reply.\n@return The RPC's id."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestTag.java",
    "type": "method",
    "name": "isValid",
    "code": "public static boolean isValid(String name) {\n\t\tif (name == null) {\n\t\t\treturn false;\n\t\t}\n\t\tname = name.trim();\n\n\t\treturn !name.isEmpty() && //\n\t\t\t\tStringUtils.doesNotContainWhitespace(name) && //\n\t\t\t\tStringUtils.doesNotContainIsoControlCharacter(name) && //\n\t\t\t\tdoesNotContainReservedCharacter(name);\n\t}",
    "comment": "Determine if the supplied tag name is valid with regard to the supported\nsyntax for tags.\n\n<h4>Syntax Rules for Tags</h4>\n<ul>\n<li>A tag must not be {@code null}.</li>\n<li>A tag must not be blank.</li>\n<li>A trimmed tag must not contain whitespace.</li>\n<li>A trimmed tag must not contain ISO control characters.</li>\n<li>A trimmed tag must not contain {@linkplain #RESERVED_CHARACTERS\nreserved characters}.</li>\n</ul>\n\n<p>If this method returns {@code true} for a given name, it is then a\nvalid candidate for the {@link TestTag#create(String) create()} factory\nmethod.\n\n@param name the name of the tag to validate; may be {@code null} or blank\n@return {@code true} if the supplied tag name conforms to the supported\nsyntax for tags\n@see StringUtils#isNotBlank(String)\n@see String#trim()\n@see StringUtils#doesNotContainWhitespace(String)\n@see StringUtils#doesNotContainIsoControlCharacter(String)\n@see #RESERVED_CHARACTERS\n@see TestTag#create(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tooling-support-tests/src/archUnit/java/platform/tooling/support/tests/ArchUnitTests.java",
    "type": "method",
    "name": "avoidAccessingStandardStreams",
    "code": "void avoidAccessingStandardStreams(JavaClasses classes) {\n\t\tvar subset = classes //\n\t\t\t\t.that(are(not(name(\"org.junit.platform.console.ConsoleLauncher\")))) //\n\t\t\t\t.that(are(not(name(\"org.junit.platform.console.tasks.ConsoleTestExecutor\")))) //\n\t\t\t\t.that(are(not(name(\"org.junit.platform.launcher.core.StreamInterceptor\")))) //\n\t\t\t\t.that(are(not(name(\"org.junit.platform.runner.JUnitPlatformRunnerListener\")))) //\n\t\t\t\t.that(are(not(name(\"org.junit.platform.testkit.engine.Events\")))) //\n\t\t\t\t.that(are(not(name(\"org.junit.platform.testkit.engine.Executions\")))) //\n\t\t\t\t.that(are(not(name(\"org.junit.jupiter.engine.extension.PreInterruptThreadDumpPrinter\")))) //\n\t\t\t\t.that(are(not(resideInAPackage(\"org.junit.platform.console.shadow.picocli\"))));\n\t\tGeneralCodingRules.NO_CLASSES_SHOULD_ACCESS_STANDARD_STREAMS.check(subset);\n\t}",
    "comment": "ConsoleLauncher, StreamInterceptor, Picocli et al...\nThe PreInterruptThreadDumpPrinter writes to StdOut by contract to dump threads"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/artifact/factory/DefaultArtifactFactoryTest.java",
    "type": "method",
    "name": "testPropagationOfSystemScopeRegardlessOfInheritedScope",
    "code": "void testPropagationOfSystemScopeRegardlessOfInheritedScope() {\n        Artifact artifact = factory.createDependencyArtifact(\n                \"test-grp\", \"test-artifact\", VersionRange.createFromVersion(\"1.0\"), \"type\", null, \"system\", \"provided\");\n        Artifact artifact2 = factory.createDependencyArtifact(\n                \"test-grp\", \"test-artifact-2\", VersionRange.createFromVersion(\"1.0\"), \"type\", null, \"system\", \"test\");\n        Artifact artifact3 = factory.createDependencyArtifact(\n                \"test-grp\",\n                \"test-artifact-3\",\n                VersionRange.createFromVersion(\"1.0\"),\n                \"type\",\n                null,\n                \"system\",\n                \"runtime\");\n        Artifact artifact4 = factory.createDependencyArtifact(\n                \"test-grp\",\n                \"test-artifact-4\",\n                VersionRange.createFromVersion(\"1.0\"),\n                \"type\",\n                null,\n                \"system\",\n                \"compile\");\n\n        Artifact artifact5 = factory.createDependencyArtifact(\n                \"test-grp\", \"test-artifact-5\", VersionRange.createFromVersion(\"1.0\"), \"type\", null, \"system\", \"system\");\n\n        assertEquals(\"system\", artifact.getScope());\n        assertEquals(\"system\", artifact2.getScope());\n        assertEquals(\"system\", artifact3.getScope());\n        assertEquals(\"system\", artifact4.getScope());\n        assertEquals(\"system\", artifact5.getScope());\n    }",
    "comment": "this one should never happen in practice..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExternalShuffleBlockResolver.java",
    "type": "method",
    "name": "executorRemoved",
    "code": "public void executorRemoved(String executorId, String appId) {\n    logger.info(\"Clean up non-shuffle and non-RDD files associated with the finished executor {}\",\n      MDC.of(LogKeys.EXECUTOR_ID$.MODULE$, executorId));\n    AppExecId fullId = new AppExecId(appId, executorId);\n    final ExecutorShuffleInfo executor = executors.get(fullId);\n    if (executor == null) {\n      // Executor not registered, skip clean up of the local directories.\n      logger.info(\"Executor is not registered (appId={}, execId={})\",\n        MDC.of(LogKeys.APP_ID$.MODULE$, appId),\n        MDC.of(LogKeys.EXECUTOR_ID$.MODULE$, executorId));\n    } else {\n      logger.info(\"Cleaning up non-shuffle and non-RDD files in executor {}'s {} local dirs\",\n        MDC.of(LogKeys.APP_EXECUTOR_ID$.MODULE$, fullId),\n        MDC.of(LogKeys.NUM_LOCAL_DIRS$.MODULE$, executor.localDirs.length));\n\n      // Execute the actual deletion in a different thread, as it may take some time.\n      directoryCleaner.execute(() -> deleteNonShuffleServiceServedFiles(executor.localDirs));\n    }\n  }",
    "comment": "Removes all the files which cannot be served by the external shuffle service (non-shuffle and\nnon-RDD files) in any local directories associated with the finished executor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(float[] expected, float[] actual, Supplier<String> messageSupplier) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} float arrays are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/RunRules.java",
    "type": "method",
    "name": "RunRules",
    "code": "public RunRules(Statement base, Iterable<TestRule> rules, Description description) {\n        statement = applyAll(base, rules, description);\n    }",
    "comment": "Runs a collection of rules on a statement.\n\n@since 4.9"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toInt",
    "code": "private boolean toInt(IntWrapper intWrapper, boolean allowDecimal) {\n    int offset = 0;\n    while (offset < this.numBytes && isWhitespaceOrISOControl(getByte(offset))) offset++;\n    if (offset == this.numBytes) return false;\n\n    int end = this.numBytes - 1;\n    while (end > offset && isWhitespaceOrISOControl(getByte(end))) end--;\n\n    byte b = getByte(offset);\n    final boolean negative = b == '-';\n    if (negative || b == '+') {\n      if (end - offset == 0) {\n        return false;\n      }\n      offset++;\n    }\n\n    final byte separator = '.';\n    final int radix = 10;\n    final int stopValue = Integer.MIN_VALUE / radix;\n    int result = 0;\n\n    while (offset <= end) {\n      b = getByte(offset);\n      offset++;\n      if (b == separator && allowDecimal) {\n        break;\n      }\n\n      int digit;\n      if (b >= '0' && b <= '9') {\n        digit = b - '0';\n      } else {\n        return false;\n      }\n\n      if (result < stopValue) {\n        return false;\n      }\n\n      result = result * radix - digit;\n      if (result > 0) {\n        return false;\n      }\n    }\n\n    while (offset <= end) {\n      byte currentByte = getByte(offset);\n      if (currentByte < '0' || currentByte > '9') {\n        return false;\n      }\n      offset++;\n    }\n\n    if (!negative) {\n      result = -result;\n      if (result < 0) {\n        return false;\n      }\n    }\n    intWrapper.value = result;\n    return true;\n  }",
    "comment": "We allow decimals and will return a truncated integral in that case.\nTherefore we won't throw an exception here (checking the fractional\npart happens below.)\nWe are going to process the new digit and accumulate the result. However, before doing\nthis, if the result is already smaller than the stopValue(Integer.MIN_VALUE / radix), then\nresult * 10 will definitely be smaller than minValue, and we can stop\nSince the previous result is less than or equal to stopValue(Integer.MIN_VALUE / radix),\nwe can just use `result > 0` to check overflow. If result overflows, we should stop\nThis is the case when we've encountered a decimal separator. The fractional\npart will not change the number, but we will verify that the fractional part\nis well formed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/CustomHealthIndicatorTest.java",
    "type": "method",
    "name": "whenHealthCheckTimesOut_thenHealthIsDown",
    "code": "void whenHealthCheckTimesOut_thenHealthIsDown() {\n    CompletableFuture<Health> future = new CompletableFuture<>();\n    when(healthChecker.performCheck(any(), anyLong())).thenReturn(future);\n\n    Health health = customHealthIndicator.health();\n\n    assertEquals(Status.DOWN, health.getStatus());\n  }",
    "comment": "Test case for the `health()` method when the health check times out.\n\n<p>Asserts that when the `health()` method is called and the health check times out, it returns\na Health object with Status.DOWN."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Shape.java",
    "type": "method",
    "name": "size",
    "code": "public long size(int i) {\n    return shape[i];\n  }",
    "comment": "The size of the i-th dimension.\n\n@return The size of the requested dimension or -1 if it is unknown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "setContextValue",
    "code": "public void setContextValue(String key, Object value) {\n        if (context == null) {\n            context = new HashMap<>();\n        }\n        if (value != null) {\n            context.put(key, value);\n        } else {\n            context.remove(key);\n        }\n    }",
    "comment": "Sets the value of the context value of this project identified by the given key. If the supplied value is\n<code>null</code>, the context value is removed from this project. Context values are intended to allow core\nextensions to associate derived state with project instances."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTimeout",
    "code": "public static <T> T assertTimeout(Duration timeout, ThrowingSupplier<T> supplier, String message) {\n\t\treturn AssertTimeout.assertTimeout(timeout, supplier, message);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code supplier}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>If the assertion passes then the {@code supplier}'s result is returned.\n\n<p>Note: the {@code supplier} will be executed in the same thread as that\nof the calling code. Consequently, execution of the {@code supplier} will\nnot be preemptively aborted if the timeout is exceeded.\n\n<p>Fails with the supplied failure {@code message}.\n\n@see #assertTimeout(Duration, Executable)\n@see #assertTimeout(Duration, Executable, String)\n@see #assertTimeout(Duration, Executable, Supplier)\n@see #assertTimeout(Duration, ThrowingSupplier)\n@see #assertTimeout(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeoutPreemptively(Duration, Executable, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationSupport.java",
    "type": "method",
    "name": "if",
    "code": "final int collationId) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType) {\n        return execBinary(source, dict);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(source, dict);\n      } else {\n        return execICU(source, dict, collationId);\n      }\n    }",
    "comment": "Space trimming does not affect the output of this expression."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/App.java",
    "type": "method",
    "name": "App",
    "code": "private App() {\n    executor = Executors.newFixedThreadPool(2);\n    stopLatch = new CountDownLatch(2);\n  }",
    "comment": "The Promise object is used for asynchronous computations. A Promise represents an operation that\nhasn't completed yet, but is expected in the future.\n\n<p>A Promise represents a proxy for a value not necessarily known when the promise is created. It\nallows you to associate dependent promises to an asynchronous action's eventual success value or\nfailure reason. This lets asynchronous methods return values like synchronous methods: instead of\nthe final value, the asynchronous method returns a promise of having a value at some point in the\nfuture.\n\n<p>Promises provide a few advantages over callback objects:\n\n<ul>\n<li>Functional composition and error handling\n<li>Prevents callback hell and provides callback aggregation\n</ul>\n\n<p>In this application the usage of promise is demonstrated with two examples:\n\n<ul>\n<li>Count Lines: In this example a file is downloaded and its line count is calculated. The\ncalculated line count is then consumed and printed on console.\n<li>Lowest Character Frequency: In this example a file is downloaded and its lowest frequency\ncharacter is found and printed on console. This happens via a chain of promises, we start\nwith a file download promise, then a promise of character frequency, then a promise of\nlowest frequency character which is finally consumed and result is printed on console.\n</ul>\n\n@see CompletableFuture"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/AssertTest.java",
    "type": "method",
    "name": "testAssertionFailedErrorToStringWithMessage",
    "code": "public void testAssertionFailedErrorToStringWithMessage() {\n        try {\n            fail(\"woops!\");\n        } catch (AssertionFailedError e) {\n            assertEquals(\"junit.framework.AssertionFailedError: woops!\", e.toString());\n            return;\n        }\n        throw new AssertionFailedError();\n    }",
    "comment": "Also, we are testing fail, so we can't rely on fail() working.\nWe have to throw the exception manually."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/launcher/listeners/UniqueIdTrackingListenerIntegrationTests.java",
    "type": "method",
    "name": "confirmExpectedUniqueIdsViaEngineTestKit",
    "code": "void confirmExpectedUniqueIdsViaEngineTestKit() {\n\t\t// @formatter:off\n\t\tEngineTestKit.engine(\"junit-jupiter\")\n\t\t\t.selectors(selectClasses())\n\t\t\t.execute()\n\t\t\t.testEvents()\n\t\t\t.assertStatistics(stats -> stats.started(7).skipped(1).aborted(1).succeeded(5).failed(1))\n\t\t\t.assertEventsMatchLoosely(\n\t\t\t\tevent(test(uniqueId(passingTest)), finishedSuccessfully()),\n\t\t\t\tevent(test(uniqueId(abortedTest)), abortedWithReason(instanceOf(TestAbortedException.class))),\n\t\t\t\tevent(test(uniqueId(failingTest)), finishedWithFailure(instanceOf(AssertionFailedError.class))),\n\t\t\t\tevent(test(uniqueId(dynamicTest1)), finishedSuccessfully()),\n\t\t\t\tevent(test(uniqueId(dynamicTest2)), finishedSuccessfully()),\n\t\t\t\tevent(test(uniqueId(testA)), finishedSuccessfully()),\n\t\t\t\tevent(test(uniqueId(testB)), finishedSuccessfully())\n\t\t\t);\n\t\t// @formatter:on\n\t}",
    "comment": "Integration tests for the {@link UniqueIdTrackingListener}.\n\n@since 1.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/logging/Slf4jLoggerManager.java",
    "type": "method",
    "name": "getLoggerForComponent",
    "code": "public Logger getLoggerForComponent(String role, String hint) {\n        return (null == hint\n                ? getLoggerForComponent(role)\n                : new Slf4jLogger(loggerFactory.getLogger(role + '.' + hint)));\n    }",
    "comment": "The logger name for a component with a non-null hint is <code>role.hint</code>.\n<b>Warning</b>: this does not conform to logger name as class name convention.\n(and what about <code>null</code> and <code>default</code> hint equivalence?)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaGradientBoostedTreeClassifierExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaGradientBoostedTreeClassifierExample\")\n      .getOrCreate();\n\n    Dataset<Row> data = spark\n      .read()\n      .format(\"libsvm\")\n      .load(\"data/mllib/sample_libsvm_data.txt\");\n\n    StringIndexerModel labelIndexer = new StringIndexer()\n      .setInputCol(\"label\")\n      .setOutputCol(\"indexedLabel\")\n      .fit(data);\n    VectorIndexerModel featureIndexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexedFeatures\")\n      .setMaxCategories(4)\n      .fit(data);\n\n    Dataset<Row>[] splits = data.randomSplit(new double[] {0.7, 0.3});\n      .setStages(new PipelineStage[] {labelIndexer, featureIndexer, gbt, labelConverter});\n}",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data file, converting it to a DataFrame.\nIndex labels, adding metadata to the label column.\nFit on whole dataset to include all labels in index.\nAutomatically identify categorical features, and index them.\nSet maxCategories so features with > 4 distinct values are treated as continuous.\nSplit the data into training and test sets (30% held out for testing)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java",
    "type": "method",
    "name": "getEffectiveAnnotatedParameter",
    "code": "private static AnnotatedElement getEffectiveAnnotatedParameter(Parameter parameter, int index) {\n\t\tPreconditions.notNull(parameter, \"Parameter must not be null\");\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\n\t\tif (executable instanceof Constructor && isInnerClass(executable.getDeclaringClass())\n\t\t\t\t&& executable.getParameterAnnotations().length == executable.getParameterCount() - 1) {\n\n\t\t\tif (index == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn executable.getParameters()[index - 1];\n\t\t}\n\n\t\treturn parameter;\n\t}",
    "comment": "Due to a bug in {@code javac} on JDK versions prior to JDK 9, looking up\nannotations directly on a {@link Parameter} will fail for inner class\nconstructors.\n\n<h3>Bug in {@code javac} on JDK versions prior to JDK 9</h3>\n\n<p>The parameter annotations array in the compiled byte code for the user's\nclass excludes an entry for the implicit <em>enclosing instance</em>\nparameter for an inner class constructor.\n\n<h3>Workaround</h3>\n\n<p>This method provides a workaround for this off-by-one error by helping\nJUnit maintainers and extension authors to access annotations on the preceding\n{@link Parameter} object (i.e., {@code index - 1}). If the supplied\n{@code index} is zero in such situations this method will return {@code null}\nsince the parameter for the implicit <em>enclosing instance</em> will never\nbe annotated.\n\n<h4>WARNING</h4>\n\n<p>The {@code AnnotatedElement} returned by this method should never be cast and\ntreated as a {@code Parameter} since the metadata (e.g., {@link Parameter#getName()},\n{@link Parameter#getType()}, etc.) will not match those for the declared parameter\nat the given index in an inner class constructor for code compiled with JDK 8.\n\n@return the supplied {@code Parameter}, or the <em>effective</em> {@code Parameter}\nif the aforementioned bug is detected, or {@code null} if the bug is detected and\nthe supplied {@code index} is {@code 0}\n@since 1.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/Result.java",
    "type": "method",
    "name": "addProblems",
    "code": "public static <T> Result<T> addProblems(Result<T> result, Iterable<? extends ModelProblem> problems) {\n        Collection<ModelProblem> list = new ArrayList<>();\n        for (ModelProblem item : problems) {\n            list.add(item);\n        }\n        for (ModelProblem item : result.getProblems()) {\n            list.add(item);\n        }\n        return new Result<>(result.hasErrors() || hasErrors(problems), result.get(), list);\n    }",
    "comment": "New result that includes the given\n\n@param result\n@param problems"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/spatial-partition/src/main/java/com/iluwatar/spatialpartition/Bubble.java",
    "type": "method",
    "name": "touches",
    "code": "boolean touches(Bubble b) {\n    return (this.coordinateX - b.coordinateX) * (this.coordinateX - b.coordinateX)\n            + (this.coordinateY - b.coordinateY) * (this.coordinateY - b.coordinateY)\n        <= (this.radius + b.radius) * (this.radius + b.radius);\n  }",
    "comment": "distance between them is greater than sum of radii (both sides of equation squared)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/Truck.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n    return \"Truck{\"\n        + \"id=\"\n        + getId()\n        + \", make='\"\n        + getMake()\n        + '\\''\n        + \", model='\"\n        + getModel()\n        + '\\''\n        + \", year=\"\n        + getYear()\n        + \", payloadCapacity=\"\n        + getLoadCapacity()\n        + '}';\n  }",
    "comment": "Returns a string representation of the truck.\n\n@return a string with the truck's details"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java",
    "type": "method",
    "name": "resolveDependencies",
    "code": "private DependencyResolutionResult resolveDependencies(MavenProject project) {\n            DependencyResolutionResult resolutionResult;\n\n            RepositorySystemSession session = this.session.getSession();\n            try {\n                DefaultDependencyResolutionRequest resolution =\n                        new DefaultDependencyResolutionRequest(project, session);\n                resolutionResult = dependencyResolver.resolve(resolution);\n            } catch (DependencyResolutionException e) {\n                resolutionResult = e.getResult();\n            }\n\n            Set<Artifact> artifacts = new LinkedHashSet<>();\n            if (resolutionResult.getDependencyGraph() != null) {\n                RepositoryUtils.toArtifacts(\n                        artifacts,\n                        resolutionResult.getDependencyGraph().getChildren(),\n                        Collections.singletonList(project.getArtifact().getId()),\n                        null);\n\n                LocalRepositoryManager lrm = session.getLocalRepositoryManager();\n                for (Artifact artifact : artifacts) {\n                    if (!artifact.isResolved()) {\n                        Path path = lrm.getAbsolutePathForLocalArtifact(RepositoryUtils.toArtifact(artifact));\n                        artifact.setFile(path.toFile());\n                    }\n                }\n            }\n            project.setResolvedArtifacts(artifacts);\n            project.setArtifacts(artifacts);\n\n            return resolutionResult;\n        }",
    "comment": "Maven 2.x quirk: an artifact always points at the local repo, regardless whether resolved or not"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TemporaryFolder.java",
    "type": "method",
    "name": "parentFolder",
    "code": "public Builder parentFolder(File parentFolder) {\n            this.parentFolder = parentFolder;\n            return this;\n        }",
    "comment": "Specifies which folder to use for creating temporary resources.\nIf {@code null} then system default temporary-file directory is\nused.\n\n@return this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/ChunkFetchFailure.java",
    "type": "method",
    "name": "ChunkFetchFailure",
    "code": "public ChunkFetchFailure(StreamChunkId streamChunkId, String errorString) {\n    this.streamChunkId = streamChunkId;\n    this.errorString = errorString;\n  }",
    "comment": "Response to {@link ChunkFetchRequest} when there is an error fetching the chunk."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/MavenSessionBuilderSupplier.java",
    "type": "method",
    "name": "getArtifactTypeRegistry",
    "code": "protected ArtifactTypeRegistry getArtifactTypeRegistry() {\n        DefaultArtifactTypeRegistry stereotypes = new DefaultArtifactTypeRegistry();\n        new DefaultTypeProvider().types().forEach(stereotypes::add);\n        return stereotypes;\n    }",
    "comment": "This method produces \"surrogate\" type registry that is static: it aims users that want to use\nMaven-Resolver without involving Maven Core and related things.\n<p>\nThis type registry is NOT used by Maven Core: Maven replaces it during Session creation with a type registry\nthat supports extending it (i.e. via Maven Extensions).\n<p>\nImportant: this \"static\" list of types should be in-sync with core provided types."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Float unexpected, float actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Float) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "dynamicTestRegistered",
    "code": "public static Condition<Event> dynamicTestRegistered(String uniqueIdSubstring) {\n\t\treturn dynamicTestRegistered(uniqueIdSubstring(uniqueIdSubstring));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link EventType#DYNAMIC_TEST_REGISTERED} and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the\nsupplied {@link String}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/shuffledb/DBIterator.java",
    "type": "method",
    "name": "remove",
    "code": "default void remove() {\n        throw new UnsupportedOperationException();\n    }",
    "comment": "Position at the first entry in the source whose `key` is at target."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "skipped",
    "code": "public Events skipped() {\n\t\treturn new Events(eventsByType(EventType.SKIPPED), this.category + \" Skipped\");\n\t}",
    "comment": "Get the skipped {@link Events} contained in this {@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/main/java/com/iluwatar/health/check/MemoryHealthIndicator.java",
    "type": "method",
    "name": "checkMemory",
    "code": "public Health checkMemory() {\n    Supplier<Health> memoryCheck =\n        () -> {\n          MemoryMXBean memoryMxBean = ManagementFactory.getMemoryMXBean();\n          MemoryUsage heapMemoryUsage = memoryMxBean.getHeapMemoryUsage();\n          long maxMemory = heapMemoryUsage.getMax();\n          long usedMemory = heapMemoryUsage.getUsed();\n\n          double memoryUsage = (double) usedMemory / maxMemory;\n          String format = String.format(\"%.2f%% of %d max\", memoryUsage * 100, maxMemory);\n\n          if (memoryUsage < memoryThreshold) {\n            LOGGER.info(\"Memory usage is below threshold: {}\", format);\n            return Health.up().withDetail(\"memory usage\", format).build();\n          } else {\n            return Health.down().withDetail(\"memory usage\", format).build();\n          }\n        };\n\n    try {\n      CompletableFuture<Health> future =\n          asynchronousHealthChecker.performCheck(memoryCheck, timeoutInSeconds);\n      return future.get();\n    } catch (InterruptedException e) {\n      LOGGER.error(\"Health check interrupted\", e);\n      Thread.currentThread().interrupt();\n      return Health.down().withDetail(\"error\", \"Health check interrupted\").build();\n    } catch (ExecutionException e) {\n      LOGGER.error(\"Health check failed\", e);\n      Throwable cause = e.getCause() == null ? e : e.getCause();\n      return Health.down().withDetail(\"error\", cause.toString()).build();\n    }\n  }",
    "comment": "Performs a health check by checking the memory usage of the application.\n\n@return the health status of the application"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProjectActivation.java",
    "type": "method",
    "name": "getExcludedProjects",
    "code": "public List<String> getExcludedProjects() {\n        return Collections.unmodifiableList(new ArrayList<>(getProjectSelectors(pa -> !pa.active())));\n    }",
    "comment": "Mimics the pre-Maven 4 \"excluded projects\" list.\n@deprecated Use {@link #getRequiredInactiveProjectSelectors()} and {@link #getOptionalInactiveProjectSelectors()}\ninstead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvn/resident/ResidentMavenInvoker.java",
    "type": "method",
    "name": "ResidentMavenInvoker",
    "code": "public ResidentMavenInvoker(Lookup protoLookup) {\n        super(protoLookup, null);\n        this.residentContext = new ConcurrentHashMap<>();\n    }",
    "comment": "Resident invoker implementation, specialization of Maven Invoker, but keeps Maven instance resident. This implies, that\nthings like environment, system properties, extensions etc. are loaded only once. It is caller duty to ensure\nthat subsequent call is right for the resident instance (ie no env change or different extension needed).\nThis implementation \"pre-populates\" MavenContext with pre-existing stuff (except for very first call)\nand does not let DI container to be closed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String expected, String actual) {\n        Assert.assertEquals(expected, actual);\n    }",
    "comment": "Asserts that two Strings are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/Cart.java",
    "type": "method",
    "name": "getTotalPrice",
    "code": "public double getTotalPrice() {\n    return product.getPrice() * quantity;\n  }",
    "comment": "Calculates the total price of the products in the cart. The total price is the product's price\nmultiplied by the quantity.\n\n@return the total price of the products in the cart."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/FileSelectorTests.java",
    "type": "method",
    "name": "equalsAndHashCode",
    "code": "void equalsAndHashCode() {\n\t\tvar selector1 = new FileSelector(\"/example/foo.txt\", null);\n\t\tvar selector2 = new FileSelector(\"/example/foo.txt\", null);\n\t\tvar selector3 = new FileSelector(\"/example/bar.txt\", null);\n\n\t\tassertEqualsAndHashCode(selector1, selector2, selector3);\n\t}",
    "comment": "Unit tests for {@link FileSelector}.\n\n@since 1.3\n@see DiscoverySelectorsTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "merge",
    "code": "static XmlNode merge(@Nullable XmlNode dominant, @Nullable XmlNode recessive) {\n        return XmlService.merge(dominant, recessive, null);\n    }",
    "comment": "Merge recessive into dominant and return either {@code dominant}\nwith merged information or a clone of {@code recessive} if\n{@code dominant} is {@code null}.\n\n@param dominant the node\n@param recessive if {@code null}, nothing will happen\n@return the merged node\n\n@deprecated use {@link XmlService#merge(XmlNode, XmlNode, Boolean)} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/test/java/org/tensorflow/TestUtil.java",
    "type": "method",
    "name": "bool2byte",
    "code": "public static byte[] bool2byte(boolean[] array) {\n    byte[] out = new byte[array.length];\n    for (int i = 0; i < array.length; i++) {\n      out[i] = array[i] ? (byte) 1 : (byte) 0;\n    }\n    return out;\n  }",
    "comment": "Converts a {@code boolean[]} to a {@code byte[]}.\n\n<p>Suitable for creating tensors of type {@link DataType#BOOL} using {@link\njava.nio.ByteBuffer}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/plugin/testing/stubs/ProjectStub.java",
    "type": "method",
    "name": "setModel",
    "code": "public void setModel(Model model) {\n        this.model = model;\n    }",
    "comment": "A stub implementation of {@link Project} for testing Maven plugins.\nProvides a simplified project structure with basic model information.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/ByteArray.java",
    "type": "method",
    "name": "getPrefix",
    "code": "public static long getPrefix(byte[] bytes) {\n    if (bytes == null) {\n      return 0L;\n    }\n    return getPrefix(bytes, Platform.BYTE_ARRAY_OFFSET, bytes.length);\n  }",
    "comment": "Returns a 64-bit integer that can be used as the prefix used in sorting."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/model/profile/AbstractProfileActivatorTest.java",
    "type": "method",
    "name": "isRootDirectory",
    "code": "protected boolean isRootDirectory(Path dir) {\n            return true;\n        }",
    "comment": "Provides common services to test {@link ProfileActivator} implementations.\n\n@param <T> the type of {@link ProfileActivator} being tested"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlob",
    "code": "public static Tensor fromBlob(LongBuffer data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_BUFFER_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.capacity(), shape);\n    checkArgument(data.isDirect(), ERROR_MSG_DATA_BUFFER_MUST_BE_DIRECT);\n    checkArgument(\n        (data.order() == ByteOrder.nativeOrder()),\n        ERROR_MSG_DATA_BUFFER_MUST_HAVE_NATIVE_BYTE_ORDER);\n    return new Tensor_int64(data, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.int64 with specified shape and data.\n\n@param data Direct buffer with native byte order that contains {@code Tensor.numel(shape)}\nelements. The buffer is used directly without copying, and changes to its content will\nchange the tensor.\n@param shape Tensor shape"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/ArtifactScopeEnum.java",
    "type": "method",
    "name": "encloses",
    "code": "public boolean encloses(ArtifactScopeEnum scope) {\n        final ArtifactScopeEnum s = checkScope(scope);\n\n        // system scope is historic only - and simple\n        if (id == system.id) {\n            return scope.id == system.id;\n        }\n\n        for (ArtifactScopeEnum[][] set : COMPLIANCY_SETS) {\n            if (id == set[0][0].id) {\n                for (ArtifactScopeEnum ase : set[1]) {\n                    if (s.id == ase.id) {\n                        return true;\n                    }\n                }\n                break;\n            }\n        }\n        return false;\n    }",
    "comment": "scope relationship function. Used by the graph conflict resolution policies\n\n@param scope a scope\n@return true is supplied scope is an inclusive sub-scope of current one."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicSample/app/src/main/java/com/example/android/persistence/db/AppDatabase.java",
    "type": "method",
    "name": "updateDatabaseCreated",
    "code": "private void updateDatabaseCreated(final Context context) {\n        if (context.getDatabasePath(DATABASE_NAME).exists()) {\n            setDatabaseCreated();\n        }\n    }",
    "comment": "Check whether the database already exists and expose it via {@link #getDatabaseCreated()}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/mapping/DefaultLifecycleMapping.java",
    "type": "method",
    "name": "initLifecycleMap",
    "code": "private synchronized void initLifecycleMap() {\n        if (lifecycleMap == null) {\n            lifecycleMap = new HashMap<>();\n\n            if (lifecycles != null) {\n                for (Lifecycle lifecycle : lifecycles) {\n                    lifecycleMap.put(lifecycle.getId(), lifecycle);\n                }\n            } else {\n                /*\n                 * NOTE: This is to provide a migration path for implementors of the legacy API which did not know about\n                 * getLifecycles().\n                 */\n\n                String[] lifecycleIds = {\"default\", \"clean\", \"site\"};\n\n                for (String lifecycleId : lifecycleIds) {\n                    Map<String, LifecyclePhase> phases = getLifecyclePhases(lifecycleId);\n                    if (phases != null) {\n                        Lifecycle lifecycle = new Lifecycle();\n\n                        lifecycle.setId(lifecycleId);\n                        lifecycle.setLifecyclePhases(phases);\n\n                        lifecycleMap.put(lifecycleId, lifecycle);\n                    }\n                }\n            }\n        }\n    }",
    "comment": "Plexus: Populates the lifecycle map from the injected list of lifecycle mappings (if not already done)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/UserDefinedScalarFunc.java",
    "type": "method",
    "name": "UserDefinedScalarFunc",
    "code": "public UserDefinedScalarFunc(String name, String canonicalName, Expression[] children) {\n    this.name = name;\n    this.canonicalName = canonicalName;\n    this.children = children;\n  }",
    "comment": "The general representation of user defined scalar function, which contains the upper-cased\nfunction name, canonical function name and all the children expressions.\n\n@since 3.4.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Session.java",
    "type": "method",
    "name": "feed",
    "code": "public Runner feed(Operand<?> operand, Tensor<?> t) {\n      inputs.add(operand.asOutput());\n      inputTensors.add(t);\n      return this;\n    }",
    "comment": "Use {@code t} instead of the Tensor referred to by executing the operation referred to by\n{@code operand}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "deleteAndGetUser",
    "code": "public void deleteAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        mDataSource.deleteAllUsers();\n\n        User dbUser = mDataSource.getUser();\n        assertNull(dbUser);\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are deleting all users\nThe user is no longer in the data source"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "next",
    "code": "public Location next() {\n      if (recordsInPage == 0) {\n        advanceToNextPage();\n      }\n      numRecords--;\n      if (currentPage != null) {\n        int totalLength = UnsafeAlignedOffset.getSize(pageBaseObject, offsetInPage);\n        loc.with(currentPage, offsetInPage);\n        offsetInPage += UnsafeAlignedOffset.getUaoSize() + totalLength + 8;\n        recordsInPage --;\n        return loc;\n      } else {\n        assert(reader != null);\n        if (!reader.hasNext()) {\n          advanceToNextPage();\n        }\n        try {\n          reader.loadNext();\n        } catch (IOException e) {\n          try {\n            reader.close();\n          } catch(IOException e2) {\n            logger.error(\"Error while closing spill reader\", e2);\n          }\n          Platform.throwException(e);\n        }\n        loc.with(reader.getBaseObject(), reader.getBaseOffset(), reader.getRecordLength());\n        return loc;\n      }\n    }",
    "comment": "[total size] [key size] [key] [value] [pointer to next]\nScala iterator does not handle exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Boolean> create(Scope scope, boolean[][][][] data) {\n    return create(scope, data, Boolean.class);\n  }",
    "comment": "Creates a rank-4 constant of {@code boolean} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ClassNamePatternFilterUtilsTests.java",
    "type": "method",
    "name": "neverExcludedConditions",
    "code": "void neverExcludedConditions(String pattern) {\n\t\tList<? extends ExecutionCondition> executionConditions = List.of(new AExecutionConditionClass(),\n\t\t\tnew BExecutionConditionClass());\n\t\tassertThat(executionConditions).filteredOn(ClassNamePatternFilterUtils.excludeMatchingClasses(pattern)) //\n\t\t\t\t.hasSize(2);\n\t}",
    "comment": "Unit tests for {@link ClassNamePatternFilterUtils}.\n\n@since 1.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/client/TransportClient.java",
    "type": "method",
    "name": "stream",
    "code": "public void stream(String streamId, StreamCallback callback) {\n    StdChannelListener listener = new StdChannelListener(streamId) {\n    };\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Sending stream request for {} to {}\", streamId, getRemoteAddress(channel));\n    }\n\n    // Need to synchronize here so that the callback is added to the queue and the RPC is\n    // written to the socket atomically, so that callbacks are called in the right order\n    // when responses arrive.\n    synchronized (this) {\n      handler.addStreamCallback(streamId, callback);\n      channel.writeAndFlush(new StreamRequest(streamId)).addListener(listener);\n    }\n  }",
    "comment": "Request to stream the data with the given stream ID from the remote end.\n\n@param streamId The stream to fetch.\n@param callback Object to call with the stream data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Stopwatch.java",
    "type": "method",
    "name": "skipped",
    "code": "protected void skipped(long nanos, AssumptionViolatedException e, Description description) {\n    }",
    "comment": "Invoked when a test is skipped due to a failed assumption."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "lpad",
    "code": "public UTF8String lpad(int len, UTF8String pad) {\n    int spaces = len - this.numChars(); // number of char need to pad\n    if (spaces <= 0 || pad.numBytes() == 0) {\n      // no padding at all, return the substring of the current string\n      return substring(0, len);\n    } else {\n      int padChars = pad.numChars();\n      int count = spaces / padChars; // how many padding string needed\n      // the partial string of the padding\n      UTF8String remain = pad.substring(0, spaces - padChars * count);\n\n      int resultSize =\n        Math.toIntExact((long) numBytes + (long) pad.numBytes * count + remain.numBytes);\n      byte[] data = new byte[resultSize];\n\n      int offset = 0;\n      int idx = 0;\n      while (idx < count) {\n        copyMemory(pad.base, pad.offset, data, BYTE_ARRAY_OFFSET + offset, pad.numBytes);\n        ++ idx;\n        offset += pad.numBytes;\n      }\n      copyMemory(remain.base, remain.offset, data, BYTE_ARRAY_OFFSET + offset, remain.numBytes);\n      offset += remain.numBytes;\n      copyMemory(this.base, this.offset, data, BYTE_ARRAY_OFFSET + offset, numBytes());\n\n      return UTF8String.fromBytes(data);\n    }\n  }",
    "comment": "Returns str, left-padded with pad to a length of len.\nFor example:\n('hi', 5, '??') =&gt; '???hi'\n('hi', 1, '??') =&gt; 'h'"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistrationViaParametersAndFieldsTests.java",
    "type": "method",
    "name": "beforeAll",
    "code": "static void beforeAll() {\n\t\t\tassertThat(staticField1).isEqualTo(\"beforeAll - staticField1\");\n\t\t\tassertThat(staticField2).isEqualTo(\"beforeAll - staticField2\");\n\t\t}",
    "comment": "The {@link MagicField.Extension} is registered via a static field."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/entity/Vehicle.java",
    "type": "method",
    "name": "Vehicle",
    "code": "protected Vehicle(String manufacturer, String model) {\n    this.manufacturer = manufacturer;\n    this.model = model;\n  }",
    "comment": "An abstract class that is the root of the Vehicle Inheritance hierarchy and basic provides\nproperties for all the vehicles."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcPrivateKey",
    "code": "public File sslRpcPrivateKey() {\n    String privateKey = conf.get(\"spark.ssl.rpc.privateKey\", null);\n    if (privateKey != null) {\n      return new File(privateKey);\n    } else {\n      return null;\n    }\n  }",
    "comment": "A PKCS#8 private key file in PEM format; can be relative to the current directory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(byte[] expecteds, byte[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }",
    "comment": "Asserts that two byte arrays are equal. If they are not, an\n{@link AssertionError} is thrown.\n\n@param expecteds byte array with expected values.\n@param actuals byte array with actual values"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/DefaultProblemCollectorTest.java",
    "type": "method",
    "name": "lossy",
    "code": "void lossy() {\n        ProblemCollector<BuilderProblem> collector = ProblemCollector.create(5);\n        IntStream.range(0, 5)\n                .forEach(i -> collector.reportProblem(new DefaultBuilderProblem(\n                        \"source\", 0, 0, null, \"message \" + i, BuilderProblem.Severity.WARNING)));\n\n        assertFalse(collector.reportProblem(\n                new DefaultBuilderProblem(\"source\", 0, 0, null, \"message\", BuilderProblem.Severity.WARNING)));\n\n        assertTrue(collector.reportProblem(\n                new DefaultBuilderProblem(\"source\", 0, 0, null, \"message\", BuilderProblem.Severity.ERROR)));\n        assertTrue(collector.reportProblem(\n                new DefaultBuilderProblem(\"source\", 0, 0, null, \"message\", BuilderProblem.Severity.FATAL)));\n\n        assertFalse(collector.reportProblem(\n                new DefaultBuilderProblem(\"source\", 0, 0, null, \"message\", BuilderProblem.Severity.WARNING)));\n\n        IntStream.range(0, 5)\n                .forEach(i -> collector.reportProblem(new DefaultBuilderProblem(\n                        \"source\", 0, 0, null, \"message \" + i, BuilderProblem.Severity.FATAL)));\n\n        assertFalse(collector.reportProblem(\n                new DefaultBuilderProblem(\"source\", 0, 0, null, \"message\", BuilderProblem.Severity.WARNING)));\n        assertFalse(collector.reportProblem(\n                new DefaultBuilderProblem(\"source\", 0, 0, null, \"message\", BuilderProblem.Severity.ERROR)));\n        assertFalse(collector.reportProblem(\n                new DefaultBuilderProblem(\"source\", 0, 0, null, \"message\", BuilderProblem.Severity.FATAL)));\n\n        assertEquals(17, collector.totalProblemsReported());\n        assertEquals(8, collector.problemsReportedFor(BuilderProblem.Severity.WARNING));\n        assertEquals(2, collector.problemsReportedFor(BuilderProblem.Severity.ERROR));\n        assertEquals(7, collector.problemsReportedFor(BuilderProblem.Severity.FATAL));\n\n        assertEquals(5, collector.problems().count());\n    }",
    "comment": "collector is \"full\" of warnings\nbut collector will drop warning for more severe issues\ncollector is full of warnings, errors and fatal (mixed)\nfill it up with fatal ones\nfrom now on, only counters work, problems are lost\nbut preserved problems count == capacity"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/DataType.java",
    "type": "method",
    "name": "fromClass",
    "code": "public static DataType fromClass(Class<?> c) {\n    DataType dtype = typeCodes.get(c);\n    if (dtype == null) {\n      throw new IllegalArgumentException(\n          c.getName() + \" objects cannot be used as elements in a TensorFlow Tensor\");\n    }\n    return dtype;\n  }",
    "comment": "Returns the DataType of a Tensor whose elements have the type specified by class {@code c}.\n\n@param c The class describing the TensorFlow type of interest.\n@return The {@code DataType} enum corresponding to {@code c}.\n@throws IllegalArgumentException if objects of {@code c} do not correspond to a TensorFlow\ndatatype."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractAppHandle.java",
    "type": "method",
    "name": "dispose",
    "code": "synchronized void dispose() {\n    if (!isDisposed()) {\n      // First wait for all data from the connection to be read. Then unregister the handle.\n      // Otherwise, unregistering might cause the server to be stopped and all child connections\n      // to be closed.\n      if (connection != null) {\n        try {\n          connection.waitForClose();\n        } catch (IOException ioe) {\n          // no-op.\n        }\n      }\n      server.unregister(this);\n\n      // Set state to LOST if not yet final.\n      setState(State.LOST, false);\n      this.disposed = true;\n    }\n  }",
    "comment": "Mark the handle as disposed, and set it as LOST in case the current state is not final.\n\nThis method should be called only when there's a reasonable expectation that the communication\nwith the child application is not needed anymore, either because the code managing the handle\nhas said so, or because the child application is finished."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroArrayOfArray.java",
    "type": "method",
    "name": "put",
    "code": "public void put(int field$, java.lang.Object value$) {\n    switch (field$) {\n    case 0: int_arrays_column = (java.util.List<java.util.List<java.lang.Integer>>)value$; break;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumReader.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/ModelProblemUtils.java",
    "type": "method",
    "name": "toSourceHint",
    "code": "static String toSourceHint(Model model) {\n        if (model == null) {\n            return \"\";\n        }\n        StringBuilder buffer = new StringBuilder(128);\n        buffer.append(toId(model));\n        Path pomPath = model.getPomFile();\n        if (pomPath != null) {\n            buffer.append(\" (\").append(pomPath).append(')');\n        }\n        return buffer.toString();\n    }",
    "comment": "Creates a user-friendly source hint for the specified model.\n\n@param model The model to create a source hint for, may be {@code null}.\n@return The user-friendly source hint, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SparkSaslServer.java",
    "type": "method",
    "name": "response",
    "code": "public synchronized byte[] response(byte[] token) {\n    try {\n      return saslServer != null ? saslServer.evaluateResponse(token) : new byte[0];\n    } catch (SaslException e) {\n      throw new RuntimeException(e);\n    }\n  }",
    "comment": "Used to respond to server SASL tokens.\n@param token Server's SASL token\n@return response to send back to the server."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/OnHeapColumnVector.java",
    "type": "method",
    "name": "reserveInternal",
    "code": "protected void reserveInternal(int newCapacity) {\n    if (isArray() || type instanceof MapType) {\n      int[] newLengths = new int[newCapacity];\n      int[] newOffsets = new int[newCapacity];\n      if (this.arrayLengths != null) {\n        System.arraycopy(this.arrayLengths, 0, newLengths, 0, capacity);\n        System.arraycopy(this.arrayOffsets, 0, newOffsets, 0, capacity);\n      }\n      arrayLengths = newLengths;\n      arrayOffsets = newOffsets;\n    } else if (type instanceof BooleanType) {\n      if (byteData == null || byteData.length < newCapacity) {\n        byte[] newData = new byte[newCapacity];\n        if (byteData != null) System.arraycopy(byteData, 0, newData, 0, capacity);\n        byteData = newData;\n      }\n    } else if (type instanceof ByteType) {\n      if (byteData == null || byteData.length < newCapacity) {\n        byte[] newData = new byte[newCapacity];\n        if (byteData != null) System.arraycopy(byteData, 0, newData, 0, capacity);\n        byteData = newData;\n      }\n    } else if (type instanceof ShortType) {\n      if (shortData == null || shortData.length < newCapacity) {\n        short[] newData = new short[newCapacity];\n        if (shortData != null) System.arraycopy(shortData, 0, newData, 0, capacity);\n        shortData = newData;\n      }\n    } else if (type instanceof IntegerType || type instanceof DateType ||\n      DecimalType.is32BitDecimalType(type) || type instanceof YearMonthIntervalType) {\n      if (intData == null || intData.length < newCapacity) {\n        int[] newData = new int[newCapacity];\n        if (intData != null) System.arraycopy(intData, 0, newData, 0, capacity);\n        intData = newData;\n      }\n    } else if (type instanceof LongType ||\n        type instanceof TimestampType ||type instanceof TimestampNTZType ||\n        DecimalType.is64BitDecimalType(type) || type instanceof DayTimeIntervalType ||\n        type instanceof TimeType) {\n      if (longData == null || longData.length < newCapacity) {\n        long[] newData = new long[newCapacity];\n        if (longData != null) System.arraycopy(longData, 0, newData, 0, capacity);\n        longData = newData;\n      }\n    } else if (type instanceof FloatType) {\n      if (floatData == null || floatData.length < newCapacity) {\n        float[] newData = new float[newCapacity];\n        if (floatData != null) System.arraycopy(floatData, 0, newData, 0, capacity);\n        floatData = newData;\n      }\n    } else if (type instanceof DoubleType) {\n      if (doubleData == null || doubleData.length < newCapacity) {\n        double[] newData = new double[newCapacity];\n        if (doubleData != null) System.arraycopy(doubleData, 0, newData, 0, capacity);\n        doubleData = newData;\n      }\n    } else if (childColumns != null) {\n    } else {\n      throw new RuntimeException(\"Unhandled \" + type);\n    }\n\n    byte[] newNulls = new byte[newCapacity];\n    if (nulls != null) System.arraycopy(nulls, 0, newNulls, 0, capacity);\n    nulls = newNulls;\n\n    capacity = newCapacity;\n  }",
    "comment": "Spilt this function out since it is the slow path.\nNothing to store."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/special-case/src/main/java/com/iluwatar/specialcase/Db.java",
    "type": "method",
    "name": "findUserByUserName",
    "code": "public User findUserByUserName(String userName) {\n    if (!userName2User.containsKey(userName)) {\n      return null;\n    }\n    return userName2User.get(userName);\n  }",
    "comment": "Find a user with the userName.\n\n@param userName of the user\n@return instance of User"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "addJar",
    "code": "public T addJar(String jar) {\n    checkNotNull(jar, \"jar\");\n    builder.jars.add(jar);\n    return self();\n  }",
    "comment": "Adds a jar file to be submitted with the application.\n\n@param jar Path to the jar file.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelProblemCollectorRequest.java",
    "type": "method",
    "name": "ModelProblemCollectorRequest",
    "code": "public ModelProblemCollectorRequest(Severity severity, Version version) {\n        this.severity = Objects.requireNonNull(severity, \"severity cannot be null\");\n        this.version = Objects.requireNonNull(version, \"version cannot be null\");\n    }",
    "comment": "Create a new request with mandatory parameters.\n@param severity\n@param version"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpcOpenSslEnabled",
    "code": "public boolean sslRpcOpenSslEnabled() {\n    return conf.getBoolean(\"spark.ssl.rpc.openSslEnabled\", false);\n  }",
    "comment": "If the OpenSSL implementation is enabled,\n(if available on host system), requires certChain and keyFile arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/Logger.java",
    "type": "method",
    "name": "warn",
    "code": "default void warn(@Nonnull String message) {\n        log(Level.WARN, message);\n    }",
    "comment": "Logs a warning message without an associated exception.\n\n@param message the warning message to be logged"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/DefaultArtifactRepository.java",
    "type": "method",
    "name": "DefaultArtifactRepository",
    "code": "public DefaultArtifactRepository(String id, String url, ArtifactRepositoryLayout layout, boolean uniqueVersion) {\n        super(id, url);\n        this.layout = layout;\n    }",
    "comment": "Create a remote deployment repository.\n\n@param id            the unique identifier of the repository\n@param url           the URL of the repository\n@param layout        the layout of the repository\n@param uniqueVersion whether to assign each snapshot a unique version"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "toLowerCase",
    "code": "public static UTF8String toLowerCase(final UTF8String target, final int collationId) {\n    if (target.isFullAscii()) return target.toLowerCaseAscii();\n    return toLowerCaseSlow(target, collationId);\n  }",
    "comment": "Convert the input string to lowercase using the specified ICU collation rules.\n\n@param target the input string\n@return the lowercase string"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlanLogger.java",
    "type": "method",
    "name": "writePlan",
    "code": "public void writePlan(BuildPlan plan) {\n        if (logger.isDebugEnabled()) {\n            writePlan(logger::debug, plan);\n        }\n    }",
    "comment": "<p>\nLogs debug output from the various lifecycle phases.\n</p>\n<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java",
    "type": "method",
    "name": "if",
    "code": "if (userSuppliedConfigurationProcessorCount == 0) {\n            configurationProcessors.get(SettingsXmlConfigurationProcessor.HINT).process(cliRequest);\n        } else if (userSuppliedConfigurationProcessorCount == 1) {\n            for (Entry<String, ConfigurationProcessor> entry : configurationProcessors.entrySet()) {\n                String hint = entry.getKey();\n                if (!hint.equals(SettingsXmlConfigurationProcessor.HINT)) {\n                    ConfigurationProcessor configurationProcessor = entry.getValue();\n                    configurationProcessor.process(cliRequest);\n                }\n            }\n        } else if (userSuppliedConfigurationProcessorCount > 1) {\n            StringBuilder sb = new StringBuilder(String.format(\n                    \"%nThere can only be one user supplied ConfigurationProcessor, there are %s:%n%n\",\n                    userSuppliedConfigurationProcessorCount));\n            for (Entry<String, ConfigurationProcessor> entry : configurationProcessors.entrySet()) {\n                String hint = entry.getKey();\n                if (!hint.equals(SettingsXmlConfigurationProcessor.HINT)) {\n                    ConfigurationProcessor configurationProcessor = entry.getValue();\n                    sb.append(String.format(\n                            \"%s%n\", configurationProcessor.getClass().getName()));\n                }\n            }\n            throw new Exception(sb.toString());\n        }",
    "comment": "This is not ideal but there are events specifically for configuration from the CLI which I don't\nbelieve are really valid but there are ITs which assert the right events are published so this\nneeds to be supported so the EventSpyDispatcher needs to be put in the CliRequest so that\nit can be accessed by configuration processors.\n\n\nWe expect at most 2 implementations to be available. The SettingsXmlConfigurationProcessor implementation\nis always available in the core and likely always will be, but we may have another ConfigurationProcessor\npresent supplied by the user. The rule is that we only allow the execution of one ConfigurationProcessor.\nIf there is more than one then we execute the one supplied by the user, otherwise we execute the\ndefault SettingsXmlConfigurationProcessor.\n\n\nOur settings.xml source is historically how we have configured Maven from the CLI so we are going to\nhave to honour its existence forever. So let's run it.\n\n\nRun the user supplied ConfigurationProcessor\n\n\nThere are too many ConfigurationProcessors so we don't know which one to run so report the error."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "pointTo",
    "code": "public void pointTo(byte[] buf, int sizeInBytes) {\n    pointTo(buf, Platform.BYTE_ARRAY_OFFSET, sizeInBytes);\n  }",
    "comment": "Update this UnsafeRow to point to the underlying byte array.\n\n@param buf byte array to point to\n@param sizeInBytes the number of bytes valid in the byte array"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/Arguments.java",
    "type": "method",
    "name": "arguments",
    "code": "static Arguments arguments(Object... arguments) {\n\t\treturn of(arguments);\n\t}",
    "comment": "Factory method for creating an instance of {@code Arguments} based on\nthe supplied {@code arguments}.\n\n<p>This method is an <em>alias</em> for {@link Arguments#of} and is\nintended to be used when statically imported &mdash; for example, via:\n{@code import static org.junit.jupiter.params.provider.Arguments.arguments;}\n\n@param arguments the arguments to be used for an invocation of the test\nmethod; must not be {@code null}\n@return an instance of {@code Arguments}; never {@code null}\n@since 5.3\n@see #argumentSet(String, Object...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/DisabledOnOsConditionTests.java",
    "type": "method",
    "name": "getExecutionCondition",
    "code": "protected ExecutionCondition getExecutionCondition() {\n\t\treturn new DisabledOnOsCondition();\n\t}",
    "comment": "Unit tests for {@link DisabledOnOsCondition}.\n\n<p>Note that test method names MUST match the test method names in\n{@link DisabledOnOsIntegrationTests}.\n\n@since 5.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/PhaseRecorder.java",
    "type": "method",
    "name": "PhaseRecorder",
    "code": "public PhaseRecorder(MavenProject project) {\n        this.project = project;\n    }",
    "comment": "<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/TemporaryFolderUsageTest.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n        tempFolder = new TemporaryFolder();\n    }",
    "comment": "<tt>TemporaryFolderUsageTest</tt> provides tests for API usage correctness\nand ensure implementation symmetry of public methods against a root folder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/BuildListCalculator.java",
    "type": "method",
    "name": "calculateProjectBuilds",
    "code": "public ProjectBuildList calculateProjectBuilds(MavenSession session, List<TaskSegment> taskSegments) {\n        List<ProjectSegment> projectBuilds = new ArrayList<>();\n\n        MavenProject rootProject = session.getTopLevelProject();\n\n        for (TaskSegment taskSegment : taskSegments) {\n            List<MavenProject> projects;\n\n            if (taskSegment.isAggregating()) {\n                projects = Collections.singletonList(rootProject);\n            } else {\n                projects = session.getProjects();\n            }\n            for (MavenProject project : projects) {\n                ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n                MavenProject currentProject = session.getCurrentProject();\n                try {\n                    BuilderCommon.attachToThread(project); // Not totally sure if this is needed for anything\n                    session.setCurrentProject(project);\n                    projectBuilds.add(new ProjectSegment(project, taskSegment, session));\n                } finally {\n                    session.setCurrentProject(currentProject);\n                    Thread.currentThread().setContextClassLoader(tccl);\n                }\n            }\n        }\n        return new ProjectBuildList(projectBuilds);\n    }",
    "comment": "<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SparkSaslClient.java",
    "type": "method",
    "name": "response",
    "code": "public synchronized byte[] response(byte[] token) {\n    try {\n      return saslClient != null ? saslClient.evaluateChallenge(token) : new byte[0];\n    } catch (SaslException e) {\n      throw new RuntimeException(e);\n    }\n  }",
    "comment": "Respond to server's SASL token.\n@param token contains server's SASL token\n@return client's response SASL token"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/ToStringBuilderTests.java",
    "type": "method",
    "name": "withNullObject",
    "code": "void withNullObject() {\n\t\tassertThrows(PreconditionViolationException.class, () -> new ToStringBuilder((Object) null));\n\t}",
    "comment": "Unit tests for {@link ToStringBuilder}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<String> create(byte[][][][][][] data) {\n    return Tensor.create(data, String.class);\n  }",
    "comment": "Creates a rank-5 tensor of {@code byte} elements.\n\n@param data An array containing the data to put into the new tensor. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectModule",
    "code": "public static ModuleSelector selectModule(String moduleName) {\n\t\tPreconditions.notBlank(moduleName, \"Module name must not be null or blank\");\n\t\treturn new ModuleSelector(moduleName.trim());\n\t}",
    "comment": "Create a {@code ModuleSelector} for the supplied module name.\n\n<p>The unnamed module is not supported.\n\n@param moduleName the module name to select; never {@code null} or blank\n@since 1.1\n@see ModuleSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/MethodMap.java",
    "type": "method",
    "name": "isApplicable",
    "code": "private static boolean isApplicable(Method method, Class<?>... classes) {\n        Class<?>[] methodArgs = method.getParameterTypes();\n\n        if (methodArgs.length != classes.length) {\n            return false;\n        }\n\n        for (int i = 0; i < classes.length; ++i) {\n            if (!isMethodInvocationConvertible(methodArgs[i], classes[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }",
    "comment": "Returns true if the supplied method is applicable to actual\nargument types.\n\n@param method  The method to check for applicability\n@param classes The arguments\n@return true if the method applies to the parameter types"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/DefaultMaven.java",
    "type": "method",
    "name": "validateRequiredProfiles",
    "code": "private void validateRequiredProfiles(MavenSession session, ProfileActivation profileActivation) {\n        final Set<String> allAvailableProfiles = getAllProfiles(session);\n\n        final Set<String> requiredProfiles = new HashSet<>();\n        requiredProfiles.addAll(profileActivation.getRequiredActiveProfileIds());\n        requiredProfiles.addAll(profileActivation.getRequiredInactiveProfileIds());\n\n        // Check whether the required profiles were found in any of the projects we're building.\n        final Set<String> notFoundRequiredProfiles = requiredProfiles.stream()\n                .filter(rap -> !allAvailableProfiles.contains(rap))\n                .collect(toSet());\n\n        if (!notFoundRequiredProfiles.isEmpty()) {\n            // Use SLF4J formatter for consistency with warnings reported by logger\n            final String message = MessageFormatter.format(\n                            \"The requested profiles {} could not be activated or deactivated because they do not\"\n                                    + \" exist.\",\n                            notFoundRequiredProfiles)\n                    .getMessage();\n            addExceptionToResult(session.getResult(), new MissingProfilesException(message));\n        }\n    }",
    "comment": "Check whether the required profiles were found in any of the projects we're building or the settings.\n@param session the Maven session.\n@param profileActivation the requested optional and required profiles."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/InputLocation.java",
    "type": "method",
    "name": "getLineNumber",
    "code": "public int getLineNumber() {\n        return this.lineNumber;\n    } // -- int getLineNumber()",
    "comment": "Get the one-based line number. The value will be\nnon-positive if unknown.\n\n@return int"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MavenBuilderException.java",
    "type": "method",
    "name": "MavenBuilderException",
    "code": "public MavenBuilderException(String message, Throwable cause) {\n        super(message, cause);\n        problems = ProblemCollector.empty();\n    }",
    "comment": "Constructs a new exception with the specified message and cause.\nThis constructor creates an empty problem collector.\n\n@param message the detail message\n@param cause the cause of this exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLocksProviderTests.java",
    "type": "method",
    "name": "classLevelProvider",
    "code": "void classLevelProvider() {\n\t\tvar events = execute(ClassLevelProviderTestCase.class);\n\t\tassertThat(events.filter(event(test(), finishedSuccessfully())::matches)).hasSize(2);\n\t}",
    "comment": "Integration tests for {@link ResourceLocksProvider}.\n\n@since 5.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/event/ExecutionEventLogger.java",
    "type": "method",
    "name": "mojoStarted",
    "code": "public void mojoStarted(ExecutionEvent event) {\n        if (logger.isInfoEnabled()) {\n            init();\n            logger.info(\"\");\n\n            MessageBuilder buffer = builder().strong(\"--- \");\n            append(buffer, event.getMojoExecution());\n            append(buffer, event.getProject());\n            buffer.strong(\" ---\");\n\n            logger.info(buffer.toString());\n        }\n    }",
    "comment": "<pre>--- mojo-artifactId:version:goal (mojo-executionId) @ project-artifactId ---</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/types/DataTypes.java",
    "type": "method",
    "name": "createMapType",
    "code": "public static MapType createMapType(DataType keyType, DataType valueType) {\n    if (keyType == null) {\n      throw new IllegalArgumentException(\"keyType should not be null.\");\n    }\n    if (valueType == null) {\n      throw new IllegalArgumentException(\"valueType should not be null.\");\n    }\n    return new MapType(keyType, valueType, true);\n  }",
    "comment": "Creates a MapType by specifying the data type of keys ({@code keyType}) and values\n({@code keyType}). The field of {@code valueContainsNull} is set to {@code true}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/test/java/org/apache/spark/util/kvstore/LevelDBTypeInfoSuite.java",
    "type": "method",
    "name": "assertBefore",
    "code": "private void assertBefore(byte[] key1, byte[] key2) {\n    assertBefore(new String(key1, UTF_8), new String(key2, UTF_8));\n  }",
    "comment": "Make sure entries with conflicting names are sorted correctly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/EagerSession.java",
    "type": "method",
    "name": "create",
    "code": "public static EagerSession create() {\n    return options().build();\n  }",
    "comment": "Returns an {@code EagerSession} configured with default options.\n\n<p><b>WARNING:</b>Instances of {@code EagerSession} returned by this method must be explicitly\nfreed by invoking {@link #close()} when they are no longer needed. This could be achieve using\nthe `try-with-resources` technique.\n\n<p>Example usage:\n\n<pre>{@code\ntry (EagerSession session = EagerSession.create()) {\nOps tf = Ops.create(session);\n// build execute operations eagerly...\n}\n}</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/feature/JavaTfIdfSuite.java",
    "type": "method",
    "name": "tfIdf",
    "code": "public void tfIdf() {\n    HashingTF tf = new HashingTF();\n    JavaRDD<List<String>> documents = jsc.parallelize(Arrays.asList(\n      Arrays.asList(\"this is a sentence\".split(\" \")),\n      Arrays.asList(\"this is another sentence\".split(\" \")),\n      Arrays.asList(\"this is still a sentence\".split(\" \"))), 2);\n    JavaRDD<Vector> termFreqs = tf.transform(documents);\n    termFreqs.collect();\n    IDF idf = new IDF();\n    JavaRDD<Vector> tfIdfs = idf.fit(termFreqs).transform(termFreqs);\n    List<Vector> localTfIdfs = tfIdfs.collect();\n    int indexOfThis = tf.indexOf(\"this\");\n    for (Vector v : localTfIdfs) {\n      Assertions.assertEquals(0.0, v.apply(indexOfThis), 1e-15);\n    }\n  }",
    "comment": "The tests are to check Java compatibility."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/eclipse/sisu/plexus/PlexusXmlBeanConverter.java",
    "type": "method",
    "name": "newImplementation",
    "code": "private static <T> T newImplementation(final XmlPullParser parser, final Class<T> defaultClazz) {\n        return (T) newImplementation(loadImplementation(parseImplementation(parser), defaultClazz));\n    }",
    "comment": "Creates an instance of the implementation named in the current XML element, or the default if no name is given.\n\n@param parser The XML parser\n@param defaultClazz The default implementation type\n@return Instance of custom implementation if one was given; otherwise instance of default type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnenc/CommonsCliEncryptOptions.java",
    "type": "method",
    "name": "CommonsCliEncryptOptions",
    "code": "protected CommonsCliEncryptOptions(String source, CLIManager cliManager, CommandLine commandLine) {\n        super(source, cliManager, commandLine);\n    }",
    "comment": "Implementation of {@link EncryptOptions} (base + mvnenc)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/inference_interface/java/org/tensorflow/contrib/android/TensorFlowInferenceInterface.java",
    "type": "method",
    "name": "TensorFlowInferenceInterface",
    "code": "public TensorFlowInferenceInterface(InputStream is) {\n    prepareNativeRuntime();\n\n    this.modelName = \"\";\n    this.g = new Graph();\n    this.sess = new Session(g);\n    this.runner = sess.runner();\n\n    try {\n      if (VERSION.SDK_INT >= 18) {\n        Trace.beginSection(\"initializeTensorFlow\");\n        Trace.beginSection(\"readGraphDef\");\n      }\n\n      int baosInitSize = is.available() > 16384 ? is.available() : 16384;\n      ByteArrayOutputStream baos = new ByteArrayOutputStream(baosInitSize);\n      int numBytesRead;\n      byte[] buf = new byte[16384];\n      while ((numBytesRead = is.read(buf, 0, buf.length)) != -1) {\n        baos.write(buf, 0, numBytesRead);\n      }\n      byte[] graphDef = baos.toByteArray();\n\n      if (VERSION.SDK_INT >= 18) {\n        Trace.endSection(); // readGraphDef.\n      }\n\n      loadGraph(graphDef, g);\n      Log.i(TAG, \"Successfully loaded model from the input stream\");\n\n      if (VERSION.SDK_INT >= 18) {\n        Trace.endSection(); // initializeTensorFlow.\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Failed to load model from the input stream\", e);\n    }\n  }",
    "comment": "modelName is redundant for model loading from input stream, here is for\navoiding error in initialization as modelName is marked final."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/DefaultVersionSchemeProvider.java",
    "type": "method",
    "name": "DefaultVersionSchemeProvider",
    "code": "public DefaultVersionSchemeProvider() {\n        this.genericVersionScheme = new GenericVersionScheme();\n    }",
    "comment": "Default version scheme provider: provides singleton {@link GenericVersionScheme} instance.\n\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/actor-model/src/main/java/com/iluwatar/actormodel/ExampleActor.java",
    "type": "method",
    "name": "onReceive",
    "code": "protected void onReceive(Message message) {\n    LOGGER.info(\n        \"[{}]Received : {} from : [{}]\", getActorId(), message.getContent(), message.getSenderId());\n    Actor sender = actorSystem.getActorById(message.getSenderId()); // sender actor id\n    if (sender != null && !message.getSenderId().equals(getActorId())) {\n      sender.send(new Message(\"I got your message \", getActorId()));\n    }\n  }",
    "comment": "Logger log = Logger.getLogger(getClass().getName());\nReply of the message"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room3/java/com/example/android/persistence/migrations/UsersDatabase.java",
    "type": "method",
    "name": "Migration",
    "code": "static final Migration MIGRATION_3_4 = new Migration(3, 4) {\n    };",
    "comment": "Migrate from:\nversion 3 - using Room where the {@link User#mId} is an int\nto\nversion 4 - using Room where the {@link User#mId} is a String"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/filter/AlwaysFalse.java",
    "type": "method",
    "name": "AlwaysFalse",
    "code": "public AlwaysFalse() {\n    super(\"ALWAYS_FALSE\", new Predicate[]{});\n\n  @Override\n  public Boolean value() {\n    return false;\n  }\n\n  @Override\n  public DataType dataType() {\n    return DataTypes.BooleanType;\n  }\n\n  @Override\n  public String toString() { return \"FALSE\"; }\n}",
    "comment": "A predicate that always evaluates to {@code false}.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/SupportsDelete.java",
    "type": "method",
    "name": "canDeleteWhere",
    "code": "default boolean canDeleteWhere(Filter[] filters) {\n    return true;\n  }",
    "comment": "Checks whether it is possible to delete data from a data source table that matches filter\nexpressions.\n<p>\nRows should be deleted from the data source iff all of the filter expressions match.\nThat is, the expressions must be interpreted as a set of filters that are ANDed together.\n<p>\nSpark will call this method at planning time to check whether {@link #deleteWhere(Filter[])}\nwould reject the delete operation because it requires significant effort. If this method\nreturns false, Spark will not call {@link #deleteWhere(Filter[])} and will try to rewrite\nthe delete operation and produce row-level changes if the data source table supports deleting\nindividual records.\n\n@param filters filter expressions, used to select rows to delete when all expressions match\n@return true if the delete operation can be performed\n\n@since 3.1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/test/java/org/apache/spark/launcher/BaseSuite.java",
    "type": "method",
    "name": "postChecks",
    "code": "public void postChecks() {\n    LauncherServer server = LauncherServer.getServer();\n    if (server != null) {\n      // Shut down the server to clean things up for the next test.\n      try {\n        server.close();\n      } catch (Exception e) {\n        // Ignore.\n      }\n    }\n    assertNull(server);\n  }",
    "comment": "Handles configuring the JUL -> SLF4J bridge, and provides some utility methods for tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, double actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/internal/BootstrapCoreExtensionManager.java",
    "type": "method",
    "name": "if",
    "code": "if (clazz == ArtifactCoordinatesFactory.class) {\n                return (T) new DefaultArtifactCoordinatesFactory();\n            } else if (clazz == VersionParser.class) {\n                return (T) new DefaultVersionParser(new DefaultModelVersionParser(new GenericVersionScheme()));\n            } else if (clazz == VersionRangeResolver.class) {\n                return (T) new DefaultVersionRangeResolver(repositorySystem);\n            } else if (clazz == ArtifactResolver.class) {\n                return (T) new DefaultArtifactResolver();\n            } else if (clazz == ArtifactManager.class) {\n                return (T) new DefaultArtifactManager(this);\n            } else if (clazz == RepositoryFactory.class) {\n                return (T) new DefaultRepositoryFactory(new DefaultRemoteRepositoryManager(\n                        new DefaultUpdatePolicyAnalyzer(), new DefaultChecksumPolicyProvider()));\n            } else if (clazz == Interpolator.class) {\n                return (T) new DefaultInterpolator();\n            }",
    "comment": "} else if (clazz == ModelResolver.class) {\nreturn (T) new DefaultModelResolver();"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/feature-toggle/src/main/java/com/iluwatar/featuretoggle/pattern/propertiesversion/PropertiesFeatureToggleVersion.java",
    "type": "method",
    "name": "PropertiesFeatureToggleVersion",
    "code": "public PropertiesFeatureToggleVersion(final Properties properties) {\n    if (properties == null) {\n      throw new IllegalArgumentException(\"No Properties Provided.\");\n    } else {\n      try {\n        enhanced = (boolean) properties.get(\"enhancedWelcome\");\n      } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid Enhancement Settings Provided.\");\n      }\n    }\n  }",
    "comment": "Creates an instance of {@link PropertiesFeatureToggleVersion} using the passed {@link\nProperties} to determine, the status of the feature toggle {@link\nPropertiesFeatureToggleVersion#isEnhanced()}. There is also some defensive code to ensure the\n{@link Properties} passed are as expected.\n\n@param properties {@link Properties} used to configure the service and toggle features.\n@throws IllegalArgumentException when the passed {@link Properties} is not as expected\n@see Properties"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/DefensiveAllDefaultPossibilitiesBuilder.java",
    "type": "method",
    "name": "decorateIgnoredTestClass",
    "code": "private IgnoringRunnerDecorator decorateIgnoredTestClass(Runner runner) {\n\t\tif (runner instanceof Filterable) {\n\t\t\treturn new FilterableIgnoringRunnerDecorator(runner);\n\t\t}\n\t\treturn new IgnoringRunnerDecorator(runner);\n\t}",
    "comment": "Instead of checking for the {@link Ignore} annotation and returning an\n{@link IgnoredClassRunner} from {@link IgnoredBuilder}, we've let the\nsuper class determine the regular runner that would have been used if\n{@link Ignore} hadn't been present. Now, we decorate the runner to\noverride its runtime behavior (i.e. skip execution) but return its\nregular {@link org.junit.runner.Description}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/cache/RequestResult.java",
    "type": "method",
    "name": "isSuccess",
    "code": "Throwable error) {\n\n    public boolean isSuccess() {\n        return error == null;\n    }\n}",
    "comment": "Determines if the request was processed successfully.\n\n@return true if no error occurred during processing (error is null), false otherwise"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/transformation/impl/DefaultConsumerPomBuilder.java",
    "type": "method",
    "name": "prune",
    "code": "private static <T extends ModelBase.Builder> T prune(T builder, ModelBase model) {\n        builder.properties(null).reporting(null);\n        if (model.getDistributionManagement() != null\n                && model.getDistributionManagement().getRelocation() != null) {\n            builder.distributionManagement(DistributionManagement.newBuilder()\n                    .relocation(model.getDistributionManagement().getRelocation())\n                    .build());\n        }\n        builder.repositories(pruneRepositories(model.getRepositories()));\n        builder.pluginRepositories(null);\n        return builder;\n    }",
    "comment": "keep relocation only\nonly keep repositories other than 'central'"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/Car.java",
    "type": "method",
    "name": "setNumDoors",
    "code": "public void setNumDoors(int doors) {\n    if (doors <= 0) {\n      throw new IllegalArgumentException(\"Number of doors must be positive.\");\n    }\n    this.numDoors = doors;\n  }",
    "comment": "Sets the number of doors for the car.\n\n@param doors the number of doors"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/internal/ExtensionResolutionException.java",
    "type": "method",
    "name": "ExtensionResolutionException",
    "code": "public ExtensionResolutionException(CoreExtension extension, Throwable cause) {\n        super(\n                \"Extension \" + extension.getId() + \" or one of its dependencies could not be resolved: \"\n                        + cause.getMessage(),\n                cause);\n        this.extension = extension;\n    }",
    "comment": "Exception occurring trying to resolve a plugin."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestInstanceFactoryTests.java",
    "type": "method",
    "name": "proxyTestInstanceFactoryFailsDueToUseOfDifferentClassLoader",
    "code": "void proxyTestInstanceFactoryFailsDueToUseOfDifferentClassLoader() {\n\t\tClass<?> testClass = ProxiedTestCase.class;\n\t\tEngineExecutionResults executionResults = executeTestsForClass(testClass);\n\n\t\tassertEquals(0, executionResults.testEvents().started().count(), \"# tests started\");\n\t\tassertEquals(0, executionResults.testEvents().failed().count(), \"# tests aborted\");\n\n\t\texecutionResults.allEvents().assertEventsMatchExactly( //\n\t\t\tevent(engine(), started()), //\n\t\t\tevent(container(testClass), started()), //\n\t\t\tevent(container(testClass), //\n\t\t\t\tfinishedWithFailure(instanceOf(TestInstantiationException.class),\n\t\t\t\t\tmessage(m -> m.startsWith(\"TestInstanceFactory [\" + ProxyTestInstanceFactory.class.getName() + \"]\")\n\t\t\t\t\t\t\t&& m.contains(\"failed to return an instance of [\" + testClass.getName() + \"@\"\n\t\t\t\t\t\t\t\t\t+ Integer.toHexString(System.identityHashCode(testClass)))\n\t\t\t\t\t\t\t&& m.contains(\"and instead returned an instance of [\" + testClass.getName() + \"@\")//\n\t\t\t\t\t))), //\n\t\t\tevent(engine(), finishedSuccessfully()));\n\t}",
    "comment": "NOTE: the test class names are the same even though the objects are\ninstantiated using different ClassLoaders. Thus, we check for the\nappended \"@\" but ignore the actual hash code for the test class\nloaded by the different ClassLoader."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestReporter.java",
    "type": "method",
    "name": "publishFile",
    "code": "default void publishFile(Path file, MediaType mediaType) {\n\t\tPreconditions.condition(Files.exists(file), () -> \"file must exist: \" + file);\n\t\tPreconditions.condition(Files.isRegularFile(file), () -> \"file must be a regular file: \" + file);\n\t\tpublishFile(file.getFileName().toString(), mediaType, path -> Files.copy(file, path, REPLACE_EXISTING));\n\t}",
    "comment": "Publish the supplied file and attach it to the current test or container.\n\n<p>The file will be copied to the report output directory replacing any\npotentially existing file with the same name.\n\n@param file the file to be attached; never {@code null} or blank\n@param mediaType the media type of the file; never {@code null}; use\n{@link MediaType#APPLICATION_OCTET_STREAM} if unknown\n@since 5.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom3/java/com/example/android/persistence/migrations/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "updateAndGetUser",
    "code": "public void updateAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        User updatedUser = new User(USER.getId(), \"new username\", USER.getDate());\n        mDataSource.insertOrUpdateUser(updatedUser);\n\n        User dbUser = mDataSource.getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), \"new username\");\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are updating the name of the user\nThe retrieved user has the updated username"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ExceptionUtils.java",
    "type": "method",
    "name": "throwAsUncheckedException",
    "code": "public static RuntimeException throwAsUncheckedException(Throwable t) {\n\t\tPreconditions.notNull(t, \"Throwable must not be null\");\n\t\t// The following line will never actually return an exception but rather\n\t\t// throw t masked as a RuntimeException.\n\t\treturn ExceptionUtils.throwAs(t);\n\t}",
    "comment": "Throw the supplied {@link Throwable}, <em>masked</em> as an\nunchecked exception.\n\n<p>The supplied {@code Throwable} will not be wrapped. Rather, it\nwill be thrown <em>as is</em> using an exploit of the Java language\nthat relies on a combination of generics and type erasure to trick\nthe Java compiler into believing that the thrown exception is an\nunchecked exception even if it is a checked exception.\n\n<h4>Warning</h4>\n\n<p>This method should be used sparingly.\n\n@param t the {@code Throwable} to throw as an unchecked exception;\nnever {@code null}\n@return this method always throws an exception and therefore never\nreturns anything; the return type is merely present to allow this\nmethod to be supplied as the operand in a {@code throw} statement"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/internal/impl/TestApi.java",
    "type": "method",
    "name": "setup",
    "code": "void setup() {\n        RepositorySystemSession rss = new MavenSessionBuilderSupplier(repositorySystem)\n                .get()\n                .withLocalRepositoryBaseDirectories(new File(\"target/test-classes/apiv4-repo\").toPath())\n                .build();\n        DefaultMavenExecutionRequest mer = new DefaultMavenExecutionRequest();\n        DefaultMavenExecutionResult meres = new DefaultMavenExecutionResult();\n        MavenSession ms = new MavenSession(rss, mer, meres);\n        DefaultSession session = new DefaultSession(\n                ms,\n                repositorySystem,\n                Collections.emptyList(),\n                mavenRepositorySystem,\n                new DefaultLookup(plexusContainer),\n                runtimeInformation);\n        org.apache.maven.api.RemoteRepository remoteRepository = session.getRemoteRepository(\n                new RemoteRepository.Builder(\"mirror\", \"default\", \"file:target/test-classes/repo\").build());\n        this.session = session.withRemoteRepositories(Collections.singletonList(remoteRepository));\n        InternalSession.associate(rss, this.session);\n        sessionScope.enter();\n        sessionScope.seed(InternalMavenSession.class, InternalMavenSession.from(this.session));\n    }",
    "comment": "create session with any local repo, is redefined anyway below"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/LifecycleDependencyResolver.java",
    "type": "method",
    "name": "getProjects",
    "code": "public static List<MavenProject> getProjects(MavenProject project, MavenSession session, boolean aggregator) {\n        if (aggregator && project.getCollectedProjects() != null) {\n            Set<MavenProject> projectAndSubmodules = new HashSet<>(project.getCollectedProjects());\n            projectAndSubmodules.add(project);\n            return session.getProjects().stream() // sorted all\n                    .filter(projectAndSubmodules::contains)\n                    .collect(Collectors.toList()); // sorted and filtered to what we need\n        } else {\n            return Collections.singletonList(project);\n        }\n    }",
    "comment": "get the unsorted list of wanted projects"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/memory/MemoryBlock.java",
    "type": "method",
    "name": "fromLongArray",
    "code": "public static MemoryBlock fromLongArray(final long[] array) {\n    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8L);\n  }",
    "comment": "Creates a memory block pointing to the memory used by the long array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/toolchain/DefaultToolchainManagerTest.java",
    "type": "method",
    "name": "testNoModels",
    "code": "void testNoModels() {\n        MavenSession session = mock(MavenSession.class);\n        MavenExecutionRequest executionRequest = new DefaultMavenExecutionRequest();\n        when(session.getRequest()).thenReturn(executionRequest);\n\n        List<Toolchain> toolchains = toolchainManager.getToolchains(session, \"unknown\", null);\n\n        assertEquals(0, toolchains.size());\n    }",
    "comment": "Mocks to inject into toolchainManager"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassNamePatternFilterUtils.java",
    "type": "method",
    "name": "includeMatchingClasses",
    "code": "public static <T> Predicate<T> includeMatchingClasses(String patterns) {\n\t\treturn matchingClasses(patterns, object -> object.getClass().getName(), FilterType.INCLUDE);\n\t}",
    "comment": "Create a {@link Predicate} that can be used to include (i.e., filter in)\nobjects of type {@code T} whose fully qualified class names match any of\nthe supplied patterns.\n\n@param patterns a comma-separated list of patterns"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/client/StreamInterceptor.java",
    "type": "method",
    "name": "deactivateStream",
    "code": "private void deactivateStream() {\n    if (handler instanceof TransportResponseHandler transportResponseHandler) {\n      transportResponseHandler.deactivateStream();\n    }\n  }",
    "comment": "we only have to do this for TransportResponseHandler as it exposes numOutstandingFetches\n(there is no extra cleanup that needs to happen)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Long> create(Scope scope, long[][][][][][] data) {\n    return create(scope, data, Long.class);\n  }",
    "comment": "Creates a rank-6 constant of {@code long} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/LoginPage.java",
    "type": "method",
    "name": "navigateToPage",
    "code": "public LoginPage navigateToPage() {\n    try {\n      page = this.webClient.getPage(PAGE_URL);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return this;\n  }",
    "comment": "Navigates to the Login page\n\n@return {@link LoginPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenSimpleLogger.java",
    "type": "method",
    "name": "setLogSink",
    "code": "public static void setLogSink(Consumer<String> logSink) {\n        MavenSimpleLogger.logSink = logSink;\n    }",
    "comment": "Logger for Maven, that support colorization of levels and stacktraces. This class implements 2 methods introduced in\nslf4j-simple provider local copy.\n\n@since 3.5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/StreamChunkId.java",
    "type": "method",
    "name": "encodedLength",
    "code": "public int encodedLength() {\n    return 8 + 4;\n  }",
    "comment": "Encapsulates a request for a particular chunk of a stream."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/money/src/test/java/com/iluwater/money/MoneyTest.java",
    "type": "method",
    "name": "testSubtractMoney_AmountTooLarge",
    "code": "void testSubtractMoney_AmountTooLarge() {\n    Money money1 = new Money(50.00, \"USD\");\n    Money money2 = new Money(60.00, \"USD\");\n\n    assertThrows(CannotSubtractException.class, () -> money1.subtractMoney(money2));\n  }",
    "comment": "Test subtracting an amount larger than the current amount"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/OperationManager.java",
    "type": "method",
    "name": "isFetchFirst",
    "code": "private boolean isFetchFirst(FetchOrientation fetchOrientation) {\n    if (fetchOrientation.equals(FetchOrientation.FETCH_FIRST)) {\n      return true;\n    }\n    return false;\n  }",
    "comment": "TODO: Since OperationLog is moved to package o.a.h.h.ql.session,\nwe may add a Enum there and map FetchOrientation to it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/MethodOrderer.java",
    "type": "method",
    "name": "orderMethods",
    "code": "public void orderMethods(MethodOrdererContext context) {\n\t\t\tCollections.shuffle(context.getMethodDescriptors(),\n\t\t\t\tnew java.util.Random(RandomOrdererUtils.getSeed(context::getConfigurationParameter, logger)));\n\t\t}",
    "comment": "Order the methods encapsulated in the supplied\n{@link MethodOrdererContext} pseudo-randomly."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "unescapeJava",
    "code": "protected static String unescapeJava(String str) {\n        if (str == null) {\n            return null;\n        }\n        int sz = str.length();\n        StringBuilder out = new StringBuilder(sz);\n        StringBuilder unicode = new StringBuilder(UNICODE_LEN);\n        boolean hadSlash = false;\n        boolean inUnicode = false;\n        for (int i = 0; i < sz; i++) {\n            char ch = str.charAt(i);\n            if (inUnicode) {\n                // if in unicode, then we're reading unicode\n                // values in somehow\n                unicode.append(ch);\n                if (unicode.length() == UNICODE_LEN) {\n                    // unicode now contains the four hex digits\n                    // which represents our unicode character\n                    try {\n                        int value = Integer.parseInt(unicode.toString(), HEX_RADIX);\n                        out.append((char) value);\n                        unicode.setLength(0);\n                        inUnicode = false;\n                        hadSlash = false;\n                    } catch (NumberFormatException nfe) {\n                        throw new IllegalArgumentException(\"Unable to parse unicode value: \" + unicode, nfe);\n                    }\n                }\n                continue;\n            }\n\n            if (hadSlash) {\n                // handle an escaped value\n                hadSlash = false;\n                switch (ch) {\n                    case '\\\\':\n                        out.append('\\\\');\n                        break;\n                    case '\\'':\n                        out.append('\\'');\n                        break;\n                    case '\\\"':\n                        out.append('\"');\n                        break;\n                    case 'r':\n                        out.append('\\r');\n                        break;\n                    case 'f':\n                        out.append('\\f');\n                        break;\n                    case 't':\n                        out.append('\\t');\n                        break;\n                    case 'n':\n                        out.append('\\n');\n                        break;\n                    case 'b':\n                        out.append('\\b');\n                        break;\n                    case 'u':\n                        // uh-oh, we're in unicode country....\n                        inUnicode = true;\n                        break;\n                    default:\n                        out.append(ch);\n                        break;\n                }\n                continue;\n            } else if (ch == '\\\\') {\n                hadSlash = true;\n                continue;\n            }\n            out.append(ch);\n        }\n\n        if (hadSlash) {\n            // then we're in the weird case of a \\ at the end of the\n            // string, let's output it anyway.\n            out.append('\\\\');\n        }\n\n        return out.toString();\n    }",
    "comment": "<p>Unescapes any Java literals found in the <code>String</code> to a\n<code>Writer</code>.</p> This is a slightly modified version of the\nStringEscapeUtils.unescapeJava() function in commons-lang that doesn't\ndrop escaped separators (i.e '\\,').\n\n@param str  the <code>String</code> to unescape, may be null\n@return the processed string\n@throws IllegalArgumentException if the Writer is <code>null</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java",
    "type": "method",
    "name": "doNotSkip",
    "code": "public static SkipResult doNotSkip() {\n\t\t\treturn alwaysExecuteSkipResult;\n\t\t}",
    "comment": "Factory for creating <em>do not skip</em> results.\n\n<p>A context that is not skipped will be executed as normal.\n\n@return a <em>do not skip</em> {@code SkipResult}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvn/LayeredMavenOptions.java",
    "type": "method",
    "name": "layerMavenOptions",
    "code": "public static MavenOptions layerMavenOptions(Collection<MavenOptions> options) {\n        List<MavenOptions> o = options.stream().filter(Objects::nonNull).toList();\n        if (o.isEmpty()) {\n            throw new IllegalArgumentException(\"No options specified (or all were null)\");\n        } else if (o.size() == 1) {\n            return o.get(0);\n        } else {\n            return new LayeredMavenOptions<>(o);\n        }\n    }",
    "comment": "Options that are \"layered\" by precedence order.\n\n@param <O> the specific type of Maven Options that are layered"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-toolchain-builder/src/main/java/org/apache/maven/toolchain/io/ToolchainsParseException.java",
    "type": "method",
    "name": "ToolchainsParseException",
    "code": "public ToolchainsParseException(String message, int lineNumber, int columnNumber, Throwable cause) {\n        super(message);\n        initCause(cause);\n        this.lineNumber = lineNumber;\n        this.columnNumber = columnNumber;\n    }",
    "comment": "Creates a new parser exception with the specified details.\n\n@param message The error message, may be {@code null}.\n@param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.\n@param columnNumber The one-based index of the column containing the error or {@code -1} if unknown.\n@param cause The nested cause of this error, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-di/src/main/java/org/apache/maven/di/impl/Types.java",
    "type": "method",
    "name": "getUppermostType",
    "code": "public static Type getUppermostType(Type[] types) {\n        Type result = types[0];\n        for (int i = 1; i < types.length; i++) {\n            Type type = types[i];\n            if (isAssignable(type, result)) {\n                result = type;\n                continue;\n            } else if (isAssignable(result, type)) {\n                continue;\n            }\n            throw new IllegalArgumentException(\"Unrelated types: \" + result + \" , \" + type);\n        }\n        return result;\n    }",
    "comment": "Returns the most common type among given types"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedRleValuesReader.java",
    "type": "method",
    "name": "if",
    "code": "ParquetVectorUpdater updater) {\n\n    long rowId = state.rowId;\n    int leftInBatch = state.rowsToReadInBatch;\n    int leftInPage = state.valuesToReadInPage;\n\n    while (leftInBatch > 0 && leftInPage > 0) {\n      if (currentCount == 0 && !readNextGroup()) break;\n      int n = Math.min(leftInBatch, Math.min(leftInPage, this.currentCount));\n\n      long rangeStart = state.currentRangeStart();\n      long rangeEnd = state.currentRangeEnd();\n\n      if (rowId + n < rangeStart) {\n        skipValues(n, state, valueReader, updater);\n        rowId += n;\n        leftInPage -= n;\n      } else if (rowId > rangeEnd) {\n        state.nextRange();\n      } else {\n        long start = Math.max(rangeStart, rowId);\n        long end = Math.min(rangeEnd, rowId + n - 1);\n\n        int toSkip = (int) (start - rowId);\n        if (toSkip > 0) {\n          skipValues(toSkip, state, valueReader, updater);\n          rowId += toSkip;\n          leftInPage -= toSkip;\n        }\n\n        n = (int) (end - start + 1);\n        readValuesN(n, state, defLevels, values, nulls, valueReader, updater);\n\n        state.levelOffset += n;\n        leftInBatch -= n;\n        rowId += n;\n        leftInPage -= n;\n        currentCount -= n;\n        defLevels.addElementsAppended(n);\n      }\n    }\n\n    state.rowsToReadInBatch = leftInBatch;\n    state.valuesToReadInPage = leftInPage;\n    state.rowId = rowId;\n  }",
    "comment": "The range [rowId, rowId + n) overlaps with the current row range in state\nSkip the part [rowId, start)\nRead the part [start, end]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestExecutionResult.java",
    "type": "method",
    "name": "failed",
    "code": "public static TestExecutionResult failed(Throwable throwable) {\n\t\treturn new TestExecutionResult(FAILED, throwable);\n\t}",
    "comment": "Create a {@code TestExecutionResult} for a <em>failed</em> execution\nof a test or container with the supplied {@link Throwable throwable}.\n\n@param throwable the throwable that caused the failed execution; may be\n{@code null}\n@return the {@code TestExecutionResult}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/special-case/src/main/java/com/iluwatar/specialcase/DomainServicesImpl.java",
    "type": "method",
    "name": "purchase",
    "code": "public ReceiptViewModel purchase(String userName, String itemName) {\n    Db.User user = Db.getInstance().findUserByUserName(userName);\n    if (user == null) {\n      return new InvalidUser(userName);\n    }\n\n    Db.Account account = Db.getInstance().findAccountByUser(user);\n    return purchase(user, account, itemName);\n  }",
    "comment": "Domain purchase with userName and itemName, with validation for userName.\n\n@param userName of the user\n@param itemName of the item\n@return instance of ReceiptViewModel"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/test/java/org/tensorflow/op/ScopeTest.java",
    "type": "method",
    "name": "zeroValue",
    "code": "public static Object zeroValue(Class<?> c) {\n    return zeros.get(c);\n  }",
    "comment": "Returns the zero value of type described by {@code c}, or null if the type (e.g., string) is\nnot numeric and therefore has no zero value.\n\n@param c The class describing the TensorFlow type of interest."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-executor/src/test/java/org/apache/maven/cling/executor/impl/ToolboxToolTest.java",
    "type": "method",
    "name": "metadataPath3",
    "code": "void metadataPath3(ExecutorHelper.Mode mode) {\n        ExecutorHelper helper = new HelperImpl(\n                mode,\n                mvn3ExecutorRequestBuilder().build().installationDirectory(),\n                userHome,\n                MavenExecutorTestSupport.EMBEDDED_MAVEN_EXECUTOR,\n                MavenExecutorTestSupport.FORKED_MAVEN_EXECUTOR);\n        String path = new ToolboxTool(helper).metadataPath(helper.executorRequest(), \"aopalliance\", \"someremote\");\n        assertTrue(path.endsWith(\"aopalliance\" + File.separator + \"maven-metadata-someremote.xml\"), \"path=\" + path);\n    }",
    "comment": "split repository: assert \"ends with\" as split may introduce prefixes"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProfileActivation.java",
    "type": "method",
    "name": "overwriteInactiveProfiles",
    "code": "public void overwriteInactiveProfiles(List<String> inactiveProfileIds) {\n        getInactiveProfiles().forEach(this.activations::remove);\n        inactiveProfileIds.forEach(this::deactivateOptionalProfile);\n    }",
    "comment": "Overwrites the inactive profiles based on a pre-Maven 4 \"inactive profiles\" list.\n@param inactiveProfileIds A {@link List} of profile IDs that must be deactivated.\n@deprecated Use {@link #deactivateOptionalProfile(String)} or {@link #deactivateRequiredProfile(String)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Byte unexpected, Byte actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/test/java/com/iluwatar/RegisterWorkerTest.java",
    "type": "method",
    "name": "runWithMissingName",
    "code": "void runWithMissingName() {\n    RegisterWorkerDto workerDto = createValidWorkerDto();\n    workerDto.setupWorkerDto(null, \"occupation\", LocalDate.of(2000, 12, 1));\n    RegisterWorker registerWorker = new RegisterWorker(workerDto);\n\n    registerWorker.run();\n\n    assertTrue(registerWorker.getNotification().hasErrors());\n    assertTrue(\n        registerWorker.getNotification().getErrors().contains(RegisterWorkerDto.MISSING_NAME));\n    assertEquals(registerWorker.getNotification().getErrors().size(), 1);\n  }",
    "comment": "Run the registration process\nVerify that the notification contains the missing name error"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Byte expected, Byte actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java",
    "type": "method",
    "name": "testName",
    "code": "protected String testName(FrameworkMethod method) {\n        return method.getName();\n    }",
    "comment": "Returns the name that describes {@code method} for {@link Description}s.\nDefault implementation is the method's name"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/AutoCloseTests.java",
    "type": "method",
    "name": "resetTracking",
    "code": "void resetTracking() {\n\t\tInstancePerClassTestCase.closed = false;\n\t\trecorder.clear();\n\t}",
    "comment": "Integration tests for {@link AutoClose @AutoClose} and the {@link AutoCloseExtension}.\n\n@since 5.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3748BadSettingsXmlTest.java",
    "type": "method",
    "name": "MavenITmng3748BadSettingsXmlTest",
    "code": "public MavenITmng3748BadSettingsXmlTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3748\">MNG-3748</a>.\n\nVerifies that the settings.xml file is parsed using strict mode, such that invalid\nxml will cause an error (specifically, when repositories are not contained within a profile declaration)\n\n@author jdcasey\n\nNOTE (cstamas): this IT was written to test that settings.xml is STRICT, while later changes modified\nthis very IT into the opposite: to test that parsing is LENIENT."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/ReportingTests.java",
    "type": "method",
    "name": "MyReportingTestCase",
    "code": "public MyReportingTestCase(TestReporter reporter) {\n\t\t\treporter.publishEntry(\"Constructor\");\n\t\t\treporter.publishFile(\"constructor\", MediaType.TEXT_PLAIN_UTF_8,\n\t\t\t\tfile -> Files.writeString(file, \"constructor\"));\n\t\t}",
    "comment": "Reported on class-level for PER_CLASS lifecycle and on method-level for PER_METHOD lifecycle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/combinator/src/test/java/com/iluwatar/combinator/CombinatorAppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> CombinatorApp.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nCombinatorApp#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java",
    "type": "method",
    "name": "instanceOf",
    "code": "public static Condition<Throwable> instanceOf(Class<? extends Throwable> expectedType) {\n\t\treturn new Condition<>(expectedType::isInstance, \"instance of %s\", expectedType.getName());\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if a\nthe supplied {@link Class}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "trim",
    "code": "public UTF8String trim() {\n    int s = 0;\n    // skip all of the space (0x20) in the left side\n    while (s < this.numBytes && getByte(s) == ' ') s++;\n    if (s == this.numBytes) {\n      // Everything trimmed\n      return EMPTY_UTF8;\n    }\n    // skip all of the space (0x20) in the right side\n    int e = this.numBytes - 1;\n    while (e > s && getByte(e) == ' ') e--;\n    if (s == 0 && e == numBytes - 1) {\n      // Nothing trimmed\n      return this;\n    }\n    return copyUTF8String(s, e);\n  }",
    "comment": "Trims space characters (ASCII 32) from both ends of this string.\n\n@return this string with no spaces at the start or end"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/BlockPushingListener.java",
    "type": "method",
    "name": "onBlockTransferSuccess",
    "code": "default void onBlockTransferSuccess(String blockId, ManagedBuffer data) {\n    onBlockPushSuccess(blockId, data);\n  }",
    "comment": "Called at least once per block upon failures."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/Column.java",
    "type": "method",
    "name": "create",
    "code": "static Column create(String name, DataType dataType) {\n    return create(name, dataType, true);\n  }",
    "comment": "An interface representing a column of a {@link Table}. It defines basic properties of a column,\nsuch as name and data type, as well as some advanced ones like default column value.\n<p>\nData Sources do not need to implement it. They should consume it in APIs like\n{@link TableCatalog#createTable(Identifier, Column[], Transform[], Map)}, and report it in\n{@link Table#columns()} by calling the static {@code create} functions of this interface to\ncreate it.\n<p>\nA column cannot have both a default value and a generation expression."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(String message, boolean condition) {\n        assertTrue(message, !condition);\n    }",
    "comment": "Asserts that a condition is false. If it isn't it throws an\n{@link AssertionError} with the given message.\n\n@param message the identifying message for the {@link AssertionError} (<code>null</code>\nokay)\n@param condition condition to be checked"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/TestTimedOutException.java",
    "type": "method",
    "name": "TestTimedOutException",
    "code": "public TestTimedOutException(long timeout, TimeUnit timeUnit) {\n        super(String.format(\"test timed out after %d %s\", \n                timeout, timeUnit.name().toLowerCase()));\n        this.timeUnit = timeUnit;\n        this.timeout = timeout;\n    }",
    "comment": "Creates exception with a standard message \"test timed out after [timeout] [timeUnit]\"\n\n@param timeout the amount of time passed before the test was interrupted\n@param timeUnit the time unit for the timeout value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelBuildingException.java",
    "type": "method",
    "name": "getProblems",
    "code": "public List<ModelProblem> getProblems() {\n        if (result == null) {\n            return Collections.emptyList();\n        }\n        return Collections.unmodifiableList(result.getProblems());\n    }",
    "comment": "Gets the problems that caused this exception.\n\n@return The problems that caused this exception, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(float unexpected, float actual, float delta, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, delta, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal\nwithin the given {@code delta}.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaDecisionTreeClassificationExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaDecisionTreeClassificationExample\")\n      .getOrCreate();\n\n    Dataset<Row> data = spark\n      .read()\n      .format(\"libsvm\")\n      .load(\"data/mllib/sample_libsvm_data.txt\");\n\n    StringIndexerModel labelIndexer = new StringIndexer()\n      .setInputCol(\"label\")\n      .setOutputCol(\"indexedLabel\")\n      .fit(data);\n\n    VectorIndexerModel featureIndexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexedFeatures\")\n      .setMaxCategories(4) // features with > 4 distinct values are treated as continuous.\n      .fit(data);\n\n    Dataset<Row>[] splits = data.randomSplit(new double[]{0.7, 0.3});\n      .setStages(new PipelineStage[]{labelIndexer, featureIndexer, dt, labelConverter});\n}",
    "comment": "scalastyle:off println\n$example on$\n$example off$\n$example on$\nLoad the data stored in LIBSVM format as a DataFrame.\nIndex labels, adding metadata to the label column.\nFit on whole dataset to include all labels in index.\nAutomatically identify categorical features, and index them.\nSplit the data into training and test sets (30% held out for testing)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "updateColumnNullability",
    "code": "static TableChange updateColumnNullability(String[] fieldNames, boolean nullable) {\n    return new UpdateColumnNullability(fieldNames, nullable);\n  }",
    "comment": "Create a TableChange for updating the nullability of a field.\n<p>\nThe name is used to find the field to update.\n<p>\nIf the field does not exist, the change will result in an {@link IllegalArgumentException}.\n\n@param fieldNames field names of the column to update\n@param nullable the nullability\n@return a TableChange for the update"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/master-worker/src/main/java/com/iluwatar/masterworker/system/systemworkers/ArrayTransposeWorker.java",
    "type": "method",
    "name": "ArrayTransposeWorker",
    "code": "public ArrayTransposeWorker(Master master, int id) {\n    super(master, id);\n  }",
    "comment": "Class ArrayTransposeWorker extends abstract class {@link Worker} and defines method\nexecuteOperation(), to be performed on data received from master."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/Operation.java",
    "type": "method",
    "name": "createOperationLog",
    "code": "protected void createOperationLog() {\n    if (parentSession.isOperationLogEnabled()) {\n      File operationLogFile = new File(parentSession.getOperationLogSessionDir(),\n          opHandle.getHandleIdentifier().toString());\n      isOperationLogEnabled = true;\n\n      try {\n        if (operationLogFile.exists()) {\n          LOG.warn(\"The operation log file should not exist, but it is already there: {}\",\n            MDC.of(LogKeys.PATH$.MODULE$, operationLogFile.getAbsolutePath()));\n          operationLogFile.delete();\n        }\n        if (!operationLogFile.createNewFile()) {\n          if (!operationLogFile.canRead() || !operationLogFile.canWrite()) {\n            LOG.warn(\"The already existed operation log file cannot be recreated, \" +\n              \"and it cannot be read or written: {}\",\n              MDC.of(LogKeys.PATH$.MODULE$, operationLogFile.getAbsolutePath()));\n            isOperationLogEnabled = false;\n            return;\n          }\n        }\n      } catch (Exception e) {\n        LOG.warn(\"Unable to create operation log file: {}\", e,\n          MDC.of(LogKeys.PATH$.MODULE$, operationLogFile.getAbsolutePath()));\n        isOperationLogEnabled = false;\n        return;\n      }\n\n      try {\n        operationLog = new OperationLog(opHandle.toString(), operationLogFile, parentSession.getHiveConf());\n      } catch (FileNotFoundException e) {\n        LOG.warn(\"Unable to instantiate OperationLog object for operation: {}\", e,\n          MDC.of(LogKeys.OPERATION_HANDLE$.MODULE$, opHandle));\n        isOperationLogEnabled = false;\n        return;\n      }\n\n      OperationLog.setCurrentOperationLog(operationLog);\n    }\n  }",
    "comment": "create log file\nthe log file already exists and cannot be deleted.\nIf it can be read/written, keep its contents and use it.\ncreate OperationLog object with above log file\nregister this operationLog to current thread"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "getValueLength",
    "code": "public int getValueLength() {\n      assert (isDefined);\n      return valueLength;\n    }",
    "comment": "Returns the length of the value defined at this position.\nUnspecified behavior if the key is not defined."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assume.java",
    "type": "method",
    "name": "assumeThat",
    "code": "public static <T> void assumeThat(String message, T actual, Matcher<T> matcher) {\n        if (!matcher.matches(actual)) {\n            throw new AssumptionViolatedException(message, actual, matcher);\n        }\n    }",
    "comment": "Call to assume that <code>actual</code> satisfies the condition specified by <code>matcher</code>.\nIf not, the test halts and is ignored.\nExample:\n<pre>:\nassumeThat(\"alwaysPasses\", 1, is(1)); // passes\nfoo(); // will execute\nassumeThat(\"alwaysFails\", 0, is(1)); // assumption failure! test halts\nint x = 1 / 0; // will never execute\n</pre>\n\n@param <T> the static type accepted by the matcher (this can flag obvious compile-time problems such as {@code assumeThat(1, is(\"a\"))}\n@param actual the computed value being compared\n@param matcher an expression, built of {@link Matcher}s, specifying allowed values\n@see org.hamcrest.CoreMatchers\n@see org.junit.matchers.JUnitMatchers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactoryTests.java",
    "type": "method",
    "name": "setUp",
    "code": "void setUp() {\n\t\tparameters = new TimeoutInvocationParameters<>(invocation, timeoutDuration, () -> \"description\",\n\t\t\tPreInterruptCallbackInvocation.NOOP);\n\t\ttimeoutInvocationFactory = new TimeoutInvocationFactory(store);\n\t}",
    "comment": "org.mockito.exceptions.base.MockitoException: Unable to initialize @Spy annotated field 'store'.\nMockito cannot mock this class: class org.junit.jupiter.engine.execution.NamespaceAwareStore.\nYou are seeing this disclaimer because Mockito is configured to create inlined mocks.\nByte Buddy could not instrument all classes within the mock's type hierarchy."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/filter/ClasspathScanningSupport.java",
    "type": "method",
    "name": "buildClassFilter",
    "code": "public static ClassFilter buildClassFilter(EngineDiscoveryRequest request, Predicate<Class<?>> classPredicate) {\n\t\treturn ClassFilter.of(buildClassNamePredicate(request), classPredicate);\n\t}",
    "comment": "Build a {@link ClassFilter} by combining the name predicate built by\n{@link #buildClassNamePredicate(EngineDiscoveryRequest)} and the passed-in\nclass predicate.\n\n@param request the request to build a name predicate from\n@param classPredicate the class predicate\n@deprecated Please use {@link org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/test/java/com/iluwatar/caching/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "UpdateColumnComment",
    "code": "private UpdateColumnComment(String[] fieldNames, String newComment) {\n      this.fieldNames = fieldNames;\n      this.newComment = newComment;\n    }",
    "comment": "A TableChange to update the comment of a field.\n<p>\nThe field names are used to find the field to update.\n<p>\nIf the field does not exist, the change must result in an {@link IllegalArgumentException}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/util/Os.java",
    "type": "method",
    "name": "isFamily",
    "code": "public static boolean isFamily(String family, String actualOsName) {\n        // windows probing logic relies on the word 'windows' in the OS\n        boolean isWindows = actualOsName.contains(FAMILY_WINDOWS);\n        boolean is9x = false;\n        boolean isNT = false;\n        if (isWindows) {\n            // there are only four 9x platforms that we look for\n            is9x = (actualOsName.contains(\"95\")\n                    || actualOsName.contains(\"98\")\n                    || actualOsName.contains(\"me\")\n                    // wince isn't really 9x, but crippled enough to\n                    // be a muchness. Maven doesn't run on CE, anyway.\n                    || actualOsName.contains(\"ce\"));\n            isNT = !is9x;\n        }\n        return switch (family) {\n            case FAMILY_WINDOWS -> isWindows;\n            case FAMILY_WIN9X -> isWindows && is9x;\n            case FAMILY_NT -> isWindows && isNT;\n            case FAMILY_OS2 -> actualOsName.contains(FAMILY_OS2);\n            case FAMILY_NETWARE -> actualOsName.contains(FAMILY_NETWARE);\n            case FAMILY_DOS -> PATH_SEP.equals(\";\") && !isFamily(FAMILY_NETWARE, actualOsName) && !isWindows;\n            case FAMILY_MAC -> actualOsName.contains(FAMILY_MAC) || actualOsName.contains(DARWIN);\n            case FAMILY_TANDEM -> actualOsName.contains(\"nonstop_kernel\");\n            case FAMILY_UNIX -> PATH_SEP.equals(\":\")\n                    && !isFamily(FAMILY_OPENVMS, actualOsName)\n                    && (!isFamily(FAMILY_MAC, actualOsName) || actualOsName.endsWith(\"x\"));\n            case FAMILY_ZOS -> actualOsName.contains(FAMILY_ZOS) || actualOsName.contains(FAMILY_OS390);\n            case FAMILY_OS400 -> actualOsName.contains(FAMILY_OS400);\n            case FAMILY_OPENVMS -> actualOsName.contains(FAMILY_OPENVMS);\n            default -> actualOsName.contains(family.toLowerCase(Locale.US));\n        };\n    }",
    "comment": "Determines if the OS on which Maven is executing matches the\ngiven OS family derived from the given OS name\n\n@param family the family to check for\n@param actualOsName the OS name to check against\n@return true if the OS matches"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/transfer/SimplexTransferListener.java",
    "type": "method",
    "name": "SimplexTransferListener",
    "code": "public SimplexTransferListener(TransferListener delegate) {\n        this(delegate, QUEUE_SIZE, BATCH_MAX_SIZE, true);\n    }",
    "comment": "Constructor that makes passed in delegate run on single thread, and will block on last event."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/project/ProjectBuilderTest.java",
    "type": "method",
    "name": "Thread",
    "code": "Thread t = new Thread(new Runnable() {\n        });",
    "comment": "Here we will actually not have any artifacts because the ProjectDependenciesResolver is not involved here. So\nright now it's not valid to ask for artifacts unless plugins require the artifacts.\nsingle project build entry point\nmulti projects build entry point"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(double[] expected, double[] actual, double delta, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, delta, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} double arrays are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/MemoryHealthIndicatorTest.java",
    "type": "method",
    "name": "whenHealthCheckExecutionFails_thenHealthIsDown",
    "code": "void whenHealthCheckExecutionFails_thenHealthIsDown() {\n    // Arrange\n    CompletableFuture<Health> future = new CompletableFuture<>();\n    future.completeExceptionally(\n        new ExecutionException(new RuntimeException(\"Service unavailable\")));\n    when(asynchronousHealthChecker.performCheck(any(Supplier.class), anyLong())).thenReturn(future);\n\n    // Act\n    Health health = memoryHealthIndicator.health();\n\n    // Assert\n    assertEquals(Status.DOWN, health.getStatus());\n    assertTrue(health.getDetails().get(\"error\").toString().contains(\"Service unavailable\"));\n  }",
    "comment": "Test case for the `health()` method when the health check execution fails.\n\n<p>Asserts that when the `health()` method is called and the health check execution fails, it\nreturns a Health object with Status DOWN and an error detail indicating the failure."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestExecutionExceptionHandlerTests.java",
    "type": "method",
    "name": "handleTestExecutionException",
    "code": "public void handleTestExecutionException(ExtensionContext context, Throwable throwable) {\n\t\t\tassertInstanceOf(IOException.class, throwable);\n\t\t\thandleExceptionCalled = true;\n\t\t\thandlerCalls.add(\"swallow\");\n\t\t}",
    "comment": "swallow exception by not rethrowing it"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "getAvgHashProbesPerKey",
    "code": "public double getAvgHashProbesPerKey() {\n    return (1.0 * numProbes) / numKeyLookups;\n  }",
    "comment": "Returns the average number of probes per key lookup."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/master-worker/src/main/java/com/iluwatar/masterworker/ArrayUtilityMethods.java",
    "type": "method",
    "name": "matricesSame",
    "code": "public static boolean matricesSame(int[][] m1, int[][] m2) {\n    if (m1.length != m2.length) {\n      return false;\n    } else {\n      var answer = false;\n      for (var i = 0; i < m1.length; i++) {\n        if (arraysSame(m1[i], m2[i])) {\n          answer = true;\n        } else {\n          answer = false;\n          break;\n        }\n      }\n      return answer;\n    }\n  }",
    "comment": "Method matricesSame compares 2 matrices @param m1 and @param m2 and @return whether their\nvalues are equal (boolean)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/AsynchronousHealthCheckerTest.java",
    "type": "method",
    "name": "doesLogContainMessage",
    "code": "private boolean doesLogContainMessage(Runnable action) {\n    action.run();\n    List<ILoggingEvent> events = listAppender.list;\n    return events.stream()\n        .anyMatch(event -> event.getMessage().contains(\"Health check executor did not terminate\"));\n  }",
    "comment": "Helper method to check if the log contains a specific message.\n\n@param action The action that triggers the log statement.\n@return True if the log contains the message after the action is performed, false otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java",
    "type": "method",
    "name": "FailOnTimeout",
    "code": "public FailOnTimeout(Statement statement, long timeoutMillis) {\n        this(builder().withTimeout(timeoutMillis, TimeUnit.MILLISECONDS), statement);\n    }",
    "comment": "Creates an instance wrapping the given statement with the given timeout in milliseconds.\n\n@param statement the statement to wrap\n@param timeoutMillis the timeout in milliseconds\n@deprecated use {@link #builder()} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getFieldAtIndex",
    "code": "public ObjectField getFieldAtIndex(int index) {\n    return handleObject(value, pos, (size, idSize, offsetSize, idStart, offsetStart, dataStart) -> {\n      if (index < 0 || index >= size) return null;\n      int id = readUnsigned(value, idStart + idSize * index, idSize);\n      int offset = readUnsigned(value, offsetStart + offsetSize * index, offsetSize);\n      String key = getMetadataKey(metadata, id);\n      Variant v = new Variant(value, metadata, dataStart + offset);\n      return new ObjectField(key, v);\n    });\n  }",
    "comment": "Get the object field at the `index` slot. Return null if `index` is out of the bound of\n`[0, objectSize())`.\nIt is only legal to call it when `getType()` is `Type.OBJECT`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "setConfig",
    "code": "public static void setConfig(String name, String value) {\n    launcherConfig.put(name, value);\n  }",
    "comment": "Set a configuration value for the launcher library. These config values do not affect the\nlaunched application, but rather the behavior of the launcher library itself when managing\napplications.\n\n@since 1.6.0\n@param name Config name.\n@param value Config value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertNotSame",
    "code": "public static void assertNotSame(Object expected, Object actual) {\n        assertNotSame(null, expected, actual);\n    }",
    "comment": "Asserts that two objects do not refer to the same object. If they do\nrefer to the same object an AssertionFailedError is thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantShreddingWriter.java",
    "type": "method",
    "name": "if",
    "code": "ShreddedResultBuilder builder) {\n    VariantUtil.Type variantType = v.getType();\n    ShreddedResult result = builder.createEmpty(schema);\n\n    if (schema.topLevelMetadataIdx >= 0) {\n      result.addMetadata(v.getMetadata());\n    }\n\n    if (schema.arraySchema != null && variantType == VariantUtil.Type.ARRAY) {\n      // The array element is always a struct containing untyped and typed fields.\n      VariantSchema elementSchema = schema.arraySchema;\n      int size = v.arraySize();\n      ShreddedResult[] array = new ShreddedResult[size];\n      for (int i = 0; i < size; ++i) {\n        ShreddedResult shreddedArray = castShredded(v.getElementAtIndex(i), elementSchema, builder);\n        array[i] = shreddedArray;\n      }\n      result.addArray(array);\n    } else if (schema.objectSchema != null && variantType == VariantUtil.Type.OBJECT) {\n      VariantSchema.ObjectField[] objectSchema = schema.objectSchema;\n      ShreddedResult[] shreddedValues = new ShreddedResult[objectSchema.length];\n\n      // Create a variantBuilder for any field that exist in `v`, but not in the shredding schema.\n      VariantBuilder variantBuilder = new VariantBuilder(false);\n      ArrayList<VariantBuilder.FieldEntry> fieldEntries = new ArrayList<>();\n      // Keep track of which schema fields we actually found in the Variant value.\n      int numFieldsMatched = 0;\n      int start = variantBuilder.getWritePos();\n      for (int i = 0; i < v.objectSize(); ++i) {\n        Variant.ObjectField field = v.getFieldAtIndex(i);\n        Integer fieldIdx = schema.objectSchemaMap.get(field.key);\n        if (fieldIdx != null) {\n          // The field exists in the shredding schema. Recursively shred, and write the result.\n          ShreddedResult shreddedField = castShredded(\n              field.value, objectSchema[fieldIdx].schema, builder);\n          shreddedValues[fieldIdx] = shreddedField;\n          numFieldsMatched++;\n        } else {\n          // The field is not shredded. Put it in the untyped_value column.\n          int id = v.getDictionaryIdAtIndex(i);\n          fieldEntries.add(new VariantBuilder.FieldEntry(\n              field.key, id, variantBuilder.getWritePos() - start));\n          // shallowAppendVariant is needed for correctness, since we're relying on the metadata IDs\n          // being unchanged.\n          variantBuilder.shallowAppendVariant(field.value);\n        }\n      }\n      if (numFieldsMatched < objectSchema.length) {\n        // Set missing fields to non-null with all fields set to null.\n        for (int i = 0; i < objectSchema.length; ++i) {\n          if (shreddedValues[i] == null) {\n            VariantSchema.ObjectField fieldSchema = objectSchema[i];\n            ShreddedResult emptyChild = builder.createEmpty(fieldSchema.schema);\n            shreddedValues[i] = emptyChild;\n            numFieldsMatched += 1;\n          }\n        }\n      }\n      if (numFieldsMatched != objectSchema.length) {\n        // Since we just filled in all the null entries, this can only happen if we tried to write\n        // to the same field twice; i.e. the Variant contained duplicate fields, which is invalid.\n        throw VariantUtil.malformedVariant();\n      }\n      result.addObject(shreddedValues);\n      if (variantBuilder.getWritePos() != start) {\n        // We added something to the untyped value.\n        variantBuilder.finishWritingObject(start, fieldEntries);\n        result.addVariantValue(variantBuilder.valueWithoutMetadata());\n      }\n    } else if (schema.scalarSchema != null) {\n      VariantSchema.ScalarType scalarType = schema.scalarSchema;\n      Object typedValue = tryTypedShred(v, variantType, scalarType, builder);\n      if (typedValue != null) {\n        // Store the typed value.\n        result.addScalar(typedValue);\n      } else {\n        result.addVariantValue(v.getValue());\n      }\n    } else {\n      // Store in untyped.\n      result.addVariantValue(v.getValue());\n    }\n    return result;\n  }",
    "comment": "Converts an input variant into shredded components. Returns the shredded result, as well\nas the original Variant with shredded fields removed.\n`dataType` must be a valid shredding schema, as described in\nhttps://github.com/apache/parquet-format/blob/master/VariantShredding.md."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/DefaultMaven.java",
    "type": "method",
    "name": "execute",
    "code": "public MavenExecutionResult execute(MavenExecutionRequest request) {\n        MavenExecutionResult result;\n\n        try {\n            result = doExecute(request);\n        } catch (OutOfMemoryError e) {\n            result = addExceptionToResult(new DefaultMavenExecutionResult(), e);\n        } catch (RuntimeException e) {\n            if (e.getCause() instanceof ProjectCycleException) {\n                result = addExceptionToResult(new DefaultMavenExecutionResult(), e.getCause());\n            } else {\n                result = addExceptionToResult(\n                        new DefaultMavenExecutionResult(), new InternalErrorException(\"Internal error: \" + e, e));\n            }\n        } finally {\n            legacySupport.setSession(null);\n        }\n\n        return result;\n    }",
    "comment": "TODO Hack to make the cycle detection the same for the new graph builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng6090CIFriendlyTest.java",
    "type": "method",
    "name": "MavenITmng6090CIFriendlyTest",
    "code": "public MavenITmng6090CIFriendlyTest() {\n        // The first version which contains the fix for the MNG-issue.\n        // TODO: Think about it!\n        super(\"[3.5.0-alpha-2,)\");\n    }",
    "comment": "The usage of a <code>${revision}</code> for the version in the pom file and furthermore\ndefining the property in the pom file and overwrite it via command line and\ntry to build a partial reactor via <code>mvn -pl ..</code>\n<a href=\"https://issues.apache.org/jira/browse/MNG-6090\">MNG-6090</a>.\n\n@author Karl Heinz Marbaise khmarbaise@apache.org"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng6057CheckReactorOrderTest.java",
    "type": "method",
    "name": "MavenITmng6057CheckReactorOrderTest",
    "code": "public MavenITmng6057CheckReactorOrderTest() {\n        // The first version which contains the fix for the MNG-6057 issue.\n        // TODO: Think about it!\n        super(\"[3.5.0-alpha-2,)\");\n    }",
    "comment": "Using a <code>${revision}</code> in the version will change the reactor order before fixing\n<a href=\"https://issues.apache.org/jira/browse/MNG-6057\">MNG-6057</a>. Without the fix for this issue the order of\nthe reactor is changed in that way that the parent is ordered to the last position instead of the first position.\n\n@author Karl Heinz Marbaise khmarbaise@apache.org"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroPrimitives.java",
    "type": "method",
    "name": "setBoolColumn",
    "code": "public void setBoolColumn(java.lang.Boolean value) {\n    this.bool_column = value;\n  }",
    "comment": "Sets the value of the 'bool_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertLinesMatch",
    "code": "public static void assertLinesMatch(Stream<String> expectedLines, Stream<String> actualLines) {\n\t\tAssertLinesMatch.assertLinesMatch(expectedLines, actualLines);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} stream of {@linkplain String}s matches {@code actual}\nstream.\n\n<p>Find a detailed description of the matching algorithm in {@link #assertLinesMatch(List, List)}.\n\n<p>Note: An implementation of this method may consume all lines of both streams eagerly and\ndelegate the evaluation to {@link #assertLinesMatch(List, List)}.\n\n@since 5.7\n@see #assertLinesMatch(List, List)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/internal/impl/TestApi.java",
    "type": "method",
    "name": "testResolveArtifactCoordinatesDependencies",
    "code": "void testResolveArtifactCoordinatesDependencies() {\n        DependencyCoordinates coords = session.createDependencyCoordinates(\n                session.createArtifactCoordinates(\"org.apache.maven.core.test\", \"test-extension\", \"1\", \"jar\"));\n\n        List<Path> paths = session.resolveDependencies(coords);\n\n        assertNotNull(paths);\n        assertEquals(10, paths.size());\n        assertEquals(\"test-extension-1.jar\", paths.get(0).getFileName().toString());\n\n        Map<PathType, List<Path>> dispatched = session.resolveDependencies(\n                coords, PathScope.TEST_COMPILE, Arrays.asList(JavaPathType.CLASSES, JavaPathType.MODULES));\n        List<Path> classes = dispatched.get(JavaPathType.CLASSES);\n        List<Path> modules = dispatched.get(JavaPathType.MODULES);\n        List<Path> unresolved = dispatched.get(PathType.UNRESOLVED);\n        assertEquals(3, dispatched.size());\n        assertEquals(1, unresolved.size());\n        assertEquals(8, classes.size()); // \"plexus.pom\" and \"junit.jar\" are excluded.\n        assertEquals(1, modules.size());\n        assertEquals(\"plexus-1.0.11.pom\", unresolved.get(0).getFileName().toString());\n        assertEquals(\"test-extension-1.jar\", classes.get(0).getFileName().toString());\n        assertEquals(\"junit-4.13.1.jar\", modules.get(0).getFileName().toString());\n        assertTrue(paths.containsAll(classes));\n        assertTrue(paths.containsAll(modules));\n\n        dispatched = session.resolveDependencies(coords, PathScope.TEST_COMPILE, Arrays.asList(JavaPathType.CLASSES));\n        classes = dispatched.get(JavaPathType.CLASSES);\n        modules = dispatched.get(JavaPathType.MODULES);\n        unresolved = dispatched.get(PathType.UNRESOLVED);\n        assertEquals(2, dispatched.size());\n        assertEquals(1, unresolved.size());\n        assertEquals(9, classes.size());\n        assertNull(modules);\n        assertTrue(paths.containsAll(classes));\n        assertEquals(\"plexus-1.0.11.pom\", unresolved.get(0).getFileName().toString());\n    }",
    "comment": "JUnit has an \"Automatic-Module-Name\", so it appears on the module path.\nIf caller wants only a classpath, JUnit shall move there."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/CacheStore.java",
    "type": "method",
    "name": "invalidate",
    "code": "public void invalidate(final String userId) {\n    cache.invalidate(userId);\n  }",
    "comment": "Delegate to backing cache store.\n\n@param userId {@link String}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/commander/src/main/java/com/iluwatar/commander/shippingservice/ShippingService.java",
    "type": "method",
    "name": "ShippingService",
    "code": "public ShippingService(ShippingDatabase db, Exception... exc) {\n    super(db, exc);\n  }",
    "comment": "ShippingService class receives request from {@link com.iluwatar.commander.Commander} class and\nadds it to the {@link ShippingDatabase}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/ExtensibleEnums.java",
    "type": "method",
    "name": "language",
    "code": "static Language language(String id) {\n        return new DefaultLanguage(id);\n    }",
    "comment": "Creates a new Language instance with the specified ID.\n\n@param id the identifier for the language\n@return a new Language instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/serialized-lob/src/main/java/com/iluwatar/slob/App.java",
    "type": "method",
    "name": "createForest",
    "code": "private static Forest createForest() {\n    Plant grass = new Plant(\"Grass\", \"Herb\");\n    Plant oak = new Plant(\"Oak\", \"Tree\");\n\n    Animal zebra = new Animal(\"Zebra\", Set.of(grass), Collections.emptySet());\n    Animal buffalo = new Animal(\"Buffalo\", Set.of(grass), Collections.emptySet());\n    Animal lion = new Animal(\"Lion\", Collections.emptySet(), Set.of(zebra, buffalo));\n\n    return new Forest(\"Amazon\", Set.of(lion, buffalo, zebra), Set.of(grass, oak));\n  }",
    "comment": "Creates a Forest with {@link Animal} and {@link Plant} along with their respective\nrelationships.\n\n<p>The method creates a {@link Forest} with 2 Plants Grass and Oak of type Herb and tree\nrespectively.\n\n<p>It also creates 3 animals Zebra and Buffalo which eat the plant grass. Lion consumes the\nZebra and the Buffalo.\n\n<p>With the above animals and plants and their relationships a forest object is created which\nrepresents the Object Graph.\n\n@return Forest Object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolver.java",
    "type": "method",
    "name": "addResourceContainerSelectorResolver",
    "code": "public Builder<T> addResourceContainerSelectorResolver(Predicate<Resource> resourceFilter) {\n\t\t\tPreconditions.notNull(resourceFilter, \"resourceFilter must not be null\");\n\t\t\treturn addSelectorResolver(\n\t\t\t\tcontext -> new ResourceContainerSelectorResolver(resourceFilter, context.getPackageFilter()));\n\t\t}",
    "comment": "Add a predefined resolver that resolves {@link ClasspathRootSelector\nClasspathRootSelectors}, {@link ModuleSelector ModuleSelectors}, and\n{@link PackageSelector PackageSelectors} into {@link ClasspathResourceSelector\nClasspathResourceSelectors} by scanning for resources that satisfy the supplied\npredicate in the respective class containers to this builder.\n\n@param resourceFilter predicate the resolved classes must satisfy; never\n{@code null}\n@return this builder for method chaining\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(boolean[] expecteds, boolean[] actuals) {\n        assertArrayEquals(null, expecteds, actuals);\n    }",
    "comment": "Asserts that two boolean arrays are equal. If they are not, an\n{@link AssertionError} is thrown. If <code>expected</code> and\n<code>actual</code> are <code>null</code>, they are considered\nequal.\n\n@param expecteds boolean array with expected values.\n@param actuals boolean array with expected values."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/extensions/AllTests.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n        junit.textui.TestRunner.run(suite());\n    }",
    "comment": "TestSuite that runs all the extension tests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/textui/TestRunner.java",
    "type": "method",
    "name": "TestRunner",
    "code": "public TestRunner(ResultPrinter printer) {\n        fPrinter = printer;\n    }",
    "comment": "Constructs a TestRunner using the given ResultPrinter all the output"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportFrameDecoder.java",
    "type": "method",
    "name": "nextBufferForFrame",
    "code": "private ByteBuf nextBufferForFrame(int bytesToRead) {\n    ByteBuf buf = buffers.getFirst();\n    ByteBuf frame;\n\n    if (buf.readableBytes() > bytesToRead) {\n      frame = buf.retain().readSlice(bytesToRead);\n      totalSize -= bytesToRead;\n    } else {\n      frame = buf;\n      buffers.removeFirst();\n      totalSize -= frame.readableBytes();\n    }\n\n    return frame;\n  }",
    "comment": "Takes the first buffer in the internal list, and either adjust it to fit in the frame\n(by taking a slice out of it) or remove it from the internal list."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/Logger.java",
    "type": "method",
    "name": "error",
    "code": "default void error(@Nonnull String message) {\n        log(Level.ERROR, message);\n    }",
    "comment": "Logs an error message without an associated exception.\n\n@param message the error message to be logged"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/VersionRange.java",
    "type": "method",
    "name": "matchVersion",
    "code": "public ArtifactVersion matchVersion(List<ArtifactVersion> versions) {\n\n        ArtifactVersion matched = null;\n        for (ArtifactVersion version : versions) {\n            if (containsVersion(version)) {\n                if (matched == null || version.compareTo(matched) > 0) {\n                    matched = version;\n                }\n            }\n        }\n        return matched;\n    }",
    "comment": "TODO could be more efficient by sorting the list and then moving along the restrictions in order?\nvalid - check if it is greater than the currently matched version"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "addFailure",
    "code": "public synchronized void addFailure(Test test, AssertionFailedError e) {\n        fFailures.add(new TestFailure(test, e));\n        for (TestListener each : cloneListeners()) {\n            each.addFailure(test, e);\n        }\n    }",
    "comment": "Adds a failure to the list of failures. The passed in exception\ncaused the failure."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Timeout.java",
    "type": "method",
    "name": "apply",
    "code": "public Statement apply(Statement base, Description description) {\n        try {\n            return createFailOnTimeoutStatement(base);\n        } catch (final Exception e) {\n            return new Statement() {\n            };\n        }\n    }",
    "comment": "Creates a {@link Statement} that will run the given\n{@code statement}, and timeout the operation based\non the values configured in this rule. Subclasses\ncan override this method for different behavior.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(byte unexpected, byte actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "destructiveIterator",
    "code": "public MapIterator destructiveIterator() {\n    updatePeakMemoryUsed();\n    return new MapIterator(numValues, new Location(), true);\n  }",
    "comment": "Returns a destructive iterator for iterating over the entries of this map. It frees each page\nas it moves onto next one. Notice: it is illegal to call any method on the map after\n`destructiveIterator()` has been called.\n\nFor efficiency, all calls to `next()` will return the same {@link Location} object.\n\nThe returned iterator is thread-safe. However if the map is modified while iterating over it,\nthe behavior of the returned iterator is undefined."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java",
    "type": "method",
    "name": "from",
    "code": "public static MethodSource from(Method testMethod) {\n\t\treturn new MethodSource(testMethod);\n\t}",
    "comment": "Create a new {@code MethodSource} using the supplied {@link Method method}.\n@see #from(Class, Method)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/memory/MemoryBlock.java",
    "type": "method",
    "name": "fill",
    "code": "public void fill(byte value) {\n    Platform.setMemory(obj, offset, length, value);\n  }",
    "comment": "Fills the memory block with the specified byte value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/classification/JavaRandomForestClassifierSuite.java",
    "type": "method",
    "name": "runDT",
    "code": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 2);\n\n    RandomForestClassifier rf = new RandomForestClassifier()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setSubsamplingRate(1.0)\n      .setSeed(1234)\n      .setNumTrees(3)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String impurity : RandomForestClassifier.supportedImpurities()) {\n      rf.setImpurity(impurity);\n    }\n    for (String featureSubsetStrategy : RandomForestClassifier.supportedFeatureSubsetStrategies()) {\n      rf.setFeatureSubsetStrategy(featureSubsetStrategy);\n    }\n    String[] realStrategies = {\".1\", \".10\", \"0.10\", \"0.1\", \"0.9\", \"1.0\"};\n    for (String strategy : realStrategies) {\n      rf.setFeatureSubsetStrategy(strategy);\n    }\n    String[] integerStrategies = {\"1\", \"10\", \"100\", \"1000\", \"10000\"};\n    for (String strategy : integerStrategies) {\n      rf.setFeatureSubsetStrategy(strategy);\n    }\n    String[] invalidStrategies = {\"-.1\", \"-.10\", \"-0.10\", \".0\", \"0.0\", \"1.1\", \"0\"};\n    for (String strategy : invalidStrategies) {\n      Assertions.assertThrows(IllegalArgumentException.class,\n        () -> rf.setFeatureSubsetStrategy(strategy));\n    }\n\n    RandomForestClassificationModel model = rf.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.totalNumNodes();\n    model.toDebugString();\n    model.trees();\n    model.treeWeights();\n    Vector importances = model.featureImportances();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model3.save(sc.sc(), path);\n      RandomForestClassificationModel sameModel =\n          RandomForestClassificationModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model3, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
    "comment": "This tests setters. Training with various options is tested in Scala.\nTODO: Add test once save/load are implemented.  SPARK-6725"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "enableImplicitConfigurationParameters",
    "code": "public SuiteLauncherDiscoveryRequestBuilder enableImplicitConfigurationParameters(boolean enabled) {\n\t\tthis.delegate.enableImplicitConfigurationParameters(enabled);\n\t\treturn this;\n\t}",
    "comment": "Configure whether implicit configuration parameters should be considered.\n\n<p>By default, in addition to those parameters that are passed explicitly\nto this builder, configuration parameters are read from system properties\nand from the {@code junit-platform.properties} classpath resource.\nPassing {@code false} to this method, disables the latter two sources so\nthat only explicit configuration parameters are taken into account.\n\n@param enabled {@code true} if implicit configuration parameters should be\nconsidered\n@return this builder for method chaining\n@see #configurationParameter(String, String)\n@see #configurationParameters(Map)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/CpuHealthIndicatorTest.java",
    "type": "method",
    "name": "setUp",
    "code": "void setUp() {\n    // Mock the com.sun.management.OperatingSystemMXBean\n    mockOsBean = Mockito.mock(com.sun.management.OperatingSystemMXBean.class);\n    cpuHealthIndicator = new CpuHealthIndicator();\n    setOperatingSystemMXBean(cpuHealthIndicator, mockOsBean);\n  }",
    "comment": "Sets up the test environment before each test method.\n\n<p>Mocks the {@link OperatingSystemMXBean} and sets it in the {@link CpuHealthIndicator}\ninstance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/ByteArray.java",
    "type": "method",
    "name": "fillWithPattern",
    "code": "private static void fillWithPattern(byte[] result, int firstPos, int beyondPos, byte[] pad) {\n    for (int pos = firstPos; pos < beyondPos; pos += pad.length) {\n      final int jMax = Math.min(pad.length, beyondPos - pos);\n      for (int j = 0; j < jMax; ++j) {\n        result[pos + j] = pad[j];\n      }\n    }\n  }",
    "comment": "Helper method for implementing `lpad` and `rpad`.\nFills the resulting byte sequence with the pattern. The resulting byte sequence is\npassed as the first argument and it is filled from position `firstPos` (inclusive)\nto position `beyondPos` (not inclusive)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/AssumptionViolatedException.java",
    "type": "method",
    "name": "AssumptionViolatedException",
    "code": "public <T> AssumptionViolatedException(T actual, Matcher<T> matcher) {\n        super(actual, matcher);\n    }",
    "comment": "An assumption exception with the given <i>actual</i> value and a <i>matcher</i> describing\nthe expectation that failed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/VersionTest.java",
    "type": "method",
    "name": "testCompareUuidRandom",
    "code": "void testCompareUuidRandom() {\n        for (int j = 0; j < 32; j++) {\n            ArrayList<Version> versions = new ArrayList<>();\n            for (int i = 0; i < 64; i++) {\n                versions.add(newVersion(UUID.randomUUID().toString()));\n            }\n            try {\n                Collections.sort(versions);\n            } catch (Exception e) {\n                e.printStackTrace(System.err);\n                System.err.println(\"The UUIDs used\");\n                System.err.println(versions.stream().map(Version::toString).collect(Collectors.joining(\"\\n\")));\n                fail(\"unexpected exception\");\n            }\n        }\n    }",
    "comment": "UT for <a href=\"https://issues.apache.org/jira/browse/MRESOLVER-314\">MRESOLVER-314</a>.\n\nGenerates random UUID string based versions and tries to sort them. While this test is not as reliable\nas {@link #testCompareUuidVersionStringStream()}, it covers broader range and in case it fails it records\nthe failed array, so we can investigate more."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeNeverField",
    "code": "void cleanupModeNeverField() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(NeverFieldCase.class, \"testNeverField\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(neverFieldDir).exists();\n\t\t}",
    "comment": "Ensure that NEVER cleanup modes are obeyed for fields.\n<p/>\nExpect the TempDir not to be cleaned up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(double expected, Double actual, String message) {\n\t\tAssertEquals.assertEquals((Double) expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoverySelectorIdentifier.java",
    "type": "method",
    "name": "create",
    "code": "public static DiscoverySelectorIdentifier create(String prefix, String value) {\n\t\treturn new DiscoverySelectorIdentifier(prefix, value);\n\t}",
    "comment": "Create a new {@code DiscoverySelectorIdentifier} with the supplied prefix and\n@param value the value; never {@code null} or blank"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "readFieldValue",
    "code": "public static Optional<Object> readFieldValue(Field field, Object instance) {\n\t\treturn tryToReadFieldValue(field, instance).toOptional();\n\t}",
    "comment": "Read the value of the supplied field, making it accessible if necessary\nand {@linkplain ExceptionUtils#throwAsUncheckedException masking} any\nchecked exception as an unchecked exception.\n\n<p>If the value of the field is {@code null}, an empty {@link Optional}\nwill be returned.\n\n@param field the field to read; never {@code null}\n@param instance the instance from which the value is to be read; may\nbe {@code null} for a static field\n@see #readFieldValue(Field)\n@see #readFieldValue(Class, String, Object)\n@deprecated Please use {@link #tryToReadFieldValue(Field, Object)}\ninstead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/plugin/testing/stubs/RepositorySystemSupplier.java",
    "type": "method",
    "name": "createArtifactDecoratorFactories",
    "code": "protected Map<String, ArtifactDecoratorFactory> createArtifactDecoratorFactories() {\n        return new HashMap<>();\n    }",
    "comment": "by default none, this is extension point"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/server/RpcHandler.java",
    "type": "method",
    "name": "receive",
    "code": "public void receive(TransportClient client, ByteBuffer message) {\n    receive(client, message, ONE_WAY_CALLBACK);\n  }",
    "comment": "Receives an RPC message that does not expect a reply. The default implementation will\ncall \"{@link #receive(TransportClient, ByteBuffer, RpcResponseCallback)}\" and log a warning if\nany of the callback methods are called.\n\n@param client A channel client which enables the handler to make requests back to the sender\nof this RPC. This will always be the exact same object for a particular channel.\n@param message The serialized bytes of the RPC."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/lifecycle/LifecycleConfiguration.java",
    "type": "method",
    "name": "setLifecycles",
    "code": "public void setLifecycles(java.util.List<Lifecycle> lifecycles) {\n        this.lifecycles = lifecycles;\n    } // -- void setLifecycles( java.util.List )",
    "comment": "Set the lifecycles field.\n\n@param lifecycles a lifecycles object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/RepositoryUtils.java",
    "type": "method",
    "name": "nullify",
    "code": "private static String nullify(String string) {\n        return (string == null || string.isEmpty()) ? null : string;\n    }",
    "comment": "<strong>Warning:</strong> This is an internal utility class that is only public for technical reasons, it is not part\nof the public API. In particular, this class can be changed or deleted without prior notice."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/shuffle/sort/ShuffleInMemorySorter.java",
    "type": "method",
    "name": "reset",
    "code": "public void reset() {\n    pos = 0;\n    if (consumer != null) {\n      consumer.freeArray(array);\n      array = null;\n      usableCapacity = 0;\n      array = consumer.allocateArray(initialSize);\n      usableCapacity = getUsableCapacity();\n    }\n  }",
    "comment": "Reset `pos` here so that `spill` triggered by the below `allocateArray` will be no-op.\nAs `array` has been released, we should set it to  `null` to avoid accessing it before\n`allocateArray` returns. `usableCapacity` is also set to `0` to avoid any codes writing\ndata to `ShuffleInMemorySorter` when `array` is `null` (e.g., in\nShuffleExternalSorter.growPointerArrayIfNecessary, we may try to access\n`ShuffleInMemorySorter` when `allocateArray` throws SparkOutOfMemoryError)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testSimpleMultiply",
    "code": "public void testSimpleMultiply() {\n        Money expected = new Money(28, \"CHF\");\n        assertEquals(expected, f14CHF.multiply(2));\n    }",
    "comment": "[14 CHF] *2 == [28 CHF]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "findAllResourcesInClasspathRoot",
    "code": "public static List<Resource> findAllResourcesInClasspathRoot(URI root, Predicate<Resource> resourceFilter) {\n\t\treturn ReflectionUtils.findAllResourcesInClasspathRoot(root, resourceFilter);\n\t}",
    "comment": "Find all {@linkplain Resource resources} in the supplied classpath {@code root}\nthat match the specified {@code resourceFilter} predicate.\n\n<p>The classpath scanning algorithm searches recursively in subpackages\nbeginning with the root of the classpath.\n\n@param root the URI for the classpath root in which to scan; never\n{@code null}\n@param resourceFilter the resource type filter; never {@code null}\n@return an immutable list of all such resources found; never {@code null}\nbut potentially empty\n@since 1.11\n@see #findAllResourcesInPackage(String, Predicate)\n@see #findAllResourcesInModule(String, Predicate)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterApi.java",
    "type": "method",
    "name": "create",
    "code": "static InterpreterApi create(@NonNull ByteBuffer byteBuffer, InterpreterApi.Options options) {\n    TfLiteRuntime runtime = (options == null ? null : options.getRuntime());\n    InterpreterFactoryApi factory = TensorFlowLite.getFactory(runtime);\n    return factory.create(byteBuffer, options);\n  }",
    "comment": "Constructs an {@link InterpreterApi} instance, using the specified model and options. The model\nwill be read from a {@code ByteBuffer}.\n\n@param byteBuffer A pre-trained TF Lite model, in binary serialized form. The ByteBuffer should\nnot be modified after the construction of an {@link InterpreterApi} instance. The {@code\nByteBuffer} can be either a {@code MappedByteBuffer} that memory-maps a model file, or a\ndirect {@code ByteBuffer} of nativeOrder() that contains the bytes content of a model.\n@param options A set of options for customizing interpreter behavior.\n@throws IllegalArgumentException if {@code byteBuffer} is not a {@code MappedByteBuffer} nor a\ndirect {@code ByteBuffer} of nativeOrder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, String expected, String actual) {\n        Assert.assertEquals(message, expected, actual);\n    }",
    "comment": "Asserts that two Strings are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java",
    "type": "method",
    "name": "initProject",
    "code": "private void initProject(MavenProject project, ModelBuilderResult result) {\n            project.setModel(new org.apache.maven.model.Model(result.getEffectiveModel()));\n            project.setOriginalModel(new org.apache.maven.model.Model(result.getFileModel()));\n\n            initParent(project, result);\n\n            Artifact projectArtifact = repositorySystem.createArtifact(\n                    project.getGroupId(), project.getArtifactId(), project.getVersion(), null, project.getPackaging());\n            project.setArtifact(projectArtifact);\n\n            if (project.getFile() != null) {\n                Build build = project.getBuild().getDelegate();\n                List<org.apache.maven.api.model.Source> sources = build.getSources();\n                Path baseDir = project.getBaseDirectory();\n                boolean hasScript = false;\n                boolean hasMain = false;\n                boolean hasTest = false;\n                for (var source : sources) {\n                    var src = new DefaultSourceRoot(session, baseDir, source);\n                    project.addSourceRoot(src);\n                    Language language = src.language();\n                    if (Language.JAVA_FAMILY.equals(language)) {\n                        ProjectScope scope = src.scope();\n                        if (ProjectScope.MAIN.equals(scope)) {\n                            hasMain = true;\n                        } else {\n                            hasTest |= ProjectScope.TEST.equals(scope);\n                        }\n                    } else {\n                        hasScript |= Language.SCRIPT.equals(language);\n                    }\n                }\n                /*\n                 * `sourceDirectory`, `testSourceDirectory` and `scriptSourceDirectory`\n                 * are ignored if the POM file contains at least one <source> element\n                 * for the corresponding scope and language. This rule exists because\n                 * Maven provides default values for those elements which may conflict\n                 * with user's configuration.\n                 */\n                if (!hasScript) {\n                    project.addScriptSourceRoot(build.getScriptSourceDirectory());\n                }\n                if (!hasMain) {\n                    project.addCompileSourceRoot(build.getSourceDirectory());\n                }\n                if (!hasTest) {\n                    project.addTestCompileSourceRoot(build.getTestSourceDirectory());\n                }\n                for (Resource resource : project.getBuild().getDelegate().getResources()) {\n                    project.addSourceRoot(new DefaultSourceRoot(baseDir, ProjectScope.MAIN, resource));\n                }\n                for (Resource resource : project.getBuild().getDelegate().getTestResources()) {\n                    project.addSourceRoot(new DefaultSourceRoot(baseDir, ProjectScope.TEST, resource));\n                }\n            }\n\n            project.setActiveProfiles(\n                    Stream.concat(result.getActivePomProfiles().stream(), result.getActiveExternalProfiles().stream())\n                            .map(org.apache.maven.model.Profile::new)\n                            .toList());\n\n            project.setInjectedProfileIds(\"external\", getProfileIds(result.getActiveExternalProfiles()));\n            project.setInjectedProfileIds(\n                    result.getEffectiveModel().getId(), getProfileIds(result.getActivePomProfiles()));\n\n\n            project.setProjectBuildingRequest(request);\n\n            Set<Artifact> pluginArtifacts = new HashSet<>();\n            for (Plugin plugin : project.getModel().getDelegate().getBuild().getPlugins()) {\n                Artifact artifact = repositorySystem.createPluginArtifact(new org.apache.maven.model.Plugin(plugin));\n\n                if (artifact != null) {\n                    pluginArtifacts.add(artifact);\n                }\n            }\n            project.setPluginArtifacts(pluginArtifacts);\n\n            Set<Artifact> reportArtifacts = new HashSet<>();\n            for (ReportPlugin report :\n                    project.getModel().getDelegate().getReporting().getPlugins()) {\n                Plugin pp = Plugin.newBuilder()\n                        .groupId(report.getGroupId())\n                        .artifactId(report.getArtifactId())\n                        .version(report.getVersion())\n                        .build();\n\n                Artifact artifact = repositorySystem.createPluginArtifact(new org.apache.maven.model.Plugin(pp));\n\n                if (artifact != null) {\n                    reportArtifacts.add(artifact);\n                }\n            }\n            project.setReportArtifacts(reportArtifacts);\n\n            Set<Artifact> extensionArtifacts = new HashSet<>();\n            List<Extension> extensions =\n                    project.getModel().getDelegate().getBuild().getExtensions();\n            if (extensions != null) {\n                for (Extension ext : extensions) {\n                    String version;\n                    if (ext.getVersion() == null || ext.getVersion().isEmpty()) {\n                        version = \"RELEASE\";\n                    } else {\n                        version = ext.getVersion();\n                    }\n\n                    Artifact artifact = repositorySystem.createArtifact(\n                            ext.getGroupId(), ext.getArtifactId(), version, null, \"jar\");\n\n                    if (artifact != null) {\n                        extensionArtifacts.add(artifact);\n                    }\n                }\n            }\n            project.setExtensionArtifacts(extensionArtifacts);\n\n            Map<String, Artifact> map = Collections.emptyMap();\n            final DependencyManagement dependencyManagement =\n                    project.getModel().getDelegate().getDependencyManagement();\n            if (dependencyManagement != null\n                    && dependencyManagement.getDependencies() != null\n                    && !dependencyManagement.getDependencies().isEmpty()) {\n                map = new LazyMap<>(() -> {\n                    }\n                    return Collections.unmodifiableMap(tmp);\n                });\n            }",
    "comment": "only set those on 2nd phase, ignore on 1st pass\n\nAll the parts that were taken out of MavenProject for Maven 4.0.0\n\npluginArtifacts\nreportArtifacts\nextensionArtifacts\nmanagedVersionMap"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ModelBuilderRequest.java",
    "type": "method",
    "name": "build",
    "code": "static ModelBuilderRequest build(@Nonnull ModelBuilderRequest request, @Nonnull ModelSource source) {\n        return builder(requireNonNull(request, \"request cannot be null\"))\n                .source(requireNonNull(source, \"source cannot be null\"))\n                .build();\n    }",
    "comment": "Provides a map of user properties.\nUser properties"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/pipeline/src/main/java/com/iluwatar/pipeline/RemoveAlphabetsHandler.java",
    "type": "method",
    "name": "process",
    "code": "public String process(String input) {\n    var inputWithoutAlphabets = new StringBuilder();\n    var isAlphabetic = (IntPredicate) Character::isAlphabetic;\n    input\n        .chars()\n        .filter(isAlphabetic.negate())\n        .mapToObj(x -> (char) x)\n        .forEachOrdered(inputWithoutAlphabets::append);\n\n    var inputWithoutAlphabetsStr = inputWithoutAlphabets.toString();\n    LOGGER.info(\n        String.format(\n            \"Current handler: %s, input is %s of type %s, output is %s, of type %s\",\n            RemoveAlphabetsHandler.class,\n            input,\n            String.class,\n            inputWithoutAlphabetsStr,\n            String.class));\n\n    return inputWithoutAlphabetsStr;\n  }",
    "comment": "Stage handler that returns a new instance of String without the alphabet characters of the input\nstring."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(long expected, long actual) {\n        assertEquals(null, expected, actual);\n    }",
    "comment": "Asserts that two longs are equal. If they are not, an\n{@link AssertionError} is thrown.\n\n@param expected expected long value.\n@param actual actual long value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/classification/JavaOneVsRestSuite.java",
    "type": "method",
    "name": "oneVsRestDefaultParams",
    "code": "public void oneVsRestDefaultParams() {\n    OneVsRest ova = new OneVsRest();\n    ova.setClassifier(new LogisticRegression());\n    Assertions.assertEquals(\"label\", ova.getLabelCol());\n    Assertions.assertEquals(\"prediction\", ova.getPredictionCol());\n    OneVsRestModel ovaModel = ova.fit(dataset);\n    Dataset<Row> predictions = ovaModel.transform(dataset).select(\"label\", \"prediction\");\n    predictions.collectAsList();\n    Assertions.assertEquals(\"label\", ovaModel.getLabelCol());\n    Assertions.assertEquals(\"prediction\", ovaModel.getPredictionCol());\n  }",
    "comment": "The following coefficients and xMean/xVariance are computed from iris dataset with\nlambda=0.2.\nAs a result, we are drawing samples from probability distribution of an actual model."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestWatcherTests.java",
    "type": "method",
    "name": "testWatcherSemanticsWhenRegisteredAtClassLevel",
    "code": "void testWatcherSemanticsWhenRegisteredAtClassLevel() {\n\t\tClass<?> testClass = ClassLevelTestWatcherTestCase.class;\n\t\tassertStatsForAbstractDisabledMethodsTestCase(testClass);\n\n\t\tassertThat(TrackingTestWatcher.results.get(\"testDisabled\")).containsExactly(\"test\", \"repeatedTest\");\n\t}",
    "comment": "We get \"testDisabled\" events for the @Test method and the @RepeatedTest container."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/state/src/test/java/com/iluwatar/state/MammothTest.java",
    "type": "method",
    "name": "testTimePasses",
    "code": "void testTimePasses() {\n    final var mammoth = new Mammoth();\n\n    mammoth.observe();\n    assertEquals(\"The mammoth is calm and peaceful.\", appender.getLastMessage());\n    assertEquals(1, appender.getLogSize());\n\n    mammoth.timePasses();\n    assertEquals(\"The mammoth gets angry!\", appender.getLastMessage());\n    assertEquals(2, appender.getLogSize());\n\n    mammoth.observe();\n    assertEquals(\"The mammoth is furious!\", appender.getLastMessage());\n    assertEquals(3, appender.getLogSize());\n\n    mammoth.timePasses();\n    assertEquals(\"The mammoth calms down.\", appender.getLastMessage());\n    assertEquals(4, appender.getLogSize());\n\n    mammoth.observe();\n    assertEquals(\"The mammoth is calm and peaceful.\", appender.getLastMessage());\n    assertEquals(5, appender.getLogSize());\n  }",
    "comment": "Switch to a complete mammoth 'mood'-cycle and verify if the observed mood matches the expected\nvalue."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testBagMultiply",
    "code": "public void testBagMultiply() {\n        IMoney expected = MoneyBag.create(new Money(24, \"CHF\"), new Money(14, \"USD\"));\n        assertEquals(expected, fMB1.multiply(2));\n        assertEquals(fMB1, fMB1.multiply(1));\n        assertTrue(fMB1.multiply(0).isZero());\n    }",
    "comment": "{[12 CHF][7 USD]} *2 == {[24 CHF][14 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ArtifactResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default ArtifactResolverResult resolve(Session session, Collection<? extends ArtifactCoordinates> coordinates) {\n        return resolve(ArtifactResolverRequest.build(session, coordinates));\n    }",
    "comment": "Resolves several artifacts from their coordinates.\n\n@param session {@link Session}\n@param coordinates array of {@link ArtifactCoordinates}\n@return {@link ArtifactResolverResult}\n@throws ArtifactResolverException in case of an error.\n@throws IllegalArgumentException in case of parameter {@code buildingRequest} is {@code null} or\nparameter {@code coordinates} is {@code null} or invalid"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaUserDefinedTypedAggregation.java",
    "type": "method",
    "name": "reduce",
    "code": "public Average reduce(Average buffer, Employee employee) {\n      long newSum = buffer.getSum() + employee.getSalary();\n      long newCount = buffer.getCount() + 1;\n      buffer.setSum(newSum);\n      buffer.setCount(newCount);\n      return buffer;\n    }",
    "comment": "Combine two values to produce a new value. For performance, the function may modify `buffer`\nand return it instead of constructing a new object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/ReactorReader.java",
    "type": "method",
    "name": "isTestArtifact",
    "code": "private static boolean isTestArtifact(Artifact artifact) {\n        return (\"test-jar\".equals(artifact.getProperty(\"type\", \"\")))\n                || (\"jar\".equals(artifact.getExtension()) && \"tests\".equals(artifact.getClassifier()));\n    }",
    "comment": "Determines whether the specified artifact refers to test classes.\n\n@param artifact The artifact to check, must not be {@code null}.\n@return {@code true} if the artifact refers to test classes, {@code false} otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/ErrorCollector.java",
    "type": "method",
    "name": "checkThrows",
    "code": "public void checkThrows(Class<? extends Throwable> expectedThrowable, ThrowingRunnable runnable) {\n        try {\n            assertThrows(expectedThrowable, runnable);\n        } catch (AssertionError e) {\n            addError(e);\n        }\n    }",
    "comment": "Adds a failure to the table if {@code runnable} does not throw an\nexception of type {@code expectedThrowable} when executed.\nExecution continues, but the test will fail at the end if the runnable\ndoes not throw an exception, or if it throws a different exception.\n\n@param expectedThrowable the expected type of the exception\n@param runnable       a function that is expected to throw an exception when executed\n@since 4.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(short[] expected, short[] actual) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} short arrays are equal.\n<p>If both are {@code null}, they are considered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaRowSuite.java",
    "type": "method",
    "name": "constructComplexRow",
    "code": "public void constructComplexRow() {\n    List<String> simpleStringArray = Arrays.asList(\n      stringValue + \" (1)\", stringValue + \" (2)\", stringValue + \"(3)\");\n\n    Map<String, Long> simpleMap = new HashMap<>();\n    simpleMap.put(stringValue + \" (1)\", longValue);\n    simpleMap.put(stringValue + \" (2)\", longValue - 1);\n    simpleMap.put(stringValue + \" (3)\", longValue - 2);\n\n    Row simpleStruct = RowFactory.create(\n      doubleValue, stringValue, timestampValue, null);\n\n    List<Map<String, Long>> arrayOfMaps = Arrays.asList(simpleMap);\n    List<Row> arrayOfRows = Arrays.asList(simpleStruct);\n\n    Map<List<Row>, Row> complexMap = new HashMap<>();\n    complexMap.put(arrayOfRows, simpleStruct);\n\n    Row complexStruct = RowFactory.create(\n      simpleStringArray,\n      simpleMap,\n      simpleStruct,\n      arrayOfMaps,\n      arrayOfRows,\n      complexMap,\n      null);\n    Assertions.assertEquals(simpleStringArray, complexStruct.get(0));\n    Assertions.assertEquals(simpleMap, complexStruct.get(1));\n    Assertions.assertEquals(simpleStruct, complexStruct.get(2));\n    Assertions.assertEquals(arrayOfMaps, complexStruct.get(3));\n    Assertions.assertEquals(arrayOfRows, complexStruct.get(4));\n    Assertions.assertEquals(complexMap, complexStruct.get(5));\n    Assertions.assertNull(complexStruct.get(6));\n\n    Row complexRow = RowFactory.create(arrayOfMaps, arrayOfRows, complexMap, complexStruct);\n    Assertions.assertEquals(arrayOfMaps, complexRow.get(0));\n    Assertions.assertEquals(arrayOfRows, complexRow.get(1));\n    Assertions.assertEquals(complexMap, complexRow.get(2));\n    Assertions.assertEquals(complexStruct, complexRow.get(3));\n  }",
    "comment": "Simple array\nSimple map\nSimple struct\nComplex array\nComplex map\nComplex struct\nA very complex row"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/runners/CustomBlockJUnit4ClassRunnerTest.java",
    "type": "method",
    "name": "methodBlock",
    "code": "protected Statement methodBlock(FrameworkMethod method) {\n\t\t\tif (\"throwException\".equals(method.getName())) {\n\t\t\t\tthrow new RuntimeException(\"throwException() test method invoked\");\n\t\t\t}\n\t\t\treturn super.methodBlock(method);\n\t\t}",
    "comment": "Custom extension of {@link BlockJUnit4ClassRunner} that always throws\nan exception from the {@code methodBlock()} if a test method is named\nexactly {@code \"throwException\"}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfig.java",
    "type": "method",
    "name": "enableTestExecutionListenerAutoRegistration",
    "code": "public Builder enableTestExecutionListenerAutoRegistration(boolean enabled) {\n\t\t\tthis.testExecutionListenerAutoRegistrationEnabled = enabled;\n\t\t\treturn this;\n\t\t}",
    "comment": "Configure the auto-registration flag for test execution listeners.\n\n<p>Defaults to {@code true}.\n\n@param enabled {@code true} if test execution listeners should be\nautomatically registered\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "getImplementationProvider",
    "code": "protected static ImplementationProvider getImplementationProvider(int collationId) {\n        if (collationId == INDETERMINATE_COLLATION_ID) {\n          return ImplementationProvider.INDETERMINATE;\n        }\n\n        return ImplementationProvider.values()[SpecifierUtils.getSpecValue(collationId,\n          IMPLEMENTATION_PROVIDER_OFFSET, IMPLEMENTATION_PROVIDER_MASK)];\n      }",
    "comment": "Utility function to retrieve `ImplementationProvider` enum instance from collation ID."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-yarn/src/main/java/org/apache/spark/network/yarn/YarnShuffleService.java",
    "type": "method",
    "name": "initRecoveryDb",
    "code": "protected File initRecoveryDb(String dbName) {\n    Preconditions.checkNotNull(_recoveryPath,\n      \"recovery path should not be null if NM recovery is enabled\");\n\n    File recoveryFile = new File(_recoveryPath.toUri().getPath(), dbName);\n    if (recoveryFile.exists()) {\n      return recoveryFile;\n    }\n\n    // db doesn't exist in recovery path go check local dirs for it\n    String[] localDirs = _conf.getTrimmedStrings(\"yarn.nodemanager.local-dirs\");\n    for (String dir : localDirs) {\n      File f = new File(new Path(dir).toUri().getPath(), dbName);\n      if (f.exists()) {\n        // If the recovery path is set then either NM recovery is enabled or another recovery\n        // DB has been initialized. If NM recovery is enabled and had set the recovery path\n        // make sure to move all DBs to the recovery path from the old NM local dirs.\n        // If another DB was initialized first just make sure all the DBs are in the same\n        // location.\n        Path newLoc = new Path(_recoveryPath, dbName);\n        Path copyFrom = new Path(f.toURI());\n        if (!newLoc.equals(copyFrom)) {\n          logger.info(\"Moving \" + copyFrom + \" to: \" + newLoc);\n          try {\n            // The move here needs to handle moving non-empty directories across NFS mounts\n            FileSystem fs = FileSystem.getLocal(_conf);\n            fs.rename(copyFrom, newLoc);\n          } catch (Exception e) {\n            // Fail to move recovery file to new path, just continue on with new DB location\n            logger.error(\"Failed to move recovery file {} to the path {}\", e,\n              MDC.of(LogKeys.SHUFFLE_MERGE_RECOVERY_FILE$.MODULE$, dbName),\n              MDC.of(LogKeys.PATH$.MODULE$, _recoveryPath.toString()));\n          }\n        }\n        return new File(newLoc.toUri().getPath());\n      }\n    }\n\n    return new File(_recoveryPath.toUri().getPath(), dbName);\n  }",
    "comment": "Figure out the recovery path and handle moving the DB if YARN NM recovery gets enabled\nand DB exists in the local dir of NM by old version of shuffle service."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "inputLocation",
    "code": "public Builder inputLocation(Object inputLocation) {\n            this.inputLocation = inputLocation;\n            return this;\n        }",
    "comment": "Sets the input location information for the XML node.\n<p>\nThis is typically used for error reporting and debugging purposes.\n\n@param inputLocation the input location object\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/table-inheritance/src/main/java/com/iluwatar/table/inheritance/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    final Logger logger = Logger.getLogger(App.class.getName());\n\n    VehicleDatabase database = new VehicleDatabase();\n\n    Car car = new Car(2020, \"Toyota\", \"Corolla\", 4, 1);\n    Truck truck = new Truck(2018, \"Ford\", \"F-150\", 60, 2);\n\n    database.saveVehicle(car);\n    database.saveVehicle(truck);\n\n    database.printAllVehicles();\n\n    Vehicle vehicle = database.getVehicle(car.getId());\n    Car retrievedCar = database.getCar(car.getId());\n    Truck retrievedTruck = database.getTruck(truck.getId());\n\n    logger.info(String.format(\"Retrieved Vehicle: %s\", vehicle));\n    logger.info(String.format(\"Retrieved Car: %s\", retrievedCar));\n    logger.info(String.format(\"Retrieved Truck: %s\", retrievedTruck));\n  }",
    "comment": "Manages the storage and retrieval of Vehicle objects, including Cars and Trucks.\n\n<p>This example demonstrates the **Table Inheritance** pattern, where each vehicle type (Car\nand Truck) is stored in its own separate table. The `VehicleDatabase` simulates a simple\ndatabase that manages these entities, with each subclass (Car and Truck) being stored in its\nrespective table.\n\n<p>The `VehicleDatabase` contains the following tables: - `vehicleTable`: Stores all vehicle\nobjects, including both `Car` and `Truck` objects. - `carTable`: Stores only `Car` objects,\nwith fields specific to cars. - `truckTable`: Stores only `Truck` objects, with fields specific\nto trucks.\n\n<p>The example demonstrates: 1. Saving instances of `Car` and `Truck` to their respective\ntables in the database. 2. Retrieving vehicles (both cars and trucks) from the appropriate\ntable based on their ID. 3. Printing all vehicles stored in the database. 4. Showing how to\nretrieve specific types of vehicles (`Car` or `Truck`) by their IDs.\n\n<p>In the **Table Inheritance** pattern, each subclass has its own table, making it easier to\nmanage specific attributes of each subclass.\n\n@param args command-line arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(long expected, long actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/LauncherServer.java",
    "type": "method",
    "name": "acceptConnections",
    "code": "private void acceptConnections() {\n    try {\n      while (running) {\n        final Socket client = server.accept();\n        TimerTask timerTask = new TimerTask() {\n            }\n          }\n        };\n        ServerConnection clientConnection = new ServerConnection(client, timerTask);\n        Thread clientThread = factory.newThread(clientConnection);\n        clientConnection.setConnectionThread(clientThread);\n        synchronized (clients) {\n          clients.add(clientConnection);\n        }\n\n        long timeoutMs = getConnectionTimeout();\n        if (timeoutMs > 0) {\n          timeoutTimer.schedule(timerTask, timeoutMs);\n        } else {\n          timerTask.run();\n        }\n\n        clientThread.start();\n      }",
    "comment": "no-op.\n0 is used for testing to avoid issues with clock resolution / thread scheduling,\nand force an immediate timeout."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/DependencyScope.java",
    "type": "method",
    "name": "forId",
    "code": "public static DependencyScope forId(String id) {\n        return IDS.get(id);\n    }",
    "comment": "{@return the dependency scope for the given identifier, or {@code null} if none}.\nThe identifiers are usually in lower cases with {@code '-'} instead of {@code '_'}\nas word separator.\n\n@param id the identifier of the scope (case-sensitive)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "setDecimal",
    "code": "public void setDecimal(int ordinal, Decimal value, int precision) {\n    assertIndexIsValid(ordinal);\n    if (precision <= Decimal.MAX_LONG_DIGITS()) {\n      // compact format\n      if (value == null) {\n        setNullAt(ordinal);\n      } else {\n        setLong(ordinal, value.toUnscaledLong());\n      }\n    } else {\n      // fixed length\n      long cursor = getLong(ordinal) >>> 32;\n      assert cursor > 0 : \"invalid cursor \" + cursor;\n      // zero-out the bytes\n      Platform.putLong(baseObject, baseOffset + cursor, 0L);\n      Platform.putLong(baseObject, baseOffset + cursor + 8, 0L);\n\n      if (value == null || !value.changePrecision(precision, value.scale())) {\n        setNullAt(ordinal);\n        // keep the offset for future update\n        Platform.putLong(baseObject, getFieldOffset(ordinal), cursor << 32);\n      } else {\n\n        final BigInteger integer = value.toJavaBigDecimal().unscaledValue();\n        byte[] bytes = integer.toByteArray();\n        assert(bytes.length <= 16);\n\n        // Write the bytes to the variable length portion.\n        Platform.copyMemory(\n          bytes, Platform.BYTE_ARRAY_OFFSET, baseObject, baseOffset + cursor, bytes.length);\n        setLong(ordinal, (cursor << 32) | ((long) bytes.length));\n      }\n    }\n  }",
    "comment": "Updates the decimal column.\n\nNote: In order to support update a decimal with precision > 18, CAN NOT call\nsetNullAt() for this column."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java",
    "type": "method",
    "name": "getNullValueWithTypeSafety",
    "code": "void getNullValueWithTypeSafety() {\n\t\t\tstore.put(namespace, key, null);\n\n\t\t\tString requiredTypeValue = store.get(namespace, key, String.class);\n\t\t\tassertNull(requiredTypeValue);\n\t\t}",
    "comment": "The fact that we can declare this as a String suffices for testing the required type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/test/java/com/iluwatar/RegisterWorkerTest.java",
    "type": "method",
    "name": "runWithMissingOccupation",
    "code": "void runWithMissingOccupation() {\n    RegisterWorkerDto workerDto = createValidWorkerDto();\n    workerDto.setupWorkerDto(\"name\", null, LocalDate.of(2000, 12, 1));\n    RegisterWorker registerWorker = new RegisterWorker(workerDto);\n\n    registerWorker.run();\n\n    assertTrue(registerWorker.getNotification().hasErrors());\n    assertTrue(\n        registerWorker\n            .getNotification()\n            .getErrors()\n            .contains(RegisterWorkerDto.MISSING_OCCUPATION));\n    assertEquals(registerWorker.getNotification().getErrors().size(), 1);\n  }",
    "comment": "Run the registration process\nVerify that the notification contains the missing occupation error"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/Java8APISuite.java",
    "type": "method",
    "name": "testMapWithStateAPI",
    "code": "public void testMapWithStateAPI() {\n    JavaPairRDD<String, Boolean> initialRDD = null;\n    JavaPairDStream<String, Integer> wordsDstream = null;\n\n    Function4<Time, String, Optional<Integer>, State<Boolean>, Optional<Double>> mapFn =\n      (time, key, value, state) -> {\n        // Use all State's methods here\n        state.exists();\n        state.get();\n        state.isTimingOut();\n        state.remove();\n        state.update(true);\n        return Optional.of(2.0);\n      };\n\n    JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream =\n      wordsDstream.mapWithState(\n        StateSpec.function(mapFn)\n          .initialState(initialRDD)\n          .numPartitions(10)\n          .partitioner(new HashPartitioner(10))\n          .timeout(Durations.seconds(10)));\n\n    JavaPairDStream<String, Boolean> emittedRecords = stateDstream.stateSnapshots();\n\n    Function3<String, Optional<Integer>, State<Boolean>, Double> mapFn2 =\n      (key, value, state) -> {\n        state.exists();\n        state.get();\n        state.isTimingOut();\n        state.remove();\n        state.update(true);\n        return 2.0;\n      };\n\n    JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream2 =\n      wordsDstream.mapWithState(\n        StateSpec.function(mapFn2)\n          .initialState(initialRDD)\n          .numPartitions(10)\n          .partitioner(new HashPartitioner(10))\n          .timeout(Durations.seconds(10)));\n\n    JavaPairDStream<String, Boolean> mappedDStream = stateDstream2.stateSnapshots();\n  }",
    "comment": "This test is only for testing the APIs. It's not necessary to run it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-to-worker/src/main/java/com/iluwatar/servicetoworker/Dispatcher.java",
    "type": "method",
    "name": "Dispatcher",
    "code": "public Dispatcher(GiantView giantView) {\n    this.giantView = giantView;\n    this.actions = new ArrayList<>();\n  }",
    "comment": "Instantiates a new Dispatcher.\n\n@param giantView the giant view"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenFailOnSeverityLogger.java",
    "type": "method",
    "name": "error",
    "code": "public void error(String format, Object... argArray) {\n        super.error(format, argArray);\n        logLevelRecorder.record(Level.ERROR);\n    }",
    "comment": "Perform double parameter substitution before logging the message of level\nERROR according to the format outlined above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/LruCache.java",
    "type": "method",
    "name": "invalidate",
    "code": "public void invalidate(final String userId) {\n    var toBeRemoved = cache.remove(userId);\n    if (toBeRemoved != null) {\n      LOGGER.info(\"# {} has been updated! \" + \"Removing older version from cache...\", userId);\n      remove(toBeRemoved);\n    }\n  }",
    "comment": "Invalidate cache for user.\n\n@param userId {@link String}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java",
    "type": "method",
    "name": "getAnnotations",
    "code": "private static Annotation[] getAnnotations(TestCase test) {\n        try {\n            Method m = test.getClass().getMethod(test.getName());\n            return m.getDeclaredAnnotations();\n        } catch (SecurityException e) {\n        } catch (NoSuchMethodException e) {\n        }\n        return new Annotation[0];\n    }",
    "comment": "Get the annotations associated with given TestCase.\n@param test the TestCase."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/singleton/src/main/java/com/iluwatar/singleton/IvoryTower.java",
    "type": "method",
    "name": "getInstance",
    "code": "public static IvoryTower getInstance() {\n    return INSTANCE;\n  }",
    "comment": "To be called by user to obtain instance of the class.\n\n@return instance of the singleton."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testSimpleSubtract",
    "code": "public void testSimpleSubtract() {\n        Money expected = new Money(2, \"CHF\");\n        assertEquals(expected, f14CHF.subtract(f12CHF));\n    }",
    "comment": "[14 CHF] - [12 CHF] == [2 CHF]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/firebase/android/src/org/tensorflow/lite/benchmark/firebase/BenchmarkModelActivity.java",
    "type": "method",
    "name": "onCreate",
    "code": "public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    Intent intent = getIntent();\n    if (!intent.getAction().equals(\"com.google.intent.action.TEST_LOOP\")) {\n      Log.e(TAG, \"Received non Firebase Game Loop test intent \" + intent.getAction());\n      finish();\n    }\n    int scenario = intent.getIntExtra(\"scenario\", 0);\n    Log.i(TAG, \"Running TensorFlow Lite benchmark with scenario: \" + scenario);\n\n    ParcelFileDescriptor parcelFileDescriptor = null;\n    Uri reportFile = intent.getData();\n    if (reportFile != null) {\n      Log.i(TAG, \"Logging the result to \" + reportFile.getEncodedPath());\n      try {\n        parcelFileDescriptor =\n            getContentResolver().openAssetFileDescriptor(reportFile, \"w\").getParcelFileDescriptor();\n      } catch (FileNotFoundException | NullPointerException e) {\n        Log.e(TAG, \"Error while opening Firebase Test Lab report file\", e);\n      }\n    }\n\n    int reportFd = parcelFileDescriptor != null ? parcelFileDescriptor.getFd() : -1;\n    BenchmarkModel.run(this, scenario, reportFd);\n\n    if (parcelFileDescriptor != null) {\n      try {\n        parcelFileDescriptor.close();\n      } catch (IOException e) {\n        Log.e(TAG, \"Failed to close Firebase Test Lab result file\", e);\n      }\n    }\n\n    finish();\n  }",
    "comment": "{@code Activity} class for Firebase Game Loop test.\n\n<p>This Activity receives and handles an {@code Intent} for Firebase Game Loop test. Refer to\nhttps://firebase.google.com/docs/test-lab/android/game-loop."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/tasks/CustomClassLoaderCloseStrategy.java",
    "type": "method",
    "name": "handle",
    "code": "public void handle(ClassLoader customClassLoader) {\n\t\t\tif (customClassLoader instanceof AutoCloseable) {\n\t\t\t\tclose((AutoCloseable) customClassLoader);\n\t\t\t}\n\t\t}",
    "comment": "Close the custom class loader after calling the\n{@link org.junit.platform.launcher.Launcher} for test discovery or\nexecution."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "replaceWhitespaceCharacters",
    "code": "public static String replaceWhitespaceCharacters(String str, String replacement) {\n\t\tPreconditions.notNull(replacement, \"replacement must not be null\");\n\t\treturn str == null ? null : WHITESPACE_PATTERN.matcher(str).replaceAll(replacement);\n\t}",
    "comment": "Replace all whitespace characters in the supplied {@link String}.\n\n@param str the string in which to perform the replacement; may be {@code null}\n@param replacement the replacement string; never {@code null}\n@return the supplied string with all whitespace characters replaced, or\n{@code null} if the supplied string was {@code null}\n@since 1.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeExternalSorter.java",
    "type": "method",
    "name": "closeCurrentPage",
    "code": "public void closeCurrentPage() {\n    if (currentPage != null) {\n      pageCursor = currentPage.getBaseOffset() + currentPage.size();\n    }\n  }",
    "comment": "Marks the current page as no-more-space-available, and as a result, either allocate a\nnew page or spill when we see the next record."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/memory/MemoryBlock.java",
    "type": "method",
    "name": "MemoryBlock",
    "code": "public MemoryBlock(@Nullable Object obj, long offset, long length) {\n    super(obj, offset);\n    this.length = length;\n  }",
    "comment": "Optional page number; used when this MemoryBlock represents a page allocated by a\nTaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\nwhich lives in a different package."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/streaming/src/test/java/test/org/apache/spark/streaming/JavaAPISuite.java",
    "type": "method",
    "name": "testVariousTransform",
    "code": "public void testVariousTransform() {\n\n    List<List<Integer>> inputData = Arrays.asList(Arrays.asList(1));\n    JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1);\n\n    List<List<Tuple2<String, Integer>>> pairInputData =\n        Arrays.asList(Arrays.asList(new Tuple2<>(\"x\", 1)));\n    JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(\n        JavaTestUtils.attachTestInputStream(ssc, pairInputData, 1));\n\n    stream.transform(in -> null);\n\n    stream.transform((in, time) -> null);\n\n    stream.transformToPair(in -> null);\n\n    stream.transformToPair((in, time) -> null);\n\n    pairStream.transform(in -> null);\n\n    pairStream.transform((in, time) -> null);\n\n    pairStream.transformToPair(in -> null);\n\n    pairStream.transformToPair((in, time) -> null);\n\n  }",
    "comment": "tests whether all variations of transform can be called from Java"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "tryToGetResources",
    "code": "public static Try<Set<Resource>> tryToGetResources(String classpathResourceName, ClassLoader classLoader) {\n\t\tPreconditions.notBlank(classpathResourceName, \"Resource name must not be null or blank\");\n\t\tPreconditions.notNull(classLoader, \"Class loader must not be null\");\n\t\tboolean startsWithSlash = classpathResourceName.startsWith(\"/\");\n\t\tString canonicalClasspathResourceName = (startsWithSlash ? classpathResourceName.substring(1)\n\t\t\t\t: classpathResourceName);\n\n\t\treturn Try.call(() -> {\n\t\t\tList<URL> resources = Collections.list(classLoader.getResources(canonicalClasspathResourceName));\n\t\t\treturn resources.stream().map(url -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn new DefaultResource(canonicalClasspathResourceName, url.toURI());\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\tthrow ExceptionUtils.throwAsUncheckedException(e);\n\t\t\t\t}\n\t\t\t}).collect(toCollection(LinkedHashSet::new));\n\t\t});\n\t}",
    "comment": "Try to get {@linkplain Resource resources} by their name, using the\nsupplied {@link ClassLoader}.\n\n<p>See {@link org.junit.platform.commons.support.ReflectionSupport#tryToGetResources(String, ClassLoader)}\nfor details.\n\n@param classpathResourceName the name of the resources to load; never {@code null} or blank\n@param classLoader the {@code ClassLoader} to use; never {@code null}\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeInMemorySorter.java",
    "type": "method",
    "name": "insertRecord",
    "code": "public void insertRecord(long recordPointer, long keyPrefix, boolean prefixIsNull) {\n    if (!hasSpaceForAnotherRecord()) {\n      throw new IllegalStateException(\"There is no space for new record\");\n    }\n    if (prefixIsNull && radixSortSupport != null) {\n      // Swap forward a non-null record to make room for this one at the beginning of the array.\n      array.set(pos, array.get(nullBoundaryPos));\n      pos++;\n      array.set(pos, array.get(nullBoundaryPos + 1));\n      pos++;\n      // Place this record in the vacated position.\n      array.set(nullBoundaryPos, recordPointer);\n      nullBoundaryPos++;\n      array.set(nullBoundaryPos, keyPrefix);\n      nullBoundaryPos++;\n    } else {\n      array.set(pos, recordPointer);\n      pos++;\n      array.set(pos, keyPrefix);\n      pos++;\n    }\n  }",
    "comment": "Inserts a record to be sorted. Assumes that the record pointer points to a record length\nstored as a uaoSize(4 or 8) bytes integer, followed by the record's bytes.\n\n@param recordPointer pointer to a record in a data page, encoded by {@link TaskMemoryManager}.\n@param keyPrefix a user-defined key prefix"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java",
    "type": "method",
    "name": "getStackTrace",
    "code": "private StackTraceElement[] getStackTrace(Thread thread) {\n        try {\n            return thread.getStackTrace();\n        } catch (SecurityException e) {\n            return new StackTraceElement[0];\n        }\n    }",
    "comment": "Retrieves the stack trace for a given thread.\n@param thread The thread whose stack is to be retrieved.\n@return The stack trace; returns a zero-length array if the thread has\nterminated or the stack cannot be retrieved for some other reason."
  }
]