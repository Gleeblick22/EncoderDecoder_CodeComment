[
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/test/java/org/apache/spark/util/kvstore/RocksDBSuite.java",
    "type": "method",
    "name": "createCustomType1",
    "code": "for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        ArrayKeyIndexType o = new ArrayKeyIndexType();\n        o.key = new int[] { i, j, 0 };\n        o.id = new String[] { \"things\" };\n        o.key = new int[] { i, j, 1 };\n        o.id = new String[] { \"more things\" };\n    }\n\n    ArrayKeyIndexType o = new ArrayKeyIndexType();\n    o.key = new int[] { 2, 2, 2 };\n    o.id = new String[] { \"things\" };\n      ImmutableSet.of(new int[] {0, 0, 0}, new int[] { 2, 2, 2 }));\n      ImmutableSet.of(new String[] { \"things\" }));\n      ImmutableSet.of(new String[] { \"more things\" }));\n\n  @Test\n  public void testSkip() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      db.write(createCustomType1(i));\n    }\n\n    try (KVStoreIterator<CustomType1> it = db.view(CustomType1.class).closeableIterator()) {\n      assertTrue(it.hasNext());\n      assertTrue(it.skip(5));\n      assertEquals(\"key5\", it.next().key);\n      assertTrue(it.skip(3));\n      assertEquals(\"key9\", it.next().key);\n      assertFalse(it.hasNext());\n    }\n  }\n\n  @Test\n  public void testNegativeIndexValues() throws Exception {\n    List<Integer> expected = Arrays.asList(-100, -50, 0, 50, 100);\n\n    expected.forEach(i -> {\n      try {\n        db.write(createCustomType1(i));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    try (KVStoreIterator<CustomType1> iterator =\n      db.view(CustomType1.class).index(\"int\").closeableIterator()) {\n      List<Integer> results = StreamSupport\n        .stream(Spliterators.spliteratorUnknownSize(iterator, 0), false)\n        .map(e -> e.num)\n        .collect(Collectors.toList());\n\n      assertEquals(expected, results);\n    }\n  }\n\n  @Test\n  public void testCloseRocksDBIterator() throws Exception {\n    File dbPathForCloseTest = File\n      .createTempFile(\n        \"test_db_close.\",\n        \".rdb\");\n    dbPathForCloseTest.delete();\n    RocksDB dbForCloseTest = new RocksDB(dbPathForCloseTest);\n    for (int i = 0; i < 8192; i++) {\n      dbForCloseTest.write(createCustomType1(i));\n    }\n    String key = dbForCloseTest\n      .view(CustomType1.class).iterator().next().key;\n    assertEquals(\"key0\", key);\n    Iterator<CustomType1> it0 = dbForCloseTest\n      .view(CustomType1.class).max(1).iterator();\n    while (it0.hasNext()) {\n      it0.next();\n    }\n    System.gc();\n    Iterator<CustomType1> it1 = dbForCloseTest\n      .view(CustomType1.class).iterator();\n    assertEquals(\"key0\", it1.next().key);\n    try (KVStoreIterator<CustomType1> it2 = dbForCloseTest\n      .view(CustomType1.class).closeableIterator()) {\n      assertEquals(\"key0\", it2.next().key);\n    }\n    dbForCloseTest.close();\n    assertTrue(dbPathForCloseTest.exists());\n    FileUtils.deleteQuietly(dbPathForCloseTest);\n    assertTrue(!dbPathForCloseTest.exists());\n  }\n\n  @Test\n  public void testHasNextAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertFalse(iter.hasNext());\n  }\n\n  @Test\n  public void testHasNextAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    db.close();\n    assertFalse(iter.hasNext());\n  }\n\n  @Test\n  public void testNextAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertThrows(NoSuchElementException.class, iter::next);\n  }\n\n  @Test\n  public void testNextAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertThrows(NoSuchElementException.class, iter::next);\n  }\n\n  @Test\n  public void testSkipAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    iter.close();\n    assertFalse(iter.skip(0));\n    assertFalse(iter.skip(1));\n  }\n\n  @Test\n  public void testSkipAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    db.close();\n    assertFalse(iter.skip(0));\n    assertFalse(iter.skip(1));\n  }\n\n  @Test\n  public void testResourceCleaner() throws Exception {\n    File dbPathForCleanerTest = File.createTempFile(\n      \"test_db_cleaner.\", \".rdb\");\n    dbPathForCleanerTest.delete();\n\n    RocksDB dbForCleanerTest = new RocksDB(dbPathForCleanerTest);\n    try {\n      for (int i = 0; i < 8192; i++) {\n        dbForCleanerTest.write(createCustomType1(i));\n      }\n      RocksDBIterator<CustomType1> rocksDBIterator =\n        (RocksDBIterator<CustomType1>) dbForCleanerTest.view(CustomType1.class).iterator();\n      Reference<RocksDBIterator<?>> reference = new WeakReference<>(rocksDBIterator);\n      assertNotNull(reference);\n      RocksDBIterator.ResourceCleaner resourceCleaner = rocksDBIterator.getResourceCleaner();\n      assertFalse(resourceCleaner.isCompleted());\n      rocksDBIterator = null;\n      int count = 0;\n      while (count < 100 && !reference.refersTo(null)) {\n        System.gc();\n        count++;\n        Thread.sleep(100);\n      }\n      assertTrue(reference.refersTo(null));\n      assertTrue(resourceCleaner.isCompleted());\n    } finally {\n      dbForCleanerTest.close();\n      FileUtils.deleteQuietly(dbPathForCleanerTest);\n    }\n  }\n\n  @Test\n  public void testMultipleTypesWriteAll() throws Exception {\n\n    List<CustomType1> type1List = Arrays.asList(\n      createCustomType1(1),\n      createCustomType1(2),\n      createCustomType1(3),\n      createCustomType1(4)\n    );\n\n    List<CustomType2> type2List = Arrays.asList(\n      createCustomType2(10),\n      createCustomType2(11),\n      createCustomType2(12),\n      createCustomType2(13)\n    );\n\n    List fullList = new ArrayList();\n    fullList.addAll(type1List);\n    fullList.addAll(type2List);\n\n    db.writeAll(fullList);\n    for (CustomType1 value : type1List) {\n      assertEquals(value, db.read(value.getClass(), value.key));\n    }\n    for (CustomType2 value : type2List) {\n      assertEquals(value, db.read(value.getClass(), value.key));\n    }\n  }\n\n  private CustomType1 createCustomType1(int i) {\n    CustomType1 t = new CustomType1();\n    t.key = \"key\" + i;\n    t.id = \"id\" + i;\n    t.name = \"name\" + i;\n    t.num = i;\n    t.child = \"child\" + i;\n    return t;\n  }\n\n  private CustomType2 createCustomType2(int i) {\n    CustomType2 t = new CustomType2();\n    t.key = \"key\" + i;\n    t.id = \"id\" + i;\n    t.parentId = \"parent_id\" + (i / 2);\n    return t;\n  }\n\n  private int countKeys(Class<?> type) throws Exception {\n    byte[] prefix = db.getTypeInfo(type).keyPrefix();\n    int count = 0;\n\n    try (RocksIterator it = db.db().newIterator()) {\n      it.seek(prefix);\n\n      while (it.isValid()) {\n        byte[] key = it.key();\n        if (RocksDBIterator.startsWith(key, prefix)) {\n          count++;\n        }\n        it.next();\n      }\n    }\n\n    return count;\n  }\n}",
    "comment": "Look into the actual DB and make sure that all the keys related to the type have been\nremoved.\nThere should be one \"id\" index entry with two values.\nDelete the first entry; now there should be 3 remaining keys, since one of the \"name\"\nindex entries should have been removed.\nMake sure there's a single entry in the \"id\" index now.\nDelete the remaining entry, make sure all data is gone.\nSPARK-31929: test when RocksDB.close() is called, related RocksDBIterators\nare closed. And files opened by iterators are also closed.\niter should be true\nclose iter\niter.hasNext should be false after iter close\niter should be true\nclose db\niter.hasNext should be false after db close\niter should be true\nclose iter\niter.next should throw NoSuchElementException after iter close\niter should be true\nclose db\niter.next should throw NoSuchElementException after db close\nclose iter\nskip should always return false after iter close\niter should be true\nclose db\nskip should always return false after db close\nManually set rocksDBIterator to null, to be GC.\n100 times gc, the rocksDBIterator should be GCed.\ncheck rocksDBIterator should be GCed\nVerify that the Cleaner will be executed after a period of time,\nand status will become false."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/AbstractScopeArtifactFilter.java",
    "type": "method",
    "name": "addScopeInternal",
    "code": "void addScopeInternal(String scope) {\n        if (Artifact.SCOPE_COMPILE.equals(scope)) {\n            systemScope = true;\n            providedScope = true;\n            compileScope = true;\n        } else if (Artifact.SCOPE_RUNTIME.equals(scope)) {\n            compileScope = true;\n            runtimeScope = true;\n        } else if (Artifact.SCOPE_COMPILE_PLUS_RUNTIME.equals(scope)) {\n            systemScope = true;\n            providedScope = true;\n            compileScope = true;\n            runtimeScope = true;\n        } else if (Artifact.SCOPE_RUNTIME_PLUS_SYSTEM.equals(scope)) {\n            systemScope = true;\n            compileScope = true;\n            runtimeScope = true;\n        } else if (Artifact.SCOPE_TEST.equals(scope)) {\n            systemScope = true;\n            providedScope = true;\n            compileScope = true;\n            runtimeScope = true;\n            testScope = true;\n        }\n    }",
    "comment": "Filter to only retain objects in the given artifactScope or better."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/options/TestDiscoveryOptionsMixin.java",
    "type": "method",
    "name": "setConfigurationParameters",
    "code": "public void setConfigurationParameters(Map<String, String> map) {\n\t\t\tfor (String key : map.keySet()) {\n\t\t\t\tString newValue = map.get(key);\n\t\t\t\tvalidateUnique(key, newValue);\n\t\t\t\tconfigurationParameters.put(key, newValue);\n\t\t\t}\n\t\t}",
    "comment": "Adds the specified key-value pair (or pairs) to the configuration parameters.\nA {@code ParameterException} is thrown if the same key is specified multiple times\non the command line.\n\n@param map the key-value pairs to add\n@throws CommandLine.ParameterException if the map already contains this key\n@see <a href=\"https://github.com/junit-team/junit5/issues/1308\">#1308</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/sqlite/java/com/example/android/persistence/migrations/UsersDbHelper.java",
    "type": "method",
    "name": "onUpgrade",
    "code": "public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n    }",
    "comment": "Not required as at version 1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvn/MavenInvoker.java",
    "type": "method",
    "name": "getResumeFromSelector",
    "code": "protected String getResumeFromSelector(List<MavenProject> mavenProjects, MavenProject firstFailedProject) {\n        boolean hasOverlappingArtifactId = mavenProjects.stream()\n                        .filter(project -> firstFailedProject.getArtifactId().equals(project.getArtifactId()))\n                        .count()\n                > 1;\n\n        if (hasOverlappingArtifactId) {\n            return firstFailedProject.getGroupId() + \":\" + firstFailedProject.getArtifactId();\n        }\n\n        return \":\" + firstFailedProject.getArtifactId();\n    }",
    "comment": "A helper method to determine the value to resume the build with {@code -rf} taking into account the edge case\nwhere multiple modules in the reactor have the same artifactId.\n<p>\n{@code -rf :artifactId} will pick up the first module which matches, but when multiple modules in the reactor\nhave the same artifactId, effective failed module might be later in build reactor.\nThis means that developer will either have to type groupId or wait for build execution of all modules which\nwere fine, but they are still before one which reported errors.\n<p>Then the returned value is {@code groupId:artifactId} when there is a name clash and\n{@code :artifactId} if there is no conflict.\nThis method is made package-private for testing purposes.\n\n@param mavenProjects Maven projects which are part of build execution.\n@param firstFailedProject The first project which has failed.\n@return Value for -rf flag to resume build exactly from place where it failed ({@code :artifactId} in general\nand {@code groupId:artifactId} when there is a name clash)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/ExecutionRecorder.java",
    "type": "method",
    "name": "reportingEntryPublished",
    "code": "public void reportingEntryPublished(TestDescriptor testDescriptor, ReportEntry entry) {\n\t\tthis.events.add(Event.reportingEntryPublished(testDescriptor, entry));\n\t}",
    "comment": "Record an {@link Event} for a published {@link ReportEntry}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertionFailureBuilder.java",
    "type": "method",
    "name": "formatClassAndValue",
    "code": "private static String formatClassAndValue(Object value, String valueString) {\n\t\tif (value == null) {\n\t\t\treturn \"<null>\";\n\t\t}\n\t\tString classAndHash = getClassName(value) + toHash(value);\n\t\treturn (value instanceof Class ? \"<\" + classAndHash + \">\" : classAndHash + \"<\" + valueString + \">\");\n\t}",
    "comment": "If the value is null, return <null> instead of null<null>.\nif it's a class, there's no need to repeat the class name contained in the valueString."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantBuilder.java",
    "type": "method",
    "name": "appendDecimal",
    "code": "public void appendDecimal(BigDecimal d) {\n    checkCapacity(2 + 16);\n    BigInteger unscaled = d.unscaledValue();\n    if (d.scale() <= MAX_DECIMAL4_PRECISION && d.precision() <= MAX_DECIMAL4_PRECISION) {\n      writeBuffer[writePos++] = primitiveHeader(DECIMAL4);\n      writeBuffer[writePos++] = (byte) d.scale();\n      writeLong(writeBuffer, writePos, unscaled.intValueExact(), 4);\n      writePos += 4;\n    } else if (d.scale() <= MAX_DECIMAL8_PRECISION && d.precision() <= MAX_DECIMAL8_PRECISION) {\n      writeBuffer[writePos++] = primitiveHeader(DECIMAL8);\n      writeBuffer[writePos++] = (byte) d.scale();\n      writeLong(writeBuffer, writePos, unscaled.longValueExact(), 8);\n      writePos += 8;\n    } else {\n      assert d.scale() <= MAX_DECIMAL16_PRECISION && d.precision() <= MAX_DECIMAL16_PRECISION;\n      writeBuffer[writePos++] = primitiveHeader(DECIMAL16);\n      writeBuffer[writePos++] = (byte) d.scale();\n      byte[] bytes = unscaled.toByteArray();\n      for (int i = 0; i < bytes.length; ++i) {\n        writeBuffer[writePos + i] = bytes[bytes.length - 1 - i];\n      }\n      byte sign = (byte) (bytes[0] < 0 ? -1 : 0);\n      for (int i = bytes.length; i < 16; ++i) {\n        writeBuffer[writePos + i] = sign;\n      }\n      writePos += 16;\n    }\n  }",
    "comment": "Append a decimal value to the variant builder. The caller should guarantee that its precision\nand scale fit into `MAX_DECIMAL16_PRECISION`.\n`toByteArray` returns a big-endian representation. We need to copy it reversely and sign\nextend it to 16 bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dirty-flag/src/main/java/com/iluwatar/dirtyflag/World.java",
    "type": "method",
    "name": "fetch",
    "code": "public List<String> fetch() {\n    var data = df.fetch();\n    countries = data.isEmpty() ? countries : data;\n    return countries;\n  }",
    "comment": "Calls {@link DataFetcher} to fetch data from back-end.\n\n@return List of strings"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/BaseParser.java",
    "type": "method",
    "name": "getTopDirectory",
    "code": "protected Path getTopDirectory(LocalContext context) {\n        Path topDirectory = requireNonNull(context.cwd);\n        boolean isAltFile = false;\n        for (String arg : context.parserRequest.args()) {\n            if (isAltFile) {\n                Path path = topDirectory.resolve(stripLeadingAndTrailingQuotes(arg));\n                if (Files.isDirectory(path)) {\n                    topDirectory = path;\n                } else if (Files.isRegularFile(path)) {\n                    topDirectory = path.getParent();\n                    if (!Files.isDirectory(topDirectory)) {\n                        throw new IllegalArgumentException(\"Directory \" + topDirectory\n                                + \" extracted from the -f/--file command-line argument \" + arg + \" does not exist\");\n                    }\n                } else {\n                    throw new IllegalArgumentException(\n                            \"POM file \" + arg + \" specified with the -f/--file command line argument does not exist\");\n                }\n                break;\n            } else {\n                isAltFile = arg.equals(\"-f\") || arg.equals(\"--file\");\n            }\n        }\n        return getCanonicalPath(topDirectory);\n    }",
    "comment": "We need to locate the top level project which may be pointed at using\nthe -f/--file option.\nthis is the argument following -f/--file\nCheck if this is the -f/--file option"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-repository-metadata/src/test/java/org/apache/maven/artifact/repository/metadata/MetadataTest.java",
    "type": "method",
    "name": "mergeWithSnapshotLegacy",
    "code": "void mergeWithSnapshotLegacy() {\n        Metadata source = createMetadataFromArtifact(artifact);\n        Date before = new Date(System.currentTimeMillis() - 5000);\n        Date after = new Date(System.currentTimeMillis());\n        addSnapshotVersion(target.getVersioning(), before, artifact);\n        addSnapshotVersionLegacy(source.getVersioning(), after, 2);\n        assertTrue(target.merge(source));\n        assertEquals(0, target.getVersioning().getSnapshotVersions().size());\n        assertEquals(formatDate(after, false), target.getVersioning().getLastUpdated());\n        assertEquals(\n                formatDate(after, true), target.getVersioning().getSnapshot().getTimestamp());\n        assertEquals(2, target.getVersioning().getSnapshot().getBuildNumber());\n    }",
    "comment": "legacy metadata did not have \"versioning.snapshotVersions\"\nalthough nothing has changed merge returns true, as the last modified date is equal\nTODO: improve merge here?\nthe result must be legacy format as well"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "setUseNnapiCpu",
    "code": "public Options setUseNnapiCpu(boolean enable) {\n      this.useNnapiCpu = enable;\n      return this;\n    }",
    "comment": "Enable or disable the NNAPI CPU Device \"nnapi-reference\". If unset it will use the NNAPI\ndefault settings.\n\n<p>Only effective on Android 10 (API level 29) and above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/protocol/Encoders.java",
    "type": "method",
    "name": "decode",
    "code": "public static RoaringBitmap decode(ByteBuf buf) {\n      RoaringBitmap bitmap = new RoaringBitmap();\n      try {\n        bitmap.deserialize(buf.nioBuffer());\n        buf.readerIndex(buf.readerIndex() + bitmap.serializedSizeInBytes());\n      } catch (IOException e) {\n        throw new RuntimeException(\"Exception while decoding bitmap\", e);\n      }\n      return bitmap;\n    }",
    "comment": "RoaringBitmap deserialize does not advance the reader index of the underlying ByteBuf.\nManually update the index here."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/CWD.java",
    "type": "method",
    "name": "resolve",
    "code": "public Path resolve(String seg) {\n        requireNonNull(seg, \"seg\");\n        return directory.resolve(seg).normalize();\n    }",
    "comment": "Resolves against current cwd, resulting path is normalized.\n\n@throws NullPointerException if {@code seg} is {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/internal/runners/statements/ExpectExceptionTest.java",
    "type": "method",
    "name": "whenExpectingAssumptionViolatedExceptionStatementsThrowingItShouldPass",
    "code": "public void whenExpectingAssumptionViolatedExceptionStatementsThrowingItShouldPass() {\n        Statement delegate = new Fail(new AssumptionViolatedException(\"expected\"));\n        ExpectException expectException = new ExpectException(delegate, AssumptionViolatedException.class);\n\n        try {\n            expectException.evaluate();\n            // then AssumptionViolatedException should not be thrown\n        } catch (Throwable e) { // need to explicitly catch and re-throw as an AssertionError or it might be skipped\n            fail(\"should not throw anything, but was thrown: \" + e);\n        }\n    }",
    "comment": "Integration tests can be found in {@link org.junit.tests.running.methods.ExpectedTest}.\nSee e.g. {@link org.junit.tests.running.methods.ExpectedTest#expectsAssumptionViolatedException()}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolver.java",
    "type": "method",
    "name": "addSelectorResolver",
    "code": "public Builder<T> addSelectorResolver(Function<InitializationContext<T>, SelectorResolver> resolverCreator) {\n\t\t\tresolverCreators.add(resolverCreator);\n\t\t\treturn this;\n\t\t}",
    "comment": "Add a context sensitive {@link SelectorResolver} to this builder.\n\n@param resolverCreator the function that will be called to create the\n{@link SelectorResolver} to be added.\n@return this builder for method chaining\n@see InitializationContext"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setFloat",
    "code": "public void setFloat(float value) {\n    floatData = value;\n  }",
    "comment": "Sets the float `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/categories/CategoryValidator.java",
    "type": "method",
    "name": "validateAnnotatedMethod",
    "code": "public List<Exception> validateAnnotatedMethod(FrameworkMethod method) {\n        List<Exception> errors = new ArrayList<Exception>();\n        Annotation[] annotations = method.getAnnotations();\n        for (Annotation annotation : annotations) {\n            for (Class<?> clazz : INCOMPATIBLE_ANNOTATIONS) {\n                if (annotation.annotationType().isAssignableFrom(clazz)) {\n                    addErrorMessage(errors, clazz);\n                }\n            }\n        }\n        return unmodifiableList(errors);\n    }",
    "comment": "Adds to {@code errors} a throwable for each problem detected. Looks for\n{@code BeforeClass}, {@code AfterClass}, {@code Before} and {@code After}\nannotations.\n\n@param method the method that is being validated\n@return A list of exceptions detected\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "getBytes",
    "code": "public byte[] getBytes() {\n    return UnsafeDataUtils.getBytes(baseObject, baseOffset, sizeInBytes);\n  }",
    "comment": "Returns the underlying bytes for this UnsafeRow."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "setFooter",
    "code": "public void setFooter(List<String> footer) {\n        this.footer = footer;\n    }",
    "comment": "Set the comment footer.\n\n@param footer the footer to use"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/PackageNameFilter.java",
    "type": "method",
    "name": "excludePackageNames",
    "code": "static PackageNameFilter excludePackageNames(String... names) {\n\t\treturn new ExcludePackageNameFilter(names);\n\t}",
    "comment": "Create a new <em>exclude</em> {@link PackageNameFilter} based on the\n@see Package#getName()\n@see #excludePackageNames(List)\n@see #includePackageNames(String...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultArtifactDeployer.java",
    "type": "method",
    "name": "deploy",
    "code": "public void deploy(@Nonnull ArtifactDeployerRequest request) {\n        nonNull(request, \"request\");\n        InternalSession session = InternalSession.from(request.getSession());\n        Collection<ProducedArtifact> artifacts = nonNull(request.getArtifacts(), \"request.artifacts\");\n        RemoteRepository repository = nonNull(request.getRepository(), \"request.repository\");\n        try {\n            DeployRequest deployRequest = new DeployRequest()\n                    .setRepository(session.toRepository(repository))\n                    .setArtifacts(session.toArtifacts(artifacts));\n\n            session.getRepositorySystem().deploy(session.getSession(), deployRequest);\n        } catch (DeploymentException e) {\n            throw new ArtifactDeployerException(\"Unable to deploy artifacts\", e);\n        }\n    }",
    "comment": "Implementation of {@link ArtifactDeployer} service."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/testFixtures/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java",
    "type": "method",
    "name": "uniqueIdForClass",
    "code": "public static UniqueId uniqueIdForClass(Class<?> clazz) {\n\t\tif (isInnerClass(clazz)) {\n\t\t\tvar segmentType = classSegmentType(clazz, NestedClassTestDescriptor.SEGMENT_TYPE,\n\t\t\t\tClassTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE);\n\t\t\treturn uniqueIdForClass(clazz.getEnclosingClass()).append(segmentType, clazz.getSimpleName());\n\t\t}\n\t\treturn uniqueIdForStaticClass(clazz.getName());\n\t}",
    "comment": "Test data builder for unique IDs for JupiterTestEngine.\n\nUsed to decouple tests from concrete unique ID strings.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/LookupInvoker.java",
    "type": "method",
    "name": "LookupInvoker",
    "code": "public LookupInvoker(Lookup protoLookup, @Nullable Consumer<LookupContext> contextConsumer) {\n        this.protoLookup = requireNonNull(protoLookup);\n        this.contextConsumer = contextConsumer;\n    }",
    "comment": "Lookup invoker implementation, that boots up DI container.\n\n@param <C> The context type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "a",
    "code": "default MessageBuilder a(char[] value, int offset, int len) {\n        return append(String.valueOf(value, offset, len));\n    }",
    "comment": "Append content to the message buffer.\n\n@param value the content to append\n@param offset the index of the first {@code char} to append\n@param len the number of {@code char}s to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isNotAbstract",
    "code": "public static boolean isNotAbstract(Member member) {\n\t\treturn ReflectionUtils.isNotAbstract(member);\n\t}",
    "comment": "Determine if the supplied member is not {@code abstract}.\n\n@param member the class to check; never {@code null}\n@return {@code true} if the member is not {@code abstract}\n@since 1.13\n@see java.lang.reflect.Modifier#isAbstract(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedProgrammaticExtensionRegistrationTests.java",
    "type": "method",
    "name": "instanceLevelWithDefaultOrderPlusOneAndDefaultOrder",
    "code": "void instanceLevelWithDefaultOrderPlusOneAndDefaultOrder() {\n\t\tClass<?> testClass = DefaultOrderPlusOneAndDefaultOrderInstanceLevelExtensionRegistrationTestCase.class;\n\t\tString testClassName = testClass.getSimpleName();\n\t\tassertOutcome(testClass, //\n\t\t\ttestClassName + \" :: extension1 :: after test\", //\n\t\t\ttestClassName + \" :: extension3 :: after test\", //\n\t\t\ttestClassName + \" :: extension2 :: after test\" //\n\t\t);\n\t}",
    "comment": "Verify that an \"after\" callback can be registered first relative to other\nnon-annotated \"after\" callbacks.\n\n@since 5.6\n@see <a href=\"https://github.com/junit-team/junit5/issues/1924\">gh-1924</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/SupportsCatalogOptions.java",
    "type": "method",
    "name": "extractTimeTravelTimestamp",
    "code": "default Optional<String> extractTimeTravelTimestamp(CaseInsensitiveStringMap options) {\n    return Optional.empty();\n  }",
    "comment": "Extracts the timestamp string for time travel from the given options."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/lockable-object/src/main/java/com/iluwatar/lockableobject/SwordOfAragorn.java",
    "type": "method",
    "name": "SwordOfAragorn",
    "code": "public SwordOfAragorn() {\n    this.locker = null;\n    this.synchronizer = new Object();\n  }",
    "comment": "An implementation of a Lockable object. This is the Sword of Aragorn and every creature wants to\npossess it!"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(char expected, char actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/PluginsMetadataGeneratorFactory.java",
    "type": "method",
    "name": "newInstance",
    "code": "public MetadataGenerator newInstance(RepositorySystemSession session, InstallRequest request) {\n        return new PluginsMetadataGenerator(session, request);\n    }",
    "comment": "Maven G level metadata generator factory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/tools/benchmark/experimental/delegate_performance/android/src/main/java/org/tensorflow/lite/benchmark/delegateperformance/RawDelegateMetricsEntry.java",
    "type": "method",
    "name": "delegateIdentifier",
    "code": "String delegateIdentifier() {\n    return delegateName + \" (\" + path + \")\";\n  }",
    "comment": "Returns an identifier for the delegate. The idenfier consists of the delegate type and the path\nto the delegate settings file."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, float actual, float delta, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, delta, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/Throwables.java",
    "type": "method",
    "name": "processLine",
    "code": "@Override public State processLine(String methodName) {\n                if (isReflectionMethod(methodName)) {\n                    return this;\n                } else if (isTestFrameworkMethod(methodName)) {\n                    return PROCESSING_TEST_FRAMEWORK_CODE;\n                }\n                return DONE;\n            }",
    "comment": "This is here to handle TestCase.runBare() calling TestCase.runTest()."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/LauncherSessionListener.java",
    "type": "method",
    "name": "LauncherSessionListener",
    "code": "LauncherSessionListener NOOP = new LauncherSessionListener() {\n\n\tdefault void launcherSessionOpened(LauncherSession session) {\n\t}\n\n\tdefault void launcherSessionClosed(LauncherSession session) {\n\t}\n\n}",
    "comment": "Called when a launcher session was closed.\n\n@param session the closed session"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionProfileActivator.java",
    "type": "method",
    "name": "isActive",
    "code": "public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        if (profile.getActivation() == null || profile.getActivation().getCondition() == null) {\n            return false;\n        }\n        String condition = profile.getActivation().getCondition();\n        try {\n            Map<String, ConditionParser.ExpressionFunction> functions = registerFunctions(context, versionParser);\n            UnaryOperator<String> propertyResolver = s -> property(context, s);\n            return toBoolean(new ConditionParser(functions, propertyResolver).parse(condition));\n        } catch (Exception e) {\n            problems.add(\n                    Severity.ERROR, Version.V41, \"Error parsing profile activation condition: \" + e.getMessage(), e);\n            return false;\n        }\n    }",
    "comment": "Determines whether a profile should be active based on its condition.\n\n@param profile The profile to evaluate\n@param context The context in which the profile is being evaluated\n@param problems A collector for any problems encountered during evaluation\n@return true if the profile should be active, false otherwise"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationSupport.java",
    "type": "method",
    "name": "exec",
    "code": "public static UTF8String exec(final UTF8String v, final int collationId, boolean useICU) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType) {\n        return useICU ? execBinaryICU(v) : execBinary(v);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(v);\n      } else {\n        return execICU(v, collationId);\n      }\n    }",
    "comment": "Space trimming does not affect the output of this expression."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvn/resident/ResidentMavenInvoker.java",
    "type": "method",
    "name": "copyIfDifferent",
    "code": "protected MavenContext copyIfDifferent(MavenContext mavenContext, InvokerRequest invokerRequest) {\n        if (invokerRequest == mavenContext.invokerRequest) {\n            return mavenContext;\n        }\n        MavenContext shadow = new MavenContext(invokerRequest, false);\n\n        shadow.containerCapsule = mavenContext.containerCapsule;\n        shadow.lookup = mavenContext.lookup;\n        shadow.eventSpyDispatcher = mavenContext.eventSpyDispatcher;\n        shadow.maven = mavenContext.maven;\n\n        return shadow;\n    }",
    "comment": "we carry over only \"resident\" things"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/Size.java",
    "type": "method",
    "name": "Size",
    "code": "public Size(final int width, final int height) {\n    this.width = width;\n    this.height = height;\n  }",
    "comment": "Size class independent of a Camera object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/AssertionsDemo.java",
    "type": "method",
    "name": "timeoutNotExceeded",
    "code": "void timeoutNotExceeded() {\n\t\tassertTimeout(ofMinutes(2), () -> {\n\t\t});\n\t}",
    "comment": "end::user_guide[]\ntag::user_guide[]\nThe following assertion succeeds.\nPerform task that takes less than 2 minutes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertSame",
    "code": "public static void assertSame(Object expected, Object actual) {\n        Assert.assertSame(expected, actual);\n    }",
    "comment": "Asserts that two objects refer to the same object. If they are not\nthe same an AssertionFailedError is thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "cursorUp",
    "code": "public Ansi cursorUp(final int y) {\n        return y > 0 ? appendEscapeSequence('A', y) : y < 0 ? cursorDown(-y) : this;\n    }",
    "comment": "Moves the cursor up. If the parameter y is negative it moves the cursor down.\n\n@param y the number of lines to move up\n@return this Ansi instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfig.java",
    "type": "method",
    "name": "addPostDiscoveryFilters",
    "code": "public Builder addPostDiscoveryFilters(PostDiscoveryFilter... filters) {\n\t\t\tPreconditions.notNull(filters, \"PostDiscoveryFilter array must not be null\");\n\t\t\tPreconditions.containsNoNullElements(filters, \"PostDiscoveryFilter array must not contain null elements\");\n\t\t\tCollections.addAll(this.postDiscoveryFilters, filters);\n\t\t\treturn this;\n\t\t}",
    "comment": "Add all of the supplied {@code filters} to the configuration.\n\n@param filters additional post discovery filters to register;\nnever {@code null} or containing {@code null}\n@return this builder for method chaining\n@since 1.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Byte unexpected, byte actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Byte) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, Object expected, Object actual) {\n        if (expected == null && actual == null) {\n            return;\n        }\n        if (expected != null && expected.equals(actual)) {\n            return;\n        }\n        failNotEquals(message, expected, actual);\n    }",
    "comment": "Asserts that two objects are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "uniqueIdSubstrings",
    "code": "public static Condition<Event> uniqueIdSubstrings(String... uniqueIdSubstrings) {\n\t\treturn uniqueIdSubstrings(Arrays.asList(uniqueIdSubstrings));\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if the\n{@link Event}'s {@linkplain Event#getTestDescriptor() test descriptor}\ncontains all of the supplied strings.\n\n@since 1.6"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventStatistics.java",
    "type": "method",
    "name": "dynamicallyRegistered",
    "code": "public EventStatistics dynamicallyRegistered(long expected) {\n\t\tthis.executables.add(\n\t\t\t() -> assertEquals(expected, this.events.dynamicallyRegistered().count(), \"dynamically registered\"));\n\t\treturn this;\n\t}",
    "comment": "Specify the number of expected <em>dynamic registration</em> events.\n\n@param expected the expected number of events\n@return this {@code EventStatistics} for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "tryToGetResources",
    "code": "public static Try<Set<Resource>> tryToGetResources(String classpathResourceName, ClassLoader classLoader) {\n\t\treturn ReflectionUtils.tryToGetResources(classpathResourceName, classLoader);\n\t}",
    "comment": "Try to load the {@linkplain Resource resources} for the supplied classpath\nresource name, using the supplied {@link ClassLoader}.\n\n<p>The name of a <em>classpath resource</em> must follow the semantics\nfor resource paths as defined in {@link ClassLoader#getResource(String)}.\n\n<p>If the supplied classpath resource name is prefixed with a slash\n({@code /}), the slash will be removed.\n\n@param classpathResourceName the name of the resource to load; never\n{@code null} or blank\n@param classLoader the {@code ClassLoader} to use; never {@code null}\n@return a successful {@code Try} containing the loaded resources or a failed\n{@code Try} containing the exception if no such resources could be loaded;\nnever {@code null}\n@since 1.12\n@see #tryToGetResources(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/Logger.java",
    "type": "method",
    "name": "info",
    "code": "default void info(@Nonnull String message, @Nullable Throwable error) {\n        log(Level.INFO, message, error);\n    }",
    "comment": "Logs an info message with an associated exception.\n\n@param message the info message to be logged\n@param error the associated exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectMethod",
    "code": "public static MethodSelector selectMethod(Class<?> javaClass, String methodName) {\n\t\treturn selectMethod(javaClass, methodName, \"\");\n\t}",
    "comment": "Create a {@code MethodSelector} for the supplied {@link Class} and method name.\n\n@param javaClass the class in which the method is declared, or a subclass thereof;\nnever {@code null}\n@param methodName the name of the method to select; never {@code null} or blank\n@see MethodSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "getArray",
    "code": "public LongArray getArray() {\n    assert(longArray != null);\n    return longArray;\n  }",
    "comment": "Returns the underline long[] of longArray."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/mediator/src/test/java/com/iluwatar/mediator/PartyImplTest.java",
    "type": "method",
    "name": "testPartyAction",
    "code": "void testPartyAction() {\n    final var partyMember1 = mock(PartyMember.class);\n    final var partyMember2 = mock(PartyMember.class);\n\n    final var party = new PartyImpl();\n    party.addMember(partyMember1);\n    party.addMember(partyMember2);\n\n    verify(partyMember1).joinedParty(party);\n    verify(partyMember2).joinedParty(party);\n\n    party.act(partyMember1, Action.GOLD);\n    verifyNoMoreInteractions(partyMember1);\n    verify(partyMember2).partyAction(Action.GOLD);\n\n    verifyNoMoreInteractions(partyMember1, partyMember2);\n  }",
    "comment": "Verify if a member is notified when it's joining a party. Generate an action and see if the\nother member gets it. Also check members don't get their own actions."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/arrange-act-assert/src/test/java/com/iluwatar/arrangeactassert/CashAAATest.java",
    "type": "method",
    "name": "testPlus",
    "code": "void testPlus() {\n    // Arrange\n    var cash = new Cash(3);\n    // Act\n    cash.plus(4);\n    // Assert\n    assertEquals(7, cash.count());\n  }",
    "comment": "Arrange/Act/Assert (AAA) is a pattern for organizing unit tests. It is a way to structure your\ntests, so they're easier to read, maintain and enhance.\n\n<p>It breaks tests down into three clear and distinct steps:\n\n<p>1. Arrange: Perform the setup and initialization required for the test.\n\n<p>2. Act: Take action(s) required for the test.\n\n<p>3. Assert: Verify the outcome(s) of the test.\n\n<p>This pattern has several significant benefits. It creates a clear separation between a test's\nsetup, operations, and results. This structure makes the code easier to read and understand. If\nyou place the steps in order and format your code to separate them, you can scan a test and\nquickly comprehend what it does.\n\n<p>It also enforces a certain degree of discipline when you write your tests. You have to think\nclearly about the three steps your test will perform. But it makes tests more natural to write at\nthe same time since you already have an outline.\n\n<p>In ({@link CashAAATest}) we have four test methods. Each of them has only one reason to change\nand one reason to fail. In a large and complicated code base, tests that honor the single\nresponsibility principle are much easier to troubleshoot."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelData.java",
    "type": "method",
    "name": "setVersion",
    "code": "public void setVersion(String version) {\n        this.version = version;\n    }",
    "comment": "Sets the effective version of the model.\n\n@param version The effective version of the model, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom/java/com/example/android/persistence/migrations/UserDaoTest.java",
    "type": "method",
    "name": "initDb",
    "code": "public void initDb() {\n        // using an in-memory database because the information stored here disappears when the\n        // process is killed\n        mDatabase = Room.inMemoryDatabaseBuilder(ApplicationProvider.getApplicationContext(),\n                UsersDatabase.class).build();\n    }",
    "comment": "Test the implementation of {@link UserDao}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(ModuleSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link ModuleSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Float> create(Scope scope, float data) {\n    return create(scope, data, Float.class);\n  }",
    "comment": "Creates a constant containing a single {@code float} element.\n\n@param scope is a scope used to add the underlying operation.\n@param data The value to put into the new constant.\n@return a float constant"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java",
    "type": "method",
    "name": "isRepeatableAnnotationContainer",
    "code": "private static boolean isRepeatableAnnotationContainer(Class<? extends Annotation> candidateContainerType) {\n\t\treturn repeatableAnnotationContainerCache.computeIfAbsent(candidateContainerType, candidate -> {\n\t\t\t// @formatter:off\n\t\t\tRepeatable repeatable = Arrays.stream(candidate.getMethods())\n\t\t\t\t\t.filter(attribute -> attribute.getName().equals(\"value\") && attribute.getReturnType().isArray())\n\t\t\t\t\t.findFirst()\n\t\t\t\t\t.map(attribute -> attribute.getReturnType().getComponentType().getAnnotation(Repeatable.class))\n\t\t\t\t\t.orElse(null);\n\t\t\t// @formatter:on\n\n\t\t\treturn repeatable != null && candidate.equals(repeatable.value());\n\t\t});\n\t}",
    "comment": "Determine if the supplied annotation type is a container for a repeatable\nannotation.\n\n@since 1.5"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "sslRpctrustStoreReloadIntervalMs",
    "code": "public int sslRpctrustStoreReloadIntervalMs() {\n    return conf.getInt(\"spark.ssl.rpc.trustStoreReloadIntervalMs\", 10000);\n  }",
    "comment": "The interval, in milliseconds, the trust-store will reload its configuration"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/CompositeService.java",
    "type": "method",
    "name": "stop",
    "code": "private synchronized void stop(int numOfServicesStarted) {\n    for (int i = numOfServicesStarted; i >= 0; i--) {\n      Service service = serviceList.get(i);\n      try {\n        service.stop();\n      } catch (Throwable t) {\n        LOG.info(\"Error stopping {}\", t, MDC.of(LogKeys.SERVICE_NAME$.MODULE$, service.getName()));\n      }\n    }\n  }",
    "comment": "stop in reserve order of start"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/project/artifact/DefaultMavenMetadataCache.java",
    "type": "method",
    "name": "isStale",
    "code": "public boolean isStale() {\n            File pomFile = pomArtifact.getFile();\n            if (pomFile != null) {\n                if (pomFile.canRead()) {\n                    return length != pomFile.length() || timestamp != pomFile.lastModified();\n                } else {\n                    boolean snapshot = pomArtifact.isSnapshot();\n                    for (ArtifactRepository repository : remoteRepositories) {\n                        ArtifactRepositoryPolicy policy =\n                                snapshot ? repository.getSnapshots() : repository.getReleases();\n                        if (ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS.equals(policy.getUpdatePolicy())) {\n                            return true;\n                        }\n                    }\n                }\n            }\n\n            return length != -1 || timestamp != -1;\n        }",
    "comment": "if the POM didn't exist, retry if any repo is configured to always update"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-bus/src/main/java/com/iluwatar/databus/DataBus.java",
    "type": "method",
    "name": "subscribe",
    "code": "public void subscribe(final Member member) {\n    this.listeners.add(member);\n  }",
    "comment": "Register a member with the data-bus to start receiving events.\n\n@param member The member to register"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/fluent-interface/src/main/java/com/iluwatar/fluentinterface/fluentiterable/lazy/LazyFluentIterable.java",
    "type": "method",
    "name": "last",
    "code": "public Optional<E> last() {\n    var resultIterator = last(1).iterator();\n    return resultIterator.hasNext() ? Optional.of(resultIterator.next()) : Optional.empty();\n  }",
    "comment": "Can be used to collect objects from the iteration. Is a terminating operation.\n\n@return an Optional containing the last object of this Iterable"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/MonotonicClock.java",
    "type": "method",
    "name": "start",
    "code": "public static Instant start() {\n        return get().startInstant();\n    }",
    "comment": "Returns the initialization time of this monotonic clock.\nThis is a convenience method equivalent to {@code get().start()}.\n\n@return the instant when this monotonic clock was initialized\n@see #startInstant()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeNeverParameter",
    "code": "void cleanupModeNeverParameter() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(NeverParameterCase.class, \"testNeverParameter\", \"java.nio.file.Path\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(neverParameterDir).exists();\n\t\t}",
    "comment": "Ensure that NEVER cleanup modes are obeyed for parameters.\n<p/>\nExpect the TempDir not to be cleaned up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/server/BlockPushNonFatalFailure.java",
    "type": "method",
    "name": "fillInStackTrace",
    "code": "public synchronized Throwable fillInStackTrace() {\n    return this;\n  }",
    "comment": "Since this type of exception is used to only convey the error code, we reduce the\nexception initialization overhead by skipping filling the stack trace."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/map-reduce/src/test/java/com/iluwatar/ReducerTest.java",
    "type": "method",
    "name": "testReduceWithTiedCounts",
    "code": "void testReduceWithTiedCounts() {\n    Map<String, List<Integer>> input = new HashMap<>();\n    input.put(\"tie1\", Arrays.asList(2, 2));\n    input.put(\"tie2\", Arrays.asList(1, 3));\n\n    List<Map.Entry<String, Integer>> result = Reducer.reduce(input);\n\n    assertEquals(2, result.size());\n    assertEquals(4, result.get(0).getValue());\n    assertEquals(4, result.get(1).getValue());\n  }",
    "comment": "Note: The order of tie1 and tie2 is not guaranteed in case of a tie"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "parse",
    "code": "public static Optional<? extends DiscoverySelector> parse(DiscoverySelectorIdentifier identifier) {\n\t\treturn DiscoverySelectorIdentifierParsers.parse(identifier);\n\t}",
    "comment": "Parse the supplied {@link DiscoverySelectorIdentifier}.\n\n@param identifier the {@code DiscoverySelectorIdentifier} to parse;\nnever {@code null}\n@return an {@link Optional} containing the corresponding {@link DiscoverySelector};\nnever {@code null} but potentially empty\n@since 1.11\n@see DiscoverySelectorIdentifierParser"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/SnapshotMetadataGeneratorFactory.java",
    "type": "method",
    "name": "newInstance",
    "code": "public MetadataGenerator newInstance(RepositorySystemSession session, InstallRequest request) {\n        return new LocalSnapshotMetadataGenerator(session, request);\n    }",
    "comment": "Maven GAV level metadata generator factory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/merge/ModelMerger.java",
    "type": "method",
    "name": "mergeAll",
    "code": "void mergeAll(Collection<V> vs, Remapping<V> remapping) {\n            if (map == null) {\n                map = new LinkedHashMap<>(list.size() + vs.size());\n                for (V v : list) {\n                    map.put(keyComputer.key(v), v);\n                }\n                list = null;\n            }\n            if (vs instanceof MergingList mergingList && mergingList.map != null) {\n                for (Map.Entry<Object, V> e : ((MergingList<V>) vs).map.entrySet()) {\n                    Object key = e.getKey();\n                    V oldValue = map.get(key);\n                    V newValue = (oldValue == null) ? e.getValue() : remapping.merge(oldValue, e.getValue());\n                    if (newValue == null) {\n                        remove(key);\n                    } else if (newValue != oldValue) {\n                        map.put(key, newValue);\n                    }\n                }\n            } else {\n                for (V v : vs) {\n                    Object key = keyComputer.key(v);\n                    V oldValue = map.get(key);\n                    V newValue = (oldValue == null) ? v : remapping.merge(oldValue, v);\n                    if (newValue == null) {\n                        remove(key);\n                    } else {\n                        map.put(key, newValue);\n                    }\n                }\n            }\n        }",
    "comment": "JDK8: this should be a call to map.merge( key, v, remapping )\nJDK8: this should be a call to map.merge( key, v, remapping )"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isNotStatic",
    "code": "public static boolean isNotStatic(Member member) {\n\t\treturn ReflectionUtils.isNotStatic(member);\n\t}",
    "comment": "Determine if the supplied member is not {@code static}.\n\n@param member the member to check; never {@code null}\n@return {@code true} if the member is not {@code static}\n@see java.lang.reflect.Modifier#isStatic(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(double unexpected, Double actual) {\n\t\tAssertNotEquals.assertNotEquals((Double) unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "keyStore",
    "code": "public Builder keyStore(File keyStore, String keyStorePassword) {\n      this.keyStore = keyStore;\n      this.keyStorePassword = keyStorePassword;\n      return this;\n    }",
    "comment": "Sets the Keystore and Keystore password\n\n@param keyStore The key store file to use\n@param keyStorePassword The password for the key store\n@return The builder object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TestPlan.java",
    "type": "method",
    "name": "getChildren",
    "code": "public Set<TestIdentifier> getChildren(TestIdentifier parent) {\n\t\tPreconditions.notNull(parent, \"parent must not be null\");\n\t\treturn getChildren(parent.getUniqueIdObject());\n\t}",
    "comment": "Get the children of the supplied {@link TestIdentifier}.\n\n@param parent the identifier to look up the children for; never {@code null}\n@return an unmodifiable set of the parent's children, potentially empty\n@see #getChildren(UniqueId)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/CookieSigner.java",
    "type": "method",
    "name": "signCookie",
    "code": "public String signCookie(String str) {\n    if (str == null || str.isEmpty()) {\n      throw new IllegalArgumentException(\"NULL or empty string to sign\");\n    }\n    String signature = getSignature(str);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Signature generated for \" + str + \" is \" + signature);\n    }\n    return str + SIGNATURE + signature;\n  }",
    "comment": "Sign the cookie given the string token as input.\n@param str Input token\n@return Signed token that can be used to create a cookie"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "listeners",
    "code": "public LauncherDiscoveryRequestBuilder listeners(LauncherDiscoveryListener... listeners) {\n\t\tPreconditions.notNull(listeners, \"discovery listener array must not be null\");\n\t\tPreconditions.containsNoNullElements(listeners, \"individual discovery listeners must not be null\");\n\t\tthis.discoveryListeners.addAll(Arrays.asList(listeners));\n\t\treturn this;\n\t}",
    "comment": "Add all supplied discovery listeners to the request.\n\n<p>In addition to the {@linkplain LauncherDiscoveryListener listeners}\nregistered using this method, this builder will add a default listener\nto this request that can be specified using the\n{@value #DEFAULT_DISCOVERY_LISTENER_CONFIGURATION_PROPERTY_NAME}\nconfiguration parameter.\n\n@param listeners the {@code LauncherDiscoveryListeners} to add; never\n{@code null}\n@return this builder for method chaining\n@since 1.6\n@see LauncherDiscoveryListener\n@see LauncherDiscoveryListeners\n@see LauncherDiscoveryRequestBuilder#DEFAULT_DISCOVERY_LISTENER_CONFIGURATION_PROPERTY_NAME"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlobUnsigned",
    "code": "public static Tensor fromBlobUnsigned(ByteBuffer data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_BUFFER_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.capacity(), shape);\n    checkArgument(data.isDirect(), ERROR_MSG_DATA_BUFFER_MUST_BE_DIRECT);\n    checkArgument(\n        (data.order() == ByteOrder.nativeOrder()),\n        ERROR_MSG_DATA_BUFFER_MUST_HAVE_NATIVE_BYTE_ORDER);\n    return new Tensor_uint8(data, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.uint8 with specified shape and data.\n\n@param data Direct buffer with native byte order that contains {@code Tensor.numel(shape)}\nelements. The buffer is used directly without copying, and changes to its content will\nchange the tensor.\n@param shape Tensor shape"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/object-pool/src/test/java/com/iluwatar/object/pool/OliphauntPoolTest.java",
    "type": "method",
    "name": "testSubsequentCheckinCheckout",
    "code": "void testSubsequentCheckinCheckout() {\n    assertTimeout(\n        ofMillis(5000),\n        () -> {\n          final var pool = new OliphauntPool();\n          assertEquals(\"Pool available=0 inUse=0\", pool.toString());\n\n          final var expectedOliphaunt = pool.checkOut();\n          assertEquals(\"Pool available=0 inUse=1\", pool.toString());\n\n          pool.checkIn(expectedOliphaunt);\n          assertEquals(\"Pool available=1 inUse=0\", pool.toString());\n\n          for (int i = 0; i < 100; i++) {\n            final var oliphaunt = pool.checkOut();\n            assertEquals(\"Pool available=0 inUse=1\", pool.toString());\n            assertSame(expectedOliphaunt, oliphaunt);\n            assertEquals(expectedOliphaunt.getId(), oliphaunt.getId());\n            assertEquals(expectedOliphaunt.toString(), oliphaunt.toString());\n\n            pool.checkIn(oliphaunt);\n            assertEquals(\"Pool available=1 inUse=0\", pool.toString());\n          }\n        });\n  }",
    "comment": "Use the same object 100 times subsequently. This should not take much time since the heavy\nobject instantiation is done only once. Verify if we get the same object each time."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java",
    "type": "method",
    "name": "setExecutorService",
    "code": "public void setExecutorService(ExecutorService executorService) {\n\t\tRunner runner = getRunnerToReport();\n\t\tif (runner instanceof ParentRunner) {\n\t\t\t((ParentRunner<?>) runner).setScheduler(new RunnerScheduler() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void finished() {\n\t\t\t\t\tThrowableCollector collector = new OpenTest4JAwareThrowableCollector();\n\t\t\t\t\tAtomicBoolean wasInterrupted = new AtomicBoolean(false);\n\t\t\t\t\tfor (Future<?> future : futures) {\n\t\t\t\t\t\tcollector.execute(() -> {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfuture.get();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (ExecutionException e) {\n\t\t\t\t\t\t\t\tthrow e.getCause();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (InterruptedException e) {\n\t\t\t\t\t\t\t\twasInterrupted.set(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tcollector.assertEmpty();\n\t\t\t\t\tif (wasInterrupted.get()) {\n\t\t\t\t\t\tlogger.warn(() -> \"Interrupted while waiting for runner to finish\");\n\t\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}",
    "comment": "We're calling `Future.get()` individually to allow for work stealing\nin case `ExecutorService` is a `ForkJoinPool`"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/functions/ScalarFunction.java",
    "type": "method",
    "name": "produceResult",
    "code": "default R produceResult(InternalRow input) {\n    throw new SparkUnsupportedOperationException(\n      \"SCALAR_FUNCTION_NOT_COMPATIBLE\",\n      Map.of(\"scalarFunc\", QuotingUtils.quoteIdentifier(name()))\n    );\n  }",
    "comment": "Applies the function to an input row to produce a value.\n\n@param input an input row\n@return a result value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/max/MaxCore.java",
    "type": "method",
    "name": "run",
    "code": "public Result run(Class<?> testClass) {\n        return run(Request.aClass(testClass));\n    }",
    "comment": "Run all the tests in <code>class</code>.\n\n@return a {@link Result} describing the details of the test run and the failed tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/xml/XmlReaderRequest.java",
    "type": "method",
    "name": "builder",
    "code": "static XmlReaderRequestBuilder builder() {\n        return new XmlReaderRequestBuilder();\n    }",
    "comment": "Interpolate the value read from the xml document\n\n@param source    The source value\n@param fieldName A description of the field being interpolated. The implementation may use this to\nlog stuff.\n@return the interpolated value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/CacheStore.java",
    "type": "method",
    "name": "writeThrough",
    "code": "public void writeThrough(final UserAccount userAccount) {\n    if (cache.contains(userAccount.getUserId())) {\n      dbManager.updateDb(userAccount);\n    } else {\n      dbManager.writeToDb(userAccount);\n    }\n    cache.set(userAccount.getUserId(), userAccount);\n  }",
    "comment": "Get user account using write-through cache.\n\n@param userAccount {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicTest.java",
    "type": "method",
    "name": "dynamicTest",
    "code": "public static DynamicTest dynamicTest(String displayName, URI testSourceUri, Executable executable) {\n\t\treturn new DynamicTest(displayName, testSourceUri, executable);\n\t}",
    "comment": "Factory for creating a new {@code DynamicTest} for the supplied display\n\n@param displayName the display name for the dynamic test; never\n{@code null} or blank\n@param testSourceUri a custom test source URI for the dynamic test; may\nbe {@code null} if the framework should generate the test source based on\nthe {@code @TestFactory} method\n@param executable the executable code block for the dynamic test;\nnever {@code null}\n@since 5.3\n@see #stream(Iterator, Function, ThrowingConsumer)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/memory/TaskMemoryManager.java",
    "type": "method",
    "name": "acquireExecutionMemory",
    "code": "public long acquireExecutionMemory(long required, MemoryConsumer requestingConsumer) {\n    assert(required >= 0);\n    assert(requestingConsumer != null);\n    MemoryMode mode = requestingConsumer.getMode();\n    // If we are allocating Tungsten pages off-heap and receive a request to allocate on-heap\n    // memory here, then it may not make sense to spill since that would only end up freeing\n    // off-heap memory. This is subject to change, though, so it may be risky to make this\n    // optimization now in case we forget to undo it late when making changes.\n    synchronized (this) {\n      long got = memoryManager.acquireExecutionMemory(required, taskAttemptId, mode);\n\n      // Try to release memory from other consumers first, then we can reduce the frequency of\n      // spilling, avoid to have too many spilled files.\n      if (got < required) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Task {} need to spill {} for {}\", taskAttemptId,\n            Utils.bytesToString(required - got), requestingConsumer);\n        }\n        // We need to call spill() on consumers to free up more memory. We want to optimize for two\n        // things:\n        // * Minimize the number of spill calls, to reduce the number of spill files and avoid small\n        //   spill files.\n        // * Avoid spilling more data than necessary - if we only need a little more memory, we may\n        //   not want to spill as much data as possible. Many consumers spill more than the\n        //   requested amount, so we can take that into account in our decisions.\n        // We use a heuristic that selects the smallest memory consumer with at least `required`\n        // bytes of memory in an attempt to balance these factors. It may work well if there are\n        // fewer larger requests, but can result in many small spills if there are many smaller\n        // requests.\n\n        // Build a map of consumer in order of memory usage to prioritize spilling. Assign current\n        // consumer (if present) a nominal memory usage of 0 so that it is always last in priority\n        // order. The map will include all consumers that have previously acquired memory.\n        TreeMap<Long, List<MemoryConsumer>> sortedConsumers = new TreeMap<>();\n        for (MemoryConsumer c: consumers) {\n          if (c.getUsed() > 0 && c.getMode() == mode) {\n            long key = c == requestingConsumer ? 0 : c.getUsed();\n            List<MemoryConsumer> list =\n                sortedConsumers.computeIfAbsent(key, k -> new ArrayList<>(1));\n            list.add(c);\n          }\n        }\n        // Iteratively spill consumers until we've freed enough memory or run out of consumers.\n        while (got < required && !sortedConsumers.isEmpty()) {\n          // Get the consumer using the least memory more than the remaining required memory.\n          Map.Entry<Long, List<MemoryConsumer>> currentEntry =\n            sortedConsumers.ceilingEntry(required - got);\n          // No consumer has enough memory on its own, start with spilling the biggest consumer.\n          if (currentEntry == null) {\n            currentEntry = sortedConsumers.lastEntry();\n          }\n          List<MemoryConsumer> cList = currentEntry.getValue();\n          got += trySpillAndAcquire(requestingConsumer, required - got, cList, cList.size() - 1);\n          if (cList.isEmpty()) {\n            sortedConsumers.remove(currentEntry.getKey());\n          }\n        }\n      }\n\n      consumers.add(requestingConsumer);\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Task {} acquired {} for {}\", taskAttemptId, Utils.bytesToString(got),\n          requestingConsumer);\n      }\n\n      if (mode == MemoryMode.OFF_HEAP) {\n        synchronized (offHeapMemoryLock) {\n          currentOffHeapMemory += got;\n          peakOffHeapMemory = Math.max(peakOffHeapMemory, currentOffHeapMemory);\n        }\n      } else {\n        synchronized (onHeapMemoryLock) {\n          currentOnHeapMemory += got;\n          peakOnHeapMemory = Math.max(peakOnHeapMemory, currentOnHeapMemory);\n        }\n      }\n\n      return got;\n    }\n  }",
    "comment": "Acquire N bytes of memory for a consumer. If there is no enough memory, it will call\nspill() of consumers to release more memory.\n\n@return number of bytes successfully granted (<= N)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/procedures/ProcedureParameter.java",
    "type": "method",
    "name": "defaultValue",
    "code": "public Builder defaultValue(String sql) {\n      this.defaultValue = new DefaultValue(sql);\n      return this;\n    }",
    "comment": "Sets the default value of the parameter using SQL."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java",
    "type": "method",
    "name": "getRequiredTestMethod",
    "code": "default Method getRequiredTestMethod() {\n\t\treturn Preconditions.notNull(getTestMethod().orElse(null),\n\t\t\t\"Illegal state: required test method is not present in the current ExtensionContext\");\n\t}",
    "comment": "Get the <em>required</em> {@link Method} associated with the current test\nor container.\n\n<p>Use this method as an alternative to {@link #getTestMethod()} for use\ncases in which the test method is required to be present.\n\n@return the test method; never {@code null}\n@throws PreconditionViolationException if the test method is not present\nin this {@code ExtensionContext}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/CacheStore.java",
    "type": "method",
    "name": "get",
    "code": "public UserAccount get(final String userId) {\n    return cache.get(userId);\n  }",
    "comment": "Delegate to backing cache store.\n\n@param userId {@link String}\n@return {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(boolean condition) {\n        Assert.assertTrue(condition);\n    }",
    "comment": "Asserts that a condition is true. If it isn't it throws\nan AssertionFailedError."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Gradients.java",
    "type": "method",
    "name": "dy",
    "code": "public <T> Output<T> dy(int index) {\n    return (Output<T>) dy.get(index);\n  }",
    "comment": "Returns a symbolic handle to one of the gradient operation output\n\n<p>Warning: Does not check that the type of the tensor matches T. It is recommended to call\nthis method with an explicit type parameter rather than letting it be inferred, e.g. {@code\ngradients.<Float>dy(0)}\n\n@param <T> The expected element type of the tensors produced by this output.\n@param index The index of the output among the gradients added by this operation"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "run",
    "code": "public TestResult run() {\n        TestResult result = createResult();\n        run(result);\n        return result;\n    }",
    "comment": "A convenience method to run this test, collecting the results with a\ndefault TestResult object.\n\n@see TestResult"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "writeTo",
    "code": "public void writeTo(DoubleBuffer dst) {\n    if (dtype != DataType.DOUBLE) {\n      throw incompatibleBuffer(dst, dtype);\n    }\n    ByteBuffer src = buffer();\n    dst.put(src.asDoubleBuffer());\n  }",
    "comment": "Write the data of a {@link Double} tensor into the given buffer.\n\n<p>Copies {@code numElements()} elements to the buffer.\n\n@param dst the destination buffer\n@throws BufferOverflowException If there is insufficient space in the given buffer for the data\nin this tensor\n@throws IllegalArgumentException If the tensor datatype is not {@link Double}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<String> create(Scope scope, String data) {\n    return create(scope, data, UTF_8);\n  }",
    "comment": "Creates a {@code String} constant using the default, UTF-8 encoding.\n\n@param scope is a scope used to add the underlying operation.\n@param data The string to put into the new constant.\n@return a string constant"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "returnsPrimitiveVoid",
    "code": "public static boolean returnsPrimitiveVoid(Method method) {\n\t\treturn method.getReturnType() == void.class;\n\t}",
    "comment": "Determine if the return type of the supplied method is primitive {@code void}.\n\n@param method the method to test; never {@code null}\n@return {@code true} if the method's return type is {@code void}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/RuleMemberValidatorTest.java",
    "type": "method",
    "name": "rejectClassRuleThatIsImplementationOfMethodRule",
    "code": "public void rejectClassRuleThatIsImplementationOfMethodRule() {\n        TestClass target = new TestClass(TestWithClassRuleIsImplementationOfMethodRule.class);\n        CLASS_RULE_VALIDATOR.validate(target, errors);\n        assertOneErrorWithMessage(\"The @ClassRule 'classRule' must implement TestRule.\");\n    }",
    "comment": "If there is any property annotated with @ClassRule then it must implement\n{@link TestRule}\n\n<p>This case has been added with\n<a href=\"https://github.com/junit-team/junit4/issues/1019\">Issue #1019</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethod.java",
    "type": "method",
    "name": "IsTestFactoryMethod",
    "code": "public IsTestFactoryMethod(DiscoveryIssueReporter issueReporter) {\n\t\tsuper(TestFactory.class, IsTestFactoryMethod::hasCompatibleReturnType, issueReporter);\n\t}",
    "comment": "Test if a method is a JUnit Jupiter {@link TestFactory @TestFactory} method.\n\n<p>NOTE: this predicate does <strong>not</strong> check if a candidate method\nhas an appropriate return type for a {@code @TestFactory} method.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "fail",
    "code": "public static <V> V fail(Throwable cause) {\n\t\tAssertionUtils.fail(cause);\n\t\treturn null; // appeasing the compiler: this line will never be executed.\n\t}",
    "comment": "<em>Fail</em> the test with the given underlying {@code cause}.\n\n<p>See Javadoc for {@link #fail(String)} for an explanation of this method's\ngeneric return type {@code V}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/hexagonal-architecture/src/main/java/com/iluwatar/hexagonal/domain/LotteryNumbers.java",
    "type": "method",
    "name": "create",
    "code": "public static LotteryNumbers create(Set<Integer> givenNumbers) {\n    return new LotteryNumbers(givenNumbers);\n  }",
    "comment": "Creates lottery number from given set of numbers.\n\n@return given LotteryNumbers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/TensorImpl.java",
    "type": "method",
    "name": "copyTo",
    "code": "private void copyTo(Buffer dst) {\n    if (dst instanceof ByteBuffer) {\n      ((ByteBuffer) dst).put(buffer());\n    } else if (dst instanceof FloatBuffer) {\n      ((FloatBuffer) dst).put(buffer().asFloatBuffer());\n    } else if (dst instanceof LongBuffer) {\n      ((LongBuffer) dst).put(buffer().asLongBuffer());\n    } else if (dst instanceof IntBuffer) {\n      ((IntBuffer) dst).put(buffer().asIntBuffer());\n    } else if (dst instanceof ShortBuffer) {\n      ((ShortBuffer) dst).put(buffer().asShortBuffer());\n    } else {\n      throw new IllegalArgumentException(\"Unexpected output buffer type: \" + dst);\n    }\n  }",
    "comment": "There is no base Buffer#put() method, so we have to ugly cast."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-yarn/src/main/java/org/apache/spark/network/yarn/YarnShuffleService.java",
    "type": "method",
    "name": "setShuffleMergeManager",
    "code": "void setShuffleMergeManager(MergedShuffleFileManager mergeManager) {\n    this.shuffleMergeManager = mergeManager;\n  }",
    "comment": "Set the customized MergedShuffleFileManager for unit testing only\n@param mergeManager"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/types/CollationSupportSuite.java",
    "type": "method",
    "name": "testLowerCaseCodePoints",
    "code": "public void testLowerCaseCodePoints() {\n    assertLowerCaseCodePoints(\"\", \"\", false);\n    assertLowerCaseCodePoints(\"\", \"\", true);\n    assertLowerCaseCodePoints(\"xyz\", \"xyz\", false);\n    assertLowerCaseCodePoints(\"xyz\", \"xyz\", true);\n    assertLowerCaseCodePoints(\"abcd\", \"abcd\", false);\n    assertLowerCaseCodePoints(\"abcd\", \"abcd\", true);\n    assertLowerCaseCodePoints(\"你好\", \"你好\", false);\n    assertLowerCaseCodePoints(\"你好\", \"你好\", true);\n    assertLowerCaseCodePoints(\"Γειά\", \"γειά\", false);\n    assertLowerCaseCodePoints(\"Γειά\", \"γειά\", true);\n    assertLowerCaseCodePoints(\"Здраво\", \"здраво\", false);\n    assertLowerCaseCodePoints(\"Здраво\", \"здраво\", true);\n    assertLowerCaseCodePoints(\"xYz\", \"xyz\", false);\n    assertLowerCaseCodePoints(\"xYz\", \"xyz\", true);\n    assertLowerCaseCodePoints(\"AbCd\", \"abcd\", false);\n    assertLowerCaseCodePoints(\"aBcD\", \"abcd\", true);\n    assertLowerCaseCodePoints(\"äbć\", \"äbć\", false);\n    assertLowerCaseCodePoints(\"äbć\", \"äbć\", true);\n    assertLowerCaseCodePoints(\"AbĆd\", \"abćd\", false);\n    assertLowerCaseCodePoints(\"aBcΔ\", \"abcδ\", true);\n    assertLowerCaseCodePoints(\"i\\u0307\", \"i\\u0307\", false);\n    assertLowerCaseCodePoints(\"i\\u0307\", \"i\\u0307\", true);\n    assertLowerCaseCodePoints(\"I\\u0307\", \"i\\u0307\", false);\n    assertLowerCaseCodePoints(\"I\\u0307\", \"i\\u0307\", true);\n    assertLowerCaseCodePoints(\"İ\", \"i\\u0307\", false);\n    assertLowerCaseCodePoints(\"İ\", \"i\\u0307\", true);\n    assertLowerCaseCodePoints(\"İİİ\", \"i\\u0307i\\u0307i\\u0307\", false);\n    assertLowerCaseCodePoints(\"İİİ\", \"i\\u0307i\\u0307i\\u0307\", true);\n    assertLowerCaseCodePoints(\"İiIi\\u0307\", \"i\\u0307iii\\u0307\", false);\n    assertLowerCaseCodePoints(\"İiIi\\u0307\", \"i\\u0307iii\\u0307\", true);\n    assertLowerCaseCodePoints(\"İoDiNe\", \"i\\u0307odine\", false);\n    assertLowerCaseCodePoints(\"İodInE\", \"i\\u0307odine\", true);\n    assertLowerCaseCodePoints(\"Abi\\u0307o12\", \"abi\\u0307o12\", false);\n    assertLowerCaseCodePoints(\"aBi\\u0307o12\", \"abi\\u0307o12\", true);\n    assertLowerCaseCodePoints(\"ς\", \"ς\", false);\n    assertLowerCaseCodePoints(\"ς\", \"σ\", true);\n    assertLowerCaseCodePoints(\"σ\", \"σ\", false);\n    assertLowerCaseCodePoints(\"σ\", \"σ\", true);\n    assertLowerCaseCodePoints(\"Σ\", \"σ\", false);\n    assertLowerCaseCodePoints(\"Σ\", \"σ\", true);\n    assertLowerCaseCodePoints(\"ςΑΛΑΤΑ\", \"ςαλατα\", false);\n    assertLowerCaseCodePoints(\"ςΑΛΑΤΑ\", \"σαλατα\", true);\n    assertLowerCaseCodePoints(\"σΑΛΑΤΑ\", \"σαλατα\", false);\n    assertLowerCaseCodePoints(\"σΑΛΑΤΑ\", \"σαλατα\", true);\n    assertLowerCaseCodePoints(\"ΣΑΛΑΤΑ\", \"σαλατα\", false);\n    assertLowerCaseCodePoints(\"ΣΑΛΑΤΑ\", \"σαλατα\", true);\n    assertLowerCaseCodePoints(\"ΘΑΛΑΣΣΙΝΟς\", \"θαλασσινος\", false);\n    assertLowerCaseCodePoints(\"ΘΑΛΑΣΣΙΝΟς\", \"θαλασσινοσ\", true);\n    assertLowerCaseCodePoints(\"ΘΑΛΑΣΣΙΝΟσ\", \"θαλασσινοσ\", false);\n    assertLowerCaseCodePoints(\"ΘΑΛΑΣΣΙΝΟσ\", \"θαλασσινοσ\", true);\n    assertLowerCaseCodePoints(\"ΘΑΛΑΣΣΙΝΟΣ\", \"θαλασσινος\", false);\n    assertLowerCaseCodePoints(\"ΘΑΛΑΣΣΙΝΟΣ\", \"θαλασσινοσ\", true);\n    assertLowerCaseCodePoints(\"a🙃b🙃c\", \"a🙃b🙃c\", false);\n    assertLowerCaseCodePoints(\"a🙃b🙃c\", \"a🙃b🙃c\", true);\n    assertLowerCaseCodePoints(\"😀😆😃😄😄😆\", \"😀😆😃😄😄😆\", false);\n    assertLowerCaseCodePoints(\"😀😆😃😄😄😆\", \"😀😆😃😄😄😆\", true);\n    assertLowerCaseCodePoints(\"𐐅\", \"𐐭\", false);\n    assertLowerCaseCodePoints(\"𐐅\", \"𐐭\", true);\n    assertLowerCaseCodePoints(\"𝔸\", \"𝔸\", false);\n    assertLowerCaseCodePoints(\"𝔸\", \"𝔸\", true);\n  }",
    "comment": "Empty strings.\nBasic tests.\nAdvanced tests.\nCase variation.\nAccent variation.\nOne-to-many case mapping (e.g. Turkish dotted I).\nConditional case mapping (e.g. Greek sigmas).\nSurrogate pairs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/running/methods/TimeoutTest.java",
    "type": "method",
    "name": "runAndTime",
    "code": "private long runAndTime(Class<?> clazz) {\n        JUnitCore core = new JUnitCore();\n        long startTime = System.currentTimeMillis();\n        core.run(clazz);\n        long totalTime = System.currentTimeMillis() - startTime;\n        return totalTime;\n    }",
    "comment": "\"prime the pump\": running these beforehand makes the runtimes more predictable\n(because of class loading?)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, byte expected, byte actual) {\n        Assert.assertEquals(message, expected, actual);\n    }",
    "comment": "Asserts that two bytes are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/CommandBuilderUtils.java",
    "type": "method",
    "name": "redact",
    "code": "static String redact(String arg) {\n    Matcher m = keyValuePattern.matcher(arg);\n    if (m.find() && redactPattern.matcher(m.group(1)).find()) {\n      return String.format(\"-D%s=%s\", m.group(1), \"*********(redacted)\");\n    } else {\n      return arg;\n    }\n  }",
    "comment": "Redact a command-line argument's value part which matches `-Dkey=value` pattern."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/procedures/ProcedureParameter.java",
    "type": "method",
    "name": "build",
    "code": "public ProcedureParameter build() {\n      return new ProcedureParameterImpl(mode, name, dataType, defaultValue, comment);\n    }",
    "comment": "Builds the stored procedure parameter."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java",
    "type": "method",
    "name": "findAllResourcesInPackage",
    "code": "public static List<Resource> findAllResourcesInPackage(String basePackageName, Predicate<Resource> resourceFilter) {\n\t\treturn ReflectionUtils.findAllResourcesInPackage(basePackageName, resourceFilter);\n\t}",
    "comment": "Find all {@linkplain Resource resources} in the supplied {@code basePackageName}\nthat match the specified {@code resourceFilter} predicate.\n\n<p>The classpath scanning algorithm searches recursively in subpackages\nbeginning within the supplied base package. The resulting list may include\nidentically named resources from different classpath roots.\n\n@param basePackageName the name of the base package in which to start\nscanning; must not be {@code null} and must be valid in terms of Java\nsyntax\n@param resourceFilter the resource type filter; never {@code null}\n@return an immutable list of all such classes found; never {@code null}\nbut potentially empty\n@since 1.11\n@see #findAllResourcesInClasspathRoot(URI, Predicate)\n@see #findAllResourcesInModule(String, Predicate)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/tracking/ObjectTracker.java",
    "type": "method",
    "name": "TimestampedDeltas",
    "code": "public TimestampedDeltas(final long timestamp, final byte[] deltas) {\n      this.timestamp = timestamp;\n      this.deltas = deltas;\n    }",
    "comment": "How many frames of optical flow deltas to record.\nTODO(andrewharp): Push this down to the native level so it can be polled\nefficiently into a an array for upload, instead of keeping a duplicate\ncopy in Java."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/main/java/com/iluwatar/health/check/RetryConfig.java",
    "type": "method",
    "name": "retryTemplate",
    "code": "public RetryTemplate retryTemplate() {\n    RetryTemplate retryTemplate = new RetryTemplate();\n\n    FixedBackOffPolicy fixedBackOffPolicy = new FixedBackOffPolicy();\n    fixedBackOffPolicy.setBackOffPeriod(backOffPeriod); // wait 2 seconds between retries\n    retryTemplate.setBackOffPolicy(fixedBackOffPolicy);\n\n    SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();\n    retryPolicy.setMaxAttempts(maxAttempts); // retry a max of 3 attempts\n    retryTemplate.setRetryPolicy(retryPolicy);\n\n    return retryTemplate;\n  }",
    "comment": "Creates a retry template with the configured backoff period and maximum number of attempts.\n\n@return a retry template"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeAlwaysField",
    "code": "void cleanupModeAlwaysField() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(AlwaysFieldCase.class, \"testAlwaysField\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(alwaysFieldDir).doesNotExist();\n\t\t}",
    "comment": "Ensure that ALWAYS cleanup modes are obeyed for fields.\n<p/>\nExpect the TempDir to be cleaned up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaBisectingKMeansExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkConf sparkConf = new SparkConf().setAppName(\"JavaBisectingKMeansExample\");\n    JavaSparkContext sc = new JavaSparkContext(sparkConf);\n\n    // $example on$\n    List<Vector> localData = Arrays.asList(\n      Vectors.dense(0.1, 0.1),   Vectors.dense(0.3, 0.3),\n      Vectors.dense(10.1, 10.1), Vectors.dense(10.3, 10.3),\n      Vectors.dense(20.1, 20.1), Vectors.dense(20.3, 20.3),\n      Vectors.dense(30.1, 30.1), Vectors.dense(30.3, 30.3)\n    );\n    JavaRDD<Vector> data = sc.parallelize(localData, 2);\n\n    BisectingKMeans bkm = new BisectingKMeans()\n      .setK(4);\n    BisectingKMeansModel model = bkm.run(data);\n\n    System.out.println(\"Compute Cost: \" + model.computeCost(data));\n\n    Vector[] clusterCenters = model.clusterCenters();\n    for (int i = 0; i < clusterCenters.length; i++) {\n      Vector clusterCenter = clusterCenters[i];\n      System.out.println(\"Cluster Center \" + i + \": \" + clusterCenter);\n    }\n    // $example off$\n\n    sc.stop();\n  }",
    "comment": "Java example for bisecting k-means clustering."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ResolverFacade.java",
    "type": "method",
    "name": "isAggregator",
    "code": "boolean isAggregator() {\n\t\t\treturn ArgumentsAccessor.class.isAssignableFrom(getParameterType())\n\t\t\t\t\t|| isAnnotated(getAnnotatedElement(), AggregateWith.class);\n\t\t}",
    "comment": "Determine if the supplied {@link Parameter} is an aggregator (i.e., of\ntype {@link ArgumentsAccessor} or annotated with {@link AggregateWith}).\n\n@return {@code true} if the parameter is an aggregator"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/util/ClockSource.java",
    "type": "method",
    "name": "elapsedMillis",
    "code": "static long elapsedMillis(long startTime, long endTime) {\n      return CLOCK.elapsedMillis0(startTime, endTime);\n   }",
    "comment": "Get the difference in milliseconds between two opaque time-stamps returned\nby currentTime().\n\n@param startTime an opaque time-stamp returned by an instance of this class\n@param endTime an opaque time-stamp returned by an instance of this class\n@return the elapsed time between startTime and endTime in milliseconds"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-yarn/src/main/java/org/apache/spark/network/yarn/YarnShuffleService.java",
    "type": "method",
    "name": "YarnShuffleService",
    "code": "public YarnShuffleService() {\n    // The name of the auxiliary service configured within the NodeManager\n    // (`yarn.nodemanager.aux-services`) is treated as the source-of-truth, so this one can be\n    // arbitrary. The NodeManager will log a warning if the configured name doesn't match this name,\n    // to inform operators of a potential misconfiguration, but this name is otherwise not used.\n    // It is hard-coded instead of using the value of the `spark.shuffle.service.name` configuration\n    // because at this point in instantiation there is no Configuration object; it is not passed\n    // until `serviceInit` is called, at which point it's too late to adjust the name.\n    super(\"spark_shuffle\");\n    logger.info(\"Initializing YARN shuffle service for Spark\");\n    instance = this;\n  }",
    "comment": "The name of the resource to search for on the classpath to find a shuffle service-specific\nconfiguration overlay. If found, this will be parsed as a standard Hadoop\n{@link Configuration config} file and will override the configs passed from the NodeManager."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/front-controller/src/main/java/com/iluwatar/front/controller/Dispatcher.java",
    "type": "method",
    "name": "getCommand",
    "code": "Command getCommand(String request) {\n    var commandClass = getCommandClass(request);\n    try {\n      return (Command) commandClass.getDeclaredConstructor().newInstance();\n    } catch (Exception e) {\n      throw new ApplicationException(e);\n    }\n  }",
    "comment": "Retrieves the appropriate command instance for the given request.\n\n@param request the request to be handled\n@return the command instance corresponding to the request"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantUtil.java",
    "type": "method",
    "name": "writeLong",
    "code": "public static void writeLong(byte[] bytes, int pos, long value, int numBytes) {\n    for (int i = 0; i < numBytes; ++i) {\n      bytes[pos + i] = (byte) ((value >>> (8 * i)) & 0xFF);\n    }\n  }",
    "comment": "This class defines constants related to the variant format and provides functions for\nmanipulating variant binaries.\n\nA variant is made up of 2 binaries: value and metadata. A variant value consists of a one-byte\nheader and a number of content bytes (can be zero). The header byte is divided into upper 6 bits\n(called \"type info\") and lower 2 bits (called \"basic type\"). The content format is explained in\nthe below constants for all possible basic type and type info values.\n\nThe variant metadata includes a version id and a dictionary of distinct strings (case-sensitive).\nIts binary format is:\n- Version: 1-byte unsigned integer. The only acceptable value is 1 currently.\n- Dictionary size: 4-byte little-endian unsigned integer. The number of keys in the\ndictionary.\n- Offsets: (size + 1) * 4-byte little-endian unsigned integers. `offsets[i]` represents the\nstarting position of string i, counting starting from the address of `offsets[0]`. Strings\nmust be stored contiguously, so we don’t need to store the string size, instead, we compute it\nwith `offset[i + 1] - offset[i]`.\n- UTF-8 string data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptor.java",
    "type": "method",
    "name": "getMojo",
    "code": "public MojoDescriptor getMojo(String goal) {\n        if (getMojos() == null) {\n            return null; // no mojo in this POM\n        }\n\n        for (MojoDescriptor desc : getMojos()) {\n            if (goal.equals(desc.getGoal())) {\n                return desc;\n            }\n        }\n        return null;\n    }",
    "comment": "TODO could we use a map? Maybe if the parent did that for components too, as this is too vulnerable to\nchanges above not being propagated to the map"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/special-case/src/main/java/com/iluwatar/specialcase/Db.java",
    "type": "method",
    "name": "getInstance",
    "code": "public static synchronized Db getInstance() {\n    if (instance == null) {\n      Db newInstance = new Db();\n      newInstance.userName2User = new HashMap<>();\n      newInstance.user2Account = new HashMap<>();\n      newInstance.itemName2Product = new HashMap<>();\n      instance = newInstance;\n    }\n    return instance;\n  }",
    "comment": "Get the instance of Db.\n\n@return singleton instance of Db class"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/composite-view/src/main/java/com/iluwatar/compositeview/ClientPropertiesBean.java",
    "type": "method",
    "name": "ClientPropertiesBean",
    "code": "public ClientPropertiesBean(HttpServletRequest req) {\n    worldNewsInterest = Boolean.parseBoolean(req.getParameter(WORLD_PARAM));\n    sportsInterest = Boolean.parseBoolean(req.getParameter(SPORTS_PARAM));\n    businessInterest = Boolean.parseBoolean(req.getParameter(BUSINESS_PARAM));\n    scienceNewsInterest = Boolean.parseBoolean(req.getParameter(SCIENCE_PARAM));\n    String tempName = req.getParameter(NAME_PARAM);\n    if (tempName == null || tempName.equals(\"\")) {\n      tempName = DEFAULT_NAME;\n    }\n    name = tempName;\n  }",
    "comment": "Constructor that parses an HttpServletRequest and stores all the request parameters.\n\n@param req the HttpServletRequest object that is passed in"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/retry/src/test/java/com/iluwatar/retry/RetryExponentialBackoffTest.java",
    "type": "method",
    "name": "attempts",
    "code": "void attempts() {\n    final var e = new BusinessException(\"unhandled\");\n    final var retry =\n        new RetryExponentialBackoff<String>(\n            () -> {\n              throw e;\n            },\n            2,\n            0);\n    try {\n      retry.perform();\n    } catch (BusinessException ex) {\n      // ignore\n    }\n\n    assertThat(retry.attempts(), is(1));\n  }",
    "comment": "No exceptions will be ignored, hence final number of attempts should be 1 even if we're asking\nit to attempt twice."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(float[] expected, float[] actual, float delta, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, delta, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} float arrays are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "reserveDictionaryIds",
    "code": "public WritableColumnVector reserveDictionaryIds(int capacity) {\n    if (dictionaryIds == null) {\n      dictionaryIds = reserveNewColumn(capacity, DataTypes.IntegerType);\n    } else {\n      dictionaryIds.reset();\n      dictionaryIds.reserve(capacity);\n    }\n    return dictionaryIds;\n  }",
    "comment": "Reserve a integer column for ids of dictionary."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/test/java/org/apache/maven/impl/model/MavenModelMergerTest.java",
    "type": "method",
    "name": "testMergeModelPrerequisites",
    "code": "void testMergeModelPrerequisites() {\n        Model parent =\n                Model.newBuilder().prerequisites(Prerequisites.newInstance()).build();\n        Model model = Model.newInstance();\n        Model.Builder builder = Model.newBuilder(model);\n        modelMerger.mergeModel_Prerequisites(builder, model, parent, false, null);\n        assertNull(builder.build().getPrerequisites());\n\n        Prerequisites modelPrerequisites =\n                Prerequisites.newBuilder().maven(\"3.0\").build();\n        model = Model.newBuilder().prerequisites(modelPrerequisites).build();\n        builder = Model.newBuilder(model);\n        modelMerger.mergeModel_Prerequisites(builder, model, parent, false, null);\n        assertEquals(modelPrerequisites, builder.build().getPrerequisites());\n    }",
    "comment": "Prerequisites are neither inherited nor injected"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/InMemoryCartRepository.java",
    "type": "method",
    "name": "getItemsInCart",
    "code": "public List<Cart> getItemsInCart(final String userId) {\n    return userCarts.getOrDefault(userId, new ArrayList<>());\n  }",
    "comment": "Retrieves all items in the user's cart.\n\n@param userId The ID of the user.\n@return A list of {@link Cart} items in the user's cart."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "SortState",
    "code": "private SortState(Buffer a, Comparator<? super K> c, int len) {\n      this.aLength = len;\n      this.a = a;\n      this.c = c;\n\n      // Allocate temp storage (which may be increased later if necessary)\n      tmpLength = len < 2 * INITIAL_TMP_STORAGE_LENGTH ? len >>> 1 : INITIAL_TMP_STORAGE_LENGTH;\n      tmp = s.allocate(tmpLength);\n\n      /*\n       * Allocate runs-to-be-merged stack (which cannot be expanded).  The\n       * stack length requirements are described in listsort.txt.  The C\n       * version always uses the same stack length (85), but this was\n       * measured to be too expensive when sorting \"mid-sized\" arrays (e.g.,\n       * 100 elements) in Java.  Therefore, we use smaller (but sufficiently\n       * large) stack lengths for smaller arrays.  The \"magic numbers\" in the\n       * computation below must be changed if MIN_MERGE is decreased.  See\n       * the MIN_MERGE declaration above for more information.\n       * The maximum value of 49 allows for an array up to length\n       * Integer.MAX_VALUE-4, if array is filled by the worst case stack size\n       * increasing scenario. More explanations are given in section 4 of:\n       * http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf\n       */\n      int stackLen = (len <    120  ?  5 :\n                      len <   1542  ? 10 :\n                      len < 119151  ? 24 : 49);\n      runBase = new int[stackLen];\n      runLen = new int[stackLen];\n    }",
    "comment": "Creates a TimSort instance to maintain the state of an ongoing sort.\n\n@param a the array to be sorted\n@param c the comparator to determine the order of the sort"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<String> create(Scope scope, byte[][][][][][] data) {\n    return create(scope, data, String.class);\n  }",
    "comment": "Creates a rank-5 constant of {@code String} elements, each represented as an array of {@code byte}s.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expressions.java",
    "type": "method",
    "name": "identity",
    "code": "public static Transform identity(String column) {\n    return LogicalExpressions.identity(Expressions.column(column));\n  }",
    "comment": "Create an identity transform for a column.\n<p>\nThis transform represents a logical mapping from a value to itself.\n<p>\nThe name reported by transforms created with this method is \"identity\".\n\n@param column an input column\n@return a logical identity transform with name \"identity\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/fpm/JavaPrefixSpanSuite.java",
    "type": "method",
    "name": "runPrefixSpan",
    "code": "public void runPrefixSpan() {\n    JavaRDD<List<List<Integer>>> sequences = jsc.parallelize(Arrays.asList(\n      Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3)),\n      Arrays.asList(Arrays.asList(1), Arrays.asList(3, 2), Arrays.asList(1, 2)),\n      Arrays.asList(Arrays.asList(1, 2), Arrays.asList(5)),\n      Arrays.asList(Arrays.asList(6))\n    ), 2);\n    PrefixSpan prefixSpan = new PrefixSpan()\n      .setMinSupport(0.5)\n      .setMaxPatternLength(5);\n    PrefixSpanModel<Integer> model = prefixSpan.run(sequences);\n    JavaRDD<FreqSequence<Integer>> freqSeqs = model.freqSequences().toJavaRDD();\n    List<FreqSequence<Integer>> localFreqSeqs = freqSeqs.collect();\n    Assertions.assertEquals(5, localFreqSeqs.size());\n    for (PrefixSpan.FreqSequence<Integer> freqSeq : localFreqSeqs) {\n      List<List<Integer>> seq = freqSeq.javaSequence();\n      long freq = freqSeq.freq();\n    }\n  }",
    "comment": "Check that each frequent sequence could be materialized."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/BeforeAndAfterEachTests.java",
    "type": "method",
    "name": "beforeEachMethodThrowsAnException",
    "code": "void beforeEachMethodThrowsAnException() {\n\t\tEvents testEvents = executeTestsForClass(ExceptionInBeforeEachMethodTestCase.class).testEvents();\n\n\t\tassertEquals(1, testEvents.started().count(), \"# tests started\");\n\t\tassertEquals(0, testEvents.succeeded().count(), \"# tests succeeded\");\n\t\tassertEquals(0, testEvents.skipped().count(), \"# tests skipped\");\n\t\tassertEquals(0, testEvents.aborted().count(), \"# tests aborted\");\n\t\tassertEquals(1, testEvents.failed().count(), \"# tests failed\");\n\n\n\t\tList<String> list1 = asList(\n\t\t\t\"fooBeforeEachCallback\",\n\t\t\t\t\"beforeEachMethod1\", // throws an exception.\n\t\t\t\t\"afterEachMethod\",\n\t\t\t\"fooAfterEachCallback\"\n\t\t);\n\t\tList<String> list2 = asList(\n\t\t\t\"fooBeforeEachCallback\",\n\t\t\t\t\"beforeEachMethod2\",\n\t\t\t\t\"beforeEachMethod1\", // throws an exception.\n\t\t\t\t\"afterEachMethod\",\n\t\t\t\"fooAfterEachCallback\"\n\t\t);\n\n\t\tList<String> expected = beforeEachMethodCallSequence.getFirst().equals(\"beforeEachMethod1\") ? list1 : list2;\n\n\t\tassertEquals(expected, callSequence, \"wrong call sequence\");\n\n\t\tassertThat(actualExceptionInAfterEachCallback).containsInstanceOf(EnigmaException.class);\n\t}",
    "comment": "Since the JVM does not guarantee the order in which methods are\nreturned via reflection (and since JUnit Jupiter does not yet\nsupport ordering of @BeforeEach methods), we have to figure out\nwhich @BeforeEach method got executed first in order to determine\nthe expected call sequence.\n@formatter:off\n\"beforeEachMethod2\" should not get invoked\ntest should not get invoked.\ntest should not get invoked.\n@formatter:on"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/test/org/apache/spark/Java8RDDAPISuite.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n    sc = new JavaSparkContext(\"local\", \"JavaAPISuite\");\n  }",
    "comment": "Most of these tests replicate org.apache.spark.JavaAPISuite using java 8\nlambda syntax."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/InternalErrorException.java",
    "type": "method",
    "name": "InternalErrorException",
    "code": "public InternalErrorException(String message, Throwable cause) {\n        super(message, cause);\n    }",
    "comment": "Signals an internal error in Maven itself, e.g. a programming bug."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertNotNull",
    "code": "public static void assertNotNull(Object object) {\n        assertNotNull(null, object);\n    }",
    "comment": "Asserts that an object isn't null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/Graph.java",
    "type": "method",
    "name": "if",
    "code": "Collection<Vertex> children, Map<Vertex, DfsState> stateMap, LinkedList<String> cycle) {\n        for (Vertex v : children) {\n            DfsState state = stateMap.putIfAbsent(v, DfsState.VISITING);\n            if (state == null) {\n                cycle.addLast(v.label);\n                List<String> ret = visitCycle(v.children, stateMap, cycle);\n                if (ret != null) {\n                    return ret;\n                }\n                cycle.removeLast();\n                stateMap.put(v, DfsState.VISITED);\n            } else if (state == DfsState.VISITING) {\n                int pos = cycle.lastIndexOf(v.label);\n                List<String> ret = cycle.subList(pos, cycle.size());\n                ret.add(v.label);\n                return ret;\n            }\n        }\n        return null;\n    }",
    "comment": "we are already visiting this vertex, this mean we have a cycle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/AlbumPage.java",
    "type": "method",
    "name": "changeAlbumYear",
    "code": "public AlbumPage changeAlbumYear(int year) {\n    var albumYearSelectOption = (HtmlSelect) page.getElementById(\"albumYear\");\n    var yearOption = albumYearSelectOption.getOptionByValue(Integer.toString(year));\n    albumYearSelectOption.setSelectedAttribute(yearOption, true);\n    return this;\n  }",
    "comment": "Selects the select's option value based on the year value given.\n\n@param year the new year value to set\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/project/interpolation/AbstractStringBasedModelInterpolator.java",
    "type": "method",
    "name": "PrefixedValueSourceWrapper",
    "code": "final Model model, final File projectDir, final ProjectBuilderConfiguration config) {\n        String timestampFormat = DEFAULT_BUILD_TIMESTAMP_FORMAT;\n\n        Properties modelProperties = model.getProperties();\n        if (modelProperties != null) {\n            timestampFormat = modelProperties.getProperty(BUILD_TIMESTAMP_FORMAT_PROPERTY, timestampFormat);\n        }\n\n        ValueSource modelValueSource1 = new PrefixedObjectValueSource(PROJECT_PREFIXES, model, false);\n        ValueSource modelValueSource2 = new ObjectBasedValueSource(model);\n\n        ValueSource basedirValueSource = new PrefixedValueSourceWrapper(\n                new AbstractValueSource(false) {\n                        return null;\n                    }\n                },",
    "comment": "Interpolates all expressions in the src parameter.\n<p>\nThe algorithm used for each expression is:\n<ul>\n<li>If it starts with either \"pom.\" or \"project.\", the expression is evaluated against the model.</li>\n<li>If the value is null, get the value from the context.</li>\n<li>If the value is null, but the context contains the expression, don't replace the expression string\nwith the value, and continue to find other expressions.</li>\n<li>If the value is null, get it from the model properties.</li>\n</ul>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/bridge/src/test/java/com/iluwatar/bridge/WeaponTest.java",
    "type": "method",
    "name": "testBasicWeaponActions",
    "code": "final void testBasicWeaponActions(final Weapon weapon) {\n    assertNotNull(weapon);\n    var enchantment = weapon.getEnchantment();\n    assertNotNull(enchantment);\n    assertNotNull(weapon.getEnchantment());\n\n    weapon.swing();\n    verify(enchantment).apply();\n    verifyNoMoreInteractions(enchantment);\n\n    weapon.wield();\n    verify(enchantment).onActivate();\n    verifyNoMoreInteractions(enchantment);\n\n    weapon.unwield();\n    verify(enchantment).onDeactivate();\n    verifyNoMoreInteractions(enchantment);\n  }",
    "comment": "Invoke the basic actions of the given weapon, and test if the underlying enchantment\nimplementation is invoked"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/LogDivertAppender.java",
    "type": "method",
    "name": "filter",
    "code": "public Result filter(LogEvent logEvent) {\n      OperationLog log = operationManager.getOperationLogByThread();\n      boolean excludeMatches = (loggingMode == OperationLog.LoggingLevel.VERBOSE);\n\n      if (log == null) {\n        return Result.DENY;\n      }\n\n      OperationLog.LoggingLevel currentLoggingMode = log.getOpLoggingLevel();\n      if (currentLoggingMode == OperationLog.LoggingLevel.NONE) {\n        return Result.DENY;\n      }\n      if (currentLoggingMode != loggingMode) {\n        loggingMode = currentLoggingMode;\n        setCurrentNamePattern(loggingMode);\n      }\n\n      boolean isMatch = namePattern.matcher(logEvent.getLoggerName()).matches();\n\n      if (excludeMatches == isMatch) {\n        return Result.DENY;\n      }\n      return Result.NEUTRAL;\n    }",
    "comment": "If logging is disabled, deny everything.\nLook at the current session's setdoAppendting\nand set the pattern and excludeMatches accordingly.\nDeny if this is black-list filter (excludeMatches = true) and it\nmatched\nor if this is whitelist filter and it didn't match"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Float> create(Scope scope, float[][][][] data) {\n    return create(scope, data, Float.class);\n  }",
    "comment": "Creates a rank-4 constant of {@code float} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ResolverFacade.java",
    "type": "method",
    "name": "determineConsumedArgumentCount",
    "code": "int determineConsumedArgumentCount(EvaluatedArgumentSet arguments) {\n\t\tif (this.aggregatorParameters.isEmpty()) {\n\t\t\treturn this.indexedParameterDeclarations.declarationsByIndex.subMap(0,\n\t\t\t\targuments.getConsumedLength()).size();\n\t\t}\n\t\treturn arguments.getTotalLength();\n\t}",
    "comment": "Determine the number of arguments that are considered consumed by the\nparameter declarations in this resolver.\n\n<p>If an aggregator is present, all arguments are considered consumed.\nOtherwise, the consumed argument count, is the number of indexes that\ncorrespond to indexed parameter declarations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/Node.java",
    "type": "method",
    "name": "stream",
    "code": "default Stream<Node> stream() {\n        return Stream.concat(Stream.of(this), getChildren().stream().flatMap(Node::stream));\n    }",
    "comment": "Obtain a Stream containing this node and all its descendants.\n\n@return a stream containing this node and its descendants"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toTitleCase",
    "code": "public UTF8String toTitleCase() {\n    if (numBytes == 0) {\n      return EMPTY_UTF8;\n    }\n\n    return isFullAscii() ? toTitleCaseAscii() : toTitleCaseSlow();\n  }",
    "comment": "Returns the title case of this string, that could be used as title. There are essentially two\ndifferent version of this method - one using the JVM case mapping rules, and the other using\nthe ICU case mapping rules. ASCII implementation is the same for both, but please refer to the\nrespective methods for the slow (non-ASCII) implementation for more details on the differences."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/RuleMemberValidatorTest.java",
    "type": "method",
    "name": "rejectClassRuleThatReturnsImplementationOfMethodRule",
    "code": "public void rejectClassRuleThatReturnsImplementationOfMethodRule() {\n        TestClass target = new TestClass(TestWithClassRuleMethodThatReturnsMethodRule.class);\n        CLASS_RULE_METHOD_VALIDATOR.validate(target, errors);\n        assertOneErrorWithMessage(\"The @ClassRule 'methodRule' must return an implementation of TestRule.\");\n    }",
    "comment": "If there is any method annotated with @ClassRule then it must return an\nimplementation of {@link TestRule}\n\n<p>This case has been added with\n<a href=\"https://github.com/junit-team/junit4/issues/1019\">Issue #1019</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/repository/MavenArtifactRepository.java",
    "type": "method",
    "name": "decode",
    "code": "private static String decode(String url) {\n        String decoded = url;\n        if (url != null) {\n            int pos = -1;\n            while ((pos = decoded.indexOf('%', pos + 1)) >= 0) {\n                if (pos + 2 < decoded.length()) {\n                    String hexStr = decoded.substring(pos + 1, pos + 3);\n                    char ch = (char) Integer.parseInt(hexStr, 16);\n                    decoded = decoded.substring(0, pos) + ch + decoded.substring(pos + 3);\n                }\n            }\n        }\n        return decoded;\n    }",
    "comment": "Decodes the specified (portion of a) URL. <strong>Note:</strong> This decoder assumes that ISO-8859-1 is used to\nconvert URL-encoded bytes to characters.\n\n@param url The URL to decode, may be <code>null</code>.\n@return The decoded URL or <code>null</code> if the input was <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/observer/src/test/java/com/iluwatar/observer/WeatherTest.java",
    "type": "method",
    "name": "testAddRemoveObserver",
    "code": "void testAddRemoveObserver() {\n    final var observer = mock(WeatherObserver.class);\n\n    final var weather = new Weather();\n    weather.addObserver(observer);\n    verifyNoMoreInteractions(observer);\n\n    weather.timePasses();\n    assertEquals(\"The weather changed to rainy.\", appender.getLastMessage());\n    verify(observer).update(WeatherType.RAINY);\n\n    weather.removeObserver(observer);\n    weather.timePasses();\n    assertEquals(\"The weather changed to windy.\", appender.getLastMessage());\n\n    verifyNoMoreInteractions(observer);\n    assertEquals(2, appender.getLogSize());\n  }",
    "comment": "Add a {@link WeatherObserver}, verify if it gets notified of a weather change, remove the\nobserver again and verify that there are no more notifications."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaElementwiseProductExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaElementwiseProductExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    JavaRDD<Vector> data = jsc.parallelize(Arrays.asList(\n      Vectors.dense(1.0, 2.0, 3.0), Vectors.dense(4.0, 5.0, 6.0)));\n    Vector transformingVector = Vectors.dense(0.0, 1.0, 2.0);\n    ElementwiseProduct transformer = new ElementwiseProduct(transformingVector);\n\n    JavaRDD<Vector> transformedData = transformer.transform(data);\n    JavaRDD<Vector> transformedData2 = data.map(transformer::transform);\n\n    System.out.println(\"transformedData: \");\n    transformedData.foreach(System.out::println);\n\n    System.out.println(\"transformedData2: \");\n    transformedData2.foreach(System.out::println);\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\n$example off$\n$example on$\nCreate some vector data; also works for sparse vectors\nBatch transform and per-row transform give the same results:\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/CartController.java",
    "type": "method",
    "name": "addItemToCart",
    "code": "public void addItemToCart(final String userId, final String productId, final int quantity) {\n    shoppingCartUseCase.addItemToCart(userId, productId, quantity);\n  }",
    "comment": "Adds an item to the user's cart.\n\n@param userId The ID of the user.\n@param productId The ID of the product to be added.\n@param quantity The quantity of the product."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/entity/Freighter.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n    return \"Freighter{ \" + super.toString() + \" ,\" + \"flightLength=\" + flightLength + '}';\n  }",
    "comment": "Overridden the toString method to specify the Vehicle object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/SourceRoot.java",
    "type": "method",
    "name": "directory",
    "code": "default Path directory() {\n        return Path.of(\"src\", scope().id(), language().id());\n    }",
    "comment": "{@return the root directory where the sources are stored}.\nThe path is relative to the <abbr>POM</abbr> file.\n\n<h4>Default implementation</h4>\nThe default value is <code>src/{@linkplain #scope() scope}/{@linkplain #language() language}</code>\nas a relative path. Implementation classes may override this default with an absolute path instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/LogicalWriteInfo.java",
    "type": "method",
    "name": "rowIdSchema",
    "code": "default Optional<StructType> rowIdSchema() {\n    throw new SparkUnsupportedOperationException(\n      \"_LEGACY_ERROR_TEMP_3133\", Map.of(\"class\", getClass().getName()));\n  }",
    "comment": "the schema of the ID columns from Spark to data source."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Long> create(long[][] data) {\n    return Tensor.create(data, Long.class);\n  }",
    "comment": "Creates a rank-2 tensor of {@code long} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/resolver/MavenChainedWorkspaceReader.java",
    "type": "method",
    "name": "of",
    "code": "public static WorkspaceReader of(Collection<WorkspaceReader> workspaceReaderCollection) {\n        WorkspaceReader[] readers = workspaceReaderCollection.toArray(new WorkspaceReader[0]);\n        if (readers.length == 1) {\n            return readers[0];\n        }\n        return new MavenChainedWorkspaceReader(readers);\n    }",
    "comment": "chains a collection of {@link WorkspaceReader}s\n@param workspaceReaderCollection the collection of readers, might be empty but never <code>null</code>\n@return if the collection contains only one item returns the single item, otherwise creates a new\n{@link MavenChainedWorkspaceReader} chaining all readers in the order of the given collection."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "if",
    "code": "int count, final int collationId) {\n    if (delimiter.numBytes() == 0 || count == 0 || string.numBytes() == 0) {\n      return UTF8String.EMPTY_UTF8;\n    }\n    String str = string.toValidString();\n    String delim = delimiter.toValidString();\n    StringSearch stringSearch = CollationFactory.getStringSearch(str, delim, collationId);\n    stringSearch.setOverlapping(true);\n    if (count > 0) {\n      int searchIndex = findIndex(stringSearch, count);\n      if (searchIndex == MATCH_NOT_FOUND) {\n        return string;\n      } else if (searchIndex == 0) {\n        return UTF8String.EMPTY_UTF8;\n      } else {\n        return UTF8String.fromString(str.substring(0, searchIndex));\n      }\n    } else {\n      int searchIndex = findIndexReverse(stringSearch, -count);\n      if (searchIndex == MATCH_NOT_FOUND) {\n          return string;\n      } else if (searchIndex == str.length()) {\n          return UTF8String.EMPTY_UTF8;\n      } else {\n          return UTF8String.fromString(str.substring(searchIndex));\n      }\n    }\n  }",
    "comment": "If the count is positive, we search for the count-th delimiter from the left.\nIf the count is negative, we search for the count-th delimiter from the right."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/Main.java",
    "type": "method",
    "name": "handle",
    "code": "protected boolean handle(String opt, String value) {\n      if (CLASS.equals(opt)) {\n        className = value;\n      }\n      return false;\n    }",
    "comment": "A parser used when command line parsing fails for spark-submit. It's used as a best-effort\nat trying to identify the class the user wanted to invoke, since that may require special\nusage strings (handled by SparkSubmitArguments)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "setIsConstant",
    "code": "public final void setIsConstant() {\n    if (childColumns != null) {\n      for (WritableColumnVector c : childColumns) {\n        c.setIsConstant();\n      }\n    }\n    isConstant = true;\n  }",
    "comment": "Marks this column as being constant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/CalendarInterval.java",
    "type": "method",
    "name": "extractAsDuration",
    "code": "public Duration extractAsDuration() { return Duration.of(microseconds, ChronoUnit.MICROS); }",
    "comment": "Extracts the time part of the interval.\n@return an instance of {@code java.time.Duration} based on the microseconds field\nof the given interval, not null.\n@throws ArithmeticException if a numeric overflow occurs"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/DefaultValue.java",
    "type": "method",
    "name": "DefaultValue",
    "code": "public DefaultValue(String sql) {\n    this(sql, null /* no expression */);\n  }",
    "comment": "A class that represents default values.\n<p>\nConnectors can define default values using either a SQL string (Spark SQL dialect) or an\n{@link Expression expression} if the default value can be expressed as a supported connector\nexpression. If both the SQL string and the expression are provided, Spark first attempts to\nconvert the given expression to its internal representation. If the expression cannot be\nconverted, and a SQL string is provided, Spark will fall back to parsing the SQL string.\n\n@since 4.1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginRealmCache.java",
    "type": "method",
    "name": "register",
    "code": "public void register(MavenProject project, Key key, CacheRecord record) {\n    }",
    "comment": "default cache does not track plugin usage"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n\t\t// @formatter:off\n\t\treturn new ToStringBuilder(this)\n\t\t\t\t.append(\"type\", this.type)\n\t\t\t\t.append(\"testDescriptor\", this.testDescriptor)\n\t\t\t\t.append(\"timestamp\", this.timestamp)\n\t\t\t\t.append(\"payload\", this.payload)\n\t\t\t\t.toString();\n\t\t// @formatter:on\n\t}",
    "comment": "Get the payload of the required type.\n\n<p>This is a convenience method that automatically casts the payload to\nthe required type. If the payload is not present or is not of the expected\ntype, this method will throw an {@link IllegalArgumentException}.\n\n@param payloadType the required payload type; never {@code null}\n@return the payload\n@throws IllegalArgumentException if the payload is of a different type\nor is not present\n@see #getPayload()\n@see #getPayload(Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "escapeJson",
    "code": "static String escapeJson(String str) {\n    try (CharArrayWriter writer = new CharArrayWriter();\n         JsonGenerator gen = new JsonFactory().createGenerator(writer)) {\n      throw new RuntimeException(e);\n    }\n  }",
    "comment": "Escape a string so that it can be pasted into JSON structure.\nFor example, if `str` only contains a new-line character, then the result content is \"\\n\"\n(4 characters)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom_Common/java/com/example/android/persistence/migrations/SqliteTestDbOpenHelper.java",
    "type": "method",
    "name": "onDowngrade",
    "code": "public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n    }",
    "comment": "Not required as at version 1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/textui/TestRunner.java",
    "type": "method",
    "name": "runAndWait",
    "code": "static public void runAndWait(Test suite) {\n        TestRunner aTestRunner = new TestRunner();\n        aTestRunner.doRun(suite, true);\n    }",
    "comment": "Runs a single test and waits until the user\ntypes RETURN."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/sasl/ShuffleSecretManager.java",
    "type": "method",
    "name": "getSaslUser",
    "code": "public String getSaslUser(String appId) {\n    return SPARK_SASL_USER;\n  }",
    "comment": "Return the Spark user for authenticating SASL connections."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/AetherDependencyWrapper.java",
    "type": "method",
    "name": "getClassifier",
    "code": "public String getClassifier() {\n        String classifier = dependency.getArtifact().getClassifier();\n        if (classifier.isEmpty()) {\n            classifier = getType().getClassifier();\n            if (classifier == null) {\n                classifier = \"\";\n            }\n        }\n        return classifier;\n    }",
    "comment": "{@return the classifier (\"jar\", \"test-jar\", …) of the wrapped dependency}\nThe default implementation first delegates to the Eclipse Aether artifact.\nIf the latter does not provide a non-empty classifier,\nthen the default value is determined by {@linkplain #getType() type}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/crypto/AuthClientBootstrap.java",
    "type": "method",
    "name": "doBootstrap",
    "code": "public void doBootstrap(TransportClient client, Channel channel) {\n    if (!conf.encryptionEnabled()) {\n      LOG.debug(\"AES encryption disabled, using old auth protocol.\");\n      doSaslAuth(client, channel);\n      return;\n    }\n\n    try {\n      doSparkAuth(client, channel);\n      client.setClientId(appId);\n    } catch (GeneralSecurityException | IOException e) {\n      throw new RuntimeException(e);\n    } catch (RuntimeException e) {\n      if (!conf.saslFallback() || e.getCause() instanceof TimeoutException) {\n        throw e;\n      }\n\n      if (LOG.isDebugEnabled()) {\n        Throwable cause = e.getCause() != null ? e.getCause() : e;\n        LOG.debug(\"New auth protocol failed, trying SASL.\", cause);\n      } else {\n        LOG.info(\"New auth protocol failed, trying SASL.\");\n      }\n      doSaslAuth(client, channel);\n    }\n  }",
    "comment": "There isn't a good exception that can be caught here to know whether it's really\nOK to switch back to SASL (because the server doesn't speak the new protocol). So\ntry it anyway, unless it's a timeout, which is locally fatal. In the worst case\nthings will fail again."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Output.java",
    "type": "method",
    "name": "tensor",
    "code": "public Tensor<T> tensor() {\n    return (Tensor<T>) operation.tensor(index);\n  }",
    "comment": "Returns the tensor at this output.\n\n<p>This operation is only supported on the outputs of an operation executed eagerly. For graph\nenvironments, output tensors must be fetched by running a session, using {@link\nSession.Runner#fetch(Output)}.\n\n@return tensor\n@throws IllegalStateException if this output results from a graph\n@see EagerSession"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/testFixtures/java/org/junit/platform/commons/test/TestClassLoader.java",
    "type": "method",
    "name": "forClasses",
    "code": "public static TestClassLoader forClasses(List<Class<?>> classes) {\n\t\tPredicate<String> classNameFilter = name -> classes.stream().map(Class::getName).anyMatch(name::equals);\n\t\treturn new TestClassLoader(getCodeSourceUrl(stackWalker.getCallerClass()), classNameFilter);\n\t}",
    "comment": "Create a {@link TestClassLoader} that filters the provided classes.\n\n@see #forClasses(Class...)\n@see #forClassNamePrefix(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/AbstractService.java",
    "type": "method",
    "name": "init",
    "code": "public synchronized void init(HiveConf hiveConf) {\n    ensureCurrentState(STATE.NOTINITED);\n    this.hiveConf = hiveConf;\n    changeState(STATE.INITED);\n    LOG.info(\"Service:{} is inited.\", MDC.of(LogKeys.SERVICE_NAME$.MODULE$, getName()));\n  }",
    "comment": "{@inheritDoc}\n\n@throws IllegalStateException\nif the current service state does not permit\nthis action"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/saga/src/main/java/com/iluwatar/saga/orchestration/Service.java",
    "type": "method",
    "name": "process",
    "code": "public ChapterResult<K> process(K value) {\n    LOGGER.info(\n        \"The chapter '{}' has been started. \"\n            + \"The data {} has been stored or calculated successfully\",\n        getName(),\n        value);\n    return ChapterResult.success(value);\n  }",
    "comment": "Common abstraction class representing services. implementing a general contract @see {@link\nOrchestrationChapter}\n\n@param <K> type of incoming param"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/RequestTimeoutIntegrationSuite.java",
    "type": "method",
    "name": "onSuccess",
    "code": "public void onSuccess(ByteBuffer response) {\n      successLength = response.remaining();\n      latch.countDown();\n    }",
    "comment": "Callback which sets 'success' or 'failure' on completion.\nAdditionally notifies all waiters on this callback when invoked."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectFile",
    "code": "public static FileSelector selectFile(File file) {\n\t\treturn selectFile(file, null);\n\t}",
    "comment": "Create a {@code FileSelector} for the supplied {@linkplain File file}.\n\n<p>This method selects the file in its {@linkplain File#getCanonicalPath()\ncanonical} form and throws a {@link PreconditionViolationException} if the\nfile does not exist.\n\n@param file the file to select; never {@code null}\n@see FileSelector\n@see #selectFile(String)\n@see #selectFile(File, FilePosition)\n@see #selectFile(String, FilePosition)\n@see #selectDirectory(String)\n@see #selectDirectory(File)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/Filter.java",
    "type": "method",
    "name": "composeFilters",
    "code": "static <T> Filter<T> composeFilters(Filter<T>... filters) {\n\t\tPreconditions.notNull(filters, \"filters array must not be null\");\n\t\tPreconditions.containsNoNullElements(filters, \"individual filters must not be null\");\n\n\t\tif (filters.length == 0) {\n\t\t\treturn alwaysIncluded();\n\t\t}\n\t\tif (filters.length == 1) {\n\t\t\treturn filters[0];\n\t\t}\n\t\treturn new CompositeFilter<>(asList(filters));\n\t}",
    "comment": "Return a filter that will include elements if and only if all of the\nfilters in the supplied array of {@link Filter filters} include it.\n\n<p>If the array is empty, the returned filter will include all elements\nit is asked to filter.\n\n@param filters the array of filters to compose; never {@code null}\n@see #composeFilters(Collection)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "followedByCasedLetter",
    "code": "private static boolean followedByCasedLetter(UTF8String source, int offset) {\n    // Moving the offset one character forward, so we could start the linear search from there.\n    offset += UTF8String.numBytesForFirstByte(source.getByte(offset));\n    int len = source.numBytes();\n\n    while (offset < len) {\n      int codepoint = source.codePointFrom(offset);\n\n      if (UCharacter.hasBinaryProperty(codepoint, UProperty.CASE_IGNORABLE)) {\n        offset += UTF8String.numBytesForFirstByte(source.getByte(offset));\n        continue;\n      }\n      return UCharacter.hasBinaryProperty(codepoint, UProperty.CASED);\n    }\n    return false;\n  }",
    "comment": "Checks if the character beginning at 'offset'(in 'sources' byte array) is followed by a cased\nletter."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/test/java/org/apache/spark/launcher/SparkSubmitCommandBuilderSuite.java",
    "type": "method",
    "name": "testIsClientMode",
    "code": "public void testIsClientMode() {\n    SparkSubmitCommandBuilder builder = newCommandBuilder(Collections.emptyList());\n    assertTrue(builder.isClientMode(Collections.emptyMap()),\n      \"By default application run in local mode\");\n    List<String> sparkSubmitArgs = Arrays.asList(parser.MASTER, \"yarn\");\n    builder = newCommandBuilder(sparkSubmitArgs);\n    assertTrue(builder.isClientMode(Collections.emptyMap()), \"By default deploy mode is client\");\n    Map<String, String> userProps = new HashMap<>();\n    userProps.put(\"spark.submit.deployMode\", \"client\");\n    assertTrue(builder.isClientMode(userProps));\n  }",
    "comment": "Default master is \"local[*]\"\n--master yarn or it can be any RM\n--master yarn and set spark.submit.deployMode to client"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/throttling/src/main/java/com/iluwatar/throttling/Bartender.java",
    "type": "method",
    "name": "orderDrink",
    "code": "public int orderDrink(BarCustomer barCustomer) {\n    var tenantName = barCustomer.getName();\n    var count = callsCount.getCount(tenantName);\n    if (count >= barCustomer.getAllowedCallsPerSecond()) {\n      LOGGER.error(\"I'm sorry {}, you've had enough for today!\", tenantName);\n      return -1;\n    }\n    callsCount.incrementCount(tenantName);\n    LOGGER.debug(\"Serving beer to {} : [{} consumed] \", barCustomer.getName(), count + 1);\n    return getRandomCustomerId();\n  }",
    "comment": "Orders a drink from the bartender.\n\n@return customer id which is randomly generated"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/timing/TimingExtension.java",
    "type": "method",
    "name": "getStore",
    "code": "private Store getStore(ExtensionContext context) {\n\t\treturn context.getStore(Namespace.create(getClass(), context.getRequiredTestMethod()));\n\t}",
    "comment": "Simple extension that <em>times</em> the execution of test methods and\nlogs the results at {@code INFO} level.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/CollectionUtils.java",
    "type": "method",
    "name": "forEachInReverseOrder",
    "code": "public static <T> void forEachInReverseOrder(List<T> list, Consumer<? super T> action) {\n\t\tif (list.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tif (list.size() == 1) {\n\t\t\taction.accept(list.get(0));\n\t\t\treturn;\n\t\t}\n\t\tfor (ListIterator<T> iterator = list.listIterator(list.size()); iterator.hasPrevious();) {\n\t\t\taction.accept(iterator.previous());\n\t\t}\n\t}",
    "comment": "Call the supplied action on each element of the supplied {@link List} from last to first element."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, char expected, char actual) {\n        assertEquals(message, Character.valueOf(expected), Character.valueOf(actual));\n    }",
    "comment": "Asserts that two chars are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/suite/engine/BeforeAndAfterSuiteTests.java",
    "type": "method",
    "name": "setUp",
    "code": "void setUp() {\n\t\tStatefulTestCase.callSequence = new ArrayList<>();\n\t}",
    "comment": "Integration tests that verify support for {@link BeforeSuite} and {@link AfterSuite},\nin the {@link SuiteTestEngine}.\n\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/InputLocation.java",
    "type": "method",
    "name": "getSource",
    "code": "public InputSource getSource() {\n        return this.source;\n    } // -- InputSource getSource()",
    "comment": "Get the source field.\n\n@return InputSource"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/test/java/org/apache/spark/sql/catalyst/expressions/HiveHasherSuite.java",
    "type": "method",
    "name": "randomizedStressTestPaddedStrings",
    "code": "public void randomizedStressTestPaddedStrings() {\n    int size = 64000;\n    Set<Integer> hashcodes = new HashSet<>();\n    for (int i = 0; i < size; i++) {\n      int byteArrSize = 8;\n      byte[] strBytes = String.valueOf(i).getBytes(StandardCharsets.UTF_8);\n      byte[] paddedBytes = new byte[byteArrSize];\n      System.arraycopy(strBytes, 0, paddedBytes, 0, strBytes.length);\n\n      Assertions.assertEquals(\n          HiveHasher.hashUnsafeBytes(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize),\n          HiveHasher.hashUnsafeBytes(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n\n      hashcodes.add(HiveHasher.hashUnsafeBytes(\n          paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n    }\n\n    Assertions.assertTrue(hashcodes.size() > size * 0.95);\n  }",
    "comment": "A set used to track collision rate.\nA very loose bound."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlob",
    "code": "public static Tensor fromBlob(FloatBuffer data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_BUFFER_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.capacity(), shape);\n    checkArgument(data.isDirect(), ERROR_MSG_DATA_BUFFER_MUST_BE_DIRECT);\n    checkArgument(\n        (data.order() == ByteOrder.nativeOrder()),\n        ERROR_MSG_DATA_BUFFER_MUST_HAVE_NATIVE_BYTE_ORDER);\n    return new Tensor_float32(data, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.float32 with specified shape and data.\n\n@param data Direct buffer with native byte order that contains {@code Tensor.numel(shape)}\nelements. The buffer is used directly without copying, and changes to its content will\nchange the tensor.\n@param shape Tensor shape"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/TensorFlowImageClassifier.java",
    "type": "method",
    "name": "recognizeImage",
    "code": "String outputName) {\n    TensorFlowImageClassifier c = new TensorFlowImageClassifier();\n    c.inputName = inputName;\n    c.outputName = outputName;\n\n    // Read the label names into memory.\n    // TODO(andrewharp): make this handle non-assets.\n    String actualFilename = labelFilename.split(\"file:///android_asset/\")[1];\n    Log.i(TAG, \"Reading labels from: \" + actualFilename);\n    BufferedReader br = null;\n    try {\n      br = new BufferedReader(new InputStreamReader(assetManager.open(actualFilename)));\n      String line;\n      while ((line = br.readLine()) != null) {\n        c.labels.add(line);\n      }\n      br.close();\n    } catch (IOException e) {\n      throw new RuntimeException(\"Problem reading label file!\" , e);\n    }\n\n    c.inferenceInterface = new TensorFlowInferenceInterface(assetManager, modelFilename);\n\n    // The shape of the output is [N, NUM_CLASSES], where N is the batch size.\n    final Operation operation = c.inferenceInterface.graphOperation(outputName);\n    final int numClasses = (int) operation.output(0).shape().size(1);\n    Log.i(TAG, \"Read \" + c.labels.size() + \" labels, output layer size is \" + numClasses);\n\n    // Ideally, inputSize could have been retrieved from the shape of the input operation.  Alas,\n    // the placeholder node for input in the graphdef typically used does not specify a shape, so it\n    // must be passed in as a parameter.\n    c.inputSize = inputSize;\n    c.imageMean = imageMean;\n    c.imageStd = imageStd;\n\n    // Pre-allocate buffers.\n    c.outputNames = new String[] {outputName};\n\n  @Override\n  public List<Recognition> recognizeImage(final Bitmap bitmap) {\n    // Log this method so that it can be analyzed with systrace.\n    Trace.beginSection(\"recognizeImage\");\n\n    Trace.beginSection(\"preprocessBitmap\");\n    // Preprocess the image data from 0-255 int to normalized float based\n    // on the provided parameters.\n    bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());\n    for (int i = 0; i < intValues.length; ++i) {\n      final int val = intValues[i];\n      floatValues[i * 3 + 0] = (((val >> 16) & 0xFF) - imageMean) / imageStd;\n      floatValues[i * 3 + 1] = (((val >> 8) & 0xFF) - imageMean) / imageStd;\n      floatValues[i * 3 + 2] = ((val & 0xFF) - imageMean) / imageStd;\n    }\n    Trace.endSection();\n\n    // Copy the input data into TensorFlow.\n    Trace.beginSection(\"feed\");\n    inferenceInterface.feed(inputName, floatValues, 1, inputSize, inputSize, 3);\n    Trace.endSection();\n\n    // Run the inference call.\n    Trace.beginSection(\"run\");\n    inferenceInterface.run(outputNames, logStats);\n    Trace.endSection();\n\n    // Copy the output Tensor back into the output array.\n    Trace.beginSection(\"fetch\");\n    inferenceInterface.fetch(outputName, outputs);\n    Trace.endSection();\n\n    // Find the best classifications.\n    PriorityQueue<Recognition> pq =\n        new PriorityQueue<Recognition>(\n            3,\n            new Comparator<Recognition>() {\n            });\n    for (int i = 0; i < outputs.length; ++i) {\n      if (outputs[i] > THRESHOLD) {\n        pq.add(\n            new Recognition(\n                \"\" + i, labels.size() > i ? labels.get(i) : \"unknown\", outputs[i], null));\n      }\n    }\n    final ArrayList<Recognition> recognitions = new ArrayList<Recognition>();\n    int recognitionsSize = Math.min(pq.size(), MAX_RESULTS);\n    for (int i = 0; i < recognitionsSize; ++i) {\n      recognitions.add(pq.poll());\n    }\n    Trace.endSection(); // \"recognizeImage\"\n    return recognitions;\n  }\n\n  @Override\n  public void enableStatLogging(boolean logStats) {\n    this.logStats = logStats;\n  }\n\n  @Override\n  public String getStatString() {\n    return inferenceInterface.getStatString();\n  }\n\n  @Override\n  public void close() {\n    inferenceInterface.close();\n  }\n}",
    "comment": "Initializes a native TensorFlow session for classifying images.\n\n@param assetManager The asset manager to be used to load assets.\n@param modelFilename The filepath of the model GraphDef protocol buffer.\n@param labelFilename The filepath of label file for classes.\n@param inputSize The input size. A square image of inputSize x inputSize is assumed.\n@param imageMean The assumed mean of the image values.\n@param imageStd The assumed std of the image values.\n@param inputName The label of the image input node.\n@param outputName The label of the output node.\n@throws IOException"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "fail",
    "code": "public static <V> V fail(Supplier<String> messageSupplier) {\n\t\tAssertionUtils.fail(messageSupplier);\n\t\treturn null; // appeasing the compiler: this line will never be executed.\n\t}",
    "comment": "<em>Fail</em> the test with the failure message retrieved from the\ngiven {@code messageSupplier}.\n\n<p>See Javadoc for {@link #fail(String)} for an explanation of this method's\ngeneric return type {@code V}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "fileEntry",
    "code": "public static Condition<Event> fileEntry(Predicate<FileEntry> predicate) {\n\t\treturn new Condition<>(byPayload(FileEntry.class, predicate), \"event for file entry with custom predicate\");\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link FileEntry} that contains a file that matches the supplied\n{@link Predicate}.\n\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/builder/BuilderCommon.java",
    "type": "method",
    "name": "getKey",
    "code": "public static String getKey(MavenProject project) {\n        return project.getGroupId() + ':' + project.getArtifactId() + ':' + project.getVersion();\n    }",
    "comment": "TODO I'm really wondering where this method belongs; smells like it should be on MavenProject, but for some\nreason it isn't ? This localization is kind-of a code smell."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/separated-interface/src/main/java/com/iluwatar/separatedinterface/invoice/InvoiceGenerator.java",
    "type": "method",
    "name": "InvoiceGenerator",
    "code": "public record InvoiceGenerator(double amount, TaxCalculator taxCalculator) {\n  public double getAmountWithTax() {\n    return amount + taxCalculator.calculate(amount);\n  }\n}",
    "comment": "TaxCalculator description: The TaxCalculator interface to calculate the payable tax. Amount\ndescription: The base product amount without tax."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/RuleMemberValidatorTest.java",
    "type": "method",
    "name": "arbitraryObject",
    "code": "public static Object arbitraryObject() {\n            return 1;\n        }",
    "comment": "If there is any method annotated with @ClassRule then it must return an\nimplementation of {@link TestRule}\n\n<p>This case has been added with\n<a href=\"https://github.com/junit-team/junit4/issues/1019\">Issue #1019</a>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Integer> create(int[] data) {\n    return Tensor.create(data, Integer.class);\n  }",
    "comment": "Creates a rank-1 tensor of {@code int} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/map-reduce/src/main/java/com/iluwatar/MapReduce.java",
    "type": "method",
    "name": "MapReduce",
    "code": "private MapReduce() {\n    throw new UnsupportedOperationException(\n        \"MapReduce is a utility class and cannot be instantiated.\");\n  }",
    "comment": "The MapReduce class orchestrates the MapReduce process, calling the Mapper, Shuffler, and Reducer\ncomponents."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TerminationInfo.java",
    "type": "method",
    "name": "skipped",
    "code": "public static TerminationInfo skipped(String reason) {\n\t\treturn new TerminationInfo(true, reason, null);\n\t}",
    "comment": "Create a <em>skipped</em> {@code TerminationInfo} instance for the\nsupplied reason.\n\n@param reason the reason the execution was skipped; may be {@code null}\n@return the created {@code TerminationInfo}; never {@code null}\n@see #executed(TestExecutionResult)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultSourceRoot.java",
    "type": "method",
    "name": "nonBlank",
    "code": "private static String nonBlank(String value) {\n        if (value != null) {\n            value = value.trim();\n            if (value.isBlank()) {\n                value = null;\n            }\n        }\n        return value;\n    }",
    "comment": "{@return the given value as a trimmed non-blank string, or null otherwise}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/SerializableMatcherDescription.java",
    "type": "method",
    "name": "asSerializableMatcher",
    "code": "static <T> Matcher<T> asSerializableMatcher(Matcher<T> matcher) {\n        if (matcher == null || matcher instanceof Serializable) {\n            return matcher;\n        } else {\n            return new SerializableMatcherDescription<T>(matcher);\n        }\n    }",
    "comment": "Factory method that checks to see if the matcher is already serializable.\n@param matcher the matcher to make serializable\n@return The provided matcher if it is null or already serializable,\nthe SerializableMatcherDescription representation of it if it is not."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/EvaluatedArgumentSet.java",
    "type": "method",
    "name": "allOf",
    "code": "static EvaluatedArgumentSet allOf(Arguments arguments) {\n\t\tObject[] all = arguments.get();\n\t\treturn create(all, all, arguments);\n\t}",
    "comment": "Encapsulates the evaluation of an {@link Arguments} instance (so it happens\nonly once) and access to the resulting argument values.\n\n<p>The provided accessor methods are focused on the different use cases and\nmake it less error-prone to access the argument values.\n\n@since 5.13"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "reportingEntryPublished",
    "code": "public static Event reportingEntryPublished(TestDescriptor testDescriptor, ReportEntry entry) {\n\t\tPreconditions.notNull(entry, \"ReportEntry must not be null\");\n\t\treturn new Event(EventType.REPORTING_ENTRY_PUBLISHED, testDescriptor, entry);\n\t}",
    "comment": "Create an {@code Event} for a reporting entry published for the\nsupplied {@link TestDescriptor} and {@link ReportEntry}.\n\n@param testDescriptor the {@code TestDescriptor} associated with the event;\nnever {@code null}\n@param entry the {@code ReportEntry} that was published; never {@code null}\n@return the newly created {@code Event}\n@see EventType#REPORTING_ENTRY_PUBLISHED"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/androidTest/java/com/example/android/observability/persistence/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "deleteAndGetUser",
    "code": "public void deleteAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER).blockingAwait();\n\n        mDataSource.deleteAllUsers();\n        mDatabase.userDao().getUser()\n                .test()\n                .assertNoValues();\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are deleting all users\nWhen subscribing to the emissions of the user\ncheck that there's no user emitted"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineExecutionResults.java",
    "type": "method",
    "name": "filterEvents",
    "code": "private static Stream<Event> filterEvents(List<Event> events, Predicate<? super TestDescriptor> predicate) {\n\t\treturn events.stream().filter(byTestDescriptor(predicate));\n\t}",
    "comment": "Filter the supplied list of events using the supplied predicate."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlanExecutor.java",
    "type": "method",
    "name": "mojoExecutionConfigurator",
    "code": "private MojoExecutionConfigurator mojoExecutionConfigurator(MojoExecution mojoExecution) {\n        String configuratorId = mojoExecution.getMojoDescriptor().getComponentConfigurator();\n        if (configuratorId == null) {\n            configuratorId = \"default\";\n        }\n\n        MojoExecutionConfigurator mojoExecutionConfigurator = mojoExecutionConfigurators.get(configuratorId);\n\n        if (mojoExecutionConfigurator == null) {\n            mojoExecutionConfigurator = mojoExecutionConfigurators.get(\"default\");\n        }\n        return mojoExecutionConfigurator;\n    }",
    "comment": "The plugin has a custom component configurator but does not have a custom mojo execution configurator\nso fall back to the default mojo execution configurator."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/ClassMap.java",
    "type": "method",
    "name": "getAccessibleMethods",
    "code": "private static int getAccessibleMethods(Class<?> clazz, MethodInfo[] methodInfos, int upcastCount) {\n        int l = methodInfos.length;\n\n        // if this class is public, then check each of the currently\n        // 'non-upcasted' methods to see if we have a match\n        if (Modifier.isPublic(clazz.getModifiers())) {\n            for (int i = 0; i < l && upcastCount < l; ++i) {\n                try {\n                    MethodInfo methodInfo = methodInfos[i];\n                    if (!methodInfo.upcast) {\n                        methodInfo.tryUpcasting(clazz);\n                        upcastCount++;\n                    }\n                } catch (NoSuchMethodException e) {\n                    // Intentionally ignored - it means it wasn't found in the current class\n                }\n            }\n\n            /*\n             *  Short circuit if all methods were upcast\n             */\n\n            if (upcastCount == l) {\n                return upcastCount;\n            }\n        }\n\n        // Examine superclass\n        Class<?> superclazz = clazz.getSuperclass();\n        if (superclazz != null) {\n            upcastCount = getAccessibleMethods(superclazz, methodInfos, upcastCount);\n\n            // Short circuit if all methods were upcast\n            if (upcastCount == l) {\n                return upcastCount;\n            }\n        }\n\n        // Examine interfaces. Note we do it even if superclazz == null.\n        // This is redundant as currently java.lang.Object does not implement\n        // any interfaces, however nothing guarantees it will not in the future.\n        Class<?>[] interfaces = clazz.getInterfaces();\n        for (int i = interfaces.length; i-- > 0; ) {\n            upcastCount = getAccessibleMethods(interfaces[i], methodInfos, upcastCount);\n\n            // Short circuit if all methods were upcast\n            if (upcastCount == l) {\n                return upcastCount;\n            }\n        }\n\n        return upcastCount;\n    }",
    "comment": "Recursively finds a match for each method, starting with the class, and then\nsearching the superclass and interfaces.\n\n@param clazz       Class to check\n@param methodInfos array of methods we are searching to match\n@param upcastCount current number of methods we have matched\n@return count of matched methods"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/builder/multithreaded/ConcurrencyDependencyGraph.java",
    "type": "method",
    "name": "getSchedulableNewProcesses",
    "code": "private List<MavenProject> getSchedulableNewProcesses(MavenProject finishedProject) {\n        List<MavenProject> result = new ArrayList<>();\n        for (MavenProject dependentProject : projectDependencyGraph.getDownstreamProjects(finishedProject, false)) {\n            final List<MavenProject> upstreamProjects =\n                    projectDependencyGraph.getUpstreamProjects(dependentProject, false);\n            if (finishedProjects.containsAll(upstreamProjects)) {\n                result.add(dependentProject);\n            }\n        }\n        return result;\n    }",
    "comment": "schedule dependent projects, if all of their requirements are met"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room3/java/com/example/android/persistence/migrations/UsersDatabase.java",
    "type": "method",
    "name": "Migration",
    "code": "static final Migration MIGRATION_1_2 = new Migration(1, 2) {\n    };",
    "comment": "Migrate from:\nversion 1 - using the SQLiteDatabase API\nto\nversion 2 - using Room"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "public ArtifactResolutionResult resolve(ArtifactResolutionRequest request) {\n        Artifact rootArtifact = request.getArtifact();\n        Set<Artifact> artifacts = request.getArtifactDependencies();\n        Map<String, Artifact> managedVersions = request.getManagedVersionMap();\n        List<ResolutionListener> listeners = request.getListeners();\n        ArtifactFilter collectionFilter = request.getCollectionFilter();\n        ArtifactFilter resolutionFilter = request.getResolutionFilter();\n        RepositorySystemSession session = getSession(request.getLocalRepository());\n\n        if (source == null) {\n            try {\n                source = container.lookup(ArtifactMetadataSource.class);\n            } catch (ComponentLookupException e) {\n            }\n        }\n\n        if (listeners == null) {\n            listeners = new ArrayList<>();\n\n            if (logger.isDebugEnabled()) {\n                listeners.add(new DebugResolutionListener(logger));\n            }\n\n            listeners.add(new WarningResolutionListener(logger));\n        }\n\n        ArtifactResolutionResult result = new ArtifactResolutionResult();\n\n\n        if (request.isResolveRoot() /* && rootArtifact.getFile() == null */) {\n            try {\n                resolve(rootArtifact, request.getRemoteRepositories(), session);\n            } catch (ArtifactResolutionException e) {\n                result.addErrorArtifactException(e);\n                return result;\n            } catch (ArtifactNotFoundException e) {\n                result.addMissingArtifact(request.getArtifact());\n                return result;\n            }\n        }\n\n        ArtifactResolutionRequest collectionRequest = request;\n\n        if (request.isResolveTransitively()) {\n            MetadataResolutionRequest metadataRequest = new DefaultMetadataResolutionRequest(request);\n\n            metadataRequest.setArtifact(rootArtifact);\n            metadataRequest.setResolveManagedVersions(managedVersions == null);\n\n            try {\n                ResolutionGroup resolutionGroup = source.retrieve(metadataRequest);\n\n                if (managedVersions == null) {\n                    managedVersions = resolutionGroup.getManagedVersions();\n                }\n\n                Set<Artifact> directArtifacts = resolutionGroup.getArtifacts();\n\n                if (artifacts == null || artifacts.isEmpty()) {\n                    artifacts = directArtifacts;\n                } else {\n                    List<Artifact> allArtifacts = new ArrayList<>();\n                    allArtifacts.addAll(artifacts);\n                    allArtifacts.addAll(directArtifacts);\n\n                    Map<String, Artifact> mergedArtifacts = new LinkedHashMap<>();\n                    for (Artifact artifact : allArtifacts) {\n                        String conflictId = artifact.getDependencyConflictId();\n                        if (!mergedArtifacts.containsKey(conflictId)) {\n                            mergedArtifacts.put(conflictId, artifact);\n                        }\n                    }\n\n                    artifacts = new LinkedHashSet<>(mergedArtifacts.values());\n                }\n\n                collectionRequest = new ArtifactResolutionRequest(request);\n                collectionRequest.setServers(request.getServers());\n                collectionRequest.setMirrors(request.getMirrors());\n                collectionRequest.setProxies(request.getProxies());\n                collectionRequest.setRemoteRepositories(resolutionGroup.getResolutionRepositories());\n            } catch (ArtifactMetadataRetrievalException e) {\n                ArtifactResolutionException are = new ArtifactResolutionException(\n                        \"Unable to get dependency information for \" + rootArtifact.getId() + \": \" + e.getMessage(),\n                        rootArtifact,\n                        metadataRequest.getRemoteRepositories(),\n                        e);\n                result.addMetadataResolutionException(are);\n                return result;\n            }\n        }\n\n        if (artifacts == null || artifacts.isEmpty()) {\n            if (request.isResolveRoot()) {\n                result.addArtifact(rootArtifact);\n            }\n            return result;\n        }\n\n        result = artifactCollector.collect(\n                artifacts, rootArtifact, managedVersions, collectionRequest, source, collectionFilter, listeners, null);\n\n\n        if (result.hasMetadataResolutionExceptions()\n                || result.hasVersionRangeViolations()\n                || result.hasCircularDependencyExceptions()) {\n            return result;\n        }\n\n        if (result.getArtifactResolutionNodes() != null) {\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\n            CountDownLatch latch =\n                    new CountDownLatch(result.getArtifactResolutionNodes().size());\n\n            for (ResolutionNode node : result.getArtifactResolutionNodes()) {\n                Artifact artifact = node.getArtifact();\n\n                if (resolutionFilter == null || resolutionFilter.include(artifact)) {\n                    executor.execute(new ResolveTask(\n                            classLoader, latch, artifact, session, node.getRemoteRepositories(), result));\n                } else {\n                    latch.countDown();\n                }\n            }\n            try {\n                latch.await();\n            } catch (InterruptedException e) {\n                result.addErrorArtifactException(\n                        new ArtifactResolutionException(\"Resolution interrupted\", rootArtifact, e));\n            }\n        }\n\n        if (request.isResolveRoot()) {\n            Set<Artifact> allArtifacts = new LinkedHashSet<>();\n            allArtifacts.add(rootArtifact);\n            allArtifacts.addAll(result.getArtifacts());\n            result.setArtifacts(allArtifacts);\n        }\n\n        return result;\n    }",
    "comment": "This is required by the surefire plugin\nWe have collected all the problems so let's mimic the way the old code worked and just blow up right here.\nThat's right lets just let it rip right here and send a big incomprehensible blob of text at unsuspecting\nusers. Bad dog!\n------------------------------------------------------------------------\n\n------------------------------------------------------------------------\nTODO: hack because metadata isn't generated in m2e correctly and i want to run the maven i have in the\nworkspace\nwon't happen\nThe root artifact may, or may not be resolved so we need to check before we attempt to resolve.\nThis is often an artifact like a POM that is taken from disk and we already have hold of the\nfile reference. But this may be a Maven Plugin that we need to resolve from a remote repository\nas well as its dependencies.\nAfter the collection we will have the artifact object in the result but they will not be resolved yet.\nWe have metadata retrieval problems, or there are cycles that have been detected\nso we give this back to the calling code and let them deal with this information\nappropriately.\nWe want to send the root artifact back in the result but we need to do this after the other dependencies\nhave been resolved.\nAdd the root artifact (as the first artifact to retain logical order of class path!)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/exception/DefaultExceptionHandler.java",
    "type": "method",
    "name": "getMessage",
    "code": "private String getMessage(String message, Throwable exception) {\n        String fullMessage = (message != null) ? message : \"\";\n\n        Set<Throwable> dejaVu = Collections.newSetFromMap(new IdentityHashMap<>());\n        for (Throwable t = exception; t != null && t != t.getCause(); t = t.getCause()) {\n            String exceptionMessage = t.getMessage();\n            String longMessage = null;\n\n            if (t instanceof AbstractMojoExecutionException abstractMojoExecutionException) {\n                longMessage = abstractMojoExecutionException.getLongMessage();\n            } else if (t instanceof MojoException mojoException) {\n                longMessage = mojoException.getLongMessage();\n            }\n\n            if (longMessage != null && !longMessage.isEmpty()) {\n                if ((exceptionMessage == null || exceptionMessage.isEmpty())\n                        || longMessage.contains(exceptionMessage)) {\n                    exceptionMessage = longMessage;\n                } else if (!exceptionMessage.contains(longMessage)) {\n                    exceptionMessage = join(exceptionMessage, System.lineSeparator() + longMessage);\n                }\n            }\n\n            if (exceptionMessage == null || exceptionMessage.isEmpty()) {\n                exceptionMessage = t.getClass().getSimpleName();\n            }\n\n            if (t instanceof UnknownHostException && !fullMessage.contains(\"host\")) {\n                fullMessage = join(fullMessage, \"Unknown host \" + exceptionMessage);\n            } else if (!fullMessage.contains(exceptionMessage)) {\n                fullMessage = join(fullMessage, exceptionMessage);\n            }\n\n            if (!dejaVu.add(t)) {\n                fullMessage = join(fullMessage, \"[CIRCULAR REFERENCE]\");\n                break;\n            }\n        }\n\n        return fullMessage.trim();\n    }",
    "comment": "To break out of possible endless loop when getCause returns \"this\", or dejaVu for n-level recursion (n>1)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/gpu/java/src/main/java/org/tensorflow/lite/gpu/GpuDelegateNative.java",
    "type": "method",
    "name": "init",
    "code": "static void init() {\n    if (isInit) {\n      return;\n    }\n\n    try {\n      // Try to invoke a native method (which itself does nothing) to ensure that native libs are\n      // available.\n      // This code is thread safe without synchronization, as multiple concurrent callers will\n      // either throw an exception without setting this value or set it to true several times.\n      nativeDoNothing();\n      isInit = true;\n    } catch (UnsatisfiedLinkError originalUnsatisfiedLinkError) {\n      // Prefer logging the original library loading exception if native methods are unavailable.\n      Throwable exceptionToLog =\n          LOAD_LIBRARY_EXCEPTION != null ? LOAD_LIBRARY_EXCEPTION : originalUnsatisfiedLinkError;\n      UnsatisfiedLinkError exceptionToThrow =\n          new UnsatisfiedLinkError(\n              \"Failed to load native GpuDelegate methods. Check that the correct native\"\n                  + \" libraries are present, and, if using a custom native library, have been\"\n                  + \" properly loaded via System.loadLibrary():\\n\"\n                  + \"  \"\n                  + exceptionToLog);\n      exceptionToThrow.initCause(originalUnsatisfiedLinkError);\n      exceptionToThrow.addSuppressed(exceptionToLog);\n      throw exceptionToThrow;\n    }\n  }",
    "comment": "Ensure the GpuDelegate native library has been loaded.\n\n<p>If unsuccessful, throws an UnsatisfiedLinkError with the appropriate error message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/superpom/DefaultSuperPomProvider.java",
    "type": "method",
    "name": "setModelProcessor",
    "code": "public DefaultSuperPomProvider setModelProcessor(ModelProcessor modelProcessor) {\n        this.modelProcessor = modelProcessor;\n        return this;\n    }",
    "comment": "The cached super POM, lazily created."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(float unexpected, float actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expressions.java",
    "type": "method",
    "name": "sort",
    "code": "public static SortOrder sort(Expression expr, SortDirection direction, NullOrdering nullOrder) {\n    return LogicalExpressions.sort(expr, direction, nullOrder);\n  }",
    "comment": "Create a sort expression.\n\n@param expr an expression to produce values to sort\n@param direction direction of the sort\n@param nullOrder null order of the sort\n@return a SortOrder\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(float unexpected, float actual, float delta) {\n        assertNotEquals(null, unexpected, actual, delta);\n    }",
    "comment": "Asserts that two floats are <b>not</b> equal to within a positive delta.\nIf they are, an {@link AssertionError} is thrown. If the unexpected\nvalue is infinity then the delta value is ignored.NaNs are considered\nequal: <code>assertNotEquals(Float.NaN, Float.NaN, *)</code> fails\n\n@param unexpected unexpected value\n@param actual the value to check against <code>unexpected</code>\n@param delta the maximum delta between <code>unexpected</code> and\n<code>actual</code> for which both numbers are still\nconsidered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/LogicalWriteInfo.java",
    "type": "method",
    "name": "metadataSchema",
    "code": "default Optional<StructType> metadataSchema() {\n    throw new SparkUnsupportedOperationException(\n      \"_LEGACY_ERROR_TEMP_3134\", Map.of(\"class\", getClass().getName()));\n  }",
    "comment": "the schema of the input metadata from Spark to data source."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/iterator/src/main/java/com/iluwatar/iterator/bst/TreeNode.java",
    "type": "method",
    "name": "insert",
    "code": "public void insert(T valToInsert) {\n    var parent = getParentNodeOfValueToBeInserted(valToInsert);\n    parent.insertNewChild(valToInsert);\n  }",
    "comment": "Inserts new TreeNode based on a given value into the subtree represented by self.\n\n@param valToInsert The value to insert as a new TreeNode"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/internal/compat/interactivity/LegacyPlexusInteractivity.java",
    "type": "method",
    "name": "LegacyPlexusInteractivity",
    "code": "public LegacyPlexusInteractivity(org.apache.maven.api.services.Prompter prompter) {\n        this.prompter = prompter;\n    }",
    "comment": "This class is injected into any legacy component that would want to use legacy \"Plexus Interactivity API\".\nIt simply delegates to Maven4 API {@link org.apache.maven.api.services.Prompter}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/JUnitCore.java",
    "type": "method",
    "name": "run",
    "code": "public Result run(Runner runner) {\n        Result result = new Result();\n        RunListener listener = result.createListener();\n        notifier.addFirstListener(listener);\n        try {\n            notifier.fireTestRunStarted(runner.getDescription());\n            runner.run(notifier);\n            notifier.fireTestRunFinished(result);\n        } finally {\n            removeListener(listener);\n        }\n        return result;\n    }",
    "comment": "Do not use. Testing purposes only."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ForkJoinPoolHierarchicalTestExecutorService.java",
    "type": "method",
    "name": "submit",
    "code": "public Future<Void> submit(TestTask testTask) {\n\t\tExclusiveTask exclusiveTask = new ExclusiveTask(testTask);\n\t\tif (!isAlreadyRunningInForkJoinPool()) {\n\t\t\treturn forkJoinPool.submit(exclusiveTask);\n\t\t}\n\t\tif (testTask.getExecutionMode() == CONCURRENT && ForkJoinTask.getSurplusQueuedTaskCount() < parallelism) {\n\t\t\treturn exclusiveTask.fork();\n\t\t}\n\t\texclusiveTask.execSync();\n\t\treturn completedFuture(null);\n\t}",
    "comment": "ensure we're running inside the ForkJoinPool so we\ncan use ForkJoinTask API in invokeAll etc.\nLimit the amount of queued work so we don't consume dynamic tests too eagerly\nby forking only if the current worker thread's queue length is below the\ndesired parallelism. This optimistically assumes that the already queued tasks\ncan be stolen by other workers and the new task requires about the same\nexecution time as the already queued tasks. If the other workers are busy,\nthe parallelism is already at its desired level. If all already queued tasks\ncan be stolen by otherwise idle workers and the new task takes significantly\nlonger, parallelism will drop. However, that only happens if the enclosing test\ntask is the only one remaining which should rarely be the case."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/TestManagedBuffer.java",
    "type": "method",
    "name": "TestManagedBuffer",
    "code": "public TestManagedBuffer(int len) {\n    Preconditions.checkArgument(len <= Byte.MAX_VALUE);\n    this.len = len;\n    byte[] byteArray = new byte[len];\n    for (int i = 0; i < len; i ++) {\n      byteArray[i] = (byte) i;\n    }\n    this.underlying = new NettyManagedBuffer(Unpooled.wrappedBuffer(byteArray));\n  }",
    "comment": "A ManagedBuffer implementation that contains 0, 1, 2, 3, ..., (len-1).\n\nUsed for testing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/ConstantColumnVector.java",
    "type": "method",
    "name": "setCalendarInterval",
    "code": "public void setCalendarInterval(CalendarInterval value) {\n    this.childData[0].setInt(value.months);\n    this.childData[1].setInt(value.days);\n    this.childData[2].setLong(value.microseconds);\n  }",
    "comment": "Sets the CalendarInterval `value` for all rows"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/MavenExecutionPlan.java",
    "type": "method",
    "name": "getNonThreadSafePlugins",
    "code": "public Set<Plugin> getNonThreadSafePlugins() {\n        Set<Plugin> plugins = new HashSet<>();\n        for (ExecutionPlanItem executionPlanItem : planItem) {\n            final MojoExecution mojoExecution = executionPlanItem.getMojoExecution();\n            if (!mojoExecution.getMojoDescriptor().isThreadSafe()) {\n                plugins.add(mojoExecution.getPlugin());\n            }\n        }\n        return plugins;\n    }",
    "comment": "Get set of plugins having a goal/mojo used but not marked @threadSafe\n\n@return the set of plugins (without info on which goal is concerned)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/PathType.java",
    "type": "method",
    "name": "PathType",
    "code": "PathType UNRESOLVED = new PathType() {\n\n        @Override\n        public String id() {\n            return \"UNRESOLVED\";\n        }\n\n        @Override\n        public Optional<String> option() {\n            return Optional.empty();\n        }\n\n        @Override\n        public String[] option(Iterable<? extends Path> paths) {\n            return new String[0];\n        }\n    };",
    "comment": "The type for all paths that could not be placed in any of the types requested by a caller.\nThis type can appear in the return value of a call to\n{@link Session#resolveDependencies resolveDependencies(...)} when at least one dependency\ncannot be associated to any type specified in the {@code desiredTypes} argument.\nPlugins can choose to report a warning to users when unresolved paths exist."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/gen/java/org/tensorflow/processor/OperatorProcessor.java",
    "type": "method",
    "name": "buildOpMethodJavadoc",
    "code": "private String buildOpMethodJavadoc(ClassName opClassName, ExecutableElement factoryMethod) {\n    StringBuilder javadoc = new StringBuilder();\n    javadoc.append(\"Builds an {@link \").append(opClassName.simpleName()).append(\"} operation\\n\\n\");\n\n    Matcher tagMatcher = JAVADOC_TAG_PATTERN.matcher(elements.getDocComment(factoryMethod));\n    boolean firstParam = true;\n\n    while (tagMatcher.find()) {\n      String tag = tagMatcher.group();\n      if (tag.startsWith(\"@param\") && firstParam) {\n        firstParam = false;\n      } else {\n        javadoc.append(tag).append('\\n');\n      }\n    }\n    javadoc.append(\"@see \").append(opClassName).append(\"\\n\");\n\n    return javadoc.toString();\n  }",
    "comment": "Add all javadoc tags found in the operator factory method but the first one, which should be\nin all cases the\n'scope' parameter that is implicitly passed by this API"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "toString",
    "code": "public String toString() {\n        return getName() + \"(\" + getClass().getName() + \")\";\n    }",
    "comment": "Returns a string representation of the test case."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-bus/src/main/java/com/iluwatar/databus/DataBus.java",
    "type": "method",
    "name": "getInstance",
    "code": "public static DataBus getInstance() {\n    return INSTANCE;\n  }",
    "comment": "The Data-Bus implementation.\n\n<p>This implementation uses a Singleton."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-aggregator/src/test/java/com/iluwatar/event/aggregator/EventEmitterTest.java",
    "type": "method",
    "name": "testAllDaysWithDefaultObserver",
    "code": "private void testAllDaysWithDefaultObserver(final Weekday specialDay, final Event event) {\n    final var defaultObserver = mock(EventObserver.class);\n    final var observer1 = mock(EventObserver.class);\n    final var observer2 = mock(EventObserver.class);\n\n    final var emitter = this.factoryWithDefaultObserver.apply(defaultObserver, event);\n    emitter.registerObserver(observer1, event);\n    emitter.registerObserver(observer2, event);\n\n    testAllDays(specialDay, event, emitter, defaultObserver, observer1, observer2);\n  }",
    "comment": "Go over every day of the month, and check if the event is emitted on the given day.\n\n@param specialDay The special day on which an event is emitted\n@param event The expected event emitted by the test object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "getLowercaseDict",
    "code": "private static Map<Integer, String> getLowercaseDict(final Map<String, String> dict) {\n    // Replace all the keys in the dict with lowercased code points.\n    Map<Integer, String> lowercaseDict = new HashMap<>();\n    for (Map.Entry<String, String> entry : dict.entrySet()) {\n      int codePoint = entry.getKey().codePointAt(0);\n      lowercaseDict.putIfAbsent(getLowercaseCodePoint(codePoint), entry.getValue());\n    }\n    return lowercaseDict;\n  }",
    "comment": "Converts the original translation dictionary (`dict`) to a dictionary with lowercased keys.\nThis method is used to create a dictionary that can be used for the UTF8_LCASE collation.\nNote that `StringTranslate.buildDict` will ensure that all strings are validated properly.\n\nThe method returns a map with lowercased code points as keys, while the values remain\nunchanged. Note that `dict` is constructed on a character by character basis, and the\noriginal keys are stored as strings. Keys in the resulting lowercase dictionary are stored\nas integers, which correspond only to single characters from the original `dict`. Also,\nthere is special handling for the Turkish dotted uppercase letter I (U+0130)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/IValue.java",
    "type": "method",
    "name": "IValue",
    "code": "private IValue(int typeCode) {\n    this.mTypeCode = typeCode;\n  }",
    "comment": "Java representation of a TorchScript value, which is implemented as tagged union that can be one\nof the supported types: https://pytorch.org/docs/stable/jit.html#types .\n\n<p>Calling {@code toX} methods for inappropriate types will throw {@link IllegalStateException}.\n\n<p>{@code IValue} objects are constructed with {@code IValue.from(value)}, {@code\nIValue.tupleFrom(value1, value2, ...)}, {@code IValue.listFrom(value1, value2, ...)}, or one of\nthe {@code dict} methods, depending on the key type.\n\n<p>Data is retrieved from {@code IValue} objects with the {@code toX()} methods. Note that {@code\nstr}-type IValues must be extracted with {@link #toStr()}, rather than {@link #toString()}.\n\n<p>{@code IValue} objects may retain references to objects passed into their constructors, and\nmay return references to their internal state from {@code toX()}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Integer> create(int[][][][][] data) {\n    return Tensor.create(data, Integer.class);\n  }",
    "comment": "Creates a rank-5 tensor of {@code int} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-transfer-object/src/main/java/com/iluwatar/datatransfer/customer/CustomerResource.java",
    "type": "method",
    "name": "CustomerResource",
    "code": "public record CustomerResource(List<CustomerDto> customers) {\n  public void save(CustomerDto customer) {\n    customers.add(customer);\n  }\n\n  public void delete(String customerId) {\n    customers.removeIf(customer -> customer.id().equals(customerId));\n  }\n}",
    "comment": "Delete customer with given id.\n\n@param customerId delete customer with id {@code customerId}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Long> create(long[][][][][] data) {\n    return Tensor.create(data, Long.class);\n  }",
    "comment": "Creates a rank-5 tensor of {@code long} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedDeltaByteArrayReader.java",
    "type": "method",
    "name": "setPreviousReader",
    "code": "public void setPreviousReader(ValuesReader reader) {\n    if (reader != null) {\n      this.previous = ((VectorizedDeltaByteArrayReader) reader).previous;\n    }\n  }",
    "comment": "There was a bug (PARQUET-246) in which DeltaByteArrayWriter's reset() method did not clear the\nprevious value state that it tracks internally. This resulted in the first value of all pages\n(except for the first page) to be a delta from the last value of the previous page. In order to\nread corrupted files written with this bug, when reading a new page we need to recover the\nprevious page's last value to use it (if needed) to read the first value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TestName.java",
    "type": "method",
    "name": "starting",
    "code": "protected void starting(Description d) {\n        name = d.getMethodName();\n    }",
    "comment": "The TestName Rule makes the current test name available inside test methods:\n\n<pre>\npublic class TestNameTest {\n&#064;Rule\npublic TestName name= new TestName();\n\n&#064;Test\npublic void testA() {\nassertEquals(&quot;testA&quot;, name.getMethodName());\n}\n\n&#064;Test\npublic void testB() {\nassertEquals(&quot;testB&quot;, name.getMethodName());\n}\n}\n</pre>\n\n@since 4.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(float unexpected, Float actual) {\n\t\tAssertNotEquals.assertNotEquals((Float) unexpected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterExpressionEvaluatorV4.java",
    "type": "method",
    "name": "PluginParameterExpressionEvaluatorV4",
    "code": "public PluginParameterExpressionEvaluatorV4(Session session, Project project) {\n        this(session, project, null);\n    }",
    "comment": "Evaluator for plugin parameters expressions. Content surrounded by <code>${</code> and <code>}</code> is evaluated.\nRecognized values are:\n<table border=\"1\">\n<caption>Expression matrix</caption>\n<tr><th>expression</th>                     <th></th>               <th>evaluation result</th></tr>\n<tr><td><code>session.*</code></td>         <td></td>               <td></td></tr>\n<tr><td><code>project.*</code></td>         <td></td>               <td></td></tr>\n<tr><td><code>settings.*</code></td>        <td></td>               <td></td></tr>\n<tr><td><code>mojo.*</code></td>            <td></td>               <td>the actual {@link MojoExecution}</td></tr>\n<tr><td><code>*</code></td>                 <td></td>               <td>user properties</td></tr>\n<tr><td><code>*</code></td>                 <td></td>               <td>system properties</td></tr>\n<tr><td><code>*</code></td>                 <td></td>               <td>project properties</td></tr>\n</table>\n\n@see Session\n@see Project\n@see org.apache.maven.api.settings.Settings\n@see MojoExecution"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProfileActivation.java",
    "type": "method",
    "name": "deactivateOptionalProfile",
    "code": "public void deactivateOptionalProfile(String id) {\n        this.activations.put(id, ActivationSettings.deactivatedOpt());\n    }",
    "comment": "Mark a profile as optional and deactivated.\n@param id The identifier of the profile."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "initWithInterpreterFactoryApi",
    "code": "public void initWithInterpreterFactoryApi(InterpreterFactoryApi interpreterFactoryApi) {\n    impl = interpreterFactoryApi.createNnApiDelegateImpl(options);\n    initialized = true;\n  }",
    "comment": "Called when an interpreter is constructed with this delegate. This method is only for use by TF\nLite itself, and should not be used by application developers.\n\n@hide"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/ClassMap.java",
    "type": "method",
    "name": "getAccessibleMethods",
    "code": "private static Method[] getAccessibleMethods(Class<?> clazz) {\n        Method[] methods = clazz.getMethods();\n\n        // Short circuit for the (hopefully) majority of cases where the\n        // clazz is public\n        if (Modifier.isPublic(clazz.getModifiers())) {\n            return methods;\n        }\n\n        // No luck - the class is not public, so we're going the longer way.\n        MethodInfo[] methodInfos = new MethodInfo[methods.length];\n        for (int i = methods.length; i-- > 0; ) {\n            methodInfos[i] = new MethodInfo(methods[i]);\n        }\n\n        int upcastCount = getAccessibleMethods(clazz, methodInfos, 0);\n\n        // Reallocate array in case some method had no accessible counterpart.\n        if (upcastCount < methods.length) {\n            methods = new Method[upcastCount];\n        }\n\n        int j = 0;\n        for (MethodInfo methodInfo : methodInfos) {\n            if (methodInfo.upcast) {\n                methods[j++] = methodInfo.method;\n            }\n        }\n        return methods;\n    }",
    "comment": "Retrieves public methods for a class. In case the class is not\npublic, retrieves methods with same signature as its public methods\nfrom public superclasses and interfaces (if they exist). Basically\nupcasts every method to the nearest acccessible method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-sourcing/src/main/java/com/iluwatar/event/sourcing/processor/DomainEventProcessor.java",
    "type": "method",
    "name": "DomainEventProcessor",
    "code": "public DomainEventProcessor(EventJournal eventJournal) {\n    this.eventJournal = eventJournal;\n  }",
    "comment": "This is the implementation of event processor. All events are processed by this class. This\nprocessor uses eventJournal to persist and recover events.\n\n<p>Created by Serdar Hamzaogullari on 06.08.2017."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(long expected, Long actual) {\n\t\tAssertEquals.assertEquals((Long) expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/testkit/engine/ExecutionsIntegrationTests.java",
    "type": "method",
    "name": "executionsFromAbortedTestEvents",
    "code": "void executionsFromAbortedTestEvents() {\n\t\tvar testEvents = getTestEvents();\n\n\t\tassertThat(testEvents.executions().aborted().count()).isEqualTo(1);\n\t\tassertThat(testEvents.aborted().executions().count()).isEqualTo(0);\n\t}",
    "comment": "We expect 1 if the executions are created BEFORE filtering out \"started\" events.\nWe expect 0 if the executions are created AFTER filtering out \"started\" events."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryCleanupTests.java",
    "type": "method",
    "name": "cleanupModeOnSuccessPassingField",
    "code": "void cleanupModeOnSuccessPassingField() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(OnSuccessPassingFieldCase.class, \"testOnSuccessPassingField\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(onSuccessPassingFieldDir).doesNotExist();\n\t\t}",
    "comment": "Ensure that ON_SUCCESS cleanup modes are obeyed for passing field tests.\n<p/>\nExpect the TempDir to be cleaned up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/ResolveFile.java",
    "type": "method",
    "name": "resolveFile",
    "code": "public static File resolveFile(File file, String baseDirectory) {\n        if (file == null) {\n            return null;\n        } else if (file.isAbsolute()) {\n            return file;\n        } else if (file.getPath().startsWith(File.separator)) {\n            // drive-relative Windows path\n            return file.getAbsoluteFile();\n        } else {\n            return Paths.get(baseDirectory, file.getPath()).normalize().toFile();\n        }\n    }",
    "comment": "Resolve relative file path against the given base directory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/InputPartition.java",
    "type": "method",
    "name": "preferredLocations",
    "code": "default String[] preferredLocations() {\n    return new String[0];\n  }",
    "comment": "The preferred locations where the input partition reader returned by this partition can run\nfaster, but Spark does not guarantee to run the input partition reader on these locations.\nThe implementations should make sure that it can be run on any location.\nThe location is a string representing the host name.\n<p>\nNote that if a host name cannot be recognized by Spark, it will be ignored as it was not in\nthe returned locations. The default return value is empty string array, which means this\ninput partition's reader has no location preference.\n<p>\nIf this method fails (by throwing an exception), the action will fail and no Spark job will be\nsubmitted."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaUDFSuite.java",
    "type": "method",
    "name": "udf4Test",
    "code": "public void udf4Test() {\n    spark.udf().register(\"inc\", (Long i) -> i + 1, DataTypes.LongType);\n\n    spark.range(10).toDF(\"x\").createOrReplaceTempView(\"tmp\");\n    List<Row> results = spark.sql(\"SELECT inc(x) FROM tmp GROUP BY inc(x)\").collectAsList();\n    Assertions.assertEquals(10, results.size());\n    long sum = 0;\n    for (Row result : results) {\n      sum += result.getLong(0);\n    }\n    Assertions.assertEquals(55, sum);\n  }",
    "comment": "This tests when Java UDFs are required to be the semantically same (See SPARK-9435)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "getSpecValue",
    "code": "private static int getSpecValue(int collationId, int offset, int mask) {\n        return (collationId >> offset) & mask;\n      }",
    "comment": "Utility class for manipulating conversions between collation IDs and specifier enums/locale\nIDs. Scope bitwise operations here to avoid confusion."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/object-mother/src/main/java/com/iluwatar/objectmother/RoyaltyObjectMother.java",
    "type": "method",
    "name": "createSoberUnhappyKing",
    "code": "public static King createSoberUnhappyKing() {\n    return new King();\n  }",
    "comment": "Method to create a sober and unhappy king. The standard parameters are set.\n\n@return An instance of {@link com.iluwatar.objectmother.King} with the standard properties."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/DefaultMethodTests.java",
    "type": "method",
    "name": "resetFlags",
    "code": "void resetFlags() {\n\t\tbeforeAllInvoked = false;\n\t\tafterAllInvoked = false;\n\t\tdefaultMethodInvoked = false;\n\t\toverriddenDefaultMethodInvoked = false;\n\t\tlocalMethodInvoked = false;\n\t}",
    "comment": "Integration tests that verify support for selecting and executing default\nmethods from interfaces in conjunction with the {@link JupiterTestEngine}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/CartController.java",
    "type": "method",
    "name": "removeItemFromCart",
    "code": "public void removeItemFromCart(final String userId, final String productId) {\n    shoppingCartUseCase.removeItemFromCart(userId, productId);\n  }",
    "comment": "Removes an item from the user's cart.\n\n@param userId The ID of the user.\n@param productId The ID of the product to be removed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/ArtifactCoordinates.java",
    "type": "method",
    "name": "getId",
    "code": "default String getId() {\n        String c = getClassifier();\n        return getGroupId()\n                + ':'\n                + getArtifactId()\n                + ':'\n                + getExtension()\n                + ':'\n                + c\n                + (c.isEmpty() ? \"\" : \":\")\n                + getVersionConstraint();\n    }",
    "comment": "{@return a unique string representation identifying this artifact}\n\nThe default implementation returns a colon-separated list of group\nidentifier, artifact identifier, extension, classifier and version.\n\n@see Artifact#key()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "maxSaslEncryptedBlockSize",
    "code": "public int maxSaslEncryptedBlockSize() {\n    return Ints.checkedCast(JavaUtils.byteStringAsBytes(\n      conf.get(\"spark.network.sasl.maxEncryptedBlockSize\", \"64k\")));\n  }",
    "comment": "Maximum number of bytes to be encrypted at a time when SASL encryption is used."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "discover",
    "code": "public static EngineDiscoveryResults discover(TestEngine testEngine, LauncherDiscoveryRequest discoveryRequest) {\n\t\tPreconditions.notNull(testEngine, \"TestEngine must not be null\");\n\t\tPreconditions.notNull(discoveryRequest, \"EngineDiscoveryRequest must not be null\");\n\t\tLauncherDiscoveryResult discoveryResult = discover(testEngine, discoveryRequest, DISCOVERY);\n\t\tTestDescriptor engineDescriptor = discoveryResult.getEngineTestDescriptor(testEngine);\n\t\tList<DiscoveryIssue> discoveryIssues = discoveryResult.getDiscoveryIssues(testEngine);\n\t\treturn new EngineDiscoveryResults(engineDescriptor, discoveryIssues);\n\t}",
    "comment": "Discover tests for the given {@link LauncherDiscoveryRequest} using the\nsupplied {@link TestEngine}.\n\n<p>{@link org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder}\nprovides a convenient way to build an appropriate discovery request to\nsupply to this method. As an alternative, consider using\n{@link #engine(TestEngine)} for a more fluent API.\n\n@param testEngine the {@code TestEngine} to use; must not be {@code null}\n@param discoveryRequest the {@code EngineDiscoveryResults} to use; must\nnot be {@code null}\n@return the recorded {@code EngineExecutionResults}\n@throws PreconditionViolationException for invalid arguments\n@since 1.13\n@see #discover(String, LauncherDiscoveryRequest)\n@see #engine(String)\n@see #engine(TestEngine)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertSame",
    "code": "public static void assertSame(String message, Object expected, Object actual) {\n        if (expected == actual) {\n            return;\n        }\n        failNotSame(message, expected, actual);\n    }",
    "comment": "Asserts that two objects refer to the same object. If they are not, an\n{@link AssertionError} is thrown with the given message.\n\n@param message the identifying message for the {@link AssertionError} (<code>null</code>\nokay)\n@param expected the expected object\n@param actual the object to compare to <code>expected</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-console/src/main/java/org/junit/platform/console/tasks/VerboseTreePrintingListener.java",
    "type": "method",
    "name": "printDetail",
    "code": "private void printDetail(Style style, String detail, String format, Object... args) {\n\t\t// print initial verticals - expecting to be at start of the line\n\t\tString verticals = verticals(frames.size() + 1);\n\t\tprintf(NONE, verticals);\n\t\tString detailFormat = \"%9s\";\n\t\t// omit detail string if it's empty\n\t\tif (!detail.isEmpty()) {\n\t\t\tprintf(NONE, \"%s\", String.format(detailFormat + \": \", detail));\n\t\t}\n\t\t// trivial case: at least one arg is given? Let printf do the entire work\n\t\tif (args.length > 0) {\n\t\t\tprintf(style, format, args);\n\t\t\treturn;\n\t\t}\n\t\t// still here? Split format into separate lines and indent them from the second line on\n\t\tString[] lines = format.split(\"\\\\R\");\n\t\tprintf(style, \"%s\", lines[0]);\n\t\tif (lines.length > 1) {\n\t\t\tString delimiter = System.lineSeparator() + verticals + String.format(detailFormat + \"    \", \"\");\n\t\t\tfor (int i = 1; i < lines.length; i++) {\n\t\t\t\tprintf(NONE, \"%s\", delimiter);\n\t\t\t\tprintf(style, \"%s\", lines[i]);\n\t\t\t}\n\t\t}\n\t\tprintf(NONE, \"%n\");\n\t}",
    "comment": "Print single detail with a potential multi-line message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "isArray",
    "code": "public static boolean isArray(Object obj) {\n\t\treturn (obj != null && obj.getClass().isArray());\n\t}",
    "comment": "Determine if the supplied object is an array.\n\n@param obj the object to test; potentially {@code null}\n@return {@code true} if the object is an array"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/NewestConflictResolverTest.java",
    "type": "method",
    "name": "testDepth",
    "code": "void testDepth() {\n        ResolutionNode a1n = createResolutionNode(a1);\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n\n        assertResolveConflict(a2n, a1n, a2n);\n    }",
    "comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\na:1.0\nb:1.0 -&gt; a:2.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "updateColumnPosition",
    "code": "static TableChange updateColumnPosition(String[] fieldNames, ColumnPosition newPosition) {\n    return new UpdateColumnPosition(fieldNames, newPosition);\n  }",
    "comment": "Create a TableChange for updating the position of a field.\n<p>\nThe name is used to find the field to update.\n<p>\nIf the field does not exist, the change will result in an {@link IllegalArgumentException}.\n\n@param fieldNames field names of the column to update\n@param newPosition the new position\n@return a TableChange for the update"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/saga/src/main/java/com/iluwatar/saga/choreography/Saga.java",
    "type": "method",
    "name": "chapter",
    "code": "public Saga chapter(String name) {\n    this.chapters.add(new Chapter(name));\n    return this;\n  }",
    "comment": "add chapter to saga.\n\n@param name chapter name\n@return this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/inference_interface/java/org/tensorflow/contrib/android/TensorFlowInferenceInterface.java",
    "type": "method",
    "name": "run",
    "code": "public void run(String[] outputNames) {\n    run(outputNames, false);\n  }",
    "comment": "Runs inference between the previously registered input nodes (via feed*) and the requested\noutput nodes. Output nodes can then be queried with the fetch* methods.\n\n@param outputNames A list of output nodes which should be filled by the inference pass."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toLong",
    "code": "public boolean toLong(LongWrapper toLongResult) {\n    return toLong(toLongResult, true);\n  }",
    "comment": "Parses this UTF8String(trimmed if needed) to long.\n\nNote that, in this method we accumulate the result in negative format, and convert it to\npositive format at the end, if this string is not started with '-'. This is because min value\nis bigger than max value in digits, e.g. Long.MAX_VALUE is '9223372036854775807' and\nLong.MIN_VALUE is '-9223372036854775808'.\n\nThis code is mostly copied from LazyLong.parseLong in Hive.\n\n@param toLongResult If a valid `long` was parsed from this UTF8String, then its value would\nbe set in `toLongResult`\n@return true if the parsing was successful else false"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/client/TransportClient.java",
    "type": "method",
    "name": "StdChannelListener",
    "code": "ChunkReceivedCallback callback) {\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Sending fetch chunk request {} to {}\", chunkIndex, getRemoteAddress(channel));\n    }\n\n    StreamChunkId streamChunkId = new StreamChunkId(streamId, chunkIndex);\n    StdChannelListener listener = new StdChannelListener(streamChunkId) {\n    };\n    handler.addFetchRequest(streamChunkId, callback);\n\n    channel.writeAndFlush(new ChunkFetchRequest(streamChunkId)).addListener(listener);\n  }",
    "comment": "Requests a single chunk from the remote side, from the pre-negotiated streamId.\n\nChunk indices go from 0 onwards. It is valid to request the same chunk multiple times, though\nsome streams may not support this.\n\nMultiple fetchChunk requests may be outstanding simultaneously, and the chunks are guaranteed\nto be returned in the same order that they were requested, assuming only a single\nTransportClient is used to fetch the chunks.\n\n@param streamId Identifier that refers to a stream in the remote StreamManager. This should\nbe agreed upon by client and server beforehand.\n@param chunkIndex 0-based index of the chunk to fetch\n@param callback Callback invoked upon successful receipt of chunk, or upon any failure."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(boolean condition, Supplier<String> messageSupplier) {\n\t\tAssertTrue.assertTrue(condition, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that the supplied {@code condition} is {@code true}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/MutableColumnarRow.java",
    "type": "method",
    "name": "MutableColumnarRow",
    "code": "public MutableColumnarRow(WritableColumnVector[] writableColumns) {\n    this.columns = writableColumns;\n  }",
    "comment": "A mutable version of {@link ColumnarRow}, which is used in the vectorized hash map for hash\naggregate, and {@link ColumnarBatch} to save object creation.\n\nNote that this class intentionally has a lot of duplicated code with {@link ColumnarRow}, to\navoid java polymorphism overhead by keeping {@link ColumnarRow} and this class final classes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportFrameDecoder.java",
    "type": "method",
    "name": "consumeCurrentFrameBuf",
    "code": "private ByteBuf consumeCurrentFrameBuf() {\n    ByteBuf frame = frameBuf;\n    frameBuf = null;\n    consolidatedFrameBufSize = 0;\n    consolidatedNumComponents = 0;\n    nextFrameSize = UNKNOWN_FRAME_SIZE;\n    return frame;\n  }",
    "comment": "Reset buf and size for next frame."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeRowWriter.java",
    "type": "method",
    "name": "resetRowWriter",
    "code": "public void resetRowWriter() {\n    this.startingOffset = cursor();\n\n    // grow the global buffer to make sure it has enough space to write fixed-length data.\n    grow(fixedSize);\n    increaseCursor(fixedSize);\n\n    zeroOutNullBytes();\n  }",
    "comment": "Resets the `startingOffset` according to the current cursor of row buffer, and clear out null\nbits.  This should be called before we write a new nested struct to the row buffer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/microservices-client-side-ui-composition/src/main/java/com/iluwatar/clientsideuicomposition/CartFrontend.java",
    "type": "method",
    "name": "getData",
    "code": "protected String getData(Map<String, String> params) {\n    String userId = params.getOrDefault(\"userId\", \"anonymous\");\n    return \"Shopping Cart for user '\" + userId + \"': [Item 1, Item 2]\";\n  }",
    "comment": "Fetches the current state of the shopping cart based on dynamic parameters like user ID.\n\n@param params parameters that influence the cart data, e.g., \"userId\"\n@return a string representing the items in the shopping cart for a given user"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/callback/src/test/java/com/iluwatar/callback/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/Write.java",
    "type": "method",
    "name": "toBatch",
    "code": "default BatchWrite toBatch() {\n    throw new SparkUnsupportedOperationException(\n      \"_LEGACY_ERROR_TEMP_3137\", Map.of(\"description\", description()));\n  }",
    "comment": "Returns a {@link BatchWrite} to write data to batch source. By default this method throws\nexception, data sources must overwrite this method to provide an implementation, if the\n{@link Table} that creates this write returns {@link TableCapability#BATCH_WRITE} support in\nits {@link Table#capabilities()}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/EnabledIfConditionTests.java",
    "type": "method",
    "name": "getExecutionCondition",
    "code": "protected ExecutionCondition getExecutionCondition() {\n\t\treturn new EnabledIfCondition();\n\t}",
    "comment": "Unit tests for {@link EnabledIf}.\n\n<p>Note that test method names MUST match the test method names in\n{@link EnabledIfIntegrationTests}.\n\n@since 5.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/VersionRangeResolverResult.java",
    "type": "method",
    "name": "getLowestVersion",
    "code": "default Optional<Version> getLowestVersion() {\n        return getVersions().isEmpty()\n                ? Optional.empty()\n                : Optional.of(getVersions().get(0));\n    }",
    "comment": "Gets the lowest version matching the requested range.\n\n@return An Optional containing the lowest matching version, or empty Optional if no versions\nmatched the requested range"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/parameter-object/src/main/java/com/iluwatar/parameter/object/SearchService.java",
    "type": "method",
    "name": "search",
    "code": "public String search(ParameterObject parameterObject) {\n    return getQuerySummary(\n        parameterObject.getType(), parameterObject.getSortBy(), parameterObject.getSortOrder());\n  }",
    "comment": "The need for multiple method definitions can be avoided by the Parameter Object pattern. Below\nis the example where only one method is required and all the logic for having default values\nare abstracted into the Parameter Object at the time of object creation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java",
    "type": "method",
    "name": "source",
    "code": "default Builder source(Optional<TestSource> source) {\n\t\t\tsource.ifPresent(this::source);\n\t\t\treturn this;\n\t\t}",
    "comment": "Set the {@link TestSource} for the {@code DiscoveryIssue}.\n\n@param source the {@link TestSource} for the {@code DiscoveryIssue};\nnever {@code null} but potentially empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/AlbumPage.java",
    "type": "method",
    "name": "changeAlbumRating",
    "code": "public AlbumPage changeAlbumRating(String albumRating) {\n    var albumRatingInputTextField = (HtmlTextInput) page.getElementById(\"albumRating\");\n    albumRatingInputTextField.setText(albumRating);\n    return this;\n  }",
    "comment": "Sets the album rating input text field.\n\n@param albumRating the new album rating value to set\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java",
    "type": "method",
    "name": "doesNotThrowExceptionWhenParametrizedTestDoesNotRequireArguments",
    "code": "void doesNotThrowExceptionWhenParametrizedTestDoesNotRequireArguments() {\n\t\tvar extensionContext = getExtensionContextReturningSingleMethod(new TestCaseAllowNoArgumentsMethod());\n\n\t\tvar stream = this.parameterizedTestExtension.provideTestTemplateInvocationContexts(extensionContext);\n\t\tstream.toArray();\n\t\tstream.close();\n\t}",
    "comment": "cause the stream to be evaluated"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "levenshteinDistance",
    "code": "public int levenshteinDistance(UTF8String other) {\n    // Implementation adopted from\n    // org.apache.commons.text.similarity.LevenshteinDistance.unlimitedCompare\n\n    int n = numChars();\n    int m = other.numChars();\n\n    if (n == 0) {\n      return m;\n    } else if (m == 0) {\n      return n;\n    }\n\n    UTF8String s, t;\n\n    if (n <= m) {\n      s = this;\n      t = other;\n    } else {\n      s = other;\n      t = this;\n      int swap;\n      swap = n;\n      n = m;\n      m = swap;\n    }\n\n    int[] p = new int[n + 1];\n    int[] d = new int[n + 1];\n    int[] swap;\n\n    int i, i_bytes, j, j_bytes, num_bytes_j, cost;\n\n    for (i = 0; i <= n; i++) {\n      p[i] = i;\n    }\n\n    for (j = 0, j_bytes = 0; j < m; j_bytes += num_bytes_j, j++) {\n      num_bytes_j = numBytesForFirstByte(t.getByte(j_bytes));\n      d[0] = j + 1;\n\n      for (i = 0, i_bytes = 0; i < n; i_bytes += numBytesForFirstByte(s.getByte(i_bytes)), i++) {\n        if (s.getByte(i_bytes) != t.getByte(j_bytes) ||\n              num_bytes_j != numBytesForFirstByte(s.getByte(i_bytes))) {\n          cost = 1;\n        } else {\n          cost = (ByteArrayMethods.arrayEquals(t.base, t.offset + j_bytes, s.base,\n              s.offset + i_bytes, num_bytes_j)) ? 0 : 1;\n        }\n        d[i + 1] = Math.min(Math.min(d[i] + 1, p[i + 1] + 1), p[i] + cost);\n      }\n\n      swap = p;\n      p = d;\n      d = swap;\n    }\n\n    return p[n];\n  }",
    "comment": "Levenshtein distance is a metric for measuring the distance of two strings. The distance is\ndefined by the minimum number of single-character edits (i.e. insertions, deletions or\nsubstitutions) that are required to change one of the strings into the other."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/DefaultArtifactRepository.java",
    "type": "method",
    "name": "DefaultArtifactRepository",
    "code": "public DefaultArtifactRepository(String id, String url, ArtifactRepositoryLayout layout) {\n        this(id, url, layout, null, null);\n    }",
    "comment": "Create a local repository or a test repository.\n\n@param id     the unique identifier of the repository\n@param url    the URL of the repository\n@param layout the layout of the repository"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/Scope.java",
    "type": "method",
    "name": "makeOpName",
    "code": "public String makeOpName(String defaultName) {\n    return nameScope.makeOpName(defaultName);\n  }",
    "comment": "Create a unique name for an operator, using a provided default if necessary.\n\n<p>This is normally called only by operator building classes.\n\n<p>This method generates a unique name, appropriate for the name scope controlled by this\ninstance. Typical operator building code might look like\n\n<pre>{@code\nscope.env().opBuilder(\"Const\", scope.makeOpName(\"Const\"))...\n}</pre>\n\n<p><b>Note:</b> if you provide a composite operator building class (i.e, a class that creates a\nset of related operations by calling other operator building code), the provided name will act\nas a subscope to all underlying operators.\n\n@param defaultName name for the underlying operator.\n@return unique name for the operator.\n@throws IllegalArgumentException if the default name is invalid."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/documentation/src/test/java/example/exception/ExceptionAssertionDemo.java",
    "type": "method",
    "name": "testExpectedExceptionIsThrown",
    "code": "void testExpectedExceptionIsThrown() {\n\t\tIllegalArgumentException exception =\n\t\t\tassertThrows(IllegalArgumentException.class, () -> {\n\t\t\t\tthrow new IllegalArgumentException(\"expected message\");\n\t\t\t});\n\t\tassertEquals(\"expected message\", exception.getMessage());\n\n\t\tassertThrows(RuntimeException.class, () -> {\n\t\t\tthrow new IllegalArgumentException(\"expected message\");\n\t\t});\n\t}",
    "comment": "@formatter:off\ntag::user_guide[]\nThe following assertion succeeds because the code under assertion\nthrows the expected IllegalArgumentException.\nThe assertion also returns the thrown exception which can be used for\nfurther assertions like asserting the exception message.\nThe following assertion also succeeds because the code under assertion\nthrows IllegalArgumentException which is a subclass of RuntimeException."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/FileProfileActivator.java",
    "type": "method",
    "name": "isActive",
    "code": "public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        Activation activation = profile.getActivation();\n\n        if (activation == null) {\n            return false;\n        }\n\n        ActivationFile file = activation.getFile();\n\n        if (file == null) {\n            return false;\n        }\n\n        String path;\n        boolean missing;\n\n        boolean hasExists = file.getExists() != null && !file.getExists().isEmpty();\n        boolean hasMissing = file.getMissing() != null && !file.getMissing().isEmpty();\n        if (hasExists) {\n            if (hasMissing) {\n                problems.add(\n                        BuilderProblem.Severity.WARNING,\n                        ModelProblem.Version.BASE,\n                        String.format(\n                                \"Profile '%s' file activation conflict: Both 'missing' (%s) and 'exists' assertions are defined. \"\n                                        + \"The 'missing' assertion will be ignored. Please remove one assertion to resolve this conflict.\",\n                                profile.getId(), file.getMissing()),\n                        file.getLocation(\"missing\"));\n            }\n            path = file.getExists();\n            missing = false;\n        } else if (hasMissing) {\n            path = file.getMissing();\n            missing = true;\n        } else {\n            return false;\n        }\n\n        boolean fileExists;\n        try {\n            fileExists = context.exists(path, false);\n        } catch (MavenException e) {\n            problems.add(\n                    BuilderProblem.Severity.ERROR,\n                    ModelProblem.Version.BASE,\n                    \"Failed to check file existence \" + path + \" for profile \" + profile.getId() + \": \"\n                            + e.getMessage(),\n                    file.getLocation(missing ? \"missing\" : \"exists\"),\n                    e);\n            return false;\n        }\n\n        return missing != fileExists;\n    }",
    "comment": "Determines profile activation based on the existence/absence of some file.\nFile name interpolation support is limited to <code>${project.basedir}</code>\nsystem properties and user properties.\n\n@see ActivationFile\n@see DefaultModelValidator#validateRawModel"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Result.java",
    "type": "method",
    "name": "SerializedForm",
    "code": "public SerializedForm(Result result) {\n            fCount = result.count;\n            fIgnoreCount = result.ignoreCount;\n            assumptionFailureCount = result.assumptionFailureCount;\n            fFailures = Collections.synchronizedList(new ArrayList<Failure>(result.failures));\n            fRunTime = result.runTime.longValue();\n            fStartTime = result.startTime.longValue();\n        }",
    "comment": "Represents the serialized output of {@code Result}. The fields on this\nclass match the files that {@code Result} had in JUnit 4.11."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNull",
    "code": "public static void assertNull(Object actual, Supplier<String> messageSupplier) {\n\t\tAssertNull.assertNull(actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code actual} is {@code null}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/InitializationError.java",
    "type": "method",
    "name": "InitializationError",
    "code": "public InitializationError(List<Throwable> errors) {\n        this.fErrors = errors;\n    }",
    "comment": "Use the published version:\n{@link org.junit.runners.model.InitializationError}\nThis may disappear as soon as 1 April 2009"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/collecting-parameter/src/main/java/com/iluwatar/collectingparameter/App.java",
    "type": "method",
    "name": "addValidA2Papers",
    "code": "public static void addValidA2Papers(Queue<PrinterItem> printerItemsCollection) {\n    for (PrinterItem nextItem : printerQueue.getPrinterQueue()) {\n      if (nextItem.paperSize.equals(PaperSizes.A2)) {\n\n        // Encoding the policy into a Boolean: the A2 paper must be single page, single-sided, and\n        // non-coloured.\n        var isNotColouredSingleSidedAndOnePage =\n            nextItem.pageCount == 1 && !nextItem.isDoubleSided && !nextItem.isColour;\n        if (isNotColouredSingleSidedAndOnePage) {\n          printerItemsCollection.add(nextItem);\n        }\n      }\n    }\n  }",
    "comment": "Adds A2 document jobs to the collecting parameter according to some policy that can be whatever\nthe client (the print center) wants. The code is similar to the 'addA4Papers' method. The code\ncan be changed to accommodate the wants of the client.\n\n@param printerItemsCollection the collecting parameter"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/WarningResolutionListener.java",
    "type": "method",
    "name": "WarningResolutionListener",
    "code": "public WarningResolutionListener(Logger logger) {\n        this.logger = logger;\n    }",
    "comment": "Send resolution warning events to the warning log."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/OverConstrainedVersionException.java",
    "type": "method",
    "name": "OverConstrainedVersionException",
    "code": "public OverConstrainedVersionException(String msg, Artifact artifact) {\n        super(msg, artifact);\n    }",
    "comment": "Occurs when ranges exclude each other and no valid value remains."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room3/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "updateUserName",
    "code": "void updateUserName(String userName, UpdateUserCallback callback) {\n        final WeakReference<UpdateUserCallback> updateUserCallback = new WeakReference<>(callback);\n\n        Date date = new Date(System.currentTimeMillis());\n        final User user = mCachedUser == null\n                ? new User(userName)\n                : new User(mCachedUser.getId(), userName, date);\n\n        // update the user on the I/O thread\n        mAppExecutors.diskIO().execute(new Runnable() {\n                mAppExecutors.mainThread().execute(new Runnable() {\n                    }\n                });\n            }",
    "comment": "Insert an new user or update the name of the user.\n\n@param userName the user name\n@param callback callback that gets triggered when the user was updated."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<String> create(byte[][][] data) {\n    return Tensor.create(data, String.class);\n  }",
    "comment": "Creates a rank-2 tensor of {@code byte} elements.\n\n@param data An array containing the data to put into the new tensor. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/CollectionUtils.java",
    "type": "method",
    "name": "toSet",
    "code": "public static <T> Set<T> toSet(T[] values) {\n\t\tPreconditions.notNull(values, \"values array must not be null\");\n\t\tif (values.length == 0) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tif (values.length == 1) {\n\t\t\treturn Collections.singleton(values[0]);\n\t\t}\n\t\tSet<T> set = new HashSet<>();\n\t\tCollections.addAll(set, values);\n\t\treturn set;\n\t}",
    "comment": "Convert the supplied array of values to a {@link Set}.\n\n@param values the array of values; never {@code null}\n@return a set of the values\n@throws PreconditionViolationException if the array is {@code null}\n@since 1.6"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/AppManager.java",
    "type": "method",
    "name": "saveAside",
    "code": "private void saveAside(final UserAccount userAccount) {\n    dbManager.updateDb(userAccount);\n    cacheStore.invalidate(userAccount.getUserId());\n  }",
    "comment": "Cache-Aside save user account helper.\n\n@param userAccount {@link UserAccount}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Double> create(double[][][] data) {\n    return Tensor.create(data, Double.class);\n  }",
    "comment": "Creates a rank-3 tensor of {@code double} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-toolchain-builder/src/main/java/org/apache/maven/toolchain/io/ToolchainsParseException.java",
    "type": "method",
    "name": "ToolchainsParseException",
    "code": "public ToolchainsParseException(String message, int lineNumber, int columnNumber) {\n        super(message);\n        this.lineNumber = lineNumber;\n        this.columnNumber = columnNumber;\n    }",
    "comment": "Creates a new parser exception with the specified details.\n\n@param message The error message, may be {@code null}.\n@param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.\n@param columnNumber The one-based index of the column containing the error or {@code -1} if unknown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/eventspy/internal/EventSpyDispatcher.java",
    "type": "method",
    "name": "EventSpyDispatcher",
    "code": "public EventSpyDispatcher(List<EventSpy> eventSpies) {\n        // make copy to get rid of needless overhead for dynamic lookups\n        this.eventSpies = new ArrayList<>(eventSpies);\n    }",
    "comment": "Dispatches callbacks to all registered EventSpies.\n@since 3.0.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelNormalizer.java",
    "type": "method",
    "name": "injectDependency",
    "code": "private Dependency injectDependency(Dependency d) {\n        return (d.getScope() == null || d.getScope().isEmpty()) ? d.withScope(\"compile\") : d;\n    }",
    "comment": "we cannot set this directly in the MDO due to the interactions with dependency management"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/filterer/src/main/java/com/iluwatar/filterer/App.java",
    "type": "method",
    "name": "filteringSimpleProbableThreats",
    "code": "private static void filteringSimpleProbableThreats() {\n    LOGGER.info(\"### Filtering ProbabilisticThreatAwareSystem by probability ###\");\n\n    var trojanArcBomb = new SimpleProbableThreat(\"Trojan-ArcBomb\", 1, ThreatType.TROJAN, 0.99);\n    var rootkit = new SimpleProbableThreat(\"Rootkit-Kernel\", 2, ThreatType.ROOTKIT, 0.8);\n\n    List<ProbableThreat> probableThreats = List.of(trojanArcBomb, rootkit);\n\n    var probabilisticThreatAwareSystem =\n        new SimpleProbabilisticThreatAwareSystem(\"Sys-1\", probableThreats);\n\n    LOGGER.info(\n        \"Filtering ProbabilisticThreatAwareSystem. Initial : \" + probabilisticThreatAwareSystem);\n\n    // Filtering using filterer\n    var filteredThreatAwareSystem =\n        probabilisticThreatAwareSystem\n            .filtered()\n            .by(probableThreat -> Double.compare(probableThreat.probability(), 0.99) == 0);\n\n    LOGGER.info(\"Filtered by probability = 0.99 : \" + filteredThreatAwareSystem);\n  }",
    "comment": "Demonstrates how to filter {@link com.iluwatar.filterer.threat.ProbabilisticThreatAwareSystem}\nbased on probability property. The @{@link com.iluwatar.filterer.domain.Filterer#by(Predicate)}\nmethod is able to use {@link com.iluwatar.filterer.threat.ProbableThreat} as predicate\nargument."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dynamic-proxy/src/main/java/com/iluwatar/dynamicproxy/App.java",
    "type": "method",
    "name": "createDynamicProxy",
    "code": "public void createDynamicProxy() {\n    AlbumInvocationHandler albumInvocationHandler = new AlbumInvocationHandler(baseUrl, httpClient);\n\n    albumServiceProxy =\n        (AlbumService)\n            Proxy.newProxyInstance(\n                App.class.getClassLoader(),\n                new Class<?>[] {AlbumService.class},\n\n  public void callMethods() {\n    int albumId = 17;\n    int userId = 3;\n\n    var albums = albumServiceProxy.readAlbums();\n    albums.forEach(album -> LOGGER.info(\"{}\", album));\n\n    var album = albumServiceProxy.readAlbum(albumId);\n    LOGGER.info(\"{}\", album);\n\n    var newAlbum =\n        albumServiceProxy.createAlbum(Album.builder().title(\"Big World\").userId(userId).build());\n    LOGGER.info(\"{}\", newAlbum);\n\n    var editAlbum =\n        albumServiceProxy.updateAlbum(\n            albumId, Album.builder().title(\"Green Valley\").userId(userId).build());\n    LOGGER.info(\"{}\", editAlbum);\n\n    var removedAlbum = albumServiceProxy.deleteAlbum(albumId);\n    LOGGER.info(\"{}\", removedAlbum);\n  }\n}",
    "comment": "Call the methods of the Dynamic Proxy, in other words, the AlbumService interface's methods and\nreceive the responses from the Rest API."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/DefaultArtifactRepositoryFactory.java",
    "type": "method",
    "name": "isLocalRepository",
    "code": "private boolean isLocalRepository(ArtifactRepository repository) {\n        return \"local\".equals(repository.getId());\n    }",
    "comment": "unfortunately, the API doesn't allow to tell a remote repo and the local repo apart..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "removeSourceRoot",
    "code": "public void removeSourceRoot(@Nonnull ProjectScope scope, @Nonnull Language language, @Nonnull String directory) {\n        directory =\n                Objects.requireNonNull(directory, \"directory cannot be null\").trim();\n        if (!directory.isBlank()) {\n            removeSourceRoot(scope, language, Path.of(directory));\n        }\n    }",
    "comment": "Removes a source root from the project.\n\n@param scope the scope of the source root\n@param language the language of the source root\n@param directory the directory of the source root"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-layer/src/main/java/com/iluwatar/servicelayer/hibernate/HibernateUtil.java",
    "type": "method",
    "name": "getSessionFactory",
    "code": "public static synchronized SessionFactory getSessionFactory() {\n    if (sessionFactory == null) {\n      try {\n        sessionFactory =\n            new Configuration()\n                .addAnnotatedClass(Wizard.class)\n                .addAnnotatedClass(Spellbook.class)\n                .addAnnotatedClass(Spell.class)\n                .setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.H2Dialect\")\n                .setProperty(\"hibernate.connection.url\", \"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\")\n                .setProperty(\"hibernate.current_session_context_class\", \"thread\")\n                .setProperty(\"hibernate.show_sql\", \"false\")\n                .setProperty(\"hibernate.hbm2ddl.auto\", \"create-drop\")\n                .buildSessionFactory();\n      } catch (Throwable ex) {\n        LOGGER.error(\"Initial SessionFactory creation failed.\", ex);\n        throw new ExceptionInInitializerError(ex);\n      }\n    }\n    return sessionFactory;\n  }",
    "comment": "Create the current session factory instance, create a new one when there is none yet.\n\n@return The session factory"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-settings-builder/src/main/java/org/apache/maven/settings/io/SettingsParseException.java",
    "type": "method",
    "name": "SettingsParseException",
    "code": "public SettingsParseException(String message, int lineNumber, int columnNumber, Throwable cause) {\n        super(message);\n        initCause(cause);\n        this.lineNumber = lineNumber;\n        this.columnNumber = columnNumber;\n    }",
    "comment": "Creates a new parser exception with the specified details.\n\n@param message The error message, may be {@code null}.\n@param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.\n@param columnNumber The one-based index of the column containing the error or {@code -1} if unknown.\n@param cause The nested cause of this error, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/interpreter/src/test/java/com/iluwatar/interpreter/MinusExpressionTest.java",
    "type": "method",
    "name": "expressionProvider",
    "code": "public Stream<Arguments> expressionProvider() {\n    return prepareParameters((f, s) -> f - s);\n  }",
    "comment": "Create a new set of test entries with the expected result\n\n@return The list of parameters used during this test"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/feature-toggle/src/main/java/com/iluwatar/featuretoggle/pattern/tieredversion/TieredFeatureToggleVersion.java",
    "type": "method",
    "name": "getWelcomeMessage",
    "code": "public String getWelcomeMessage(User user) {\n    if (UserGroup.isPaid(user)) {\n      return \"You're amazing \" + user + \". Thanks for paying for this awesome software.\";\n    }\n\n    return \"I suppose you can use this software.\";\n  }",
    "comment": "Generates a welcome message from the passed {@link User}. The resulting message depends on the\ngroup of the {@link User}. So if the {@link User} is in the {@link UserGroup#paidGroup} then\nthe enhanced version of the welcome message will be returned where the username is displayed.\n\n@param user the {@link User} to generate the welcome message for, different messages are\ndisplayed if the user is in the {@link UserGroup#isPaid(User)} or {@link\nUserGroup#freeGroup}\n@return Resulting welcome message.\n@see User\n@see UserGroup"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutExtension.java",
    "type": "method",
    "name": "isTimeoutDisabled",
    "code": "private boolean isTimeoutDisabled(ExtensionContext extensionContext) {\n\t\tOptional<String> mode = extensionContext.getConfigurationParameter(TIMEOUT_MODE_PROPERTY_NAME);\n\t\treturn mode.map(this::isTimeoutDisabled).orElse(false);\n\t}",
    "comment": "Determine if timeouts are disabled for the supplied extension context."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-executor/src/main/java/org/apache/maven/api/cli/ExecutorRequest.java",
    "type": "method",
    "name": "toBuilder",
    "code": "default Builder toBuilder() {\n        return new Builder(\n                command(),\n                arguments(),\n                cwd(),\n                installationDirectory(),\n                userHomeDirectory(),\n                jvmSystemProperties().orElse(null),\n                environmentVariables().orElse(null),\n                jvmArguments().orElse(null),\n                stdIn().orElse(null),\n                stdOut().orElse(null),\n                stdErr().orElse(null));\n    }",
    "comment": "Returns {@link Builder} created from this instance."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/StaticNestedBeforeAllAndAfterAllMethodsTests.java",
    "type": "method",
    "name": "staticBeforeAllAndAfterAllMethodsInNestedTestClass",
    "code": "void staticBeforeAllAndAfterAllMethodsInNestedTestClass() {\n\t\texecuteTestsForClass(TestCase.class).testEvents().assertStatistics(stats -> stats.started(2).succeeded(2));\n\n\t\tassertThat(methodsInvoked).containsExactly(//\n\t\t\t\"@BeforeAll: top-level\", //\n\t\t\t\"@Test: top-level\", //\n\t\t\t\"@BeforeAll: nested\", //\n\t\t\t\"@Test: nested\", //\n\t\t\t\"@AfterAll: nested\", //\n\t\t\t\"@AfterAll: top-level\"//\n\t\t);\n\t}",
    "comment": "Integration tests that verify support for {@code static} {@link BeforeAll} and\n{@link AfterAll} methods in {@link Nested} tests on Java 16+.\n\n@since 5.9\n@see BeforeAllAndAfterAllComposedAnnotationTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/test-automation/src/main/java/com/iluwatar/pageobject/LoginPage.java",
    "type": "method",
    "name": "login",
    "code": "public AlbumListPage login() {\n    var loginButton = (HtmlSubmitInput) page.getElementById(\"loginButton\");\n    try {\n      loginButton.click();\n    } catch (IOException e) {\n      LOGGER.error(\"An error occurred on login.\", e);\n    }\n    return new AlbumListPage(webClient);\n  }",
    "comment": "Clicking on the login button to 'login'.\n\n@return {@link AlbumListPage} - this is the page that user gets navigated to once successfully\nlogged in"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<String> create(byte[][][][] data) {\n    return Tensor.create(data, String.class);\n  }",
    "comment": "Creates a rank-3 tensor of {@code byte} elements.\n\n@param data An array containing the data to put into the new tensor. String elements are\nsequences of bytes from the last array dimension."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/connect/client/jvm/src/test/java/org/apache/spark/sql/JavaEncoderSuite.java",
    "type": "method",
    "name": "setup",
    "code": "public static void setup() {\n    Assumptions.assumeTrue(IntegrationTestUtils.isAssemblyJarsDirExists(),\n      \"Skipping all tests because assembly jars directory does not exist.\");\n    spark = SparkConnectServerUtils.createSparkSession();\n  }",
    "comment": "Tests for the encoders class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "endTest",
    "code": "public void endTest(Test test) {\n        for (TestListener each : cloneListeners()) {\n            each.endTest(test);\n        }\n    }",
    "comment": "Informs the result that a test was completed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isStatic",
    "code": "public static boolean isStatic(Class<?> clazz) {\n\t\treturn ReflectionUtils.isStatic(clazz);\n\t}",
    "comment": "Determine if the supplied class is {@code static}.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is {@code static}\n@see java.lang.reflect.Modifier#isStatic(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/InvokerRequest.java",
    "type": "method",
    "name": "effectiveVerbose",
    "code": "default boolean effectiveVerbose() {\n        return options().verbose().orElse(ciInfo().isPresent() && ciInfo().get().isVerbose());\n    }",
    "comment": "This method returns \"verbose\" option value derived from multiple places: CLI options, but also CI detection,\nif applicable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetVectorUpdaterFactory.java",
    "type": "method",
    "name": "isDecimalTypeMatched",
    "code": "private static boolean isDecimalTypeMatched(ColumnDescriptor descriptor, DataType dt) {\n    DecimalType requestedType = (DecimalType) dt;\n    LogicalTypeAnnotation typeAnnotation = descriptor.getPrimitiveType().getLogicalTypeAnnotation();\n    if (typeAnnotation instanceof DecimalLogicalTypeAnnotation) {\n      DecimalLogicalTypeAnnotation parquetType = (DecimalLogicalTypeAnnotation) typeAnnotation;\n      int scaleIncrease = requestedType.scale() - parquetType.getScale();\n      int precisionIncrease = requestedType.precision() - parquetType.getPrecision();\n      return scaleIncrease >= 0 && precisionIncrease >= scaleIncrease;\n    } else if (typeAnnotation == null || isSignedIntAnnotation(typeAnnotation)) {\n      PrimitiveType.PrimitiveTypeName typeName =\n        descriptor.getPrimitiveType().getPrimitiveTypeName();\n      int integerPrecision = requestedType.precision() - requestedType.scale();\n      switch (typeName) {\n        case INT32:\n          return integerPrecision >= DecimalType$.MODULE$.IntDecimal().precision();\n        case INT64:\n          return integerPrecision >= DecimalType$.MODULE$.LongDecimal().precision();\n        default:\n          return false;\n      }\n    }\n    return false;\n  }",
    "comment": "If the required scale is larger than or equal to the physical decimal scale in the Parquet\nmetadata, we can upscale the value as long as the precision also increases by as much so\nthat there is no loss of precision.\nAllow reading signed integers (which may be un-annotated) as decimal as long as the\nrequested decimal type is large enough to represent all possible values."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaElementwiseProductExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaElementwiseProductExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(\"a\", Vectors.dense(1.0, 2.0, 3.0)),\n      RowFactory.create(\"b\", Vectors.dense(4.0, 5.0, 6.0))\n    );\n\n    List<StructField> fields = new ArrayList<>(2);\n    fields.add(DataTypes.createStructField(\"id\", DataTypes.StringType, false));\n    fields.add(DataTypes.createStructField(\"vector\", new VectorUDT(), false));\n\n    StructType schema = DataTypes.createStructType(fields);\n\n    Dataset<Row> dataFrame = spark.createDataFrame(data, schema);\n\n    Vector transformingVector = Vectors.dense(0.0, 1.0, 2.0);\n\n    ElementwiseProduct transformer = new ElementwiseProduct()\n      .setScalingVec(transformingVector)\n      .setInputCol(\"vector\")\n      .setOutputCol(\"transformedVector\");\n\n    transformer.transform(dataFrame).show();\n    spark.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nCreate some vector data; also works for sparse vectors\nBatch transform the vectors to create new column:\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/resolver/ArtifactResolutionResult.java",
    "type": "method",
    "name": "addVersionRangeViolation",
    "code": "public ArtifactResolutionResult addVersionRangeViolation(Exception e) {\n        versionRangeViolations = initList(versionRangeViolations);\n\n        versionRangeViolations.add(e);\n\n        exceptions = initList(exceptions);\n\n        exceptions.add(e);\n\n        return this;\n    }",
    "comment": "TODO this needs to accept a {@link OverConstrainedVersionException} as returned by\n{@link #getVersionRangeViolation(int)} but it's not used like that in\nDefaultLegacyArtifactCollector\n\n@param e an exception\n@return {@code this}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/stat/JavaKolmogorovSmirnovTestSuite.java",
    "type": "method",
    "name": "testKSTestCDF",
    "code": "public void testKSTestCDF() {\n    NormalDistribution stdNormalDist = new NormalDistribution(0, 1);\n\n    Long seed = 10L;\n    stdNormalDist.reseedRandomGenerator(seed);\n    Function<Double, Double> stdNormalCDF = (x) -> stdNormalDist.cumulativeProbability(x);\n\n    double pThreshold = 0.05;\n\n    Row results = KolmogorovSmirnovTest\n      .test(dataset, \"sample\", stdNormalCDF).head();\n    double pValue1 = results.getDouble(0);\n    Assertions.assertTrue(pValue1 > pThreshold);\n  }",
    "comment": "Create theoretical distributions\nset seeds\nComparing a standard normal sample to a standard normal distribution\nCannot reject null hypothesis"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/BloomFilter.java",
    "type": "method",
    "name": "optimalNumOfHashFunctions",
    "code": "private static int optimalNumOfHashFunctions(long n, long m) {\n    // (m / n) * log(2), but avoid truncation due to division!\n    return Math.max(1, (int) Math.round((double) m / n * Math.log(2)));\n  }",
    "comment": "Computes the optimal k (number of hashes per item inserted in Bloom filter), given the\nexpected insertions and total number of bits in the Bloom filter.\n\nSee http://en.wikipedia.org/wiki/File:Bloom_filter_fp_probability.svg for the formula.\n\n@param n expected insertions (must be positive)\n@param m total number of bits in Bloom filter (must be positive)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/JavaPathType.java",
    "type": "method",
    "name": "format",
    "code": "final String[] format(String moduleName, Iterable<? extends Path> paths) {\n        if (option == null) {\n            throw new IllegalStateException(\"No option is associated to this path type.\");\n        }\n        String prefix = (moduleName == null) ? \"\" : (moduleName + '=');\n        StringJoiner joiner = new StringJoiner(File.pathSeparator, prefix, \"\");\n        joiner.setEmptyValue(\"\");\n        for (Path p : paths) {\n            joiner.add(p.toString());\n        }\n        String value = joiner.toString();\n        if (value.isEmpty()) {\n            return new String[0];\n        }\n        return new String[] {option, value};\n\n    @Override\n    public String toString() {\n        return \"PathType[\" + id() + \"]\";\n    }\n\n    public final class Modular implements PathType {\n        @Nonnull\n        private final String moduleName;\n\n        private Modular(@Nonnull String moduleName) {\n            this.moduleName = Objects.requireNonNull(moduleName);\n        }\n\n        @Nonnull\n        public JavaPathType rawType() {\n            return JavaPathType.this;\n        }\n\n        @Override\n        public String id() {\n            return JavaPathType.this.name() + \":\" + moduleName;\n        }\n\n        @Nonnull\n        @Override\n        public String name() {\n            return JavaPathType.this.name();\n        }\n\n        @Nonnull\n        public String moduleName() {\n            return moduleName;\n        }\n\n        @Nonnull\n        @Override\n        public Optional<String> option() {\n            return JavaPathType.this.option();\n        }\n\n        @Nonnull\n        @Override\n        public String[] option(Iterable<? extends Path> paths) {\n            return format(moduleName, paths);\n        }\n\n        @Nonnull\n        @Override\n        public String toString() {\n            return \"PathType[\" + id() + \"]\";\n        }\n    }\n}",
    "comment": "Returns the programmatic name of this path type, including the module to patch.\nFor example, if this type was created by {@code JavaPathType.patchModule(\"foo.bar\")},\nthen this method returns {@code \"PathType[PATCH_MODULE:foo.bar]\")}.\n\n@return the programmatic name together with the module name on which it applies"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "build",
    "code": "public LauncherDiscoveryRequest build() {\n\t\tif (this.filterStandardClassNamePatterns && !this.includeClassNamePatternsUsed) {\n\t\t\tthis.delegate.filters(createIncludeClassNameFilter(STANDARD_INCLUDE_PATTERN));\n\t\t}\n\n\t\tif (this.enableParentConfigurationParameters && this.parentConfigurationParameters != null) {\n\t\t\tthis.delegate.parentConfigurationParameters(this.parentConfigurationParameters);\n\t\t}\n\n\t\treturn this.delegate.build();\n\t}",
    "comment": "Build the {@link LauncherDiscoveryRequest} that has been configured via\nthis builder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/component/src/main/java/com/iluwatar/component/GameObject.java",
    "type": "method",
    "name": "updateVelocity",
    "code": "public void updateVelocity(int acceleration) {\n    this.velocity += acceleration;\n  }",
    "comment": "Update the velocity based on the acceleration of the GameObject.\n\n@param acceleration the acceleration of the GameObject"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "numBytesForFirstByte",
    "code": "public static int numBytesForFirstByte(final byte b) {\n    final int offset = b & 0xFF;\n    byte numBytes = bytesOfCodePointInUTF8[offset];\n    return (numBytes == 0) ? 1: numBytes; // Skip the first byte disallowed in UTF-8\n  }",
    "comment": "Returns the number of bytes for a code point with the first byte as `b`\n@param b The first byte of a code point"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ProjectBuilderRequest.java",
    "type": "method",
    "name": "trace",
    "code": "public ProjectBuilderRequestBuilder trace(RequestTrace trace) {\n            this.trace = trace;\n            return this;\n        }",
    "comment": "Sets the request trace for this request.\nThe trace is used for debugging and monitoring purposes.\n\n@param trace the request trace\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/test/java/org/apache/spark/sql/hive/execution/UDFToListMapStringListInt.java",
    "type": "method",
    "name": "evaluate",
    "code": "public List<Map<String, List<Integer>>> evaluate(Object o) {\n    final Map<String, List<Integer>> map = new HashMap<>();\n    map.put(\"a\", Arrays.asList(1, 2));\n    map.put(\"b\", Arrays.asList(3, 4));\n    return Collections.singletonList(map);\n  }",
    "comment": "UDF that returns a nested list of maps that uses a string as its key and a list of ints as its\nvalues."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/api/plugin/ExecutorPlugin.java",
    "type": "method",
    "name": "init",
    "code": "default void init(PluginContext ctx, Map<String, String> extraConf) {}",
    "comment": "Initialize the executor plugin.\n<p>\nWhen a Spark plugin provides an executor plugin, this method will be called during the\ninitialization of the executor process. It will block executor initialization until it\nreturns.\n<p>\nExecutor plugins that publish metrics should register all metrics with the context's\nregistry ({@link PluginContext#metricRegistry()}) when this method is called. Metrics\nregistered afterwards are not guaranteed to show up.\n\n@param ctx Context information for the executor where the plugin is running.\n@param extraConf Extra configuration provided by the driver component during its\ninitialization."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/Promise.java",
    "type": "method",
    "name": "fulfillInAsync",
    "code": "public Promise<T> fulfillInAsync(final Callable<T> task, Executor executor) {\n    executor.execute(\n        () -> {\n          try {\n            fulfill(task.call());\n          } catch (Exception ex) {\n            fulfillExceptionally(ex);\n          }\n        });\n    return this;\n  }",
    "comment": "Executes the task using the executor in other thread and fulfills the promise returned once the\ntask completes either successfully or with an exception.\n\n@param task the task that will provide the value to fulfill the promise.\n@param executor the executor in which the task should be run.\n@return a promise that represents the result of running the task provided."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/VariableLengthRowBasedKeyValueBatch.java",
    "type": "method",
    "name": "getValueFromKey",
    "code": "public UnsafeRow getValueFromKey(int rowId) {\n    if (keyRowId != rowId) {\n      getKeyRow(rowId);\n    }\n    assert(rowId >= 0);\n    int uaoSize = UnsafeAlignedOffset.getUaoSize();\n    long offset = keyRow.getBaseOffset();\n    int klen = keyRow.getSizeInBytes();\n    int vlen = UnsafeAlignedOffset.getSize(base, offset - uaoSize * 2L) - klen - uaoSize;\n    valueRow.pointTo(base, offset + klen, vlen);\n    return valueRow;\n  }",
    "comment": "Returns the value row by two steps:\n1) looking up the key row with the same id (skipped if the key row is cached)\n2) retrieve the value row by reusing the metadata from step 1)\nIn most times, 1) is skipped because `getKeyRow(id)` is often called before `getValueRow(id)`."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/collector/PomlessCollectionStrategy.java",
    "type": "method",
    "name": "PomlessCollectionStrategy",
    "code": "public PomlessCollectionStrategy(ProjectBuilder projectBuilder) {\n        this.projectBuilder = projectBuilder;\n    }",
    "comment": "Strategy to collect projects for building when the Maven invocation is not in a directory that contains a pom.xml."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/ArtifactInstallerRequest.java",
    "type": "method",
    "name": "builder",
    "code": "static ArtifactInstallerRequestBuilder builder() {\n        return new ArtifactInstallerRequestBuilder();\n    }",
    "comment": "A request for installing one or more artifacts in the local repository.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Integer> create(int[][][][][][] data) {\n    return Tensor.create(data, Integer.class);\n  }",
    "comment": "Creates a rank-6 tensor of {@code int} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/main/java/com/iluwatar/RegisterWorkerService.java",
    "type": "method",
    "name": "registerWorker",
    "code": "public void registerWorker(RegisterWorkerDto registration) {\n    var cmd = new RegisterWorker(registration);\n    cmd.run();\n  }",
    "comment": "Creates and runs a command object to do the work needed, in this case, register a worker in the\nsystem.\n\n@param registration worker to be registered if possible"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/object-mother/src/main/java/com/iluwatar/objectmother/RoyaltyObjectMother.java",
    "type": "method",
    "name": "createHappyDrunkKing",
    "code": "public static King createHappyDrunkKing() {\n    var king = new King();\n    king.makeHappy();\n    king.makeDrunk();\n    return king;\n  }",
    "comment": "Method to create a happy and drunk king.\n\n@return A drunk and happy {@link com.iluwatar.objectmother.King}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/samples/money/Money.java",
    "type": "method",
    "name": "add",
    "code": "public IMoney add(IMoney m) {\n        return m.addMoney(this);\n    }",
    "comment": "Adds a money to this money. Forwards the request to the addMoney helper."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventStatistics.java",
    "type": "method",
    "name": "fileEntryPublished",
    "code": "public EventStatistics fileEntryPublished(long expected) {\n\t\tthis.executables.add(\n\t\t\t() -> assertEquals(expected, this.events.fileEntryPublished().count(), \"file entry published\"));\n\t\treturn this;\n\t}",
    "comment": "Specify the number of expected <em>file entry publication</em> events.\n\n@param expected the expected number of events\n@return this {@code EventStatistics} for method chaining\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/filter/Predicate.java",
    "type": "method",
    "name": "Predicate",
    "code": "public Predicate(String name, Expression[] children) {\n    super(name, children);\n  }",
    "comment": "The general representation of predicate expressions, which contains the upper-cased expression\nname and all the children expressions. You can also use these concrete subclasses for better\ntype safety: {@link And}, {@link Or}, {@link Not}, {@link AlwaysTrue}, {@link AlwaysFalse}.\n<p>\nThe currently supported predicate expressions:\n<ol>\n<li>Name: <code>IS_NULL</code>\n<ul>\n<li>SQL semantic: <code>expr IS NULL</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>IS_NOT_NULL</code>\n<ul>\n<li>SQL semantic: <code>expr IS NOT NULL</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>STARTS_WITH</code>\n<ul>\n<li>SQL semantic: <code>expr1 LIKE 'expr2%'</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>ENDS_WITH</code>\n<ul>\n<li>SQL semantic: <code>expr1 LIKE '%expr2'</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>CONTAINS</code>\n<ul>\n<li>SQL semantic: <code>expr1 LIKE '%expr2%'</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>IN</code>\n<ul>\n<li>SQL semantic: <code>expr IN (expr1, expr2, ...)</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>=</code>\n<ul>\n<li>SQL semantic: <code>expr1 = expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>&lt;&gt;</code>\n<ul>\n<li>SQL semantic: <code>expr1 &lt;&gt; expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>&lt;=&gt;</code>\n<ul>\n<li>SQL semantic: null-safe version of <code>expr1 = expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>&lt;</code>\n<ul>\n<li>SQL semantic: <code>expr1 &lt; expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>&lt;=</code>\n<ul>\n<li>SQL semantic: <code>expr1 &lt;= expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>&gt;</code>\n<ul>\n<li>SQL semantic: <code>expr1 &gt; expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>&gt;=</code>\n<ul>\n<li>SQL semantic: <code>expr1 &gt;= expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>AND</code>\n<ul>\n<li>SQL semantic: <code>expr1 AND expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>OR</code>\n<ul>\n<li>SQL semantic: <code>expr1 OR expr2</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>NOT</code>\n<ul>\n<li>SQL semantic: <code>NOT expr</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>ALWAYS_TRUE</code>\n<ul>\n<li>SQL semantic: <code>TRUE</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n<li>Name: <code>ALWAYS_FALSE</code>\n<ul>\n<li>SQL semantic: <code>FALSE</code></li>\n<li>Since version: 3.3.0</li>\n</ul>\n</li>\n</ol>\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "MapIterator",
    "code": "private MapIterator(int numRecords, Location loc, boolean destructive) {\n      this.numRecords = numRecords;\n      this.loc = loc;\n      this.destructive = destructive;\n      if (destructive) {\n        destructiveIterator = this;\n        if (longArray != null) {\n          freeArray(longArray);\n          longArray = null;\n        }\n      }\n    }",
    "comment": "If this iterator destructive or not. When it is true, it frees each page as it moves onto\nnext one.\nlongArray will not be used anymore if destructive is true, release it now."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java",
    "type": "method",
    "name": "getStuckThread",
    "code": "private Thread getStuckThread(Thread mainThread) {\n        List<Thread> threadsInGroup = getThreadsInGroup(mainThread.getThreadGroup());\n        if (threadsInGroup.isEmpty()) {\n            return null;\n        }\n\n        // Now that we have all the threads in the test's thread group: Assume that\n        // any thread we're \"stuck\" in is RUNNABLE.  Look for all RUNNABLE threads. \n        // If just one, we return that (unless it equals threadMain).  If there's more\n        // than one, pick the one that's using the most CPU time, if this feature is\n        // supported.\n        Thread stuckThread = null;\n        long maxCpuTime = 0;\n        for (Thread thread : threadsInGroup) {\n            if (thread.getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime(thread);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = thread;\n                    maxCpuTime = threadCpuTime;\n                }\n            }               \n        }\n        return (stuckThread == mainThread) ? null : stuckThread;\n    }",
    "comment": "Determines whether the test appears to be stuck in some thread other than\nthe \"main thread\" (the one created to run the test).  This feature is experimental.\nBehavior may change after the 4.12 release in response to feedback.\n@param mainThread The main thread created by {@code evaluate()}\n@return The thread which appears to be causing the problem, if different from\n{@code mainThread}, or {@code null} if the main thread appears to be the\nproblem or if the thread cannot be determined.  The return value is never equal\nto {@code mainThread}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Object expected, Object actual) {\n        assertEquals(null, expected, actual);\n    }",
    "comment": "Asserts that two objects are equal. If they are not\nan AssertionFailedError is thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.java",
    "type": "method",
    "name": "preDestroyTestInstances",
    "code": "static void preDestroyTestInstances(ExtensionContext context, Consumer<Object> callback) {\n\t\tList<Object> destroyedInstances = new ArrayList<>(context.getRequiredTestInstances().getAllInstances());\n\t\tfor (Optional<ExtensionContext> current = context.getParent(); current.isPresent(); current = current.get().getParent()) {\n\t\t\tcurrent.get().getTestInstances().map(TestInstances::getAllInstances).ifPresent(\n\t\t\t\tdestroyedInstances::removeAll);\n\t\t}\n\t\tCollections.reverse(destroyedInstances);\n\t\tdestroyedInstances.forEach(callback);\n\t}",
    "comment": "Utility method for processing <em>all</em> test instances of an\n{@link ExtensionContext} that are not present in any of its parent\ncontexts.\n\n<p>This method should be called in order to implement this interface\ncorrectly since it ensures that the right test instances are processed\nregardless of the used {@linkplain Lifecycle lifecycle}. The supplied\ncallback is called once per test instance that is about to be destroyed\nstarting with the innermost one.\n\n<p>This method is intended to be called from an implementation of\n{@link #preDestroyTestInstance(ExtensionContext)} like this:\n\n<pre>{@code class MyExtension implements TestInstancePreDestroyCallback {\n@Override\npublic void preDestroyTestInstance(ExtensionContext context) {\nTestInstancePreDestroyCallback.preDestroyTestInstances(context, testInstance -> {\n// custom logic that processes testInstance\n});\n}\n}}</pre>\n\n@param context the current extension context; never {@code null}\n@param callback the callback to be invoked for every test instance of the\ncurrent extension context that is about to be destroyed; never\n{@code null}\n@since 5.7.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/OrderController.java",
    "type": "method",
    "name": "OrderController",
    "code": "public OrderController(final ShoppingCartService shoppingCartUse) {\n    this.shoppingCartUseCase = shoppingCartUse;\n  }",
    "comment": "Constructs an {@code OrderController} with the given shopping cart service.\n\n@param shoppingCartUse The shopping cart service used to process orders."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/Expressions.java",
    "type": "method",
    "name": "months",
    "code": "public static Transform months(String column) {\n    return LogicalExpressions.months(Expressions.column(column));\n  }",
    "comment": "Create a monthly transform for a timestamp or date column.\n<p>\nThis transform represents a logical mapping from a timestamp or date to a month, such as\n2018-05.\n<p>\nThe name reported by transforms created with this method is \"months\".\n\n@param column an input timestamp or date column\n@return a logical monthly transform with name \"months\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java",
    "type": "method",
    "name": "after",
    "code": "public final void after(JupiterEngineExecutionContext context) {\n\n\t\tThrowableCollector throwableCollector = context.getThrowableCollector();\n\t\tThrowable previousThrowable = throwableCollector.getThrowable();\n\n\t\tif (context.beforeAllMethodsExecuted()) {\n\t\t\tinvokeAfterAllMethods(context);\n\t\t}\n\n\t\tif (context.beforeAllCallbacksExecuted()) {\n\t\t\tinvokeAfterAllCallbacks(context);\n\t\t}\n\n\t\tif (isPerClassLifecycle(context) && context.getExtensionContext().getTestInstance().isPresent()) {\n\t\t\tinvokeTestInstancePreDestroyCallbacks(context);\n\t\t}\n\n\t\tif (previousThrowable != throwableCollector.getThrowable()) {\n\t\t\tthrowableCollector.assertEmpty();\n\t\t}\n\t}",
    "comment": "If the previous Throwable was not null when this method was called,\nthat means an exception was already thrown either before or during\nthe execution of this Node. If an exception was already thrown, any\nlater exceptions were added as suppressed exceptions to that original\nexception unless a more severe exception occurred in the meantime."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/TimeMode.java",
    "type": "method",
    "name": "None",
    "code": "public static final TimeMode None() { return NoTime$.MODULE$; }",
    "comment": "Neither timers nor ttl is supported in this mode."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/props/MavenProperties.java",
    "type": "method",
    "name": "parseProperty",
    "code": "private static String[] parseProperty(String line) {\n            // sorry for this spaghetti code, please replace it as soon as\n            // possible with a regexp when the Java 1.3 requirement is dropped\n\n            String[] result = new String[2];\n            StringBuilder key = new StringBuilder();\n            StringBuilder value = new StringBuilder();\n\n            // state of the automaton:\n            // 0: key parsing\n            // 1: antislash found while parsing the key\n            // 2: separator crossing\n            // 3: white spaces\n            // 4: value parsing\n            int state = 0;\n\n            for (int pos = 0; pos < line.length(); pos++) {\n                char c = line.charAt(pos);\n\n                switch (state) {\n                    case 0:\n                        if (c == '\\\\') {\n                            state = 1;\n                        } else if (contains(WHITE_SPACE, c)) {\n                            // switch to the separator crossing state\n                            state = 2;\n                        } else if (contains(SEPARATORS, c)) {\n                            // switch to the value parsing state\n                            state = 3;\n                        } else {\n                            key.append(c);\n                        }\n\n                        break;\n\n                    case 1:\n                        if (contains(SEPARATORS, c) || contains(WHITE_SPACE, c)) {\n                            // this is an escaped separator or white space\n                            key.append(c);\n                        } else {\n                            // another escaped character, the '\\' is preserved\n                            key.append('\\\\');\n                            key.append(c);\n                        }\n\n                        // return to the key parsing state\n                        state = 0;\n\n                        break;\n\n                    case 2:\n                        if (contains(WHITE_SPACE, c)) {\n                            // do nothing, eat all white spaces\n                            state = 2;\n                        } else if (contains(SEPARATORS, c)) {\n                            // switch to the value parsing state\n                            state = 3;\n                        } else {\n                            // any other character indicates we encoutered the beginning of the value\n                            value.append(c);\n\n                            // switch to the value parsing state\n                            state = 4;\n                        }\n\n                        break;\n\n                    case 3:\n                        if (contains(WHITE_SPACE, c)) {\n                            // do nothing, eat all white spaces\n                            state = 3;\n                        } else {\n                            // any other character indicates we encoutered the beginning of the value\n                            value.append(c);\n\n                            // switch to the value parsing state\n                            state = 4;\n                        }\n\n                        break;\n\n                    case 4:\n                        value.append(c);\n                        break;\n\n                    default:\n                        throw new IllegalStateException();\n                }\n            }\n\n            result[0] = key.toString();\n            result[1] = value.toString();\n\n            return result;\n        }",
    "comment": "Parse a property line and return the key and the value in an array.\n\n@param line the line to parse\n@return an array with the property's key and value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "test",
    "code": "public static Condition<Event> test() {\n\t\treturn new Condition<>(byTestDescriptor(TestDescriptor::isTest), \"is a test\");\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\na {@linkplain TestDescriptor#isTest() test}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/main/java/com/iluwatar/health/check/GarbageCollectionHealthIndicator.java",
    "type": "method",
    "name": "health",
    "code": "public Health health() {\n    List<GarbageCollectorMXBean> gcBeans = getGarbageCollectorMxBeans();\n    List<MemoryPoolMXBean> memoryPoolMxBeans = getMemoryPoolMxBeans();\n    Map<String, Map<String, String>> gcDetails = new HashMap<>();\n\n    for (GarbageCollectorMXBean gcBean : gcBeans) {\n      Map<String, String> collectorDetails = createCollectorDetails(gcBean, memoryPoolMxBeans);\n      gcDetails.put(gcBean.getName(), collectorDetails);\n    }\n\n    return Health.up().withDetails(gcDetails).build();\n  }",
    "comment": "Performs a health check by gathering garbage collection metrics and evaluating the overall\nhealth of the garbage collection system.\n\n@return a {@link Health} object representing the health status of the garbage collection system"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java",
    "type": "method",
    "name": "prefix",
    "code": "private static UnaryOperator<String> prefix(String prefix, UnaryOperator<String> cb) {\n        return s -> {\n            String v = null;\n            if (s.startsWith(prefix)) {\n                v = cb.apply(s.substring(prefix.length()));\n            }\n            return v;\n        };\n    }",
    "comment": "----------------------------------------------------------------------\nI'm leaving the setting of system properties here as not to break\nthe SystemPropertyProfileActivator. This won't harm embedding. jvz.\n----------------------------------------------------------------------"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java",
    "type": "method",
    "name": "getRootCause",
    "code": "private static Throwable getRootCause(Throwable throwable, List<Throwable> causeChain) {\n\t\t// If we have already seen the current Throwable, that means we have\n\t\t// encountered recursion in the cause chain and therefore return the last\n\t\t// Throwable in the cause chain, which was the root cause before the recursion.\n\t\tif (causeChain.contains(throwable)) {\n\t\t\treturn causeChain.get(causeChain.size() - 1);\n\t\t}\n\t\tThrowable cause = throwable.getCause();\n\t\tif (cause == null) {\n\t\t\treturn throwable;\n\t\t}\n\t\t// Track current Throwable before recursing.\n\t\tcauseChain.add(throwable);\n\t\treturn getRootCause(cause, causeChain);\n\t}",
    "comment": "Get the root cause of the supplied {@link Throwable}, or the supplied\n{@link Throwable} if it has no cause."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/ProjectBuildList.java",
    "type": "method",
    "name": "ProjectBuildList",
    "code": "public ProjectBuildList(List<ProjectSegment> items) {\n        this.items = Collections.unmodifiableList(items);\n    }",
    "comment": "<p>\nA list of project segments, ordered so that all ProjectSegments from first TaskSegment come before any\nsubsequent TaskSegments.\n</p>\n<strong>Note:</strong> This interface is part of work in progress and can be changed or removed without notice.\n\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "Builder",
    "code": "private Builder(MetricRegistry registry) {\n            this.registry = registry;\n            this.tMax = 60;\n            this.dMax = 0;\n            this.rateUnit = TimeUnit.SECONDS;\n            this.durationUnit = TimeUnit.MILLISECONDS;\n            this.filter = MetricFilter.ALL;\n            this.executor = null;\n            this.shutdownExecutorOnStop = true;\n        }",
    "comment": "A builder for {@link GangliaReporter} instances. Defaults to using a {@code tmax} of {@code 60},\na {@code dmax} of {@code 0}, converting rates to events/second, converting durations to\nmilliseconds, and not filtering metrics."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestDescriptor.java",
    "type": "method",
    "name": "containsTests",
    "code": "static boolean containsTests(TestDescriptor testDescriptor) {\n\t\tPreconditions.notNull(testDescriptor, \"TestDescriptor must not be null\");\n\t\treturn testDescriptor.isTest() || testDescriptor.mayRegisterTests()\n\t\t\t\t|| testDescriptor.getChildren().stream().anyMatch(TestDescriptor::containsTests);\n\t}",
    "comment": "Determine if the supplied descriptor (or any of its descendants)\n{@linkplain TestDescriptor#isTest() is a test} or\n{@linkplain TestDescriptor#mayRegisterTests() may potentially register\ntests dynamically}.\n\n@param testDescriptor the {@code TestDescriptor} to check for tests; never\n{@code null}\n@return {@code true} if the descriptor is a test, contains tests, or may\nlater register tests dynamically"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java",
    "type": "method",
    "name": "message",
    "code": "public static Condition<Throwable> message(Predicate<String> expectedMessagePredicate) {\n\t\treturn new Condition<>(where(Throwable::getMessage, expectedMessagePredicate), \"message matches predicate\");\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if a\nthe supplied {@link Predicate}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(ClasspathRootSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link ClasspathRootSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java",
    "type": "method",
    "name": "configurationParameters",
    "code": "public Builder configurationParameters(Map<String, String> configurationParameters) {\n\t\t\tthis.requestBuilder.configurationParameters(configurationParameters);\n\t\t\treturn this;\n\t\t}",
    "comment": "Add all of the supplied <em>configuration parameters</em>.\n\n@param configurationParameters the map of configuration parameters to add;\nnever {@code null}\n@return this builder for method chaining\n@see #selectors(DiscoverySelector...)\n@see #filters(Filter...)\n@see #configurationParameter(String, String)\n@see #execute()\n@see org.junit.platform.engine.ConfigurationParameters"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "copyUTF8String",
    "code": "public UTF8String copyUTF8String(int start, int end) {\n    int len = end - start + 1;\n    byte[] newBytes = new byte[len];\n    copyMemory(base, offset + start, newBytes, BYTE_ARRAY_OFFSET, len);\n    return UTF8String.fromBytes(newBytes);\n  }",
    "comment": "Copy the bytes from the current UTF8String, and make a new UTF8String.\n@param start the start position of the current UTF8String in bytes.\n@param end the end position of the current UTF8String in bytes.\n@return a new UTF8String in the position of [start, end] of current UTF8String bytes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/ArrayComparisonFailure.java",
    "type": "method",
    "name": "ArrayComparisonFailure",
    "code": "public ArrayComparisonFailure(String message, AssertionError cause, int index) {\n        this.fMessage = message;\n        this.fCause = cause;\n        initCause(fCause);\n        addDimension(index);\n    }",
    "comment": "Construct a new <code>ArrayComparisonFailure</code> with an error text and the array's\ndimension that was not equal\n\n@param cause the exception that caused the array's content to fail the assertion test\n@param index the array position of the objects that are not equal.\n@see Assert#assertArrayEquals(String, Object[], Object[])"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Byte unexpected, Byte actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/filter/And.java",
    "type": "method",
    "name": "And",
    "code": "public And(Predicate left, Predicate right) {\n    super(\"AND\", new Predicate[]{left, right});\n\n  public Predicate left() { return (Predicate) children()[0]; }\n  public Predicate right() { return (Predicate) children()[1]; }\n}",
    "comment": "A predicate that evaluates to {@code true} iff both {@code left} and {@code right} evaluate to\n{@code true}.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultPathTranslator.java",
    "type": "method",
    "name": "alignToBaseDirectory",
    "code": "public String alignToBaseDirectory(String path, Path basedir) {\n        String result = path;\n\n        if (path != null && basedir != null) {\n            path = path.replace('\\\\', File.separatorChar).replace('/', File.separatorChar);\n\n            File file = new File(path);\n            if (file.isAbsolute()) {\n                // path was already absolute, just normalize file separator and we're done\n                result = file.getPath();\n            } else if (file.getPath().startsWith(File.separator)) {\n                // drive-relative Windows path, don't align with project directory but with drive root\n                result = file.getAbsolutePath();\n            } else {\n                // an ordinary relative path, align with project directory\n                result = basedir.resolve(path).normalize().toString();\n            }\n        }\n\n        return result;\n    }",
    "comment": "Resolves relative paths against a specific base directory."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/rules/MethodRulesTest.java",
    "type": "method",
    "name": "runsAllMethodRulesThatAreReturnedByMethods",
    "code": "public void runsAllMethodRulesThatAreReturnedByMethods() {\n        runCount = 0;\n        assertThat(testResult(HasMultipleMethodsReturningMethodRule.class), isSuccessful());\n        assertEquals(2, runCount);\n    }",
    "comment": "If there are multiple public methods annotated with @Rule returning a {@link MethodRule}\nthen all the rules returned should be run.\n\n<p>This case has been added with\n<a href=\"https://github.com/junit-team/junit4/issues/589\">Issue #589</a> -\nSupport @Rule for methods works only for TestRule but not for MethodRule"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/injection/sample/MapOfStringsParameterResolver.java",
    "type": "method",
    "name": "supportsParameter",
    "code": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\tType type = parameterContext.getParameter().getParameterizedType();\n\t\tif (!(type instanceof ParameterizedType)) {\n\t\t\treturn false;\n\t\t}\n\t\tType[] actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments();\n\t\tif (actualTypeArguments.length != 2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn actualTypeArguments[0] == String.class && actualTypeArguments[1] == String.class;\n\t}",
    "comment": "Example {@link ParameterResolver} that resolves {@code Map<String, String>} types.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-locator/src/main/java/com/iluwatar/servicelocator/InitContext.java",
    "type": "method",
    "name": "lookup",
    "code": "public Object lookup(String serviceName) {\n    if (serviceName.equals(\"jndi/serviceA\")) {\n      LOGGER.info(\"Looking up service A and creating new service for A\");\n      return new ServiceImpl(\"jndi/serviceA\");\n    } else if (serviceName.equals(\"jndi/serviceB\")) {\n      LOGGER.info(\"Looking up service B and creating new service for B\");\n      return new ServiceImpl(\"jndi/serviceB\");\n    } else {\n      return null;\n    }\n  }",
    "comment": "Perform the lookup based on the service name. The returned object will need to be cast into a\n{@link Service}\n\n@param serviceName a string\n@return an {@link Object}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<String> create(String data, java.nio.charset.Charset charset) {\n    return Tensor.create(data.getBytes(charset), String.class);\n  }",
    "comment": "Creates a scalar String tensor using a specified encoding.\n\n@param charset The encoding from String to bytes.\n@param data The string to put into the new scalar tensor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/OverlayView.java",
    "type": "method",
    "name": "addCallback",
    "code": "public void addCallback(final DrawCallback callback) {\n    callbacks.add(callback);\n  }",
    "comment": "Interface defining the callback for client classes."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "tryToReadFieldValue",
    "code": "public static <T> Try<Object> tryToReadFieldValue(Class<T> clazz, String fieldName, T instance) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notBlank(fieldName, \"Field name must not be null or blank\");\n\n\t\t// @formatter:off\n\t\treturn Try.call(() -> clazz.getDeclaredField(fieldName))\n\t\t\t\t.andThen(field -> tryToReadFieldValue(field, instance));\n\t\t// @formatter:on\n\t}",
    "comment": "Try to read the value of a potentially inaccessible or nonexistent field.\n\n<p>If the field does not exist or an exception occurs while reading it, a\nfailed {@link Try} is returned that contains the corresponding exception.\n\n@param clazz the class where the field is declared; never {@code null}\n@param fieldName the name of the field; never {@code null} or empty\n@param instance the instance from where the value is to be read; may\nbe {@code null} for a static field\n@since 1.4\n@see #tryToReadFieldValue(Field)\n@see #tryToReadFieldValue(Field, Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/AutoFitTextureView.java",
    "type": "method",
    "name": "AutoFitTextureView",
    "code": "public AutoFitTextureView(final Context context) {\n    this(context, null);\n  }",
    "comment": "A {@link TextureView} that can be adjusted to a specified aspect ratio."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java",
    "type": "method",
    "name": "isExternalRepo",
    "code": "static boolean isExternalRepo(ArtifactRepository originalRepository) {\n        try {\n            URL url = new URL(originalRepository.getUrl());\n            return !(isLocal(url.getHost()) || url.getProtocol().equals(\"file\"));\n        } catch (MalformedURLException e) {\n            // bad url just skip it here. It should have been validated already, but the wagon lookup will deal with it\n            return false;\n        }\n    }",
    "comment": "Checks the URL to see if this repository refers to an external repository\n\n@param originalRepository\n@return true if external."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Integer expected, Integer actual, String message) {\n\t\tAssertEquals.assertEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/repository/src/main/java/com/iluwatar/repository/AppConfig.java",
    "type": "method",
    "name": "dataSource",
    "code": "public DataSource dataSource() {\n    var basicDataSource = new BasicDataSource();\n    basicDataSource.setDriverClassName(\"org.h2.Driver\");\n    basicDataSource.setUrl(\"jdbc:h2:mem:databases-person\");\n    basicDataSource.setUsername(\"sa\");\n    basicDataSource.setPassword(\"sa\");\n    return basicDataSource;\n  }",
    "comment": "Creation of H2 db.\n\n@return A new Instance of DataSource"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-locator/src/main/java/com/iluwatar/servicelocator/ServiceCache.java",
    "type": "method",
    "name": "ServiceCache",
    "code": "public ServiceCache() {\n    serviceCache = new HashMap<>();\n  }",
    "comment": "The service cache implementation which will cache services that are being created. On first hit,\nthe cache will be empty and thus any service that is being requested, will be created fresh and\nthen placed into the cache map. On next hit, if same service name will be requested, it will be\nreturned from the cache"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/management/DefaultPluginManagementInjector.java",
    "type": "method",
    "name": "injectManagement",
    "code": "public void injectManagement(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\n        merger.mergeManagedBuildPlugins(model);\n    }",
    "comment": "Handles injection of plugin management into the model.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-xml/src/main/java/org/apache/maven/internal/xml/XmlNodeImpl.java",
    "type": "method",
    "name": "XmlNodeImpl",
    "code": "public XmlNodeImpl(String name) {\n        this(name, null, null, null, null);\n    }",
    "comment": "NOTE: remove all the util code in here when separated, this class should be pure data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Long> create(long data) {\n    return Tensor.create(data, Long.class);\n  }",
    "comment": "Creates a scalar tensor containing a single {@code long} element.\n\n@param data The value to put into the new scalar tensor."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/configuration/internal/DefaultBeanConfigurator.java",
    "type": "method",
    "name": "DefaultBeanConfigurator",
    "code": "public DefaultBeanConfigurator() {\n        converterLookup = new EnhancedConverterLookup();\n    }",
    "comment": "<strong>Warning:</strong> This is an internal class that is only public for technical reasons, it is not part of the\npublic API. In particular, this class can be changed or deleted without prior notice."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/DelegatingCatalogExtension.java",
    "type": "method",
    "name": "setDelegateCatalog",
    "code": "public final void setDelegateCatalog(CatalogPlugin delegate) {\n    this.delegate = delegate;\n  }",
    "comment": "A simple implementation of {@link CatalogExtension}, which implements all the catalog functions\nby calling the built-in session catalog directly. This is created for convenience, so that users\nonly need to override some methods where they want to apply custom logic. For example, they can\noverride {@code createTable}, do something else before calling {@code super.createTable}.\n\n@since 3.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/NioReactor.java",
    "type": "method",
    "name": "onChannelReadable",
    "code": "private void onChannelReadable(SelectionKey key) {\n    try {\n      var readObject = ((AbstractNioChannel) key.attachment()).read(key);\n      dispatchReadEvent(key, readObject);\n    } catch (IOException e) {\n      try {\n        key.channel().close();\n      } catch (IOException e1) {\n        LOGGER.error(\"error closing channel\", e1);\n      }\n    }\n  }",
    "comment": "reads the incoming data in context of reactor main loop. Can this be improved?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/internal/NonClosableMutableURLClassLoader.java",
    "type": "method",
    "name": "NonClosableMutableURLClassLoader",
    "code": "public NonClosableMutableURLClassLoader(ClassLoader parent) {\n    super(new URL[]{}, parent);\n\n  @Override\n  public void close() {}\n}",
    "comment": "This class loader cannot be closed (its `close` method is a no-op)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/DefaultArtifactRepository.java",
    "type": "method",
    "name": "find",
    "code": "public Artifact find(Artifact artifact) {\n        File artifactFile = new File(getBasedir(), pathOf(artifact));\n\n        artifact.setFile(artifactFile);\n\n        if (artifactFile.exists()) {\n            artifact.setResolved(true);\n        }\n\n        return artifact;\n    }",
    "comment": "We need to set the file here or the resolver will fail with an NPE, not fully equipped to deal\nwith multiple local repository implementations yet."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/ErrorCollector.java",
    "type": "method",
    "name": "checkSucceeds",
    "code": "public <T> T checkSucceeds(Callable<T> callable) {\n        try {\n            return callable.call();\n        } catch (AssumptionViolatedException e) {\n            AssertionError error = new AssertionError(\"Callable threw AssumptionViolatedException\");\n            error.initCause(e);\n            addError(error);\n            return null;\n        } catch (Throwable e) {\n            addError(e);\n            return null;\n        }\n    }",
    "comment": "Adds to the table the exception, if any, thrown from {@code callable}.\nExecution continues, but the test will fail at the end if\n{@code callable} threw an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/LevelDBTypeInfo.java",
    "type": "method",
    "name": "toKey",
    "code": "byte[] toKey(Object value, byte prefix) {\n      final byte[] result;\n\n      if (value instanceof String str) {\n        byte[] bytes = str.getBytes(UTF_8);\n        result = new byte[bytes.length + 1];\n        result[0] = prefix;\n        System.arraycopy(bytes, 0, result, 1, bytes.length);\n      } else if (value instanceof Boolean bool) {\n        result = new byte[] { prefix, bool ? TRUE : FALSE };\n        int length = Array.getLength(value);\n        byte[][] components = new byte[length][];\n        for (int i = 0; i < length; i++) {\n          components[i] = toKey(Array.get(value, i));\n        }\n        result = buildKey(false, components);\n      } else {\n        int bytes;\n\n        if (value instanceof Integer) {\n          bytes = Integer.SIZE;\n        } else if (value instanceof Long) {\n          bytes = Long.SIZE;\n        } else if (value instanceof Short) {\n          bytes = Short.SIZE;\n        } else if (value instanceof Byte) {\n          bytes = Byte.SIZE;\n        } else {\n          throw new IllegalArgumentException(String.format(\"Type %s not allowed as key.\",\n            value.getClass().getName()));\n        }\n\n        bytes = bytes / Byte.SIZE;\n\n        byte[] key = new byte[bytes * 2 + 2];\n        long longValue = ((Number) value).longValue();\n        key[0] = prefix;\n        key[1] = longValue >= 0 ? POSITIVE_MARKER : NEGATIVE_MARKER;\n\n        for (int i = 0; i < key.length - 2; i++) {\n          int masked = (int) ((longValue >>> (4 * i)) & 0xF);\n          key[key.length - i - 1] = HEX_BYTES[masked];\n        }\n\n        result = key;\n      }\n\n      return result;\n    }",
    "comment": "Translates a value to be used as part of the store key.\n\nIntegral numbers are encoded as a string in a way that preserves lexicographical\nordering. The string is prepended with a marker telling whether the number is negative\nor positive (\"*\" for negative and \"=\" for positive are used since \"-\" and \"+\" have the\nopposite of the desired order), and then the number is encoded into a hex string (so\nit occupies twice the number of bytes as the original type).\n\nArrays are encoded by encoding each element separately, separated by KEY_SEPARATOR."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelProcessor.java",
    "type": "method",
    "name": "setModelLocator",
    "code": "public DefaultModelProcessor setModelLocator(ModelLocator locator) {\n        this.locator = locator;\n        return this;\n    }",
    "comment": "Note: uses @Typed to limit the types it is available for injection to just ModelProcessor.\n\nThis is because the ModelProcessor interface extends ModelLocator and ModelReader. If we\nmade this component available under all its interfaces then it could end up being injected\ninto itself leading to a stack overflow.\n\nA side effect of using @Typed is that it translates to explicit bindings in the container.\nSo instead of binding the component under a 'wildcard' key it is now bound with an explicit\nkey. Since this is a default component, this will be a plain binding of ModelProcessor to\nthis implementation type; that is no hint/name.\n\nThis leads to a second side effect in that any @Inject request for just ModelProcessor in\nthe same injector is immediately matched to this explicit binding, which means extensions\ncannot override this binding. This is because the lookup is always short-circuited in this\nspecific situation (plain @Inject request, and plain explicit binding for the same type.)\n\nThe simplest solution is to use a custom @Named here so it isn't bound under the plain key.\nThis is only necessary for default components using @Typed that want to support overriding.\n\nAs a non-default component this now gets a negative priority relative to other implementations\nof the same interface. Since we want to allow overriding this doesn't matter in this case.\n(if it did we could add @Priority of 0 to match the priority given to default components.)\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/Trigger.java",
    "type": "method",
    "name": "Continuous",
    "code": "public static Trigger Continuous(long interval, TimeUnit timeUnit) {\n    return ContinuousTrigger.create(interval, timeUnit);\n  }",
    "comment": "A trigger that continuously processes streaming data, asynchronously checkpointing at\nthe specified interval.\n\n{{{\nimport java.util.concurrent.TimeUnit\ndf.writeStream.trigger(Trigger.Continuous(10, TimeUnit.SECONDS))\n}}}\n\n@since 2.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/promise/src/main/java/com/iluwatar/promise/Promise.java",
    "type": "method",
    "name": "onError",
    "code": "public Promise<T> onError(Consumer<? super Throwable> exceptionHandler) {\n    this.exceptionHandler = exceptionHandler;\n    return this;\n  }",
    "comment": "Set the exception handler on this promise.\n\n@param exceptionHandler a consumer that will handle the exception occurred while fulfilling the\npromise.\n@return this"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/bully/BullyInstance.java",
    "type": "method",
    "name": "handleHeartbeatInvokeMessage",
    "code": "protected void handleHeartbeatInvokeMessage() {\n    try {\n      boolean isLeaderAlive = messageManager.sendHeartbeatMessage(leaderId);\n      if (isLeaderAlive) {\n        LOGGER.info(INSTANCE + localId + \"- Leader is alive.\");\n        Thread.sleep(HEARTBEAT_INTERVAL);\n        messageManager.sendHeartbeatInvokeMessage(localId);\n      } else {\n        LOGGER.info(INSTANCE + localId + \"- Leader is not alive. Start election.\");\n        boolean electionResult =\n            messageManager.sendElectionMessage(localId, String.valueOf(localId));\n        if (electionResult) {\n          LOGGER.info(INSTANCE + localId + \"- Succeed in election. Start leader notification.\");\n          messageManager.sendLeaderMessage(localId, localId);\n        }\n      }\n    } catch (InterruptedException e) {\n      LOGGER.info(INSTANCE + localId + \"- Interrupted.\");\n    }\n  }",
    "comment": "Process the heartbeat invoke message. After receiving the message, the instance will send a\nheartbeat to leader to check its health. If alive, it will inform the next instance to do the\nheartbeat. If not, it will start the election process."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/converter/src/main/java/com/iluwatar/converter/Converter.java",
    "type": "method",
    "name": "convertFromEntity",
    "code": "public final T convertFromEntity(final U entity) {\n    return fromEntity.apply(entity);\n  }",
    "comment": "Converts Entity to DTO.\n\n@param entity domain entity\n@return The DTO representation - the result of the converting function application on domain\nentity."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/ProtoSession.java",
    "type": "method",
    "name": "newBuilder",
    "code": "static Builder newBuilder() {\n        return new Builder().withStartTime(MonotonicClock.now());\n    }",
    "comment": "Returns new builder from scratch."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(char[] expected, char[] actual, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} char arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/test/java/com/iluwatar/identitymap/PersonTest.java",
    "type": "method",
    "name": "testEquality",
    "code": "void testEquality() {\n    Person person1 = new Person(1, \"Harry\", 989950022);\n    Person person2 = new Person(2, \"Kane\", 989920011);\n    Assertions.assertNotEquals(person1, person2, \"Incorrect equality condition\");\n    Person person3 = new Person(2, \"John\", 789012211);\n    Assertions.assertEquals(person2, person3, \"Incorrect inequality condition\");\n  }",
    "comment": "dummy persons.\nperson with duplicate nationalID.\nIf nationalID is equal then persons are equal(even if name or phoneNum are different).\nThis situation will never arise in this implementation. Only for testing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java",
    "type": "method",
    "name": "validateZeroArgConstructor",
    "code": "protected void validateZeroArgConstructor(List<Throwable> errors) {\n        if (!getTestClass().isANonStaticInnerClass()\n                && hasOneConstructor()\n                && (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {\n            String gripe = \"Test class should have exactly one public zero-argument constructor\";\n            errors.add(new Exception(gripe));\n        }\n    }",
    "comment": "Adds to {@code errors} if the test class's single constructor takes\nparameters (do not override)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/Logger.java",
    "type": "method",
    "name": "log",
    "code": "default void log(@Nonnull Level level, @Nonnull String message) {\n        log(level, message, null);\n    }",
    "comment": "Logs a message at the specified level without an associated exception.\n\n@param level the severity level of the message\n@param message the message to be logged"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "fromAddress",
    "code": "public static UTF8String fromAddress(Object base, long offset, int numBytes) {\n    return new UTF8String(base, offset, numBytes);\n  }",
    "comment": "Creates an UTF8String from given address (base and offset) and length."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Short expected, short actual) {\n\t\tAssertEquals.assertEquals(expected, (Short) actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/BlacklistedExceptions.java",
    "type": "method",
    "name": "rethrowIfBlacklisted",
    "code": "public static void rethrowIfBlacklisted(Throwable exception) {\n\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(exception);\n\t}",
    "comment": "Rethrow the supplied {@link Throwable exception} if it is\n<em>unrecoverable</em>.\n\n<p>If the supplied {@code exception} is not <em>unrecoverable</em>, this\nmethod does nothing.\n\n@deprecated Use {@link UnrecoverableExceptions#rethrowIfUnrecoverable}\ninstead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/memory/HeapMemoryAllocator.java",
    "type": "method",
    "name": "shouldPool",
    "code": "private boolean shouldPool(long size) {\n    // Very small allocations are less likely to benefit from pooling.\n    return size >= POOLING_THRESHOLD_BYTES;\n  }",
    "comment": "Returns true if allocations of the given size should go through the pooling mechanism and\nfalse otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertionFailureBuilder.java",
    "type": "method",
    "name": "expected",
    "code": "public AssertionFailureBuilder expected(Object expected) {\n\t\tthis.mismatch = true;\n\t\tthis.expected = expected;\n\t\treturn this;\n\t}",
    "comment": "Set the expected value of the assertion.\n\n@param expected the expected value; may be {@code null}\n@return this builder for method chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/Size.java",
    "type": "method",
    "name": "parseFromString",
    "code": "public static Size parseFromString(String sizeString) {\n    if (TextUtils.isEmpty(sizeString)) {\n      return null;\n    }\n\n    sizeString = sizeString.trim();\n\n    final String[] components = sizeString.split(\"x\");\n    if (components.length == 2) {\n      try {\n        final int width = Integer.parseInt(components[0]);\n        final int height = Integer.parseInt(components[1]);\n        return new Size(width, height);\n      } catch (final NumberFormatException e) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }",
    "comment": "The expected format is \"<width>x<height>\"."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "getProperty",
    "code": "public String getProperty(String key, String defaultValue) {\n        if (this.get(key) != null) {\n            return this.get(key);\n        }\n        return defaultValue;\n    }",
    "comment": "Searches for the property with the specified key in this property list. If the key is not found in this property\nlist, the default property list, and its defaults, recursively, are then checked. The method returns the default\nvalue argument if the property is not found.\n\n@param key the property key.\n@param defaultValue a default value.\n@return The property value of the default value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectFile",
    "code": "public static FileSelector selectFile(String path) {\n\t\treturn selectFile(path, null);\n\t}",
    "comment": "Create a {@code FileSelector} for the supplied file path.\n\n<p>This method selects the file using the supplied path <em>as is</em>,\nwithout verifying if the file exists.\n\n@param path the path to the file to select; never {@code null} or blank\n@see FileSelector\n@see #selectFile(File)\n@see #selectFile(String, FilePosition)\n@see #selectFile(File, FilePosition)\n@see #selectDirectory(String)\n@see #selectDirectory(File)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/TransportConf.java",
    "type": "method",
    "name": "memoryMapBytes",
    "code": "public int memoryMapBytes() {\n    return Ints.checkedCast(JavaUtils.byteStringAsBytes(\n      conf.get(\"spark.storage.memoryMapThreshold\", \"2m\")));\n  }",
    "comment": "Minimum size of a block that we should start using memory map rather than reading in through\nnormal IO operations. This prevents Spark from memory mapping very small blocks. In general,\nmemory mapping has high overhead for blocks close to or below the page size of the OS."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/ExpectedException.java",
    "type": "method",
    "name": "none",
    "code": "public static ExpectedException none() {\n        return new ExpectedException();\n    }",
    "comment": "Returns a {@linkplain TestRule rule} that expects no exception to\nbe thrown (identical to behavior without this rule).\n\n@deprecated Since 4.13\n{@link org.junit.Assert#assertThrows(Class, org.junit.function.ThrowingRunnable)\nAssert.assertThrows} can be used to verify that your code throws a specific\nexception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-based-asynchronous/src/main/java/com/iluwatar/event/asynchronous/App.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n    var prop = new Properties();\n\n    var inputStream = App.class.getClassLoader().getResourceAsStream(PROP_FILE_NAME);\n\n    if (inputStream != null) {\n      try {\n        prop.load(inputStream);\n      } catch (IOException e) {\n        LOGGER.error(\"{} was not found. Defaulting to non-interactive mode.\", PROP_FILE_NAME, e);\n      }\n      var property = prop.getProperty(\"INTERACTIVE_MODE\");\n      if (property.equalsIgnoreCase(\"YES\")) {\n        interactiveMode = true;\n      }\n    }\n  }",
    "comment": "App can run in interactive mode or not. Interactive mode == Allow user interaction with command\nline. Non-interactive is a quick sequential run through the available {@link EventManager}\noperations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/FileSource.java",
    "type": "method",
    "name": "getPosition",
    "code": "public final Optional<FilePosition> getPosition() {\n\t\treturn Optional.ofNullable(this.filePosition);\n\t}",
    "comment": "Get the {@link FilePosition}, if available."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectorIdentifierParsers.java",
    "type": "method",
    "name": "parseAll",
    "code": "static Stream<? extends DiscoverySelector> parseAll(String... identifiers) {\n\t\tPreconditions.notNull(identifiers, \"identifiers must not be null\");\n\t\treturn Stream.of(identifiers) //\n\t\t\t\t.map(DiscoverySelectorIdentifierParsers::parse) //\n\t\t\t\t.filter(Optional::isPresent) //\n\t\t\t\t.map(Optional::get);\n\t}",
    "comment": "Utility class for parsing {@link DiscoverySelectorIdentifier\nDiscoverySelectorIdentifiers}.\n\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "test",
    "code": "public static Condition<Event> test(Condition<Event> condition) {\n\t\treturn allOf(test(), condition);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@linkplain Event#getTestDescriptor() test descriptor} is a\n{@linkplain TestDescriptor#isTest() test}.\n\n<p>For example, {@code test(displayName(\"my display name\"))} can be used\nto match against a test with the given display name.\n\n@since 1.8\n@see #test(String)\n@see #test(String, String)\n@see #displayName(String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/FileSource.java",
    "type": "method",
    "name": "from",
    "code": "public static FileSource from(File file, FilePosition filePosition) {\n\t\treturn new FileSource(file, filePosition);\n\t}",
    "comment": "Create a new {@code FileSource} using the supplied {@link File file} and\n\n@param file the source file; must not be {@code null}\n@param filePosition the position in the source file; may be {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "isInnerClass",
    "code": "public static boolean isInnerClass(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\treturn !isStatic(clazz) && clazz.isMemberClass();\n\t}",
    "comment": "Determine if the supplied class is an <em>inner class</em> (i.e., a\nnon-static member class).\n\n<p>Technically speaking (i.e., according to the Java Language\nSpecification), \"an inner class may be a non-static member class, a\nlocal class, or an anonymous class.\" However, this method does not\nreturn {@code true} for a local or anonymous class.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is an <em>inner class</em>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Float unexpected, float actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Float) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/main/java/com/example/android/observability/persistence/LocalUserDataSource.java",
    "type": "method",
    "name": "LocalUserDataSource",
    "code": "public LocalUserDataSource(UserDao userDao) {\n        mUserDao = userDao;\n    }",
    "comment": "Using the Room database as a data source."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-access-object/src/test/java/com/iluwatar/dao/InMemoryCustomerDaoTest.java",
    "type": "method",
    "name": "retriveShouldReturnTheCustomer",
    "code": "void retriveShouldReturnTheCustomer() {\n      var optionalCustomer = dao.getById(CUSTOMER.getId());\n\n      assertTrue(optionalCustomer.isPresent());\n      assertEquals(CUSTOMER, optionalCustomer.get());\n    }",
    "comment": "Represents the scenario when the DAO operations are being performed on an already existing\ncustomer."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testNormalize2",
    "code": "public void testNormalize2() {\n        Money expected = new Money(7, \"USD\");\n        assertEquals(expected, fMB1.subtract(f12CHF));\n    }",
    "comment": "{[12 CHF][7 USD]} - [12 CHF] == [7 USD]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Description.java",
    "type": "method",
    "name": "createTestDescription",
    "code": "public static Description createTestDescription(Class<?> clazz, String name, Annotation... annotations) {\n        return new Description(clazz, formatDisplayName(name, clazz.getName()), annotations);\n    }",
    "comment": "Create a <code>Description</code> of a single test named <code>name</code> in the class <code>clazz</code>.\nGenerally, this will be a leaf <code>Description</code>.\n\n@param clazz the class of the test\n@param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n@param annotations meta-data about the test, for downstream interpreters\n@return a <code>Description</code> named <code>name</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "setJavaHome",
    "code": "public SparkLauncher setJavaHome(String javaHome) {\n    checkNotNull(javaHome, \"javaHome\");\n    builder.javaHome = javaHome;\n    return this;\n  }",
    "comment": "Set a custom JAVA_HOME for launching the Spark application.\n\n@param javaHome Path to the JAVA_HOME to use.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/serialized-lob/src/main/java/com/iluwatar/slob/App.java",
    "type": "method",
    "name": "executeSerializer",
    "code": "private static void executeSerializer(Forest forest, LobSerializer lobSerializer) {\n    try (LobSerializer serializer = lobSerializer) {\n\n      Object serialized = serializer.serialize(forest);\n      int id = serializer.persistToDb(1, forest.getName(), serialized);\n\n      Object fromDb = serializer.loadFromDb(id, Forest.class.getSimpleName());\n      Forest forestFromDb = serializer.deSerialize(fromDb);\n\n      LOGGER.info(forestFromDb.toString());\n    } catch (SQLException\n        | IOException\n        | TransformerException\n        | ParserConfigurationException\n        | SAXException\n        | ClassNotFoundException e) {\n      throw new RuntimeException(e);\n    }\n  }",
    "comment": "Serialize the input object using the input serializer and persist to DB. After this it loads\nthe same object back from DB and deserializes using the same serializer.\n\n@param forest Object to Serialize and Persist\n@param lobSerializer Serializer to Serialize and Deserialize Object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetColumnVector.java",
    "type": "method",
    "name": "reset",
    "code": "void reset() {\n    // nothing to do if the column itself is missing\n    if (vector.isAllNull()) return;\n\n    vector.reset();\n    if (repetitionLevels != null) {\n      repetitionLevels.reset();\n    }\n    if (definitionLevels != null) {\n      definitionLevels.reset();\n    }\n    for (ParquetColumnVector child : children) {\n      child.reset();\n    }\n  }",
    "comment": "Resets this Parquet column vector, which includes resetting all the writable column vectors\n(used to store values, definition levels, and repetition levels) for this and all its children."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/requests/FilterRequest.java",
    "type": "method",
    "name": "FilterRequest",
    "code": "public FilterRequest(Request request, Filter filter) {\n        this.request = request;\n        this.fFilter = filter;\n    }",
    "comment": "Creates a filtered Request\n\n@param request a {@link Request} describing your Tests\n@param filter {@link Filter} to apply to the Tests described in\n<code>request</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/connector/spark-ganglia-lgpl/src/main/java/com/codahale/metrics/ganglia/GangliaReporter.java",
    "type": "method",
    "name": "shutdownExecutorOnStop",
    "code": "public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {\n            this.shutdownExecutorOnStop = shutdownExecutorOnStop;\n            return this;\n        }",
    "comment": "Specifies whether or not, the executor (used for reporting) will be stopped with same time with reporter.\nDefault value is true.\nSetting this parameter to false, has the sense in combining with providing external managed executor via {@link #scheduleOn(ScheduledExecutorService)}.\n\n@param shutdownExecutorOnStop if true, then executor will be stopped in same time with this reporter\n@return {@code this}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaPipelineExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaPipelineExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Prepare training documents, which are labeled.\n    Dataset<Row> training = spark.createDataFrame(Arrays.asList(\n      new JavaLabeledDocument(0L, \"a b c d e spark\", 1.0),\n      new JavaLabeledDocument(1L, \"b d\", 0.0),\n      new JavaLabeledDocument(2L, \"spark f g h\", 1.0),\n      new JavaLabeledDocument(3L, \"hadoop mapreduce\", 0.0)\n    ), JavaLabeledDocument.class);\n\n    // Configure an ML pipeline, which consists of three stages: tokenizer, hashingTF, and lr.\n    Tokenizer tokenizer = new Tokenizer()\n      .setInputCol(\"text\")\n      .setOutputCol(\"words\");\n    HashingTF hashingTF = new HashingTF()\n      .setNumFeatures(1000)\n      .setInputCol(tokenizer.getOutputCol())\n      .setOutputCol(\"features\");\n    LogisticRegression lr = new LogisticRegression()\n      .setMaxIter(10)\n      .setRegParam(0.001);\n    Pipeline pipeline = new Pipeline()\n      .setStages(new PipelineStage[] {tokenizer, hashingTF, lr});\n    // $example off$\n\n    spark.stop();\n  }",
    "comment": "Java example for simple text document 'Pipeline'."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/singleton/src/main/java/com/iluwatar/singleton/BillPughImplementation.java",
    "type": "method",
    "name": "getInstance",
    "code": "public static BillPughImplementation getInstance() {\n    return InstanceHolder.instance;\n  }",
    "comment": "Public accessor for the singleton instance.\n\n<p>When this method is called, the InstanceHolder is loaded into memory and creates the\nSingleton instance. This method provides a global access point for the singleton instance.\n\n@return an instance of the class."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Double> create(double[][][][] data) {\n    return Tensor.create(data, Double.class);\n  }",
    "comment": "Creates a rank-4 tensor of {@code double} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/SupportsPushDownTopN.java",
    "type": "method",
    "name": "isPartiallyPushed",
    "code": "default boolean isPartiallyPushed() { return true; }\n}",
    "comment": "Whether the top N is partially pushed or not. If it returns true, then Spark will do top N\nagain. This method will only be called when {@link #pushTopN} returns true."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java",
    "type": "method",
    "name": "include",
    "code": "public boolean include(Artifact artifact) {\n        String id = artifact.getGroupId() + \":\" + artifact.getArtifactId();\n\n        boolean matched = false;\n        for (Iterator<String> i = patterns.iterator(); i.hasNext() & !matched; ) {\n            if (id.equals(i.next())) {\n                matched = true;\n            }\n        }\n        return matched;\n    }",
    "comment": "TODO what about wildcards? Just specifying groups? versions?"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/KVStoreView.java",
    "type": "method",
    "name": "first",
    "code": "public KVStoreView<T> first(Object value) {\n    this.first = value;\n    return this;\n  }",
    "comment": "Iterates starting at the given value of the chosen index (inclusive)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/TestExecutionExceptionHandlerTests.java",
    "type": "method",
    "name": "resetStatics",
    "code": "void resetStatics() {\n\t\thandlerCalls.clear();\n\t\tRethrowException.handleExceptionCalled = false;\n\t\tConvertException.handleExceptionCalled = false;\n\t\tSwallowException.handleExceptionCalled = false;\n\t\tShouldNotBeCalled.handleExceptionCalled = false;\n\t}",
    "comment": "Integration tests that verify support for {@link TestExecutionExceptionHandler}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/master-worker/src/main/java/com/iluwatar/masterworker/Input.java",
    "type": "method",
    "name": "Input",
    "code": "public Input(T data) {\n    this.data = data;\n  }",
    "comment": "The abstract Input class, having 1 public field which contains input data, and abstract method\ndivideData.\n\n@param <T> T will be type of data."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/demo/app/src/main/java/com/example/android/tflitecamerademo/Camera2BasicFragment.java",
    "type": "method",
    "name": "showToast",
    "code": "private void showToast(String s) {\n    SpannableStringBuilder builder = new SpannableStringBuilder();\n    SpannableString str1 = new SpannableString(s);\n    builder.append(str1);\n    showToast(builder);\n  }",
    "comment": "Shows a {@link Toast} on the UI thread for the classification results.\n\n@param text The message to show"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProfileActivation.java",
    "type": "method",
    "name": "activateOptionalProfile",
    "code": "public void activateOptionalProfile(String id) {\n        this.activations.put(id, ActivationSettings.activatedOpt());\n    }",
    "comment": "Mark a profile as optional and activated.\n@param id The identifier of the profile."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/sqlite/java/com/example/android/persistence/migrations/UsersDbHelper.java",
    "type": "method",
    "name": "onDowngrade",
    "code": "public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n    }",
    "comment": "Not required as at version 1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/fusesource/jansi/Ansi.java",
    "type": "method",
    "name": "render",
    "code": "public Ansi render(final String text) {\n        a(new org.jline.jansi.Ansi().render(text).toString());\n        return this;\n    }",
    "comment": "Uses the {@link org.jline.jansi.AnsiRenderer}\nto generate the ANSI escape sequences for the supplied text.\n\n@param text text\n@return this\n@since 2.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/OnHeapColumnVector.java",
    "type": "method",
    "name": "OnHeapColumnVector",
    "code": "public OnHeapColumnVector(int capacity, DataType type) {\n    super(capacity, type);\n\n    reserveInternal(capacity);\n    reset();\n  }",
    "comment": "The data stored in these arrays need to maintain binary compatible. We can\ndirectly pass this buffer to external components.\nThis is faster than a boolean array and we optimize this over memory footprint.\nArray for each type. Only 1 is populated for any type.\nOnly set if type is Array or Map."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/sasl/ShuffleSecretManager.java",
    "type": "method",
    "name": "unregisterApp",
    "code": "public void unregisterApp(String appId) {\n    shuffleSecretMap.remove(appId);\n    logger.info(\"Unregistered shuffle secret for application {}\",\n      MDC.of(LogKeys.APP_ID$.MODULE$, appId));\n  }",
    "comment": "Unregister an application along with its secret.\nThis is called when the application terminates."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/lockable-object/src/main/java/com/iluwatar/lockableobject/domain/Creature.java",
    "type": "method",
    "name": "Creature",
    "code": "protected Creature(@NonNull String name) {\n    this.name = name;\n    this.instruments = new HashSet<>();\n  }",
    "comment": "An abstract class of a creature that wanders across the wasteland. It can attack, get hit and\nacquire a Lockable object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/test/java/com/iluwatar/async/method/invocation/ThreadAsyncExecutorTest.java",
    "type": "method",
    "name": "testEndProcess",
    "code": "void testEndProcess() {\n    assertTimeout(\n        ofMillis(5000),\n        () -> {\n          // Instantiate a new executor and start a new 'null' task ...\n          final var executor = new ThreadAsyncExecutor();\n\n          final var result = new Object();\n          when(task.call())\n              .thenAnswer(\n                  i -> {\n                    Thread.sleep(1500);\n                    return result;\n                  });\n\n          final var asyncResult = executor.startProcess(task);\n          assertNotNull(asyncResult);\n          assertFalse(asyncResult.isCompleted());\n\n          try {\n            asyncResult.getValue();\n            fail(\n                \"Expected IllegalStateException when calling AsyncResult#getValue on a non-completed task\");\n          } catch (IllegalStateException e) {\n            assertNotNull(e.getMessage());\n          }\n\n          assertSame(result, executor.endProcess(asyncResult));\n          verify(task, times(1)).call();\n          assertTrue(asyncResult.isCompleted());\n\n          // Calling end process a second time while already finished should give the same result\n          assertSame(result, executor.endProcess(asyncResult));\n          verifyNoMoreInteractions(task);\n        });\n  }",
    "comment": "Test used to verify the happy path of {@link ThreadAsyncExecutor#startProcess(Callable)} when a\ntask takes a while to execute, while waiting on the result using {@link\nThreadAsyncExecutor#endProcess(AsyncResult)}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProfileActivation.java",
    "type": "method",
    "name": "activateRequiredProfile",
    "code": "public void activateRequiredProfile(String id) {\n        this.activations.put(id, ActivationSettings.activated());\n    }",
    "comment": "Mark a profile as required and activated.\n@param id The identifier of the profile."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryRequestBuilder.java",
    "type": "method",
    "name": "build",
    "code": "public LauncherDiscoveryRequest build() {\n\t\tLauncherConfigurationParameters launcherConfigurationParameters = buildLauncherConfigurationParameters();\n\t\tLauncherDiscoveryListener discoveryListener = getLauncherDiscoveryListener(launcherConfigurationParameters);\n\t\tOutputDirectoryProvider outputDirectoryProvider = getOutputDirectoryProvider(launcherConfigurationParameters);\n\t\treturn new DefaultDiscoveryRequest(this.selectors, this.engineFilters, this.discoveryFilters,\n\t\t\tthis.postDiscoveryFilters, launcherConfigurationParameters, discoveryListener, outputDirectoryProvider);\n\t}",
    "comment": "Build the {@link LauncherDiscoveryRequest} that has been configured via\nthis builder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/TimSort.java",
    "type": "method",
    "name": "ensureCapacity",
    "code": "private Buffer ensureCapacity(int minCapacity) {\n      if (tmpLength < minCapacity) {\n        // Compute smallest power of 2 > minCapacity\n        int newSize = minCapacity;\n        newSize |= newSize >> 1;\n        newSize |= newSize >> 2;\n        newSize |= newSize >> 4;\n        newSize |= newSize >> 8;\n        newSize |= newSize >> 16;\n        newSize++;\n\n        if (newSize < 0) // Not bloody likely!\n          newSize = minCapacity;\n        else\n          newSize = Math.min(newSize, aLength >>> 1);\n\n        tmp = s.allocate(newSize);\n        tmpLength = newSize;\n      }\n      return tmp;\n    }",
    "comment": "Ensures that the external array tmp has at least the specified\nnumber of elements, increasing its size if necessary.  The size\nincreases exponentially to ensure amortized linear time complexity.\n\n@param minCapacity the minimum required capacity of the tmp array\n@return tmp, whether or not it grew"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/adapter/src/main/java/com/iluwatar/adapter/FishingBoat.java",
    "type": "method",
    "name": "sail",
    "code": "void sail() {\n    LOGGER.info(\"The fishing boat is sailing\");\n  }",
    "comment": "Device class (adaptee in the pattern). We want to reuse this class. Fishing boat moves by\nsailing."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/memory/SparkOutOfMemoryError.java",
    "type": "method",
    "name": "SparkOutOfMemoryError",
    "code": "public SparkOutOfMemoryError(String errorClass, Map<String, String> messageParameters) {\n        super(SparkThrowableHelper.getMessage(errorClass, messageParameters));\n        this.errorClass = errorClass;\n        this.messageParameters = messageParameters;\n    }",
    "comment": "This exception is thrown when a task can not acquire memory from the Memory manager.\nInstead of throwing {@link OutOfMemoryError}, which kills the executor,\nwe should use throw this exception, which just kills the current task."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/DependencyResolverRequest.java",
    "type": "method",
    "name": "pathTypeFilter",
    "code": "public DependencyResolverRequestBuilder pathTypeFilter(@Nonnull Collection<? extends PathType> desiredTypes) {\n            return pathTypeFilter(desiredTypes::contains);\n        }",
    "comment": "Specifies the type of paths to include in the result. This is a convenience method for\n{@link #pathTypeFilter(Predicate)} using {@link Collection#contains(Object)} as the filter.\n\n@param desiredTypes the type of paths to include in the result\n@return {@code this} for method call chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/dependency-injection/src/main/java/com/iluwatar/dependency/injection/GuiceWizard.java",
    "type": "method",
    "name": "GuiceWizard",
    "code": "public GuiceWizard(Tobacco tobacco) {\n    this.tobacco = tobacco;\n  }",
    "comment": "GuiceWizard implements inversion of control. Its dependencies are injected through its\nconstructor by Guice framework."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeWriter.java",
    "type": "method",
    "name": "write",
    "code": "public final void write(UnsafeArrayData array) {\n    int numBytes = array.getSizeInBytes();\n    grow(numBytes);\n    Platform.copyMemory(\n            array.getBaseObject(),\n            array.getBaseOffset(),\n            getBuffer(),\n            cursor(),\n            numBytes);\n    increaseCursor(numBytes);\n  }",
    "comment": "Unsafe arrays both can be written as a regular array field or as part of a map. This makes\nupdating the offset and size dependent on the code path, this is why we currently do not\nprovide an method for writing unsafe arrays that also updates the size and offset."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/runner/BaseTestRunner.java",
    "type": "method",
    "name": "getFilteredTrace",
    "code": "public static String getFilteredTrace(Throwable e) {\n        return BaseTestRunner.getFilteredTrace(Throwables.getStacktrace(e));\n    }",
    "comment": "Returns a filtered stack trace"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/repository/Proxy.java",
    "type": "method",
    "name": "setUserName",
    "code": "public void setUserName(String userName) {\n        this.userName = userName;\n    }",
    "comment": "Set the proxy username.\n\n@param userName username for the proxy server"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/test/java/com/iluwatar/identitymap/PersonFinderTest.java",
    "type": "method",
    "name": "personFoundInIdMap",
    "code": "void personFoundInIdMap() {\n    PersonFinder personFinder = new PersonFinder();\n    PersonDbSimulatorImplementation db = new PersonDbSimulatorImplementation();\n    Person person1 = new Person(1, \"John\", 27304159);\n    Person person2 = new Person(2, \"Thomas\", 42273631);\n    Person person3 = new Person(3, \"Arthur\", 27489171);\n    Person person4 = new Person(4, \"Finn\", 20499078);\n    Person person5 = new Person(5, \"Michael\", 40599078);\n    db.insert(person1);\n    db.insert(person2);\n    db.insert(person3);\n    db.insert(person4);\n    db.insert(person5);\n    personFinder.setDb(db);\n    Assertions.assertFalse(personFinder.getIdentityMap().getPersonMap().containsKey(3));\n    Assertions.assertEquals(person3, personFinder.getPerson(3), \"Finder returns incorrect record.\");\n    Assertions.assertTrue(personFinder.getIdentityMap().getPersonMap().containsKey(3));\n    Assertions.assertEquals(person3, personFinder.getPerson(3), \"Finder returns incorrect record.\");\n  }",
    "comment": "personFinderInstance\ninit database for our personFinder\nDummy persons\nAdd data to the database.\nAssure key is not in the ID map.\nAssure key is in the database.\nAssure that the record for this key is cached in the Map now.\nFind the record again. This time it will be found in the map."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/PrefixedObjectValueSource.java",
    "type": "method",
    "name": "PrefixedObjectValueSource",
    "code": "public PrefixedObjectValueSource(List<String> possiblePrefixes, Object root, boolean allowUnprefixedExpressions) {\n        super(new PrefixedValueSourceWrapper(\n                new ObjectBasedValueSource(root), possiblePrefixes, allowUnprefixedExpressions));\n    }",
    "comment": "Wrap the specified root object, allowing the specified list of expression\nprefixes and setting whether the {@link PrefixedValueSourceWrapper} allows\nunprefixed expressions.\n@param possiblePrefixes The possible prefixes.\n@param root The root of the graph.\n@param allowUnprefixedExpressions if we allow undefined expressions or not."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/Arguments.java",
    "type": "method",
    "name": "of",
    "code": "static Arguments of(Object... arguments) {\n\t\tPreconditions.notNull(arguments, \"arguments array must not be null\");\n\t\treturn () -> arguments;\n\t}",
    "comment": "Factory method for creating an instance of {@code Arguments} based on\nthe supplied {@code arguments}.\n\n@param arguments the arguments to be used for an invocation of the test\nmethod; must not be {@code null}\n@return an instance of {@code Arguments}; never {@code null}\n@see #arguments(Object...)\n@see #argumentSet(String, Object...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/internal/impl/DefaultPackagingRegistry.java",
    "type": "method",
    "name": "lookup",
    "code": "public Optional<Packaging> lookup(String id) {\n        id = id.toLowerCase(Locale.ROOT);\n        LifecycleMapping lifecycleMapping =\n                lookup.lookupOptional(LifecycleMapping.class, id).orElse(null);\n        if (lifecycleMapping == null) {\n            return Optional.empty();\n        }\n        Type type = typeRegistry.lookup(id).orElse(null);\n        if (type == null) {\n            return Optional.empty();\n        }\n        return Optional.of(new DefaultPackaging(id, type, getPlugins(lifecycleMapping)));\n    }",
    "comment": "TODO: we should be able to inject a Map<String, LifecycleMapping> directly,\nhowever, SISU visibility filtering can only happen when an explicit\nlookup is performed. The whole problem here is caused by \"project extensions\"\nwhich are bound to a project's classloader, without any clear definition\nof a \"project scope\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/MojoDescriptorCreator.java",
    "type": "method",
    "name": "if",
    "code": "if (numTokens >= 4) {\n            plugin = new Plugin();\n            plugin.setGroupId(tok[0]);\n            plugin.setArtifactId(tok[1]);\n            plugin.setVersion(tok[2]);\n            goal.append(tok[3]);\n\n            for (int idx = 4; idx < tok.length; idx++) {\n                goal.append(\":\").append(tok[idx]);\n            }\n        } else if (numTokens == 3) {\n\n            String firstToken = tok[0];\n            if (firstToken.contains(\".\")) {\n                plugin = new Plugin();\n                plugin.setGroupId(firstToken);\n                plugin.setArtifactId(tok[1]);\n            } else {\n                plugin = findPluginForPrefix(firstToken, session);\n                plugin.setVersion(tok[1]);\n            }\n            goal.append(tok[2]);\n        } else {\n            String prefix = tok[0];\n\n            if (numTokens == 2) {\n                goal.append(tok[1]);\n            }\n\n\n            plugin = findPluginForPrefix(prefix, session);\n        }",
    "comment": "org.apache.maven.plugins:maven-remote-resources-plugin:1.0:process@executionId\nWe have everything that we need\n\norg.apache.maven.plugins:maven-remote-resources-plugin:1.0:process\n\ngroupId\nartifactId\nversion\ngoal\n\nThis won't be valid, but it constructs something easy to read in the error message\ngroupId:artifactId:goal or pluginPrefix:version:goal (since Maven 3.9.0)\ngroupId or pluginPrefix? heuristics: groupId contains dot (.) but not pluginPrefix\nWe have everything that we need except the version\n\norg.apache.maven.plugins:maven-remote-resources-plugin:???:process\n\ngroupId\nartifactId\n???\ngoal\n\npluginPrefix:version:goal, like remote-resources:3.5.0:process\nWe have a prefix and goal\n\nidea:idea\n\nThis is the case where someone has executed a single goal from the command line\nof the form:\n\nmvn remote-resources:process\n\nFrom the metadata stored on the server which has been created as part of a standard\nMaven plugin deployment we will find the right PluginDescriptor from the remote\nrepository."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/JdkVersionProfileActivator.java",
    "type": "method",
    "name": "isActive",
    "code": "public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        Activation activation = profile.getActivation();\n\n        if (activation == null) {\n            return false;\n        }\n\n        String jdk = activation.getJdk();\n\n        if (jdk == null) {\n            return false;\n        }\n\n        String version = context.getSystemProperty(\"java.version\");\n\n        if (version == null || version.isEmpty()) {\n            problems.add(\n                    BuilderProblem.Severity.ERROR,\n                    ModelProblem.Version.BASE,\n                    \"Failed to determine Java version for profile \" + profile.getId(),\n                    activation.getLocation(\"jdk\"));\n            return false;\n        }\n        try {\n            return isJavaVersionCompatible(jdk, version);\n        } catch (NumberFormatException e) {\n            problems.add(\n                    BuilderProblem.Severity.WARNING,\n                    ModelProblem.Version.BASE,\n                    \"Failed to determine JDK activation for profile \" + profile.getId() + \" due invalid JDK version: '\"\n                            + version + \"'\",\n                    profile.getLocation(\"jdk\"));\n            return false;\n        }\n    }",
    "comment": "Determines profile activation based on the version of the current Java runtime.\n\n@see Activation#getJdk()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/AbstractModelBuildingListener.java",
    "type": "method",
    "name": "buildExtensionsAssembled",
    "code": "public void buildExtensionsAssembled(ModelBuildingEvent event) {\n        // default does nothing\n    }",
    "comment": "Provides a skeleton implementation for model building listeners. The methods of this class are empty.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/graph/DefaultGraphBuilder.java",
    "type": "method",
    "name": "DefaultGraphBuilder",
    "code": "public DefaultGraphBuilder() {\n        this(null, null, null, null);\n    }",
    "comment": "@deprecated Use {@link #DefaultGraphBuilder(BuildResumptionDataRepository, PomlessCollectionStrategy,\nMultiModuleCollectionStrategy, RequestPomCollectionStrategy)} instead or rely on JSR 330"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultLifecycleMappingDelegate.java",
    "type": "method",
    "name": "DefaultLifecycleMappingDelegate",
    "code": "public DefaultLifecycleMappingDelegate(BuildPluginManager pluginManager) {\n        this.pluginManager = pluginManager;\n    }",
    "comment": "Lifecycle mapping delegate component interface. Calculates project build execution plan given {@link Lifecycle} and\nlifecycle phase. Standard lifecycles use plugin execution {@code <phase>} or mojo default lifecycle phase to\ncalculate the execution plan, but custom lifecycles can use alternative mapping strategies."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(char[] expected, char[] actual) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} char arrays are equal.\n<p>If both are {@code null}, they are considered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/LifecyclePluginResolver.java",
    "type": "method",
    "name": "LifecyclePluginResolver",
    "code": "public LifecyclePluginResolver(PluginVersionResolver pluginVersionResolver) {\n        this.pluginVersionResolver = pluginVersionResolver;\n    }",
    "comment": "<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n@since 3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/NativeInterpreterWrapper.java",
    "type": "method",
    "name": "allocateTensorsIfNeeded",
    "code": "private boolean allocateTensorsIfNeeded() {\n    if (isMemoryAllocated) {\n      return false;\n    }\n\n    isMemoryAllocated = true;\n    allocateTensors(interpreterHandle, errorHandle);\n    for (TensorImpl outputTensor : outputTensors) {\n      if (outputTensor != null) {\n        outputTensor.refreshShape();\n      }\n    }\n    return true;\n  }",
    "comment": "Allocates tensor memory space in the given subgraph and returns true when allocation happens"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/ParquetAvroCompat.java",
    "type": "method",
    "name": "getSchema",
    "code": "public org.apache.avro.Schema getSchema() { return SCHEMA$; }\n  public java.lang.Object get(int field$) {\n    switch (field$) {\n    case 0: return strings_column;\n    case 1: return string_to_int_column;\n    case 2: return complex_column;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
    "comment": "Used by DatumWriter.  Applications should not call."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/support/conversion/ConversionSupportTests.java",
    "type": "method",
    "name": "isAwareOfNull",
    "code": "void isAwareOfNull() {\n\t\tassertConverts(null, Object.class, null);\n\t\tassertConverts(null, String.class, null);\n\t\tassertConverts(null, Boolean.class, null);\n\t}",
    "comment": "Unit tests for {@link ConversionSupport}.\n\n@since 5.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/NewestConflictResolverTest.java",
    "type": "method",
    "name": "testEqual",
    "code": "void testEqual() {\n        ResolutionNode a1n = createResolutionNode(a1);\n        ResolutionNode a2n = createResolutionNode(a2);\n\n        assertResolveConflict(a2n, a1n, a2n);\n    }",
    "comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\na:1.0\na:2.0\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-driven-architecture/src/main/java/com/iluwatar/eda/framework/EventDispatcher.java",
    "type": "method",
    "name": "dispatch",
    "code": "public <E extends Event> void dispatch(E event) {\n    var handler = (Handler<E>) handlers.get(event.getClass());\n    if (handler != null) {\n      handler.onEvent(event);\n    }\n  }",
    "comment": "Dispatches an {@link Event} depending on its type.\n\n@param event The {@link Event} to be dispatched"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/inheritance/DefaultInheritanceAssembler.java",
    "type": "method",
    "name": "getChildPathAdjustment",
    "code": "private String getChildPathAdjustment(Model child, Model parent, String childDirectory) {\n        String adjustment = \"\";\n\n        if (parent != null) {\n            String childName = child.getArtifactId();\n\n            /*\n             * This logic (using filesystem, against wanted independence from the user environment) exists only for the\n             * sake of backward-compat with 2.x (MNG-5000). In general, it is wrong to\n             * base URL inheritance on the module directory names as this information is unavailable for POMs in the\n             * repository. In other words, modules where artifactId != moduleDirName will see different effective URLs\n             * depending on how the model was constructed (from filesystem or from repository).\n             */\n            if (child.getProjectDirectory() != null) {\n                childName = child.getProjectDirectory().getName();\n            }\n\n            for (String module : parent.getModules()) {\n                module = module.replace('\\\\', '/');\n\n                if (module.regionMatches(true, module.length() - 4, \".xml\", 0, 4)) {\n                    module = module.substring(0, module.lastIndexOf('/') + 1);\n                }\n\n                String moduleName = module;\n                if (moduleName.endsWith(\"/\")) {\n                    moduleName = moduleName.substring(0, moduleName.length() - 1);\n                }\n\n                int lastSlash = moduleName.lastIndexOf('/');\n\n                moduleName = moduleName.substring(lastSlash + 1);\n\n                if ((moduleName.equals(childName) || (moduleName.equals(childDirectory))) && lastSlash >= 0) {\n                    adjustment = module.substring(0, lastSlash);\n                    break;\n                }\n            }\n        }\n\n        return adjustment;\n    }",
    "comment": "Calculates the relative path from the base directory of the parent to the parent directory of the base directory\nof the child. The general idea is to adjust inherited URLs to match the project layout (in SCM).\n\n<p>This calculation is only a heuristic based on our conventions.\nIn detail, the algo relies on the following assumptions: <ul>\n<li>The parent uses aggregation and refers to the child via the modules section</li>\n<li>The module path to the child is considered to\npoint at the POM rather than its base directory if the path ends with \".xml\" (ignoring case)</li>\n<li>The name of the child's base directory matches the artifact id of the child.</li>\n</ul>\nNote that for the sake of independence from the user\nenvironment, the filesystem is intentionally not used for the calculation.</p>\n\n@param child The child model, must not be <code>null</code>.\n@param parent The parent model, may be <code>null</code>.\n@param childDirectory The directory defined in child model, may be <code>null</code>.\n@return The path adjustment, can be empty but never <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/resolver/validator/MavenValidator.java",
    "type": "method",
    "name": "containsPlaceholder",
    "code": "protected boolean containsPlaceholder(String value) {\n        return value != null && value.contains(\"${\");\n    }\n\n    @Override\n    public void validateArtifact(Artifact artifact) throws IllegalArgumentException {\n        if (containsPlaceholder(artifact.getGroupId())\n                || containsPlaceholder(artifact.getArtifactId())\n                || containsPlaceholder(artifact.getVersion())\n                || containsPlaceholder(artifact.getClassifier())\n                || containsPlaceholder(artifact.getExtension())) {\n            throw new IllegalArgumentException(\"Not fully interpolated artifact \" + artifact);\n        }\n    }\n\n    @Override\n    public void validateMetadata(Metadata metadata) throws IllegalArgumentException {\n        if (containsPlaceholder(metadata.getGroupId())\n                || containsPlaceholder(metadata.getArtifactId())\n                || containsPlaceholder(metadata.getVersion())\n                || containsPlaceholder(metadata.getType())) {\n            throw new IllegalArgumentException(\"Not fully interpolated metadata \" + metadata);\n        }\n    }\n\n    @Override\n    public void validateDependency(Dependency dependency) throws IllegalArgumentException {\n        Artifact artifact = dependency.getArtifact();\n        if (containsPlaceholder(artifact.getGroupId())\n                || containsPlaceholder(artifact.getArtifactId())\n                || containsPlaceholder(artifact.getVersion())\n                || containsPlaceholder(artifact.getClassifier())\n                || containsPlaceholder(artifact.getExtension())\n                || containsPlaceholder(dependency.getScope())\n                || dependency.getExclusions().stream()\n                        .anyMatch(e -> containsPlaceholder(e.getGroupId())\n                                || containsPlaceholder(e.getArtifactId())\n                                || containsPlaceholder(e.getClassifier())\n                                || containsPlaceholder(e.getExtension()))) {\n            throw new IllegalArgumentException(\"Not fully interpolated dependency \" + dependency);\n        }\n    }\n\n    @Override\n    public void validateLocalRepository(LocalRepository localRepository) throws IllegalArgumentException {\n        if (containsPlaceholder(localRepository.getBasePath().toString())\n                || containsPlaceholder(localRepository.getContentType())\n                || containsPlaceholder(localRepository.getId())) {\n            throw new IllegalArgumentException(\"Not fully interpolated local repository \" + localRepository);\n        }\n    }\n\n    @Override\n    public void validateRemoteRepository(RemoteRepository remoteRepository) throws IllegalArgumentException {\n        if (containsPlaceholder(remoteRepository.getUrl())\n                || containsPlaceholder(remoteRepository.getContentType())\n                || containsPlaceholder(remoteRepository.getId())) {\n            throw new IllegalArgumentException(\"Not fully interpolated remote repository \" + remoteRepository);\n        }\n    }\n}",
    "comment": "Simplest Maven specific validator that is meant to prevent un-interpolated\nelements enter resolver; if it does, is most likely some bug."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "closeCamera",
    "code": "private void closeCamera() {\n    try {\n      cameraOpenCloseLock.acquire();\n      if (null != captureSession) {\n        captureSession.close();\n        captureSession = null;\n      }\n      if (null != cameraDevice) {\n        cameraDevice.close();\n        cameraDevice = null;\n      }\n      if (null != previewReader) {\n        previewReader.close();\n        previewReader = null;\n      }\n    } catch (final InterruptedException e) {\n      throw new RuntimeException(\"Interrupted while trying to lock camera closing.\", e);\n    } finally {\n      cameraOpenCloseLock.release();\n    }\n  }",
    "comment": "Closes the current {@link CameraDevice}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getType",
    "code": "public Type getType() {\n    return VariantUtil.getType(value, pos);\n  }",
    "comment": "Get the value type of the variant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/test/java/com/iluwatar/RegisterWorkerFormTest.java",
    "type": "method",
    "name": "submitWithErrors",
    "code": "void submitWithErrors() {\n    registerWorkerForm = new RegisterWorkerForm(null, null, null);\n\n    registerWorkerForm.submit();\n\n    assertNull(registerWorkerForm.worker.getName());\n    assertNull(registerWorkerForm.worker.getOccupation());\n    assertNull(registerWorkerForm.worker.getDateOfBirth());\n\n    assertEquals(registerWorkerForm.worker.getNotification().getErrors().size(), 4);\n  }",
    "comment": "Set up the worker with a notification containing errors\nSubmit the form\nVerify that the worker's properties remain unchanged\nVerify the presence of errors"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/properties/internal/EnvironmentUtils.java",
    "type": "method",
    "name": "addEnvVars",
    "code": "public static void addEnvVars(Properties props) {\n        if (props != null) {\n            if (envVars == null) {\n                Properties tmp = new Properties();\n                boolean caseSensitive = !Os.IS_WINDOWS;\n                for (Map.Entry<String, String> entry : System.getenv().entrySet()) {\n                    String key = \"env.\"\n                            + (caseSensitive ? entry.getKey() : entry.getKey().toUpperCase(Locale.ENGLISH));\n                    tmp.setProperty(key, entry.getValue());\n                }\n                envVars = tmp;\n            }\n\n            props.putAll(envVars);\n        }\n    }",
    "comment": "Adds the environment variables in the form of properties whose keys are prefixed with {@code env.}, e.g. {@code\nenv.PATH}. Unlike native environment variables, properties are always case-sensitive. For the sake of\ndeterminism, the environment variable names will be normalized to upper case on platforms with case-insensitive\nvariable lookup.\n\n@param props The properties to add the environment variables to, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassNamePatternFilterUtils.java",
    "type": "method",
    "name": "excludeMatchingClasses",
    "code": "public static <T> Predicate<T> excludeMatchingClasses(String patterns) {\n\t\treturn matchingClasses(patterns, object -> object.getClass().getName(), FilterType.EXCLUDE);\n\t}",
    "comment": "Create a {@link Predicate} that can be used to exclude (i.e., filter out)\nobjects of type {@code T} whose fully qualified class names match any of\nthe supplied patterns.\n\n@param patterns a comma-separated list of patterns"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensor.java",
    "type": "method",
    "name": "if",
    "code": "private static Tensor<?> create(Object obj, DataType dtype) {\n    @SuppressWarnings(\"rawtypes\")\n    Tensor<?> t = new Tensor(dtype);\n    t.shapeCopy = new long[numDimensions(obj, dtype)];\n    fillShape(obj, 0, t.shapeCopy);\n    long nativeHandle;\n    if (t.dtype != DataType.STRING) {\n      int byteSize = elemByteSize(t.dtype) * numElements(t.shapeCopy);\n      nativeHandle = allocate(t.dtype.c(), t.shapeCopy, byteSize);\n      setValue(nativeHandle, obj);\n    } else if (t.shapeCopy.length != 0) {\n      nativeHandle = allocateNonScalarBytes(t.shapeCopy, (Object[]) obj);\n    } else {\n      nativeHandle = allocateScalarBytes((byte[]) obj);\n    }\n    t.nativeRef = new NativeReference(nativeHandle);\n    return t;\n  }",
    "comment": "Create a Tensor of data type {@code dtype} from a Java object. Requires the parameter {@code T}\nto match {@code type}, but this condition is not checked.\n\n@param obj the object supplying the tensor data.\n@param dtype the data type of the tensor to create. It must be compatible with the run-time\ntype of the object.\n@return the new tensor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/circuit-breaker/src/main/java/com/iluwatar/circuitbreaker/DelayedRemoteService.java",
    "type": "method",
    "name": "DelayedRemoteService",
    "code": "public DelayedRemoteService(long serverStartTime, int delay) {\n    this.serverStartTime = serverStartTime;\n    this.delay = delay;\n  }",
    "comment": "Constructor to create an instance of DelayedService, which is down for first few seconds.\n\n@param delay the delay after which service would behave properly, in seconds"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/util/NettyUtils.java",
    "type": "method",
    "name": "defaultNumThreads",
    "code": "public static int defaultNumThreads(int numUsableCores) {\n    final int availableCores;\n    if (numUsableCores > 0) {\n      availableCores = numUsableCores;\n    } else {\n      availableCores = Runtime.getRuntime().availableProcessors();\n    }\n    return Math.min(availableCores, MAX_DEFAULT_NETTY_THREADS);\n  }",
    "comment": "Returns the default number of threads for both the Netty client and server thread pools.\nIf numUsableCores is 0, we will use Runtime get an approximate number of available cores."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "soundex",
    "code": "public UTF8String soundex() {\n    if (numBytes == 0) {\n      return EMPTY_UTF8;\n    }\n\n    byte b = getByte(0);\n    if ('a' <= b && b <= 'z') {\n      b -= 32;\n    } else if (b < 'A' || 'Z' < b) {\n      // first character must be a letter\n      return this;\n    }\n    byte[] sx = {'0', '0', '0', '0'};\n    sx[0] = b;\n    int sxi = 1;\n    int idx = b - 'A';\n    byte lastCode = US_ENGLISH_MAPPING[idx];\n\n    for (int i = 1; i < numBytes; i++) {\n      b = getByte(i);\n      if ('a' <= b && b <= 'z') {\n        b -= 32;\n      } else if (b < 'A' || 'Z' < b) {\n        // not a letter, skip it\n        lastCode = '0';\n        continue;\n      }\n      idx = b - 'A';\n      byte code = US_ENGLISH_MAPPING[idx];\n      if (code == '7') {\n        // ignore it\n      } else {\n        if (code != '0' && code != lastCode) {\n          sx[sxi++] = code;\n          if (sxi > 3) break;\n        }\n        lastCode = code;\n      }\n    }\n    return UTF8String.fromBytes(sx);\n  }",
    "comment": "Encodes a string into a Soundex value. Soundex is an encoding used to relate similar names,\nbut can also be used as a general purpose scheme to find word with similar phonemes.\nhttps://en.wikipedia.org/wiki/Soundex"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "success",
    "code": "default MessageBuilder success(Object message) {\n        return style(\".\" + Constants.MAVEN_STYLE_SUCCESS_NAME + \":-\" + Constants.MAVEN_STYLE_SUCCESS_DEFAULT, message);\n    }",
    "comment": "Append message content in success style.\nBy default, bold green\n\n@param message the message to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java",
    "type": "method",
    "name": "suppressed",
    "code": "public static Condition<Throwable> suppressed(int index, Condition<Throwable>... conditions) {\n\t\tList<Condition<Throwable>> list = Arrays.stream(conditions)//\n\t\t\t\t.map(condition -> suppressed(index, condition))//\n\t\t\t\t.collect(toList());\n\n\t\treturn Assertions.allOf(list);\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if a\nthrowable} at the supplied index matches all supplied conditions.\n\n@see #cause(Condition...)\n@see #rootCause(Condition...)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Long> create(Scope scope, long[] shape, LongBuffer data) {\n    try (Tensor<Long> value = Tensor.create(shape, data)) {\n      return createWithTensor(scope, value);\n    }\n  }",
    "comment": "Create a {@link DataType#INT64} constant with data from the given buffer.\n\n<p>Creates a constant with the given shape by copying elements from the buffer (starting from\nits current position) into the tensor. For example, if {@code shape = {2,3} } (which represents\na 2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param scope is a scope used to add the underlying operation.\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@return a long constant\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestResult.java",
    "type": "method",
    "name": "stop",
    "code": "public synchronized void stop() {\n        fStop = true;\n    }",
    "comment": "Marks that the test run should stop."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/ml/regression/JavaRandomForestRegressorSuite.java",
    "type": "method",
    "name": "runDT",
    "code": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 0);\n\n    RandomForestRegressor rf = new RandomForestRegressor()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setSubsamplingRate(1.0)\n      .setSeed(1234)\n      .setNumTrees(3)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String impurity : RandomForestRegressor.supportedImpurities()) {\n      rf.setImpurity(impurity);\n    }\n    for (String featureSubsetStrategy : RandomForestRegressor.supportedFeatureSubsetStrategies()) {\n      rf.setFeatureSubsetStrategy(featureSubsetStrategy);\n    }\n    String[] realStrategies = {\".1\", \".10\", \"0.10\", \"0.1\", \"0.9\", \"1.0\"};\n    for (String strategy : realStrategies) {\n      rf.setFeatureSubsetStrategy(strategy);\n    }\n    String[] integerStrategies = {\"1\", \"10\", \"100\", \"1000\", \"10000\"};\n    for (String strategy : integerStrategies) {\n      rf.setFeatureSubsetStrategy(strategy);\n    }\n    String[] invalidStrategies = {\"-.1\", \"-.10\", \"-0.10\", \".0\", \"0.0\", \"1.1\", \"0\"};\n    for (String strategy : invalidStrategies) {\n      Assertions.assertThrows(IllegalArgumentException.class,\n        () -> rf.setFeatureSubsetStrategy(strategy));\n    }\n\n    RandomForestRegressionModel model = rf.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.totalNumNodes();\n    model.toDebugString();\n    model.trees();\n    model.treeWeights();\n    Vector importances = model.featureImportances();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model2.save(sc.sc(), path);\n      RandomForestRegressionModel sameModel = RandomForestRegressionModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model2, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
    "comment": "This tests setters. Training with various options is tested in Scala.\nTODO: Add test once save/load are implemented.   SPARK-6725"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/AutoFitTextureView.java",
    "type": "method",
    "name": "setAspectRatio",
    "code": "public void setAspectRatio(final int width, final int height) {\n    if (width < 0 || height < 0) {\n      throw new IllegalArgumentException(\"Size cannot be negative.\");\n    }\n    ratioWidth = width;\n    ratioHeight = height;\n    requestLayout();\n  }",
    "comment": "Sets the aspect ratio for this view. The size of the view will be measured based on the ratio\ncalculated from the parameters. Note that the actual sizes of parameters don't matter, that\nis, calling setAspectRatio(2, 3) and setAspectRatio(4, 6) make the same result.\n\n@param width  Relative horizontal size\n@param height Relative vertical size"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/FrameworkMethod.java",
    "type": "method",
    "name": "validatePublicVoid",
    "code": "public void validatePublicVoid(boolean isStatic, List<Throwable> errors) {\n        if (isStatic() != isStatic) {\n            String state = isStatic ? \"should\" : \"should not\";\n            errors.add(new Exception(\"Method \" + method.getName() + \"() \" + state + \" be static\"));\n        }\n        if (!isPublic()) {\n            errors.add(new Exception(\"Method \" + method.getName() + \"() should be public\"));\n        }\n        if (method.getReturnType() != Void.TYPE) {\n            errors.add(new Exception(\"Method \" + method.getName() + \"() should be void\"));\n        }\n    }",
    "comment": "Adds to {@code errors} if this method:\n<ul>\n<li>is not public, or\n<li>returns something other than void, or\n<li>is static (given {@code isStatic is false}), or\n<li>is not static (given {@code isStatic is true}).\n</ul>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isNotAbstract",
    "code": "public static boolean isNotAbstract(Class<?> clazz) {\n\t\treturn ReflectionUtils.isNotAbstract(clazz);\n\t}",
    "comment": "Determine if the supplied class is not {@code abstract}.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is not {@code abstract}\n@since 1.13\n@see java.lang.reflect.Modifier#isAbstract(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertNullAssertionsTests.java",
    "type": "method",
    "name": "assertNullWithNonNullObjectWithNullReferenceReturnedFromToString",
    "code": "private void assertNullWithNonNullObjectWithNullReferenceReturnedFromToString(Supplier<String> messageSupplier) {\n\t\tObject actual = new NullToString();\n\t\ttry {\n\t\t\tif (messageSupplier == null) {\n\t\t\t\tassertNull(actual);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertNull(actual, messageSupplier);\n\t\t\t}\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tString prefix = (messageSupplier != null ? messageSupplier.get() + \" ==> \" : \"\");\n\t\t\tassertMessageMatches(ex, prefix\n\t\t\t\t\t+ \"expected: <null> but was: org\\\\.junit\\\\.jupiter\\\\.api\\\\.AssertNullAssertionsTests\\\\$NullToString@.+<null>\");\n\t\t\tassertExpectedAndActualValues(ex, null, actual);\n\t\t}\n\t}",
    "comment": "Should look something like:\nexpected: <null> but was: org.junit.jupiter.api.AssertNullAssertionsTests$NullToString@4e7912d8<null>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-di/src/main/java/org/apache/maven/di/impl/InjectorImpl.java",
    "type": "method",
    "name": "doBindImplicit",
    "code": "protected void doBindImplicit(Key<?> key, Binding<?> binding) {\n        if (binding != null) {\n            Object qualifier = key.getQualifier();\n            Class<?> type = key.getRawType();\n            Set<Class<?>> types = getBoundTypes(type.getAnnotation(Typed.class), type);\n            for (Type t : Types.getAllSuperTypes(type)) {\n                if (types == null || types.contains(Types.getRawType(t))) {\n                    bind(Key.ofType(t, qualifier), binding);\n                    if (qualifier != null) {\n                        bind(Key.ofType(t), binding);\n                    }\n                }\n            }\n        }\n        for (Class<?> inner : key.getRawType().getDeclaredClasses()) {\n            boolean hasQualifier = Stream.of(inner.getAnnotations())\n                    .anyMatch(ann -> ann.annotationType().isAnnotationPresent(Qualifier.class));\n            if (hasQualifier) {\n                bindImplicit(inner);\n            }\n        }\n        for (Method method : key.getRawType().getDeclaredMethods()) {\n            if (method.isAnnotationPresent(Provides.class)) {\n                if (method.getTypeParameters().length != 0) {\n                    throw new DIException(\"Parameterized method are not supported \" + method);\n                }\n                Object qualifier = ReflectionUtils.qualifierOf(method);\n                Annotation scope = ReflectionUtils.scopeOf(method);\n                Type returnType = method.getGenericReturnType();\n                Set<Class<?>> types = getBoundTypes(method.getAnnotation(Typed.class), Types.getRawType(returnType));\n                Binding<Object> bind = ReflectionUtils.bindingFromMethod(method).scope(scope);\n                for (Type t : Types.getAllSuperTypes(returnType)) {\n                    if (types == null || types.contains(Types.getRawType(t))) {\n                        bind(Key.ofType(t, qualifier), bind);\n                        if (qualifier != null) {\n                            bind(Key.ofType(t), bind);\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "comment": "For non-explicit bindings, also bind all their base classes and interfaces according to the @Type\nBind inner classes\nBind inner providers"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/test/java/org/apache/maven/lifecycle/internal/stub/LifecycleExecutionPlanCalculatorStub.java",
    "type": "method",
    "name": "getDefaultLifecycles",
    "code": "private static DefaultLifecycles getDefaultLifecycles() {\n        try {\n            return DefaultLifecyclesStub.createDefaultLifecycles();\n        } catch (ComponentLookupException e) {\n            return null;\n        }\n    }",
    "comment": "The remaining are basically \"for future expansion\"\nignore"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/main/java/com/iluwatar/health/check/HealthCheckInterruptedException.java",
    "type": "method",
    "name": "HealthCheckInterruptedException",
    "code": "public HealthCheckInterruptedException(Throwable cause) {\n    super(\"Health check interrupted\", cause);\n  }",
    "comment": "Constructs a new HealthCheckInterruptedException with the specified cause.\n\n@param cause the cause of the exception"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/server/HiveServer2.java",
    "type": "method",
    "name": "parse",
    "code": "public ServerOptionsProcessorResponse parse(String[] argv) {\n      try {\n        commandLine = new GnuParser().parse(options, argv);\n        Properties confProps = commandLine.getOptionProperties(\"hiveconf\");\n        for (String propKey : confProps.stringPropertyNames()) {\n          debugMessage.append(\"Setting \" + propKey + \"=\" + confProps.getProperty(propKey) + \";\\n\");\n          System.setProperty(propKey, confProps.getProperty(propKey));\n        }\n\n        if (commandLine.hasOption('H')) {\n          return new ServerOptionsProcessorResponse(new HelpOptionExecutor(serverName, options));\n        }\n      } catch (ParseException e) {\n        System.err.println(\"Error starting HiveServer2 with given arguments: \");\n        System.err.println(e.getMessage());\n        System.exit(-1);\n      }\n      return new ServerOptionsProcessorResponse(new StartOptionExecutor());\n    }",
    "comment": "Process --hiveconf\nGet hiveconf param values and set the System property values\nsave logging message for log4j output latter after log4j initialize properly\nProcess --help\nError out & exit - we were not able to parse the args successfully\nDefault executor, when no option is specified"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkSubmitOptionParser.java",
    "type": "method",
    "name": "handleUnknown",
    "code": "protected boolean handleUnknown(String opt) {\n    throw new UnsupportedOperationException();\n  }",
    "comment": "Callback for when an unrecognized option is parsed.\n\n@param opt Unrecognized option from the command line.\n@return Whether to continue parsing the argument list."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Double> create(double[] data) {\n    return Tensor.create(data, Double.class);\n  }",
    "comment": "Creates a rank-1 tensor of {@code double} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/protocol/BlockPushReturnCode.java",
    "type": "method",
    "name": "BlockPushReturnCode",
    "code": "public BlockPushReturnCode(byte returnCode, String failureBlockId) {\n    Preconditions.checkNotNull(BlockPushNonFatalFailure.getReturnCode(returnCode));\n    this.returnCode = returnCode;\n    this.failureBlockId = failureBlockId;\n  }",
    "comment": "Error code indicating a non-fatal failure of a block push request.\nDue to the best-effort nature of push-based shuffle, these failures\ndo not impact the completion of the block push process. The list of\nsuch errors is in\n{@link org.apache.spark.network.server.BlockPushNonFatalFailure.ReturnCode}.\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "compareLowerCaseAscii",
    "code": "private static int compareLowerCaseAscii(final UTF8String left, final UTF8String right) {\n    int leftBytes = left.numBytes(), rightBytes = right.numBytes();\n    for (int curr = 0; curr < leftBytes && curr < rightBytes; curr++) {\n      int lowerLeftByte = Character.toLowerCase(left.getByte(curr));\n      int lowerRightByte = Character.toLowerCase(right.getByte(curr));\n      if (lowerLeftByte != lowerRightByte) {\n        return lowerLeftByte - lowerRightByte;\n      }\n    }\n    return leftBytes - rightBytes;\n  }",
    "comment": "Fast version of the `compareLowerCase` method, used when both arguments are ASCII strings.\n\n@param left The first ASCII UTF8String to compare.\n@param right The second ASCII UTF8String to compare.\n@return An integer representing the comparison result."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "fromCollationId",
    "code": "private static CollationSpecUTF8 fromCollationId(int collationId) {\n        int caseConversionOrdinal = SpecifierUtils.getSpecValue(collationId,\n          CASE_SENSITIVITY_OFFSET, CASE_SENSITIVITY_MASK);\n        int spaceTrimmingOrdinal = getSpaceTrimming(collationId).ordinal();\n        assert(isValidCollationId(collationId));\n        return new CollationSpecUTF8(\n          CaseSensitivity.values()[caseConversionOrdinal],\n          SpaceTrimming.values()[spaceTrimmingOrdinal]);\n      }",
    "comment": "Extract case sensitivity from collation ID.\nExtract space trimming from collation ID."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/checksum/ShuffleChecksumHelper.java",
    "type": "method",
    "name": "createPartitionChecksums",
    "code": "public static Checksum[] createPartitionChecksums(int numPartitions, String algorithm) {\n    return getChecksumsByAlgorithm(numPartitions, algorithm);\n  }",
    "comment": "A set of utility functions for the shuffle checksum."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3043BestEffortReactorResolutionTest.java",
    "type": "method",
    "name": "assertContains",
    "code": "private void assertContains(List<String> collection, String[] items) {\n        for (String item : items) {\n            assertContains(collection, item);\n        }\n    }",
    "comment": "Test that dependency resolution still uses the actual artifact files once these have been\nassembled/attached in the \"package\" phase. This ensures the class path is accurate and not locked to\nthe output directories of the best effort model from above.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(boolean condition) {\n\t\tAssertTrue.assertTrue(condition);\n\t}",
    "comment": "<em>Assert</em> that the supplied {@code condition} is {@code true}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationContext.java",
    "type": "method",
    "name": "getDisplayName",
    "code": "default String getDisplayName(int invocationIndex) {\n\t\treturn \"[\" + invocationIndex + \"]\";\n\t}",
    "comment": "Get the display name for this invocation.\n\n<p>The supplied {@code invocationIndex} is incremented by the framework\nwith each container invocation. Thus, in the case of multiple active\n{@linkplain ClassTemplateInvocationContextProvider providers}, only the\nfirst active provider receives indices starting with {@code 1}.\n\n<p>The default implementation returns the supplied {@code invocationIndex}\nwrapped in brackets &mdash; for example, {@code [1]}, {@code [42]}, etc.\n\n@param invocationIndex the index of this invocation (1-based).\n@return the display name for this invocation; never {@code null} or blank"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkLauncher.java",
    "type": "method",
    "name": "redirectError",
    "code": "public SparkLauncher redirectError() {\n    redirectErrorStream = true;\n    return this;\n  }",
    "comment": "Specifies that stderr in spark-submit should be redirected to stdout.\n\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/RowFactory.java",
    "type": "method",
    "name": "create",
    "code": "public static Row create(Object ... values) {\n    return new GenericRow(values);\n  }",
    "comment": "Create a {@link Row} from the given arguments. Position i in the argument list becomes\nposition i in the created {@link Row} object.\n\n@since 1.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "debug",
    "code": "public Events debug() {\n\t\tdebug(System.out);\n\t\treturn this;\n\t}",
    "comment": "Print all events to {@link System#out}.\n\n@return this {@code Events} object for method chaining; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/AnnotatedElementContext.java",
    "type": "method",
    "name": "findAnnotation",
    "code": "default <A extends Annotation> Optional<A> findAnnotation(Class<A> annotationType) {\n\t\treturn AnnotationSupport.findAnnotation(getAnnotatedElement(), annotationType);\n\t}",
    "comment": "Find the first annotation of {@code annotationType} that is either\n<em>present</em> or <em>meta-present</em> on the {@link AnnotatedElement} for\nthis context.\n\n<h4>WARNING</h4>\n<p>Favor the use of this method over directly invoking annotation lookup\nmethods in the {@link AnnotatedElement} API due to a bug in {@code javac} on JDK\nversions prior to JDK 9.\n\n@param <A> the annotation type\n@param annotationType the annotation type to search for; never {@code null}\n@return an {@code Optional} containing the annotation; never {@code null} but\npotentially empty\n@see #isAnnotated(Class)\n@see #findRepeatableAnnotations(Class)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/HealthCheckRepositoryTest.java",
    "type": "method",
    "name": "whenCheckHealth_andDatabaseIsDown_thenThrowsException",
    "code": "void whenCheckHealth_andDatabaseIsDown_thenThrowsException() {\n    // Arrange\n    when(entityManager.createNativeQuery(\"SELECT 1\")).thenThrow(RuntimeException.class);\n\n    // Act & Assert\n    assertThrows(RuntimeException.class, () -> healthCheckRepository.checkHealth());\n  }",
    "comment": "Test case for the `checkHealth()` method when the database is down.\n\n<p>Asserts that when the `checkHealth()` method is called and the database is down, it throws a\nRuntimeException."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Float expected, Float actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedInvocationNameFormatter.java",
    "type": "method",
    "name": "determineNonPlaceholderFormatter",
    "code": "private static PartialFormatter determineNonPlaceholderFormatter(String segment, int argumentMaxLength) {\n\t\treturn segment.contains(\"{\") //\n\t\t\t\t? new MessageFormatPartialFormatter(segment, argumentMaxLength) //\n\t\t\t\t: (context, result) -> result.append(segment);\n\t}\n\n\tprivate PartialFormatters createPartialFormatters(String displayName,\n\t\t\tParameterizedDeclarationContext<?> declarationContext, int argumentMaxLength) {\n\n\t\tPartialFormatter argumentsWithNamesFormatter = new CachingByArgumentsLengthPartialFormatter(\n\t\t\tlength -> new MessageFormatPartialFormatter(argumentsWithNamesPattern(length, declarationContext),\n\t\t\t\targumentMaxLength));\n\n\t\tPartialFormatter argumentSetNameFormatter = new ArgumentSetNameFormatter(\n\t\t\tdeclarationContext.getAnnotationName());\n\n\t\tPartialFormatters formatters = new PartialFormatters();\n\t\tformatters.put(INDEX_PLACEHOLDER, PartialFormatter.INDEX);\n\t\tformatters.put(DISPLAY_NAME_PLACEHOLDER, (context, result) -> result.append(displayName));\n\t\tformatters.put(ARGUMENT_SET_NAME_PLACEHOLDER, argumentSetNameFormatter);\n\t\tformatters.put(ARGUMENTS_WITH_NAMES_PLACEHOLDER, argumentsWithNamesFormatter);\n\t\tformatters.put(ARGUMENTS_PLACEHOLDER, new CachingByArgumentsLengthPartialFormatter(\n\t\t\tlength -> new MessageFormatPartialFormatter(argumentsPattern(length), argumentMaxLength)));\n\t\tformatters.put(ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER, (context, result) -> {\n\t\t\tPartialFormatter formatterToUse = context.argumentSetName.isPresent() //\n\t\t\t\t\t? argumentSetNameFormatter //\n\t\t\t\t\t: argumentsWithNamesFormatter;\n\t\t\tformatterToUse.append(context, result);\n\t\t});\n\t\treturn formatters;\n\t}\n\n\tprivate static String argumentsWithNamesPattern(int length, ParameterizedDeclarationContext<?> declarationContext) {\n\t\tResolverFacade resolverFacade = declarationContext.getResolverFacade();\n\t\treturn IntStream.range(0, length) //\n\t\t\t\t.mapToObj(index -> resolverFacade.getParameterName(index).map(name -> name + \"=\").orElse(\"\") + \"{\"\n\t\t\t\t\t\t+ index + \"}\") //\n\t\t\t\t.collect(joining(\", \"));\n\t}\n\n\tprivate static String argumentsPattern(int length) {\n\t\treturn IntStream.range(0, length) //\n\t\t\t\t.mapToObj(index -> \"{\" + index + \"}\") //\n\t\t\t\t.collect(joining(\", \"));\n\t}\n\n\tprivate static class PlaceholderPosition {\n\n\t\tfinal int index;\n\t\tfinal String placeholder;\n\n\t\tPlaceholderPosition(int index, String placeholder) {\n\t\t\tthis.index = index;\n\t\t\tthis.placeholder = placeholder;\n\t\t}\n\n\t}\n\n\tprivate static class ArgumentsContext {\n\n\t\tprivate final int invocationIndex;\n\t\tprivate final Object[] consumedArguments;\n\t\tprivate final Optional<String> argumentSetName;\n\n\t\tArgumentsContext(int invocationIndex, Object[] consumedArguments, Optional<String> argumentSetName) {\n\t\t\tthis.invocationIndex = invocationIndex;\n\t\t\tthis.consumedArguments = consumedArguments;\n\t\t\tthis.argumentSetName = argumentSetName;\n\t\t}\n\t}\n\n\t@FunctionalInterface\n\tprivate interface PartialFormatter {\n\n\t\tPartialFormatter INDEX = (context, result) -> result.append(context.invocationIndex);\n\n\t\tvoid append(ArgumentsContext context, StringBuffer result);\n\n\t}\n\n\tprivate static class ArgumentSetNameFormatter implements PartialFormatter {\n\n\t\tprivate final String annotationName;\n\n\t\tArgumentSetNameFormatter(String annotationName) {\n\t\t\tthis.annotationName = annotationName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void append(ArgumentsContext context, StringBuffer result) {\n\t\t\tif (context.argumentSetName.isPresent()) {\n\t\t\t\tresult.append(context.argumentSetName.get());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new ExtensionConfigurationException(String.format(\n\t\t\t\t\"When the display name pattern for a @%s contains %s, the arguments must be supplied as an ArgumentSet.\",\n\t\t\t\tthis.annotationName, ARGUMENT_SET_NAME_PLACEHOLDER));\n\t\t}\n\t}\n\n\tprivate static class MessageFormatPartialFormatter implements PartialFormatter {\n\n\t\t@SuppressWarnings(\"UnnecessaryUnicodeEscape\")\n\t\tprivate static final char ELLIPSIS = '\\u2026';\n\n\t\tprivate final MessageFormat messageFormat;\n\t\tprivate final int argumentMaxLength;\n\n\t\tMessageFormatPartialFormatter(String pattern, int argumentMaxLength) {\n\t\t\tthis.messageFormat = new MessageFormat(pattern);\n\t\t\tthis.argumentMaxLength = argumentMaxLength;\n\t\t}\n\n\t\t@Override\n\t\tpublic synchronized void append(ArgumentsContext context, StringBuffer result) {\n\t\t\tthis.messageFormat.format(makeReadable(context.consumedArguments), result, new FieldPosition(0));\n\t\t}\n\n\t\tprivate Object[] makeReadable(Object[] arguments) {\n\t\t\tFormat[] formats = messageFormat.getFormatsByArgumentIndex();\n\t\t\tObject[] result = Arrays.copyOf(arguments, Math.min(arguments.length, formats.length), Object[].class);\n\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\tif (formats[i] == null) {\n\t\t\t\t\tresult[i] = truncateIfExceedsMaxLength(StringUtils.nullSafeToString(arguments[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate String truncateIfExceedsMaxLength(String argument) {\n\t\t\tif (argument != null && argument.length() > this.argumentMaxLength) {\n\t\t\t\treturn argument.substring(0, this.argumentMaxLength - 1) + ELLIPSIS;\n\t\t\t}\n\t\t\treturn argument;\n\t\t}\n\t}\n\n\tprivate static class CachingByArgumentsLengthPartialFormatter implements PartialFormatter {\n\n\t\tprivate final ConcurrentMap<Integer, PartialFormatter> cache = new ConcurrentHashMap<>(1);\n\t\tprivate final Function<Integer, PartialFormatter> factory;\n\n\t\tCachingByArgumentsLengthPartialFormatter(Function<Integer, PartialFormatter> factory) {\n\t\t\tthis.factory = factory;\n\t\t}\n\n\t\t@Override\n\t\tpublic void append(ArgumentsContext context, StringBuffer result) {\n\t\t\tcache.computeIfAbsent(context.consumedArguments.length, factory).append(context, result);\n\t\t}\n\t}\n\n\tprivate static class PartialFormatters {\n\n\t\tprivate final Map<String, PartialFormatter> formattersByPlaceholder = new LinkedHashMap<>();\n\t\tprivate int minimumPlaceholderLength = Integer.MAX_VALUE;\n\n\t\tvoid put(String placeholder, PartialFormatter formatter) {\n\t\t\tformattersByPlaceholder.put(placeholder, formatter);\n\t\t\tint newPlaceholderLength = placeholder.length();\n\t\t\tif (newPlaceholderLength < minimumPlaceholderLength) {\n\t\t\t\tminimumPlaceholderLength = newPlaceholderLength;\n\t\t\t}\n\t\t}\n\n\t\tPartialFormatter get(String placeholder) {\n\t\t\treturn formattersByPlaceholder.get(placeholder);\n\t\t}\n\n\t\tSet<String> placeholders() {\n\t\t\treturn formattersByPlaceholder.keySet();\n\t\t}\n\t}\n\n}",
    "comment": "synchronized because MessageFormat is not thread-safe"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SaslClientBootstrap.java",
    "type": "method",
    "name": "doBootstrap",
    "code": "public void doBootstrap(TransportClient client, Channel channel) {\n    SparkSaslClient saslClient = new SparkSaslClient(appId, secretKeyHolder, conf.saslEncryption());\n    try {\n      byte[] payload = saslClient.firstToken();\n\n      while (!saslClient.isComplete()) {\n        SaslMessage msg = new SaslMessage(appId, payload);\n        ByteBuf buf = Unpooled.buffer(msg.encodedLength() + (int) msg.body().size());\n        msg.encode(buf);\n        ByteBuffer response;\n        buf.writeBytes(msg.body().nioByteBuffer());\n        try {\n          response = client.sendRpcSync(buf.nioBuffer(), conf.authRTTimeoutMs());\n        } catch (RuntimeException ex) {\n          // We know it is a Sasl timeout here if it is a TimeoutException.\n          if (ex.getCause() instanceof TimeoutException te) {\n            throw new SaslTimeoutException(te);\n          } else {\n            throw ex;\n          }\n        }\n        payload = saslClient.response(JavaUtils.bufferToArray(response));\n      }\n\n      client.setClientId(appId);\n\n      if (conf.saslEncryption()) {\n        if (!SparkSaslServer.QOP_AUTH_CONF.equals(saslClient.getNegotiatedProperty(Sasl.QOP))) {\n          throw new RuntimeException(\n            new SaslException(\"Encryption requests by negotiated non-encrypted connection.\"));\n        }\n\n        SaslEncryption.addToChannel(channel, saslClient, conf.maxSaslEncryptedBlockSize());\n        saslClient = null;\n        logger.debug(\"Channel {} configured for encryption.\", client);\n      }\n    } catch (IOException ioe) {\n      throw new RuntimeException(ioe);\n    } finally {\n      if (saslClient != null) {\n        try {\n          // Once authentication is complete, the server will trust all remaining communication.\n          saslClient.dispose();\n        } catch (RuntimeException e) {\n          logger.error(\"Error while disposing SASL client\", e);\n        }\n      }\n    }\n  }",
    "comment": "Performs SASL authentication by sending a token, and then proceeding with the SASL\nchallenge-response tokens until we either successfully authenticate or throw an exception\ndue to mismatch."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/main/java/com/example/android/observability/persistence/User.java",
    "type": "method",
    "name": "User",
    "code": "public User(String userName) {\n        mId = UUID.randomUUID().toString();\n        mUserName = userName;\n    }",
    "comment": "Immutable model class for a User"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/TensorFlowLite.java",
    "type": "method",
    "name": "schemaVersion",
    "code": "public static String schemaVersion() {\n    return schemaVersion(null);\n  }",
    "comment": "Returns the version of the TensorFlowLite model schema that is supported by the default\nTensorFlowLite runtime."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/memory/TaskMemoryManagerSuite.java",
    "type": "method",
    "name": "prefersSmallestBigEnoughAllocation",
    "code": "public void prefersSmallestBigEnoughAllocation() {\n    final TestMemoryManager memoryManager = new TestMemoryManager(new SparkConf());\n    memoryManager.limit(100);\n    final TaskMemoryManager manager = new TaskMemoryManager(memoryManager, 0);\n\n    TestMemoryConsumer c1 = new TestMemoryConsumer(manager);\n    TestMemoryConsumer c2 = new TestMemoryConsumer(manager);\n    TestMemoryConsumer c3 = new TestMemoryConsumer(manager);\n    TestMemoryConsumer c4 = new TestMemoryConsumer(manager);\n\n\n    c1.use(50);\n    c2.use(40);\n    c3.use(10);\n    c4.use(5);\n    Assertions.assertEquals(50, c1.getUsed());\n    Assertions.assertEquals(40, c2.getUsed());\n    Assertions.assertEquals(0, c3.getUsed());\n    Assertions.assertEquals(5, c4.getUsed());\n\n    c3.use(45);\n    Assertions.assertEquals(50, c1.getUsed());\n    Assertions.assertEquals(0, c2.getUsed());\n    Assertions.assertEquals(45, c3.getUsed());\n    Assertions.assertEquals(5, c4.getUsed());\n\n    c2.use(51);\n    Assertions.assertEquals(0, c1.getUsed());\n    Assertions.assertEquals(51, c2.getUsed());\n    Assertions.assertEquals(45, c3.getUsed());\n    Assertions.assertEquals(0, c4.getUsed());\n  }",
    "comment": "Test that the smallest consumer with at least the requested size is chosen to spill.\nAllocate 45. 5 is unused and 40 will come from c2.\nAllocate 51. 50 is taken from c1, then c4 is the best fit to get 1 more byte."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/RocksDBTypeInfo.java",
    "type": "method",
    "name": "checkParent",
    "code": "private void checkParent(byte[] prefix) {\n      if (prefix != null) {\n        Preconditions.checkState(parent != null, \"Parent prefix provided for parent index.\");\n      } else {\n        Preconditions.checkState(parent == null, \"Parent prefix missing for child index.\");\n      }\n    }",
    "comment": "Gets the index value for a particular entity (which is the value of the field or method\ntagged with the index annotation). This is used as part of the RocksDB key where the\nentity (or its id) is stored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java",
    "type": "method",
    "name": "parseValueArray",
    "code": "private Stream<Arguments> parseValueArray(CsvSource csvSource) {\n\t\tboolean useHeadersInDisplayName = csvSource.useHeadersInDisplayName();\n\t\tList<Arguments> argumentsList = new ArrayList<>();\n\n\t\ttry {\n\t\t\tString[] headers = null;\n\t\t\tAtomicInteger index = new AtomicInteger(0);\n\t\t\tfor (String input : csvSource.value()) {\n\t\t\t\tindex.incrementAndGet();\n\t\t\t\tString[] csvRecord = this.csvParser.parseLine(input + LINE_SEPARATOR);\n\t\t\t\tif (useHeadersInDisplayName && headers == null) {\n\t\t\t\t\theaders = getHeaders(this.csvParser);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tPreconditions.notNull(csvRecord,\n\t\t\t\t\t() -> \"Record at index \" + index + \" contains invalid CSV: \\\"\" + input + \"\\\"\");\n\t\t\t\targumentsList.add(processCsvRecord(csvRecord, this.nullValues, useHeadersInDisplayName, headers));\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\tthrow handleCsvException(throwable, csvSource);\n\t\t}\n\n\t\treturn argumentsList.stream();\n\t}",
    "comment": "Lazily retrieve headers if necessary."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java",
    "type": "method",
    "name": "provideForNestedClass",
    "code": "default Set<Lock> provideForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> testClass) {\n\t\treturn emptySet();\n\t}",
    "comment": "Add shared resources for a\n{@link org.junit.jupiter.api.Nested @Nested} test class.\n\n<p>Invoked in case:\n<ul>\n<li>an enclosing test class of any level or its parent class is\nannotated with {@code @ResourceLock(providers = ...)}.</li>\n<li>a nested test class or its parent class is annotated with\n{@code @ResourceLock(providers = ...)}.</li>\n</ul>\n\n@apiNote Adding {@linkplain Lock a shared resource} via this method has\nthe same semantics as annotating a nested test class with an analogous\n{@code @ResourceLock(value, mode)} declaration.\n\n@implNote The classes supplied as {@code enclosingInstanceTypes} may\ndiffer from the classes returned from invocations of\n{@link Class#getEnclosingClass()} &mdash; for example, when a nested test\nclass is inherited from a superclass.\n\n@param enclosingInstanceTypes the runtime types of the enclosing\ninstances for the test class, ordered from outermost to innermost,\nexcluding {@code testClass}; never {@code null}\n@param testClass a nested test class for which to add shared resources\n@return a set of {@link Lock}; may be empty\n@see org.junit.jupiter.api.Nested @Nested"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationFactory.java",
    "type": "method",
    "name": "applyTrimmingPolicy",
    "code": "public static UTF8String applyTrimmingPolicy(UTF8String input, int collationId) {\n    return Collation.CollationSpec.applyTrimmingPolicy(input, collationId);\n  }",
    "comment": "Applies trimming policy depending up on trim collation type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng4360WebDavSupportTest.java",
    "type": "method",
    "name": "AbstractHandler",
    "code": "Handler repoHandler = new AbstractHandler() {\n                    writer.println(\"empty\");\n                } else if (request.getRequestURI().endsWith(\".md5\")",
    "comment": "Verify that WebDAV works in principle. This test is not actually concerned about proper transfers but more\nthat the Slide based wagon can be properly loaded and doesn't die due to some class realm issue.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java",
    "type": "method",
    "name": "MavenCli",
    "code": "public MavenCli(ClassWorld classWorld) {\n        this.classWorld = classWorld;\n        this.messageBuilderFactory = new JLineMessageBuilderFactory();\n    }",
    "comment": "This supports painless invocation by the Verifier during embedded execution of the core ITs"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testBagSimpleAdd",
    "code": "public void testBagSimpleAdd() {\n        IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n        assertEquals(expected, fMB1.add(f14CHF));\n    }",
    "comment": "{[12 CHF][7 USD]} + [14 CHF] == {[26 CHF][7 USD]}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/Task.java",
    "type": "method",
    "name": "Task",
    "code": "public Task(String value) {\n        this.value = Objects.requireNonNull(value, \"value\");\n    }",
    "comment": "A Maven task, at this level is merely just an opaque string.\n<p>\n<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/Interpolator.java",
    "type": "method",
    "name": "interpolate",
    "code": "default void interpolate(@Nonnull Map<String, String> properties, @Nullable UnaryOperator<String> callback) {\n        interpolate(properties, callback, null, true);\n    }",
    "comment": "Interpolates the values in the given map using the provided callback function.\nThis method defaults to setting empty strings for unresolved placeholders.\n\n@param properties The map containing key-value pairs to be interpolated.\n@param callback The function to resolve variable values not found in the map."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/InterpreterFactory.java",
    "type": "method",
    "name": "create",
    "code": "public InterpreterApi create(@NonNull File modelFile, InterpreterApi.Options options) {\n    return InterpreterApi.create(modelFile, options);\n  }",
    "comment": "Constructs an {@link InterpreterApi} instance, using the specified model and options. The model\nwill be loaded from a file.\n\n@param modelFile A file containing a pre-trained TF Lite model.\n@param options A set of options for customizing interpreter behavior.\n@throws IllegalArgumentException if {@code modelFile} does not encode a valid TensorFlow Lite\nmodel."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng3415JunkRepositoryMetadataTest.java",
    "type": "method",
    "name": "MavenITmng3415JunkRepositoryMetadataTest",
    "code": "public MavenITmng3415JunkRepositoryMetadataTest() {\n        // we're going to control the test execution according to the maven version present within each test method.\n        // all methods should execute as long as we're using maven 2.0.9+, but the specific tests may vary a little\n        // depending on which version we're using above 2.0.8.\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
    "comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3415\">MNG-3415</a>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/transfer/AbstractMavenTransferListener.java",
    "type": "method",
    "name": "transferSucceeded",
    "code": "public void transferSucceeded(TransferEvent event) {\n        String darkOn = MessageUtils.isColorEnabled() ? ANSI_DARK_SET : \"\";\n        String darkOff = MessageUtils.isColorEnabled() ? ANSI_DARK_RESET : \"\";\n\n        String action = (event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\");\n        String direction = event.getRequestType() == TransferEvent.RequestType.PUT ? \"to\" : \"from\";\n\n        TransferResource resource = event.getResource();\n        long contentLength = event.getTransferredBytes();\n        FileSizeFormat format = new FileSizeFormat(Locale.ENGLISH);\n\n        StringBuilder message = new StringBuilder();\n        message.append(action).append(darkOn).append(' ').append(direction).append(' ');\n        message.append(darkOff).append(resource.getRepositoryId());\n        message.append(darkOn).append(\": \").append(resource.getRepositoryUrl());\n        message.append(darkOff).append(resource.getResourceName());\n        message.append(darkOn).append(\" (\").append(format.format(contentLength));\n\n        long duration = System.currentTimeMillis() - resource.getTransferStartTime();\n        if (duration > 0L) {\n            double bytesPerSecond = contentLength / (duration / 1000.0);\n            message.append(\" at \").append(format.format((long) bytesPerSecond)).append(\"/s\");\n        }\n\n        message.append(')').append(darkOff);\n        out.println(message);\n    }",
    "comment": "TODO This needs to be colorized"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnenc/goals/InteractiveGoalSupport.java",
    "type": "method",
    "name": "InteractiveGoalSupport",
    "code": "protected InteractiveGoalSupport(MessageBuilderFactory messageBuilderFactory, SecDispatcher secDispatcher) {\n        super(messageBuilderFactory, secDispatcher);\n    }",
    "comment": "The support class for interactive goal implementations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaGaussianMixtureExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaGaussianMixtureExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    String path = \"data/mllib/gmm_data.txt\";\n    JavaRDD<String> data = jsc.textFile(path);\n    JavaRDD<Vector> parsedData = data.map(s -> {\n      String[] sarray = s.trim().split(\" \");\n      double[] values = new double[sarray.length];\n      for (int i = 0; i < sarray.length; i++) {\n        values[i] = Double.parseDouble(sarray[i]);\n      }\n      return Vectors.dense(values);\n    });\n    parsedData.cache();\n\n    GaussianMixtureModel gmm = new GaussianMixture().setK(2).run(parsedData.rdd());\n\n    gmm.save(jsc.sc(), \"target/org/apache/spark/JavaGaussianMixtureExample/GaussianMixtureModel\");\n    GaussianMixtureModel sameModel = GaussianMixtureModel.load(jsc.sc(),\n      \"target/org.apache.spark.JavaGaussianMixtureExample/GaussianMixtureModel\");\n\n    for (int j = 0; j < gmm.k(); j++) {\n      System.out.printf(\"weight=%f\\nmu=%s\\nsigma=\\n%s\\n\",\n        gmm.weights()[j], gmm.gaussians()[j].mu(), gmm.gaussians()[j].sigma());\n    }\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nLoad and parse data\nCluster the data into two classes using GaussianMixture\nSave and load GaussianMixtureModel\nOutput the parameters of the mixture model\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/AssumptionViolatedException.java",
    "type": "method",
    "name": "AssumptionViolatedException",
    "code": "public AssumptionViolatedException(String assumption) {\n        this(assumption, false, null, null);\n    }",
    "comment": "An assumption exception with the given message only.\n\n@deprecated Please use {@link org.junit.AssumptionViolatedException} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetVectorUpdaterFactory.java",
    "type": "method",
    "name": "isSameDecimalScale",
    "code": "private static boolean isSameDecimalScale(ColumnDescriptor descriptor, DataType dt) {\n    DecimalType d = (DecimalType) dt;\n    LogicalTypeAnnotation typeAnnotation = descriptor.getPrimitiveType().getLogicalTypeAnnotation();\n    if (typeAnnotation instanceof DecimalLogicalTypeAnnotation) {\n      DecimalLogicalTypeAnnotation decimalType = (DecimalLogicalTypeAnnotation) typeAnnotation;\n      return decimalType.getScale() == d.scale();\n    } else if (typeAnnotation == null || isSignedIntAnnotation(typeAnnotation)) {\n      return d.scale() == 0;\n    }\n    return false;\n  }",
    "comment": "Consider signed integers (which may be un-annotated) as having scale 0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "getKeyOffset",
    "code": "public long getKeyOffset() {\n      assert (isDefined);\n      return keyOffset;\n    }",
    "comment": "Returns the offset for key."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "maxNumKeysIndex",
    "code": "public int maxNumKeysIndex() {\n    return (int) (longArray.size() / 2);\n  }",
    "comment": "The maximum number of allowed keys index.\n\nThe value of allowed keys index is in the range of [0, maxNumKeysIndex - 1]."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "putByteArray",
    "code": "public final int putByteArray(int rowId, byte[] value) {\n    return putByteArray(rowId, value, 0, value.length);\n  }",
    "comment": "Sets values from [value + offset, value + offset + count) to the values at rowId."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java",
    "type": "method",
    "name": "equalsAndHashCode",
    "code": "void equalsAndHashCode() {\n\t\tvar selector1 = new MethodSelector(null, TEST_CASE_NAME, \"method\", \"int, boolean\");\n\t\tvar selector2 = new MethodSelector(null, TEST_CASE_NAME, \"method\", \"int, boolean\");\n\t\tvar selector3 = new MethodSelector(TestCase.class, \"method\", \"int, boolean\");\n\t\tvar selector4 = new MethodSelector(TestCase.class, \"method\", int.class, boolean.class);\n\n\t\tStream.of(selector2, selector3, selector4).forEach(selector -> {\n\t\t\tassertEqualsAndHashCode(selector1, selector, new MethodSelector(null, TEST_CASE_NAME, \"method\", \"int\"));\n\t\t\tassertEqualsAndHashCode(selector1, selector, new MethodSelector(null, TEST_CASE_NAME, \"method\", \"\"));\n\t\t\tassertEqualsAndHashCode(selector1, selector, new MethodSelector(null, TEST_CASE_NAME, \"X\", \"int, boolean\"));\n\t\t\tassertEqualsAndHashCode(selector1, selector, new MethodSelector(null, TEST_CASE_NAME, \"X\", \"\"));\n\t\t\tassertEqualsAndHashCode(selector1, selector, new MethodSelector(null, \"X\", \"method\", \"int, boolean\"));\n\t\t\tassertEqualsAndHashCode(selector1, selector, new MethodSelector(null, \"X\", \"method\", \"\"));\n\t\t});\n\t}",
    "comment": "Unit tests for {@link MethodSelector}.\n\n@since 1.3\n@see DiscoverySelectorsTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/test/java/org/apache/spark/unsafe/hash/Murmur3_x86_32Suite.java",
    "type": "method",
    "name": "randomizedStressTestPaddedStrings",
    "code": "public void randomizedStressTestPaddedStrings() {\n    int size = 64000;\n    Set<Integer> hashcodes = new HashSet<>();\n    for (int i = 0; i < size; i++) {\n      int byteArrSize = 8;\n      byte[] strBytes = String.valueOf(i).getBytes(StandardCharsets.UTF_8);\n      byte[] paddedBytes = new byte[byteArrSize];\n      System.arraycopy(strBytes, 0, paddedBytes, 0, strBytes.length);\n\n      Assertions.assertEquals(\n        hasher.hashUnsafeWords(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize),\n        hasher.hashUnsafeWords(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n\n      hashcodes.add(hasher.hashUnsafeWords(\n        paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));\n    }\n\n    Assertions.assertTrue(hashcodes.size() > size * 0.95);\n  }",
    "comment": "A set used to track collision rate.\nA very loose bound."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-expression/src/main/java/org/apache/maven/plugin/coreit/PropertyUtil.java",
    "type": "method",
    "name": "store",
    "code": "public static void store(Properties props, String key, Object obj) {\n        store(props, key, obj, new HashSet());\n    }",
    "comment": "Serializes the specified object into the given properties, using the provided key. The object may be a scalar\nvalue like a string or some array/collection/map or a bean.\n\n@param props The properties to serialize into, must not be <code>null</code>.\n@param key   The key to use for serialization of the object data, must not be <code>null</code>.\n@param obj   The object to serialize, may be <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/PathModularization.java",
    "type": "method",
    "name": "getPathType",
    "code": "public JavaPathType getPathType() {\n        return descriptors.isEmpty() ? JavaPathType.CLASSES : JavaPathType.MODULES;\n    }",
    "comment": "{@return the type of path detected}\nThe return value is {@link JavaPathType#MODULES}\nif the dependency is a modular JAR file or a directory containing module descriptor(s),\nor {@link JavaPathType#CLASSES} otherwise. A JAR file without module descriptor but with\nan \"Automatic-Module-Name\" manifest attribute is considered modular."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/server/HiveServer2.java",
    "type": "method",
    "name": "ServerOptionsProcessor",
    "code": "public ServerOptionsProcessor(String serverName) {\n      this.serverName = serverName;\n      // -hiveconf x=y\n      options.addOption(OptionBuilder\n          .withValueSeparator()\n          .hasArgs(2)\n          .withArgName(\"property=value\")\n          .withLongOpt(\"hiveconf\")\n          .withDescription(\"Use value for given property\")\n          .create());\n      options.addOption(new Option(\"H\", \"help\", false, \"Print help information\"));\n    }",
    "comment": "ServerOptionsProcessor.\nProcess arguments given to HiveServer2 (-hiveconf property=value)\nSet properties in System properties\nCreate an appropriate response object,\nwhich has executor to execute the appropriate command based on the parsed options."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/artifact/resolver/filter/ExclusionArtifactFilter.java",
    "type": "method",
    "name": "createPathProxy",
    "code": "private static Path createPathProxy(String value) {\n        return (Path) Proxy.newProxyInstance(\n                ExclusionArtifactFilter.class.getClassLoader(), new Class[] {Path.class}, (proxy1, method, args) -> {\n                    throw new UnsupportedOperationException();\n                });\n    }",
    "comment": "In order to reuse the glob matcher from the filesystem, we need\nto create Path instances.  Those are only used with the toString method.\nThis hack works because the only system-dependent thing is the path\nseparator which should not be part of the groupId or artifactId."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegateImpl.java",
    "type": "method",
    "name": "NnApiDelegateImpl",
    "code": "public NnApiDelegateImpl(NnApiDelegate.Options options) {\n    // Ensure the native TensorFlow Lite libraries are available.\n    TensorFlowLite.init();\n    delegateHandle =\n        createDelegate(\n            options.getExecutionPreference(),\n            options.getAcceleratorName(),\n            options.getCacheDir(),\n            options.getModelToken(),\n            options.getMaxNumberOfDelegatedPartitions(),\n            /*overrideDisallowCpu=*/ options.getUseNnapiCpu() != null,\n            /*disallowCpuValue=*/ options.getUseNnapiCpu() != null\n                ? !options.getUseNnapiCpu().booleanValue()\n                : true,\n            options.getAllowFp16(),\n            options.getNnApiSupportLibraryHandle());\n  }",
    "comment": "Implementation of {@link Delegate} for NNAPI inference. Only for use by packages in\norg.tensorflow.lite.\n\n@hide"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "Variant",
    "code": "public Variant(byte[] value, byte[] metadata) {\n    this(value, metadata, 0);\n  }",
    "comment": "This class is structurally equivalent to {@link org.apache.spark.unsafe.types.VariantVal}. We\ndefine a new class to avoid depending on or modifying Spark."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-based-asynchronous/src/test/java/com/iluwatar/event/asynchronous/AppTest.java",
    "type": "method",
    "name": "shouldExecuteApplicationWithoutException",
    "code": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
    "comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ThrowableCollector.java",
    "type": "method",
    "name": "isNotEmpty",
    "code": "public boolean isNotEmpty() {\n\t\treturn (this.throwable != null);\n\t}",
    "comment": "Determine if this {@code ThrowableCollector} is <em>not empty</em> (i.e.,\nhas collected at least one {@code Throwable})."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/hash/Murmur3_x86_32.java",
    "type": "method",
    "name": "hashUnsafeBytes",
    "code": "public static int hashUnsafeBytes(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes >= 0): \"lengthInBytes cannot be negative\";\n    int lengthAligned = lengthInBytes - lengthInBytes % 4;\n    int h1 = hashBytesByInt(base, offset, lengthAligned, seed);\n    for (int i = lengthAligned; i < lengthInBytes; i++) {\n      int halfWord = Platform.getByte(base, offset + i);\n      int k1 = mixK1(halfWord);\n      h1 = mixH1(h1, k1);\n    }\n    return fmix(h1, lengthInBytes);\n  }",
    "comment": "This is not compatible with original and another implementations.\nBut remain it for backward compatibility for the components existing before 2.3."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/bytecode/src/main/java/com/iluwatar/bytecode/Instruction.java",
    "type": "method",
    "name": "getInstruction",
    "code": "public static Instruction getInstruction(int value) {\n    for (var i = 0; i < Instruction.values().length; i++) {\n      if (Instruction.values()[i].getIntValue() == value) {\n        return Instruction.values()[i];\n      }\n    }\n    throw new IllegalArgumentException(\"Invalid instruction value\");\n  }",
    "comment": "Converts integer value to Instruction.\n\n@param value value of instruction\n@return representation of the instruction"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/config/CachingJupiterConfigurationTests.java",
    "type": "method",
    "name": "cachesDefaultTempDirCleanupMode",
    "code": "void cachesDefaultTempDirCleanupMode() {\n\t\twhen(delegate.getDefaultTempDirCleanupMode()).thenReturn(NEVER);\n\n\t\tassertThat(cache.getDefaultTempDirCleanupMode()).isSameAs(NEVER);\n\t\tassertThat(cache.getDefaultTempDirCleanupMode()).isSameAs(NEVER);\n\n\t\tverify(delegate, only()).getDefaultTempDirCleanupMode();\n\t}",
    "comment": "call `cache.getDefaultTempStrategyDirCleanupMode()` twice to verify the delegate method is called only once."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuilder.java",
    "type": "method",
    "name": "hasFatalErrors",
    "code": "protected boolean hasFatalErrors(ModelProblemCollectorExt problems) {\n        if (problems instanceof DefaultModelProblemCollector collector) {\n            return collector.hasFatalErrors();\n        } else {\n            throw new IllegalStateException();\n        }\n    }",
    "comment": "the default execution path only knows the DefaultModelProblemCollector,\nonly reason it's not in signature is because it's package private"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/OneForOneBlockFetcher.java",
    "type": "method",
    "name": "splitBlockId",
    "code": "private String[] splitBlockId(String blockId) {\n    String[] blockIdParts = blockId.split(\"_\");\n    if (blockIdParts.length < 4 || blockIdParts.length > 5) {\n      throw new IllegalArgumentException(\"Unexpected shuffle block id format: \" + blockId);\n    }\n    if (blockIdParts.length == 4 && !blockIdParts[0].equals(SHUFFLE_BLOCK_SPLIT)) {\n      throw new IllegalArgumentException(\"Unexpected shuffle block id format: \" + blockId);\n    }\n    if (blockIdParts.length == 5 &&\n      !(blockIdParts[0].equals(SHUFFLE_BLOCK_SPLIT) ||\n        blockIdParts[0].equals(SHUFFLE_CHUNK_SPLIT))) {\n      throw new IllegalArgumentException(\"Unexpected shuffle block id format: \" + blockId);\n    }\n    return blockIdParts;\n  }",
    "comment": "Split the blockId and return accordingly\nshuffleChunk - return shuffleId, shuffleMergeId, reduceId and chunkIds\nshuffle block - return shuffleId, mapId, reduceId\nshuffle batch block - return shuffleId, mapId, begin reduceId and end reduceId"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "hasNext",
    "code": "public boolean hasNext() {\n      return byteIndex < numBytes;\n    }",
    "comment": "Code point iterator implementation for the UTF8String class. The iterator will return code\npoints in the current string one by one, as integers. However, the code point iterator is only\nguaranteed to work if the current UTF8String does not contain any invalid UTF-8 byte sequences.\nIf the current string contains any invalid UTF-8 byte sequences, exceptions will be thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/ViewChange.java",
    "type": "method",
    "name": "setProperty",
    "code": "static ViewChange setProperty(String property, String value) {\n    return new SetProperty(property, value);\n  }",
    "comment": "Create a ViewChange for setting a table property.\n\n@param property the property name\n@param value the new property value\n@return a ViewChange"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java",
    "type": "method",
    "name": "threadGroupForNewThread",
    "code": "private ThreadGroup threadGroupForNewThread() {\n        if (!lookForStuckThread) {\n            return null;\n        }\n\n        ThreadGroup threadGroup = new ThreadGroup(\"FailOnTimeoutGroup\");\n        if (!threadGroup.isDaemon()) {\n            try {\n                threadGroup.setDaemon(true);\n            } catch (SecurityException e) {\n            }\n        }\n        return threadGroup;\n    }",
    "comment": "Use the default ThreadGroup (usually the one from the current\nthread).\nCreate the thread in a new ThreadGroup, so if the time-limited thread\nbecomes stuck, getStuckThread() can find the thread likely to be the\nculprit.\nMark the new ThreadGroup as a daemon thread group, so it will be\ndestroyed after the time-limited thread completes. By ensuring the\nThreadGroup is destroyed, any data associated with the ThreadGroup\n(ex: via java.beans.ThreadGroupContext) is destroyed.\nSwallow the exception to keep the same behavior as in JUnit 4.12."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/converter/src/main/java/com/iluwatar/converter/Converter.java",
    "type": "method",
    "name": "createFromEntities",
    "code": "public final List<T> createFromEntities(final Collection<U> entities) {\n    return entities.stream().map(this::convertFromEntity).toList();\n  }",
    "comment": "Converts list of Entities to list of DTOs.\n\n@param entities collection of domain entities\n@return List of domain representation of provided entities retrieved by mapping each of them\nwith the conversion function"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
    "type": "method",
    "name": "execute",
    "code": "public void execute() {\n\t\ttry {\n\t\t\tthrowableCollector = taskContext.getThrowableCollectorFactory().create();\n\t\t\tprepare();\n\t\t\tif (throwableCollector.isEmpty()) {\n\t\t\t\tcheckWhetherSkipped();\n\t\t\t}\n\t\t\tif (throwableCollector.isEmpty() && !skipResult.isSkipped()) {\n\t\t\t\texecuteRecursively();\n\t\t\t}\n\t\t\tif (context != null) {\n\t\t\t\tcleanUp();\n\t\t\t}\n\t\t\treportCompletion();\n\t\t}\n\t\tfinally {\n\t\t\tif (Thread.interrupted()) {\n\t\t\t\tlogger.debug(() -> String.format(\n\t\t\t\t\t\"Execution of TestDescriptor with display name [%s] \"\n\t\t\t\t\t\t\t+ \"and unique ID [%s] failed to clear the 'interrupted status' flag for the \"\n\t\t\t\t\t\t\t+ \"current thread. JUnit has cleared the flag, but you may wish to investigate \"\n\t\t\t\t\t\t\t+ \"why the flag was not cleared by user code.\",\n\t\t\t\t\tthis.testDescriptor.getDisplayName(), this.testDescriptor.getUniqueId()));\n\t\t\t}\n\t\t\tfinalizer.run();\n\t\t}\n\n\t\tcontext = null;\n\t}",
    "comment": "Ensure that the 'interrupted status' flag for the current thread\nis cleared for reuse of the thread in subsequent task executions.\nSee https://github.com/junit-team/junit5/issues/1688\nClear reference to context to allow it to be garbage collected.\nSee https://github.com/junit-team/junit5/issues/1578"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/JUnitCore.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String... args) {\n        System.exit(runMain(args));\n    }",
    "comment": "Run the tests contained in the classes named in the <code>args</code>.\nIf all tests run successfully, exit with a status of 0. Otherwise exit with a status of 1.\nWrite feedback while tests are running and write\nstack traces for all failed tests after the tests all complete.\n\n@param args names of classes in which to find tests to run"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/test/java/org/apache/spark/sql/hive/test/Complex.java",
    "type": "method",
    "name": "findByThriftIdOrThrow",
    "code": "public static _Fields findByThriftIdOrThrow(int fieldId) {\n      _Fields fields = findByThriftId(fieldId);\n      if (fields == null) throw new IllegalArgumentException(\"Field \" + fieldId + \" doesn't exist!\");\n      return fields;\n    }",
    "comment": "Find the _Fields constant that matches fieldId, throwing an exception\nif it is not found."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TemporaryFolder.java",
    "type": "method",
    "name": "delete",
    "code": "public void delete() {\n        if (!tryDelete()) {\n            if (assureDeletion) {\n                fail(\"Unable to clean up temporary folder \" + folder);\n            }\n        }\n    }",
    "comment": "Delete all files and folders under the temporary folder. Usually not\ncalled directly, since it is automatically applied by the {@link Rule}.\n\n@throws AssertionError if unable to clean up resources\nand deletion of resources is assured."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/AnnotationSupport.java",
    "type": "method",
    "name": "findAnnotatedFieldValues",
    "code": "public static List<Object> findAnnotatedFieldValues(Object instance, Class<? extends Annotation> annotationType) {\n\t\tPreconditions.notNull(instance, \"instance must not be null\");\n\n\t\tList<Field> fields = findAnnotatedFields(instance.getClass(), annotationType, ModifierSupport::isNotStatic,\n\t\t\tHierarchyTraversalMode.TOP_DOWN);\n\n\t\treturn ReflectionUtils.readFieldValues(fields, instance);\n\t}",
    "comment": "Find the values of all non-static {@linkplain Field fields} of the supplied\n{@code instance} that are annotated or <em>meta-annotated</em> with the\nspecified {@code annotationType}, using top-down search semantics within\nthe type hierarchy.\n\n<p>Values from fields declared in the same class or interface will be\nordered using an algorithm that is deterministic but intentionally\nnonobvious.\n\n<p>The results will not contain values from fields that are <em>hidden</em>\nor {@linkplain Field#isSynthetic() synthetic}.\n\n@param instance the instance in which to find the fields; never {@code null}\n@param annotationType the annotation type to search for; never {@code null}\n@return the list of all such field values found; neither {@code null} nor mutable\n@since 1.4\n@see #findAnnotatedFields(Class, Class)\n@see #findAnnotatedFields(Class, Class, Predicate, HierarchyTraversalMode)\n@see ReflectionSupport#findFields(Class, Predicate, HierarchyTraversalMode)\n@see ReflectionSupport#tryToReadFieldValue(Field, Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(boolean[] expected, boolean[] actual, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} boolean arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/main/java/org/apache/hadoop/hive/ql/exec/HiveFunctionRegistryUtils.java",
    "type": "method",
    "name": "if",
    "code": "if (udfMethods.size() > 1) {\n\n      int lowestNumericType = Integer.MAX_VALUE;\n      boolean multiple = true;\n      Method candidate = null;\n      List<TypeInfo> referenceArguments = null;\n\n      for (Method m: udfMethods) {\n        int maxNumericType = 0;\n\n        List<TypeInfo> argumentsAccepted =\n            TypeInfoUtils.getParameterTypeInfos(m, argumentsPassed.size());\n\n        if (referenceArguments == null) {\n          referenceArguments = argumentsAccepted;\n        }\n\n        Iterator<TypeInfo> referenceIterator = referenceArguments.iterator();\n\n        for (TypeInfo accepted: argumentsAccepted) {\n          TypeInfo reference = referenceIterator.next();\n\n          boolean acceptedIsPrimitive = false;\n          PrimitiveCategory acceptedPrimCat = PrimitiveCategory.UNKNOWN;\n          if (accepted.getCategory() == Category.PRIMITIVE) {\n            acceptedIsPrimitive = true;\n            acceptedPrimCat = ((PrimitiveTypeInfo) accepted).getPrimitiveCategory();\n          }\n          if (acceptedIsPrimitive && TypeInfoUtils.numericTypes.containsKey(acceptedPrimCat)) {\n            int typeValue = TypeInfoUtils.numericTypes.get(acceptedPrimCat);\n            maxNumericType = typeValue > maxNumericType ? typeValue : maxNumericType;\n          } else if (!accepted.equals(reference)) {\n            throw new AmbiguousMethodException(udfClass, argumentsPassed, mlist);\n          }\n        }\n\n        if (lowestNumericType > maxNumericType) {\n          multiple = false;\n          lowestNumericType = maxNumericType;\n          candidate = m;\n        } else if (maxNumericType == lowestNumericType) {\n          multiple = true;\n        }\n      }\n\n      if (!multiple) {\n        return candidate;\n      } else {\n        throw new AmbiguousMethodException(udfClass, argumentsPassed, mlist);\n      }\n    }",
    "comment": "if the only difference is numeric types, pick the method\nwith the smallest overall numeric type.\nkeep the arguments for reference - we want all the non-numeric\narguments to be the same\nWe're looking for the udf with the smallest maximum numeric type.\nThere are non-numeric arguments that don't match from one UDF to\nanother. We give up at this point.\nmultiple udfs with the same max type. Unless we find a lower one\nwe'll give up."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestFailure.java",
    "type": "method",
    "name": "isFailure",
    "code": "public boolean isFailure() {\n        return thrownException() instanceof AssertionFailedError;\n    }",
    "comment": "Returns {@code true} if the error is considered a failure\n(i.e. if it is an instance of {@code AssertionFailedError}),\n{@code false} otherwise."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertFalse",
    "code": "public static void assertFalse(String message, boolean condition) {\n        assertTrue(message, !condition);\n    }",
    "comment": "Asserts that a condition is false. If it isn't it throws\nan AssertionFailedError with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/PathModularization.java",
    "type": "method",
    "name": "containsModule",
    "code": "public boolean containsModule(String name) {\n        return descriptors.containsValue(name);\n    }",
    "comment": "{@return whether the dependency contains a module of the given name}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "public void resolve(EngineDiscoveryRequest request, T engineDescriptor, DiscoveryIssueReporter issueReporter) {\n\t\tPreconditions.notNull(request, \"request must not be null\");\n\t\tPreconditions.notNull(engineDescriptor, \"engineDescriptor must not be null\");\n\t\tPreconditions.notNull(issueReporter, \"issueReporter must not be null\");\n\t\tInitializationContext<T> initializationContext = new DefaultInitializationContext<>(request, engineDescriptor,\n\t\t\tissueReporter);\n\t\tList<SelectorResolver> resolvers = instantiate(resolverCreators, initializationContext);\n\t\tList<TestDescriptor.Visitor> visitors = instantiate(visitorCreators, initializationContext);\n\t\tnew EngineDiscoveryRequestResolution(request, engineDescriptor, resolvers, visitors).run();\n\t}",
    "comment": "Resolve the supplied {@link EngineDiscoveryRequest} and collect the\nresults into the supplied {@link TestDescriptor} using the supplied\n{@link DiscoveryIssueReporter} to report issues encountered during\nresolution.\n\n<p>The algorithm works as described in\n{@link #resolve(EngineDiscoveryRequest, TestDescriptor)}.\n\n@param request the request to be resolved; never {@code null}\n@param engineDescriptor the engine's {@code TestDescriptor} to be used\nfor adding direct children\n@param issueReporter the {@link DiscoveryIssueReporter} to report issues\nencountered during resolution\n@since 1.13\n@see #resolve(EngineDiscoveryRequest, TestDescriptor)\n@see SelectorResolver\n@see TestDescriptor.Visitor"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/DiscoveryIssue.java",
    "type": "method",
    "name": "builder",
    "code": "static Builder builder(Severity severity, String message) {\n\t\tPreconditions.notNull(severity, \"severity must not be null\");\n\t\tPreconditions.notBlank(message, \"message must not be blank\");\n\t\treturn new DefaultDiscoveryIssue.Builder(severity, message);\n\t}",
    "comment": "Create a new {@link Builder} for creating a {@code DiscoveryIssue} with\n\n@param severity the severity of the issue; never {@code null}\n@param message the message of the issue; never blank\n@see Builder\n@see #create(Severity, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/TestCase.java",
    "type": "method",
    "name": "assertNotSame",
    "code": "public static void assertNotSame(Object expected, Object actual) {\n        Assert.assertNotSame(expected, actual);\n    }",
    "comment": "Asserts that two objects do not refer to the same object. If they do\nrefer to the same object an AssertionFailedError is thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultPluginManagementInjector.java",
    "type": "method",
    "name": "injectManagement",
    "code": "public Model injectManagement(Model model, ModelBuilderRequest request, ModelProblemCollector problems) {\n        return merger.mergeManagedBuildPlugins(model);\n    }",
    "comment": "Handles injection of plugin management into the model."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java",
    "type": "method",
    "name": "supportsReturnsFalseForMissingTestMethod",
    "code": "void supportsReturnsFalseForMissingTestMethod() {\n\t\tvar extensionContextWithoutTestMethod = getExtensionContextReturningSingleMethod(new TestCaseWithoutMethod());\n\t\tassertFalse(this.parameterizedTestExtension.supportsTestTemplate(extensionContextWithoutTestMethod));\n\t}",
    "comment": "Unit tests for {@link ParameterizedTestExtension}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TestWatcher.java",
    "type": "method",
    "name": "skipped",
    "code": "protected void skipped(AssumptionViolatedException e, Description description) {\n        // For backwards compatibility with JUnit 4.11 and earlier, call the legacy version\n        org.junit.internal.AssumptionViolatedException asInternalException = e;\n        skipped(asInternalException, description);\n    }",
    "comment": "Invoked when a test is skipped due to a failed assumption."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "addSparkArg",
    "code": "public T addSparkArg(String arg) {\n    SparkSubmitOptionParser validator = new ArgumentValidator(false);\n    validator.parse(Arrays.asList(arg));\n    builder.userArgs.add(arg);\n    return self();\n  }",
    "comment": "Adds a no-value argument to the Spark invocation. If the argument is known, this method\nvalidates whether the argument is indeed a no-value argument, and throws an exception\notherwise.\n<p>\nUse this method with caution. It is possible to create an invalid Spark command by passing\nunknown arguments to this method, since those are allowed for forward compatibility.\n\n@since 1.5.0\n@param arg Argument to add.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/notification/src/main/java/com/iluwatar/RegisterWorker.java",
    "type": "method",
    "name": "isNullOrBlank",
    "code": "protected boolean isNullOrBlank(Object obj) {\n    if (obj == null) {\n      return true;\n    }\n\n    if (obj instanceof String) {\n      return ((String) obj).trim().isEmpty();\n    }\n\n    return false;\n  }",
    "comment": "Validates for null/empty value.\n\n@param obj any object\n@return boolean"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/GraphOperationBuilder.java",
    "type": "method",
    "name": "build",
    "code": "public GraphOperation build() {\n    Graph.Reference r = graph.ref();\n    try {\n      GraphOperation op = new GraphOperation(graph, finish(unsafeNativeHandle));\n      unsafeNativeHandle = 0;\n      return op;\n    } finally {\n      r.close();\n    }\n  }",
    "comment": "Add the {@link GraphOperation} being built to the {@link Graph}.\n\n<p>The OperationBuilder is not usable after build() returns."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/money/src/main/java/com/iluwatar/Money.java",
    "type": "method",
    "name": "multiply",
    "code": "public void multiply(int factor) {\n    if (factor < 0) {\n      throw new IllegalArgumentException(\"Factor must be non-negative\");\n    }\n    this.amount = roundToTwoDecimals(this.amount * factor);\n  }",
    "comment": "Multiplies the current amount of money by a factor.\n\n@param factor the factor to multiply by.\n@throws IllegalArgumentException if the factor is negative."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "getFullyQualifiedMethodName",
    "code": "public static String getFullyQualifiedMethodName(String className, String methodName, String parameterTypeNames) {\n\t\tPreconditions.notBlank(className, \"Class name must not be null or blank\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\t\tPreconditions.notNull(parameterTypeNames, \"Parameter type names must not be null\");\n\n\t\treturn String.format(\"%s#%s(%s)\", className, methodName, parameterTypeNames);\n\t}",
    "comment": "Build the <em>fully qualified method name</em> for the method described by the\nsupplied class name, method name, and parameter types.\n\n<p>Note that the class is not necessarily the class in which the method is\ndeclared.\n\n@param className the name of the class from which the method should be referenced;\nnever {@code null}\n@param methodName the name of the method; never {@code null} or blank\n@param parameterTypeNames the parameter type names of the method; may be\nempty but not {@code null}\n@return fully qualified method name; never {@code null}\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/page-object/src/test/java/com/iluwatar/pageobject/pages/AlbumPage.java",
    "type": "method",
    "name": "saveChanges",
    "code": "public AlbumPage saveChanges() {\n    var saveButton = (HtmlSubmitInput) page.getElementById(\"saveButton\");\n    try {\n      saveButton.click();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return this;\n  }",
    "comment": "Saves changes made by clicking the save button\n\n@return {@link AlbumPage}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-settings-builder/src/main/java/org/apache/maven/settings/crypto/MavenSecDispatcher.java",
    "type": "method",
    "name": "configurationFile",
    "code": "private static Path configurationFile() {\n        String mavenUserConf = System.getProperty(Constants.MAVEN_USER_CONF);\n        if (mavenUserConf != null) {\n            return Paths.get(mavenUserConf, FILE_NAME);\n        }\n        return Paths.get(System.getProperty(\"user.home\"), \".m2\", FILE_NAME);\n    }",
    "comment": "this means we are in UT or alike"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/ParquetColumnVector.java",
    "type": "method",
    "name": "assembleStruct",
    "code": "private void assembleStruct() {\n    int maxRepetitionLevel = column.repetitionLevel();\n    int maxDefinitionLevel = column.definitionLevel();\n\n    vector.reserve(definitionLevels.getElementsAppended());\n\n    int rowId = 0;\n    boolean hasRepetitionLevels =\n      repetitionLevels != null && repetitionLevels.getElementsAppended() > 0;\n    for (int i = 0; i < definitionLevels.getElementsAppended(); i++) {\n      if (!hasRepetitionLevels || repetitionLevels.getInt(i) <= maxRepetitionLevel) {\n        if (definitionLevels.getInt(i) <= maxDefinitionLevel - 1) {\n          vector.putNull(rowId);\n          rowId++;\n        } else if (definitionLevels.getInt(i) >= maxDefinitionLevel) {\n          vector.putNotNull(rowId);\n          rowId++;\n        }\n      }\n    }\n    vector.addElementsAppended(rowId);\n  }",
    "comment": "If repetition level > maxRepetitionLevel, the value is a nested element (e.g., an array\nelement in struct<array<int>>), and we should skip the definition level since it doesn't\nrepresent with the struct.\nStruct is null"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/NameScope.java",
    "type": "method",
    "name": "checkPattern",
    "code": "private static void checkPattern(Pattern pattern, String name) {\n    if (name == null) {\n      throw new IllegalArgumentException(\"Names cannot be null\");\n    }\n    if (!pattern.matcher(name).matches()) {\n      throw new IllegalArgumentException(\n          String.format(\n              \"invalid name: '%s' does not match the regular expression %s\",\n              name, NAME_REGEX.pattern()));\n    }\n  }",
    "comment": "If opPrefix is non-null, it is a prefix applied to all names\ncreated by this instance.\nIf opName is non-null, it is used to derive the unique name\nfor operators rather than the provided default name.\nNameScope generates unique names by appending a numeric suffix if\nneeded. This is a map containing names already created by this\ninstance mapped to the next available numeric suffix for it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/DefaultMaven.java",
    "type": "method",
    "name": "doExecute",
    "code": "private MavenExecutionResult doExecute(MavenExecutionRequest request) {\n        request.setStartInstant(MonotonicClock.now());\n\n        MavenExecutionResult result = new DefaultMavenExecutionResult();\n\n        try {\n            validateLocalRepository(request);\n        } catch (IOException e) {\n            return addExceptionToResult(result, e);\n        }\n\n        sessionScope.enter();\n        MavenChainedWorkspaceReader chainedWorkspaceReader =\n                new MavenChainedWorkspaceReader(request.getWorkspaceReader(), ideWorkspaceReader);\n        try (CloseableSession closeableSession = newCloseableSession(request, chainedWorkspaceReader)) {\n            MavenSession session = new MavenSession(closeableSession, request, result);\n            session.setSession(defaultSessionFactory.newSession(session));\n\n            sessionScope.seed(MavenSession.class, session);\n            sessionScope.seed(Session.class, session.getSession());\n            sessionScope.seed(InternalMavenSession.class, InternalMavenSession.from(session.getSession()));\n\n            legacySupport.setSession(session);\n\n            return doExecute(request, session, result, chainedWorkspaceReader);\n        } finally {\n            sessionScope.exit();\n        }\n    }",
    "comment": "1) Setup initial properties.\n\n2) Validate local repository directory is accessible.\n\n3) Create RepositorySystemSession.\n\n4) Create MavenSession.\n\n5) Execute AbstractLifecycleParticipant.afterSessionStart(session)\n\n6) Get reactor projects looking for general POM errors\n\n7) Create ProjectDependencyGraph using trimming which takes into account --projects and reactor mode.\nThis ensures that the projects passed into the ReactorReader are only those specified.\n\n8) Create ReactorReader with the getProjectMap( projects ). NOTE that getProjectMap(projects) is the code that\nchecks for duplicate projects definitions in the build. Ideally this type of duplicate checking should be\npart of getting the reactor projects in 6). The duplicate checking is conflated with getProjectMap(projects).\n\n9) Execute AbstractLifecycleParticipant.afterProjectsRead(session)\n\n10) Create ProjectDependencyGraph without trimming (as trimming was done in 7). A new topological sort is\nrequired after the execution of 9) as the AbstractLifecycleParticipants are free to mutate the MavenProject\ninstances, which may change dependencies which can, in turn, affect the build order.\n\n11) Execute LifecycleStarter.start()\n\n\nWe enter the session scope right after the MavenSession creation and before any of the\nAbstractLifecycleParticipant lookups\nso that @SessionScoped components can be @Injected into AbstractLifecycleParticipants."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "renameColumn",
    "code": "static TableChange renameColumn(String[] fieldNames, String newName) {\n    return new RenameColumn(fieldNames, newName);\n  }",
    "comment": "Create a TableChange for renaming a field.\n<p>\nThe name is used to find the field to rename. The new name will replace the leaf field name.\nFor example, renameColumn([\"a\", \"b\", \"c\"], \"x\") should produce column a.b.x.\n<p>\nIf the field does not exist, the change will result in an {@link IllegalArgumentException}.\n\n@param fieldNames the current field names\n@param newName the new name\n@return a TableChange for the rename"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/RuntimeUtils.java",
    "type": "method",
    "name": "isDebugMode",
    "code": "public static boolean isDebugMode() {\n\t\treturn getInputArguments() //\n\t\t\t\t.map(args -> args.stream().anyMatch(\n\t\t\t\t\targ -> arg.startsWith(\"-agentlib:jdwp\") || arg.startsWith(\"-Xrunjdwp\"))) //\n\t\t\t\t.orElse(false);\n\t}",
    "comment": "Try to determine whether the VM was started in debug mode or not."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/DependencyCoordinatesFactory.java",
    "type": "method",
    "name": "create",
    "code": "default DependencyCoordinates create(@Nonnull Session session, @Nonnull ArtifactCoordinates coordinates) {\n        return create(DependencyCoordinatesFactoryRequest.build(session, coordinates));\n    }",
    "comment": "Creates a new {@link DependencyCoordinates} object from the request.\n@return a new {@link DependencyCoordinates} object\nif {@code request.getSession()} is null or invalid"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/DependencyResolverRequest.java",
    "type": "method",
    "name": "builder",
    "code": "static DependencyResolverRequestBuilder builder() {\n        return new DependencyResolverRequestBuilder();\n    }",
    "comment": "Returns a filter for the types of path (class-path, module-path, …) accepted by the tool.\nFor example, if a Java tools accepts only class-path elements, then the filter should return\n{@code true} for {@link JavaPathType#CLASSES} and {@code false} for {@link JavaPathType#MODULES}.\nIf no filter is explicitly set, then the default is a filter accepting everything.\n\n@return a filter for the types of path (class-path, module-path, …) accepted by the tool"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/aggregate/Min.java",
    "type": "method",
    "name": "Min",
    "code": "public Min(Expression column) { this.input = column; }",
    "comment": "An aggregate function that returns the minimum value in a group.\n\n@since 3.2.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Float expected, float actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Float) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaDatasetAggregatorSuiteBase.java",
    "type": "method",
    "name": "setUp",
    "code": "public void setUp() {\n    // Trigger static initializer of TestData\n    spark = new TestSparkSession();\n    spark.loadTestData();\n  }",
    "comment": "Common test base shared across this and Java8DatasetAggregatorSuite."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(short expected, Short actual, String message) {\n\t\tAssertEquals.assertEquals((Short) expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/prefix/internal/DefaultPluginPrefixResolver.java",
    "type": "method",
    "name": "resolveFromRepository",
    "code": "private PluginPrefixResult resolveFromRepository(PluginPrefixRequest request) {\n        RequestTrace trace = RequestTrace.newChild(null, request);\n\n        List<MetadataRequest> requests = new ArrayList<>();\n\n        for (String pluginGroup : request.getPluginGroups()) {\n            org.eclipse.aether.metadata.Metadata metadata =\n                    new DefaultMetadata(pluginGroup, \"maven-metadata.xml\", DefaultMetadata.Nature.RELEASE_OR_SNAPSHOT);\n\n            requests.add(new MetadataRequest(metadata, null, REPOSITORY_CONTEXT).setTrace(trace));\n\n            for (RemoteRepository repository : request.getRepositories()) {\n                requests.add(new MetadataRequest(metadata, repository, REPOSITORY_CONTEXT).setTrace(trace));\n            }\n        }\n\n\n        List<MetadataResult> results = repositorySystem.resolveMetadata(request.getRepositorySession(), requests);\n        requests.clear();\n\n        PluginPrefixResult result = processResults(request, trace, results, requests);\n\n        if (result != null) {\n            return result;\n        }\n\n\n        if (!request.getRepositorySession().isOffline() && !requests.isEmpty()) {\n            DefaultRepositorySystemSession session = new DefaultRepositorySystemSession(request.getRepositorySession());\n            session.setUpdatePolicy(RepositoryPolicy.UPDATE_POLICY_ALWAYS);\n\n            results = repositorySystem.resolveMetadata(session, requests);\n\n            return processResults(request, trace, results, null);\n        }\n\n        return null;\n    }",
    "comment": "initial try, use locally cached metadata\nsecond try, refetch all (possibly outdated) metadata that wasn't updated in the first attempt"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExecutableInvoker.java",
    "type": "method",
    "name": "invoke",
    "code": "default <T> T invoke(Constructor<T> constructor) {\n\t\treturn invoke(constructor, null);\n\t}",
    "comment": "Invoke the supplied top-level constructor with dynamic parameter resolution.\n\n@param constructor the constructor to invoke and resolve parameters for\n@see #invoke(Constructor, Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/OneForOneBlockFetcher.java",
    "type": "method",
    "name": "isAnyBlockNotStartWithShuffleBlockPrefix",
    "code": "private static boolean isAnyBlockNotStartWithShuffleBlockPrefix(String[] blockIds) {\n    for (String blockId : blockIds) {\n      if (!blockId.startsWith(SHUFFLE_BLOCK_PREFIX)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "SPARK-40398: Replace `Arrays.stream().anyMatch()` with this method due to perf gain."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "trimTrailingSpaces",
    "code": "public UTF8String trimTrailingSpaces(int numSpaces) {\n    assert numSpaces > 0;\n    int endIdx = numBytes - 1;\n    int trimTo = numBytes - numSpaces;\n    while (endIdx >= trimTo && getByte(endIdx) == 0x20) endIdx--;\n    return copyUTF8String(0, endIdx);\n  }",
    "comment": "Trims at most `numSpaces` space characters (ASCII 32) from the end of this string."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "toUpperCaseSlow",
    "code": "private static UTF8String toUpperCaseSlow(final UTF8String target, final int collationId) {\n    ULocale locale = CollationFactory.fetchCollation(collationId)\n      .getCollator().getLocale(ULocale.ACTUAL_LOCALE);\n    return UTF8String.fromString(UCharacter.toUpperCase(locale, target.toValidString()));\n  }",
    "comment": "Note: In order to achieve the desired behavior, we use the ICU UCharacter class to\nconvert the string to uppercase, which only accepts a Java strings as input."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(boolean[] expected, boolean[] actual) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} boolean arrays are equal.\n<p>If both are {@code null}, they are considered equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaUserDefinedUntypedAggregation.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"Java Spark SQL user-defined DataFrames aggregation example\")\n      .getOrCreate();\n\n    spark.udf().register(\"myAverage\", functions.udaf(new MyAverage(), Encoders.LONG()));\n\n    Dataset<Row> df = spark.read().json(\"examples/src/main/resources/employees.json\");\n    df.createOrReplaceTempView(\"employees\");\n    df.show();\n\n    Dataset<Row> result = spark.sql(\"SELECT myAverage(salary) as average_salary FROM employees\");\n    result.show();\n\n    spark.stop();\n  }",
    "comment": "$example off:untyped_custom_aggregation$\n$example on:untyped_custom_aggregation$\nRegister the function to access it\n+-------+------+\n|   name|salary|\n+-------+------+\n|Michael|  3000|\n|   Andy|  4500|\n| Justin|  3500|\n|  Berta|  4000|\n+-------+------+\n+--------------+\n|average_salary|\n+--------------+\n|        3750.0|\n+--------------+\n$example off:untyped_custom_aggregation$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStore.java",
    "type": "method",
    "name": "NamespacedHierarchicalStore",
    "code": "public NamespacedHierarchicalStore(NamespacedHierarchicalStore<N> parentStore, CloseAction<N> closeAction) {\n\t\tthis.parentStore = parentStore;\n\t\tthis.closeAction = closeAction;\n\t}",
    "comment": "Create a new store with the supplied parent and close action.\n\n@param parentStore the parent store to use for lookups; may be {@code null}\n@param closeAction the action to be called for each stored value when this\nstore is closed; may be {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryOrchestrator.java",
    "type": "method",
    "name": "discover",
    "code": "public LauncherDiscoveryResult discover(LauncherDiscoveryRequest request, Phase phase) {\n\t\treturn discover(request, phase, UniqueId::forEngine);\n\t}",
    "comment": "Discovers tests for the supplied request in the supplied phase using the\nconfigured test engines.\n\n<p>Applies {@linkplain org.junit.platform.launcher.EngineFilter engine\nfilters} and {@linkplain PostDiscoveryFilter post-discovery filters} and\n{@linkplain TestDescriptor#prune() prunes} the resulting test tree."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/NameScope.java",
    "type": "method",
    "name": "makeOpName",
    "code": "String makeOpName(String name) {\n    checkPattern(NAME_REGEX, name);\n    String actualName = (opName != null) ? opName : name;\n    return fullyQualify(makeUnique(actualName));\n  }",
    "comment": "Override with opName if it exists."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/LoggingListener.java",
    "type": "method",
    "name": "forJavaUtilLogging",
    "code": "public static LoggingListener forJavaUtilLogging(Level logLevel) {\n\t\tPreconditions.notNull(logLevel, \"logLevel must not be null\");\n\t\tLogger logger = Logger.getLogger(LoggingListener.class.getName());\n\t\treturn new LoggingListener((t, messageSupplier) -> logger.log(logLevel, t, messageSupplier));\n\t}",
    "comment": "Create a {@code LoggingListener} which delegates to a\n{@link java.util.logging.Logger} using the supplied\n{@linkplain Level log level}.\n\n@param logLevel the log level to use; never {@code null}\n@see #forJavaUtilLogging()\n@see #forBiConsumer(BiConsumer)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java",
    "type": "method",
    "name": "getJavaMethod",
    "code": "public Method getJavaMethod() {\n\t\tlazyLoadJavaMethod();\n\t\treturn this.javaMethod;\n\t}",
    "comment": "Get the selected {@link Method}.\n\n<p>If the {@link Method} was not provided, but only the name, this method\nattempts to lazily load the {@code Method} based on its name and throws a\n{@link PreconditionViolationException} if the method cannot be loaded.\n\n@see #getJavaClass()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/util/collection/unsafe/sort/UnsafeInMemorySorterSuite.java",
    "type": "method",
    "name": "RecordComparator",
    "code": "final RecordComparator recordComparator = new RecordComparator() {\n    };",
    "comment": "Since the key fits within the 8-byte prefix, we don't need to do any record comparison, so\nuse a dummy comparator"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/PackageSource.java",
    "type": "method",
    "name": "from",
    "code": "public static PackageSource from(String packageName) {\n\t\treturn new PackageSource(packageName);\n\t}",
    "comment": "Create a new {@code PackageSource} using the supplied {@code packageName}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuilder.java",
    "type": "method",
    "name": "if",
    "code": "for (ModelData currentData = resultData; currentData != null; ) {\n            lineage.add(currentData);\n\n            Model rawModel = currentData.getModel();\n            currentData.setRawModel(rawModel);\n\n            Model tmpModel = rawModel.clone();\n            currentData.setModel(tmpModel);\n\n            problems.setSource(tmpModel);\n\n            modelNormalizer.mergeDuplicates(tmpModel, request, problems);\n\n            profileActivationContext.setProjectProperties(tmpModel.getProperties());\n\n            List<Profile> interpolatedProfiles = getInterpolatedProfiles(rawModel, profileActivationContext, problems);\n            tmpModel.setProfiles(interpolatedProfiles);\n\n            List<Profile> activePomProfiles =\n                    profileSelector.getActiveProfiles(tmpModel.getProfiles(), profileActivationContext, problems);\n\n            List<Profile> rawProfiles = new ArrayList<>();\n            for (Profile activePomProfile : activePomProfiles) {\n                rawProfiles.add(rawModel.getProfiles().get(interpolatedProfiles.indexOf(activePomProfile)));\n            }\n            currentData.setActiveProfiles(rawProfiles);\n\n            for (Profile activeProfile : activePomProfiles) {\n                profileInjector.injectProfile(tmpModel, activeProfile, request, problems);\n            }\n\n            if (currentData == resultData) {\n                for (Profile activeProfile : activeExternalProfiles) {\n                    profileInjector.injectProfile(tmpModel, activeProfile, request, problems);\n                }\n            }\n\n            if (currentData == superData) {\n                break;\n            }\n\n            configureResolver(request.getModelResolver(), tmpModel, problems);\n\n            ModelData parentData = readParent(tmpModel, currentData.getSource(), request, problems);\n\n            if (parentData == null) {\n                currentData = superData;\n            } else if (currentData == resultData) { // First iteration - add initial id after version resolution.\n                currentData.setGroupId(\n                        currentData.getRawModel().getGroupId() == null\n                                ? parentData.getGroupId()\n                                : currentData.getRawModel().getGroupId());\n\n                currentData.setVersion(\n                        currentData.getRawModel().getVersion() == null\n                                ? parentData.getVersion()\n                                : currentData.getRawModel().getVersion());\n\n                currentData.setArtifactId(currentData.getRawModel().getArtifactId());\n                parentIds.add(currentData.getId());\n                currentData.setGroupId(null);\n                currentData.setArtifactId(null);\n                currentData.setVersion(null);\n                currentData = parentData;\n            } else if (!parentIds.add(parentData.getId())) {\n                StringBuilder message = new StringBuilder(\"The parents form a cycle: \");\n                for (String modelId : parentIds) {\n                    message.append(modelId);\n                    message.append(\" -> \");\n                }\n                message.append(parentData.getId());\n\n                problems.add(new ModelProblemCollectorRequest(ModelProblem.Severity.FATAL, ModelProblem.Version.BASE)\n                        .setMessage(message.toString()));\n\n                throw problems.newModelBuildingException();\n            } else {\n                currentData = parentData;\n            }\n        }",
    "comment": "model normalization\nprofile injection\nReset - only needed for 'getId'."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/test/java/org/tensorflow/TestUtil.java",
    "type": "method",
    "name": "flatten",
    "code": "public static Object flatten(Object array, Class<?> elementType) {\n    Object out = Array.newInstance(elementType, flattenedNumElements(array));\n    flatten(array, out, 0);\n    return out;\n  }",
    "comment": "Flattens an ND-array into a 1D-array with the same elements.\n\n@param array the array to flatten\n@param elementType the element class (e.g. {@code Integer.TYPE} for an {@code int[]})\n@return a flattened array"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/ProjectActivation.java",
    "type": "method",
    "name": "getSelectedProjects",
    "code": "public List<String> getSelectedProjects() {\n        return Collections.unmodifiableList(new ArrayList<>(getProjectSelectors(pa -> pa.active())));\n    }",
    "comment": "Mimics the pre-Maven 4 \"selected projects\" list.\n@deprecated Use {@link #getRequiredActiveProjectSelectors()} and {@link #getOptionalActiveProjectSelectors()}\ninstead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/reflection/ClassMap.java",
    "type": "method",
    "name": "getAccessibleMethods",
    "code": "private static int getAccessibleMethods(Class<?> clazz, MethodInfo[] methodInfos, int upcastCount) {\n        int l = methodInfos.length;\n\n        // if this class is public, then check each of the currently\n        // 'non-upcasted' methods to see if we have a match\n        if (Modifier.isPublic(clazz.getModifiers())) {\n            for (int i = 0; i < l && upcastCount < l; ++i) {\n                try {\n                    MethodInfo methodInfo = methodInfos[i];\n                    if (!methodInfo.upcast) {\n                        methodInfo.tryUpcasting(clazz);\n                        upcastCount++;\n                    }\n                } catch (NoSuchMethodException e) {\n                    // Intentionally ignored - it means it wasn't found in the current class\n                }\n            }\n\n            /*\n             *  Short circuit if all methods were upcast\n             */\n\n            if (upcastCount == l) {\n                return upcastCount;\n            }\n        }\n\n        // Examine superclass\n        Class<?> superclazz = clazz.getSuperclass();\n        if (superclazz != null) {\n            upcastCount = getAccessibleMethods(superclazz, methodInfos, upcastCount);\n\n            // Short circuit if all methods were upcast\n            if (upcastCount == l) {\n                return upcastCount;\n            }\n        }\n\n        // Examine interfaces. Note we do it even if superclazz == null.\n        // This is redundant as currently java.lang.Object does not implement\n        // any interfaces, however nothing guarantees it will not in the future.\n        Class<?>[] interfaces = clazz.getInterfaces();\n        for (int i = interfaces.length; i-- > 0; ) {\n            upcastCount = getAccessibleMethods(interfaces[i], methodInfos, upcastCount);\n\n            // Short circuit if all methods were upcast\n            if (upcastCount == l) {\n                return upcastCount;\n            }\n        }\n\n        return upcastCount;\n    }",
    "comment": "Recursively finds a match for each method, starting with the class, and then\nsearching the superclass and interfaces.\n\n@param clazz       Class to check\n@param methodInfos array of methods we are searching to match\n@param upcastCount current number of methods we have matched\n@return count of matched methods"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/read/streaming/SupportsAdmissionControl.java",
    "type": "method",
    "name": "reportLatestOffset",
    "code": "default Offset reportLatestOffset() { return null; }\n}",
    "comment": "Returns the most recent offset available.\n<p>\nThe source can return `null`, if there is no data to process or the source does not support\nto this method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/ServiceOperations.java",
    "type": "method",
    "name": "stopQuietly",
    "code": "public static Exception stopQuietly(Service service) {\n    try {\n      stop(service);\n    } catch (Exception e) {\n      LOG.warn(\"When stopping the service {}\", e,\n        MDC.of(LogKeys.SERVICE_NAME$.MODULE$, service.getName()));\n      return e;\n    }\n    return null;\n  }",
    "comment": "Stop a service; if it is null do nothing. Exceptions are caught and\nlogged at warn level. (but not Throwables). This operation is intended to\nbe used in cleanup operations\n\n@param service a service; may be null\n@return any exception that was caught; null if none was."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/DefaultProjectRealmCache.java",
    "type": "method",
    "name": "register",
    "code": "public void register(MavenProject project, Key key, CacheRecord record) {\n    }",
    "comment": "default cache does not track record usage"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultArtifact.java",
    "type": "method",
    "name": "DefaultArtifact",
    "code": "public DefaultArtifact(@Nonnull InternalSession session, @Nonnull org.eclipse.aether.artifact.Artifact artifact) {\n        this.session = nonNull(session, \"session\");\n        this.artifact = nonNull(artifact, \"artifact\");\n        this.key = getGroupId()\n                + ':'\n                + getArtifactId()\n                + ':'\n                + getExtension()\n                + (getClassifier().isEmpty() ? \"\" : \":\" + getClassifier())\n                + ':'\n                + getVersion();\n    }",
    "comment": "A wrapper class around a maven resolver artifact."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/procedures/ProcedureParameter.java",
    "type": "method",
    "name": "defaultValue",
    "code": "public Builder defaultValue(Expression expression) {\n      this.defaultValue = new DefaultValue(expression);\n      return this;\n    }",
    "comment": "Sets the default value of the parameter using an expression."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/BasicRxJavaSample/app/src/androidTest/java/com/example/android/observability/persistence/LocalUserDataSourceTest.java",
    "type": "method",
    "name": "updateAndGetUser",
    "code": "public void updateAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER).blockingAwait();\n\n        User updatedUser = new User(USER.getId(), \"new username\");\n        mDataSource.insertOrUpdateUser(updatedUser).blockingAwait();\n\n        mDatabase.userDao().getUser()\n                .test()\n                .assertValue(user -> {\n                    return user != null && user.getId().equals(USER.getId()) &&\n                            user.getUserName().equals(\"new username\");\n                });\n    }",
    "comment": "Given that we have a user in the data source\nWhen we are updating the name of the user\nWhen subscribing to the emissions of the user\nassertValue asserts that there was only one emission of the user\nThe emitted user is the expected one"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/plugin/testing/MojoExtension.java",
    "type": "method",
    "name": "getBasedir",
    "code": "public static String getBasedir() {\n        return requireNonNull(basedir != null ? basedir : MavenDIExtension.basedir);\n    }",
    "comment": "Gets the base directory for test resources.\nIf not explicitly set via {@link Basedir}, returns the plugin base directory.\n\n@return the base directory path\n@throws NullPointerException if neither basedir nor plugin basedir is set"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java",
    "type": "method",
    "name": "getGeneratorFor",
    "code": "private static DisplayNameGenerator getGeneratorFor(Class<?> testClass, List<Class<?>> enclosingInstanceTypes) {\n\t\t\treturn findIndicativeSentencesGeneration(testClass, enclosingInstanceTypes)//\n\t\t\t\t\t.map(IndicativeSentencesGeneration::generator)//\n\t\t\t\t\t.filter(notIndicativeSentences)//\n\t\t\t\t\t.map(DisplayNameGenerator::getDisplayNameGenerator)//\n\t\t\t\t\t.orElseGet(() -> getDisplayNameGenerator(IndicativeSentencesGeneration.DEFAULT_GENERATOR));\n\t\t}",
    "comment": "Get the display name generator to use for the supplied test class.\n\n<p>If {@link IndicativeSentencesGeneration @IndicativeSentencesGeneration}\nis present (searching enclosing classes if not found locally), the\nconfigured {@link IndicativeSentencesGeneration#generator() generator}\nwill be used. Otherwise, {@link IndicativeSentencesGeneration#DEFAULT_GENERATOR}\nwill be used.\n\n@param testClass the test class to search on for {@code @IndicativeSentencesGeneration}\n@param enclosingInstanceTypes the runtime types of the enclosing\ninstances; never {@code null}\n@return the {@code DisplayNameGenerator} instance to use"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(byte expected, byte actual) {\n        assertEquals(null, expected, actual);\n    }",
    "comment": "Asserts that two bytes are equal."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DiscoveryIssueNotifier.java",
    "type": "method",
    "name": "logger",
    "code": "private static Consumer<Supplier<String>> logger(Severity severity) {\n\t\tswitch (severity) {\n\t\t\tcase INFO:\n\t\t\t\treturn logger::info;\n\t\t\tcase WARNING:\n\t\t\t\treturn logger::warn;\n\t\t\tcase ERROR:\n\t\t\t\treturn logger::error;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Unknown severity: \" + severity);\n\t\t}\n\t}",
    "comment": "TODO [#4246] Use switch expression"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/test/java/org/apache/maven/api/MonotonicClockTest.java",
    "type": "method",
    "name": "testClockTimezone",
    "code": "void testClockTimezone() {\n        MonotonicClock clock = MonotonicClock.get();\n\n        assertEquals(ZoneOffset.UTC, clock.getZone(), \"Clock should use UTC timezone\");\n\n        Clock newClock = clock.withZone(ZoneId.systemDefault());\n        assertSame(clock, newClock, \"withZone() should return the same clock instance\");\n    }",
    "comment": "Verify that attempting to change timezone returns the same instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectClass",
    "code": "public static ClassSelector selectClass(String className) {\n\t\treturn selectClass(null, className);\n\t}",
    "comment": "Create a {@code ClassSelector} for the supplied class name.\n\n@param className the fully qualified name of the class to select; never\n{@code null} or blank\n@see ClassSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/throttling/src/main/java/com/iluwatar/throttling/CallsCount.java",
    "type": "method",
    "name": "getCount",
    "code": "public long getCount(String tenantName) {\n    return tenantCallsCount.get(tenantName).get();\n  }",
    "comment": "Get count of tenant based on tenant name.\n\n@param tenantName name of the tenant.\n@return the count of the tenant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/PluginLoaderException.java",
    "type": "method",
    "name": "PluginLoaderException",
    "code": "public PluginLoaderException(Plugin plugin, String message, ArtifactResolutionException cause) {\n        super(message, cause);\n        pluginKey = plugin.getKey();\n    }",
    "comment": "Signifies a failure to load a plugin. This is used to abstract the specific errors which may be\nencountered at lower levels, and provide a dependable interface to the plugin-loading framework."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/LookupInvoker.java",
    "type": "method",
    "name": "doDetermineWriter",
    "code": "protected Consumer<String> doDetermineWriter(C context) {\n        Options options = context.invokerRequest.options();\n        if (options.logFile().isPresent()) {\n            Path logFile = context.cwd.resolve(options.logFile().get());\n            try {\n                PrintWriter printWriter = new PrintWriter(Files.newBufferedWriter(logFile), true);\n                context.closeables.add(printWriter);\n                return printWriter::println;\n            } catch (IOException e) {\n                throw new MavenException(\"Unable to redirect logging to \" + logFile, e);\n            }\n        } else {\n            return msg -> {\n                PrintWriter pw = context.terminal.writer();\n                pw.println(msg);\n                pw.flush();\n            };\n        }\n    }",
    "comment": "Given the terminal creation has been offloaded to a different thread,\ndo not pass directly the terminal writer"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/BorderedText.java",
    "type": "method",
    "name": "BorderedText",
    "code": "public BorderedText(final int interiorColor, final int exteriorColor, final float textSize) {\n    interiorPaint = new Paint();\n    interiorPaint.setTextSize(textSize);\n    interiorPaint.setColor(interiorColor);\n    interiorPaint.setStyle(Style.FILL);\n    interiorPaint.setAntiAlias(false);\n    interiorPaint.setAlpha(255);\n\n    exteriorPaint = new Paint();\n    exteriorPaint.setTextSize(textSize);\n    exteriorPaint.setColor(exteriorColor);\n    exteriorPaint.setStyle(Style.FILL_AND_STROKE);\n    exteriorPaint.setStrokeWidth(textSize / 8);\n    exteriorPaint.setAntiAlias(false);\n    exteriorPaint.setAlpha(255);\n\n    this.textSize = textSize;\n  }",
    "comment": "Create a bordered text object with the specified interior and exterior colors, text size and\nalignment.\n\n@param interiorColor the interior text color\n@param exteriorColor the exterior text color\n@param textSize text size in pixels"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaTfIdfExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaTfIdfExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(0.0, \"Hi I heard about Spark\"),\n      RowFactory.create(0.0, \"I wish Java could use case classes\"),\n      RowFactory.create(1.0, \"Logistic regression models are neat\")\n    );\n    StructType schema = new StructType(new StructField[]{\n    Dataset<Row> sentenceData = spark.createDataFrame(data, schema);\n\n    Tokenizer tokenizer = new Tokenizer().setInputCol(\"sentence\").setOutputCol(\"words\");\n    Dataset<Row> wordsData = tokenizer.transform(sentenceData);\n\n    int numFeatures = 20;\n    HashingTF hashingTF = new HashingTF()\n      .setInputCol(\"words\")\n      .setOutputCol(\"rawFeatures\")\n      .setNumFeatures(numFeatures);\n\n    Dataset<Row> featurizedData = hashingTF.transform(wordsData);\n\n    IDF idf = new IDF().setInputCol(\"rawFeatures\").setOutputCol(\"features\");\n    IDFModel idfModel = idf.fit(featurizedData);\n\n    Dataset<Row> rescaledData = idfModel.transform(featurizedData);\n    rescaledData.select(\"label\", \"features\").show();\n\n    spark.stop();\n  }\n}",
    "comment": "$example on$\n$example off$\n$example on$\nalternatively, CountVectorizer can also be used to get term frequency vectors\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java",
    "type": "method",
    "name": "nodeFinished",
    "code": "default void nodeFinished(C context, TestDescriptor testDescriptor, TestExecutionResult result) {\n\t}",
    "comment": "Callback invoked when the execution of this node has finished.\n\n<p>The default implementation does nothing.\n\n@param context the execution context\n@param testDescriptor the test descriptor that was executed\n@param result the result of the execution\n@since 1.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ThrowableCollector.java",
    "type": "method",
    "name": "isEmpty",
    "code": "public boolean isEmpty() {\n\t\treturn (this.throwable == null);\n\t}",
    "comment": "Determine if this {@code ThrowableCollector} is <em>empty</em> (i.e.,\nhas not collected any {@code Throwables})."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleConfigurationTests.java",
    "type": "method",
    "name": "instancePerClassConfiguredViaConfigParamThatOverridesSystemProperty",
    "code": "void instancePerClassConfiguredViaConfigParamThatOverridesSystemProperty() {\n\t\tClass<?> testClass = AssumedInstancePerClassTestCase.class;\n\n\t\tSystem.setProperty(KEY, PER_METHOD.name());\n\t\tperformAssertions(testClass, 1, 1, 0);\n\n\t\tperformAssertions(testClass, singletonMap(KEY, PER_CLASS.name()), 2, 0, 1, \"beforeAll\", \"test\", \"afterAll\");\n\t}",
    "comment": "Should fail with system property\nShould pass with the config param"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/guarded-suspension/src/main/java/com/iluwatar/guarded/suspension/GuardedQueue.java",
    "type": "method",
    "name": "get",
    "code": "public synchronized Integer get() {\n    while (sourceList.isEmpty()) {\n      try {\n        LOGGER.info(\"waiting\");\n        wait();\n      } catch (InterruptedException e) {\n        LOGGER.error(\"Error occurred: \", e);\n      }\n    }\n    LOGGER.info(\"getting\");\n    return sourceList.peek();\n  }",
    "comment": "Get the last element of the queue if exists.\n\n@return last element of a queue if queue is not empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/sasl/SparkSaslClient.java",
    "type": "method",
    "name": "dispose",
    "code": "public synchronized void dispose() {\n    if (saslClient != null) {\n      try {\n        saslClient.dispose();\n      } catch (SaslException e) {\n        // ignore\n      } finally {\n        saslClient = null;\n      }\n    }\n  }",
    "comment": "Disposes of any system resources or security-sensitive information the\nSaslClient might be using."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/server/TransportServer.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n    if (channelFuture != null) {\n      channelFuture.channel().close().awaitUninterruptibly(10, TimeUnit.SECONDS);\n      channelFuture = null;\n    }\n    if (bootstrap != null && bootstrap.config().group() != null) {\n      bootstrap.config().group().shutdownGracefully();\n    }\n    if (bootstrap != null && bootstrap.config().childGroup() != null) {\n      bootstrap.config().childGroup().shutdownGracefully();\n    }\n    bootstrap = null;\n  }",
    "comment": "close is a local operation and should finish within milliseconds; timeout just to be safe"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassNamePatternFilterUtils.java",
    "type": "method",
    "name": "includeMatchingClassNames",
    "code": "public static Predicate<String> includeMatchingClassNames(String patterns) {\n\t\treturn matchingClasses(patterns, Function.identity(), FilterType.INCLUDE);\n\t}",
    "comment": "Create a {@link Predicate} that can be used to include (i.e., filter in)\nfully qualified class names matching any of the supplied patterns.\n\n@param patterns a comma-separated list of patterns"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/half-sync-half-async/src/main/java/com/iluwatar/halfsynchalfasync/AsynchronousService.java",
    "type": "method",
    "name": "execute",
    "code": "public <T> void execute(final AsyncTask<T> task) {\n    try {\n      // some small tasks such as validation can be performed here.\n      task.onPreCall();\n    } catch (Exception e) {\n      task.onError(e);\n      return;\n    }\n\n    service.submit(\n        new FutureTask<>(task) {\n              // should not occur\n            } catch (ExecutionException e) {\n              task.onError(e.getCause());\n            }\n          }",
    "comment": "A non-blocking method which performs the task provided in background and returns immediately.\n\n<p>On successful completion of task the result is posted back using callback method {@link\nAsyncTask#onPostCall(Object)}, if task execution is unable to complete normally due to some\nexception then the reason for error is posted back using callback method {@link\nAsyncTask#onError(Throwable)}.\n\n<p>NOTE: The results are posted back in the context of background thread in this\nimplementation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/pytorch/android/pytorch_android/src/main/java/org/pytorch/Tensor.java",
    "type": "method",
    "name": "fromBlob",
    "code": "public static Tensor fromBlob(double[] data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_ARRAY_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.length, shape);\n    final DoubleBuffer doubleBuffer = allocateDoubleBuffer((int) numel(shape));\n    doubleBuffer.put(data);\n    return new Tensor_float64(doubleBuffer, shape, memoryFormat);\n  }",
    "comment": "Creates a new Tensor instance with dtype torch.float64 with specified shape and data as array\nof doubles.\n\n@param shape Tensor shape\n@param data Tensor elements"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-xml/src/main/java/org/apache/maven/api/xml/XmlNode.java",
    "type": "method",
    "name": "value",
    "code": "public Builder value(String value) {\n            this.value = value;\n            return this;\n        }",
    "comment": "Sets the text content of the XML node.\n\n@param value the text content of the XML node\n@return this builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/LifecycleNotFoundException.java",
    "type": "method",
    "name": "LifecycleNotFoundException",
    "code": "public LifecycleNotFoundException(String lifecycleId) {\n        super(\"Unknown lifecycle \" + lifecycleId);\n        this.lifecycleId = (lifecycleId != null) ? lifecycleId : \"\";\n    }",
    "comment": "Creates a new exception to indicate that the specified lifecycle is unknown.\n\n@param lifecycleId The identifier of the lifecycle that could not be located, may be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/adapter/src/test/java/com/iluwatar/adapter/AdapterPatternTest.java",
    "type": "method",
    "name": "testAdapter",
    "code": "void testAdapter() {\n    var captain = (Captain) beans.get(ROWING_BEAN);\n\n    // when captain moves\n    captain.row();\n\n    // the captain internally calls the battleship object to move\n    var adapter = (RowingBoat) beans.get(FISHING_BEAN);\n    verify(adapter).row();\n  }",
    "comment": "This test asserts that when we use the row() method on a captain bean(client), it is internally\ncalling sail method on the fishing boat object. The Adapter ({@link FishingBoatAdapter} )\nconverts the interface of the target class ( {@link FishingBoat}) into a suitable one expected\nby the client ({@link Captain} )."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeWriter.java",
    "type": "method",
    "name": "write",
    "code": "public void write(int ordinal, VariantVal input) {\n    byte[] value = input.getValue();\n    byte[] metadata = input.getMetadata();\n    int totalSize = 4 + value.length + metadata.length;\n    int roundedSize = ByteArrayMethods.roundNumberOfBytesToNearestWord(totalSize);\n    grow(roundedSize);\n    zeroOutPaddingBytes(totalSize);\n    Platform.putInt(getBuffer(), cursor(), value.length);\n    Platform.copyMemory(value, Platform.BYTE_ARRAY_OFFSET, getBuffer(), cursor() + 4, value.length);\n    Platform.copyMemory(\n        metadata,\n        Platform.BYTE_ARRAY_OFFSET,\n        getBuffer(),\n        cursor() + 4 + value.length,\n        metadata.length\n    );\n    setOffsetAndSize(ordinal, totalSize);\n    increaseCursor(roundedSize);\n  }",
    "comment": "See the class comment of VariantVal for the format of the binary content."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java",
    "type": "method",
    "name": "tryToResetPermissions",
    "code": "private static void tryToResetPermissions(Path path) {\n\t\t\tFile file;\n\t\t\ttry {\n\t\t\t\tfile = path.toFile();\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ignore) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfile.setReadable(true);\n\t\t\tfile.setWritable(true);\n\t\t\tif (Files.isDirectory(path)) {\n\t\t\t\tfile.setExecutable(true);\n\t\t\t}\n\t\t\tDosFileAttributeView dos = Files.getFileAttributeView(path, DosFileAttributeView.class);\n\t\t\tif (dos != null) {\n\t\t\t\ttry {\n\t\t\t\t\tdos.setReadOnly(false);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ignore) {\n\t\t\t\t}\n\t\t\t}\n\t\t}",
    "comment": "Might happen when the `TempDirFactory` uses a custom `FileSystem`\nnothing we can do"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/commons/util/AnnotationUtilsTests.java",
    "type": "method",
    "name": "findPublicAnnotatedFieldsForNullClass",
    "code": "void findPublicAnnotatedFieldsForNullClass() {\n\t\tassertThrows(PreconditionViolationException.class,\n\t\t\t() -> findPublicAnnotatedFields(null, String.class, Annotation1.class));\n\t}",
    "comment": "Prerequisite\nActual use cases for this test\n=== findPublicAnnotatedFields() ========================================="
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenPropertiesLoader.java",
    "type": "method",
    "name": "nextLocation",
    "code": "private static String nextLocation(StringTokenizer st) {\n        boolean optional = false;\n        String retVal = null;\n\n        if (st.countTokens() > 0) {\n            String tokenList = \"?\\\",\";\n            StringBuilder tokBuf = new StringBuilder(10);\n            String tok;\n            boolean inQuote = false;\n            boolean tokStarted = false;\n            boolean exit = false;\n            while ((st.hasMoreTokens()) && (!exit)) {\n                tok = st.nextToken(tokenList);\n                switch (tok) {\n                    case \"\\\"\":\n                        inQuote = !inQuote;\n                        if (inQuote) {\n                            tokenList = \"\\\"\";\n                        } else {\n                            tokenList = \"\\\" \";\n                        }\n                        break;\n                    case \",\":\n                        if (tokStarted) {\n                            retVal = tokBuf.toString();\n                            tokStarted = false;\n                            tokBuf = new StringBuilder(10);\n                            exit = true;\n                        }\n                        break;\n                    case \"?\":\n                        optional = true;\n                        break;\n                    default:\n                        tokStarted = true;\n                        tokBuf.append(tok.trim());\n                        break;\n                }\n            }\n\n            if ((!exit) && (tokStarted)) {\n                retVal = tokBuf.toString();\n            }\n        }\n\n        return optional ? \"?\" + retVal : retVal;\n    }",
    "comment": "Handle case where end of token stream and\nstill got data"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/test/java/org/apache/maven/model/merge/MavenMergerTest.java",
    "type": "method",
    "name": "mergeArtifactId",
    "code": "void mergeArtifactId() {\n        Model target = Model.newBuilder().artifactId(\"TARGET\").build();\n\n        Model source = Model.newBuilder().artifactId(\"SOURCE\").build();\n\n        Model merged = mavenMerger.merge(target, source, true, null);\n        assertThat(merged.getArtifactId(), is(\"SOURCE\"));\n\n        merged = mavenMerger.merge(target, source, false, null);\n        assertThat(merged.getArtifactId(), is(\"TARGET\"));\n    }",
    "comment": "MavenMerger is based on same instances, subclasses should override KeyComputer per type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/ReactorReader.java",
    "type": "method",
    "name": "getAllProjects",
    "code": "private Map<String, Map<String, Map<String, MavenProject>>> getAllProjects() {\n        if (allProjects == null) {\n            List<MavenProject> allProjects = session.getAllProjects();\n            if (allProjects != null) {\n                Map<String, Map<String, Map<String, MavenProject>>> map = new HashMap<>();\n                allProjects.forEach(project -> map.computeIfAbsent(project.getGroupId(), k -> new HashMap<>())\n                        .computeIfAbsent(project.getArtifactId(), k -> new HashMap<>())\n                        .put(project.getVersion(), project));\n                this.allProjects = map;\n            } else {\n                return Collections.emptyMap();\n            }\n        }\n        return allProjects;\n    }",
    "comment": "groupId -> (artifactId -> (version -> project)))\ncompute the projects mapping"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/main/java/com/zaxxer/hikari/metrics/prometheus/PrometheusHistogramMetricsTracker.java",
    "type": "method",
    "name": "registerHistogram",
    "code": "private static Histogram registerHistogram(String name, String help, double bucketStart) {\n      return Histogram.build()\n         .name(name)\n         .labelNames(\"pool\")\n         .help(help)\n         .exponentialBuckets(bucketStart, 2.0, 11)\n         .create();\n   }",
    "comment": "Alternative Prometheus metrics tracker using a Histogram instead of Summary\n<p>\nThis is an alternative metrics tracker that doesn't use a {@link io.prometheus.client.Summary}. Summaries require\nheavy locks that might cause performance issues. Source: https://github.com/prometheus/client_java/issues/328\n\n@see PrometheusMetricsTracker"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assert.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(String message, long unexpected, long actual) {\n        if (unexpected == actual) {\n            failEquals(message, Long.valueOf(actual));\n        }\n    }",
    "comment": "Asserts that two longs are <b>not</b> equals. If they are, an\n{@link AssertionError} is thrown with the given message.\n\n@param message the identifying message for the {@link AssertionError} (<code>null</code>\nokay)\n@param unexpected unexpected value to check\n@param actual the value to check against <code>unexpected</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/leader-election/src/main/java/com/iluwatar/leaderelection/ring/RingInstance.java",
    "type": "method",
    "name": "handleElectionMessage",
    "code": "protected void handleElectionMessage(Message message) {\n    var content = message.getContent();\n    LOGGER.info(INSTANCE + localId + \" - Election Message: \" + content);\n    var candidateList =\n        Arrays.stream(content.trim().split(\",\")).map(Integer::valueOf).sorted().toList();\n    if (candidateList.contains(localId)) {\n      var newLeaderId = candidateList.get(0);\n      LOGGER.info(INSTANCE + localId + \" - New leader should be \" + newLeaderId + \".\");\n      messageManager.sendLeaderMessage(localId, newLeaderId);\n    } else {\n      content += \",\" + localId;\n      messageManager.sendElectionMessage(localId, content);\n    }\n  }",
    "comment": "Process election message. If the local ID is contained in the ID list, the instance will select\nthe alive instance with the smallest ID to be the new leader, and send the leader inform\nmessage. If not, it will add its local ID to the list and send the message to the next instance\nin the ring."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/hikaricp/src/test/java/com/zaxxer/hikari/util/TomcatConcurrentBagLeakTest.java",
    "type": "method",
    "name": "if",
    "code": "if (map != null) {\n            Object[] table = (Object[]) internalTableField.get(map);\n            if (table != null) {\n               for (Object obj : table) {\n                  if (obj != null) {\n                     boolean keyLoadedByWebapp = false;\n                     boolean valueLoadedByWebapp = false;\n                     // Check the key\n                     Object key = ((Reference<?>) obj).get();\n                     if (this.equals(key) || loadedByThisOrChild(key)) {\n                        keyLoadedByWebapp = true;\n                     }\n                     // Check the value\n                     Field valueField = obj.getClass().getDeclaredField(\"value\");\n                     valueField.setAccessible(true);\n                     Object value = valueField.get(obj);\n                     if (this.equals(value) || loadedByThisOrChild(value)) {\n                        valueLoadedByWebapp = true;\n                     }\n                     if (keyLoadedByWebapp || valueLoadedByWebapp) {\n                        Object[] args = new Object[5];\n                        args[0] = getContextName();\n                        if (key != null) {\n                           args[1] = getPrettyClassName(key.getClass());\n                           try {\n                              args[2] = key.toString();\n                           } catch (Exception e) {\n                              log.warn(\"Unable to determine string representation of key of type [{}]\", args[1], e);\n                              args[2] = \"Unknown\";\n                           }\n                        }\n                        if (value != null) {\n                           args[3] = getPrettyClassName(value.getClass());\n                           try {\n                              args[4] = value.toString();\n                           } catch (Exception e) {\n                              log.warn(\"webappClassLoader.checkThreadLocalsForLeaks.badValue {}\", args[3], e);\n                              args[4] = \"Unknown\";\n                           }\n                        }\n\n                        if (valueLoadedByWebapp) {\n                           log.error(\"The web application [{}] created a ThreadLocal with key of type [{}] \" +\n                              \"(value [{}]) and a value of type [{}] (value [{}]) but failed to remove \" +\n                              \"it when the web application was stopped. Threads are going to be renewed \" +\n                              \"over time to try and avoid a probable memory leak.\", args);\n                           failureException = new Exception();\n                        } else if (value == null) {\n                           log.debug(\"The web application [{}] created a ThreadLocal with key of type [{}] \" +\n                              \"(value [{}]). The ThreadLocal has been correctly set to null and the \" +\n                              \"key will be removed by GC.\", args);\n                           failureException = new Exception();\n                        } else {\n                           log.debug(\"The web application [{}] created a ThreadLocal with key of type [{}] \" +\n                              \"(value [{}]) and a value of type [{}] (value [{}]). Since keys are only \" +\n                              \"weakly held by the ThreadLocal Map this is not a memory leak.\", args);\n                           failureException = new Exception();\n                        }\n                     }\n                  }\n               }\n            }\n         }",
    "comment": "Analyzes the given thread local map object. Also pass in the field that\npoints to the internal table to save re-calculating it on every\ncall to this method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExternalBlockStoreClient.java",
    "type": "method",
    "name": "setComparableAppAttemptId",
    "code": "private void setComparableAppAttemptId(String appAttemptId) {\n    try {\n      this.comparableAppAttemptId = Integer.parseInt(appAttemptId);\n    } catch (NumberFormatException e) {\n      logger.warn(\"Push based shuffle requires comparable application attemptId, \" +\n        \"but the appAttemptId {} cannot be parsed to Integer\", e,\n          MDC.of(LogKeys.APP_ATTEMPT_ID$.MODULE$, appAttemptId));\n    }\n  }",
    "comment": "For now, push based shuffle only supports running in YARN.\nApplication attemptId in YARN is integer and it can be safely parsed\nto integer here. For the application attemptId from other cluster set up\nwhich is not numeric, it needs to generate this comparableAppAttemptId\nfrom the String typed appAttemptId through some other customized logic."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertArrayEquals",
    "code": "public static void assertArrayEquals(float[] expected, float[] actual, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} float arrays are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "addCliArguments",
    "code": "public void addCliArguments(String... cliArguments) {\n        Collections.addAll(this.cliArguments, cliArguments);\n    }",
    "comment": "Add a command line arguments, each argument must be set separately one by one.\n<p>\n<code>${basedir}</code> in argument will be replaced by value of {@link #getBasedir()} during execution.\n\n@param cliArguments an arguments list to add"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "toBinaryString",
    "code": "public static UTF8String toBinaryString(long val) {\n    int zeros = Long.numberOfLeadingZeros(val);\n    if (zeros == Long.SIZE) {\n      return UTF8String.ZERO_UTF8;\n    } else {\n      int length = Long.SIZE - zeros;\n      byte[] bytes = new byte[length];\n      do {\n        bytes[--length] = (byte) ((val & 0x1) == 1 ? '1': '0');\n        val >>>= 1;\n      } while (length > 0);\n      return fromBytes(bytes);\n    }\n  }",
    "comment": "Convert a long value to its binary format stripping leading zeros."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/samples/money/MoneyTest.java",
    "type": "method",
    "name": "testSimpleAdd",
    "code": "public void testSimpleAdd() {\n        Money expected = new Money(26, \"CHF\");\n        assertEquals(expected, f12CHF.add(f14CHF));\n    }",
    "comment": "[12 CHF] + [14 CHF] == [26 CHF]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/hexagonal-architecture/src/main/java/com/iluwatar/hexagonal/domain/LotteryNumbers.java",
    "type": "method",
    "name": "RandomNumberGenerator",
    "code": "public RandomNumberGenerator(int min, int max) {\n      randomIterator = new SecureRandom().ints(min, max + 1).iterator();\n    }",
    "comment": "Initialize a new random number generator that generates random numbers in the range [min,\nmax].\n\n@param min the min value (inclusive)\n@param max the max value (inclusive)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/producer-consumer/src/main/java/com/iluwatar/producer/consumer/Producer.java",
    "type": "method",
    "name": "Producer",
    "code": "public Producer(String name, ItemQueue queue) {\n    this.name = name;\n    this.queue = queue;\n  }",
    "comment": "Class responsible for producing unit of work that can be expressed as {@link Item} and submitted\nto queue."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/extension/ExtensionComposabilityTests.java",
    "type": "method",
    "name": "ensureJupiterExtensionApisAreComposable",
    "code": "void ensureJupiterExtensionApisAreComposable() {\n\n\t\t// 1) Find all existing top-level Extension APIs\n\t\tList<Class<?>> extensionApis = findExtensionApis();\n\n\t\t// 2) Determine which methods we expect the kitchen sink to implement...\n\n\t\t// @formatter:off\n\t\tList<Method> expectedMethods = extensionApis.stream()\n\t\t\t\t.map(Class::getDeclaredMethods)\n\t\t\t\t.flatMap(Arrays::stream)\n\t\t\t\t.filter(not(Method::isSynthetic))\n\t\t\t\t.filter(not(where(Method::getModifiers, Modifier::isStatic)))\n\t\t\t\t.toList();\n\n\t\tList<String> expectedMethodSignatures = expectedMethods.stream()\n\t\t\t\t.map(this::methodSignature)\n\t\t\t\t.sorted()\n\t\t\t\t.toList();\n\n\t\tList<String> expectedMethodNames = expectedMethods.stream()\n\t\t\t\t.map(Method::getName)\n\t\t\t\t.distinct()\n\t\t\t\t.sorted()\n\t\t\t\t.toList();\n\t\t// @formatter:on\n\n\t\t// 3) Dynamically implement all Extension APIs\n\t\tObject dynamicKitchenSinkExtension = Proxy.newProxyInstance(getClass().getClassLoader(),\n\t\t\textensionApis.toArray(Class[]::new), (proxy, method, args) -> null);\n\n\t\t// 4) Determine what ended up in the kitchen sink...\n\n\t\t// @formatter:off\n\t\tList<Method> actualMethods = Arrays.stream(dynamicKitchenSinkExtension.getClass().getDeclaredMethods())\n\t\t\t\t.filter(ModifierSupport::isNotStatic)\n\t\t\t\t.toList();\n\n\t\tList<String> actualMethodSignatures = actualMethods.stream()\n\t\t\t\t.map(this::methodSignature)\n\t\t\t\t.distinct()\n\t\t\t\t.sorted()\n\t\t\t\t.collect(toCollection(ArrayList::new));\n\n\t\tList<String> actualMethodNames = actualMethods.stream()\n\t\t\t\t.map(Method::getName)\n\t\t\t\t.distinct()\n\t\t\t\t.sorted()\n\t\t\t\t.collect(toCollection(ArrayList::new));\n\t\t// @formatter:on\n\n\t\t// 5) Remove methods from java.lang.Object\n\t\tactualMethodSignatures.remove(\"equals(Object)\");\n\t\tactualMethodSignatures.remove(\"hashCode()\");\n\t\tactualMethodSignatures.remove(\"toString()\");\n\t\tactualMethodNames.remove(\"equals\");\n\t\tactualMethodNames.remove(\"hashCode\");\n\t\tactualMethodNames.remove(\"toString\");\n\n\t\t// 6) Verify our expectations\n\n\t\t// @formatter:off\n\t\tassertAll(\n\t\t\t\t() -> assertThat(actualMethodSignatures).isEqualTo(expectedMethodSignatures),\n\t\t\t\t() -> assertThat(actualMethodNames).isEqualTo(expectedMethodNames)\n\t\t);\n\t\t// @formatter:on\n\t}",
    "comment": "Unit tests for extension composability in JUnit Jupiter.\n\n<p>The purpose of these tests is to ensure that a concrete extension\n(a.k.a., the kitchen sink extension) is able to implement all extension\nAPIs supported by JUnit Jupiter without any naming conflicts or\nambiguities with regard to method names or method signatures.\n\n@since 5.0\n@see KitchenSinkExtension"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/single-table-inheritance/src/main/java/com/iluwatar/entity/PassengerVehicle.java",
    "type": "method",
    "name": "PassengerVehicle",
    "code": "protected PassengerVehicle(String manufacturer, String model, int noOfPassengers) {\n    super(manufacturer, model);\n    this.noOfPassengers = noOfPassengers;\n  }",
    "comment": "An abstract class that extends the Vehicle class and provides properties for the Passenger type\nof Vehicles.\n\n@see Vehicle"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/test/java/com/iluwatar/identitymap/PersonDbSimulatorImplementationTest.java",
    "type": "method",
    "name": "deleteNotInDb",
    "code": "void deleteNotInDb() {\n    PersonDbSimulatorImplementation db = new PersonDbSimulatorImplementation();\n    Person person1 = new Person(1, \"Thomas\", 27304159);\n    Person person2 = new Person(2, \"John\", 42273631);\n    db.insert(person1);\n    db.insert(person2);\n    Assertions.assertThrows(IdNotFoundException.class, () -> db.delete(3));\n  }",
    "comment": "Test if IdNotFoundException is thrown when person with this ID not in DB."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/ProjectBuildList.java",
    "type": "method",
    "name": "findByMavenProject",
    "code": "public ProjectSegment findByMavenProject(MavenProject mavenProject) {\n        return items.stream()\n                .filter(pb -> mavenProject.equals(pb.getProject()))\n                .findFirst()\n                .orElse(null);\n    }",
    "comment": "Finds the first ProjectSegment matching the supplied project\n@param mavenProject the requested project\n@return The projectSegment or null."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/types/UTF8String.java",
    "type": "method",
    "name": "levenshteinDistance",
    "code": "public int levenshteinDistance(UTF8String other, int threshold) {\n\n    int n = numChars();\n    int m = other.numChars();\n\n    if (n == 0) {\n      return m <= threshold ? m : -1;\n    }\n    if (m == 0) {\n      return n <= threshold ? n : -1;\n    }\n\n    UTF8String s, t;\n\n    if (n <= m) {\n      s = this;\n      t = other;\n    } else {\n      s = other;\n      t = this;\n      int swap;\n      swap = n;\n      n = m;\n      m = swap;\n    }\n\n    if (m - n > threshold) {\n      return -1;\n    }\n\n    int[] p = new int[n + 1];\n    int[] d = new int[n + 1];\n    int[] swap;\n\n    int i, i_bytes, num_bytes_i, j, j_bytes, num_bytes_j;\n\n    final int boundary = Math.min(n, threshold) + 1;\n    for (i = 0; i < boundary; i++) { p[i] = i; }\n    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);\n    Arrays.fill(d, Integer.MAX_VALUE);\n\n    for (j = 0, j_bytes = 0; j < m; j_bytes += num_bytes_j, j++) {\n      num_bytes_j = numBytesForFirstByte(t.getByte(j_bytes));\n\n      d[0] = j + 1;\n\n      final int min = Math.max(1, j + 1 - threshold);\n      final int max = j + 1 > Integer.MAX_VALUE - threshold ? n : Math.min(n, j + 1 + threshold);\n      if (min > 1) {\n        d[min - 1] = Integer.MAX_VALUE;\n      }\n\n      int lowerBound = Integer.MAX_VALUE;\n\n      for (i = 0, i_bytes = 0; i <= max; i_bytes += num_bytes_i, i++) {\n        if (i < min - 1) {\n          num_bytes_i = numBytesForFirstByte(s.getByte(i_bytes));\n        } else if (i == min - 1) {\n          num_bytes_i = 0;\n        } else {\n          if (ByteArrayMethods.arrayEquals(t.base, t.offset + j_bytes,\n                  s.base, s.offset + i_bytes, num_bytes_j)) {\n            d[i] = p[i - 1];\n          } else {\n            d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\n          }\n          lowerBound = Math.min(lowerBound, d[i]);\n          num_bytes_i = numBytesForFirstByte(s.getByte(i_bytes));\n        }\n      }\n\n      if (lowerBound > threshold) {\n        return -1;\n      }\n\n      swap = p;\n      p = d;\n      d = swap;\n    }\n\n    if (p[n] <= threshold) {\n      return p[n];\n    }\n    return -1;\n  }",
    "comment": "Implementation adopted from\norg.apache.commons.text.similarity.LevenshteinDistance.limitedCompare\nif p[n] is greater than the threshold, there's no guarantee on it\nbeing the correct distance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/MojoDescriptor.java",
    "type": "method",
    "name": "getParameterMap",
    "code": "public Map<String, Parameter> getParameterMap() {\n        LinkedHashMap<String, Parameter> parameterMap = new LinkedHashMap<>();\n\n        for (Parameter pd : parameters) {\n            parameterMap.put(pd.getName(), pd);\n        }\n\n        return parameterMap;\n    }",
    "comment": "@return the list parameters as a Map (keyed by {@link Parameter#getName()}) that is built from\n{@link #parameters} list on each call. In other words, the map returned is built on fly and is a copy.\nAny change to this map is NOT reflected on list and other way around!"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java",
    "type": "method",
    "name": "toListString",
    "code": "private String toListString() {\n            StringBuilder buffer = new StringBuilder();\n            buffer.append(\"[\");\n            for (Item item : this) {\n                if (buffer.length() > 1) {\n                    buffer.append(\", \");\n                }\n                if (item instanceof ListItem listItem) {\n                    buffer.append(listItem.toListString());\n                } else {\n                    buffer.append(item);\n                }\n            }\n            buffer.append(\"]\");\n            return buffer.toString();\n        }",
    "comment": "Return the contents in the same format that is used when you call toString() on a List."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/RocksDBTypeInfo.java",
    "type": "method",
    "name": "childPrefix",
    "code": "byte[] childPrefix(Object value) {\n      Preconditions.checkState(parent == null, \"Not a parent index.\");\n      return buildKey(name, toParentKey(value));\n    }",
    "comment": "Creates a key prefix for child indices of this index. This allows the prefix to be\ncalculated only once, avoiding redundant work when multiple child indices of the\nsame parent index exist."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/test/java/com/example/android/persistence/migrations/UserPresenterTest.java",
    "type": "method",
    "name": "updateUserName_updatesView",
    "code": "public void updateUserName_updatesView() {\n        mPresenter.updateUserName(\"user name\");\n        verify(mUserRepository).updateUserName(eq(\"user name\"),\n                mUpdateUserCallbackArgumentCaptor.capture());\n        User user = new User(\"user name\");\n        mUpdateUserCallbackArgumentCaptor.getValue().onUserUpdated(user);\n\n        verify(mView).showUserName(\"user name\");\n    }",
    "comment": "When updating the username\nCallback is captured and invoked\nVerify that the username is set in the view"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtilsTests.java",
    "type": "method",
    "name": "findBeforeEachMethodsWithStandardLifecycle",
    "code": "void findBeforeEachMethodsWithStandardLifecycle() {\n\t\tList<Method> methods = findBeforeEachMethods(TestCaseWithStandardLifecycle.class, issueReporter);\n\n\t\tassertThat(namesOf(methods)).containsExactlyInAnyOrder(\"nine\", \"ten\");\n\t\tassertThat(discoveryIssues).isEmpty();\n\t}",
    "comment": "Unit tests for {@link LifecycleMethodUtils}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/vectorized/ColumnarBatchRow.java",
    "type": "method",
    "name": "ColumnarBatchRow",
    "code": "public ColumnarBatchRow(ColumnVector[] columns) {\n    this.columns = columns;\n  }",
    "comment": "This class wraps an array of {@link ColumnVector} and provides a row view.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/Tensors.java",
    "type": "method",
    "name": "create",
    "code": "public static Tensor<Integer> create(int[][] data) {\n    return Tensor.create(data, Integer.class);\n  }",
    "comment": "Creates a rank-2 tensor of {@code int} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/iterator/src/main/java/com/iluwatar/iterator/App.java",
    "type": "method",
    "name": "demonstrateTreasureChestIteratorForType",
    "code": "private static void demonstrateTreasureChestIteratorForType(ItemType itemType) {\n    LOGGER.info(\"------------------------\");\n    LOGGER.info(\"Item Iterator for ItemType \" + itemType + \": \");\n    var itemIterator = TREASURE_CHEST.iterator(itemType);\n    while (itemIterator.hasNext()) {\n      LOGGER.info(itemIterator.next().toString());\n    }\n  }",
    "comment": "The Iterator pattern is a design pattern in which an iterator is used to traverse a container and\naccess the container's elements. The Iterator pattern decouples algorithms from containers.\n\n<p>In this example the Iterator ({@link Iterator}) adds abstraction layer on top of a collection\n({@link TreasureChest}). This way the collection can change its internal implementation without\naffecting its clients."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/AutoCloseTests.java",
    "type": "method",
    "name": "superSetup",
    "code": "static void superSetup() {\n\t\t\tsuperStaticClosable = new AutoCloseSpy(\"superStaticClosable\");\n\t\t}",
    "comment": "WARNING: if this method is named setup() AND the @BeforeAll method in\nSubTestCase is also named setup(), the latter will \"hide\" the former."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/UnsafeRow.java",
    "type": "method",
    "name": "createFromByteArray",
    "code": "public static UnsafeRow createFromByteArray(int numBytes, int numFields) {\n    final UnsafeRow row = new UnsafeRow(numFields);\n    row.pointTo(new byte[numBytes], numBytes);\n    return row;\n  }",
    "comment": "Creates an empty UnsafeRow from a byte array with specified numBytes and numFields.\nThe returned row is invalid until we call copyFrom on it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/maven-it-helper/src/main/java/org/apache/maven/it/Verifier.java",
    "type": "method",
    "name": "getArtifactMetadataPath",
    "code": "public String getArtifactMetadataPath(String gid, String aid, String version, String filename, String repoId) {\n        String gav;\n        if (gid != null) {\n            gav = gid + \":\";\n        } else {\n            gav = \":\";\n        }\n        if (aid != null) {\n            gav += aid + \":\";\n        } else {\n            gav += \":\";\n        }\n        if (version != null) {\n            gav += version + \":\";\n        } else {\n            gav += \":\";\n        }\n        gav += filename;\n        return getLocalRepository()\n                + File.separator\n                + executorTool.metadataPath(executorHelper.executorRequest(), gav, repoId);\n    }",
    "comment": "Gets the path to a file in the local artifact directory. Note that the method does not check whether the returned\npath actually points to an existing file.\n\n@param gid      The group id, must not be <code>null</code>.\n@param aid      The artifact id, may be <code>null</code>.\n@param version  The artifact version, may be <code>null</code>.\n@param filename The filename to use, must not be <code>null</code>.\n@param repoId   The remote repository ID from where metadata originate, may be <code>null</code>.\n@return The (absolute) path to the local artifact metadata, never <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/main/java/org/apache/spark/util/kvstore/RocksDBIterator.java",
    "type": "method",
    "name": "loadNext",
    "code": "private byte[] loadNext() {\n    if (count >= max) {\n      return null;\n    }\n\n    while (it.isValid()) {\n      Map.Entry<byte[], byte[]> nextEntry = new AbstractMap.SimpleEntry<>(it.key(), it.value());\n\n      byte[] nextKey = nextEntry.getKey();\n      if (!startsWith(nextKey, indexKeyPrefix)) {\n        return null;\n      }\n\n      if (isEndMarker(nextKey)) {\n        if (ascending) {\n          it.next();\n        } else {\n          it.prev();\n        }\n        continue;\n      }\n\n      if (end != null) {\n        int comp = compare(nextKey, end) * (ascending ? 1 : -1);\n        if (comp > 0) {\n          return null;\n        }\n      }\n\n      count++;\n      if (ascending) {\n        it.next();\n      } else {\n        it.prev();\n      }\n      return nextEntry.getValue();\n    }\n    return null;\n  }",
    "comment": "Next key is not part of the index, stop.\nIf the next key is an end marker, then skip it.\nIf there's a known end key and iteration has gone past it, stop.\nNext element is part of the iteration, return it."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultLifecycleExecutionPlanCalculator.java",
    "type": "method",
    "name": "finalizeMojoConfiguration",
    "code": "private void finalizeMojoConfiguration(MojoExecution mojoExecution) {\n        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();\n\n        XmlNode executionConfiguration = mojoExecution.getConfiguration() != null\n                ? mojoExecution.getConfiguration().getDom()\n                : null;\n        if (executionConfiguration == null) {\n            executionConfiguration = XmlNode.newInstance(\"configuration\");\n        }\n\n        XmlNode defaultConfiguration = getMojoConfiguration(mojoDescriptor);\n\n        List<XmlNode> children = new ArrayList<>();\n        if (mojoDescriptor.getParameters() != null) {\n            for (Parameter parameter : mojoDescriptor.getParameters()) {\n                XmlNode parameterConfiguration = executionConfiguration.child(parameter.getName());\n\n                if (parameterConfiguration == null) {\n                    parameterConfiguration = executionConfiguration.child(parameter.getAlias());\n                }\n\n                XmlNode parameterDefaults = defaultConfiguration.child(parameter.getName());\n\n                if (parameterConfiguration != null) {\n                    parameterConfiguration = XmlService.merge(parameterConfiguration, parameterDefaults, Boolean.TRUE);\n                } else {\n                    parameterConfiguration = parameterDefaults;\n                }\n\n                if (parameterConfiguration != null) {\n                    Map<String, String> attributes = new HashMap<>(parameterConfiguration.attributes());\n\n                    String attributeForImplementation = parameterConfiguration.attribute(\"implementation\");\n                    String parameterForImplementation = parameter.getImplementation();\n                    if ((attributeForImplementation == null || attributeForImplementation.isEmpty())\n                            && ((parameterForImplementation != null) && !parameterForImplementation.isEmpty())) {\n                        attributes.put(\"implementation\", parameter.getImplementation());\n                    }\n\n                    parameterConfiguration = XmlNode.newInstance(\n                            parameter.getName(),\n                            parameterConfiguration.value(),\n                            attributes,\n                            parameterConfiguration.children(),\n                            parameterConfiguration.inputLocation());\n\n                    children.add(parameterConfiguration);\n                }\n            }\n        }\n        XmlNode finalConfiguration = XmlNode.newInstance(\"configuration\", children);\n\n        mojoExecution.setConfiguration(finalConfiguration);\n    }",
    "comment": "Post-processes the effective configuration for the specified mojo execution. This step discards all parameters\nfrom the configuration that are not applicable to the mojo and injects the default values for any missing\nparameters.\n\n@param mojoExecution The mojo execution whose configuration should be finalized, must not be {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/serialized-lob/src/main/java/com/iluwatar/slob/serializers/LobSerializer.java",
    "type": "method",
    "name": "close",
    "code": "public void close() {\n    try {\n      databaseService.shutDownService();\n    } catch (SQLException e) {\n      throw new RuntimeException(e);\n    }\n  }",
    "comment": "Provides the specification to Deserialize the input object.\n\n@param toDeserialize object to deserialize\n@return Deserialized Object\n@throws ParserConfigurationException If issue occurs during parsing of input object\n@throws IOException if any issues occur during reading object\n@throws SAXException if any issues occur during reading object for XML parsing"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-artifact/src/main/java/org/apache/maven/artifact/DefaultArtifact.java",
    "type": "method",
    "name": "compareTo",
    "code": "public int compareTo(Artifact a) {\n        int result = groupId.compareTo(a.getGroupId());\n        if (result == 0) {\n            result = artifactId.compareTo(a.getArtifactId());\n            if (result == 0) {\n                result = type.compareTo(a.getType());\n                if (result == 0) {\n                    if (classifier == null) {\n                        if (a.getClassifier() != null) {\n                            result = 1;\n                        }\n                    } else {\n                        if (a.getClassifier() != null) {\n                            result = classifier.compareTo(a.getClassifier());\n                        } else {\n                            result = -1;\n                        }\n                    }\n                    if (result == 0) {\n                        result = new DefaultArtifactVersion(version)\n                                .compareTo(new DefaultArtifactVersion(a.getVersion()));\n                    }\n                }\n            }\n        }\n        return result;\n    }",
    "comment": "We don't consider the version range in the comparison, just the resolved version"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-yarn/src/main/java/org/apache/spark/network/yarn/YarnShuffleService.java",
    "type": "method",
    "name": "initializeApplication",
    "code": "public void initializeApplication(ApplicationInitializationContext context) {\n    String appId = context.getApplicationId().toString();\n    try {\n      ByteBuffer appServiceData = context.getApplicationDataForService();\n      String payload = JavaUtils.bytesToString(appServiceData);\n      String shuffleSecret;\n      Map<String, Object> metaInfo;\n      try {\n        metaInfo = mapper.readValue(payload,\n            new TypeReference<Map<String, Object>>() {});\n            MDC.of(LogKeys.APP_ID$.MODULE$, appId));\n        }\n      } catch (IOException ioe) {\n        logger.warn(\"Unable to parse application data for service: \" + payload);\n        metaInfo = null;\n      }\n      if (isAuthenticationEnabled()) {\n        if (metaInfo != null) {\n          shuffleSecret = (String) metaInfo.get(SECRET_KEY);\n        } else {\n          shuffleSecret = payload;\n        }\n        if (db != null && AppsWithRecoveryDisabled.isRecoveryEnabledForApp(appId)) {\n          AppId fullId = new AppId(appId);\n          byte[] key = dbAppKey(fullId);\n          ByteBuffer dbVal = metaInfo != null ?\n              JavaUtils.stringToBytes(shuffleSecret) : appServiceData;\n          byte[] value = mapper.writeValueAsString(dbVal).getBytes(StandardCharsets.UTF_8);\n          db.put(key, value);\n        }\n        secretManager.registerApp(appId, shuffleSecret);\n      }\n    } catch (Exception e) {\n      logger.error(\"Exception when initializing application {}\", e,\n        MDC.of(LogKeys.APP_ID$.MODULE$, appId));\n    }",
    "comment": "we stick a common prefix on all the keys so we can find them in the DB"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/props/MavenProperties.java",
    "type": "method",
    "name": "hex",
    "code": "protected static String hex(char ch) {\n        return Integer.toHexString(ch).toUpperCase(Locale.ENGLISH);\n    }",
    "comment": "<p>Returns an upper case hexadecimal <code>String</code> for the given\ncharacter.</p>\n\n@param ch The character to convert.\n@return An upper case hexadecimal <code>String</code>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/AbstractService.java",
    "type": "method",
    "name": "start",
    "code": "public synchronized void start() {\n    startTime = System.currentTimeMillis();\n    ensureCurrentState(STATE.INITED);\n    changeState(STATE.STARTED);\n    LOG.info(\"Service:{} is started.\", MDC.of(LogKeys.SERVICE_NAME$.MODULE$, getName()));\n  }",
    "comment": "{@inheritDoc}\n\n@throws IllegalStateException\nif the current service state does not permit\nthis action"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/factory-method/src/test/java/com/iluwatar/factory/method/FactoryMethodTest.java",
    "type": "method",
    "name": "testElfBlacksmithWithSpear",
    "code": "void testElfBlacksmithWithSpear() {\n    var blacksmith = new ElfBlacksmith();\n    var weapon = blacksmith.manufactureWeapon(WeaponType.SPEAR);\n    verifyWeapon(weapon, WeaponType.SPEAR, ElfWeapon.class);\n  }",
    "comment": "Testing {@link ElfBlacksmith} to produce a SPEAR asserting that the Weapon is an instance of\n{@link ElfWeapon}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/DefaultModelBuilder.java",
    "type": "method",
    "name": "merge",
    "code": "Map<String, String> merge(Map<String, String> properties, Map<String, String> userProperties) {\n            Map<String, String> result = null;\n            for (Map.Entry<String, String> entry : properties.entrySet()) {\n                String key = entry.getKey();\n                String value = userProperties.get(key);\n                if (value != null && !Objects.equals(value, entry.getValue())) {\n                    if (result == null) {\n                        result = new LinkedHashMap<>(properties);\n                    }\n                    result.put(entry.getKey(), value);\n                }\n            }\n            return result;\n        }",
    "comment": "Merges model properties with user properties, giving precedence to user properties.\nFor any property key present in both maps, the user property value will override\nthe model property value when they differ.\n\n@param properties properties defined in the model\n@param userProperties user-defined properties that override model properties\n@return a new map with model properties overridden by user properties if changes were needed,\nor null if no overrides were needed"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectMethod",
    "code": "public static MethodSelector selectMethod(Class<?> javaClass, Method method) {\n\t\tPreconditions.notNull(javaClass, \"Class must not be null\");\n\t\tPreconditions.notNull(method, \"Method must not be null\");\n\t\treturn new MethodSelector(javaClass, method);\n\t}",
    "comment": "Create a {@code MethodSelector} for the supplied {@link Class} and {@link Method}.\n\n@param javaClass the class in which the method is declared, or a subclass thereof;\nnever {@code null}\n@param method the method to select; never {@code null}\n@see MethodSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/Interpreter.java",
    "type": "method",
    "name": "Interpreter",
    "code": "public Interpreter(@NonNull ByteBuffer byteBuffer, Options options) {\n    this(new NativeInterpreterWrapperExperimental(byteBuffer, options));\n  }",
    "comment": "Initializes an {@code Interpreter} with a {@code ByteBuffer} of a model file and a set of\ncustom {@link Interpreter.Options}.\n\n<p>The {@code ByteBuffer} should not be modified after the construction of an {@code\nInterpreter}. The {@code ByteBuffer} can be either a {@code MappedByteBuffer} that memory-maps\na model file, or a direct {@code ByteBuffer} of nativeOrder() that contains the bytes content\nof a model.\n\n@throws IllegalArgumentException if {@code byteBuffer} is not a {@code MappedByteBuffer} nor a\ndirect {@code ByteBuffer} of nativeOrder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "UpdateColumnType",
    "code": "private UpdateColumnType(String[] fieldNames, DataType newDataType) {\n      this.fieldNames = fieldNames;\n      this.newDataType = newDataType;\n    }",
    "comment": "A TableChange to update the type of a field.\n<p>\nThe field names are used to find the field to update.\n<p>\nIf the field does not exist, the change must result in an {@link IllegalArgumentException}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroPrimitives.java",
    "type": "method",
    "name": "setBinaryColumn",
    "code": "public void setBinaryColumn(java.nio.ByteBuffer value) {\n    this.binary_column = value;\n  }",
    "comment": "Sets the value of the 'binary_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-embedder/src/main/java/org/apache/maven/cli/MavenCli.java",
    "type": "method",
    "name": "doMain",
    "code": "public int doMain(CliRequest cliRequest) {\n        PlexusContainer localContainer = null;\n        try {\n            initialize(cliRequest);\n            cli(cliRequest);\n            properties(cliRequest);\n            logging(cliRequest);\n            informativeCommands(cliRequest);\n            version(cliRequest);\n            localContainer = container(cliRequest);\n            commands(cliRequest);\n            configure(cliRequest);\n            toolchains(cliRequest);\n            populateRequest(cliRequest);\n            encryption(cliRequest);\n            return execute(cliRequest);\n        } catch (ExitException e) {\n            return e.exitCode;\n        } catch (UnrecognizedOptionException e) {\n            return 1;\n        } catch (BuildAbort e) {\n            CLIReportingUtils.showError(slf4jLogger, \"ABORTED\", e, cliRequest.showErrors);\n\n            return 2;\n        } catch (Exception e) {\n            CLIReportingUtils.showError(slf4jLogger, \"Error executing Maven.\", e, cliRequest.showErrors);\n\n            return 1;\n        } finally {\n            if (localContainer != null) {\n                localContainer.dispose();\n            }\n        }\n    }",
    "comment": "TODO need to externalize CliRequest\npure user error, suppress stack trace"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "isRecordObject",
    "code": "public static boolean isRecordObject(Object object) {\n\t\treturn object != null && isRecordClass(object.getClass());\n\t}",
    "comment": "{@return whether the supplied {@code object} is an instance of a record class}\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/NamespaceChange.java",
    "type": "method",
    "name": "RemoveProperty",
    "code": "private RemoveProperty(String property) {\n      this.property = property;\n    }",
    "comment": "A NamespaceChange to remove a namespace property.\n<p>\nIf the property does not exist, the change should succeed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng6173GetAllProjectsInReactorTest.java",
    "type": "method",
    "name": "getProjects",
    "code": "private List<String> getProjects(Properties properties) {\n        List<String> projects = new ArrayList<>();\n\n        for (Object o : properties.keySet()) {\n            String key = o.toString();\n            if (key.startsWith(\"session.allProjects.\") && !key.endsWith(\".size\")) {\n                projects.add(properties.getProperty(key));\n            }\n        }\n\n        Collections.sort(projects);\n\n        return projects;\n    }",
    "comment": "Verifies that {@code MavenSession#getAllProjects()} returns all projects in the reactor\nnot only the ones being built.\n\n@throws Exception in case of failure"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/mvnsh/ShellParser.java",
    "type": "method",
    "name": "assembleOptions",
    "code": "protected Options assembleOptions(List<Options> parsedOptions) {\n        return parsedOptions.get(0);\n    }",
    "comment": "nothing to assemble, we deal with CLI only"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/component/src/main/java/com/iluwatar/component/GameObject.java",
    "type": "method",
    "name": "createPlayer",
    "code": "public static GameObject createPlayer() {\n    return new GameObject(\n        new PlayerInputComponent(),\n        new ObjectPhysicComponent(),\n        new ObjectGraphicComponent(),\n        \"player\");\n  }",
    "comment": "Creates a player game object.\n\n@return player object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "build",
    "code": "public SSLFactory build() {\n      return new SSLFactory(this);\n    }",
    "comment": "Builds our {@link SSLFactory}\n\n@return The built {@link SSLFactory}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "getNnapiErrno",
    "code": "public int getNnapiErrno() {\n    if (!initialized) {\n      return 0 /*ANEURALNETWORKS_NO_ERROR*/;\n    }\n    checkNotClosed();\n    return impl.getNnapiErrno();\n  }",
    "comment": "Returns the latest error code returned by an NNAPI call or zero if NO calls to NNAPI failed.\nThe error code is reset when the delegate is associated with an <a\nhref=https://www.tensorflow.org/lite/api_docs/java/org/tensorflow/lite/Interpreter>interpreter</a>.\n\n<p>For details on NNAPI error codes see <a\nhref=\"https://developer.android.com/ndk/reference/group/neural-networks#resultcode\">the NNAPI\ndocumentation</a>.\n\n@throws IllegalStateException if the method is called after {@link #close() close}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/subpackage/SubclassedAssertionsTests.java",
    "type": "method",
    "name": "assertTrueWithBooleanTrue",
    "code": "void assertTrueWithBooleanTrue() {\n\t\tassertTrue(true);\n\t\tassertTrue(true, \"test\");\n\t\tassertTrue(true, () -> \"test\");\n\t}",
    "comment": "Tests which verify that {@link Assertions} can be subclassed.\n\n@since 5.3"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTrue",
    "code": "public static void assertTrue(BooleanSupplier booleanSupplier, String message) {\n\t\tAssertTrue.assertTrue(booleanSupplier, message);\n\t}",
    "comment": "<em>Assert</em> that the boolean condition supplied by {@code booleanSupplier} is {@code true}.\n<p>Fails with the supplied failure {@code message}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java",
    "type": "method",
    "name": "determineDisplayName",
    "code": "static String determineDisplayName(AnnotatedElement element, Supplier<String> displayNameSupplier) {\n\t\tPreconditions.notNull(element, \"Annotated element must not be null\");\n\t\treturn findAnnotation(element, DisplayName.class) //\n\t\t\t\t.map(DisplayName::value) //\n\t\t\t\t.filter(StringUtils::isNotBlank) //\n\t\t\t\t.map(String::trim) //\n\t\t\t\t.orElseGet(displayNameSupplier);\n\t}",
    "comment": "Pre-defined display name generator instance producing indicative sentences."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/Request.java",
    "type": "method",
    "name": "aClass",
    "code": "public static Request aClass(Class<?> clazz) {\n        return new ClassRequest(clazz);\n    }",
    "comment": "Create a <code>Request</code> that, when processed, will run all the tests\nin a class. The odd name is necessary because <code>class</code> is a reserved word.\n\n@param clazz the class containing the tests\n@return a <code>Request</code> that will cause all tests in the class to be run"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/ClassSource.java",
    "type": "method",
    "name": "getClassName",
    "code": "public final String getClassName() {\n\t\treturn this.className;\n\t}",
    "comment": "Get the class name of this source.\n\n@see #getJavaClass()\n@see #getPosition()"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/ExternalShuffleBlockResolver.java",
    "type": "method",
    "name": "deleteNonShuffleServiceServedFiles",
    "code": "private void deleteNonShuffleServiceServedFiles(String[] dirs) {\n    FilenameFilter filter = (dir, name) -> {\n      // Don't delete shuffle data, shuffle index files or cached RDD files.\n      return !name.endsWith(\".index\") && !name.endsWith(\".data\")\n        && (!rddFetchEnabled || !name.startsWith(\"rdd_\"));\n    };\n\n    for (String localDir : dirs) {\n      try {\n        JavaUtils.deleteRecursively(new File(localDir), filter);\n        logger.debug(\"Successfully cleaned up files not served by shuffle service in directory: {}\",\n          localDir);\n      } catch (Exception e) {\n        logger.error(\"Failed to delete files not served by shuffle service in directory: {}\", e,\n          MDC.of(LogKeys.PATH$.MODULE$, localDir));\n      }\n    }\n  }",
    "comment": "Synchronously deletes files not served by shuffle service in each directory recursively.\nShould be executed in its own thread, as this may take a long time."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/testhelper/java/org/tensorflow/lite/TestHelper.java",
    "type": "method",
    "name": "getInputDataType",
    "code": "public static String getInputDataType(Interpreter interpreter, int index) {\n    if (interpreter != null && interpreter.wrapper != null) {\n      return DataTypeUtils.toStringName(interpreter.wrapper.getInputTensor(index).dataType());\n    } else {\n      throw new IllegalArgumentException(\n          \"Interpreter has not initialized;\" + \" Failed to get input data type.\");\n    }\n  }",
    "comment": "Gets the string name of the data type of an input.\n\n@param interpreter an instance of {@code Interpreter}. If it is not initialized, an {@code\nIllegalArgumentException} will be thrown.\n@param index an integer index of the input. If it is invalid, an {@code\nIllegalArgumentException} will be thrown.\n@return string name of the data type. Possible values include \"float\", \"int\", \"byte\", and\n\"long\"."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaRowSuite.java",
    "type": "method",
    "name": "constructSimpleRow",
    "code": "public void constructSimpleRow() {\n    Row simpleRow = RowFactory.create(\n      byteValue,                 // ByteType\n      Byte.valueOf(byteValue),\n      shortValue,                // ShortType\n      Short.valueOf(shortValue),\n      intValue,                  // IntegerType\n      Integer.valueOf(intValue),\n      longValue,                 // LongType\n      Long.valueOf(longValue),\n      floatValue,                // FloatType\n      Float.valueOf(floatValue),\n      doubleValue,               // DoubleType\n      Double.valueOf(doubleValue),\n      decimalValue,              // DecimalType\n      booleanValue,              // BooleanType\n      Boolean.valueOf(booleanValue),\n      stringValue,               // StringType\n      binaryValue,               // BinaryType\n      dateValue,                 // DateType\n      timestampValue,            // TimestampType\n      null                       // null\n    );\n\n    Assertions.assertEquals(byteValue, simpleRow.getByte(0));\n    Assertions.assertEquals(byteValue, simpleRow.get(0));\n    Assertions.assertEquals(byteValue, simpleRow.getByte(1));\n    Assertions.assertEquals(byteValue, simpleRow.get(1));\n    Assertions.assertEquals(shortValue, simpleRow.getShort(2));\n    Assertions.assertEquals(shortValue, simpleRow.get(2));\n    Assertions.assertEquals(shortValue, simpleRow.getShort(3));\n    Assertions.assertEquals(shortValue, simpleRow.get(3));\n    Assertions.assertEquals(intValue, simpleRow.getInt(4));\n    Assertions.assertEquals(intValue, simpleRow.get(4));\n    Assertions.assertEquals(intValue, simpleRow.getInt(5));\n    Assertions.assertEquals(intValue, simpleRow.get(5));\n    Assertions.assertEquals(longValue, simpleRow.getLong(6));\n    Assertions.assertEquals(longValue, simpleRow.get(6));\n    Assertions.assertEquals(longValue, simpleRow.getLong(7));\n    Assertions.assertEquals(longValue, simpleRow.get(7));\n    Assertions.assertEquals(floatValue, simpleRow.getFloat(8), 0);\n    Assertions.assertEquals(floatValue, simpleRow.get(8));\n    Assertions.assertEquals(floatValue, simpleRow.getFloat(9), 0);\n    Assertions.assertEquals(floatValue, simpleRow.get(9));\n    Assertions.assertEquals(doubleValue, simpleRow.getDouble(10), 0);\n    Assertions.assertEquals(doubleValue, simpleRow.get(10));\n    Assertions.assertEquals(doubleValue, simpleRow.getDouble(11), 0);\n    Assertions.assertEquals(doubleValue, simpleRow.get(11));\n    Assertions.assertEquals(decimalValue, simpleRow.get(12));\n    Assertions.assertEquals(booleanValue, simpleRow.getBoolean(13));\n    Assertions.assertEquals(booleanValue, simpleRow.get(13));\n    Assertions.assertEquals(booleanValue, simpleRow.getBoolean(14));\n    Assertions.assertEquals(booleanValue, simpleRow.get(14));\n    Assertions.assertEquals(stringValue, simpleRow.getString(15));\n    Assertions.assertEquals(stringValue, simpleRow.get(15));\n    Assertions.assertEquals(binaryValue, simpleRow.get(16));\n    Assertions.assertEquals(dateValue, simpleRow.get(17));\n    Assertions.assertEquals(timestampValue, simpleRow.get(18));\n    Assertions.assertTrue(simpleRow.isNullAt(19));\n    Assertions.assertNull(simpleRow.get(19));\n  }",
    "comment": "When we create the row, we do not do any conversion\nfor a float/double value, so we just set the delta to 0."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "iterator",
    "code": "public MapIterator iterator() {\n    return new MapIterator(numValues, new Location(), false);\n  }",
    "comment": "Returns an iterator for iterating over the entries of this map.\n\nFor efficiency, all calls to `next()` will return the same {@link Location} object.\n\nThe returned iterator is thread-safe. However if the map is modified while iterating over it,\nthe behavior of the returned iterator is undefined."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "setUserProperties",
    "code": "public DefaultProfileActivationContext setUserProperties(Map<String, String> userProperties) {\n        if (userProperties != null) {\n            this.userProperties = Collections.unmodifiableMap(userProperties);\n        } else {\n            this.userProperties = Collections.emptyMap();\n        }\n\n        return this;\n    }",
    "comment": "Sets the user properties to use for interpolation and profile activation. The user properties have been\nconfigured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command\nline.\n\n@param userProperties The user properties, may be {@code null}.\n@return This context, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-cli/src/main/java/org/apache/maven/cling/invoker/BaseParser.java",
    "type": "method",
    "name": "populateUserProperties",
    "code": "protected Map<String, String> populateUserProperties(LocalContext context) {\n        Properties userProperties = new Properties();\n\n\n        Map<String, String> userSpecifiedProperties =\n                context.options.userProperties().orElse(new HashMap<>());\n\n        Map<String, String> paths = context.extraInterpolationSource();\n        UnaryOperator<String> callback =\n                or(paths::get, prefix(\"cli.\", userSpecifiedProperties::get), context.systemProperties::get);\n\n        Path mavenConf;\n        if (context.systemProperties.get(Constants.MAVEN_INSTALLATION_CONF) != null) {\n            mavenConf = context.installationDirectory.resolve(\n                    context.systemProperties.get(Constants.MAVEN_INSTALLATION_CONF));\n        } else if (context.systemProperties.get(\"maven.conf\") != null) {\n            mavenConf = context.installationDirectory.resolve(context.systemProperties.get(\"maven.conf\"));\n        } else if (context.systemProperties.get(Constants.MAVEN_HOME) != null) {\n            mavenConf = context.installationDirectory\n                    .resolve(context.systemProperties.get(Constants.MAVEN_HOME))\n                    .resolve(\"conf\");\n        } else {\n            mavenConf = context.installationDirectory.resolve(\"\");\n        }\n        Path propertiesFile = mavenConf.resolve(\"maven.properties\");\n        try {\n            MavenPropertiesLoader.loadProperties(userProperties, propertiesFile, callback, false);\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Error loading properties from \" + propertiesFile, e);\n        }\n\n        userProperties.putAll(userSpecifiedProperties);\n\n        return toMap(userProperties);\n    }",
    "comment": "----------------------------------------------------------------------\nOptions that are set on the command line become system properties\nand therefore are set in the session properties. System properties\nare most dominant.\n----------------------------------------------------------------------\n----------------------------------------------------------------------\nLoad config files\n----------------------------------------------------------------------\nCLI specified properties are most dominant"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Event.java",
    "type": "method",
    "name": "executionSkipped",
    "code": "public static Event executionSkipped(TestDescriptor testDescriptor, String reason) {\n\t\treturn new Event(EventType.SKIPPED, testDescriptor, reason);\n\t}",
    "comment": "Create a <em>skipped</em> {@code Event} for the supplied\n{@link TestDescriptor} and {@code reason}.\n\n@param testDescriptor the {@code TestDescriptor} associated with the event;\nnever {@code null}\n@param reason the reason the execution was skipped; may be {@code null}\n@return the newly created {@code Event}\n@see EventType#SKIPPED"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/VariantBuilder.java",
    "type": "method",
    "name": "appendUuid",
    "code": "public void appendUuid(UUID uuid) {\n    checkCapacity(1 + 16);\n    writeBuffer[writePos++] = primitiveHeader(UUID);\n\n    ByteBuffer buffer = ByteBuffer.wrap(writeBuffer, writePos, 16);\n    buffer.order(ByteOrder.BIG_ENDIAN);\n    buffer.putLong(writePos, uuid.getMostSignificantBits());\n    buffer.putLong(writePos + 8, uuid.getLeastSignificantBits());\n    writePos += 16;\n  }",
    "comment": "UUID is stored big-endian, so don't use writeLong."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Stopwatch.java",
    "type": "method",
    "name": "finished",
    "code": "protected void finished(long nanos, Description description) {\n    }",
    "comment": "Invoked when a test method finishes (whether passing or failing)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/clean-architecture/src/main/java/com/iluwatar/cleanarchitecture/Cart.java",
    "type": "method",
    "name": "Cart",
    "code": "public Cart(final Product prod, final int qty) {\n    this.product = prod;\n    this.quantity = qty;\n  }",
    "comment": "Constructs a new Cart instance with a specified product and quantity.\n\n@param prod the product to be added to the cart.\n@param qty the quantity of the product in the cart."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-configuration/src/main/java/org/apache/maven/plugin/coreit/ConfigMojo.java",
    "type": "method",
    "name": "dumpConfiguration",
    "code": "private void dumpConfiguration(Properties props) {\n        /*\n         * NOTE: This intentionally does not dump the absolute path of a file to check the actual value that was\n         * injected by Maven.\n         */\n        PropertiesUtil.serialize(props, \"propertiesFile\", propertiesFile);\n        PropertiesUtil.serialize(props, \"aliasParam\", aliasParam);\n        PropertiesUtil.serialize(props, \"defaultParam\", defaultParam);\n        PropertiesUtil.serialize(props, \"defaultParamWithExpression\", defaultParamWithExpression);\n        PropertiesUtil.serialize(props, \"aliasDefaultExpressionParam\", aliasDefaultExpressionParam);\n        PropertiesUtil.serialize(props, \"booleanParam\", booleanParam);\n        if (primitiveBooleanParam) {\n            PropertiesUtil.serialize(props, \"primitiveBooleanParam\", primitiveBooleanParam);\n        }\n        PropertiesUtil.serialize(props, \"byteParam\", byteParam);\n        PropertiesUtil.serialize(props, \"shortParam\", shortParam);\n        PropertiesUtil.serialize(props, \"integerParam\", integerParam);\n        if (primitiveIntegerParam != 0) {\n            PropertiesUtil.serialize(props, \"primitiveIntegerParam\", primitiveIntegerParam);\n        }\n        PropertiesUtil.serialize(props, \"longParam\", longParam);\n        PropertiesUtil.serialize(props, \"floatParam\", floatParam);\n        PropertiesUtil.serialize(props, \"doubleParam\", doubleParam);\n        PropertiesUtil.serialize(props, \"characterParam\", characterParam);\n        PropertiesUtil.serialize(props, \"stringParam\", stringParam);\n        PropertiesUtil.serialize(props, \"fileParam\", fileParam);\n        PropertiesUtil.serialize(props, \"dateParam\", dateParam);\n        PropertiesUtil.serialize(props, \"urlParam\", urlParam);\n        PropertiesUtil.serialize(props, \"uriParam\", uriParam);\n        PropertiesUtil.serialize(props, \"stringParams\", stringParams);\n        PropertiesUtil.serialize(props, \"fileParams\", fileParams);\n        PropertiesUtil.serialize(props, \"listParam\", listParam);\n        PropertiesUtil.serialize(props, \"setParam\", setParam);\n        PropertiesUtil.serialize(props, \"mapParam\", mapParam);\n        PropertiesUtil.serialize(props, \"propertiesParam\", propertiesParam);\n        PropertiesUtil.serialize(props, \"aliasStringParams\", aliasStringParams);\n        PropertiesUtil.serialize(props, \"domParam\", domParam);\n        if (beanParam != null) {\n            PropertiesUtil.serialize(props, \"beanParam.fieldParam\", beanParam.fieldParam);\n            PropertiesUtil.serialize(props, \"beanParam.setterParam\", beanParam.setterParam);\n            PropertiesUtil.serialize(props, \"beanParam.setterCalled\", beanParam.setterCalled);\n        }\n    }",
    "comment": "Dumps the mojo configuration into the specified properties.\n\n@param props The properties to dump the configuration into, must not be <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/matchers/JUnitMatchers.java",
    "type": "method",
    "name": "hasItems",
    "code": "public static <T> Matcher<Iterable<T>> hasItems(Matcher<? super T>... elementMatchers) {\n        return CoreMatchers.hasItems(elementMatchers);\n    }",
    "comment": "@return A matcher matching any collection containing at least one element that matches\neach matcher in elementMatcher (this may be one element matching all matchers,\nor different elements matching each matcher)\n@deprecated Please use {@link CoreMatchers#hasItems(Matcher...)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/DefaultProjectArtifactFactory.java",
    "type": "method",
    "name": "DefaultProjectArtifactFactory",
    "code": "public DefaultProjectArtifactFactory(ArtifactFactory artifactFactory) {\n        this.artifactFactory = artifactFactory;\n    }",
    "comment": "Default component responsible for creation of MavenProject#dependencyArtifacts instances."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/main/java/org/tensorflow/lite/Tensor.java",
    "type": "method",
    "name": "QuantizationParams",
    "code": "public QuantizationParams(final float scale, final int zeroPoint) {\n      this.scale = scale;\n      this.zeroPoint = zeroPoint;\n    }",
    "comment": "Creates a {@link QuantizationParams} with {@code scale} and {@code zero_point}.\n\n@param scale The scale value used in quantization.\n@param zeroPoint The zero point value used in quantization."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/monitor/src/main/java/com/iluwatar/monitor/Bank.java",
    "type": "method",
    "name": "transfer",
    "code": "public synchronized void transfer(int accountA, int accountB, int amount) {\n    if (accounts[accountA] >= amount && accountA != accountB) {\n      accounts[accountB] += amount;\n      accounts[accountA] -= amount;\n      if (LOGGER.isDebugEnabled()) {\n        LOGGER.debug(\n            \"Transferred from account: {} to account: {} , amount: {} , bank balance at: {}, source account balance: {}, destination account balance: {}\",\n            accountA,\n            accountB,\n            amount,\n            getBalance(),\n            getBalance(accountA),\n            getBalance(accountB));\n      }\n    }\n  }",
    "comment": "Transfer amounts from one account to another.\n\n@param accountA - source account\n@param accountB - destination account\n@param amount - amount to be transferred"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/expressions/aggregate/GeneralAggregateFunc.java",
    "type": "method",
    "name": "GeneralAggregateFunc",
    "code": "public GeneralAggregateFunc(String name, boolean isDistinct, Expression[] children) {\n    this.name = name;\n    this.isDistinct = isDistinct;\n    this.children = children;\n    this.orderingWithinGroups = new SortValue[]{};\n\n  public GeneralAggregateFunc(\n      String name, boolean isDistinct, Expression[] children, SortValue[] orderingWithinGroups) {\n    this.name = name;\n    this.isDistinct = isDistinct;\n    this.children = children;\n    this.orderingWithinGroups = orderingWithinGroups;\n  }\n\n  public String name() { return name; }\n  public boolean isDistinct() { return isDistinct; }\n\n  @Override\n  public Expression[] children() { return children; }\n\n  public SortValue[] orderingWithinGroups() { return orderingWithinGroups; }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    GeneralAggregateFunc that = (GeneralAggregateFunc) o;\n\n    if (isDistinct != that.isDistinct) return false;\n    if (!name.equals(that.name)) return false;\n    if (!Arrays.equals(children, that.children)) return false;\n    return Arrays.equals(orderingWithinGroups, that.orderingWithinGroups);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = name.hashCode();\n    result = 31 * result + (isDistinct ? 1 : 0);\n    result = 31 * result + Arrays.hashCode(children);\n    result = 31 * result + Arrays.hashCode(orderingWithinGroups);\n    return result;\n  }\n}",
    "comment": "The general implementation of {@link AggregateFunc}, which contains the upper-cased function\nname, the `isDistinct` flag and all the inputs. Note that Spark cannot push down partial\naggregate with this function to the source, but can only push down the entire aggregate.\n<p>\nThe currently supported SQL aggregate functions:\n<ol>\n<li><pre>VAR_POP(input1)</pre> Since 3.3.0</li>\n<li><pre>VAR_SAMP(input1)</pre> Since 3.3.0</li>\n<li><pre>STDDEV_POP(input1)</pre> Since 3.3.0</li>\n<li><pre>STDDEV_SAMP(input1)</pre> Since 3.3.0</li>\n<li><pre>COVAR_POP(input1, input2)</pre> Since 3.3.0</li>\n<li><pre>COVAR_SAMP(input1, input2)</pre> Since 3.3.0</li>\n<li><pre>CORR(input1, input2)</pre> Since 3.3.0</li>\n<li><pre>REGR_INTERCEPT(input1, input2)</pre> Since 3.4.0</li>\n<li><pre>REGR_R2(input1, input2)</pre> Since 3.4.0</li>\n<li><pre>REGR_SLOPE(input1, input2)</pre> Since 3.4.0</li>\n<li><pre>REGR_SXY(input1, input2)</pre> Since 3.4.0</li>\n<li><pre>MODE() WITHIN (ORDER BY input1 [ASC|DESC])</pre> Since 4.0.0</li>\n<li><pre>PERCENTILE_CONT(input1) WITHIN (ORDER BY input2 [ASC|DESC])</pre> Since 4.0.0</li>\n<li><pre>PERCENTILE_DISC(input1) WITHIN (ORDER BY input2 [ASC|DESC])</pre> Since 4.0.0</li>\n</ol>\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/expressions/javalang/typed.java",
    "type": "method",
    "name": "sumLong",
    "code": "public static <T> TypedColumn<T, Long> sumLong(MapFunction<T, Long> f) {\n    return new TypedSumLong<T>(f).toColumnJava();\n  }",
    "comment": "Sum aggregate function for integral (long, i.e. 64 bit integer) type.\n\n@since 2.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, float actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/condition/OS.java",
    "type": "method",
    "name": "parse",
    "code": "static OS parse(String osName) {\n\t\tif (StringUtils.isBlank(osName)) {\n\t\t\tlogger.debug(\n\t\t\t\t() -> \"JVM system property 'os.name' is undefined. It is therefore not possible to detect the current OS.\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tosName = osName.toLowerCase(Locale.ENGLISH);\n\n\t\tif (osName.contains(\"aix\")) {\n\t\t\treturn AIX;\n\t\t}\n\t\tif (osName.contains(\"freebsd\")) {\n\t\t\treturn FREEBSD;\n\t\t}\n\t\tif (osName.contains(\"linux\")) {\n\t\t\treturn LINUX;\n\t\t}\n\t\tif (osName.contains(\"mac\")) {\n\t\t\treturn MAC;\n\t\t}\n\t\tif (osName.contains(\"openbsd\")) {\n\t\t\treturn OPENBSD;\n\t\t}\n\t\tif (osName.contains(\"sunos\") || osName.contains(\"solaris\")) {\n\t\t\treturn SOLARIS;\n\t\t}\n\t\tif (osName.contains(\"win\")) {\n\t\t\treturn WINDOWS;\n\t\t}\n\t\treturn OTHER;\n\t}",
    "comment": "null signals that the current OS is \"unknown\""
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/api/src/main/java/org/apache/spark/sql/streaming/Trigger.java",
    "type": "method",
    "name": "Continuous",
    "code": "public static Trigger Continuous(long intervalMs) {\n    return ContinuousTrigger.apply(intervalMs);\n  }",
    "comment": "A trigger that continuously processes streaming data, asynchronously checkpointing at\nthe specified interval.\n\n@since 2.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/AbstractNioChannel.java",
    "type": "method",
    "name": "write",
    "code": "public void write(Object data, SelectionKey key) {\n    var pendingWrites = this.channelToPendingWrites.get(key.channel());\n    if (pendingWrites == null) {\n      synchronized (this.channelToPendingWrites) {\n        pendingWrites =\n            this.channelToPendingWrites.computeIfAbsent(\n                key.channel(), k -> new ConcurrentLinkedQueue<>());\n      }\n    }\n    pendingWrites.add(data);\n    reactor.changeOps(key, SelectionKey.OP_WRITE);\n  }",
    "comment": "Queues the data for writing. The data is not guaranteed to be written on underlying channel\nwhen this method returns. It will be written when the channel is flushed.\n\n<p>This method is used by the {@link ChannelHandler} to send reply back to the client. <br>\nExample:\n\n<pre>\n<code>\n{@literal @}Override\npublic void handleChannelRead(AbstractNioChannel channel, Object readObj, SelectionKey key) {\nbyte[] data = ((ByteBuffer)readObj).array();\nByteBuffer buffer = ByteBuffer.wrap(\"Server reply\".getBytes());\nchannel.write(buffer, key);\n}\n</code>\n</pre>\n\n@param data the data to be written on underlying channel.\n@param key the key which is writable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/HealthCheckRepositoryTest.java",
    "type": "method",
    "name": "whenPerformTestTransaction_thenSucceeds",
    "code": "void whenPerformTestTransaction_thenSucceeds() {\n    // Arrange\n    HealthCheck healthCheck = new HealthCheck();\n    healthCheck.setStatus(\"OK\");\n\n    // Mocking the necessary EntityManager behaviors\n    when(entityManager.find(eq(HealthCheck.class), any())).thenReturn(healthCheck);\n\n    // Act & Assert\n    assertDoesNotThrow(() -> healthCheckRepository.performTestTransaction());\n\n    // Verify the interactions\n    verify(entityManager).persist(any(HealthCheck.class));\n    verify(entityManager).flush();\n    verify(entityManager).remove(any(HealthCheck.class));\n  }",
    "comment": "Test case for the `performTestTransaction()` method.\n\n<p>Asserts that when the `performTestTransaction()` method is called, it successfully executes\na test transaction."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Short unexpected, Short actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/data-mapper/src/main/java/com/iluwatar/datamapper/StudentDataMapperImpl.java",
    "type": "method",
    "name": "find",
    "code": "public Optional<Student> find(int studentId) {\n    return this.getStudents().stream().filter(x -> x.getStudentId() == studentId).findFirst();\n  }",
    "comment": "@Getter\npublic final class StudentDataMapperImpl implements StudentDataMapper {\n\n/* Note: Normally this would be in the form of an actual database"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/SessionData.java",
    "type": "method",
    "name": "key",
    "code": "static <T> Key<T> key(Class<T> clazz) {\n        return new Key<>(clazz, clazz);\n    }",
    "comment": "Create a key using the given class as an identifier and as the type of the object."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "exact",
    "code": "public static Match exact(TestDescriptor testDescriptor) {\n\t\t\treturn exact(testDescriptor, Collections::emptySet);\n\t\t}",
    "comment": "Factory for creating an exact match without any children.\n\n@param testDescriptor the resolved {@code TestDescriptor}; never\n{@code null}\n@return a match that contains the supplied {@code TestDescriptor};\nnever {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java",
    "type": "method",
    "name": "resolve",
    "code": "default Resolution resolve(NestedMethodSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
    "comment": "Resolve the supplied {@link NestedMethodSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/LifecycleMethodExecutionExceptionHandlerTests.java",
    "type": "method",
    "name": "multipleHandlersAreCalledInOrder",
    "code": "void multipleHandlersAreCalledInOrder() {\n\t\tLauncherDiscoveryRequest request = request().selectors(selectClass(MultipleHandlersTestCase.class)).build();\n\t\tEngineExecutionResults executionResults = executeTests(request);\n\n\t\texecutionResults.allEvents().assertEventsMatchExactly( //\n\t\t\tevent(engine(), started()), //\n\t\t\tevent(container(MultipleHandlersTestCase.class), started()), //\n\t\t\tevent(test(\"aTest\"), started()), //\n\t\t\tevent(test(\"aTest\"), finishedSuccessfully()), //\n\t\t\tevent(test(\"aTest2\"), started()), //\n\t\t\tevent(test(\"aTest2\"), finishedSuccessfully()), //\n\t\t\tevent(container(MultipleHandlersTestCase.class), finishedSuccessfully()), //\n\t\t\tevent(engine(), finishedSuccessfully())); //\n\n\t\tassertEquals(Arrays.asList(\n\t\t\t\"RethrowExceptionBeforeAll\", \"SwallowExceptionBeforeAll\",\n\t\t\t\"ConvertExceptionBeforeEach\", \"RethrowExceptionBeforeEach\", \"SwallowExceptionBeforeEach\",\n\t\t\t\"ConvertExceptionAfterEach\", \"RethrowExceptionAfterEach\", \"SwallowExceptionAfterEach\",\n\t\t\t\"RethrowExceptionBeforeEach\", \"SwallowExceptionBeforeEach\",\n\t\t\t\"RethrowExceptionAfterEach\", \"SwallowExceptionAfterEach\",\n\t\t\t\"RethrowExceptionAfterAll\", \"SwallowExceptionAfterAll\" //\n\t\t), handlerCalls, \"Wrong order of handler calls\");\n\t}",
    "comment": "BeforeAll chain (class level only)\nBeforeEach chain for aTest (test + class level)\nAfterEach chain for aTest  (test + class level)\nBeforeEach chain for aTest2 (class level only)\nAfterEach chain for aTest2 (class level only)\nAfterAll chain (class level only)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "onResume",
    "code": "public void onResume() {\n    super.onResume();\n    startBackgroundThread();\n\n    if (textureView.isAvailable()) {\n      openCamera(textureView.getWidth(), textureView.getHeight());\n    } else {\n      textureView.setSurfaceTextureListener(surfaceTextureListener);\n    }\n  }",
    "comment": "When the screen is turned off and turned back on, the SurfaceTexture is already\navailable, and \"onSurfaceTextureAvailable\" will not be called. In that case, we can open\na camera and start preview from here (otherwise, we wait until the surface is ready in\nthe SurfaceTextureListener)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/master-worker/src/main/java/com/iluwatar/masterworker/system/systemmaster/ArrayTransposeMaster.java",
    "type": "method",
    "name": "aggregateData",
    "code": "ArrayResult aggregateData() {\n    var allResultData = this.getAllResultData();\n    var rows = ((ArrayResult) allResultData.elements().nextElement()).data.length;\n    var elements = allResultData.elements();\n    var columns = 0; // columns = sum of number of columns in all results obtained from workers\n    while (elements.hasMoreElements()) {\n      columns += ((ArrayResult) elements.nextElement()).data[0].length;\n    }\n    var resultData = new int[rows][columns];\n    var columnsDone = 0; // columns aggregated so far\n    var workers = this.getWorkers();\n    for (var i = 0; i < this.getExpectedNumResults(); i++) {\n      var worker = workers.get(i);\n      var workerId = worker.getWorkerId();\n      var work = ((ArrayResult) allResultData.get(workerId)).data;\n      for (var m = 0; m < work.length; m++) {\n        System.arraycopy(work[m], 0, resultData[m], columnsDone, work[0].length);\n      }\n      columnsDone += work[0].length;\n    }\n    return new ArrayResult(resultData);\n  }",
    "comment": "number of rows in final result is number of rows in any of obtained results from workers\nresult obtained from ith worker\nm = row number, n = columns number"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/profile/ConditionFunctions.java",
    "type": "method",
    "name": "inrange",
    "code": "public Object inrange(List<Object> args) {\n        if (args.size() != 2) {\n            throw new IllegalArgumentException(\"inrange function requires exactly two arguments\");\n        }\n        String version = ConditionParser.toString(args.get(0));\n        String range = ConditionParser.toString(args.get(1));\n        return versionParser.parseVersionRange(range).contains(versionParser.parseVersion(version));\n    }",
    "comment": "Checks if a version is within a specified version range.\n\n@param args A list containing two strings: the version to check and the version range\n@return true if the version is within the range, false otherwise\n@throws IllegalArgumentException if the number of arguments is not exactly two"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-log-file/src/main/java/org/apache/maven/plugin/coreit/AbstractLogMojo.java",
    "type": "method",
    "name": "getLogFile",
    "code": "private File getLogFile() {\n        /*\n         * NOTE: We don't want to test path translation here.\n         */\n        return logFile.isAbsolute() ? logFile : new File(basedir, logFile.getPath());\n    }",
    "comment": "Gets the absolute path to the log file.\n\n@return The absolute path to the log file, never <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/OneForOneBlockFetcher.java",
    "type": "method",
    "name": "isAllBlocksStartWithShuffleChunkPrefix",
    "code": "private static boolean isAllBlocksStartWithShuffleChunkPrefix(String[] blockIds) {\n    for (String blockId : blockIds) {\n      if (!blockId.startsWith(SHUFFLE_CHUNK_PREFIX)) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": "SPARK-40398: Replace `Arrays.stream().allMatch()` with this method due to perf gain."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java",
    "type": "method",
    "name": "provideForMethod",
    "code": "default Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass, Method testMethod) {\n\t\treturn emptySet();\n\t}",
    "comment": "Add shared resources for a test method.\n\n<p>Invoked in case:\n<ul>\n<li>an enclosing test class of any level or its parent class is\nannotated with {@code @ResourceLock(providers)}.</li>\n<li>a test method is annotated with {@code @ResourceLock(providers)}.</li>\n</ul>\n\n@apiNote Adding {@linkplain Lock a shared resource} with this method\nhas the same semantics as annotating a test method\nwith analogous {@code @ResourceLock(value, mode)}.\n\n@implNote The classes supplied as {@code enclosingInstanceTypes} may\ndiffer from the classes returned from invocations of\n{@link Class#getEnclosingClass()} &mdash; for example, when a nested test\nclass is inherited from a superclass. Similarly, the class instance\nsupplied as {@code testClass} may differ from the class returned by\n{@code testMethod.getDeclaringClass()} &mdash; for example, when a test\nmethod is inherited from a superclass.\n\n@param enclosingInstanceTypes the runtime types of the enclosing\ninstances for the test class, ordered from outermost to innermost,\nexcluding {@code testClass}; never {@code null}\n@param testClass the test class or {@link org.junit.jupiter.api.Nested @Nested}\ntest class that contains the {@code testMethod}\n@param testMethod a test method for which to add shared resources\n@return a set of {@link Lock}; may be empty\n@see org.junit.jupiter.api.Nested @Nested"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java",
    "type": "method",
    "name": "skip",
    "code": "public static SkipResult skip(String reason) {\n\t\t\treturn new SkipResult(true, reason);\n\t\t}",
    "comment": "Factory for creating <em>skipped</em> results.\n\n<p>A context that is skipped will be not be executed.\n\n@param reason the reason that the context should be skipped,\nmay be {@code null}\n@return a skipped {@code SkipResult} with the given reason"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-repository-metadata/src/test/java/org/apache/maven/artifact/repository/metadata/MetadataTest.java",
    "type": "method",
    "name": "addSnapshotVersion",
    "code": "private static SnapshotVersion addSnapshotVersion(Versioning versioning, Date timestamp, Artifact artifact) {\n        int buildNumber = 1;\n        String version = artifact.getVersion();\n        String qualifier = formatDate(timestamp, true) + '-' + buildNumber;\n        version = version.substring(0, version.length() - SNAPSHOT.length()) + qualifier;\n        return addSnapshotVersion(versioning, artifact.getExtension(), timestamp, version, buildNumber);\n    }",
    "comment": "this generates timestamped versions like maven-resolver-provider:\nhttps://github.com/apache/maven/blob/03df5f7c639db744a3597c7175c92c8e2a27767b/maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/RemoteSnapshotMetadata.java#L79"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ConditionEvaluationResult.java",
    "type": "method",
    "name": "disabled",
    "code": "public static ConditionEvaluationResult disabled(String reason) {\n\t\treturn new ConditionEvaluationResult(false, reason);\n\t}",
    "comment": "Factory for creating <em>disabled</em> results.\n\n@param reason the reason why the container or test should be disabled\n@return a disabled {@code ConditionEvaluationResult} with the given reason"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/crypto/GcmTransportCipher.java",
    "type": "method",
    "name": "initalizeExpectedLength",
    "code": "private boolean initalizeExpectedLength(ByteBuf ciphertextNettyBuf) {\n            if (expectedLength < 0) {\n                ciphertextNettyBuf.readBytes(expectedLengthBuffer);\n                if (expectedLengthBuffer.hasRemaining()) {\n                    return false;\n                }\n                expectedLengthBuffer.flip();\n                expectedLength = expectedLengthBuffer.getLong();\n                if (expectedLength < 0) {\n                    throw new IllegalStateException(\"Invalid expected ciphertext length.\");\n                }\n                ciphertextRead += LENGTH_HEADER_BYTES;\n            }\n            return true;\n        }",
    "comment": "We did not read enough bytes to initialize the expected length."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/variant/src/main/java/org/apache/spark/types/variant/Variant.java",
    "type": "method",
    "name": "getString",
    "code": "public String getString() {\n    return VariantUtil.getString(value, pos);\n  }",
    "comment": "Get a string value from the variant."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng7470ResolverTransportTest.java",
    "type": "method",
    "name": "isJdkTransportUsable",
    "code": "private boolean isJdkTransportUsable() {\n        return JDK_TRANSPORT_USABLE_ON_JDK_SINCE.compareTo(getJavaVersion()) < 1;\n    }",
    "comment": "Returns {@code true} if JDK HttpClient transport is usable (Java11 or better)."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/TestExecutionResult.java",
    "type": "method",
    "name": "aborted",
    "code": "public static TestExecutionResult aborted(Throwable throwable) {\n\t\treturn new TestExecutionResult(ABORTED, throwable);\n\t}",
    "comment": "Create a {@code TestExecutionResult} for an <em>aborted</em> execution\nof a test or container with the supplied {@link Throwable throwable}.\n\n@param throwable the throwable that caused the aborted execution; may be\n{@code null}\n@return the {@code TestExecutionResult}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/matchers/JUnitMatchers.java",
    "type": "method",
    "name": "either",
    "code": "public static <T> CombinableEitherMatcher<T> either(Matcher<? super T> matcher) {\n        return CoreMatchers.either(matcher);\n    }",
    "comment": "This is useful for fluently combining matchers where either may pass, for example:\n<pre>\nassertThat(string, either(containsString(\"a\")).or(containsString(\"b\")));\n</pre>\n\n@deprecated Please use {@link CoreMatchers#either(Matcher)} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/anti-corruption-layer/src/main/java/com/iluwatar/corruption/system/legacy/LegacyShop.java",
    "type": "method",
    "name": "placeOrder",
    "code": "public void placeOrder(LegacyOrder legacyOrder) {\n    store.put(legacyOrder.getId(), legacyOrder);\n  }",
    "comment": "Places the order in the legacy system. If the order is already present in the modern system,\nthen the order is placed only if the data is the same. If the order is not present in the\nmodern system, then the order is placed in the legacy system."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/TemporaryFolder.java",
    "type": "method",
    "name": "build",
    "code": "public TemporaryFolder build() {\n            return new TemporaryFolder(this);\n        }",
    "comment": "Builds a {@link TemporaryFolder} instance using the values in this builder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertNull",
    "code": "public static void assertNull(String message, Object object) {\n        assertTrue(message, object == null);\n    }",
    "comment": "Asserts that an object is null.  If it is not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/operation/MetadataOperation.java",
    "type": "method",
    "name": "convertIdentifierPattern",
    "code": "protected String convertIdentifierPattern(final String pattern, boolean datanucleusFormat) {\n    if (pattern == null) {\n      return convertPattern(\"%\", true);\n    } else {\n      return convertPattern(pattern, datanucleusFormat);\n    }\n  }",
    "comment": "Convert wildchars and escape sequence from JDBC format to datanucleous/regex"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/runner/AllTests.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n        junit.textui.TestRunner.run(suite());\n    }",
    "comment": "TestSuite that runs all the sample tests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-locator/src/main/java/com/iluwatar/servicelocator/ServiceCache.java",
    "type": "method",
    "name": "getService",
    "code": "public Service getService(String serviceName) {\n    if (serviceCache.containsKey(serviceName)) {\n      var cachedService = serviceCache.get(serviceName);\n      var name = cachedService.getName();\n      var id = cachedService.getId();\n      LOGGER.info(\"(cache call) Fetched service {}({}) from cache... !\", name, id);\n      return cachedService;\n    }\n    return null;\n  }",
    "comment": "Get the service from the cache. null if no service is found matching the name\n\n@param serviceName a string\n@return {@link Service}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/model/reflection/MethodMap.java",
    "type": "method",
    "name": "isMethodInvocationConvertible",
    "code": "private static boolean isMethodInvocationConvertible(Class<?> formal, Class<?> actual) {\n        // if it's a null, it means the arg was null\n        if (actual == null && !formal.isPrimitive()) {\n            return true;\n        }\n\n        // Check for identity or widening reference conversion\n        if (actual != null && formal.isAssignableFrom(actual)) {\n            return true;\n        }\n\n        // Check for boxing with widening primitive conversion. Note that\n        // actual parameters are never primitives.\n        if (formal.isPrimitive()) {\n            if (formal == Boolean.TYPE && actual == Boolean.class) {\n                return true;\n            }\n            if (formal == Character.TYPE && actual == Character.class) {\n                return true;\n            }\n            if (formal == Byte.TYPE && actual == Byte.class) {\n                return true;\n            }\n            if (formal == Short.TYPE && (actual == Short.class || actual == Byte.class)) {\n                return true;\n            }\n            if (formal == Integer.TYPE && (actual == Integer.class || actual == Short.class || actual == Byte.class)) {\n                return true;\n            }\n            if (formal == Long.TYPE\n                    && (actual == Long.class\n                            || actual == Integer.class\n                            || actual == Short.class\n                            || actual == Byte.class)) {\n                return true;\n            }\n            if (formal == Float.TYPE\n                    && (actual == Float.class\n                            || actual == Long.class\n                            || actual == Integer.class\n                            || actual == Short.class\n                            || actual == Byte.class)) {\n                return true;\n            }\n            if (formal == Double.TYPE\n                    && (actual == Double.class\n                            || actual == Float.class\n                            || actual == Long.class\n                            || actual == Integer.class\n                            || actual == Short.class\n                            || actual == Byte.class)) {\n                return true;\n            }\n        }\n\n        return false;\n    }",
    "comment": "Determines whether a type represented by a class object is\nconvertible to another type represented by a class object using a\nmethod invocation conversion, treating object types of primitive\ntypes as if they were primitive types (that is, a Boolean actual\nparameter type matches boolean primitive formal type). This behavior\nis because this method is used to determine applicable methods for\nan actual parameter list, and primitive types are represented by\ntheir object duals in reflective method calls.\n\n@param formal the formal parameter type to which the actual\nparameter type should be convertible\n@param actual the actual parameter type.\n@return true if either formal type is assignable from actual type,\nor formal is a primitive type and actual is its corresponding object\ntype or an object type of a primitive type that can be converted to\nthe formal type."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/FileModelSource.java",
    "type": "method",
    "name": "getRelatedSource",
    "code": "public ModelSource2 getRelatedSource(String relPath) {\n        relPath = relPath.replace('\\\\', File.separatorChar).replace('/', File.separatorChar);\n\n        Path relatedPom = getPath().getParent().resolve(relPath);\n\n        if (Files.isDirectory(relatedPom)) {\n            relatedPom = relatedPom.resolve(\"pom.xml\");\n        }\n\n        if (Files.isRegularFile(relatedPom) && Files.isReadable(relatedPom)) {\n            return new FileModelSource(relatedPom.normalize());\n        }\n\n        return null;\n    }",
    "comment": "TODO figure out how to reuse ModelLocator.locatePom(File) here"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/strangler/src/main/java/com/iluwatar/strangler/NewArithmetic.java",
    "type": "method",
    "name": "ifHasZero",
    "code": "public boolean ifHasZero(int... nums) {\n    LOGGER.info(\"Arithmetic check zero {}\", VERSION);\n    return !source.ifNonZero(nums);\n  }",
    "comment": "Check if it has any zero.\n\n@param nums numbers need to check\n@return if it has any zero, return true, else, return false"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ThrowableCollector.java",
    "type": "method",
    "name": "ThrowableCollector",
    "code": "public ThrowableCollector(Predicate<? super Throwable> abortedExecutionPredicate) {\n\t\tthis.abortedExecutionPredicate = Preconditions.notNull(abortedExecutionPredicate,\n\t\t\t\"abortedExecutionPredicate must not be null\");\n\t}",
    "comment": "Create a new {@code ThrowableCollector} that uses the supplied\n<em>aborted</em> or <em>failed</em> execution.\n\n@param abortedExecutionPredicate the predicate used to decide whether a\n{@code Throwable} aborted execution; never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/ReactorReader.java",
    "type": "method",
    "name": "getProjectArtifacts",
    "code": "private Stream<Artifact> getProjectArtifacts(MavenProject project) {\n        Stream<org.apache.maven.artifact.Artifact> artifacts = Stream.concat(\n                Stream.concat(\n                        // pom artifact\n                        Stream.of(new ProjectArtifact(project)),\n                        // main project artifact if not a pom\n                        \"pom\".equals(project.getPackaging()) ? Stream.empty() : Stream.of(project.getArtifact())),\n                // attached artifacts\n                project.getAttachedArtifacts().stream());\n        return artifacts.map(RepositoryUtils::toArtifact);\n    }",
    "comment": "Retrieve a stream of the project's artifacts"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertTimeoutPreemptively",
    "code": "public static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier) {\n\t\treturn AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, supplier);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code supplier}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>See the {@linkplain Assertions Preemptive Timeouts} section of the\nclass-level Javadoc for further details.\n\n<p>If the assertion passes then the {@code supplier}'s result is returned.\n\n@see #assertTimeoutPreemptively(Duration, Executable)\n@see #assertTimeoutPreemptively(Duration, Executable, String)\n@see #assertTimeoutPreemptively(Duration, Executable, Supplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, String)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeout(Duration, Executable)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java",
    "type": "method",
    "name": "findFactoryMethod",
    "code": "private static Method findFactoryMethod(Class<?> testClass, Optional<Method> testMethod, String factoryMethodName) {\n\t\tString originalFactoryMethodName = factoryMethodName;\n\n\t\tif (StringUtils.isBlank(factoryMethodName)) {\n\t\t\tPreconditions.condition(testMethod.isPresent(),\n\t\t\t\t\"You must specify a method name when using @MethodSource with @ParameterizedClass\");\n\t\t\tfactoryMethodName = testMethod.get().getName();\n\t\t\treturn findFactoryMethodBySimpleName(testClass, testMethod, factoryMethodName);\n\t\t}\n\n\t\tif (!looksLikeAFullyQualifiedMethodName(factoryMethodName)) {\n\t\t\tfactoryMethodName = testClass.getName() + \"#\" + factoryMethodName;\n\t\t}\n\n\t\tMethod factoryMethod = findFactoryMethodByFullyQualifiedName(testClass, testMethod, factoryMethodName);\n\n\t\tPreconditions.condition(isFactoryMethod.test(factoryMethod), () -> format(\n\t\t\t\"Could not find valid factory method [%s] for test class [%s] but found the following invalid candidate: %s\",\n\t\t\toriginalFactoryMethodName, testClass.getName(), factoryMethod));\n\n\t\treturn factoryMethod;\n\t}",
    "comment": "If the user did not provide a factory method name, find a \"default\" local\nfactory method with the same name as the parameterized test method.\nConvert local factory method name to fully qualified method name.\nFind factory method using fully qualified name.\nEnsure factory method has a valid return type and is not a test method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/DependencyResolverRequest.java",
    "type": "method",
    "name": "pathTypeFilter",
    "code": "public DependencyResolverRequestBuilder pathTypeFilter(@Nonnull Predicate<PathType> pathTypeFilter) {\n            this.pathTypeFilter = pathTypeFilter;\n            return this;\n        }",
    "comment": "Filters the types of paths to include in the result.\nThe result will contain only the paths of types for which the predicate returned {@code true}.\nIt is recommended to apply a filter for retaining only the types of paths of interest,\nbecause it can resolve ambiguities when a path could be of many types.\n\n@param pathTypeFilter predicate evaluating whether a path type should be included in the result\n@return {@code this} for method call chaining"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java",
    "type": "method",
    "name": "tryToFilterRunner",
    "code": "private boolean tryToFilterRunner(Description description) {\n\t\tif (runner instanceof Filterable) {\n\t\t\tExcludeDescriptionFilter filter = new ExcludeDescriptionFilter(description);\n\t\t\ttry {\n\t\t\t\t((Filterable) runner).filter(filter);\n\t\t\t}\n\t\t\tcatch (NoTestsRemainException ignore) {\n\t\t\t}\n\t\t\treturn filter.wasSuccessful();\n\t\t}\n\t\treturn false;\n\t}",
    "comment": "it's safe to ignore this exception because childless TestDescriptors will get pruned"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/main/java/com/example/android/persistence/migrations/UserPresenter.java",
    "type": "method",
    "name": "updateUserName",
    "code": "public void updateUserName(final String userName) {\n\n        mDataSource.updateUserName(userName, mUpdateUserCallback);\n    }",
    "comment": "Update the username of the user.\n\n@param userName the new userName"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/configuration/internal/EnhancedComponentConfigurator.java",
    "type": "method",
    "name": "EnhancedComponentConfigurator",
    "code": "public EnhancedComponentConfigurator() {\n        converterLookup = new EnhancedConverterLookup();\n    }",
    "comment": "A component configurator which can leverage the {@link EnhancedConfigurationConverter}\nand {@link EnhancedConverterLookup}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/catalyst/expressions/codegen/UnsafeWriter.java",
    "type": "method",
    "name": "getBufferHolder",
    "code": "public final BufferHolder getBufferHolder() {\n    return holder;\n  }",
    "comment": "Accessor methods are delegated from BufferHolder class"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaBeanDeserializationSuite.java",
    "type": "method",
    "name": "testSpark22000",
    "code": "public void testSpark22000() {\n    List<Row> inputRows = new ArrayList<>();\n    List<RecordSpark22000> expectedRecords = new ArrayList<>();\n\n    for (long idx = 0 ; idx < 5 ; idx++) {\n      Row row = createRecordSpark22000Row(idx);\n      inputRows.add(row);\n      expectedRecords.add(createRecordSpark22000(row));\n    }\n\n    Encoder<RecordSpark22000> encoder = Encoders.bean(RecordSpark22000.class);\n\n    StructType schema = new StructType()\n      .add(\"shortField\", DataTypes.ShortType)\n      .add(\"intField\", DataTypes.IntegerType)\n      .add(\"longField\", DataTypes.LongType)\n      .add(\"floatField\", DataTypes.FloatType)\n      .add(\"doubleField\", DataTypes.DoubleType)\n      .add(\"stringField\", DataTypes.StringType)\n      .add(\"booleanField\", DataTypes.BooleanType)\n      .add(\"timestampField\", DataTypes.TimestampType)\n      .add(\"nullIntField\", DataTypes.IntegerType, true);\n\n    Dataset<Row> dataFrame = spark.createDataFrame(inputRows, schema);\n    Dataset<RecordSpark22000> dataset = dataFrame.as(encoder);\n\n    List<RecordSpark22000> records = dataset.collectAsList();\n\n    Assertions.assertEquals(expectedRecords, records);\n  }",
    "comment": "Here we try to convert the fields, from any types to string.\nBefore applying SPARK-22000, Spark called toString() against variable which type might\nbe primitive.\nSPARK-22000 it calls String.valueOf() which finally calls toString() but handles boxing\nif the type is primitive.\nexplicitly setting nullable = true to make clear the intention"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaDocument.java",
    "type": "method",
    "name": "JavaDocument",
    "code": "public JavaDocument(long id, String text) {\n    this.id = id;\n    this.text = text;\n  }",
    "comment": "Unlabeled instance type, Spark SQL can infer schema from Java Beans."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/plugin/internal/AbstractMavenPluginParametersValidator.java",
    "type": "method",
    "name": "AbstractMavenPluginParametersValidator",
    "code": "protected AbstractMavenPluginParametersValidator(PluginValidationManager pluginValidationManager) {\n        this.pluginValidationManager = requireNonNull(pluginValidationManager);\n    }",
    "comment": "Common implementations for plugin parameters configuration validation."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java",
    "type": "method",
    "name": "selectMethod",
    "code": "public static MethodSelector selectMethod(ClassLoader classLoader, String className, String methodName) {\n\t\treturn selectMethod(classLoader, className, methodName, \"\");\n\t}",
    "comment": "Create a {@code MethodSelector} for the supplied class name, method name,\nand class loader.\n\n@param classLoader the class loader to use to load the class, or {@code null}\nto signal that the default {@code ClassLoader} should be used\n@param className the fully qualified name of the class in which the method\nis declared, or a subclass thereof; never {@code null} or blank\n@param methodName the name of the method to select; never {@code null} or blank\n@since 1.10\n@see MethodSelector"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/ExecutionRecorder.java",
    "type": "method",
    "name": "fileEntryPublished",
    "code": "public void fileEntryPublished(TestDescriptor testDescriptor, FileEntry file) {\n\t\tthis.events.add(Event.fileEntryPublished(testDescriptor, file));\n\t}",
    "comment": "Record an {@link Event} for a published {@link FileEntry}.\n\n@since 1.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextStoreConcurrencyTests.java",
    "type": "method",
    "name": "concurrentAccessToDefaultStoreWithoutParentStore",
    "code": "void concurrentAccessToDefaultStoreWithoutParentStore() {\n\t\t// Run the actual test 100 times \"for good measure\".\n\t\tIntStream.range(1, 100).forEach(i -> {\n\t\t\tStore store = reset();\n\t\t\t// Simulate 100 extensions interacting concurrently with the Store.\n\t\t\tIntStream.range(1, 100).parallel().forEach(j -> store.getOrComputeIfAbsent(\"key\", this::newValue));\n\t\t\tassertEquals(1, count.get(), () -> \"number of times newValue() was invoked in run #\" + i);\n\t\t});\n\t}",
    "comment": "Concurrency tests for {@link NamespaceAwareStore} and {@link NamespacedHierarchicalStore}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(Float expected, float actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Float) actual, messageSupplier);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ConditionEvaluationException.java",
    "type": "method",
    "name": "ConditionEvaluationException",
    "code": "public ConditionEvaluationException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}",
    "comment": "Thrown if an error is encountered while evaluating an\n{@link ExecutionCondition}.\n\n@since 5.0\n@see ConditionEvaluator"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/service-locator/src/main/java/com/iluwatar/servicelocator/ServiceLocator.java",
    "type": "method",
    "name": "getService",
    "code": "public static Service getService(String serviceJndiName) {\n    var serviceObj = serviceCache.getService(serviceJndiName);\n    if (serviceObj == null) {\n      /*\n       * If we are unable to retrieve anything from cache, then lookup the service and add it in the\n       * cache map\n       */\n      var ctx = new InitContext();\n      serviceObj = (Service) ctx.lookup(serviceJndiName);\n      if (serviceObj != null) { // Only cache a service if it actually exists\n        serviceCache.addService(serviceObj);\n      }\n    }\n    return serviceObj;\n  }",
    "comment": "Fetch the service with the name param from the cache first, if no service is found, lookup the\nservice from the {@link InitContext} and then add the newly created service into the cache map\nfor future requests.\n\n@param serviceJndiName a string\n@return {@link Service}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/main/java/org/apache/spark/network/ssl/SSLFactory.java",
    "type": "method",
    "name": "privateKey",
    "code": "public Builder privateKey(File privateKey) {\n      this.privateKey = privateKey;\n      return this;\n    }",
    "comment": "Sets a PKCS#8 private key file in PEM format\n\n@param privateKey The private key file to use\n@return The builder object"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive-thriftserver/src/main/java/org/apache/hive/service/cli/session/HiveSessionImpl.java",
    "type": "method",
    "name": "processCmd",
    "code": "protected int processCmd(String cmd) {\n      int rc = 0;\n      String cmd_trimmed = cmd.trim();\n      try {\n        executeStatementInternal(cmd_trimmed, null, false, 0);\n      } catch (HiveSQLException e) {\n        rc = -1;\n        LOG.warn(\"Failed to execute HQL command in global .hiverc file.\", e);\n      }\n      return rc;\n    }",
    "comment": "It is used for processing hiverc file from HiveServer2 side."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Events.java",
    "type": "method",
    "name": "assertEventsMatchExactly",
    "code": "public final void assertEventsMatchExactly(Condition<? super Event>... conditions) {\n\t\tPreconditions.notNull(conditions, \"conditions must not be null\");\n\t\tassertEventsMatchExactly(this.events, conditions);\n\t}",
    "comment": "Assert that all {@linkplain Event events} contained in this {@code Events}\nobject exactly match the provided conditions.\n\n<p>Conditions can be imported statically from {@link EventConditions}\nand {@link TestExecutionResultConditions}.\n\n<h4>Example</h4>\n\n<pre class=\"code\">\nexecutionResults.testEvents().assertEventsMatchExactly(\nevent(test(\"exampleTestMethod\"), started()),\nevent(test(\"exampleTestMethod\"), finishedSuccessfully())\n);\n</pre>\n\n@param conditions the conditions to match against; never {@code null}\n@see #assertEventsMatchLoosely(Condition...)\n@see #assertEventsMatchLooselyInOrder(Condition...)\n@see EventConditions\n@see TestExecutionResultConditions"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java",
    "type": "method",
    "name": "generateDisplayNameForNestedClass",
    "code": "default String generateDisplayNameForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> nestedClass) {\n\t\treturn generateDisplayNameForNestedClass(nestedClass);\n\t}",
    "comment": "Generate a display name for the given {@link Nested @Nested} inner test\nclass.\n\n<p>If this method returns {@code null}, the default display name\ngenerator will be used instead.\n\n@implNote The classes supplied as {@code enclosingInstanceTypes} may\ndiffer from the classes returned from invocations of\n{@link Class#getEnclosingClass()} &mdash; for example, when a nested test\nclass is inherited from a superclass.\n\n@param enclosingInstanceTypes the runtime types of the enclosing\ninstances for the test class, ordered from outermost to innermost,\nexcluding {@code nestedClass}; never {@code null}\n@param nestedClass the class to generate a name for; never {@code null}\n@return the display name for the nested class; never blank\n@since 5.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeExternalSorter.java",
    "type": "method",
    "name": "freeMemory",
    "code": "private long freeMemory() {\n    List<MemoryBlock> pagesToFree = clearAndGetAllocatedPagesToFree();\n    long memoryFreed = 0;\n    for (MemoryBlock block : pagesToFree) {\n      memoryFreed += block.size();\n      freePage(block);\n    }\n    return memoryFreed;\n  }",
    "comment": "Free this sorter's data pages.\n\n@return the number of bytes freed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/identity-map/src/test/java/com/iluwatar/identitymap/PersonDbSimulatorImplementationTest.java",
    "type": "method",
    "name": "findNotInDb",
    "code": "void findNotInDb() {\n    PersonDbSimulatorImplementation db = new PersonDbSimulatorImplementation();\n    Person person1 = new Person(1, \"Thomas\", 27304159);\n    Person person2 = new Person(2, \"John\", 42273631);\n    db.insert(person1);\n    db.insert(person2);\n    Assertions.assertThrows(IdNotFoundException.class, () -> db.find(3));\n  }",
    "comment": "Test if IdNotFoundException is thrown where expected."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java",
    "type": "method",
    "name": "iteratorWithKeyIndex",
    "code": "public MapIteratorWithKeyIndex iteratorWithKeyIndex() {\n    return new MapIteratorWithKeyIndex();\n  }",
    "comment": "Returns an iterator for iterating over the entries of this map,\nby first iterating over the key index inside hash map's `longArray`.\n\nFor efficiency, all calls to `next()` will return the same {@link Location} object.\n\nThe returned iterator is NOT thread-safe. If the map is modified while iterating over it,\nthe behavior of the returned iterator is undefined."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/env/Logger.java",
    "type": "method",
    "name": "Logger",
    "code": "public Logger(final String messagePrefix) {\n    this(DEFAULT_TAG, messagePrefix);\n  }",
    "comment": "Creates a Logger using the specified message prefix.\n\n@param messagePrefix is prepended to the text of every message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/condition/DisabledIfSystemPropertyIntegrationTests.java",
    "type": "method",
    "name": "setSystemProperties",
    "code": "static void setSystemProperties() {\n\t\tSystem.setProperty(KEY1, ENIGMA);\n\t\tSystem.setProperty(KEY2, ENIGMA);\n\t}",
    "comment": "Integration tests for {@link DisabledIfSystemProperty}.\n\n@since 5.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java",
    "type": "method",
    "name": "randomWithDifferentSeedConsecutively",
    "code": "void randomWithDifferentSeedConsecutively(@TrackLogRecords LogRecordListener listener) {\n\t\tSet<String> uniqueSequences = new HashSet<>();\n\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\tvar seed = String.valueOf(i);\n\t\t\tvar expectedMessage = \"Using custom seed for configuration parameter [\" + Random.RANDOM_SEED_PROPERTY_NAME\n\t\t\t\t\t+ \"] with value [\" + seed + \"].\";\n\t\t\tcallSequence.clear();\n\t\t\tlistener.clear();\n\n\t\t\tvar tests = executeRandomTestCaseInParallelWithRandomSeed(seed);\n\n\t\t\ttests.assertStatistics(stats -> stats.succeeded(callSequence.size()));\n\n\t\t\tuniqueSequences.add(String.join(\",\", callSequence));\n\n\t\t\tassertThat(listener.stream(Random.class, Level.CONFIG)\n\t\t\t\t\t.map(LogRecord::getMessage))\n\t\t\t\t\t.contains(expectedMessage);\n\n\t\t\tassertThat(threadNames).hasSize(i + 1);\n\t\t}\n\n\t\tassertThat(uniqueSequences).size().isGreaterThanOrEqualTo(3);\n\t}",
    "comment": "@formatter:off\n@formatter:on\nWe assume that at least 3 out of 10 are different..."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/FrameworkMember.java",
    "type": "method",
    "name": "handlePossibleBridgeMethod",
    "code": "T handlePossibleBridgeMethod(List<T> members) {\n        for (int i = members.size() - 1; i >=0; i--) {\n            T otherMember = members.get(i);\n            if (isShadowedBy(otherMember)) {\n                if (otherMember.isBridgeMethod()) {\n                    /*\n                     *  We need to return the previously-encountered bridge method\n                     *  because JUnit won't be able to call the parent method,\n                     *  because the parent class isn't public.\n                     */\n                    members.remove(i);\n                    return otherMember;\n                }\n                // We found a shadowed member that isn't a bridge method. Ignore it.\n                return null;\n            }\n        }\n        // No shadow or bridge method found. The caller should add *this* member.\n        FrameworkMember<? extends T> thisMember = this;\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) thisMember;\n\n        return result;\n    }",
    "comment": "Parent class for {@link FrameworkField} and {@link FrameworkMethod}\n\n@since 4.7"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/CameraConnectionFragment.java",
    "type": "method",
    "name": "startBackgroundThread",
    "code": "private void startBackgroundThread() {\n    backgroundThread = new HandlerThread(\"ImageListener\");\n    backgroundThread.start();\n    backgroundHandler = new Handler(backgroundThread.getLooper());\n  }",
    "comment": "Starts a background thread and its {@link Handler}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/logging/AccumulatingLogger.java",
    "type": "method",
    "name": "log",
    "code": "public void log(Level level, String message, Throwable error) {\n        requireNonNull(level, \"level\");\n        requireNonNull(message, \"message\");\n        entries.get().add(new Entry(level, message, error));\n    }",
    "comment": "Early CLI {@link Logger} that simply accumulates log entries until some point a real logger can emit them. This\nlogger is created at start, and it exists while no logging is available yet."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Integer> create(Scope scope, int[][][][][][] data) {\n    return create(scope, data, Integer.class);\n  }",
    "comment": "Creates a rank-6 constant of {@code int} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java",
    "type": "method",
    "name": "descriptionAndRunNotificationsAreConsistent",
    "code": "public void descriptionAndRunNotificationsAreConsistent() {\n        Result result = JUnitCore.runClasses(CompatibilityTest.class);\n        assertEquals(0, result.getIgnoreCount());\n\n        Description description = Request.aClass(CompatibilityTest.class).getRunner().getDescription();\n        assertEquals(0, description.getChildren().size());\n    }",
    "comment": "when executing as JUnit 3, ignored tests are stripped out before execution"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/unsafe/hash/Murmur3_x86_32.java",
    "type": "method",
    "name": "hashUnsafeWords",
    "code": "public static int hashUnsafeWords(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes % 8 == 0): \"lengthInBytes must be a multiple of 8 (word-aligned)\";\n    int h1 = hashBytesByInt(base, offset, lengthInBytes, seed);\n    return fmix(h1, lengthInBytes);\n  }",
    "comment": "This is based on Guava's `Murmur32_Hasher.processRemaining(ByteBuffer)` method."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/FilterResult.java",
    "type": "method",
    "name": "includedIf",
    "code": "public static FilterResult includedIf(boolean included) {\n\t\treturn includedIf(included, () -> null, () -> null);\n\t}",
    "comment": "Factory for creating filter results based on the condition given.\n\n@param included whether or not the filtered object should be included\n@return a valid {@code FilterResult} for the given condition"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertSame",
    "code": "public static void assertSame(Object expected, Object actual) {\n        assertSame(null, expected, actual);\n    }",
    "comment": "Asserts that two objects refer to the same object. If they are not\nthe same an AssertionFailedError is thrown."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/androidTestRoom3/java/com/example/android/persistence/migrations/MigrationTest.java",
    "type": "method",
    "name": "getMigratedRoomDatabase",
    "code": "private UsersDatabase getMigratedRoomDatabase() {\n        UsersDatabase database = Room.databaseBuilder(ApplicationProvider.getApplicationContext(),\n                UsersDatabase.class, TEST_DB_NAME)\n                .addMigrations(MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4, MIGRATION_1_4)\n                .build();\n        // close the database and release any stream resources when the test finishes\n        mMigrationTestHelper.closeWhenFinished(database);\n        return database;\n    }",
    "comment": "Test the migration from different database schema versions to version 4."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/launcher/listeners/UniqueIdTrackingListenerIntegrationTests.java",
    "type": "method",
    "name": "executeTests",
    "code": "private List<String> executeTests(Map<String, String> configurationParameters) {\n\t\treturn executeTests(configurationParameters, selectClasses());\n\t}",
    "comment": "Sanity check using the results of our local TestExecutionListener\nCheck that files were not generated by the UniqueIdTrackingListener\nSanity check using the results of our local TestExecutionListener\nCheck contents of the file (or files) generated by the UniqueIdTrackingListener\n3 output files should have been generated.\nCheck contents of the file (or files) generated by the UniqueIdTrackingListener"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "addSourceRoot",
    "code": "public void addSourceRoot(@Nonnull ProjectScope scope, @Nonnull Language language, @Nonnull String directory) {\n        directory =\n                Objects.requireNonNull(directory, \"directory cannot be null\").trim();\n        if (!directory.isBlank()) {\n            Path path = getBaseDirectory().resolve(directory).normalize();\n            addSourceRoot(scope, language, path);\n        }\n    }",
    "comment": "Resolves and adds the given directory as a source with the given scope and language.\nIf the given directory is null, blank or already in the sources, then this method does nothing.\nOtherwise, the directory is converted to a path, resolved, normalized and finally added as a new\n{@link SourceRoot} element if no source exists for these scope, language and normalized directory.\n\n@param scope scope (main or test) of the directory to add\n@param language language of the files contained in the directory to add\n@param directory the directory to add if not already present in the source, or null\n\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuilderFactory.java",
    "type": "method",
    "name": "newModelProcessor",
    "code": "protected ModelProcessor newModelProcessor() {\n        DefaultModelProcessor processor = new DefaultModelProcessor();\n        processor.setModelLocator(newModelLocator());\n        processor.setModelReader(newModelReader());\n        return processor;\n    }",
    "comment": "A factory to create model builder instances when no dependency injection is available. <em>Note:</em> This class is\nonly meant as a utility for developers that want to employ the model builder outside of the Maven build system, Maven\nplugins should always acquire model builder instances via dependency injection. Developers might want to subclass\nthis factory to provide custom implementations for some of the components used by the model builder.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/reactor/src/main/java/com/iluwatar/reactor/framework/NioServerSocketChannel.java",
    "type": "method",
    "name": "getInterestedOps",
    "code": "public int getInterestedOps() {\n    // being a server socket channel it is interested in accepting connection from remote peers.\n    return SelectionKey.OP_ACCEPT;\n  }",
    "comment": "Creates a {@link ServerSocketChannel} which will bind at provided port and use <code>handler\n</code> to handle incoming events on this channel.\n\n<p>Note the constructor does not bind the socket, {@link #bind()} method should be called for\nbinding the socket.\n\n@param port the port on which channel will be bound to accept incoming connection requests.\n@param handler the handler that will handle incoming requests on this channel.\n@throws IOException if any I/O error occurs."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java",
    "type": "method",
    "name": "registerExtensionsFromConstructorParameters",
    "code": "static void registerExtensionsFromConstructorParameters(ExtensionRegistrar registrar, Class<?> clazz) {\n\t\tregisterExtensionsFromExecutableParameters(registrar, getDeclaredConstructor(clazz));\n\t}",
    "comment": "Register extensions using the supplied registrar from parameters in the\ndeclared constructor of the supplied class that are annotated with\n{@link ExtendWith @ExtendWith}.\n\n@param registrar the registrar with which to register the extensions; never {@code null}\n@param clazz the class in which to find the declared constructor; never {@code null}\n@since 5.8"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/caching/src/main/java/com/iluwatar/caching/LruCache.java",
    "type": "method",
    "name": "setHead",
    "code": "public void setHead(final Node node) {\n    node.next = head;\n    node.previous = null;\n    if (head != null) {\n      head.previous = node;\n    }\n    head = node;\n    if (end == null) {\n      end = head;\n    }\n  }",
    "comment": "Move node to the front of the list.\n\n@param node {@link Node}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/java/test/org/apache/spark/sql/JavaDatasetAggregatorSuite.java",
    "type": "method",
    "name": "testTypedAggregationAnonClass",
    "code": "public void testTypedAggregationAnonClass() {\n    KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset();\n\n    Dataset<Tuple2<String, Integer>> aggregated = grouped.agg(new IntSumOf().toColumn());\n    Assertions.assertEquals(\n        Arrays.asList(new Tuple2<>(\"a\", 3), new Tuple2<>(\"b\", 3)),\n        aggregated.collectAsList());\n\n    Dataset<Tuple2<String, Integer>> aggregated2 = grouped.agg(new IntSumOf().toColumn())\n      .as(Encoders.tuple(Encoders.STRING(), Encoders.INT()));\n    Assertions.assertEquals(\n      Arrays.asList(\n        new Tuple2<>(\"a\", 3),\n        new Tuple2<>(\"b\", 3)),\n      aggregated2.collectAsList());\n  }",
    "comment": "Suite for testing the aggregate functionality of Datasets in Java."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/AnnotationSupport.java",
    "type": "method",
    "name": "findAnnotatedFieldValues",
    "code": "public static List<Object> findAnnotatedFieldValues(Class<?> clazz, Class<? extends Annotation> annotationType) {\n\n\t\tList<Field> fields = findAnnotatedFields(clazz, annotationType, ModifierSupport::isStatic,\n\t\t\tHierarchyTraversalMode.TOP_DOWN);\n\n\t\treturn ReflectionUtils.readFieldValues(fields, null);\n\t}",
    "comment": "Find the values of all static {@linkplain Field fields} of the supplied\nclass or interface that are annotated or <em>meta-annotated</em> with the\nspecified {@code annotationType}, using top-down search semantics within\nthe type hierarchy.\n\n<p>Values from fields declared in the same class or interface will be\nordered using an algorithm that is deterministic but intentionally\nnonobvious.\n\n<p>The results will not contain values from fields that are <em>hidden</em>\nor {@linkplain Field#isSynthetic() synthetic}.\n\n@param clazz the class or interface in which to find the fields; never {@code null}\n@param annotationType the annotation type to search for; never {@code null}\n@return the list of all such field values found; neither {@code null} nor mutable\n@since 1.4\n@see #findAnnotatedFields(Class, Class)\n@see #findAnnotatedFields(Class, Class, Predicate, HierarchyTraversalMode)\n@see ReflectionSupport#findFields(Class, Predicate, HierarchyTraversalMode)\n@see ReflectionSupport#tryToReadFieldValue(Field, Object)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/migrationsupport/conditions/IgnoreConditionTests.java",
    "type": "method",
    "name": "ignoredTestClassWithDefaultMessage",
    "code": "void ignoredTestClassWithDefaultMessage() {\n\t\tClass<?> testClass = IgnoredClassWithDefaultMessageTestCase.class;\n\n\t\t// @formatter:off\n\t\texecuteTestsForClass(testClass).allEvents().assertEventsMatchExactly(\n\t\t\tevent(engine(), started()),\n\t\t\tevent(container(testClass), skippedWithReason(testClass + \" is disabled via @org.junit.Ignore\")),\n\t\t\tevent(engine(), finishedSuccessfully())\n\t\t);\n\t\t// @formatter:on\n\t}",
    "comment": "Integration tests for JUnit 4's {@link Ignore @Ignore} support in JUnit\nJupiter provided by the {@link IgnoreCondition}.\n\n@since 5.4\n@see IgnoreAnnotationIntegrationTests"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/rules/Timeout.java",
    "type": "method",
    "name": "getTimeout",
    "code": "protected final long getTimeout(TimeUnit unit) {\n        return unit.convert(timeout, timeUnit);\n    }",
    "comment": "Gets the timeout configured for this rule, in the given units.\n\n@since 4.12"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/DefaultModelBuildingResult.java",
    "type": "method",
    "name": "setRawModel",
    "code": "public DefaultModelBuildingResult setRawModel(String modelId, Model rawModel) {\n        Objects.requireNonNull(modelId, \"modelId cannot null\");\n\n        rawModels.put(modelId, rawModel);\n\n        return this;\n    }",
    "comment": "Intentionally notNull because Super POM may not contain a modelId"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableChange.java",
    "type": "method",
    "name": "UpdateColumnDefaultValue",
    "code": "private UpdateColumnDefaultValue(String[] fieldNames, String newDefaultValue) {\n      this.fieldNames = fieldNames;\n      this.newDefaultValue = newDefaultValue;\n    }",
    "comment": "A TableChange to update the default value of a field.\n<p>\nThe field names are used to find the field to update.\n<p>\nIf the field does not exist, the change must result in an {@link IllegalArgumentException}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-sourcing/src/main/java/com/iluwatar/event/sourcing/domain/Account.java",
    "type": "method",
    "name": "handleTransferToEvent",
    "code": "public void handleTransferToEvent(MoneyTransferEvent moneyTransferEvent) {\n    handleDeposit(moneyTransferEvent.getMoney(), moneyTransferEvent.isRealTime());\n  }",
    "comment": "Handles transfer to account event.\n\n@param moneyTransferEvent the money transfer event"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/runner/BaseTestRunner.java",
    "type": "method",
    "name": "extractClassName",
    "code": "public String extractClassName(String className) {\n        if (className.startsWith(\"Default package for\")) {\n            return className.substring(className.lastIndexOf(\".\") + 1);\n        }\n        return className;\n    }",
    "comment": "Extract the class name from a String in VA/Java style"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/plugin/testing/stubs/SessionStub.java",
    "type": "method",
    "name": "SessionStub",
    "code": "public SessionStub(Settings settings) {\n        this(null, null, settings);\n    }",
    "comment": "A stub implementation of {@link Session} for basic testing scenarios.\nProvides minimal implementation of session methods without mock dependencies.\n\n<p>For more comprehensive session mocking, consider using {@link SessionMock} instead.</p>\n\n@see SessionMock\n@since 4.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/ParameterResolverTests.java",
    "type": "method",
    "name": "doubleParameterInjection",
    "code": "void doubleParameterInjection(Double number) {\n\t\t\t/* no-op */\n\t\t}",
    "comment": "This test must fail, since {@link Double} is a {@link Number} but not an {@link Integer}.\n@see NumberParameterResolver"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/building/ModelBuildingException.java",
    "type": "method",
    "name": "getModelId",
    "code": "public String getModelId() {\n        if (result == null || result.getModelIds().isEmpty()) {\n            return \"\";\n        }\n        return result.getModelIds().get(0);\n    }",
    "comment": "Gets the identifier of the POM whose effective model could not be built. The general format of the identifier is\n{@code <groupId>:<artifactId>:<version>} but some of these coordinates may still be unknown at the point the\nexception is thrown so this information is merely meant to assist the user.\n\n@return The identifier of the POM or an empty string if not known, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/sketch/src/main/java/org/apache/spark/util/sketch/Murmur3_x86_32.java",
    "type": "method",
    "name": "fmix",
    "code": "private static int fmix(int h1, int length) {\n    h1 ^= length;\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n    return h1;\n  }",
    "comment": "Finalization mix - force all bits of a hash block to avalanche"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaVarianceThresholdSelectorExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaVarianceThresholdSelectorExample\")\n      .getOrCreate();\n\n    // $example on$\n    List<Row> data = Arrays.asList(\n      RowFactory.create(1, Vectors.dense(6.0, 7.0, 0.0, 7.0, 6.0, 0.0)),\n      RowFactory.create(2, Vectors.dense(0.0, 9.0, 6.0, 0.0, 5.0, 9.0)),\n      RowFactory.create(3, Vectors.dense(0.0, 9.0, 3.0, 0.0, 5.0, 5.0)),\n      RowFactory.create(4, Vectors.dense(0.0, 9.0, 8.0, 5.0, 6.0, 4.0)),\n      RowFactory.create(5, Vectors.dense(8.0, 9.0, 6.0, 5.0, 4.0, 4.0)),\n      RowFactory.create(6, Vectors.dense(8.0, 9.0, 6.0, 0.0, 0.0, 0.0))\n    );\n    StructType schema = new StructType(new StructField[]{\n\n    Dataset<Row> df = spark.createDataFrame(data, schema);\n\n    VarianceThresholdSelector selector = new VarianceThresholdSelector()\n      .setVarianceThreshold(8.0)\n      .setFeaturesCol(\"features\")\n      .setOutputCol(\"selectedFeatures\");\n\n    Dataset<Row> result = selector.fit(df).transform(df);\n\n    System.out.println(\"Output: Features with variance lower than \"\n        + selector.getVarianceThreshold() + \" are removed.\");\n    result.show();\n\n    // $example off$\n    spark.stop();\n  }\n}",
    "comment": "An example for VarianceThresholdSelector.\nRun with\n<pre>\nbin/run-example ml.JavaVarianceThresholdSelectorExample\n</pre>"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/hive/src/main/java/org/apache/hadoop/hive/ql/exec/SparkDefaultUDFMethodResolver.java",
    "type": "method",
    "name": "SparkDefaultUDFMethodResolver",
    "code": "public SparkDefaultUDFMethodResolver(DefaultUDFMethodResolver wrapped) {\n    try {\n      Field udfClassField = wrapped.getClass().getDeclaredField(\"udfClass\");\n      udfClassField.setAccessible(true);\n      this.udfClass = (Class<? extends UDF>) udfClassField.get(wrapped);\n    } catch (ReflectiveOperationException rethrow) {\n      throw new RuntimeException(rethrow);\n    }\n  }",
    "comment": "Constructor. This constructor extract udfClass from {@link DefaultUDFMethodResolver}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/services/MessageBuilder.java",
    "type": "method",
    "name": "mojo",
    "code": "default MessageBuilder mojo(Object message) {\n        return style(\".\" + Constants.MAVEN_STYLE_MOJO_NAME + \":-\" + Constants.MAVEN_STYLE_MOJO_DEFAULT, message);\n    }",
    "comment": "Append message content in mojo style.\nBy default, green\n\n@param message the message to append\n@return the current builder"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ModifierSupport.java",
    "type": "method",
    "name": "isFinal",
    "code": "public static boolean isFinal(Member member) {\n\t\treturn ReflectionUtils.isFinal(member);\n\t}",
    "comment": "Determine if the supplied member is {@code final}.\n\n@param member the member to check; never {@code null}\n@return {@code true} if the member is {@code final}\n@since 1.5\n@see java.lang.reflect.Modifier#isFinal(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-configuration/src/main/java/org/apache/maven/plugin/coreit/CustomConfigMojo.java",
    "type": "method",
    "name": "dumpConfiguration",
    "code": "private void dumpConfiguration(Properties props) {\n        /*\n         * NOTE: This intentionally does not dump the absolute path of a file to check the actual value that was\n         * injected by Maven.\n         */\n        PropertiesUtil.serialize(props, \"propertiesFile\", propertiesFile);\n        PropertiesUtil.serialize(props, \"customParam\", customParam);\n        PropertiesUtil.serialize(props, \"defaultParam\", defaultParam);\n        PropertiesUtil.serialize(props, \"stringParam\", stringParam);\n        PropertiesUtil.serialize(props, \"fileParam\", fileParam);\n        PropertiesUtil.serialize(props, \"stringParams\", stringParams);\n        PropertiesUtil.serialize(props, \"fileParams\", fileParams);\n        PropertiesUtil.serialize(props, \"listParam\", listParam);\n        PropertiesUtil.serialize(props, \"setParam\", setParam);\n        PropertiesUtil.serialize(props, \"mapParam\", mapParam);\n        PropertiesUtil.serialize(props, \"propertiesParam\", propertiesParam);\n    }",
    "comment": "Dumps the mojo configuration into the specified properties.\n\n@param props The properties to dump the configuration into, must not be <code>null</code>."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/AbstractLauncher.java",
    "type": "method",
    "name": "setVerbose",
    "code": "public T setVerbose(boolean verbose) {\n    builder.verbose = verbose;\n    return self();\n  }",
    "comment": "Enables verbose reporting for SparkSubmit.\n\n@param verbose Whether to enable verbose output.\n@return This launcher."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileActivationContext.java",
    "type": "method",
    "name": "setSystemProperties",
    "code": "public DefaultProfileActivationContext setSystemProperties(Properties systemProperties) {\n        if (systemProperties != null) {\n            this.systemProperties = Collections.unmodifiableMap((Map) systemProperties);\n        } else {\n            this.systemProperties = Collections.emptyMap();\n        }\n\n        return this;\n    }",
    "comment": "Sets the system properties to use for interpolation and profile activation. The system properties are collected\nfrom the runtime environment like {@link System#getProperties()} and environment variables.\n\n@param systemProperties The system properties, may be {@code null}.\n@return This context, never {@code null}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-support/core-it-plugins/maven-it-plugin-class-loader/dep-a/src/main/java/org/apache/maven/plugin/coreit/ClassA.java",
    "type": "method",
    "name": "methodA",
    "code": "public static String methodA() {\n        return \"A\";\n    }",
    "comment": "A test class that is unique to this artifact.\n\n@author Benjamin Bentmann"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/test/java/org/apache/spark/network/shuffle/RemoteBlockPushResolverSuite.java",
    "type": "method",
    "name": "RemoteBlockPushResolver",
    "code": "RemoteBlockPushResolver pushResolver = new RemoteBlockPushResolver(conf, null) {\n\n      @Override\n      void deleteMergedFiles(\n          AppAttemptShuffleMergeId appAttemptShuffleMergeId,\n          AppShuffleInfo appShuffleInfo,\n          int[] reduceIds,\n          boolean deleteFromDB) {\n        super.deleteMergedFiles(appAttemptShuffleMergeId, appShuffleInfo, reduceIds, deleteFromDB);\n        closed.release();\n      }\n    };",
    "comment": "Test for SPARK-37675 and SPARK-37793\nshufflePush_1_0_0_100 is received by the server\nshuffle 1 0 is finalized\nTest for SPARK-37675 and SPARK-37793\nshufflePush_1_0_0_100 is received by the server\nshuffle 1 0 is finalized\nshufflePush_1_0_0_200 is received by the server after finalization of shuffle 1 0 which\nshould be rejected\nshufflePush_1_0_1_100 is received by the server after finalization of shuffle 1 0 which\nshould also be rejected"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/Logger.java",
    "type": "method",
    "name": "Entry",
    "code": "record Entry(@Nonnull Level level, @Nonnull String message, @Nullable Throwable error) {}",
    "comment": "Logger entries returned by {@link #drain()} method.\n@param level The logging level, never {@code null}.\n@param message The logging message, never {@code null}.\n@param error The error, if applicable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java",
    "type": "method",
    "name": "runBasicParquetExample",
    "code": "private static void runBasicParquetExample(SparkSession spark) {\n    Dataset<Row> peopleDF = spark.read().json(\"examples/src/main/resources/people.json\");\n\n    peopleDF.write().parquet(\"people.parquet\");\n\n    Dataset<Row> parquetFileDF = spark.read().parquet(\"people.parquet\");\n\n    parquetFileDF.createOrReplaceTempView(\"parquetFile\");\n    Dataset<Row> namesDF = spark.sql(\"SELECT name FROM parquetFile WHERE age BETWEEN 13 AND 19\");\n    Dataset<String> namesDS = namesDF.map(\n        (MapFunction<Row, String>) row -> \"Name: \" + row.getString(0),\n        Encoders.STRING());\n    namesDS.show();\n  }",
    "comment": "$example on:basic_parquet_example$\nDataFrames can be saved as Parquet files, maintaining the schema information\nRead in the Parquet file created above.\nParquet files are self-describing so the schema is preserved\nThe result of loading a parquet file is also a DataFrame\nParquet files can also be used to create a temporary view and then used in SQL statements\n+------------+\n|       value|\n+------------+\n|Name: Justin|\n+------------+\n$example off:basic_parquet_example$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java",
    "type": "method",
    "name": "reason",
    "code": "public static Condition<Event> reason(Predicate<String> predicate) {\n\t\treturn new Condition<>(byPayload(String.class, predicate), \"event with custom reason predicate\");\n\t}",
    "comment": "Create a new {@link Condition} that matches if and only if an\n{@link String} that matches the supplied {@link Predicate}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/org/apache/spark/memory/TaskMemoryManagerSuite.java",
    "type": "method",
    "name": "encodePageNumberAndOffsetOffHeap",
    "code": "public void encodePageNumberAndOffsetOffHeap() {\n    final SparkConf conf = new SparkConf()\n      .set(package$.MODULE$.MEMORY_OFFHEAP_ENABLED(), true)\n      .set(package$.MODULE$.MEMORY_OFFHEAP_SIZE(), 1000L);\n    final TaskMemoryManager manager = new TaskMemoryManager(new TestMemoryManager(conf), 0);\n    final MemoryConsumer c = new TestMemoryConsumer(manager, MemoryMode.OFF_HEAP);\n    final MemoryBlock dataPage = manager.allocatePage(256, c);\n    final long offset = ((1L << TaskMemoryManager.OFFSET_BITS) + 10);\n    final long encodedAddress = manager.encodePageNumberAndOffset(dataPage, offset);\n    Assertions.assertNull(manager.getPage(encodedAddress));\n    Assertions.assertEquals(offset, manager.getOffsetInPage(encodedAddress));\n    manager.freePage(dataPage, c);\n  }",
    "comment": "In off-heap mode, an offset is an absolute address that may require more than 51 bits to\nencode. This test exercises that corner-case:"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-logging/src/main/java/org/apache/maven/slf4j/MavenFailOnSeverityLogger.java",
    "type": "method",
    "name": "warn",
    "code": "public void warn(String format, Object arg1, Object arg2) {\n        super.warn(format, arg1, arg2);\n        logLevelRecorder.record(Level.WARN);\n    }",
    "comment": "Perform double parameter substitution before logging the message of level\nWARN according to the format outlined above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-plugin-api/src/main/java/org/apache/maven/plugin/MojoExecutionException.java",
    "type": "method",
    "name": "MojoExecutionException",
    "code": "public MojoExecutionException(String message, Throwable cause) {\n        super(message, cause);\n    }",
    "comment": "Construct a new <code>MojoExecutionException</code> exception wrapping an underlying <code>Throwable</code>\nand providing a <code>message</code>.\n\n@param message\n@param cause"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/mllib/src/test/java/org/apache/spark/mllib/regression/JavaLassoSuite.java",
    "type": "method",
    "name": "validatePrediction",
    "code": "int validatePrediction(List<LabeledPoint> validationData, LassoModel model) {\n    int numAccurate = 0;\n    for (LabeledPoint point : validationData) {\n      Double prediction = model.predict(point.features());\n      if (Math.abs(prediction - point.label()) <= 0.5) {\n        numAccurate++;\n      }\n    }\n    return numAccurate;\n  }",
    "comment": "A prediction is off if the prediction is more than 0.5 away from expected value."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/SparkSubmitCommandBuilder.java",
    "type": "method",
    "name": "isConnectServer",
    "code": "private boolean isConnectServer(String mainClass) {\n    return (mainClass != null &&\n      mainClass.equals(\"org.apache.spark.sql.connect.service.SparkConnectServer\"));\n  }",
    "comment": "Return whether the given main class represents a connect server."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-testing/src/main/java/org/apache/maven/api/di/testing/MavenDIExtension.java",
    "type": "method",
    "name": "getTestPath",
    "code": "public static String getTestPath(String basedir, String path) {\n        return getTestFile(basedir, path).getAbsolutePath();\n    }",
    "comment": "Returns the absolute path for a path relative to a specified base directory.\n\n@param basedir The base directory path\n@param path The relative path\n@return The absolute path"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-executor/src/main/java/org/apache/maven/cling/executor/embedded/EmbeddedMavenExecutor.java",
    "type": "method",
    "name": "disposeRuntimeCreatedRealms",
    "code": "protected void disposeRuntimeCreatedRealms(Context context) {\n        try {\n            Method getRealms = context.classWorld.getClass().getMethod(\"getRealms\");\n            Method disposeRealm = context.classWorld.getClass().getMethod(\"disposeRealm\", String.class);\n            List<Object> realms = (List<Object>) getRealms.invoke(context.classWorld);\n            for (Object realm : realms) {\n                String realmId = (String) realm.getClass().getMethod(\"getId\").invoke(realm);\n                if (!context.originalClassRealmIds.contains(realmId)) {\n                    disposeRealm.invoke(context.classWorld, realmId);\n                }\n            }\n        } catch (Exception e) {\n            throw new ExecutorException(\"Failed to dispose runtime created realms\", e);\n        }\n    }",
    "comment": "Unloads dynamically loaded things, like extensions created realms. Makes sure we go back to \"initial state\"."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedTestContextTests.java",
    "type": "method",
    "name": "validSignatures",
    "code": "void validSignatures(String methodName) {\n\t\tassertDoesNotThrow(() -> createMethodContext(ValidTestCase.class, methodName));\n\t}",
    "comment": "Unit tests for {@link ParameterizedTestContext}.\n\n@since 5.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java",
    "type": "method",
    "name": "getSentenceBeginning",
    "code": "private String getSentenceBeginning(Class<?> testClass, List<Class<?>> enclosingInstanceTypes) {\n\t\t\tClass<?> enclosingClass = enclosingInstanceTypes.isEmpty() ? null\n\t\t\t\t\t: enclosingInstanceTypes.get(enclosingInstanceTypes.size() - 1);\n\t\t\tboolean topLevelTestClass = (enclosingClass == null || isStatic(testClass));\n\n\t\t\tString sentenceFragment = findAnnotation(testClass, DisplayName.class)//\n\t\t\t\t\t.map(DisplayName::value)//\n\t\t\t\t\t.map(String::trim)//\n\t\t\t\t\t.orElseGet(() -> getSentenceFragment(testClass));\n\n\t\t\tif (topLevelTestClass) {\n\t\t\t\tif (sentenceFragment != null) {\n\t\t\t\t\treturn sentenceFragment;\n\t\t\t\t}\n\t\t\t\tClass<? extends DisplayNameGenerator> generatorClass = findDisplayNameGeneration(testClass,\n\t\t\t\t\tenclosingInstanceTypes)//\n\t\t\t\t\t\t\t.map(DisplayNameGeneration::value)//\n\t\t\t\t\t\t\t.filter(notIndicativeSentences)//\n\t\t\t\t\t\t\t.orElse(null);\n\t\t\t\tif (generatorClass != null) {\n\t\t\t\t\treturn getDisplayNameGenerator(generatorClass).generateDisplayNameForClass(testClass);\n\t\t\t\t}\n\t\t\t\treturn generateDisplayNameForClass(testClass);\n\t\t\t}\n\n\t\t\tList<Class<?>> remainingEnclosingInstanceTypes = enclosingInstanceTypes.isEmpty() ? emptyList()\n\t\t\t\t\t: enclosingInstanceTypes.subList(0, enclosingInstanceTypes.size() - 1);\n\n\t\t\tboolean buildPrefix = findDisplayNameGeneration(enclosingClass, remainingEnclosingInstanceTypes)//\n\t\t\t\t\t.map(DisplayNameGeneration::value)//\n\t\t\t\t\t.filter(IndicativeSentences.class::equals)//\n\t\t\t\t\t.isPresent();\n\n\t\t\tString prefix = (buildPrefix\n\t\t\t\t\t? getSentenceBeginning(enclosingClass, remainingEnclosingInstanceTypes)\n\t\t\t\t\t\t\t+ getFragmentSeparator(testClass, enclosingInstanceTypes)\n\t\t\t\t\t: \"\");\n\n\t\t\treturn prefix + (sentenceFragment != null ? sentenceFragment\n\t\t\t\t\t: getGeneratorFor(testClass, enclosingInstanceTypes).generateDisplayNameForNestedClass(\n\t\t\t\t\t\tremainingEnclosingInstanceTypes, testClass));\n\t\t}",
    "comment": "Only build prefix based on the enclosing class if the enclosing\nclass is also configured to use the IndicativeSentences generator."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/write/WriteBuilder.java",
    "type": "method",
    "name": "buildForStreaming",
    "code": "default StreamingWrite buildForStreaming() {\n    throw new SparkUnsupportedOperationException(\n      \"_LEGACY_ERROR_TEMP_3136\", Map.of(\"class\", getClass().getName()));\n  }",
    "comment": "Returns a {@link StreamingWrite} to write data to streaming source.\n\n@deprecated use {@link #build()} instead."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/jupiter-tests/src/test/java/org/junit/jupiter/api/AssertTimeoutPreemptivelyAssertionsTests.java",
    "type": "method",
    "name": "assertTimeoutPreemptivelyForExecutableThatCompletesBeforeTheTimeout",
    "code": "void assertTimeoutPreemptivelyForExecutableThatCompletesBeforeTheTimeout() {\n\t\tchanged.get().set(false);\n\t\tassertTimeoutPreemptively(ofMillis(500), () -> changed.get().set(true));\n\t\tassertFalse(changed.get().get(), \"should have executed in a different thread\");\n\t\tassertTimeoutPreemptively(ofMillis(500), nix, \"message\");\n\t\tassertTimeoutPreemptively(ofMillis(500), nix, () -> \"message\");\n\t}",
    "comment": "Unit tests for {@link AssertTimeoutPreemptively}.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/FileSystemSourceTests.java",
    "type": "method",
    "name": "createSerializableInstances",
    "code": "Stream<FileSource> createSerializableInstances() {\n\t\treturn Stream.of( //\n\t\t\tFileSource.from(new File(\"file.source\")), //\n\t\t\tFileSource.from(new File(\"file.and.position\"), FilePosition.from(42, 23)));\n\t}",
    "comment": "Unit tests for {@link FileSource} and {@link DirectorySource}.\n\n@since 1.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/OneForOneBlockPusher.java",
    "type": "method",
    "name": "start",
    "code": "public void start() {\n    logger.debug(\"Start pushing {} blocks\", blockIds.length);\n    for (int i = 0; i < blockIds.length; i++) {\n      assert buffers.containsKey(blockIds[i]) : \"Could not find the block buffer for block \"\n        + blockIds[i];\n      String[] blockIdParts = blockIds[i].split(\"_\");\n      if (blockIdParts.length != 5 || !blockIdParts[0].equals(SHUFFLE_PUSH_BLOCK_PREFIX)) {\n        throw new IllegalArgumentException(\n          \"Unexpected shuffle push block id format: \" + blockIds[i]);\n      }\n      ByteBuffer header =\n        new PushBlockStream(appId, appAttemptId, Integer.parseInt(blockIdParts[1]),\n          Integer.parseInt(blockIdParts[2]), Integer.parseInt(blockIdParts[3]),\n            Integer.parseInt(blockIdParts[4]), i).toByteBuffer();\n      client.uploadStream(new NioManagedBuffer(header), buffers.get(blockIds[i]),\n        new BlockPushCallback(i, blockIds[i]));\n    }\n  }",
    "comment": "Begins the block pushing process, calling the listener with every block pushed."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/platform-tests/src/test/java/org/junit/platform/launcher/core/LauncherFactoryTests.java",
    "type": "method",
    "name": "withTestServices",
    "code": "private static void withTestServices(Runnable runnable) {\n\t\tvar current = Thread.currentThread().getContextClassLoader();\n\t\tvar url = LauncherFactoryTests.class.getClassLoader().getResource(\"testservices/\");\n\t\ttry (var classLoader = new URLClassLoader(new URL[] { url }, current)) {\n\t\tcatch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t\tfinally {\n\t\t\tThread.currentThread().setContextClassLoader(current);\n\t\t}\n\t}\n\n\tprivate LauncherDiscoveryRequest createLauncherDiscoveryRequestForBothStandardEngineExampleClasses() {\n\t\treturn request()\n\t\t\t\t.selectors(selectClass(JUnit4Example.class))\n\t\t\t\t.selectors(selectClass(JUnit5Example.class))\n\t\t\t\t.build();\n\t}\n\n\t@SuppressWarnings({ \"NewClassNamingConvention\", \"JUnitMalformedDeclaration\" })\n\tpublic static class JUnit4Example {\n\n\t\t@org.junit.Test\n\t\tpublic void testJ4() {\n\t\t}\n\n\t}\n\n\t@SuppressWarnings({ \"NewClassNamingConvention\", \"JUnitMalformedDeclaration\" })\n\tstatic class JUnit5Example {\n\n\t\t@Tag(\"test-post-discovery\")\n\t\t@Test\n\t\tvoid testJ5() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"JUnitMalformedDeclaration\")\n\t@ExtendWith(SessionTrackingExtension.class)\n\tstatic class SessionTrackingTestCase {\n\n\t\t@Test\n\t\tvoid dummyTest() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"JUnitMalformedDeclaration\")\n\t@ExtendWith(SessionStoringExtension.class)\n\tstatic class SessionStoringTestCase {\n\n\t\t@Test\n\t\tvoid dummyTest() {\n\t\t}\n\t}\n\n\tstatic class LauncherSessionListenerOpenedExample implements LauncherSessionListener {\n\t\t@Override\n\t\tpublic void launcherSessionOpened(LauncherSession session) {\n\t\t\tsession.getStore().put(Namespace.GLOBAL, \"testKey\", \"testValue\");\n\t\t}\n\t}\n\n\tstatic class LauncherSessionListenerClosedExample implements LauncherSessionListener {\n\t\t@Override\n\t\tpublic void launcherSessionClosed(LauncherSession session) {\n\t\t\tObject storedValue = session.getStore().get(Namespace.GLOBAL, \"testKey\");\n\t\t\tassertThat(storedValue).isEqualTo(\"testValue\");\n\t\t}\n\t}\n\n\tstatic class SessionTrackingExtension implements BeforeAllCallback {\n\t\t@Override\n\t\tpublic void beforeAll(ExtensionContext context) {\n\t\t\tvar value = context.getStore(ExtensionContext.Namespace.GLOBAL).get(\"testKey\");\n\t\t\tif (!\"testValue\".equals(value)) {\n\t\t\t\tthrow new IllegalStateException(\"Expected 'testValue' but got: \" + value);\n\t\t\t}\n\n\t\t\tvalue = context.getStore(StoreScope.LAUNCHER_SESSION, ExtensionContext.Namespace.GLOBAL).get(\"testKey\");\n\t\t\tif (!\"testValue\".equals(value)) {\n\t\t\t\tthrow new IllegalStateException(\"Expected 'testValue' but got: \" + value);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class SessionStoringExtension implements BeforeAllCallback {\n\t\t@Override\n\t\tpublic void beforeAll(ExtensionContext context) {\n\t\t\tcontext.getStore(StoreScope.LAUNCHER_SESSION, ExtensionContext.Namespace.GLOBAL).put(\"testKey\",\n\t\t\t\t\"testValue\");\n\t\t}\n\t}\n\n\tprivate static class CloseTrackingResource implements AutoCloseable {\n\t\tprivate static boolean closed = false;\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\tclosed = true;\n\t\t}\n\n\t\tpublic boolean isClosed() {\n\t\t\treturn closed;\n\t\t}\n\t}\n\n\tprivate static class SessionResourceStoreUsingExtension implements BeforeAllCallback {\n\t\t@Override\n\t\tpublic void beforeAll(ExtensionContext context) {\n\t\t\tCloseTrackingResource sessionResource = new CloseTrackingResource();\n\t\t\tcontext.getStore(StoreScope.LAUNCHER_SESSION, ExtensionContext.Namespace.GLOBAL).put(\"sessionResource\",\n\t\t\t\tsessionResource);\n\t\t}\n\t}\n\n\tprivate static class RequestResourceStoreUsingExtension implements BeforeAllCallback {\n\t\t@Override\n\t\tpublic void beforeAll(ExtensionContext context) {\n\t\t\tCloseTrackingResource requestResource = new CloseTrackingResource();\n\t\t\tcontext.getStore(StoreScope.EXECUTION_REQUEST, ExtensionContext.Namespace.GLOBAL).put(\"requestResource\",\n\t\t\t\trequestResource);\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"JUnitMalformedDeclaration\")\n\t@ExtendWith(SessionResourceStoreUsingExtension.class)\n\tstatic class SessionResourceAutoCloseTestCase {\n\n\t\t@Test\n\t\tvoid dummyTest() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"JUnitMalformedDeclaration\")\n\t@ExtendWith(RequestResourceStoreUsingExtension.class)\n\tstatic class RequestResourceAutoCloseTestCase {\n\n\t\t@Test\n\t\tvoid dummyTest() {\n\t\t}\n\t}\n\n\tprivate static class AutoCloseCheckListener implements LauncherSessionListener {\n\t\t@Override\n\t\tpublic void launcherSessionClosed(LauncherSession session) {\n\t\t\tCloseTrackingResource sessionResource = session //\n\t\t\t\t\t.getStore() //\n\t\t\t\t\t.get(Namespace.GLOBAL, \"sessionResource\", CloseTrackingResource.class);\n\n\t\t\tassertThat(sessionResource.isClosed()).isFalse();\n\t\t}\n\t}\n}",
    "comment": "@formatter:off\n@formatter:on\nJust a placeholder to trigger the extension\nJust a placeholder to trigger the extension\nJust a placeholder to trigger the extension\nJust a placeholder to trigger the extension"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/test/java/org/apache/spark/launcher/CommandBuilderUtilsSuite.java",
    "type": "method",
    "name": "testValidOptionStrings",
    "code": "public void testValidOptionStrings() {\n    testOpt(\"a b c d e\", Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"));\n    testOpt(\"a 'b c' \\\"d\\\" e\", Arrays.asList(\"a\", \"b c\", \"d\", \"e\"));\n    testOpt(\"a 'b\\\\\\\"c' \\\"'d'\\\" e\", Arrays.asList(\"a\", \"b\\\\\\\"c\", \"'d'\", \"e\"));\n    testOpt(\"a 'b\\\"c' \\\"\\\\\\\"d\\\\\\\"\\\" e\", Arrays.asList(\"a\", \"b\\\"c\", \"\\\"d\\\"\", \"e\"));\n    testOpt(\" a b c \\\\\\\\ \", Arrays.asList(\"a\", \"b\", \"c\", \"\\\\\"));\n\n    testOpt(\"\", new ArrayList<>());\n    testOpt(\"a\", Arrays.asList(\"a\"));\n    testOpt(\"aaa\", Arrays.asList(\"aaa\"));\n    testOpt(\"a b c\", Arrays.asList(\"a\", \"b\", \"c\"));\n    testOpt(\"  a   b\\t c \", Arrays.asList(\"a\", \"b\", \"c\"));\n    testOpt(\"a 'b c'\", Arrays.asList(\"a\", \"b c\"));\n    testOpt(\"a 'b c' d\", Arrays.asList(\"a\", \"b c\", \"d\"));\n    testOpt(\"'b c'\", Arrays.asList(\"b c\"));\n    testOpt(\"a \\\"b c\\\"\", Arrays.asList(\"a\", \"b c\"));\n    testOpt(\"a \\\"b c\\\" d\", Arrays.asList(\"a\", \"b c\", \"d\"));\n    testOpt(\"\\\"b c\\\"\", Arrays.asList(\"b c\"));\n    testOpt(\"a 'b\\\" c' \\\"d' e\\\"\", Arrays.asList(\"a\", \"b\\\" c\", \"d' e\"));\n    testOpt(\"a\\t'b\\nc'\\nd\", Arrays.asList(\"a\", \"b\\nc\", \"d\"));\n    testOpt(\"a \\\"b\\\\\\\\c\\\"\", Arrays.asList(\"a\", \"b\\\\c\"));\n    testOpt(\"a \\\"b\\\\\\\"c\\\"\", Arrays.asList(\"a\", \"b\\\"c\"));\n    testOpt(\"a 'b\\\\\\\"c'\", Arrays.asList(\"a\", \"b\\\\\\\"c\"));\n    testOpt(\"'a'b\", Arrays.asList(\"ab\"));\n    testOpt(\"'a''b'\", Arrays.asList(\"ab\"));\n    testOpt(\"\\\"a\\\"b\", Arrays.asList(\"ab\"));\n    testOpt(\"\\\"a\\\"\\\"b\\\"\", Arrays.asList(\"ab\"));\n    testOpt(\"''\", Arrays.asList(\"\"));\n    testOpt(\"\\\"\\\"\", Arrays.asList(\"\"));\n  }",
    "comment": "Following tests ported from UtilsSuite.scala."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/kvstore/src/test/java/org/apache/spark/util/kvstore/DBIteratorSuite.java",
    "type": "method",
    "name": "setupClass",
    "code": "public static void setupClass() {\n    long seed = RND.nextLong();\n    LOG.info(\"Random seed: {}\", seed);\n    RND.setSeed(seed);\n  }",
    "comment": "Implementations should override this method; it is called only once, before all tests are\nrun. Any state can be safely stored in static variables and cleaned up in a @AfterAll\nhandler."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/datasources/parquet/VectorizedRleValuesReader.java",
    "type": "method",
    "name": "if",
    "code": "ParquetVectorUpdater updater) {\n\n    long rowId = state.rowId;\n    int leftInBatch = state.rowsToReadInBatch;\n    int leftInPage = state.valuesToReadInPage;\n\n    while (leftInBatch > 0 && leftInPage > 0) {\n      if (currentCount == 0 && !readNextGroup()) break;\n      int n = Math.min(leftInBatch, Math.min(leftInPage, this.currentCount));\n\n      long rangeStart = state.currentRangeStart();\n      long rangeEnd = state.currentRangeEnd();\n\n      if (rowId + n < rangeStart) {\n        skipValues(n, state, valueReader, updater);\n        rowId += n;\n        leftInPage -= n;\n      } else if (rowId > rangeEnd) {\n        state.nextRange();\n      } else {\n        long start = Math.max(rangeStart, rowId);\n        long end = Math.min(rangeEnd, rowId + n - 1);\n\n        int toSkip = (int) (start - rowId);\n        if (toSkip > 0) {\n          skipValues(toSkip, state, valueReader, updater);\n          rowId += toSkip;\n          leftInPage -= toSkip;\n        }\n\n        n = (int) (end - start + 1);\n\n        switch (mode) {\n          case RLE -> {\n            if (currentValue == state.maxDefinitionLevel) {\n              updater.readValues(n, state.valueOffset, values, valueReader);\n            } else {\n              nulls.putNulls(state.valueOffset, n);\n            }\n            state.valueOffset += n;\n          }\n          case PACKED -> {\n            for (int i = 0; i < n; ++i) {\n              int currentValue = currentBuffer[currentBufferIdx++];\n              if (currentValue == state.maxDefinitionLevel) {\n                updater.readValue(state.valueOffset++, values, valueReader);\n              } else {\n                nulls.putNull(state.valueOffset++);\n              }\n            }\n          }\n        }\n        state.levelOffset += n;\n        leftInBatch -= n;\n        rowId += n;\n        leftInPage -= n;\n        currentCount -= n;\n      }\n    }\n\n    state.rowsToReadInBatch = leftInBatch;\n    state.valuesToReadInPage = leftInPage;\n    state.rowId = rowId;\n  }",
    "comment": "The range [rowId, rowId + n) overlaps with the current row range in state\nSkip the part [rowId, start)\nRead the part [start, end]"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/Executions.java",
    "type": "method",
    "name": "succeeded",
    "code": "public Executions succeeded() {\n\t\treturn new Executions(finishedExecutionsByStatus(Status.SUCCESSFUL), this.category + \" Successful\");\n\t}",
    "comment": "Get the succeeded {@link Executions} contained in this {@code Executions} object.\n\n@return the filtered {@code Executions}; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertThrows",
    "code": "public static <T extends Throwable> T assertThrows(Class<T> expectedType, Executable executable) {\n\t\treturn AssertThrows.assertThrows(expectedType, executable);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code executable} throws\nan exception of the {@code expectedType} and return the exception.\n\n<p>The assertion passes if the thrown exception type is the same as\n{@code expectedType} or a subtype thereof. To check for the exact thrown\ntype use {@link #assertThrowsExactly(Class, Executable) assertThrowsExactly}.\nIf no exception is thrown, or if an exception of a different type is thrown,\nthis method will fail.\n\n<p>If you do not want to perform additional checks on the exception instance,\nignore the return value.\n\n@see #assertThrowsExactly(Class, Executable)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestReporter.java",
    "type": "method",
    "name": "publishEntry",
    "code": "default void publishEntry(String value) {\n\t\tthis.publishEntry(\"value\", value);\n\t}",
    "comment": "Publish the supplied value as a <em>report entry</em>.\n\n<p>This method delegates to {@link #publishEntry(String, String)},\nsupplying {@code \"value\"} as the key and the supplied {@code value}\nargument as the value.\n\n@param value the value to be published; never {@code null} or blank\n@since 5.3\n@see #publishEntry(Map)\n@see #publishEntry(String, String)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/connector/catalog/TableInfo.java",
    "type": "method",
    "name": "TableInfo",
    "code": "private TableInfo(Builder builder) {\n    this.columns = builder.columns;\n    this.properties = builder.properties;\n    this.partitions = builder.partitions;\n    this.constraints = builder.constraints;\n  }",
    "comment": "Constructor for TableInfo used by the builder.\n@param builder Builder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeExternalSorter.java",
    "type": "method",
    "name": "acquireNewPageIfNecessary",
    "code": "private void acquireNewPageIfNecessary(int required) {\n    if (currentPage == null ||\n      pageCursor + required > currentPage.getBaseOffset() + currentPage.size()) {\n      // TODO: try to find space on previous pages\n      currentPage = allocatePage(required);\n      pageCursor = currentPage.getBaseOffset();\n      allocatedPages.add(currentPage);\n    }\n  }",
    "comment": "Allocates an additional page in order to insert an additional record. This will request\nadditional memory from the memory manager and spill if the requested memory can not be\nobtained.\n\n@param required the required space in the data page, in bytes, including space for storing\nthe record size."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/ReactorReader.java",
    "type": "method",
    "name": "isPackagedArtifactUpToDate",
    "code": "private boolean isPackagedArtifactUpToDate(MavenProject project, File packagedArtifactFile) {\n        Path outputDirectory = Paths.get(project.getBuild().getOutputDirectory());\n        if (!outputDirectory.toFile().exists()) {\n            return true;\n        }\n\n        try (Stream<Path> outputFiles = Files.walk(outputDirectory)) {\n            long artifactLastModified =\n                    Files.getLastModifiedTime(packagedArtifactFile.toPath()).toMillis();\n\n            if (session.getProjectBuildingRequest().getBuildStartTime() != null) {\n                long buildStartTime =\n                        session.getProjectBuildingRequest().getBuildStartTime().getTime();\n                if (artifactLastModified > buildStartTime) {\n                    return true;\n                }\n            }\n\n            for (Path outputFile : (Iterable<Path>) outputFiles::iterator) {\n                if (Files.isDirectory(outputFile)) {\n                    continue;\n                }\n\n                long outputFileLastModified =\n                        Files.getLastModifiedTime(outputFile).toMillis();\n                if (outputFileLastModified > artifactLastModified) {\n                    LOGGER.warn(\n                            \"File '{}' is more recent than the packaged artifact for '{}', \"\n                                    + \"please run a full `mvn package` build\",\n                            relativizeOutputFile(outputFile),\n                            project.getArtifactId());\n                    return true;\n                }\n            }\n\n            return true;\n        } catch (IOException e) {\n            LOGGER.warn(\n                    \"An I/O error occurred while checking if the packaged artifact is up-to-date \"\n                            + \"against the build output directory. \"\n                            + \"Continuing with the assumption that it is up-to-date.\",\n                    e);\n            return true;\n        }\n    }",
    "comment": "Not using File#lastModified() to avoid a Linux JDK8 milliseconds precision bug: JDK-8177809."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/test/gen-java/org/apache/spark/sql/execution/datasources/parquet/test/avro/AvroOptionalPrimitives.java",
    "type": "method",
    "name": "setMaybeLongColumn",
    "code": "public void setMaybeLongColumn(java.lang.Long value) {\n    this.maybe_long_column = value;\n  }",
    "comment": "Sets the value of the 'maybe_long_column' field.\n@param value the value to set."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-impl/src/main/java/org/apache/maven/impl/DefaultSuperPomProvider.java",
    "type": "method",
    "name": "DefaultSuperPomProvider",
    "code": "public DefaultSuperPomProvider(ModelProcessor modelProcessor) {\n        this.modelProcessor = modelProcessor;\n    }",
    "comment": "The cached super POM, lazily created."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/src/test/java/org/tensorflow/lite/TensorFlowLiteInvalidNativeLibTest.java",
    "type": "method",
    "name": "testInit",
    "code": "public void testInit() {\n    try {\n      TensorFlowLite.init();\n      fail();\n    } catch (UnsatisfiedLinkError e) {\n      assertThat(e).hasMessageThat().contains(\"Failed to load native TensorFlow Lite methods\");\n    }\n  }",
    "comment": "Tests for {@link org.tensorflow.lite.TensorFlowLite} when the native lib is loaded but the\nnecessary native methods are unavailable."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/listeners/UniqueIdTrackingListener.java",
    "type": "method",
    "name": "testPlanExecutionFinished",
    "code": "public void testPlanExecutionFinished(TestPlan testPlan) {\n\t\tif (this.enabled) {\n\t\t\tPath outputFile;\n\t\t\ttry {\n\t\t\t\toutputFile = createOutputFile(testPlan.getConfigurationParameters());\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.error(ex, () -> \"Failed to create output file\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(() -> \"Writing unique IDs to output file \" + outputFile.toAbsolutePath());\n\t\t\ttry (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(outputFile, StandardCharsets.UTF_8))) {\n\t\t\tcatch (IOException ex) {\n\t\t\t\tlogger.error(ex, () -> \"Failed to write unique IDs to output file \" + outputFile.toAbsolutePath());\n\t\t\t}\n\t\t}\n\t\tthis.testPlan = null;\n\t}\n\n\tprivate Path createOutputFile(ConfigurationParameters configurationParameters) {\n\t\tString prefix = configurationParameters.get(OUTPUT_FILE_PREFIX_PROPERTY_NAME) //\n\t\t\t\t.orElse(DEFAULT_OUTPUT_FILE_PREFIX);\n\t\tSupplier<Path> workingDirSupplier = () -> configurationParameters.get(WORKING_DIR_PROPERTY_NAME).map(\n\t\t\tPaths::get).orElseGet(() -> Paths.get(\".\"));\n\t\treturn OutputDir.create(configurationParameters.get(OUTPUT_DIR_PROPERTY_NAME), workingDirSupplier) //\n\t\t\t\t.createFile(prefix, \"txt\");\n\t}\n\n}",
    "comment": "Abort since we cannot generate the file."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/DetectorActivity.java",
    "type": "method",
    "name": "processImage",
    "code": "protected void processImage() {\n    ++timestamp;\n    final long currTimestamp = timestamp;\n    byte[] originalLuminance = getLuminance();\n    tracker.onFrame(\n        previewWidth,\n        previewHeight,\n        getLuminanceStride(),\n        sensorOrientation,\n        originalLuminance,\n        timestamp);\n    trackingOverlay.postInvalidate();\n\n    if (computingDetection) {\n      readyForNextImage();\n      return;\n    }\n    computingDetection = true;\n    LOGGER.i(\"Preparing image \" + currTimestamp + \" for detection in bg thread.\");\n\n    rgbFrameBitmap.setPixels(getRgbBytes(), 0, previewWidth, 0, 0, previewWidth, previewHeight);\n\n    if (luminanceCopy == null) {\n      luminanceCopy = new byte[originalLuminance.length];\n    }\n    System.arraycopy(originalLuminance, 0, luminanceCopy, 0, originalLuminance.length);\n    readyForNextImage();\n\n    final Canvas canvas = new Canvas(croppedBitmap);\n    canvas.drawBitmap(rgbFrameBitmap, frameToCropTransform, null);\n    if (SAVE_PREVIEW_BITMAP) {\n      ImageUtils.saveBitmap(croppedBitmap);\n    }\n\n    runInBackground(\n        new Runnable() {\n\n            final List<Classifier.Recognition> mappedRecognitions =\n                new LinkedList<Classifier.Recognition>();\n\n            for (final Classifier.Recognition result : results) {\n              final RectF location = result.getLocation();\n              if (location != null && result.getConfidence() >= minimumConfidence) {\n                canvas.drawRect(location, paint);\n\n                cropToFrameTransform.mapRect(location);\n                result.setLocation(location);\n                mappedRecognitions.add(result);\n              }\n            }\n\n            tracker.trackResults(mappedRecognitions, luminanceCopy, currTimestamp);\n            trackingOverlay.postInvalidate();\n\n            requestRender();\n            computingDetection = false;\n          }\n        });",
    "comment": "No mutex needed as this method is not reentrant.\nFor examining the actual TF input."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "validateAndGetAppShuffleInfo",
    "code": "protected AppShuffleInfo validateAndGetAppShuffleInfo(String appId) {\n    AppShuffleInfo appShuffleInfo = appsShuffleInfo.get(appId);\n    Preconditions.checkArgument(appShuffleInfo != null,\n      \"application \" + appId + \" is not registered or NM was restarted.\");\n    return appShuffleInfo;\n  }",
    "comment": "TODO: [SPARK-33236] Change the message when this service is able to handle NM restart"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/unsafe/src/main/java/org/apache/spark/sql/catalyst/util/CollationAwareUTF8String.java",
    "type": "method",
    "name": "toTitleCase",
    "code": "public static UTF8String toTitleCase(final UTF8String target, final int collationId) {\n    ULocale locale = CollationFactory.fetchCollation(collationId)\n      .getCollator().getLocale(ULocale.ACTUAL_LOCALE);\n    return UTF8String.fromString(UCharacter.toTitleCase(locale, target.toValidString(),\n      BreakIterator.getWordInstance(locale)));\n  }",
    "comment": "Convert the input string to titlecase using the specified ICU collation rules."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/factory-kit/src/test/java/com/iluwatar/factorykit/factorykit/FactoryKitTest.java",
    "type": "method",
    "name": "verifyWeapon",
    "code": "private void verifyWeapon(Weapon weapon, Class<?> clazz) {\n    assertTrue(clazz.isInstance(weapon), \"Weapon must be an object of: \" + clazz.getName());\n  }",
    "comment": "This method asserts that the weapon object that is passed is an instance of the clazz\n\n@param weapon weapon object which is to be verified\n@param clazz expected class of the weapon"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/junit/framework/Assert.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(String message, int expected, int actual) {\n        assertEquals(message, Integer.valueOf(expected), Integer.valueOf(actual));\n    }",
    "comment": "Asserts that two ints are equal. If they are not\nan AssertionFailedError is thrown with the given message."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/TestListenerTest.java",
    "type": "method",
    "name": "addError",
    "code": "public void addError(Test test, Throwable e) {\n        fErrorCount++;\n    }",
    "comment": "Test class used in SuiteTest"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/extension/internal/CoreExports.java",
    "type": "method",
    "name": "CoreExports",
    "code": "public CoreExports(CoreExtensionEntry entry) {\n        this(entry.getClassRealm(), entry.getExportedArtifacts(), entry.getExportedPackages());\n    }",
    "comment": "Provides information about artifacts (identified by groupId:artifactId string key) and classpath elements exported by\nMaven core itself and loaded Maven core extensions.\n\n@since 3.3.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/support/conversion/StringToNumberConverter.java",
    "type": "method",
    "name": "canConvertTo",
    "code": "public boolean canConvertTo(Class<?> targetType) {\n\t\treturn CONVERTERS.containsKey(targetType);\n\t}",
    "comment": "Technically, BigInteger and BigDecimal constructors are covered by\nFallbackStringToObjectConverter, but we have explicit conversion\nconfigured for them anyway."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/execution/MavenSession.java",
    "type": "method",
    "name": "clone",
    "code": "public MavenSession clone() {\n        try {\n            MavenSession clone = (MavenSession) super.clone();\n            MavenProject current = getCurrentProject();\n            clone.currentProject = ThreadLocal.withInitial(() -> current);\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(\"Bug\", e);\n        }\n    }",
    "comment": "the default must become the current project of the thread that clones this\nwe replace the thread local of the clone to prevent write through and enforce the new default value"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/project/MavenProject.java",
    "type": "method",
    "name": "getTestArtifacts",
    "code": "public List<Artifact> getTestArtifacts() {\n        List<Artifact> list = new ArrayList<>(getArtifacts().size());\n\n        for (Artifact a : getArtifacts()) {\n            if (a.getArtifactHandler().isAddedToClasspath()) {\n                list.add(a);\n            }\n        }\n        return list;\n    }",
    "comment": "TODO classpath check doesn't belong here - that's the other method"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ExclusiveResource.java",
    "type": "method",
    "name": "ExclusiveResource",
    "code": "public ExclusiveResource(String key, LockMode lockMode) {\n\t\tthis.key = Preconditions.notBlank(key, \"key must not be blank\");\n\t\tthis.lockMode = Preconditions.notNull(lockMode, \"lockMode must not be null\");\n\t}",
    "comment": "Create a new {@code ExclusiveResource}.\n@param lockMode the lock mode to use to synchronize access to the\nresource; never {@code null}"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/MediaType.java",
    "type": "method",
    "name": "parse",
    "code": "public static MediaType parse(String value) {\n\t\treturn new MediaType(value);\n\t}",
    "comment": "Parse the given media type value.\n\n<p>Must be valid according to\n<a href=\"https://tools.ietf.org/html/rfc2045\">RFC 2045</a>.\n\n@param value the media type value to parse; never {@code null}\n@return the parsed media type\n@throws PreconditionViolationException if the value is not a valid media type"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/health-check/src/test/java/CpuHealthIndicatorTest.java",
    "type": "method",
    "name": "whenSystemCpuLoadIsHigh_thenHealthIsDown",
    "code": "void whenSystemCpuLoadIsHigh_thenHealthIsDown() {\n    // Set thresholds for testing within the test method to avoid issues with Spring's @Value\n    cpuHealthIndicator.setSystemCpuLoadThreshold(80.0);\n    cpuHealthIndicator.setProcessCpuLoadThreshold(50.0);\n    cpuHealthIndicator.setLoadAverageThreshold(0.75);\n\n    // Mock the getters to return your desired values\n    when(mockOsBean.getCpuLoad()).thenReturn(0.9); // Simulate 90% system CPU load\n    when(mockOsBean.getAvailableProcessors()).thenReturn(8);\n    when(mockOsBean.getSystemLoadAverage()).thenReturn(9.0);\n\n    // Execute the health check\n    Health health = cpuHealthIndicator.health();\n\n    // Assertions\n    assertEquals(\n        Status.DOWN,\n        health.getStatus(),\n        \"Health status should be DOWN when system CPU load is high\");\n    assertEquals(\n        \"High system CPU load\",\n        health.getDetails().get(\"error\"),\n        \"Error message should indicate high system CPU load\");\n  }",
    "comment": "Tests that the health status is DOWN when the system CPU load is high.\n\n<p>Sets the system CPU load to 90% and mocks the other getters to return appropriate values.\nExecutes the health check and asserts that the health status is DOWN and the error message\nindicates high system CPU load."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/java/src/main/java/org/tensorflow/op/core/Constant.java",
    "type": "method",
    "name": "create",
    "code": "public static Constant<Long> create(Scope scope, long[][][] data) {\n    return create(scope, data, Long.class);\n  }",
    "comment": "Creates a rank-3 constant of {@code long} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/InputSource.java",
    "type": "method",
    "name": "setLocation",
    "code": "public void setLocation(String location) {\n        this.location = location;\n    } // -- void setLocation( String )",
    "comment": "Set the path/URL of the POM or {@code null} if unknown.\n\n@param location"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/ExtensibleEnums.java",
    "type": "method",
    "name": "pathScope",
    "code": "static PathScope pathScope(String id, ProjectScope projectScope, DependencyScope... dependencyScopes) {\n        return new DefaultPathScope(id, projectScope, dependencyScopes);\n    }",
    "comment": "Creates a new PathScope instance with the specified ID, project scope, and dependency scopes.\n\n@param id the identifier for the path scope\n@param projectScope the project scope associated with this path scope\n@param dependencyScopes the dependency scopes associated with this path scope\n@return a new PathScope instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/android_architecture/PersistenceMigrationsSample/app/src/room/java/com/example/android/persistence/migrations/UserRepository.java",
    "type": "method",
    "name": "UserRepository",
    "code": "public UserRepository(AppExecutors appExecutors, UserDataSource userDataSource) {\n        mAppExecutors = appExecutors;\n        mUserDataSource = userDataSource;\n    }",
    "comment": "The repository is responsible of handling user data operations."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/demo/app/src/main/java/com/example/android/tflitecamerademo/ImageClassifierQuantizedMobileNet.java",
    "type": "method",
    "name": "getModelPath",
    "code": "protected String getModelPath() {\n    // you can download this file from\n    // see build.gradle for where to obtain this file. It should be auto\n    // downloaded into assets.\n    return \"mobilenet_v1_1.0_224_quant.tflite\";\n  }",
    "comment": "Initializes an {@code ImageClassifier}.\n\n@param activity"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-cli/src/main/java/org/apache/maven/api/cli/ParserRequest.java",
    "type": "method",
    "name": "mvn",
    "code": "static Builder mvn(@Nonnull String[] args, @Nonnull MessageBuilderFactory messageBuilderFactory) {\n        return mvn(Arrays.asList(args), messageBuilderFactory);\n    }",
    "comment": "Creates a new Builder instance for constructing a Maven ParserRequest.\n\n@param args the command-line arguments\n@param messageBuilderFactory the factory for creating message builders\n@return a new Builder instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/delegates/nnapi/java/src/main/java/org/tensorflow/lite/nnapi/NnApiDelegate.java",
    "type": "method",
    "name": "setAllowFp16",
    "code": "public Options setAllowFp16(boolean enable) {\n      this.allowFp16 = enable;\n      return this;\n    }",
    "comment": "Enable or disable to allow fp32 computation to be run in fp16 in NNAPI. See\nhttps://source.android.com/devices/neural-networks#android-9\n\n<p>Only effective on Android 9 (API level 28) and above."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/OneForOneBlockFetcher.java",
    "type": "method",
    "name": "areShuffleBlocksOrChunks",
    "code": "private boolean areShuffleBlocksOrChunks(String[] blockIds) {\n    if (isAnyBlockNotStartWithShuffleBlockPrefix(blockIds)) {\n      // It comes here because there is a blockId which doesn't have \"shuffle_\" prefix so we\n      // check if all the block ids are shuffle chunk Ids.\n      return isAllBlocksStartWithShuffleChunkPrefix(blockIds);\n    }\n    return true;\n  }",
    "comment": "Check if the array of block IDs are all shuffle block IDs. With push based shuffle,\nthe shuffle block ID could be either unmerged shuffle block IDs or merged shuffle chunk\nIDs. For a given stream of shuffle blocks to be fetched in one request, they would be either\nall unmerged shuffle blocks or all merged shuffle chunks.\n@param blockIds block ID array\n@return whether the array contains only shuffle block IDs"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/subclass-sandbox/src/main/java/com/iluwatar/subclasssandbox/Superpower.java",
    "type": "method",
    "name": "spawnParticles",
    "code": "protected void spawnParticles(String particleType, int count) {\n    logger.info(\"Spawn {} particle with type {}\", count, particleType);\n  }",
    "comment": "Spawn particles for the superpower.\n\n@param particleType Particle type.\n@param count Count of particles to be spawned."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/composite-entity/src/main/java/com/iluwatar/compositeentity/CoarseGrainedObject.java",
    "type": "method",
    "name": "setData",
    "code": "public void setData(T... data) {\n    IntStream.range(0, data.length).forEach(i -> dependentObjects[i].setData(data[i]));\n  }",
    "comment": "A coarse-grained object is an object with its own life cycle manages its own relationships to\nother objects. It can be an object contained in the composite entity, or, composite entity itself\ncan be the coarse-grained object which holds dependent objects."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(Long unexpected, long actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Long) actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/mllib/JavaStratifiedSamplingExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaStratifiedSamplingExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    List<Tuple2<Integer, Character>> list = Arrays.asList(\n        new Tuple2<>(1, 'a'),\n        new Tuple2<>(1, 'b'),\n        new Tuple2<>(2, 'c'),\n        new Tuple2<>(2, 'd'),\n        new Tuple2<>(2, 'e'),\n        new Tuple2<>(3, 'f')\n    );\n\n    JavaPairRDD<Integer, Character> data = jsc.parallelizePairs(list);\n\n    ImmutableMap<Integer, Double> fractions = ImmutableMap.of(1, 0.1, 2, 0.6, 3, 0.3);\n\n    JavaPairRDD<Integer, Character> approxSample = data.sampleByKey(false, fractions);\n    JavaPairRDD<Integer, Character> exactSample = data.sampleByKeyExact(false, fractions);\n\n    System.out.println(\"approxSample size is \" + approxSample.collect().size());\n    for (Tuple2<Integer, Character> t : approxSample.collect()) {\n      System.out.println(t._1() + \" \" + t._2());\n    }\n\n    System.out.println(\"exactSample size is \" + exactSample.collect().size());\n    for (Tuple2<Integer, Character> t : exactSample.collect()) {\n      System.out.println(t._1() + \" \" + t._2());\n    }\n\n    jsc.stop();\n  }",
    "comment": "$example on$\n$example off$\n$example on$\nspecify the exact fraction desired from each key Map<K, Double>\nGet an approximate sample from each stratum\nGet an exact sample from each stratum\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/CaseInsensitiveStringMap.java",
    "type": "method",
    "name": "getLong",
    "code": "public long getLong(String key, long defaultValue) {\n    String value = get(key);\n    return value == null ? defaultValue : Long.parseLong(value);\n  }",
    "comment": "Returns the long value to which the specified key is mapped,\nor defaultValue if there is no mapping for the key. The key match is case-insensitive."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/Assume.java",
    "type": "method",
    "name": "assumeTrue",
    "code": "public static void assumeTrue(boolean b) {\n        assumeThat(b, is(true));\n    }",
    "comment": "If called with an expression evaluating to {@code false}, the test will halt and be ignored."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/examples/src/main/java/org/apache/spark/examples/ml/JavaMulticlassLogisticRegressionWithElasticNetExample.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n        SparkSession spark = SparkSession\n                .builder()\n                .appName(\"JavaMulticlassLogisticRegressionWithElasticNetExample\")\n                .getOrCreate();\n\n        Dataset<Row> training = spark.read().format(\"libsvm\")\n                .load(\"data/mllib/sample_multiclass_classification_data.txt\");\n\n        LogisticRegression lr = new LogisticRegression()\n                .setMaxIter(10)\n                .setRegParam(0.3)\n                .setElasticNetParam(0.8);\n\n        LogisticRegressionModel lrModel = lr.fit(training);\n\n        System.out.println(\"Coefficients: \\n\"\n                + lrModel.coefficientMatrix() + \" \\nIntercept: \" + lrModel.interceptVector());\n        LogisticRegressionTrainingSummary trainingSummary = lrModel.summary();\n\n        double[] objectiveHistory = trainingSummary.objectiveHistory();\n        for (double lossPerIteration : objectiveHistory) {\n            System.out.println(lossPerIteration);\n        }\n\n        System.out.println(\"False positive rate by label:\");\n        int i = 0;\n        double[] fprLabel = trainingSummary.falsePositiveRateByLabel();\n        for (double fpr : fprLabel) {\n            System.out.println(\"label \" + i + \": \" + fpr);\n            i++;\n        }\n\n        System.out.println(\"True positive rate by label:\");\n        i = 0;\n        double[] tprLabel = trainingSummary.truePositiveRateByLabel();\n        for (double tpr : tprLabel) {\n            System.out.println(\"label \" + i + \": \" + tpr);\n            i++;\n        }\n\n        System.out.println(\"Precision by label:\");\n        i = 0;\n        double[] precLabel = trainingSummary.precisionByLabel();\n        for (double prec : precLabel) {\n            System.out.println(\"label \" + i + \": \" + prec);\n            i++;\n        }\n\n        System.out.println(\"Recall by label:\");\n        i = 0;\n        double[] recLabel = trainingSummary.recallByLabel();\n        for (double rec : recLabel) {\n            System.out.println(\"label \" + i + \": \" + rec);\n            i++;\n        }\n\n        System.out.println(\"F-measure by label:\");\n        i = 0;\n        double[] fLabel = trainingSummary.fMeasureByLabel();\n        for (double f : fLabel) {\n            System.out.println(\"label \" + i + \": \" + f);\n            i++;\n        }\n\n        double accuracy = trainingSummary.accuracy();\n        double falsePositiveRate = trainingSummary.weightedFalsePositiveRate();\n        double truePositiveRate = trainingSummary.weightedTruePositiveRate();\n        double fMeasure = trainingSummary.weightedFMeasure();\n        double precision = trainingSummary.weightedPrecision();\n        double recall = trainingSummary.weightedRecall();\n        System.out.println(\"Accuracy: \" + accuracy);\n        System.out.println(\"FPR: \" + falsePositiveRate);\n        System.out.println(\"TPR: \" + truePositiveRate);\n        System.out.println(\"F-measure: \" + fMeasure);\n        System.out.println(\"Precision: \" + precision);\n        System.out.println(\"Recall: \" + recall);\n\n        spark.stop();\n    }",
    "comment": "$example on$\n$example off$\n$example on$\nLoad training data\nFit the model\nPrint the coefficients and intercept for multinomial logistic regression\nObtain the loss per iteration.\nfor multiclass, we can inspect metrics on a per-label basis\n$example off$"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/launcher/src/main/java/org/apache/spark/launcher/Main.java",
    "type": "method",
    "name": "prepareBashCommand",
    "code": "private static List<String> prepareBashCommand(List<String> cmd, Map<String, String> childEnv) {\n    if (childEnv.isEmpty()) {\n      return cmd;\n    }\n\n    List<String> newCmd = new ArrayList<>();\n    newCmd.add(\"env\");\n\n    for (Map.Entry<String, String> e : childEnv.entrySet()) {\n      newCmd.add(String.format(\"%s=%s\", e.getKey(), e.getValue()));\n    }\n    newCmd.addAll(cmd);\n    return newCmd;\n  }",
    "comment": "Prepare the command for execution from a bash script. The final command will have commands to\nset up any needed environment variables needed by the child process."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runner/JUnitCore.java",
    "type": "method",
    "name": "run",
    "code": "public Result run(Class<?>... classes) {\n        return run(defaultComputer(), classes);\n    }",
    "comment": "Run all the tests in <code>classes</code>.\n\n@param classes the classes containing tests\n@return a {@link Result} describing the details of the test run and the failed tests."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/PackageSource.java",
    "type": "method",
    "name": "getPackageName",
    "code": "public final String getPackageName() {\n\t\treturn this.packageName;\n\t}",
    "comment": "Get the package name of this test source."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeoutPreemptively.java",
    "type": "method",
    "name": "assertTimeoutPreemptively",
    "code": "static void assertTimeoutPreemptively(Duration timeout, Executable executable) {\n\t\tassertTimeoutPreemptively(timeout, executable, (String) null);\n\t}",
    "comment": "{@code AssertTimeout} is a collection of utility methods that support asserting\nthe execution of the code under test did not take longer than the timeout duration\nusing a preemptive approach.\n\n@since 5.9.1"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/test/java/junit/tests/framework/ComparisonFailureTest.java",
    "type": "method",
    "name": "testThrowing",
    "code": "public void testThrowing() {\n        try {\n            assertEquals(\"a\", \"b\");\n        } catch (ComparisonFailure e) {\n            return;\n        }\n        fail();\n    }",
    "comment": "This is like an instanceof test."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "WritableColumnVector",
    "code": "protected WritableColumnVector(int capacity, DataType dataType) {\n    super(dataType);\n    this.capacity = capacity;\n    this.defaultCapacity = capacity;\n    this.hugeVectorThreshold = SQLConf.get().vectorizedHugeVectorThreshold();\n    this.hugeVectorReserveRatio = SQLConf.get().vectorizedHugeVectorReserveRatio();\n\n    if (isArray()) {\n      DataType childType;\n      int childCapacity = capacity;\n      if (type instanceof ArrayType) {\n        childType = ((ArrayType)type).elementType();\n      } else {\n        childType = DataTypes.ByteType;\n        childCapacity *= DEFAULT_ARRAY_LENGTH;\n      }\n      this.childColumns = new WritableColumnVector[1];\n      this.childColumns[0] = reserveNewColumn(childCapacity, childType);\n    } else if (type instanceof StructType st) {\n      this.childColumns = new WritableColumnVector[st.fields().length];\n      for (int i = 0; i < childColumns.length; ++i) {\n        this.childColumns[i] = reserveNewColumn(capacity, st.fields()[i].dataType());\n      }\n    } else if (type instanceof MapType mapType) {\n      this.childColumns = new WritableColumnVector[2];\n      this.childColumns[0] = reserveNewColumn(capacity, mapType.keyType());\n      this.childColumns[1] = reserveNewColumn(capacity, mapType.valueType());\n    } else if (type instanceof CalendarIntervalType) {\n      // Three columns. Months as int. Days as Int. Microseconds as Long.\n      this.childColumns = new WritableColumnVector[3];\n      this.childColumns[0] = reserveNewColumn(capacity, DataTypes.IntegerType);\n      this.childColumns[1] = reserveNewColumn(capacity, DataTypes.IntegerType);\n      this.childColumns[2] = reserveNewColumn(capacity, DataTypes.LongType);\n    } else if (type instanceof VariantType) {\n      this.childColumns = new WritableColumnVector[2];\n      this.childColumns[0] = reserveNewColumn(capacity, DataTypes.BinaryType);\n      this.childColumns[1] = reserveNewColumn(capacity, DataTypes.BinaryType);\n    } else {\n      this.childColumns = null;\n    }\n  }",
    "comment": "Sets up the common state and also handles creating the child columns if this is a nested\ntype."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/JavaPathType.java",
    "type": "method",
    "name": "valueOf",
    "code": "public static Optional<JavaPathType> valueOf(JavaFileManager.Location location) {\n        for (JavaPathType type : JavaPathType.values()) {\n            if (location.equals(type.location)) {\n                return Optional.of(type);\n            }\n        }\n        return Optional.empty();\n    }",
    "comment": "Returns the path type associated to the given {@code javax.tool} location.\nThis method is the converse of {@link #location()}.\n\n@param location identification of a path in the {@code javax.tool} API\n@return Java path type associated to the given location"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java",
    "type": "method",
    "name": "isMultidimensionalArray",
    "code": "public static boolean isMultidimensionalArray(Object obj) {\n\t\treturn (obj != null && obj.getClass().isArray() && obj.getClass().getComponentType().isArray());\n\t}",
    "comment": "Determine if the supplied object is a multidimensional array.\n\n@param obj the object to test; potentially {@code null}\n@return {@code true} if the object is a multidimensional array\n@since 1.3.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/async-method-invocation/src/test/java/com/iluwatar/async/method/invocation/ThreadAsyncExecutorTest.java",
    "type": "method",
    "name": "testNullTaskWithCallback",
    "code": "void testNullTaskWithCallback() {\n    assertTimeout(\n        ofMillis(3000),\n        () -> {\n          // Instantiate a new executor and start a new 'null' task ...\n          final var executor = new ThreadAsyncExecutor();\n          final var asyncResult = executor.startProcess(null, callback);\n\n          assertNotNull(\n              asyncResult,\n              \"The AsyncResult should not be 'null', even though the task was 'null'.\");\n          asyncResult.await(); // Prevent timing issues, and wait until the result is available\n          assertTrue(asyncResult.isCompleted());\n          verify(callback, times(0)).onComplete(any());\n          verify(callback, times(1)).onError(exceptionCaptor.capture());\n\n          final var exception = exceptionCaptor.getValue();\n          assertNotNull(exception);\n\n          assertEquals(NullPointerException.class, exception.getClass());\n\n          try {\n            asyncResult.getValue();\n            fail(\"Expected ExecutionException with NPE as cause\");\n          } catch (final ExecutionException e) {\n            assertNotNull(e.getMessage());\n            assertNotNull(e.getCause());\n            assertEquals(NullPointerException.class, e.getCause().getClass());\n          }\n        });\n  }",
    "comment": "Test used to verify the behaviour of {@link ThreadAsyncExecutor#startProcess(Callable,\nAsyncCallback)} when the callable is 'null', but the asynchronous callback is provided"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/test/java/org/apache/maven/model/pom/PomMemoryAnalyzer.java",
    "type": "method",
    "name": "processModelNode",
    "code": "private void processModelNode(Object node, String currentPath, String elementName, Set<Object> visited) {\n        if (node == null || !visited.add(node)) {\n            return;\n        }\n\n        Class<?> clazz = node.getClass();\n        while (clazz != null && !clazz.equals(Object.class)) {\n            for (Field field : clazz.getDeclaredFields()) {\n                if (Modifier.isStatic(field.getModifiers()) || field.isSynthetic()) {\n                    continue;\n                }\n\n                try {\n                    field.setAccessible(true);\n                    Object value = field.get(node);\n                    if (value == null) {\n                        continue;\n                    }\n\n                    String fullPath = currentPath + \"/\" + field.getName();\n\n                    if (value instanceof String strValue) {\n                        recordString(fullPath, strValue);\n                        globalStringFrequency.merge(strValue, 1, Integer::sum);\n                    } else if (value instanceof List<?> list) {\n                        for (Object item : list) {\n                            if (item != null) {\n                                String itemName = getSingular(field.getName());\n                                processModelNode(item, fullPath + \"/\" + itemName, itemName, visited);\n                            }\n                        }\n                    } else if (value instanceof Map<?, ?> map) {\n                        for (Map.Entry<?, ?> entry : map.entrySet()) {\n                            if (entry.getValue() != null) {\n                                processModelNode(\n                                        entry.getValue(),\n                                        fullPath + \"/\" + entry.getKey(),\n                                        entry.getKey().toString(),\n                                        visited);\n                            }\n                        }\n                    } else if (!value.getClass().isPrimitive()\n                            && !value.getClass().getName().startsWith(\"java.\")) {\n                        processModelNode(value, fullPath, field.getName(), visited);\n                    }\n                } catch (Exception e) {\n                }\n            }\n            clazz = clazz.getSuperclass();\n        }\n    }",
    "comment": "Skip static fields and synthetic fields\nSkip inaccessible or problematic fields"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/api/maven-api-core/src/main/java/org/apache/maven/api/SessionData.java",
    "type": "method",
    "name": "key",
    "code": "static <T> Key<T> key(Class<T> clazz, Object id) {\n        return new Key<>(clazz, id);\n    }",
    "comment": "Create a key using the given class and id."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertEquals",
    "code": "public static void assertEquals(float expected, float actual, float delta) {\n\t\tAssertEquals.assertEquals(expected, actual, delta);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/main/java/org/apache/spark/util/collection/unsafe/sort/UnsafeSortDataFormat.java",
    "type": "method",
    "name": "UnsafeSortDataFormat",
    "code": "public UnsafeSortDataFormat(LongArray buffer) {\n    this.buffer = buffer;\n  }",
    "comment": "Supports sorting an array of (record pointer, key prefix) pairs.\nUsed in {@link UnsafeInMemorySorter}.\n<p>\nWithin each long[] buffer, position {@code 2 * i} holds a pointer to the record at\nindex {@code i}, while position {@code 2 * i + 1} in the array holds an 8-byte key prefix."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/its/core-it-suite/src/test/java/org/apache/maven/it/MavenITmng5895CIFriendlyUsageWithPropertyTest.java",
    "type": "method",
    "name": "MavenITmng5895CIFriendlyUsageWithPropertyTest",
    "code": "public MavenITmng5895CIFriendlyUsageWithPropertyTest() {\n        // The first version which contains the fix for the MNG-issue.\n        // TODO: Think about it!\n        super(\"[3.5.0-alpha-2,)\");\n    }",
    "comment": "The usage of a <code>${revision}</code> for the version in the pom file and furthermore\ndefining the property in the pom file and overwrite it via command line.\n<a href=\"https://issues.apache.org/jira/browse/MNG-5895\">MNG-5895</a>.\n\nThis will result in a failure without the fix for this issue.\n\n@author Karl Heinz Marbaise khmarbaise@apache.org"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicContainer.java",
    "type": "method",
    "name": "getChildren",
    "code": "public Stream<? extends DynamicNode> getChildren() {\n\t\treturn children;\n\t}",
    "comment": "Get the {@link Stream} of {@link DynamicNode DynamicNodes} associated\nwith this {@code DynamicContainer}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlan.java",
    "type": "method",
    "name": "duplicateIds",
    "code": "public Set<String> duplicateIds() {\n        if (duplicateIds == null) {\n            synchronized (this) {\n                if (duplicateIds == null) {\n                    duplicateIds = projects()\n                            .map(MavenProject::getArtifactId)\n                            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\n                            .entrySet()\n                            .stream()\n                            .filter(p -> p.getValue() > 1)\n                            .map(Map.Entry::getKey)\n                            .collect(Collectors.toSet());\n                }\n            }\n        }\n        return duplicateIds;\n    }",
    "comment": "gather artifactIds which are not unique so that the respective thread names can be extended with the groupId"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/event-sourcing/src/main/java/com/iluwatar/event/sourcing/app/App.java",
    "type": "method",
    "name": "main",
    "code": "public static void main(String[] args) {\n\n    var eventProcessor = new DomainEventProcessor(new JsonFileJournal());\n\n    LOGGER.info(\"Running the system first time............\");\n    eventProcessor.reset();\n\n    LOGGER.info(\"Creating the accounts............\");\n\n    eventProcessor.process(\n        new AccountCreateEvent(0, new Date().getTime(), ACCOUNT_OF_DAENERYS, \"Daenerys Targaryen\"));\n\n    eventProcessor.process(\n        new AccountCreateEvent(1, new Date().getTime(), ACCOUNT_OF_JON, \"Jon Snow\"));\n\n    LOGGER.info(\"Do some money operations............\");\n\n    eventProcessor.process(\n        new MoneyDepositEvent(\n            2, new Date().getTime(), ACCOUNT_OF_DAENERYS, new BigDecimal(\"100000\")));\n\n    eventProcessor.process(\n        new MoneyDepositEvent(3, new Date().getTime(), ACCOUNT_OF_JON, new BigDecimal(\"100\")));\n\n    eventProcessor.process(\n        new MoneyTransferEvent(\n            4, new Date().getTime(), new BigDecimal(\"10000\"), ACCOUNT_OF_DAENERYS, ACCOUNT_OF_JON));\n\n    LOGGER.info(\"...............State:............\");\n    LOGGER.info(AccountAggregate.getAccount(ACCOUNT_OF_DAENERYS).toString());\n    LOGGER.info(AccountAggregate.getAccount(ACCOUNT_OF_JON).toString());\n\n    LOGGER.info(\"At that point system had a shut down, state in memory is cleared............\");\n    AccountAggregate.resetState();\n\n    LOGGER.info(\"Recover the system by the events in journal file............\");\n\n    eventProcessor = new DomainEventProcessor(new JsonFileJournal());\n    eventProcessor.recover();\n\n    LOGGER.info(\"...............Recovered State:............\");\n    LOGGER.info(AccountAggregate.getAccount(ACCOUNT_OF_DAENERYS).toString());\n    LOGGER.info(AccountAggregate.getAccount(ACCOUNT_OF_JON).toString());\n  }",
    "comment": "The entry point of application.\n\n@param args the input arguments"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertLinesMatch.java",
    "type": "method",
    "name": "assertLinesMatch",
    "code": "static void assertLinesMatch(List<String> expectedLines, List<String> actualLines, Object messageOrSupplier) {\n\t\tnotNull(expectedLines, \"expectedLines must not be null\");\n\t\tnotNull(actualLines, \"actualLines must not be null\");\n\n\t\tif (expectedLines == actualLines) {\n\t\t\treturn;\n\t\t}\n\n\t\tnew LinesMatcher(expectedLines, actualLines, messageOrSupplier).assertLinesMatch();\n\t}",
    "comment": "trivial case: same list instance"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-model/src/main/java/org/apache/maven/model/InputSource.java",
    "type": "method",
    "name": "setImportedFrom",
    "code": "public void setImportedFrom(InputLocation importedFrom) {\n        this.importedFrom = importedFrom;\n    }",
    "comment": "Set the location of the POM from which this POM was imported from.\n\n@param importedFrom"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/core/src/main/java/org/apache/spark/sql/execution/vectorized/WritableColumnVector.java",
    "type": "method",
    "name": "hasDictionary",
    "code": "public boolean hasDictionary() { return this.dictionary != null; }",
    "comment": "Returns true if this column has a dictionary."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/Namespace.java",
    "type": "method",
    "name": "create",
    "code": "public static Namespace create(Object... parts) {\n\t\tPreconditions.notEmpty(parts, \"parts array must not be null or empty\");\n\t\tPreconditions.containsNoNullElements(parts, \"individual parts must not be null\");\n\t\treturn new Namespace(Arrays.asList(parts));\n\t}",
    "comment": "Create a namespace which restricts access to data to all extensions\nwhich use the same sequence of {@code parts} for creating a namespace.\n\n<p>The order of the {@code parts} is significant.\n\n<p>Internally the {@code parts} are compared using {@link Object#equals(Object)}."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/core/src/test/java/test/org/apache/spark/JavaSparkContextSuite.java",
    "type": "method",
    "name": "scalaSparkContext",
    "code": "public void scalaSparkContext() {\n    List<String> jars = List$.MODULE$.empty();\n    Map<String, String> environment = Map$.MODULE$.empty();\n\n    new SparkContext(new SparkConf().setMaster(\"local\").setAppName(\"name\")).stop();\n    new SparkContext(\"local\", \"name\", new SparkConf()).stop();\n    new SparkContext(\"local\", \"name\").stop();\n    new SparkContext(\"local\", \"name\", \"sparkHome\").stop();\n    new SparkContext(\"local\", \"name\", \"sparkHome\", jars).stop();\n    new SparkContext(\"local\", \"name\", \"sparkHome\", jars, environment).stop();\n  }",
    "comment": "Java apps can use both Java-friendly JavaSparkContext and Scala SparkContext."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/RepositoryUtils.java",
    "type": "method",
    "name": "repositoryHashCode",
    "code": "ArtifactRepository repository, RepositorySystemSession session, RepositorySystem system) {\n        if (repository == null || repository.getBasedir() == null) {\n            return session;\n        }\n\n        DefaultRepositorySystemSession newSession;\n        if (session != null) {\n            LocalRepositoryManager lrm = session.getLocalRepositoryManager();\n            if (lrm != null && lrm.getRepository().getBasedir().equals(new File(repository.getBasedir()))) {\n            newSession = new DefaultRepositorySystemSession(session);\n        } else {\n            newSession = new DefaultRepositorySystemSession(h -> false); // no close handle used\n        }\n\n        final LocalRepositoryManager llrm =\n                system.newLocalRepositoryManager(newSession, new LocalRepository(repository.getBasedir()));\n        newSession.setLocalRepositoryManager(llrm);\n        return newSession;\n    }\n\n    private static int repositoryHashCode(RemoteRepository repository) {\n        int result = 17;\n        Object obj = repository.getUrl();\n        result = 31 * result + (obj != null ? obj.hashCode() : 0);\n        return result;\n    }\n\n    private static boolean policyEquals(RepositoryPolicy p1, RepositoryPolicy p2) {\n        if (p1 == p2) {\n            return true;\n        }\n        return p1.isEnabled() == p2.isEnabled() && Objects.equals(p1.getChecksumPolicy(), p2.getChecksumPolicy());\n    }\n\n    private static boolean repositoryEquals(RemoteRepository r1, RemoteRepository r2) {\n        if (r1 == r2) {\n            return true;\n        }\n\n        return Objects.equals(r1.getId(), r2.getId())\n                && Objects.equals(r1.getUrl(), r2.getUrl())\n                && policyEquals(r1.getPolicy(false), r2.getPolicy(false))\n                && policyEquals(r1.getPolicy(true), r2.getPolicy(true));\n    }\n}",
    "comment": "update policy doesn't affect contents"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-shuffle/src/main/java/org/apache/spark/network/shuffle/RemoteBlockPushResolver.java",
    "type": "method",
    "name": "PushMergeMetrics",
    "code": "private PushMergeMetrics() {\n      allMetrics = new HashMap<>();\n      blockAppendCollisions = new Meter();\n      allMetrics.put(BLOCK_APPEND_COLLISIONS_METRIC, blockAppendCollisions);\n      lateBlockPushes = new Meter();\n      allMetrics.put(LATE_BLOCK_PUSHES_METRIC, lateBlockPushes);\n      blockBytesWritten = new Meter();\n      allMetrics.put(BLOCK_BYTES_WRITTEN_METRIC, blockBytesWritten);\n      deferredBlockBytes = new Counter();\n      allMetrics.put(DEFERRED_BLOCK_BYTES_METRIC, deferredBlockBytes);\n      deferredBlocks = new Meter();\n      allMetrics.put(DEFERRED_BLOCKS_METRIC, deferredBlocks);\n      staleBlockPushes = new Meter();\n      allMetrics.put(STALE_BLOCK_PUSHES_METRIC, staleBlockPushes);\n      ignoredBlockBytes = new Meter();\n      allMetrics.put(IGNORED_BLOCK_BYTES_METRIC, ignoredBlockBytes);\n    }",
    "comment": "A class that wraps all the push-based shuffle service metrics."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/java_design_patterns/commander/src/main/java/com/iluwatar/commander/queue/QueueDatabase.java",
    "type": "method",
    "name": "get",
    "code": "public QueueTask get(String taskId) {\n    return null;\n  }",
    "comment": "dequeue method removes the object at front and returns it.\n\n@return object at front of queue\n@throws IsEmptyException if queue is empty"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertDoesNotThrow",
    "code": "public static void assertDoesNotThrow(Executable executable, String message) {\n\t\tAssertDoesNotThrow.assertDoesNotThrow(executable, message);\n\t}",
    "comment": "<em>Assert</em> that execution of the supplied {@code executable} does\n<em>not</em> throw any kind of {@linkplain Throwable exception}.\n\n<h4>Usage Note</h4>\n<p>Although any exception thrown from a test method will cause the test\nto <em>fail</em>, there are certain use cases where it can be beneficial\nto explicitly assert that an exception is not thrown for a given code\nblock within a test method.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.2"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/RepeatedTestExtension.java",
    "type": "method",
    "name": "supportsTestTemplate",
    "code": "public boolean supportsTestTemplate(ExtensionContext context) {\n\t\treturn isAnnotated(context.getTestMethod(), RepeatedTest.class);\n\t}",
    "comment": "{@code TestTemplateInvocationContextProvider} that supports the\n{@link RepeatedTest @RepeatedTest} annotation.\n\n@since 5.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/StringUtils.java",
    "type": "method",
    "name": "containsWhitespace",
    "code": "public static boolean containsWhitespace(String str) {\n\t\treturn str != null && str.codePoints().anyMatch(Character::isWhitespace);\n\t}",
    "comment": "Determine if the supplied {@link String} contains any whitespace characters.\n\n@param str the string to check; may be {@code null}\n@return {@code true} if the string contains whitespace\n@see #containsIsoControlCharacter(String)\n@see Character#isWhitespace(int)"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/runners/model/TestClass.java",
    "type": "method",
    "name": "scanAnnotatedMembers",
    "code": "protected void scanAnnotatedMembers(Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations, Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations) {\n        for (Class<?> eachClass : getSuperClasses(clazz)) {\n            for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {\n                addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);\n            }\n            for (Field eachField : getSortedDeclaredFields(eachClass)) {\n                addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);\n            }\n        }\n    }",
    "comment": "ensuring fields are sorted to make sure that entries are inserted\nand read from fieldForAnnotations in a deterministic order"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit4/src/main/java/org/junit/experimental/categories/Categories.java",
    "type": "method",
    "name": "include",
    "code": "public static CategoryFilter include(boolean matchAny, Class<?>... categories) {\n            return new CategoryFilter(matchAny, categories, true, null);\n        }",
    "comment": "If <tt>true</tt>, the tests annotated with <em>any</em> of the categories in {@link ExcludeCategory#value()}\ndo not run. Otherwise, the tests do not run if and only if annotated with <em>all</em> categories."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java",
    "type": "method",
    "name": "AbstractRepositoryMetadata",
    "code": "protected AbstractRepositoryMetadata(Metadata metadata) {\n        this.metadata = metadata;\n    }",
    "comment": "Shared methods of the repository metadata handling."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-commons/src/main/java/org/junit/platform/commons/util/CollectionUtils.java",
    "type": "method",
    "name": "getFirstElement",
    "code": "public static <T> Optional<T> getFirstElement(Collection<T> collection) {\n\t\tPreconditions.notNull(collection, \"collection must not be null\");\n\t\treturn collection.isEmpty() //\n\t\t\t\t? Optional.empty() //\n\t\t\t\t: Optional.ofNullable(firstElement(collection));\n\t}",
    "comment": "Get the first element of the supplied collection unless it's empty.\n\n@param collection the collection to get the element from\n@return the first element of the collection; empty if the collection is empty\n@throws PreconditionViolationException if the collection is {@code null}\n@since 1.11"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherConfig.java",
    "type": "method",
    "name": "build",
    "code": "public LauncherConfig build() {\n\t\t\treturn new DefaultLauncherConfig(this.engineAutoRegistrationEnabled,\n\t\t\t\tthis.launcherSessionListenerAutoRegistrationEnabled,\n\t\t\t\tthis.launcherDiscoveryListenerAutoRegistrationEnabled,\n\t\t\t\tthis.testExecutionListenerAutoRegistrationEnabled, this.postDiscoveryFilterAutoRegistrationEnabled,\n\t\t\t\tthis.engines, this.sessionListeners, this.discoveryListeners, this.executionListeners,\n\t\t\t\tthis.postDiscoveryFilters);\n\t\t}",
    "comment": "Build the {@link LauncherConfig} that has been configured via this\nbuilder."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/lite/java/ovic/src/main/java/org/tensorflow/ovic/OvicDetectorBenchmarker.java",
    "type": "method",
    "name": "convertBitmapToInput",
    "code": "private void convertBitmapToInput(Bitmap bitmap) {\n    int originalWidth = bitmap.getWidth();\n    int originalHeight = bitmap.getHeight();\n    scaledBitmap = Bitmap.createScaledBitmap(bitmap, imgWidth, imgHeight, true);\n    scaleFactorWidth = originalWidth * 1.0 / imgWidth;\n    scaleFactorHeight = originalHeight * 1.0 / imgHeight;\n    scaledBitmap.getPixels(intValues, 0, imgWidth, 0, 0, imgWidth, imgHeight);\n    scaledBitmap.recycle();\n    loadsInputToByteBuffer();\n  }",
    "comment": "Preprocess bitmap image into {@link ByteBuffer} format for the detector.\n\n@param bitmap: a {@link Bitmap} source image."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/common/network-common/src/test/java/org/apache/spark/network/util/TransportFrameDecoderSuite.java",
    "type": "method",
    "name": "testEmptyFrame",
    "code": "public void testEmptyFrame() {\n    assertThrows(IllegalArgumentException.class, () -> testInvalidFrame(8));\n  }",
    "comment": "8 because frame size includes the frame length."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/lifecycle/internal/concurrent/BuildPlanExecutor.java",
    "type": "method",
    "name": "processStep",
    "code": "private void processStep(BuildStep step) {\n            // 1. Apply reactor failure behavior to decide whether to schedule or skip\n            ReactorBuildStatus status = reactorContext.getReactorBuildStatus();\n            boolean isAfterStep = step.name.startsWith(AFTER);\n            boolean shouldExecute;\n\n            // Check if all predecessors are executed successfully\n            boolean allPredecessorsExecuted = step.predecessors.stream().allMatch(s -> s.status.get() == EXECUTED);\n\n            // Special case for after:* steps - they should run if their corresponding before:* step ran\n            if (isAfterStep) {\n                String phaseName = step.name.substring(AFTER.length());\n                // Always process after:* steps for cleanup if their before:* step ran\n                shouldExecute = plan.step(step.project, BEFORE + phaseName)\n                        .map(s -> {\n                            int stepStatus = s.status.get();\n                            return stepStatus == EXECUTED;\n                        })\n                        .orElse(false);\n\n                // Check if any predecessor failed - if so, we'll run the step but mark it as SKIPPED\n                boolean anyPredecessorFailed = step.predecessors.stream().anyMatch(s -> s.status.get() == FAILED);\n\n                // If any predecessor failed, we'll use a special status transition: CREATED -> SKIPPED\n                // This ensures the step runs for cleanup but is marked as skipped in the end\n                if (shouldExecute && anyPredecessorFailed) {\n                    // We'll run the step but mark it as SKIPPED instead of SCHEDULED\n                    if (step.status.compareAndSet(CREATED, SKIPPED)) {\n                        logger.debug(\n                                \"Running after:* step {} for cleanup but marking it as SKIPPED because a predecessor failed\",\n                                step);\n                        executor.execute(() -> {\n                            try {\n                                executeStep(step);\n                                executePlan();\n                            } catch (Exception e) {\n                                step.status.compareAndSet(SKIPPED, FAILED);\n                                // Store the exception in the step for handling in the TEARDOWN phase\n                                step.exception = e;\n                                logger.debug(\"Stored exception for step {} to be handled in TEARDOWN phase\", step, e);\n                                // Let the scheduler handle after:* phases and TEARDOWN in the next cycle\n                                executePlan();\n                            }\n                        });\n                        return; // Skip the rest of the method since we've handled this step\n                    }\n                }\n            } else if (TEARDOWN.equals(step.name)) {\n                // TEARDOWN should always run to ensure proper cleanup and error handling\n                // We'll handle success/failure reporting inside the TEARDOWN phase\n                shouldExecute = true;\n            } else {\n                // For regular steps:\n                // Don't run for halted builds, blacklisted projects, or if predecessors failed\n                shouldExecute = !status.isHalted() && !status.isBlackListed(step.project) && allPredecessorsExecuted;\n            }\n\n            // 2. Either schedule the step or mark it as skipped based on the decision\n            if (shouldExecute && step.status.compareAndSet(CREATED, SCHEDULED)) {\n                boolean nextIsPlanning = step.successors.stream().anyMatch(st -> PLAN.equals(st.name));\n                executor.execute(() -> {\n                    try {\n                        executeStep(step);\n                        if (nextIsPlanning) {\n                            lock.writeLock().lock();\n                            try {\n                                plan();\n                            } finally {\n                                lock.writeLock().unlock();\n                            }\n                        }\n                        executePlan();\n                    } catch (Exception e) {\n                        step.status.compareAndSet(SCHEDULED, FAILED);\n\n                        // Store the exception in the step for handling in the TEARDOWN phase\n                        step.exception = e;\n                        logger.debug(\"Stored exception for step {} to be handled in TEARDOWN phase\", step, e);\n\n                        // Let the scheduler handle after:* phases and TEARDOWN in the next cycle\n                        executePlan();\n                    }\n                });\n            } else if (step.status.compareAndSet(CREATED, SKIPPED)) {\n                // Skip the step and provide a specific reason\n                if (!shouldExecute) {\n                    if (status.isHalted()) {\n                        logger.debug(\"Skipping step {} because the build is halted\", step);\n                    } else if (status.isBlackListed(step.project)) {\n                        logger.debug(\"Skipping step {} because the project is blacklisted\", step);\n                    } else if (TEARDOWN.equals(step.name)) {\n                        // This should never happen given we always process TEARDOWN steps\n                        logger.warn(\"Unexpected skipping of TEARDOWN step {}\", step);\n                    } else {\n                        logger.debug(\"Skipping step {} because a dependency has failed\", step);\n                    }\n                } else {\n                    // Skip because predecessors failed or were skipped\n                    logger.debug(\n                            \"Skipping step {} because one or more predecessors did not execute successfully\", step);\n                }\n                // Recursively call executePlan to process steps that depend on this one\n                executePlan();\n            }\n        }",
    "comment": "Processes a single build step, deciding whether to schedule it for execution or skip it.\n\n@param step The build step to process"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/spark/sql/catalyst/src/main/java/org/apache/spark/sql/util/CaseInsensitiveStringMap.java",
    "type": "method",
    "name": "empty",
    "code": "public static CaseInsensitiveStringMap empty() {\n    return new CaseInsensitiveStringMap(new HashMap<>(0));\n  }",
    "comment": "Case-insensitive map of string keys to string values.\n<p>\nThis is used to pass options to v2 implementations to ensure consistent case insensitivity.\n<p>\nMethods that return keys in this map, like {@link #entrySet()} and {@link #keySet()}, return\nkeys converted to lower case. This map doesn't allow null key.\n\n@since 3.0.0"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/tensorflow/tensorflow/tools/android/test/src/org/tensorflow/demo/SpeechActivity.java",
    "type": "method",
    "name": "requestMicrophonePermission",
    "code": "private void requestMicrophonePermission() {\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n      requestPermissions(\n          new String[]{android.Manifest.permission.RECORD_AUDIO}, REQUEST_RECORD_AUDIO);\n  }\n\n  @Override\n  public void onRequestPermissionsResult(\n      int requestCode, String[] permissions, int[] grantResults) {\n    if (requestCode == REQUEST_RECORD_AUDIO\n        && grantResults.length > 0\n        && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n      startRecording();\n      startRecognition();\n    }\n  }\n\n  public synchronized void startRecording() {\n    if (recordingThread != null) {\n      return;\n    }\n    shouldContinue = true;\n    recordingThread =\n        new Thread(\n            new Runnable() {\n            });\n    recordingThread.start();\n  }\n\n  public synchronized void stopRecording() {\n    if (recordingThread == null) {\n      return;\n    }\n    shouldContinue = false;\n    recordingThread = null;\n  }\n\n  private void record() {\n    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_AUDIO);\n\n    int bufferSize =\n        AudioRecord.getMinBufferSize(\n            SAMPLE_RATE, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT);\n    if (bufferSize == AudioRecord.ERROR || bufferSize == AudioRecord.ERROR_BAD_VALUE) {\n      bufferSize = SAMPLE_RATE * 2;\n    }\n    short[] audioBuffer = new short[bufferSize / 2];\n\n    AudioRecord record =\n        new AudioRecord(\n            MediaRecorder.AudioSource.DEFAULT,\n            SAMPLE_RATE,\n            AudioFormat.CHANNEL_IN_MONO,\n            AudioFormat.ENCODING_PCM_16BIT,\n            bufferSize);\n\n    if (record.getState() != AudioRecord.STATE_INITIALIZED) {\n      Log.e(LOG_TAG, \"Audio Record can't initialize!\");\n      return;\n    }\n\n    record.startRecording();\n\n    Log.v(LOG_TAG, \"Start recording\");\n\n    while (shouldContinue) {\n      int numberRead = record.read(audioBuffer, 0, audioBuffer.length);\n      int maxLength = recordingBuffer.length;\n      int newRecordingOffset = recordingOffset + numberRead;\n      int secondCopyLength = Math.max(0, newRecordingOffset - maxLength);\n      int firstCopyLength = numberRead - secondCopyLength;\n      recordingBufferLock.lock();\n      try {\n        System.arraycopy(audioBuffer, 0, recordingBuffer, recordingOffset, firstCopyLength);\n        System.arraycopy(audioBuffer, firstCopyLength, recordingBuffer, 0, secondCopyLength);\n        recordingOffset = newRecordingOffset % maxLength;\n      } finally {\n        recordingBufferLock.unlock();\n      }\n    }\n\n    record.stop();\n    record.release();\n  }\n\n  public synchronized void startRecognition() {\n    if (recognitionThread != null) {\n      return;\n    }\n    shouldContinueRecognition = true;\n    recognitionThread =\n        new Thread(\n            new Runnable() {\n            });\n    recognitionThread.start();\n  }\n\n  public synchronized void stopRecognition() {\n    if (recognitionThread == null) {\n      return;\n    }\n    shouldContinueRecognition = false;\n    recognitionThread = null;\n  }\n\n  private void recognize() {\n    Log.v(LOG_TAG, \"Start recognition\");\n\n    short[] inputBuffer = new short[RECORDING_LENGTH];\n    float[] floatInputBuffer = new float[RECORDING_LENGTH];\n    float[] outputScores = new float[labels.size()];\n    String[] outputScoresNames = new String[] {OUTPUT_SCORES_NAME};\n    int[] sampleRateList = new int[] {SAMPLE_RATE};\n        recordingBufferLock.unlock();\n      }\n\n      for (int i = 0; i < RECORDING_LENGTH; ++i) {\n        floatInputBuffer[i] = inputBuffer[i] / 32767.0f;\n      }\n\n      inferenceInterface.feed(SAMPLE_RATE_NAME, sampleRateList);\n      inferenceInterface.feed(INPUT_DATA_NAME, floatInputBuffer, RECORDING_LENGTH, 1);\n      inferenceInterface.run(outputScoresNames);\n      inferenceInterface.fetch(OUTPUT_SCORES_NAME, outputScores);\n\n      long currentTime = System.currentTimeMillis();\n      final RecognizeCommands.RecognitionResult result =\n          recognizeCommands.processLatestResults(outputScores, currentTime);\n\n      runOnUiThread(\n          new Runnable() {\n                }\n                final View labelView = labelsListView.getChildAt(labelIndex - 2);\n\n                AnimatorSet colorAnimation =\n                    (AnimatorSet)\n                        AnimatorInflater.loadAnimator(\n                            SpeechActivity.this, R.animator.color_animation);\n                colorAnimation.setTarget(labelView);\n                colorAnimation.start();\n              }",
    "comment": "Estimate the buffer size we'll need for this device.\nLoop, gathering audio data and copying it to a round-robin buffer.\nWe store off all the data for the recognition thread to access. The ML\nthread will copy out of this buffer into its own, while holding the\nlock, so this should be thread safe.\nWe need to feed in float values between -1.0f and 1.0f, so divide the\nsigned 16-bit inputs.\nRun the model.\nUse the smoother to figure out if we've had a real recognition event."
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/junit5/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java",
    "type": "method",
    "name": "assertNotEquals",
    "code": "public static void assertNotEquals(int unexpected, Integer actual, String message) {\n\t\tAssertNotEquals.assertNotEquals((Integer) unexpected, actual, message);\n\t}",
    "comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/impl/maven-core/src/main/java/org/apache/maven/configuration/BasedirBeanConfigurationPathTranslator.java",
    "type": "method",
    "name": "translatePath",
    "code": "public File translatePath(File path) {\n        File result = path;\n\n        if (path != null && basedir != null) {\n            if (path.isAbsolute()) {\n            } else if (path.getPath().startsWith(File.separator)) {\n                result = path.getAbsoluteFile();\n            } else {\n                result = new File(new File(basedir, path.getPath()).toURI().normalize()).getAbsoluteFile();\n            }\n        }\n\n        return result;\n    }",
    "comment": "path is already absolute, we're done\ndrive-relative Windows path, don't align with base dir but with drive root\nan ordinary relative path, align with base dir"
  },
  {
    "file": "/mnt/c/ModelTrain/Econder-Decoder/data_collection/raw_cloned_repos/maven/compat/maven-compat/src/test/java/org/apache/maven/repository/legacy/resolver/conflict/NearestConflictResolverTest.java",
    "type": "method",
    "name": "testEqual",
    "code": "void testEqual() {\n        ResolutionNode a1n = createResolutionNode(a1);\n        ResolutionNode a2n = createResolutionNode(a2);\n\n        assertResolveConflict(a1n, a1n, a2n);\n    }",
    "comment": "Tests that <code>a:1.0</code> wins in the scenario:\n<pre>\na:1.0\na:2.0\n</pre>"
  }
]