[
    {
        "id": 0,
        "code_snippet": "public static void assertFalse(boolean condition) {\n        assertFalse(null, condition);\n    }",
        "human_comment": "Asserts that a condition is false. If it isn't it throws\nan AssertionFailedError.",
        "model_generated_comment": "Asserts that a boolean condition is false."
    },
    {
        "id": 1,
        "code_snippet": "public final void assertEventsMatchLoosely(Condition<? super Event>... conditions) {\n\t\tPreconditions.notNull(conditions, \"conditions must not be null\");\n\t\tPreconditions.containsNoNullElements(conditions, \"conditions must not contain null elements\");\n\t\tassertEventsMatchLoosely(this.events, conditions);\n\t}",
        "human_comment": "Assert that all provided conditions are matched by an {@linkplain Event event}\ncontained in this {@code Events} object, regardless of order.\n\n<p>Note that this method performs a partial match. Thus, some events may\nnot match any of the provided conditions.\n\n<p>Conditions can be imported statically from {@link EventConditions}\nand {@link TestExecutionResultConditions}.\n\n<h4>Example</h4>\n\n<pre class=\"code\">\nexecutionResults.testEvents().assertEventsMatchLoosely(\nevent(test(\"exampleTestMethod\"), started()),\nevent(test(\"exampleTestMethod\"), finishedSuccessfully())\n);\n</pre>\n\n@param conditions the conditions to match against; never {@code null}\n@since 1.7\n@see #assertEventsMatchExactly(Condition...)\n@see #assertEventsMatchLooselyInOrder(Condition...)\n@see EventConditions\n@see TestExecutionResultConditions",
        "model_generated_comment": "<em>Assert</em> that {@link Event} and {@code conditions} are equal.\n\n<p>If they are not, the failure message will be retrieved lazily from the supplied\n{@link Events#compare(events, conditions)}.\n\n@since 5.4"
    },
    {
        "id": 2,
        "code_snippet": "private List<String> extractReactorBuildOrder(List<String> loadedLines) {\n        List<String> resultingLines = new LinkedList<>();\n        boolean start = false;\n        for (String line : loadedLines) {\n            if (start) {\n                if (line.startsWith(\"[INFO] -------------\")) {\n                    start = false;\n                } else if (!line.endsWith(\"[INFO] \")) {\n                    resultingLines.add(line);\n                }\n            } else {\n                if (line.startsWith(\"[INFO] Reactor Build Order:\")) {\n                    start = true;\n                }\n            }\n        }\n        return resultingLines;\n    }",
        "human_comment": "Extract the lines at the beginning of the Maven output:\n\n<pre>\n[INFO] Reactor Build Order:\n[INFO]\n[INFO] module-1\n[INFO] module-2\n[INFO] base-project\n[INFO]\n</pre>",
        "model_generated_comment": "Extract the ReactorBuild Order from the supplied list.\n\n@param loadedLines The loaded lines to extract, may be {@code null}.\n@return the resulting list"
    },
    {
        "id": 3,
        "code_snippet": "public T addSparkArg(String name, String value) {\n    SparkSubmitOptionParser validator = new ArgumentValidator(true);\n    if (validator.MASTER.equals(name)) {\n      setMaster(value);\n    } else if (validator.REMOTE.equals(name)) {\n      setRemote(value);\n    } else if (validator.PROPERTIES_FILE.equals(name)) {\n      setPropertiesFile(value);\n    } else if (validator.CONF.equals(name)) {\n      String[] vals = value.split(\"=\", 2);\n      setConf(vals[0], vals[1]);\n    } else if (validator.CLASS.equals(name)) {\n      setMainClass(value);\n    } else if (validator.JARS.equals(name)) {\n      builder.jars.clear();\n      for (String jar : value.split(\",\")) {\n        addJar(jar);\n      }\n    } else if (validator.FILES.equals(name)) {\n      builder.files.clear();\n      for (String file : value.split(\",\")) {\n        addFile(file);\n      }\n    } else if (validator.PY_FILES.equals(name)) {\n      builder.pyFiles.clear();\n      for (String file : value.split(\",\")) {\n        addPyFile(file);\n      }\n    } else {\n      validator.parse(Arrays.asList(name, value));\n      builder.userArgs.add(name);\n      builder.userArgs.add(value);\n    }\n    return self();\n  }",
        "human_comment": "Adds an argument with a value to the Spark invocation. If the argument name corresponds to\na known argument, the code validates that the argument actually expects a value, and throws\nan exception otherwise.\n<p>\nIt is safe to add arguments modified by other methods in this class (such as\n{@link #setMaster(String)} - the last invocation will be the one to take effect.\n<p>\nUse this method with caution. It is possible to create an invalid Spark command by passing\nunknown arguments to this method, since those are allowed for forward compatibility.\n\n@since 1.5.0\n@param name Name of argument to add.\n@param value Value of the argument.\n@return This launcher.",
        "model_generated_comment": "Add a SparkArg to the argument.\n\n@param name the name of the argument\n@return true if the argument is valid"
    },
    {
        "id": 4,
        "code_snippet": "public void zip() {\n    JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1, 2, 3, 4, 5));\n    JavaDoubleRDD doubles = rdd.mapToDouble(x -> 1.0 * x);\n    JavaPairRDD<Integer, Double> zipped = rdd.zip(doubles);\n    zipped.count();\n  }",
        "human_comment": "Try reading the output back as an object file",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 5,
        "code_snippet": "public String execute(Order order) {\n    var result = super.execute(order);\n    var name = order.getName();\n    if (name == null || name.isEmpty() || name.matches(\".*[^\\\\w|\\\\s]+.*\")) {\n      return result + \"Invalid name! \";\n    } else {\n      return result;\n    }\n  }",
        "human_comment": "Concrete implementation of filter. This filter checks if the input in the Name field is valid.\n(alphanumeric)",
        "model_generated_comment": "Execute the given order.\n\n@param order the order to execute\n@return the result"
    },
    {
        "id": 6,
        "code_snippet": "default Map<String, String> init(SparkContext sc, PluginContext pluginContext) {\n    return Collections.emptyMap();\n  }",
        "human_comment": "Initialize the plugin.\n<p>\nThis method is called early in the initialization of the Spark driver. Explicitly, it is\ncalled before the Spark driver's task scheduler is initialized. This means that a lot\nof other Spark subsystems may yet not have been initialized. This call also blocks driver\ninitialization.\n<p>\nIt's recommended that plugins be careful about what operations are performed in this call,\npreferably performing expensive operations in a separate thread, or postponing them until\nthe application has fully started.\n\n@param sc The SparkContext loading the plugin.\n@param pluginContext Additional plugin-specific about the Spark application where the plugin\nis running.\n@return A map that will be provided to the {@link ExecutorPlugin#init(PluginContext,Map)}\nmethod.",
        "model_generated_comment": "Create a new Map using the provided SparkContext.\n\n@param sc The SparkContext to add to the new Map.\n@return The new Map"
    },
    {
        "id": 7,
        "code_snippet": "public static DynamicTest dynamicTest(String displayName, Executable executable) {\n\t\treturn new DynamicTest(displayName, null, executable);\n\t}",
        "human_comment": "Factory for creating a new {@code DynamicTest} for the supplied display\n@param executable the executable code block for the dynamic test;\nnever {@code null}\n@see #stream(Iterator, Function, ThrowingConsumer)",
        "model_generated_comment": "Create a new {@link DynamicTest} with the supplied display name and executable.\n\n@param displayName the display name; never {@code null}\n@return a new dynamicTest"
    },
    {
        "id": 8,
        "code_snippet": "public void setProjects(List<MavenProject> projects) {\n        if (!projects.isEmpty()) {\n            MavenProject first = projects.get(0);\n            this.currentProject = ThreadLocal.withInitial(() -> first);\n            this.topLevelProject = projects.stream()\n                    .filter(project -> project.isExecutionRoot())\n                    .findFirst()\n                    .orElse(first);\n        } else {\n            this.currentProject = new ThreadLocal<>();\n            this.topLevelProject = null;\n        }\n        this.projects = projects;\n    }",
        "human_comment": "Plugin context keyed by project ({@link MavenProject#getId()}) and by plugin lookup key\n({@link PluginDescriptor#getPluginLookupKey()}). Plugin contexts itself are mappings of {@link String} keys to\n{@link Object} values.",
        "model_generated_comment": "Set the projects of the given project.\n\n@param projects The project to set, may be {@code null}."
    },
    {
        "id": 9,
        "code_snippet": "void testGetColumnNumber() {\n        DefaultProblem problem = new DefaultProblem(null, null, null, -1, -1, null);\n        assertEquals(-1, problem.getColumnNumber());\n\n        problem = new DefaultProblem(null, null, null, -1, 42, null);\n        assertEquals(42, problem.getColumnNumber());\n\n        problem = new DefaultProblem(null, null, null, -1, Integer.MAX_VALUE, null);\n        assertEquals(Integer.MAX_VALUE, problem.getColumnNumber());\n\n        problem = new DefaultProblem(null, null, null, -1, Integer.MIN_VALUE, null);\n        assertEquals(Integer.MIN_VALUE, problem.getColumnNumber());\n    }",
        "human_comment": "this case is not specified, might also return -1",
        "model_generated_comment": "Unit tests for {@link DefaultProblem}.\n\n@param problem {@code null}"
    },
    {
        "id": 10,
        "code_snippet": "public AssumptionViolatedException(Object value, Matcher<?> matcher) {\n        this(null, true, value, matcher);\n    }",
        "human_comment": "An assumption exception with the given <i>value</i> (String or\nThrowable) and an additional failing {@link Matcher}.\n\n@deprecated Please use {@link org.junit.AssumptionViolatedException} instead.",
        "model_generated_comment": "<em>AssumptionViolatedException</em> for {@code value}.\n\n@param value the value to throw."
    },
    {
        "id": 11,
        "code_snippet": "public List<Exception> validateAnnotatedClass(TestClass testClass) {\n        return NO_VALIDATION_ERRORS;\n    }",
        "human_comment": "Validates annotation on the given class.\n\n@param testClass that is being validated\n@return A list of exceptions. Default behavior is to return an empty list.\n\n@since 4.12",
        "model_generated_comment": "Validate an annotated class.\n\n@param testClass the class to validate.\n@return An annotated list of annotated classes."
    },
    {
        "id": 12,
        "code_snippet": "public void run() {\n    var count = this.msgCount;\n\n    try {\n      while (count > 0) {\n        var statusMsg = \"Message-\" + count + \" submitted by \" + Thread.currentThread().getName();\n        this.submit(new Message(statusMsg));\n\n        LOGGER.info(statusMsg);\n\n        // reduce the message count.\n        count--;\n\n        // Make the current thread to sleep after every Message submission.\n        Thread.sleep(1000);\n      }\n    } catch (Exception e) {\n      LOGGER.error(e.getMessage());\n    }\n  }",
        "human_comment": "Each TaskGenerator thread will submit all the messages to the Queue. After every message\nsubmission TaskGenerator thread will sleep for 1 second.",
        "model_generated_comment": "Run the current thread to sleep after every message submission.\n\n@param count The number of messages submitted by this thread."
    },
    {
        "id": 13,
        "code_snippet": "protected void processGameLoop() {\n    var lastFrameTime = System.currentTimeMillis();\n    while (isGameRunning()) {\n      processInput();\n      var currentFrameTime = System.currentTimeMillis();\n      var elapsedTime = currentFrameTime - lastFrameTime;\n      update(elapsedTime);\n      lastFrameTime = currentFrameTime;\n      render();\n    }\n  }",
        "human_comment": "The variable-step game loop chooses a time step to advance based on how much real time passed\nsince the last frame. The longer the frame takes, the bigger steps the game takes. It always\nkeeps up with real time because it will take bigger and bigger steps to get there.",
        "model_generated_comment": "Processes the game loop.\n\n@param lastFrameTime The last frame time of the game."
    },
    {
        "id": 14,
        "code_snippet": "private static boolean isValidContinuationByte(byte b) {\n     return b >= (byte) 0x80 && b <= (byte) 0xBF;\n  }",
        "human_comment": "Utility methods and constants for UTF-8 string validation.",
        "model_generated_comment": "Returns whether the given byte is valid.\n\n@param b the byte to check."
    },
    {
        "id": 15,
        "code_snippet": "void testGatewayFactoryRegistrationAndRetrieval() {\n    Gateway serviceA = gatewayFactory.getGateway(\"ServiceA\");\n    Gateway serviceB = gatewayFactory.getGateway(\"ServiceB\");\n    Gateway serviceC = gatewayFactory.getGateway(\"ServiceC\");\n\n    assertTrue(\n        serviceA instanceof ExternalServiceA, \"ServiceA should be an instance of ExternalServiceA\");\n    assertTrue(\n        serviceB instanceof ExternalServiceB, \"ServiceB should be an instance of ExternalServiceB\");\n    assertTrue(\n        serviceC instanceof ExternalServiceC, \"ServiceC should be an instance of ExternalServiceC\");\n  }",
        "human_comment": "Check if the retrieved instances match their expected types",
        "model_generated_comment": "Unit tests for {@link GatewayFactory}.\n\n@since 5.0"
    },
    {
        "id": 16,
        "code_snippet": "public Builder privateKeyPassword(String privateKeyPassword) {\n      this.privateKeyPassword = privateKeyPassword;\n      return this;\n    }",
        "human_comment": "Sets the private key password\n\n@param privateKeyPassword The password for the private key\n@return The builder object",
        "model_generated_comment": "Create a new {@code privateKeyPassword} with the supplied password.\n\n@param privateKey password the password to use\n@return this builder"
    },
    {
        "id": 17,
        "code_snippet": "void metadataPath4(ExecutorHelper.Mode mode) {\n        ExecutorHelper helper = new HelperImpl(\n                mode,\n                mvn4ExecutorRequestBuilder().build().installationDirectory(),\n                userHome,\n                MavenExecutorTestSupport.EMBEDDED_MAVEN_EXECUTOR,\n                MavenExecutorTestSupport.FORKED_MAVEN_EXECUTOR);\n        String path = new ToolboxTool(helper).metadataPath(helper.executorRequest(), \"aopalliance\", \"someremote\");\n        assertTrue(path.endsWith(\"aopalliance\" + File.separator + \"maven-metadata-someremote.xml\"), \"path=\" + path);\n    }",
        "human_comment": "split repository: assert \"ends with\" as split may introduce prefixes",
        "model_generated_comment": "Creates a new {@link MavenExecutorRequest} with the specified mode.\n\n@param mode the mode to use\n@return a new Maven ExecutorRequest"
    },
    {
        "id": 18,
        "code_snippet": "private static String[] doCleanArgs(String[] args) {\n        List<String> cleaned = new ArrayList<>();\n\n        StringBuilder currentArg = null;\n\n        for (String arg : args) {\n            boolean addedToBuffer = false;\n\n            if (arg.startsWith(\"\\\"\")) {\n                if (currentArg != null) {\n                    cleaned.add(currentArg.toString());\n                }\n\n                currentArg = new StringBuilder(arg.substring(1));\n                addedToBuffer = true;\n            }\n\n            if (addedToBuffer && arg.endsWith(\"\\\"\")) {\n                if (!currentArg.isEmpty()) {\n                    currentArg.setLength(currentArg.length() - 1);\n                }\n\n                cleaned.add(currentArg.toString());\n\n                currentArg = null;\n                continue;\n            }\n\n            if (!addedToBuffer) {\n                if (currentArg != null) {\n                    currentArg.append(' ').append(arg);\n                } else {\n                    cleaned.add(arg);\n                }\n            }\n        }\n\n        if (currentArg != null) {\n            cleaned.add(currentArg.toString());\n        }\n\n        int cleanedSz = cleaned.size();\n\n        String[] cleanArgs;\n\n        if (cleanedSz == 0) {\n            cleanArgs = args;\n        } else {\n            cleanArgs = cleaned.toArray(new String[0]);\n        }\n\n        return cleanArgs;\n    }",
        "human_comment": "if we're in the process of building up another arg, push it and start over.\nthis is for the case: \"-Dfoo=bar \"-Dfoo2=bar two\" (note the first unterminated quote)\nstart building an argument here.\nthis has to be a separate \"if\" statement, to capture the case of: \"-Dfoo=bar\"\nif we're building an argument, keep doing so.\nif this is the case of \"-Dfoo=bar\", then we need to adjust the buffer.\nif we haven't added this arg to the buffer, and we ARE building an argument\nbuffer, then append it with a preceding space...again, not sure what else to\ndo other than collapse whitespace.\nNOTE: The case of a trailing quote is handled by nullifying the arg buffer.",
        "model_generated_comment": "Create a new list of args.\n\n@param args The args to add to the list, may be {@code null}."
    },
    {
        "id": 19,
        "code_snippet": "public GraphOperation operation(String name) {\n    synchronized (nativeHandleLock) {\n      long oph = operation(nativeHandle, name);\n      if (oph == 0) {\n        return null;\n      }\n      return new GraphOperation(this, oph);\n    }\n  }",
        "human_comment": "Returns the operation (node in the Graph) with the provided name.\n\n<p>Or {@code null} if no such operation exists in the Graph.",
        "model_generated_comment": "Creates a new GraphOperation with the given name.\n\n@param name the name of the operation.\n@return {@code GraphOperation}"
    },
    {
        "id": 20,
        "code_snippet": "public Object getConfiguration() {\n        return this.configuration;\n    } // -- Object getConfiguration()",
        "human_comment": "Get configuration to pass to all goals run in this phase.\n\n@return Object",
        "model_generated_comment": "Returns the configuration of this object.\n\n@return this object"
    },
    {
        "id": 21,
        "code_snippet": "public int hashCode() {\n    return Murmur3_x86_32.hashUnsafeBytes(baseObject, baseOffset, sizeInBytes, 42);\n  }",
        "human_comment": "This `hashCode` computation could consume much processor time for large data.\nIf the computation becomes a bottleneck, we can use a light-weight logic; the first fixed bytes\nare used to compute `hashCode` (See `Vector.hashCode`).\nThe same issue exists in `UnsafeRow.hashCode`.",
        "model_generated_comment": "Creates a new hash code.\n\n@param baseObject the base object of the hash code\n@return the new hashCode"
    },
    {
        "id": 22,
        "code_snippet": "static long plusMillis(long time, long millis) {\n      return CLOCK.plusMillis0(time, millis);\n   }",
        "human_comment": "Return the specified opaque time-stamp plus the specified number of milliseconds.\n\n@param time an opaque time-stamp\n@param millis milliseconds to add\n@return a new opaque time-stamp",
        "model_generated_comment": "Returns the value of the given time.\n\n@param time the time to check."
    },
    {
        "id": 23,
        "code_snippet": "private String escapeSlashes(String name) {\n        return SLASHES.matcher(name).replaceAll(\"_\");\n    }",
        "human_comment": "ganglia metric names can't contain slashes.",
        "model_generated_comment": "Sets the name of a slash.\n\n@param name The name of the slash."
    },
    {
        "id": 24,
        "code_snippet": "public KVStoreView<T> index(String name) {\n    this.index = Preconditions.checkNotNull(name);\n    return this;\n  }",
        "human_comment": "Iterates according to the given index.",
        "model_generated_comment": "Returns the index of the KVStoreView.\n\n@param name the name of the store.\n@return this index"
    },
    {
        "id": 25,
        "code_snippet": "protected static Size chooseOptimalSize(final Size[] choices, final int width, final int height) {\n    final int minSize = Math.max(Math.min(width, height), MINIMUM_PREVIEW_SIZE);\n    final Size desiredSize = new Size(width, height);\n\n    // Collect the supported resolutions that are at least as big as the preview Surface\n    boolean exactSizeFound = false;\n    final List<Size> bigEnough = new ArrayList<Size>();\n    final List<Size> tooSmall = new ArrayList<Size>();\n    for (final Size option : choices) {\n      if (option.equals(desiredSize)) {\n        // Set the size but don't return yet so that remaining sizes will still be logged.\n        exactSizeFound = true;\n      }\n\n      if (option.getHeight() >= minSize && option.getWidth() >= minSize) {\n        bigEnough.add(option);\n      } else {\n        tooSmall.add(option);\n      }\n    }\n\n    LOGGER.i(\"Desired size: \" + desiredSize + \", min size: \" + minSize + \"x\" + minSize);\n    LOGGER.i(\"Valid preview sizes: [\" + TextUtils.join(\", \", bigEnough) + \"]\");\n    LOGGER.i(\"Rejected preview sizes: [\" + TextUtils.join(\", \", tooSmall) + \"]\");\n\n    if (exactSizeFound) {\n      LOGGER.i(\"Exact size match found.\");\n      return desiredSize;\n    }\n\n    // Pick the smallest of those, assuming we found any\n    if (bigEnough.size() > 0) {\n      final Size chosenSize = Collections.min(bigEnough, new CompareSizesByArea());\n      LOGGER.i(\"Chosen size: \" + chosenSize.getWidth() + \"x\" + chosenSize.getHeight());\n      return chosenSize;\n    } else {\n      LOGGER.e(\"Couldn't find any suitable preview size\");\n      return choices[0];\n    }\n  }",
        "human_comment": "Given {@code choices} of {@code Size}s supported by a camera, chooses the smallest one whose\nwidth and height are at least as large as the minimum of both, or an exact match if possible.\n\n@param choices The list of sizes that the camera supports for the intended output class\n@param width The minimum desired width\n@param height The minimum desired height\n@return The optimal {@code Size}, or an arbitrary one if none were big enough",
        "model_generated_comment": "Sets the size of the preview.\n\n@param choices the size to choose.\n@return The size to select."
    },
    {
        "id": 26,
        "code_snippet": "static String quoteForCommandString(String s) {\n    StringBuilder quoted = new StringBuilder().append('\"');\n    for (int i = 0; i < s.length(); i++) {\n      int cp = s.codePointAt(i);\n      if (cp == '\"' || cp == '\\\\') {\n        quoted.appendCodePoint('\\\\');\n      }\n      quoted.appendCodePoint(cp);\n    }\n    return quoted.append('\"').toString();\n  }",
        "human_comment": "Quotes a string so that it can be used in a command string.\nBasically, just add simple escapes. E.g.:\noriginal single argument : ab \"cd\" ef\nafter: \"ab \\\"cd\\\" ef\"\n\nThis can be parsed back into a single argument by python's \"shlex.split()\" function.",
        "model_generated_comment": "Prints a quote for command string.\n\n@param s the command string to quote.\n@return the quote"
    },
    {
        "id": 27,
        "code_snippet": "private Saga() {\n    this.chapters = new ArrayList<>();\n  }",
        "human_comment": "Saga representation. Saga consists of chapters. Every ChoreographyChapter is executed by a\ncertain service.",
        "model_generated_comment": "Creates a new Saga instance.\n\n@param chapters the Saga instance\n@return a Saga instance"
    },
    {
        "id": 28,
        "code_snippet": "public Events succeeded() {\n\t\treturn new Events(finishedEventsByStatus(Status.SUCCESSFUL), this.category + \" Successful\");\n\t}",
        "human_comment": "Get the succeeded {@link Events} contained in this {@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}",
        "model_generated_comment": "Create a new {@link Events} based on the given {@code Events} and\n{@link Status}.\n\n<p>If the event is successful, the\nnew event will be called.\n\n@param status the status of the event\n@return a new{@code Event} with the same name\n@see #success()"
    },
    {
        "id": 29,
        "code_snippet": "Boolean validateProduct() {\n    try {\n      ResponseEntity<Boolean> productValidationResult =\n          restTemplateBuilder\n              .build()\n              .postForEntity(\n                  \"http://localhost:30302/product/validate\", \"validating product\", Boolean.class);\n      LOGGER.info(\"Product validation result: {}\", productValidationResult.getBody());\n      return productValidationResult.getBody();\n    } catch (ResourceAccessException | HttpClientErrorException e) {\n      LOGGER.error(\"Error communicating with product service: {}\", e.getMessage());\n      return false;\n    }\n  }",
        "human_comment": "Validates the product by calling the respective microservice.\n\n@return true if the product is valid, false otherwise.",
        "model_generated_comment": "Converts the supplied product to a {@link ProductValidationResult} object.\n\n@return true if the product is valid"
    },
    {
        "id": 30,
        "code_snippet": "public void initDb() {\n        // using an in-memory database because the information stored here disappears when the\n        // process is killed\n        mDatabase = Room.inMemoryDatabaseBuilder(ApplicationProvider.getApplicationContext(),\n                UsersDatabase.class)\n                // allowing main thread queries, just for testing\n                .allowMainThreadQueries()\n                .build();\n    }",
        "human_comment": "Test the implementation of {@link UserDao}",
        "model_generated_comment": "Initializes the user database.\n\n@param userDatabase The user database, may be {@code null}."
    },
    {
        "id": 31,
        "code_snippet": "void testSmokeEveryThingThroughInjectionFramework() {\n\n    List<Class<? extends Tobacco>> tobaccos =\n        List.of(OldTobyTobacco.class, RivendellTobacco.class, SecondBreakfastTobacco.class);\n\n    // Configure the tobacco in the injection framework ...\n    // ... and create a new wizard with it\n    // Verify if the wizard is smoking the correct tobacco ...\n    tobaccos.forEach(\n        tobaccoClass -> {\n          final var injector =\n              Guice.createInjector(\n                  new AbstractModule() {\n                  });\n          final var guiceWizard = injector.getInstance(GuiceWizard.class);\n          guiceWizard.smoke();\n          String lastMessage = appender.getLastMessage();\n          assertEquals(\"GuiceWizard smoking \" + tobaccoClass.getSimpleName(), lastMessage);\n        });\n\n    // ... and nothing else is happening.\n    assertEquals(tobaccos.size(), appender.getLogSize());\n  }",
        "human_comment": "Test if the {@link GuiceWizard} smokes whatever instance of {@link Tobacco} is passed to him\nthrough the Guice google inject framework",
        "model_generated_comment": "TODO, this is a test set for {@link GuiceWizard}.\n\n@param tobacco class The class to test, may be {@code OldTobyTobacco}."
    },
    {
        "id": 32,
        "code_snippet": "public Type getType() {\n        String type = dependency.getArtifact().getProperty(ArtifactProperties.TYPE, getExtension());\n        return session.requireType(type);\n    }",
        "human_comment": "{@return the type of the wrapped dependency}\nThe default implementation infers the type from the properties associated to the Eclipse Aether artifact.",
        "model_generated_comment": "Get the type of the dependency.\n\n@param type the type to get\n@return the type"
    },
    {
        "id": 33,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaLogisticRegressionSummaryExample\")\n      .getOrCreate();\n\n    Dataset<Row> training = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_libsvm_data.txt\");\n\n    LogisticRegression lr = new LogisticRegression()\n      .setMaxIter(10)\n      .setRegParam(0.3)\n      .setElasticNetParam(0.8);\n\n    LogisticRegressionModel lrModel = lr.fit(training);\n\n    BinaryLogisticRegressionTrainingSummary trainingSummary = lrModel.binarySummary();\n\n    double[] objectiveHistory = trainingSummary.objectiveHistory();\n    for (double lossPerIteration : objectiveHistory) {\n      System.out.println(lossPerIteration);\n    }\n\n    Dataset<Row> roc = trainingSummary.roc();\n    roc.show();\n    roc.select(\"FPR\").show();\n    System.out.println(trainingSummary.areaUnderROC());\n\n    Dataset<Row> fMeasure = trainingSummary.fMeasureByThreshold();\n    double maxFMeasure = fMeasure.select(functions.max(\"F-Measure\")).head().getDouble(0);\n    double bestThreshold = fMeasure.where(fMeasure.col(\"F-Measure\").equalTo(maxFMeasure))\n      .select(\"threshold\").head().getDouble(0);\n    lrModel.setThreshold(bestThreshold);\n\n    spark.stop();\n  }",
        "human_comment": "$example on$\n$example off$\nLoad training data\nFit the model\n$example on$\nExtract the summary from the returned LogisticRegressionModel instance trained in the earlier\nexample\nObtain the loss per iteration.\nObtain the receiver-operating characteristic as a dataframe and areaUnderROC.\nGet the threshold corresponding to the maximum F-Measure and rerun LogisticRegression with\nthis selected threshold.\n$example off$",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 34,
        "code_snippet": "public void setArtifactFilter(ArtifactFilter artifactFilter) {\n        this.artifactFilter = artifactFilter;\n        this.artifacts = null;\n        this.artifactMap = null;\n    }",
        "human_comment": "Sets the scope filter to select the artifacts being exposed to the currently executed mojo.\n<strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not\npart of the public API. In particular, this method can be changed or deleted without prior notice and must not be\nused by plugins.\n\n@param artifactFilter The artifact filter, may be {@code null} to exclude all artifacts.",
        "model_generated_comment": "Set the artifact filter.\n\n@param artifactFilter The artifact filter to set."
    },
    {
        "id": 35,
        "code_snippet": "public void putSource(String groupId, String artifactId, ModelSource source) {\n            mappedSources\n                    .computeIfAbsent(new GAKey(groupId, artifactId), k -> new HashSet<>())\n                    .add(source);\n            if (groupId != null) {\n                putSource(null, artifactId, source);\n            }\n        }",
        "human_comment": "Also  register the source under the null groupId",
        "model_generated_comment": "Put the source of the given source into a new {@link GAKey}.\n\n@param groupId The groupId of the source, may be {@code null}."
    },
    {
        "id": 36,
        "code_snippet": "public InterpreterApi create(@NonNull ByteBuffer byteBuffer, InterpreterApi.Options options) {\n    return InterpreterApi.create(byteBuffer, options);\n  }",
        "human_comment": "Constructs an {@link InterpreterApi} instance, using the specified model and options. The model\nwill be read from a {@code ByteBuffer}.\n\n@param byteBuffer A pre-trained TF Lite model, in binary serialized form. The ByteBuffer should\nnot be modified after the construction of an {@link InterpreterApi} instance. The {@code\nByteBuffer} can be either a {@code MappedByteBuffer} that memory-maps a model file, or a\ndirect {@code ByteBuffer} of nativeOrder() that contains the bytes content of a model.\n@param options A set of options for customizing interpreter behavior.\n@throws IllegalArgumentException if {@code byteBuffer} is not a {@code MappedByteBuffer} nor a\ndirect {@code ByteBuffer} of nativeOrder.",
        "model_generated_comment": "Creates a new {@code InterpreterApi} with the supplied byte buffer.\n\n@param byteBuffer the byte buffer to put into the new interface."
    },
    {
        "id": 37,
        "code_snippet": "public Avg(Expression column, boolean isDistinct) {\n    this.input = column;\n    this.isDistinct = isDistinct;\n  }",
        "human_comment": "An aggregate function that returns the mean of all the values in a group.\n\n@since 3.3.0",
        "model_generated_comment": "<em>Avg</em> of {@code isDistinct} columns.\n\n@param column the column to compare to\n@return Avg(Expression)"
    },
    {
        "id": 38,
        "code_snippet": "public CartController(final ShoppingCartService shoppingCart) {\n    this.shoppingCartUseCase = shoppingCart;\n  }",
        "human_comment": "Constructs a CartController with the specified shopping cart service.\n\n@param shoppingCart The shopping cart service to handle cart operations.",
        "model_generated_comment": "Creates a new CartController for the supplied shoppingCart.\n\n@param shoppingCart the shoppingCart to use."
    },
    {
        "id": 39,
        "code_snippet": "public KVStoreView<T> last(Object value) {\n    this.last = value;\n    return this;\n  }",
        "human_comment": "Stops iteration at the given value of the chosen index (inclusive).",
        "model_generated_comment": "Returns the value of the KVStoreView.\n\n@param value the value to store."
    },
    {
        "id": 40,
        "code_snippet": "public XXH64(long seed) {\n    super();\n    this.seed = seed;\n  }",
        "human_comment": "xxHash64. A high quality and fast 64 bit hash code by Yann Colet and Mathias Westerdahl. The\nclass below is modelled like its Murmur3_x86_32 cousin.\n<p/>\nThis was largely based on the following (original) C and Java implementations:\nhttps://github.com/Cyan4973/xxHash/blob/master/xxhash.c\nhttps://github.com/OpenHFT/Zero-Allocation-Hashing/blob/master/src/main/java/net/openhft/hashing/XxHash_r39.java\nhttps://github.com/airlift/slice/blob/master/src/main/java/io/airlift/slice/XxHash64.java",
        "model_generated_comment": "Creates a new {@link XXH64} with the given seed."
    },
    {
        "id": 41,
        "code_snippet": "public ReactorBuildStatus(ProjectDependencyGraph projectDependencyGraph) {\n        this.projectDependencyGraph = projectDependencyGraph;\n    }",
        "human_comment": "Contains status information that is global to an entire reactor build.\n\n@since 3.0",
        "model_generated_comment": "Creates a new {@link ProjectDependencyGraph}.\n\n@since 1.0"
    },
    {
        "id": 42,
        "code_snippet": "public static void assertEquals(Integer expected, Integer actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@link Integer#equals(Object)}\n\n@since 5.4"
    },
    {
        "id": 43,
        "code_snippet": "public boolean isUpdateRequired(RepositoryMetadata metadata, ArtifactRepository repository, File file) {\n        ArtifactRepositoryPolicy policy = metadata.getPolicy(repository);\n\n        if (!policy.isEnabled()) {\n            if (getLogger().isDebugEnabled()) {\n                getLogger()\n                        .debug(\"Skipping update check for \" + metadata.getKey() + \" (\" + file + \") from \"\n                                + repository.getId() + \" (\" + repository.getUrl() + \")\");\n            }\n\n            return false;\n        }\n\n        if (getLogger().isDebugEnabled()) {\n            getLogger()\n                    .debug(\"Determining update check for \" + metadata.getKey() + \" (\" + file + \") from \"\n                            + repository.getId() + \" (\" + repository.getUrl() + \")\");\n        }\n\n        if (file == null) {\n            return true;\n        }\n\n        Date lastCheckDate = readLastUpdated(metadata, repository, file);\n\n        return (lastCheckDate == null) || policy.checkOutOfDate(lastCheckDate);\n    }",
        "human_comment": "Here, we need to determine which policy to use. Release updateInterval will be used when\nthe metadata refers to a release artifact or meta-version, and snapshot updateInterval will be used when\nit refers to a snapshot artifact or meta-version.\nNOTE: Release metadata includes version information about artifacts that have been released, to allow\nmeta-versions like RELEASE and LATEST to resolve, and also to allow retrieval of the range of valid, released\nartifacts available.\nTODO throw something instead?",
        "model_generated_comment": "Determines if update is required.\n\n@param metadata the metadata to check, may be {@code null}.\n@return true if update isn't required."
    },
    {
        "id": 44,
        "code_snippet": "public static RuleChain outerRule(TestRule outerRule) {\n        return emptyRuleChain().around(outerRule);\n    }",
        "human_comment": "Returns a {@code RuleChain} with a single {@link TestRule}. This method\nis the usual starting point of a {@code RuleChain}.\n\n@param outerRule the outer rule of the {@code RuleChain}.\n@return a {@code RuleChain} with a single {@link TestRule}.",
        "model_generated_comment": "Creates a new RuleChain with the given outerRule.\n\n@param outerRule the outerRule\n@return an empty RuleChain"
    },
    {
        "id": 45,
        "code_snippet": "public static void assertEquals(char expected, Character actual, String message) {\n\t\tAssertEquals.assertEquals((Character) expected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 46,
        "code_snippet": "public Builder certChain(File certChain) {\n      this.certChain = certChain;\n      return this;\n    }",
        "human_comment": "Sets a X.509 certificate chain file in PEM format\n\n@param certChain The certificate chain file to use\n@return The builder object",
        "model_generated_comment": "Creates a new {@link Builder}.\n\n@param certChain the {@code File} to build.\n@return this builder."
    },
    {
        "id": 47,
        "code_snippet": "public void then(BuildPlan step) {\n        step.plan.forEach((k, v) -> plan.merge(k, v, this::merge));\n        aliases.putAll(step.aliases);\n    }",
        "human_comment": "add a follow-up plan to this one",
        "model_generated_comment": "Merges all the steps in the build plan.\n\n@param step The step to merge."
    },
    {
        "id": 48,
        "code_snippet": "public SagaOrchestrator(Saga saga, ServiceDiscoveryService sd) {\n    this.saga = saga;\n    this.sd = sd;\n    this.state = new CurrentState();\n  }",
        "human_comment": "Create a new service to orchetrate sagas.\n\n@param saga saga to process\n@param sd service discovery @see {@link ServiceDiscoveryService}",
        "model_generated_comment": "Creates a new {@link SagaOrchestrator}.\n\n@param saga The saga of the {@code Saga}\n@return a new <code>Saga</code>\n@throws NullPointerException if the saga is null"
    },
    {
        "id": 49,
        "code_snippet": "public Builder enableTestEngineAutoRegistration(boolean enabled) {\n\t\t\tthis.engineAutoRegistrationEnabled = enabled;\n\t\t\treturn this;\n\t\t}",
        "human_comment": "Configure the auto-registration flag for test engines.\n\n<p>Defaults to {@code true}.\n\n@param enabled {@code true} if test engines should be automatically\nregistered\n@return this builder for method chaining",
        "model_generated_comment": "Enable {@link TestEngineAutoRegistrationEnabled}.\n\n@since 5.0"
    },
    {
        "id": 50,
        "code_snippet": "void expectedExceptionIsProcessedCorrectly() {\n\t\tEvents tests = executeTestsForClass(ExpectedExceptionTestCase.class);\n\n\t\ttests.assertStatistics(stats -> stats.started(4).succeeded(1).aborted(0).failed(3));\n\n\t\ttests.succeeded().assertThatEvents().have(\n\t\t\tevent(test(\"correctExceptionExpectedThrown\"), finishedSuccessfully()));\n\n\t\ttests.failed().assertThatEvents()//\n\t\t\t\t.haveExactly(1, //\n\t\t\t\t\tevent(test(\"noExceptionExpectedButThrown\"), //\n\t\t\t\t\t\tfinishedWithFailure(message(\"no exception expected\")))) //\n\t\t\t\t.haveExactly(1, //\n\t\t\t\t\tevent(test(\"exceptionExpectedButNotThrown\"), //\n\t\t\t\t\t\tfinishedWithFailure(instanceOf(AssertionError.class), //\n\t\t\t\t\t\t\tmessage(\"Expected test to throw an instance of java.lang.RuntimeException\")))) //\n\t\t\t\t.haveExactly(1, //\n\t\t\t\t\tevent(test(\"wrongExceptionExpected\"), //\n\t\t\t\t\t\tfinishedWithFailure(instanceOf(AssertionError.class), //\n\t\t\t\t\t\t\tmessage(value -> value.contains(\"Expected: an instance of java.io.IOException\")))));\n\t}",
        "human_comment": "Integration tests for {@link ExpectedExceptionSupport}.\n\n@since 5.0",
        "model_generated_comment": "Unit tests for {@link ExpectedExceptionTestCase}.\n\n@since 5.0"
    },
    {
        "id": 51,
        "code_snippet": "public static String bytesToString(ByteBuffer b) {\n    return StandardCharsets.UTF_8.decode(b.slice()).toString();\n  }",
        "human_comment": "Convert the given byte buffer to a string. The resulting string can be\nconverted back to the same byte buffer through {@link #stringToBytes(String)}.",
        "model_generated_comment": "Creates a string representation of bytes from a byte buffer.\n\n@param b the byte buffer to put into the string representation.\n@return The string representation"
    },
    {
        "id": 52,
        "code_snippet": "public Set<Artifact> getArtifacts() {\n        if (artifacts == null) {\n            if (artifactFilter == null || resolvedArtifacts == null) {\n                artifacts = new LinkedHashSet<>();\n            } else {\n                artifacts = new LinkedHashSet<>(resolvedArtifacts.size() * 2);\n                for (Artifact artifact : resolvedArtifacts) {\n                    if (artifactFilter.include(artifact)) {\n                        artifacts.add(artifact);\n                    }\n                }\n            }\n        }\n        return artifacts;\n    }",
        "human_comment": "All dependencies that this project has, including transitive ones. Contents are lazily populated, so depending on\nwhat phases have run dependencies in some scopes won't be included. e.g. if only compile phase has run,\ndependencies with scope test won't be included.\n\n@return {@link Set} &lt; {@link Artifact} &gt;\n@see #getDependencyArtifacts() to get only direct dependencies",
        "model_generated_comment": "Get the resolved artifacts of the given artifact.\n\n@param artifact The artifact to get, may be {@code null}."
    },
    {
        "id": 53,
        "code_snippet": "public Map<String, Lifecycle> getPhaseToLifecycleMap() {\n        return defaultLifeCycles.getPhaseToLifecycleMap();\n    }",
        "human_comment": "USED BY MAVEN HELP PLUGIN",
        "model_generated_comment": "Get the phase to lifecycle map.\n\n@param lifecycle The lifecycle of the lifecycle.\n@return the phase map"
    },
    {
        "id": 54,
        "code_snippet": "void resetForNewPage(int totalValuesInPage, long pageFirstRowIndex) {\n    this.valuesToReadInPage = totalValuesInPage;\n    this.rowId = pageFirstRowIndex;\n  }",
        "human_comment": "Must be called at the beginning of reading a new page.",
        "model_generated_comment": "Reset all values in the new page.\n\n@param totalValuesInPage the number of values to read"
    },
    {
        "id": 55,
        "code_snippet": "public ProjectBuilderRequestBuilder processPlugins(boolean processPlugins) {\n            this.processPlugins = processPlugins;\n            return this;\n        }",
        "human_comment": "Sets whether plugins should be processed during project building.\nWhen true, the builder will process plugin information which may include\nresolving plugin dependencies and executing plugin goals that participate in project building.\n\n@param processPlugins true if plugins should be processed, false otherwise\n@return this builder instance",
        "model_generated_comment": "Creates a request builder for {@link ProjectBuilderRequestBuilder}.\n\n@param processPlugins\n@return this request builder"
    },
    {
        "id": 56,
        "code_snippet": "public void preDestroyTestInstance(ExtensionContext context) {\n\t\tThrowableCollector throwableCollector = new ThrowableCollector(__ -> false);\n\t\tTestInstancePreDestroyCallback.preDestroyTestInstances(context,\n\t\t\ttestInstance -> closeFields(testInstance.getClass(), testInstance, throwableCollector));\n\t\tthrowableCollector.assertEmpty();\n\t}",
        "human_comment": "{@code AutoCloseExtension} is a JUnit Jupiter extension that closes resources\nif a field in a test class is annotated with {@link AutoClose @AutoClose}.\n\n<p>Consult the Javadoc for {@code @AutoClose} for details on the contract.\n\n@since 5.11\n@see AutoClose",
        "model_generated_comment": "Create a new {@link ThrowableCollector}.\n\n@since 5.4"
    },
    {
        "id": 57,
        "code_snippet": "public static Expression getOperatorInstance(String s, Expression left, Expression right) {\n    return switch (s) {\n      case \"+\" -> new PlusExpression(left, right);\n      case \"-\" -> new MinusExpression(left, right);\n      default -> new MultiplyExpression(left, right);\n    };\n  }",
        "human_comment": "Returns correct expression based on the parameters.\n\n@param s input string\n@param left expression\n@param right expression\n@return expression",
        "model_generated_comment": "Creates an instance of {@link OperatorInstance}.\n\n@param s An instance of the {@code Operator}\n@return the operator instance"
    },
    {
        "id": 58,
        "code_snippet": "public void safeLookup(Object keyBase, long keyOffset, int keyLength, Location loc, int hash) {\n    assert(longArray != null);\n\n    numKeyLookups++;\n\n    int pos = hash & mask;\n    int step = 1;\n    while (true) {\n      numProbes++;\n      if (longArray.get(pos * 2) == 0) {\n        // This is a new key.\n        loc.with(pos, hash, false);\n        return;\n      } else {\n        long stored = longArray.get(pos * 2 + 1);\n        if ((int) (stored) == hash) {\n          // Full hash code matches.  Let's compare the keys for equality.\n          loc.with(pos, hash, true);\n          if (loc.getKeyLength() == keyLength) {\n            final boolean areEqual = ByteArrayMethods.arrayEquals(\n              keyBase,\n              keyOffset,\n              loc.getKeyBase(),\n              loc.getKeyOffset(),\n              keyLength\n            );\n            if (areEqual) {\n              return;\n            }\n          }\n        }\n      }\n      pos = (pos + step) & mask;\n      step++;\n    }\n  }",
        "human_comment": "Looks up a key, and saves the result in provided `loc`.\n\nThis is a thread-safe version of `lookup`, could be used by multiple threads.",
        "model_generated_comment": "Returns a safe lookup of the given key.\n\n@param keyBase the keyBase, long keyOffset, int keyLength, Location loc, int hash\n@return a safe lookup of the key"
    },
    {
        "id": 59,
        "code_snippet": "public KVStoreView<T> max(long max) {\n    Preconditions.checkArgument(max > 0L, \"max must be positive.\");\n    this.max = max;\n    return this;\n  }",
        "human_comment": "Stops iteration after a number of elements has been retrieved.",
        "model_generated_comment": "Creates a KVStoreView with the specified max value.\n\n@param max the max value to view.\n@return this view"
    },
    {
        "id": 60,
        "code_snippet": "public static String getClassName(TestPlan testPlan, TestIdentifier testIdentifier) {\n\t\treturn org.junit.platform.launcher.listeners.LegacyReportingUtils.getClassName(testPlan, testIdentifier);\n\t}",
        "human_comment": "Get the class name for the supplied {@link TestIdentifier} using the\nsupplied {@link TestPlan}.\n\n<p>This implementation attempts to find the closest test identifier with\na {@link ClassSource} by traversing the hierarchy upwards towards the\nroot starting with the supplied test identifier. In case no such source\nis found, it falls back to using the parent's\n{@linkplain TestIdentifier#getLegacyReportingName legacy reporting name}.\n\n@param testPlan the test plan that contains the {@code TestIdentifier};\nnever {@code null}\n@param testIdentifier the identifier to determine the class name for;\nnever {@code null}\n@see TestIdentifier#getLegacyReportingName",
        "model_generated_comment": "Get the class name of the {@link TestPlan} used in this test.\n\n@param testPlan the test plan; never {@code null} or blank"
    },
    {
        "id": 61,
        "code_snippet": "protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main_activity);\n\n        if (savedInstanceState == null) {\n            ProductListFragment fragment = new ProductListFragment();\n\n            getSupportFragmentManager().beginTransaction()\n                    .add(R.id.fragment_container, fragment, ProductListFragment.TAG).commit();\n        }\n    }",
        "human_comment": "Add product list fragment if this is first creation",
        "model_generated_comment": "Create a new {@link ProductListFragment} with the specified savedInstanceState."
    },
    {
        "id": 62,
        "code_snippet": "void testADependencies() {\n        final List<MavenProject> mavenProjects = stub.getUpstreamProjects(ProjectDependencyGraphStub.A, false);\n        assertEquals(0, mavenProjects.size());\n    }",
        "human_comment": "Tests the stub. Yeah, I know.",
        "model_generated_comment": "Unit tests for {@link ProjectDependencyGraphStub}.\n\n@since 5.0"
    },
    {
        "id": 63,
        "code_snippet": "protected void after() {\n        // do nothing\n    }",
        "human_comment": "Override to tear down your specific external resource.",
        "model_generated_comment": "Determines if the test is successful.\n\n@param after() {@code after}"
    },
    {
        "id": 64,
        "code_snippet": "public void setConfigurationParameters2(Map<String, String> keyValuePairs) {\n\t\t\tsetConfigurationParameters(keyValuePairs);\n\t\t}",
        "human_comment": "Implementation note: the @Option annotation is on a setter method to allow validation.",
        "model_generated_comment": "Set the configuration parameters for the supplied {@link ConfigurationParameters}.\n\n@param keyValuePairs the key value pairs to set; never {@code null}\n@see #setConfigurationParameters(String)"
    },
    {
        "id": 65,
        "code_snippet": "public ObjectField(String fieldName, VariantSchema schema) {\n      this.fieldName = fieldName;\n      this.schema = schema;\n    }",
        "human_comment": "Defines a valid shredding schema, as described in\nhttps://github.com/apache/parquet-format/blob/master/VariantShredding.md.\nA shredding schema contains a value and optional typed_value field.\nIf a typed_value is an array or struct, it recursively contain its own shredding schema for\nelements and fields, respectively.\nThe schema also contains a metadata field at the top level, but not in recursively shredded\nfields.",
        "model_generated_comment": "Creates a new field with the given field name and the specified schema.\n\n@param fieldName the field name of the field, may be {@code null}."
    },
    {
        "id": 66,
        "code_snippet": "void testWeapon() {\n    var weapon = factory.create(WeaponType.SWORD);\n    verifyWeapon(weapon, Sword.class);\n  }",
        "human_comment": "Testing {@link WeaponFactory} to produce a SWORD asserting that the Weapon is an instance of\n{@link Sword}",
        "model_generated_comment": "Unit tests for {@link WeaponType}.\n\n@param weapon the weapon to test\n@return {@code WeaponType}"
    },
    {
        "id": 67,
        "code_snippet": "public ProjectBuildFailureException(String projectId, MojoFailureException cause) {\n        super(\"Build for project: \" + projectId + \" failed during execution of mojo.\", cause);\n\n        this.projectId = projectId;\n    }",
        "human_comment": "Exception which occurs when a normal (i.e. non-aggregator) mojo fails to\nexecute. In this case, the mojo failed while executing against a particular\nproject instance, so we can wrap the {@link MojoFailureException} with context\ninformation including projectId that caused the failure.",
        "model_generated_comment": "Creates a {@link ProjectBuildFailureException} with the given projectId and cause.\n\n@param projectId The projectId of the {@code projectId} to throw.\n@throws { @code MojoFailureException}."
    },
    {
        "id": 68,
        "code_snippet": "void performTest() {\n    Retry.Operation op =\n        (l) -> {\n          if (!l.isEmpty()) {\n            throw l.remove(0);\n          }\n        };\n    Retry.HandleErrorIssue<Order> handleError = (o, e) -> {};\n    var r1 =\n        new Retry<>(\n            op,\n            handleError,\n            3,\n            30000,\n            e -> DatabaseUnavailableException.class.isAssignableFrom(e.getClass()));\n    var r2 =\n        new Retry<>(\n            op,\n            handleError,\n            3,\n            30000,\n            e -> DatabaseUnavailableException.class.isAssignableFrom(e.getClass()));\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    var arr1 =\n        new ArrayList<>(\n            List.of(new ItemUnavailableException(), new DatabaseUnavailableException()));\n    try {\n      r1.perform(arr1, order);\n    } catch (Exception e1) {\n      LOG.error(\"An exception occurred\", e1);\n    }\n    var arr2 =\n        new ArrayList<>(\n            List.of(new DatabaseUnavailableException(), new ItemUnavailableException()));\n    try {\n      r2.perform(arr2, order);\n    } catch (Exception e1) {\n      LOG.error(\"An exception occurred\", e1);\n    }\n    assertTrue(arr1.size() == 1 && arr2.isEmpty());\n  }",
        "human_comment": "r1 stops at ItemUnavailableException, r2 retries because it encounters\nDatabaseUnavailableException",
        "model_generated_comment": "Perform a test with the given order.\n\n@param op the order to perform the test.\n@return the test"
    },
    {
        "id": 69,
        "code_snippet": "public MyDoubleSum() {\n    List<StructField> inputFields = new ArrayList<>();\n    inputFields.add(DataTypes.createStructField(\"inputDouble\", DataTypes.DoubleType, true));\n    _inputDataType = DataTypes.createStructType(inputFields);\n\n    List<StructField> bufferFields = new ArrayList<>();\n    bufferFields.add(DataTypes.createStructField(\"bufferDouble\", DataTypes.DoubleType, true));\n    _bufferSchema = DataTypes.createStructType(bufferFields);\n\n    _returnDataType = DataTypes.DoubleType;\n  }",
        "human_comment": "An example {@link UserDefinedAggregateFunction} to calculate the sum of a\n{@link org.apache.spark.sql.types.DoubleType} column.",
        "model_generated_comment": "Creates a double sum of {@link StructField} elements.\n\n@param inputFields the data type\n@return {@code MyDoubleSum}"
    },
    {
        "id": 70,
        "code_snippet": "public static Constant<String> create(Scope scope, String data, Charset charset) {\n    try (Tensor<String> value = Tensor.create(data.getBytes(charset), String.class)) {\n      return createWithTensor(scope, value);\n    }\n  }",
        "human_comment": "Creates a {@code String} constant using a specified encoding.\n\n@param scope is a scope used to add the underlying operation.\n@param charset The encoding from String to bytes.\n@param data The string to put into the new constant.\n@return a string constant",
        "model_generated_comment": "Creates a rank-4 constant of {@code scope} elements.\n\n@param data An array containing the values to put into the new constant."
    },
    {
        "id": 71,
        "code_snippet": "private void deleteParentIndex(Object key) {\n      if (hasNaturalParentIndex) {\n        for (NaturalKeys v : parentToChildrenMap.values()) {\n          if (v.remove(asKey(key)) != null) {\n            break;\n          }\n        }\n      }\n    }",
        "human_comment": "`v` can be empty after removing the natural key and we can remove it from\n`parentToChildrenMap`. However, `parentToChildrenMap` is a ConcurrentMap and such\nchecking and deleting can be slow.\nThis method is to delete one object with certain key, let's make it simple here.",
        "model_generated_comment": "Remove the parent index from the map.\n\n@param key The key to delete, may be {@code null}."
    },
    {
        "id": 72,
        "code_snippet": "public static void assertArrayEquals(double[] expected, double[] actual, double delta) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, delta);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} double arrays are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.",
        "model_generated_comment": "<em>Assert</em> that two double arrays are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@link Double#equals(expected, actual, delta)}.\n\n@since 5.4"
    },
    {
        "id": 73,
        "code_snippet": "void getUser(final LoadUserCallback callback) {\n        final WeakReference<LoadUserCallback> loadUserCallback = new WeakReference<>(callback);\n\n        // request the user on the I/O thread\n        mAppExecutors.diskIO().execute(() -> {\n            final User user = mUserDataSource.getUser();\n            // notify on the main thread\n            mAppExecutors.mainThread().execute(() -> {\n                final LoadUserCallback userCallback = loadUserCallback.get();\n                if (userCallback == null) {\n                    return;\n                }\n                if (user == null) {\n                    userCallback.onDataNotAvailable();\n                } else {\n                    mCachedUser = user;\n                    userCallback.onUserLoaded(mCachedUser);\n                }\n            });\n        });\n    }",
        "human_comment": "Get the user from the data source, cache it and notify via the callback that the user has\nbeen retrieved.\n\n@param callback callback that gets called when the user was retrieved from the data source.",
        "model_generated_comment": "Get the user from the main thread.\n\n@param callback callback the callback to get the user\n@return the user"
    },
    {
        "id": 74,
        "code_snippet": "private String determineReactorFailureBehaviour(final CommandLine commandLine) {\n        if (commandLine.hasOption(CLIManager.FAIL_FAST)) {\n            return MavenExecutionRequest.REACTOR_FAIL_FAST;\n        } else if (commandLine.hasOption(CLIManager.FAIL_AT_END)) {\n            return MavenExecutionRequest.REACTOR_FAIL_AT_END;\n        } else if (commandLine.hasOption(CLIManager.FAIL_NEVER)) {\n            return MavenExecutionRequest.REACTOR_FAIL_NEVER;\n        } else {\n            return MavenExecutionRequest.REACTOR_FAIL_FAST;\n        }\n    }",
        "human_comment": "this is the default behavior.",
        "model_generated_comment": "Determines whether the execution of the given command line is executed correctly.\n\n@param commandLine the command line to determine whether to execute the execution.\n@return MavenExecutionRequest.REACTOR_FAIL_FAST"
    },
    {
        "id": 75,
        "code_snippet": "private static Method getPublicMethod(Class<?> clazz, String name, Class<?>... paramTypes) {\n        // if this class is public, then try to get it\n        if ((clazz.getModifiers() & Modifier.PUBLIC) != 0) {\n            try {\n                return clazz.getMethod(name, paramTypes);\n            } catch (NoSuchMethodException e) {\n                // If the class does not have the method, then neither its superclass\n                // nor any of its interfaces has it so quickly return null.\n                return null;\n            }\n        }\n\n        //  try the superclass\n        Class<?> superclazz = clazz.getSuperclass();\n\n        if (superclazz != null) {\n            Method superclazzMethod = getPublicMethod(superclazz, name, paramTypes);\n\n            if (superclazzMethod != null) {\n                return superclazzMethod;\n            }\n        }\n\n        // and interfaces\n        Class<?>[] interfaces = clazz.getInterfaces();\n\n        for (Class<?> anInterface : interfaces) {\n            Method interfaceMethod = getPublicMethod(anInterface, name, paramTypes);\n\n            if (interfaceMethod != null) {\n                return interfaceMethod;\n            }\n        }\n\n        return null;\n    }",
        "human_comment": "Looks up the method with specified name and signature in the first public\nsuperclass or implemented interface of the class.\n\n@param clazz      the class whose method is sought\n@param name       the name of the method\n@param paramTypes the classes of method parameters",
        "model_generated_comment": "Returns the public method for the given class.\n\n@param name the name of the class\n@return The public method, never {@code null}."
    },
    {
        "id": 76,
        "code_snippet": "public static <V> V fail(String message, Throwable cause) {\n\t\tAssertionUtils.fail(message, cause);\n\t\treturn null; // appeasing the compiler: this line will never be executed.\n\t}",
        "human_comment": "<em>Fail</em> the test with the given failure {@code message} as well\nas the underlying {@code cause}.\n\n<p>See Javadoc for {@link #fail(String)} for an explanation of this method's\ngeneric return type {@code V}.",
        "model_generated_comment": "<em>Fails</em> with the supplied {@linkplain message}.\n\n@since 5.4"
    },
    {
        "id": 77,
        "code_snippet": "public static void assertNotEquals(Double unexpected, double actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Double) actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and {@link Double} are not equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code actual}.\n\n@since 5.4"
    },
    {
        "id": 78,
        "code_snippet": "public ColumnarMap(ColumnVector keys, ColumnVector values, int offset, int length) {\n    this.length = length;\n    this.keys = new ColumnarArray(keys, offset, length);\n    this.values = new ColumnarArray(values, offset, length);\n  }",
        "human_comment": "Map abstraction in {@link ColumnVector}.",
        "model_generated_comment": "Creates a new {@link ColumnarMap} with the given values.\n\n@param keys the values to put into the new column.\n@return a new Columnar Map with the specified values."
    },
    {
        "id": 79,
        "code_snippet": "public static Map<String, Integer> map(String input) {\n    Map<String, Integer> wordCount = new HashMap<>();\n    String[] words = input.split(\"\\\\s+\");\n    for (String word : words) {\n      word = word.toLowerCase().replaceAll(\"[^a-z]\", \"\");\n      if (!word.isEmpty()) {\n        wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n      }\n    }\n    return wordCount;\n  }",
        "human_comment": "Splits a given input string into words and counts their occurrences.\n\n@param input The input string to be mapped.\n@return A map where keys are words and values are their respective counts.",
        "model_generated_comment": "Creates a map of the input string.\n\n@param input The input string to put into the map.\n@return the map"
    },
    {
        "id": 80,
        "code_snippet": "public static void assertEquals(Short expected, Short actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\nsupplied\n{@code messageSupplier}.\n\n@since 5.4"
    },
    {
        "id": 81,
        "code_snippet": "public static Constant<Long> create(Scope scope, long[] data) {\n    return create(scope, data, Long.class);\n  }",
        "human_comment": "Creates a rank-1 constant of {@code long} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array.",
        "model_generated_comment": "Creates a rank-2 constant of {@code long} elements.\n\n@param scope An array containing the values to put into the new constant.\n@return a rank rank-1 constant"
    },
    {
        "id": 82,
        "code_snippet": "public Filter intersect(final Filter second) {\n        if (second == this || second == ALL) {\n            return this;\n        }\n        final Filter first = this;\n        return new Filter() {\n\n            @Override\n            public String describe() {\n                return first.describe() + \" and \" + second.describe();\n            }\n        };\n    }",
        "human_comment": "Returns a new Filter that accepts the intersection of the tests accepted\nby this Filter and {@code second}",
        "model_generated_comment": "Convert the first {@link Filter} to the second {@code Filter}"
    },
    {
        "id": 83,
        "code_snippet": "public int getNnapiErrno() {\n    checkNotClosed();\n    return getNnapiErrno(delegateHandle);\n  }",
        "human_comment": "Returns the latest error code returned by an NNAPI call or zero if NO calls to NNAPI failed.\nThe error code is reset when the delegate is associated with an <a\nhref=https://www.tensorflow.org/lite/api_docs/java/org/tensorflow/lite/Interpreter>interpreter</a>.\n\n<p>For details on NNAPI error codes see <a\nhref=\"https://developer.android.com/ndk/reference/group/neural-networks#resultcode\">the NNAPI\ndocumentation</a>.\n\n@throws IllegalStateException if the method is called after {@link #close() close}.",
        "model_generated_comment": "Get the NnapiErrno object.\n\n@param delegateHandle the NNapi object."
    },
    {
        "id": 84,
        "code_snippet": "void testAbortedExceptionInBeforeAll() {\n\t\tEngineExecutionResults results = executeTestsForClass(TestAbortedExceptionInBeforeAllTestCase.class);\n\n\t\tresults.containerEvents().assertStatistics(stats -> stats.aborted(1));\n\t\tresults.testEvents().assertStatistics(stats -> stats.started(0));\n\t}",
        "human_comment": "Integration tests that verify support for failed assumptions in the\n{@link JupiterTestEngine}.\n\n@since 5.4",
        "model_generated_comment": "Unit tests for {@link TestAbortedExceptionInBeforeAllTestCase}.\n\n@since 5.0"
    },
    {
        "id": 85,
        "code_snippet": "public static Tensor<Float> create(float[][] data) {\n    return Tensor.create(data, Float.class);\n  }",
        "human_comment": "Creates a rank-2 tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array.",
        "model_generated_comment": "Creates a rank-4 tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor."
    },
    {
        "id": 86,
        "code_snippet": "static void registerExtensionsFromExecutableParameters(ExtensionRegistrar registrar, Executable executable) {\n\t\tPreconditions.notNull(registrar, \"ExtensionRegistrar must not be null\");\n\t\tPreconditions.notNull(executable, \"Executable must not be null\");\n\n\t\tAtomicInteger index = new AtomicInteger();\n\n\t\t// @formatter:off\n\t\tArrays.stream(executable.getParameters())\n\t\t\t\t.map(parameter -> findRepeatableAnnotations(parameter, index.getAndIncrement(), ExtendWith.class))\n\t\t\t\t.flatMap(ExtensionUtils::streamDeclarativeExtensionTypes)\n\t\t\t\t.forEach(registrar::registerExtension);\n\t\t// @formatter:on\n\t}",
        "human_comment": "Register extensions using the supplied registrar from parameters in the\nsupplied {@link Executable} (i.e., a {@link java.lang.reflect.Constructor}\nor {@link java.lang.reflect.Method}) that are annotated with\n{@link ExtendWith @ExtendWith}.\n\n@param registrar the registrar with which to register the extensions; never {@code null}\n@param executable the constructor or method whose parameters should be searched; never {@code null}\n@since 5.8",
        "model_generated_comment": "Register extensions from the supplied {@link Executable}.\n\n@param registrar the registrar to register extensions from; never {@code null}\n@see #registerExtensions(Extension)"
    },
    {
        "id": 87,
        "code_snippet": "static void mergeEnvPathList(Map<String, String> userEnv, String envKey, String pathList) {\n    if (!isEmpty(pathList)) {\n      String current = firstNonEmpty(userEnv.get(envKey), System.getenv(envKey));\n      userEnv.put(envKey, join(File.pathSeparator, current, pathList));\n    }\n  }",
        "human_comment": "Updates the user environment, appending the given pathList to the existing value of the given\nenvironment variable (or setting it if it hasn't yet been set).",
        "model_generated_comment": "Merges a path list of {@link UserEnv} elements.\n\n@param userEnv The path list, may be {@code null}."
    },
    {
        "id": 88,
        "code_snippet": "public Decimal getDecimal(int rowId, int precision, int scale) {\n    if (precision <= Decimal.MAX_INT_DIGITS()) {\n      return Decimal.createUnsafe(getInt(rowId), precision, scale);\n    } else if (precision <= Decimal.MAX_LONG_DIGITS()) {\n      return Decimal.createUnsafe(getLong(rowId), precision, scale);\n    } else {\n      byte[] bytes = getBinary(rowId);\n      BigInteger bigInteger = new BigInteger(bytes);\n      BigDecimal javaDecimal = new BigDecimal(bigInteger, scale);\n      return Decimal.apply(javaDecimal, precision, scale);\n    }\n  }",
        "human_comment": "copy and modify from WritableColumnVector",
        "model_generated_comment": "Creates a Decimal with the given rowId and precision.\n\n@param rowId The rowId of the Decimal, must not be <code>null</code>."
    },
    {
        "id": 89,
        "code_snippet": "protected void handleElectionInvokeMessage() {\n    if (!isLeader()) {\n      LOGGER.info(INSTANCE + localId + \"- Start election.\");\n      boolean electionResult = messageManager.sendElectionMessage(localId, String.valueOf(localId));\n      if (electionResult) {\n        LOGGER.info(INSTANCE + localId + \"- Succeed in election. Start leader notification.\");\n        leaderId = localId;\n        messageManager.sendLeaderMessage(localId, localId);\n        messageManager.sendHeartbeatInvokeMessage(localId);\n      }\n    }\n  }",
        "human_comment": "Process election invoke message. Send election message to all the instances with smaller ID. If\nany one of them is alive, do nothing. If no instance alive, send leader message to all the\nalive instance and restart heartbeat.",
        "model_generated_comment": "Succeed in election.\n\n@param leaderId The leader of the election."
    },
    {
        "id": 90,
        "code_snippet": "static void reportAndClear(List<DiscoveryIssue> issues, DiscoveryIssueReporter reporter) {\n\t\tissues.forEach(reporter::reportIssue);\n\t\tissues.clear();\n\t}",
        "human_comment": "Report and clear the given list of {@link DiscoveryIssue}s using the\nsupplied {@link DiscoveryIssueReporter}.",
        "model_generated_comment": "Unit tests for {@link DiscoveryIssueReporter}.\n\n@since 5.4"
    },
    {
        "id": 91,
        "code_snippet": "public Executions debug() {\n\t\tdebug(System.out);\n\t\treturn this;\n\t}",
        "human_comment": "Print all executions to {@link System#out}.\n\n@return this {@code Executions} object for method chaining; never {@code null}",
        "model_generated_comment": "Unit tests for {@link Executions}.\n\n@since 5.0"
    },
    {
        "id": 92,
        "code_snippet": "static MethodFilter excludeMethodNamePatterns(List<String> patterns) {\n\t\treturn excludeMethodNamePatterns(patterns.toArray(new String[0]));\n\t}",
        "human_comment": "Create a new <em>exclude</em> {@link MethodFilter} based on the\n@see Class#getName()\n@see Method#getName()\n@see #excludeMethodNamePatterns(String...)\n@see #includeMethodNamePatterns(String...)",
        "model_generated_comment": "Create a new {@link MethodFilter} for the supplied {@code patterns}.\n\n@since 5.4"
    },
    {
        "id": 93,
        "code_snippet": "public static Transform bucket(int numBuckets, String... columns) {\n    NamedReference[] references = Arrays.stream(columns)\n      .map(Expressions::column)\n      .toArray(NamedReference[]::new);\n    return LogicalExpressions.bucket(numBuckets, references);\n  }",
        "human_comment": "Create a bucket transform for one or more columns.\n<p>\nThis transform represents a logical mapping from a value to a bucket id in [0, numBuckets)\nbased on a hash of the value.\n<p>\nThe name reported by transforms created with this method is \"bucket\".\n\n@param numBuckets the number of output buckets\n@param columns input columns for the bucket transform\n@return a logical bucket transform with name \"bucket\"",
        "model_generated_comment": "Creates a new {@link Transform} of {@code numBuckets} elements.\n\n@param columns the columns to transform\n@return a new Transform"
    },
    {
        "id": 94,
        "code_snippet": "public boolean isSuccess() {\n      return result == ChapterResult.SUCCESS;\n    }",
        "human_comment": "the result for chapter is good.\n\n@return true if is good otherwise bad",
        "model_generated_comment": "Returns whether the test is successful.\n\n@param result The test result."
    },
    {
        "id": 95,
        "code_snippet": "public static Constant<Integer> create(Scope scope, int[] data) {\n    return create(scope, data, Integer.class);\n  }",
        "human_comment": "Creates a rank-1 constant of {@code int} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array.",
        "model_generated_comment": "Creates a rank-4 constant of {@code int} elements.\n\n@param scope An array containing the values to put into the new constant."
    },
    {
        "id": 96,
        "code_snippet": "public MultiBoxTracker(final Context context) {\n    this.context = context;\n    for (final int color : COLORS) {\n      availableColors.add(color);\n    }\n\n    boxPaint.setColor(Color.RED);\n    boxPaint.setStyle(Style.STROKE);\n    boxPaint.setStrokeWidth(12.0f);\n    boxPaint.setStrokeCap(Cap.ROUND);\n    boxPaint.setStrokeJoin(Join.ROUND);\n    boxPaint.setStrokeMiter(100);\n\n    textSizePx =\n        TypedValue.applyDimension(\n            TypedValue.COMPLEX_UNIT_DIP, TEXT_SIZE_DIP, context.getResources().getDisplayMetrics());\n    borderedText = new BorderedText(textSizePx);\n  }",
        "human_comment": "A tracker wrapping ObjectTracker that also handles non-max suppression and matching existing\nobjects to new detections.",
        "model_generated_comment": "Create a {@link MultiBoxTracker} based on the given context.\n\n@param context The context to track, may be {@code null}."
    },
    {
        "id": 97,
        "code_snippet": "private static Settings adaptSettings(MavenExecutionRequest request) {\n        File localRepo = request.getLocalRepositoryPath();\n        return new Settings(org.apache.maven.api.settings.Settings.newBuilder()\n                .localRepository(localRepo != null ? localRepo.getAbsolutePath() : null)\n                .interactiveMode(request.isInteractiveMode())\n                .offline(request.isOffline())\n                .proxies(request.getProxies().stream().map(Proxy::getDelegate).collect(Collectors.toList()))\n                .servers(request.getServers().stream().map(Server::getDelegate).collect(Collectors.toList()))\n                .mirrors(request.getMirrors().stream().map(Mirror::getDelegate).collect(Collectors.toList()))\n                .profiles(request.getProfiles().stream()\n                        .map(Profile::getDelegate)\n                        .map(SettingsUtilsV4::convertToSettingsProfile)\n                        .collect(Collectors.toList()))\n                .activeProfiles(request.getActiveProfiles())\n                .pluginGroups(request.getPluginGroups())\n                .build());\n    }",
        "human_comment": "Adapt a {@link MavenExecutionRequest} to a {@link Settings} object for use in the Maven core.\nWe want to make sure that what is ask for in the execution request overrides what is in the settings.\nThe CLI feeds into an execution request so if a particular value is present in the execution request\nthen we will take that over the value coming from the user settings.",
        "model_generated_comment": "Creates a new {@link MavenExecutionRequest} with the specified settings.\n\n@param request The request to adapt, may be {@code null}."
    },
    {
        "id": 98,
        "code_snippet": "public EventDispatcher() {\n    handlers = new HashMap<>();\n  }",
        "human_comment": "Handles the routing of {@link Event} messages to associated handlers. A {@link HashMap} is used\nto store the association between events and their respective handlers.",
        "model_generated_comment": "Create an EventDispatcher instance.\n\n@param handlers the event handler"
    },
    {
        "id": 99,
        "code_snippet": "void testEqualReversed() {\n        ResolutionNode a2n = createResolutionNode(a2);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a2n, a2n, a1n);\n    }",
        "human_comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\na:2.0\na:1.0\n</pre>",
        "model_generated_comment": "Unit tests for {@link ResolutionNode}.\n\n@since 5.0"
    },
    {
        "id": 100,
        "code_snippet": "public DefaultSettingsDecrypter(MavenSecDispatcher securityDispatcher) {\n        this.securityDispatcher = securityDispatcher;\n    }",
        "human_comment": "Decrypts passwords in the settings.\n\n@deprecated since 4.0.0",
        "model_generated_comment": "Creates a default settings decrypter for Maven.\n\n@param securityDispatcher the security dispatcher\n@return Default settings Decrypter"
    },
    {
        "id": 101,
        "code_snippet": "private void assertEvaluated(String value) {\n        assertNotNull(value);\n        assertTrue(value.length() > 0);\n        assertFalse(value.contains(\"${\"), value);\n    }\n}",
        "human_comment": "Verify that plugin configurations are subject to the parameter expression evaluator, in particular composite\nparameter types.\n\n@throws Exception in case of failure",
        "model_generated_comment": "<em>Assert</em> that {@code value} is equal.\n\n@param value the value to assert."
    },
    {
        "id": 102,
        "code_snippet": "public Service(ServiceDiscoveryService service) {\n    this.sd = service;\n  }",
        "human_comment": "Common abstraction class representing services. implementing a general contract @see {@link\nChoreographyChapter}",
        "model_generated_comment": "Creates a new ServiceDiscoveryService.\n\n@param service the service to create."
    },
    {
        "id": 103,
        "code_snippet": "protected String getEnvironmentVariable(String name) {\n\t\treturn System.getenv(name);\n\t}",
        "human_comment": "Get the value of the named environment variable.\n\n<p>The default implementation delegates to\n{@link System#getenv(String)}. Can be overridden in a subclass for\ntesting purposes.",
        "model_generated_comment": "Get the environment variable for the supplied {@link System.getenv(String)}.\n\n@param name the name of the variable; never {@code null}"
    },
    {
        "id": 104,
        "code_snippet": "void getUser(final LoadUserCallback callback) {\n        final WeakReference<LoadUserCallback> loadUserCallback = new WeakReference<>(callback);\n\n        // request the user on the I/O thread\n        mAppExecutors.diskIO().execute(new Runnable() {\n                mAppExecutors.mainThread().execute(new Runnable() {\n                        if (user == null) {\n                            userCallback.onDataNotAvailable();\n                        } else {\n                            mCachedUser = user;\n                            userCallback.onUserLoaded(mCachedUser);\n                        }\n                    }\n                });\n            }",
        "human_comment": "Get the user from the data source, cache it and notify via the callback that the user has\nbeen retrieved.\n\n@param callback callback that gets called when the user was retrieved from the data source.",
        "model_generated_comment": "Get the user from the I/O thread.\n\n@param callback callback the callback to get the user"
    },
    {
        "id": 105,
        "code_snippet": "@Override public void update(MutableAggregationBuffer buffer, Row input) {\n    if (!input.isNullAt(0)) {\n      if (buffer.isNullAt(0)) {\n        buffer.update(0, input.getDouble(0));\n      } else {\n        Double newValue = input.getDouble(0) + buffer.getDouble(0);\n        buffer.update(0, newValue);\n      }\n    }\n  }",
        "human_comment": "This input Row only has a single column storing the input value in Double.\nWe only update the buffer when the input value is not null.\nIf the buffer value (the intermediate result of the sum) is still null,\nwe set the input value to the buffer.\nOtherwise, we add the input value to the buffer value.",
        "model_generated_comment": "Update the input buffer.\n\n@param buffer The buffer buffer to update.\n@throws IllegalArgumentException if buffer is null"
    },
    {
        "id": 106,
        "code_snippet": "public String getArtifactMetadataPath(String gid, String aid, String version, String filename) {\n        return getArtifactMetadataPath(gid, aid, version, filename, null);\n    }",
        "human_comment": "Gets the path to a file in the local artifact directory. Note that the method does not check whether the returned\npath actually points to an existing file.\n\n@param gid      The group id, must not be <code>null</code>.\n@param aid      The artifact id, may be <code>null</code>.\n@param version  The artifact version, may be <code>null</code>.\n@param filename The filename to use, must not be <code>null</code>.\n@return The (absolute) path to the local artifact metadata, never <code>null</code>.",
        "model_generated_comment": "Returns the metadata path for the artifact.\n\n@param gid The gid of the artifact, may be {@code null}."
    },
    {
        "id": 107,
        "code_snippet": "public static void assertNotEquals(char unexpected, Character actual, String message) {\n\t\tAssertNotEquals.assertNotEquals((Character) unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and {@link actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 108,
        "code_snippet": "public static void assertArrayEquals(Object[] expected, Object[] actual) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} object arrays are deeply equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Nested float arrays are checked as in {@link #assertEquals(float, float)}.\n<p>Nested double arrays are checked as in {@link #assertEquals(double, double)}.\n\n@see Objects#equals(Object, Object)\n@see Arrays#deepEquals(Object[], Object[])",
        "model_generated_comment": "<em>Assert</em> that two objects are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code expected} object.\n\n@since 5.4"
    },
    {
        "id": 109,
        "code_snippet": "public static InputLocation merge(InputLocation target, InputLocation source, Collection<Integer> indices) {\n        if (source == null) {\n            return target;\n        } else if (target == null) {\n            return source;\n        }\n\n        Map<Object, InputLocation> locations;\n        Map<Object, InputLocation> sourceLocations = source.locations;\n        Map<Object, InputLocation> targetLocations = target.locations;\n        if (sourceLocations == null) {\n            locations = targetLocations;\n        } else if (targetLocations == null) {\n            locations = sourceLocations;\n        } else {\n            locations = new LinkedHashMap<>();\n            for (int index : indices) {\n                InputLocation location;\n                if (index < 0) {\n                    location = sourceLocations.get(~index);\n                } else {\n                    location = targetLocations.get(index);\n                }\n                locations.put(locations.size(), location);\n            }\n        }\n\n        return new InputLocation(target.getLineNumber(), target.getColumnNumber(), target.getSource(), locations);\n    } // -- InputLocation merge( InputLocation, InputLocation, java.util.Collection )",
        "human_comment": "Merges the {@code source} location into the {@code target} location.\nThis method is used when the locations refer to lists and also merges the indices.\n\n@param target the target location\n@param source the source location\n@param indices the list of integers for the indices\n@return the merged location",
        "model_generated_comment": "Merges the input location with the source location.\n\n@param target the target location\n@return the merged location"
    },
    {
        "id": 110,
        "code_snippet": "protected ExecutionCondition getExecutionCondition() {\n\t\treturn new EnabledIfSystemPropertyCondition();\n\t}",
        "human_comment": "Unit tests for {@link EnabledIfSystemPropertyCondition}.\n\n<p>Note that test method names MUST match the test method names in\n{@link EnabledIfSystemPropertyIntegrationTests}.\n\n@since 5.1",
        "model_generated_comment": "Get the {@link EnabledIfSystemPropertyCondition}.\n\n@since 5.0"
    },
    {
        "id": 111,
        "code_snippet": "public static UTF8String fromBytes(byte[] bytes, int offset, int numBytes) {\n    if (bytes != null) {\n      return new UTF8String(bytes, BYTE_ARRAY_OFFSET + offset, numBytes);\n    } else {\n      return null;\n    }\n  }",
        "human_comment": "Creates an UTF8String from byte array, which should be encoded in UTF-8.\n\nNote: `bytes` will be hold by returned UTF8String.",
        "model_generated_comment": "Creates a UTF8String from bytes.\n\n@param bytes the bytes to put into the new string."
    },
    {
        "id": 112,
        "code_snippet": "public static Resolution selectors(Set<? extends DiscoverySelector> selectors) {\n\t\t\tPreconditions.containsNoNullElements(selectors, \"selectors must not contain null elements\");\n\t\t\tPreconditions.notEmpty(selectors, \"selectors must not be empty\");\n\t\t\treturn new Resolution(emptySet(), selectors);\n\t\t}",
        "human_comment": "Factory for creating a resolution that contains the supplied\n{@link DiscoverySelector DiscoverySelectors}.\n\n@param selectors the resolved {@code DiscoverySelectors}; never\n{@code null} or empty\n@return an resolution that contains the supplied\n{@code DiscoverySelectors}; never {@code null}",
        "model_generated_comment": "Create a new {@code Resolution} for the supplied {@link DiscoverySelectors}.\n\n@since 5.4"
    },
    {
        "id": 113,
        "code_snippet": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
        "human_comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp#main(String[])} throws an exception.",
        "model_generated_comment": "<em>Assert</em> that the execution of the main {@link App} throws an exception.\n\n@param String the String to check; never {@code null}"
    },
    {
        "id": 114,
        "code_snippet": "private static LinkedList<Method> getApplicables(List<Method> methods, Class<?>... classes) {\n        LinkedList<Method> list = new LinkedList<>();\n\n        for (Method method : methods) {\n            if (isApplicable(method, classes)) {\n                list.add(method);\n            }\n        }\n        return list;\n    }",
        "human_comment": "Returns all methods that are applicable to actual argument types.\n\n@param methods list of all candidate methods\n@param classes the actual types of the arguments\n@return a list that contains only applicable methods (number of\nformal and actual arguments matches, and argument types are assignable\nto formal types through a method invocation conversion).",
        "model_generated_comment": "Returns the list ofApplicables for the given method.\n\n@param methods the methods to getApplicables\n@return the list"
    },
    {
        "id": 115,
        "code_snippet": "void removeWithTypeSafetyAndPrimitiveValueType() {\n\t\t\tString key = \"enigma\";\n\t\t\tint value = 42;\n\t\t\tstore.put(namespace, key, value);\n\n\t\t\tint requiredInt = store.remove(namespace, key, int.class);\n\t\t\tassertEquals(value, requiredInt);\n\n\t\t\tstore.put(namespace, key, value);\n\t\t\tInteger requiredInteger = store.get(namespace, key, Integer.class);\n\t\t\tassertEquals(value, requiredInteger.intValue());\n\t\t}",
        "human_comment": "The fact that we can declare this as an int suffices for testing the required type.\nThe fact that we can declare this as an Integer suffices for testing the required type.",
        "model_generated_comment": "Remove the {@link TypeSafetyAndPrimitiveValueType()} from the store.\n\n@since 5.4"
    },
    {
        "id": 116,
        "code_snippet": "public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n\n        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;\n\n        return patterns.equals(other.patterns);\n    }",
        "human_comment": "make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!",
        "model_generated_comment": "Asserts that two objects are equal.\n\n@param obj The object to check.\n@return true if the object is equal."
    },
    {
        "id": 117,
        "code_snippet": "public static void assertEquals(char expected, Character actual) {\n\t\tAssertEquals.assertEquals((Character) expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@link Character}.\n\n@since 5.4"
    },
    {
        "id": 118,
        "code_snippet": "protected Statement methodInvoker(FrameworkMethod method, Object test) {\n        return new InvokeMethod(method, test);\n    }",
        "human_comment": "Returns a {@link Statement} that invokes {@code method} on {@code test}",
        "model_generated_comment": "Create a new {@link MethodInvoker} for the supplied method.\n\n@param method the method to invoke\n@return a new methodInvoker"
    },
    {
        "id": 119,
        "code_snippet": "public final ColumnarMap getMap(int rowId) {\n    if (isNullAt(rowId)) return null;\n    return new ColumnarMap(getChild(0), getChild(1), getArrayOffset(rowId), getArrayLength(rowId));\n  }",
        "human_comment": "`WritableColumnVector` puts the key array in the first child column vector, value array in the\nsecond child column vector, and puts the offsets and lengths in the current column vector.",
        "model_generated_comment": "Get the columnar map from the array.\n\n@param rowId The row id to get the map from.\n@return the column map"
    },
    {
        "id": 120,
        "code_snippet": "void grow(int neededSize) {\n    if (neededSize < 0) {\n      throw new SparkIllegalArgumentException(\n        \"_LEGACY_ERROR_TEMP_3198\",\n        Map.of(\"neededSize\", String.valueOf(neededSize)));\n    }\n    if (neededSize > ARRAY_MAX - totalSize()) {\n      throw new SparkIllegalArgumentException(\n        \"_LEGACY_ERROR_TEMP_3199\",\n        Map.of(\"neededSize\", String.valueOf(neededSize), \"arrayMax\", String.valueOf(ARRAY_MAX)));\n    }\n    final int length = totalSize() + neededSize;\n    if (buffer.length < length) {\n      // This will not happen frequently, because the buffer is re-used.\n      int newLength = length < ARRAY_MAX / 2 ? length * 2 : ARRAY_MAX;\n      int roundedSize = ByteArrayMethods.roundNumberOfBytesToNearestWord(newLength);\n      final byte[] tmp = new byte[roundedSize];\n      Platform.copyMemory(\n        buffer,\n        Platform.BYTE_ARRAY_OFFSET,\n        tmp,\n        Platform.BYTE_ARRAY_OFFSET,\n        totalSize());\n      buffer = tmp;\n      row.pointTo(buffer, buffer.length);\n    }\n  }",
        "human_comment": "Grows the buffer by at least neededSize and points the row to the buffer.",
        "model_generated_comment": "Grow the number of bytes in the buffer.\n\n@param neededSize The size of the buffer to grow.\n@throws IllegalArgumentException if the buffer is empty."
    },
    {
        "id": 121,
        "code_snippet": "public Thread newThread(Runnable r) {\n            Thread newThread = new Thread(GROUP, r, \"resolver-\" + THREAD_NUMBER.getAndIncrement());\n            newThread.setDaemon(true);\n            newThread.setContextClassLoader(null);\n            return newThread;\n        }",
        "human_comment": "ThreadCreator for creating daemon threads with fixed ThreadGroup-name.",
        "model_generated_comment": "Creates a new {@link Thread} for the given thread.\n\n@param r The thread to create, may be {@code null}."
    },
    {
        "id": 122,
        "code_snippet": "private SettingsUtilsV4() {\n        // don't allow construction.\n    }",
        "human_comment": "Several convenience methods to handle settings",
        "model_generated_comment": "Creates a new {@link SettingsUtilsV4} for the default settings.\n\n@param settings the settings to use, may be {@code null}."
    },
    {
        "id": 123,
        "code_snippet": "public synchronized boolean wasSuccessful() {\n        return failureCount() == 0 && errorCount() == 0;\n    }",
        "human_comment": "Returns whether the entire test was successful or not.",
        "model_generated_comment": "Returns the boolean indicating whether the failure was successful.\n\n@param failureCount The failure count"
    },
    {
        "id": 124,
        "code_snippet": "public Options setAcceleratorName(String name) {\n      this.acceleratorName = name;\n      return this;\n    }",
        "human_comment": "Specifies the name of the target accelerator to be used by NNAPI. If this parameter is\nspecified the {@link #setUseNnapiCpu(boolean)} method won't have any effect.\n\n<p>Only effective on Android 10 (API level 29) and above.",
        "model_generated_comment": "Set the name of the acceleration.\n\n@param name the name to set."
    },
    {
        "id": 125,
        "code_snippet": "public static void assertEquals(Double expected, double actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Double) actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "<em>Assert</em> that {@link Double} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 126,
        "code_snippet": "public Builder convertDurationsTo(TimeUnit durationUnit) {\n            this.durationUnit = durationUnit;\n            return this;\n        }",
        "human_comment": "Convert durations to the given time unit.\n\n@param durationUnit a unit of time\n@return {@code this}",
        "model_generated_comment": "Convert the duration of a {@link TimeUnit} to {@code durationUnit}.\n\n@param durationUnit the duration to convert\n@return this builder"
    },
    {
        "id": 127,
        "code_snippet": "List<String> buildSparkSubmitArgs(boolean includeRemote) {\n    List<String> args = new ArrayList<>();\n    OptionParser parser = new OptionParser(false);\n    final boolean isSpecialCommand;\n\n    if (!userArgs.isEmpty()) {\n      parser.parse(userArgs);\n      isSpecialCommand = parser.isSpecialCommand;\n    } else {\n      isSpecialCommand = this.isSpecialCommand;\n    }\n\n    if (!allowsMixedArguments && !isSpecialCommand) {\n      checkArgument(appResource != null, \"Missing application resource.\");\n    }\n\n    if (verbose) {\n      args.add(parser.VERBOSE);\n    }\n\n    if (master != null) {\n      args.add(parser.MASTER);\n      args.add(master);\n    }\n\n    if (includeRemote && remote != null) {\n      args.add(parser.REMOTE);\n      args.add(remote);\n    }\n\n    if (deployMode != null) {\n      args.add(parser.DEPLOY_MODE);\n      args.add(deployMode);\n    }\n\n    if (appName != null) {\n      args.add(parser.NAME);\n      args.add(appName);\n    }\n\n    for (Map.Entry<String, String> e : conf.entrySet()) {\n      if (includeRemote ||\n           (!e.getKey().equalsIgnoreCase(\"spark.api.mode\") &&\n             !e.getKey().equalsIgnoreCase(\"spark.remote\"))) {\n        args.add(parser.CONF);\n        args.add(String.format(\"%s=%s\", e.getKey(), e.getValue()));\n      }\n    }\n\n    if (propertiesFile != null) {\n      args.add(parser.PROPERTIES_FILE);\n      args.add(propertiesFile);\n    }\n\n    if (isExample) {\n      jars.addAll(findExamplesJars());\n    }\n\n    if (!jars.isEmpty()) {\n      args.add(parser.JARS);\n      args.add(join(\",\", jars));\n    }\n\n    if (!files.isEmpty()) {\n      args.add(parser.FILES);\n      args.add(join(\",\", files));\n    }\n\n    if (!pyFiles.isEmpty()) {\n      args.add(parser.PY_FILES);\n      args.add(join(\",\", pyFiles));\n    }\n\n    if (isExample && !isSpecialCommand) {\n      checkArgument(mainClass != null, \"Missing example class name.\");\n    }\n\n    if (mainClass != null) {\n      args.add(parser.CLASS);\n      if (isRemote && \"1\".equals(getenv(\"SPARK_SCALA_SHELL\"))) {\n        args.add(\"org.apache.spark.sql.application.ConnectRepl\");\n      } else {\n        args.add(mainClass);\n      }\n    }\n\n    args.addAll(parsedArgs);\n\n    if (appResource != null) {\n      if (isRemote && \"1\".equals(getenv(\"SPARK_SCALA_SHELL\"))) {\n        args.add(\"connect-shell\");\n      } else {\n        args.add(appResource);\n      }\n    }\n\n    args.addAll(appArgs);\n\n    return args;\n  }",
        "human_comment": "If the user args array is not empty, we need to parse it to detect exactly what\nthe user is trying to run, so that checks below are correct.",
        "model_generated_comment": "buildSparkSubmitArgs(boolean includeRemote)"
    },
    {
        "id": 128,
        "code_snippet": "private static Map<String, String> splitCookieToken(String tokenStr) {\n    Map<String, String> map = new HashMap<String, String>();\n    StringTokenizer st = new StringTokenizer(tokenStr, COOKIE_ATTR_SEPARATOR);\n\n    while (st.hasMoreTokens()) {\n      String part = st.nextToken();\n      int separator = part.indexOf(COOKIE_KEY_VALUE_SEPARATOR);\n      if (separator == -1) {\n        LOG.error(\"Invalid token string {}\", MDC.of(LogKeys.TOKEN$.MODULE$, tokenStr));\n        return null;\n      }\n      String key = part.substring(0, separator);\n      String value = part.substring(separator + 1);\n      map.put(key, value);\n    }\n    return map;\n  }",
        "human_comment": "Splits the cookie token into attributes pairs.\n@param str input token.\n@return a map with the attribute pairs of the token if the input is valid.\nElse, returns null.",
        "model_generated_comment": "Split the token into two parts.\n\n@param tokenStr The token to split, must not be <code>null</code>."
    },
    {
        "id": 129,
        "code_snippet": "public Options setModelToken(String modelToken) {\n      this.modelToken = modelToken;\n      return this;\n    }",
        "human_comment": "Sets the token to be used to identify this model in the model compilation cache. If either\n{@code cacheDir} or {@code modelToken} parameters are unset NNAPI caching will be disabled.\n\n<p>Only effective on Android 10 (API level 29) and above.",
        "model_generated_comment": "Sets the model token.\n\n@param modelToken The model token to set."
    },
    {
        "id": 130,
        "code_snippet": "private static LinkedList<Method> getApplicables(List<Method> methods, Class<?>... classes) {\n        LinkedList<Method> list = new LinkedList<>();\n\n        for (Method method : methods) {\n            if (isApplicable(method, classes)) {\n                list.add(method);\n            }\n        }\n        return list;\n    }",
        "human_comment": "Returns all methods that are applicable to actual argument types.\n\n@param methods list of all candidate methods\n@param classes the actual types of the arguments\n@return a list that contains only applicable methods (number of\nformal and actual arguments matches, and argument types are assignable\nto formal types through a method invocation conversion).",
        "model_generated_comment": "Returns the list ofApplicables for the given method.\n\n@param methods the methods to getApplicables\n@return the list"
    },
    {
        "id": 131,
        "code_snippet": "void outOfMemoryErrorInLeafExecution() {\n\t\tvar child = spy(new MyLeaf(UniqueId.root(\"leaf\", \"leaf\")));\n\t\tvar outOfMemoryError = new OutOfMemoryError(\"in test\");\n\t\twhen(child.execute(eq(rootContext), any())).thenThrow(outOfMemoryError);\n\t\troot.addChild(child);\n\n\t\tThrowable actualException = assertThrows(OutOfMemoryError.class, () -> executor.execute());\n\t\tassertSame(outOfMemoryError, actualException);\n\t}",
        "human_comment": "Verifies support for unrecoverable exceptions.",
        "model_generated_comment": "Unit tests for {@link MyLeaf}.\n\n@since 5.0"
    },
    {
        "id": 132,
        "code_snippet": "public static long byteStringAsMb(String str) {\n    return byteStringAs(str, ByteUnit.MiB);\n  }",
        "human_comment": "Convert a passed byte string (e.g. 50b, 100k, or 250m) to mebibytes for\ninternal use.\n\nIf no suffix is provided, the passed number is assumed to be in mebibytes.",
        "model_generated_comment": "Returns the byte string as mb.\n\n@param str String the string to return."
    },
    {
        "id": 133,
        "code_snippet": "public String[] getSupportedProtocols() {\n        return new String[] {\"b1\", \"b2\"};\n}",
        "human_comment": "Wagon for testing, for protocols <code>b1</code> and <code>b2</code>",
        "model_generated_comment": "Returns the supported implementations of {@link String}.\n\n@param b1 The supported implementations\n@return the supported implementation"
    },
    {
        "id": 134,
        "code_snippet": "private <T> List<T> injectList(List<T> list, UnaryOperator<T> modifer) {\n        List<T> newList = null;\n        for (int i = 0; i < list.size(); i++) {\n            T oldT = list.get(i);\n            T newT = modifer.apply(oldT);\n            if (newT != oldT) {\n                if (newList == null) {\n                    newList = new ArrayList<>(list);\n                }\n                newList.set(i, newT);\n            }\n        }\n        return newList;\n    }",
        "human_comment": "Returns a list suited for the builders, i.e. null if not modified",
        "model_generated_comment": "Creates a list of {@link List} elements.\n\n@param list The list of elements to inject, may be {@code null}."
    },
    {
        "id": 135,
        "code_snippet": "public double calculateTotal(final String userId) {\n    return shoppingCartUseCase.calculateTotal(userId);\n  }",
        "human_comment": "Calculates the total cost of items in the user's cart.\n\n@param userId The ID of the user.\n@return The total price of all items in the cart.",
        "model_generated_comment": "Calculate the total number of items in the shopping cart.\n\n@param userId The user ID to calculate."
    },
    {
        "id": 136,
        "code_snippet": "public void testSetup() {\n    lastError = null;\n  }",
        "human_comment": "Arguments passed to the test class to identify the test being run.",
        "model_generated_comment": "Tests that a test has been setup.\n\n@param lastError the error message"
    },
    {
        "id": 137,
        "code_snippet": "public String getGroupId() {\n        return (groupId != null) ? groupId : \"\";\n    }",
        "human_comment": "Gets the effective group identifier of the model.\n\n@return The effective group identifier of the model or an empty string if unknown, never {@code null}.",
        "model_generated_comment": "Get the group ID of the group.\n\n@param groupId The group ID to get."
    },
    {
        "id": 138,
        "code_snippet": "public void setUtf8String(UTF8String value) {\n    stringData = value;\n  }",
        "human_comment": "Sets the `UTF8String` `value` for all rows",
        "model_generated_comment": "Sets the UTF8 string value.\n\n@param value the value to set."
    },
    {
        "id": 139,
        "code_snippet": "public static <T> Result<T> newResult(T model, Iterable<? extends ModelProblem> problems) {\n        return new Result<>(hasErrors(problems), model, problems);\n    }",
        "human_comment": "New result - determine whether error or success by checking problems for errors\n\n@param model\n@param problems",
        "model_generated_comment": "Creates a new {@link Result} with the specified problems.\n\n@param model The model to put into the new result\n@return a new Result"
    },
    {
        "id": 140,
        "code_snippet": "public ProjectBuildingRequest setResolveVersionRanges(boolean value) {\n        this.resolveVersionRanges = value;\n        return this;\n    }",
        "human_comment": "@since 3.2.2\n@deprecated This got added when implementing MNG-2199 and is no longer used.\nCommit 6cf9320942c34bc68205425ab696b1712ace9ba4 updated the way 'MavenProject' objects are initialized.",
        "model_generated_comment": "Set the resolve version ranges for the given {@code value}.\n\n@param value The value to set."
    },
    {
        "id": 141,
        "code_snippet": "public static UsersDatabase getInstance(Context context) {\n        if (INSTANCE == null) {\n            synchronized (UsersDatabase.class) {\n                if (INSTANCE == null) {\n                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                            UsersDatabase.class, \"Sample.db\")\n                            .build();\n                }\n            }\n        }\n        return INSTANCE;\n    }",
        "human_comment": "The Room database that contains the Users table",
        "model_generated_comment": "Get the user database instance.\n\n@param context the context to get the database instance\n@return the userDatabase instance"
    },
    {
        "id": 142,
        "code_snippet": "protected MavenBaseLogger(String name) {\n        this.name = name;\n\n        String levelString = recursivelyComputeLevelString();\n        if (levelString != null) {\n            this.currentLogLevel = SimpleLoggerConfiguration.stringToLevel(levelString);\n        } else {\n            this.currentLogLevel = CONFIG_PARAMS.defaultLogLevel;\n        }\n    }",
        "human_comment": "Protected access allows only {@link MavenLoggerFactory} and also derived classes to instantiate\nMavenLoggerFactory instances.",
        "model_generated_comment": "Creates a new {@link MavenBaseLogger} with the given name.\n\n@param name the name of the logger, may be {@code null}."
    },
    {
        "id": 143,
        "code_snippet": "public final boolean matches(Object item) {\n        return item != null\n                && expectedType.isInstance(item)\n                && matchesSafely((T) item);\n    }",
        "human_comment": "Method made final to prevent accidental override.\nIf you need to override this, there's no point on extending TypeSafeMatcher.\nInstead, extend the {@link BaseMatcher}.",
        "model_generated_comment": "Returns whether the given item matches the given object.\n\n@param item the item to check\n@return true if the item matches"
    },
    {
        "id": 144,
        "code_snippet": "public Comparator<Description> testComparator() {\n        return new TestComparator();\n    }",
        "human_comment": "@return a comparator that ranks tests based on the JUnit Max sorting\nrules, as described in the {@link MaxCore} class comment.",
        "model_generated_comment": "Creates a {@link TestComparator}.\n\n@param testComparator the test comparison"
    },
    {
        "id": 145,
        "code_snippet": "public DefaultMojoExecutionConfigurator() {\n        this.messageBuilderFactory = new DefaultMessageBuilderFactory();\n    }",
        "human_comment": "Default ctor is used in IT and most probably some 3rd party code. For those cases, we do provide sane defaults\nbut given this is a component, injection should be used, replacing direct instantiation.\n\n@deprecated Do not use this ctor directly, inject this component instead.",
        "model_generated_comment": "Creates a new {@link DefaultMojoExecutionConfigurator}.\n\n@param builderFactory the builder to build the configurator."
    },
    {
        "id": 146,
        "code_snippet": "default Builder toBuilder() {\n        try {\n            return new Builder(\n                    getUserProperties(), getSystemProperties(), getStartTime(), getTopDirectory(), getRootDirectory());\n        } catch (IllegalStateException e) {\n            return new Builder(getUserProperties(), getSystemProperties(), getStartTime(), getTopDirectory(), null);\n        }\n    }",
        "human_comment": "Returns a proto session builder of this instance.",
        "model_generated_comment": "Returns a new Builder instance.\n\n@param builder the builder instance\n@return a new builder instance"
    },
    {
        "id": 147,
        "code_snippet": "public static void assertEquals(float expected, float actual, float delta, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, delta, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} float values are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code messageSupplier}.\n\n@since 5.4"
    },
    {
        "id": 148,
        "code_snippet": "public static void assertNotEquals(Character unexpected, Character actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@link AssertionError}.\n\n@since 5.4"
    },
    {
        "id": 149,
        "code_snippet": "private List<Restriction> intersection(List<Restriction> r1, List<Restriction> r2) {\n        List<Restriction> restrictions = new ArrayList<>(r1.size() + r2.size());\n        Iterator<Restriction> i1 = r1.iterator();\n        Iterator<Restriction> i2 = r2.iterator();\n        Restriction res1 = i1.next();\n        Restriction res2 = i2.next();\n\n        boolean done = false;\n        while (!done) {\n            if (res1.getLowerBound() == null\n                    || res2.getUpperBound() == null\n                    || res1.getLowerBound().compareTo(res2.getUpperBound()) <= 0) {\n                if (res1.getUpperBound() == null\n                        || res2.getLowerBound() == null\n                        || res1.getUpperBound().compareTo(res2.getLowerBound()) >= 0) {\n                    ArtifactVersion lower;\n                    ArtifactVersion upper;\n                    boolean lowerInclusive;\n                    boolean upperInclusive;\n\n                    if (res1.getLowerBound() == null) {\n                        lower = res2.getLowerBound();\n                        lowerInclusive = res2.isLowerBoundInclusive();\n                    } else if (res2.getLowerBound() == null) {\n                        lower = res1.getLowerBound();\n                        lowerInclusive = res1.isLowerBoundInclusive();\n                    } else {\n                        int comparison = res1.getLowerBound().compareTo(res2.getLowerBound());\n                        if (comparison < 0) {\n                            lower = res2.getLowerBound();\n                            lowerInclusive = res2.isLowerBoundInclusive();\n                        } else if (comparison == 0) {\n                            lower = res1.getLowerBound();\n                            lowerInclusive = res1.isLowerBoundInclusive() && res2.isLowerBoundInclusive();\n                        } else {\n                            lower = res1.getLowerBound();\n                            lowerInclusive = res1.isLowerBoundInclusive();\n                        }\n                    }\n\n                    if (res1.getUpperBound() == null) {\n                        upper = res2.getUpperBound();\n                        upperInclusive = res2.isUpperBoundInclusive();\n                    } else if (res2.getUpperBound() == null) {\n                        upper = res1.getUpperBound();\n                        upperInclusive = res1.isUpperBoundInclusive();\n                    } else {\n                        int comparison = res1.getUpperBound().compareTo(res2.getUpperBound());\n                        if (comparison < 0) {\n                            upper = res1.getUpperBound();\n                            upperInclusive = res1.isUpperBoundInclusive();\n                        } else if (comparison == 0) {\n                            upper = res1.getUpperBound();\n                            upperInclusive = res1.isUpperBoundInclusive() && res2.isUpperBoundInclusive();\n                        } else {\n                            upper = res2.getUpperBound();\n                            upperInclusive = res2.isUpperBoundInclusive();\n                        }\n                    }\n\n                    if (lower == null || upper == null || lower.compareTo(upper) != 0) {\n                        restrictions.add(new Restriction(lower, lowerInclusive, upper, upperInclusive));\n                    } else if (lowerInclusive && upperInclusive) {\n                        restrictions.add(new Restriction(lower, lowerInclusive, upper, upperInclusive));\n                    }\n\n                    if (upper == res2.getUpperBound()) {\n                        if (i2.hasNext()) {\n                            res2 = i2.next();\n                        } else {\n                            done = true;\n                        }\n                    } else {\n                        if (i1.hasNext()) {\n                            res1 = i1.next();\n                        } else {\n                            done = true;\n                        }\n                    }\n                } else {\n                    if (i1.hasNext()) {\n                        res1 = i1.next();\n                    } else {\n                        done = true;\n                    }\n                }\n            } else {\n                if (i2.hasNext()) {\n                    res2 = i2.next();\n                } else {\n                    done = true;\n                }\n            }\n        }\n\n        return restrictions;\n    }",
        "human_comment": "overlaps\ndon't add if they are equal and one is not inclusive\nnoinspection ObjectEquality\nadvance res2\nadvance res1\nmove on to next in r1\nmove on to next in r2",
        "model_generated_comment": "Intersects a list of {@link Restriction}.\n\n@param r1 The list containing the restrictions, may be {@code null}.\n@throws IllegalArgumentException if the list contains no restrictions"
    },
    {
        "id": 150,
        "code_snippet": "public void setSession(MavenSession session) {\n        AtomicReference<MavenSession> reference = DefaultLegacySupport.SESSION.get();\n        if (reference != null) {\n            reference.set(null);\n        }\n\n        if (session == null && reference != null) {\n            DefaultLegacySupport.SESSION.remove();\n        } else {\n            DefaultLegacySupport.SESSION.set(new AtomicReference<>(session));\n        }\n    }",
        "human_comment": "Helps to provide backward-compatibility with plugins that use legacy components. <strong>Warning:</strong> This is an\ninternal utility component that is only public for technical reasons, it is not part of the public API. In\nparticular, this component can be changed or deleted without prior notice.\n\n@since 3.0",
        "model_generated_comment": "Set the session of the session.\n\n@param session The session to set\n@return The session, never {@code null}"
    },
    {
        "id": 151,
        "code_snippet": "private ChannelFuture respond(Encodable result) {\n    SocketAddress remoteAddress = channel.remoteAddress();\n    return channel.writeAndFlush(result).addListener(future -> {\n      if (future.isSuccess()) {\n        logger.trace(\"Sent result {} to client {}\", result, remoteAddress);\n      } else {\n        logger.error(\"Error sending result {} to {}; closing connection\", future.cause(),\n          MDC.of(LogKeys.RESULT$.MODULE$, result),\n          MDC.of(LogKeys.HOST_PORT$.MODULE$, remoteAddress));\n        channel.close();\n      }\n    });\n  }",
        "human_comment": "Responds to a single message with some Encodable object. If a failure occurs while sending,\nit will be logged and the channel closed.",
        "model_generated_comment": "Sends the result to the channel.\n\n@param result the result\n@return the channel future"
    },
    {
        "id": 152,
        "code_snippet": "String getFilePath(String filename) {\n      String targetFile =\n        ExecutorDiskUtils.getFilePath(\n          appPathsInfo.activeLocalDirs,\n          appPathsInfo.subDirsPerLocalDir,\n          filename);\n      logger.debug(\"Get merged file {}\", targetFile);\n      return targetFile;\n    }",
        "human_comment": "The logic here is consistent with\n@see [[org.apache.spark.storage.DiskBlockManager#getMergedShuffleFile(\norg.apache.spark.storage.BlockId, scala.Option)]]",
        "model_generated_comment": "Get the file path for the target file.\n\n@param filename the file to get\n@return The file path"
    },
    {
        "id": 153,
        "code_snippet": "default boolean canOverwrite(Predicate[] predicates) {\n    return true;\n  }",
        "human_comment": "Checks whether it is possible to overwrite data from a data source table that matches filter\nexpressions.\n<p>\nRows should be overwritten from the data source iff all of the filter expressions match.\nThat is, the expressions must be interpreted as a set of filters that are ANDed together.\n\n@param predicates V2 filter expressions, used to match data to overwrite\n@return true if the delete operation can be performed\n\n@since 3.4.0",
        "model_generated_comment": "Can be read from a predicate.\n\n@param predicates the predicates to read from.\n@return true"
    },
    {
        "id": 154,
        "code_snippet": "public boolean isUnshredded() {\n    return topLevelMetadataIdx >= 0 && variantIdx >= 0 && typedIdx < 0;\n  }",
        "human_comment": "Return whether the variant column is unshrededed. The user is not required to do anything\nspecial, but can have certain optimizations for unshrededed variant.",
        "model_generated_comment": "Returns whether the top level metadata is unshredded.\n\n@param variantIdx The type of metadata to check."
    },
    {
        "id": 155,
        "code_snippet": "public static Tensor<Float> create(float[][][][][][] data) {\n    return Tensor.create(data, Float.class);\n  }",
        "human_comment": "Creates a rank-6 tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array.",
        "model_generated_comment": "Creates a tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor."
    },
    {
        "id": 156,
        "code_snippet": "public static Map<String, String> createDefaultConfigMap() {\n    Map<String, String> confMap = new HashMap<String, String>();\n    confMap.put(\"spark.ssl.rpc.enabled\", \"true\");\n    confMap.put(\"spark.ssl.rpc.openSslEnabled\", \"true\");\n    confMap.put(\"spark.ssl.rpc.privateKey\", SslSampleConfigs.unencryptedPrivateKeyPath);\n    // intentionally not set\n    // confMap.put(\"spark.ssl.rpc.privateKeyPassword\", \"password\");\n    confMap.put(\"spark.ssl.rpc.certChain\", SslSampleConfigs.unencryptedCertChainPath);\n    confMap.put(\"spark.ssl.enabled\", \"true\");\n    confMap.put(\"spark.ssl.keyPassword\", \"password\");\n    confMap.put(\"spark.ssl.trustStoreReloadingEnabled\", \"false\");\n    confMap.put(\"spark.ssl.trustStoreReloadIntervalMs\", \"10000\");\n    confMap.put(\"spark.ssl.keyStore\", SslSampleConfigs.keyStorePath);\n    confMap.put(\"spark.ssl.keyStorePassword\", \"password\");\n    confMap.put(\"spark.ssl.trustStore\", SslSampleConfigs.trustStorePath);\n    confMap.put(\"spark.ssl.trustStorePassword\", \"password\");\n    confMap.put(\"spark.ssl.protocol\", \"TLSv1.3\");\n    confMap.put(\"spark.ssl.standalone.enabled\", \"true\");\n    confMap.put(\"spark.ssl.ui.enabled\", \"true\");\n    return confMap;\n  }",
        "human_comment": "Creates a config map containing the settings needed to enable the RPC SSL feature\nAll the settings (except the enabled one) are intentionally set on the parent namespace\nso that we can verify settings inheritance works. We intentionally set conflicting\noptions for the key password to verify that is handled correctly.",
        "model_generated_comment": "Creates a new default config map.\n\n@param configMap the config map\n@return a new config map"
    },
    {
        "id": 157,
        "code_snippet": "public static void assertNotEquals(char unexpected, char actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and {@link actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}."
    },
    {
        "id": 158,
        "code_snippet": "void testDepth() {\n        ResolutionNode a1n = createResolutionNode(a1);\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n\n        assertResolveConflict(a1n, a1n, a2n);\n    }",
        "human_comment": "Tests that <code>a:1.0</code> wins in the scenario:\n<pre>\na:1.0\nb:1.0 -&gt; a:2.0\n</pre>",
        "model_generated_comment": "Unit tests for {@link ResolutionNode}.\n\n@since 5.0"
    },
    {
        "id": 159,
        "code_snippet": "public List<Artifact> getSystemArtifacts() {\n        List<Artifact> list = new ArrayList<>(getArtifacts().size());\n\n        for (Artifact a : getArtifacts()) {\n            if (a.getArtifactHandler().isAddedToClasspath()) {\n                if (Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\n                    list.add(a);\n                }\n            }\n        }\n        return list;\n    }",
        "human_comment": "TODO classpath check doesn't belong here - that's the other method\nTODO let the scope handler deal with this",
        "model_generated_comment": "Returns the list of {@link SystemArtifacts}.\n\n@param a {@code SystemArtifact}\n@return the list"
    },
    {
        "id": 160,
        "code_snippet": "public DelegateSymlinkTextInputSplit() {\n      super((Path) null, 0, 0, (String[]) null);\n      targetPath = null;\n    }",
        "human_comment": "Delegate for SymlinkTextInputFormat, created to address SPARK-40815.\nFixes an issue where SymlinkTextInputFormat returns empty splits which could result in\nthe correctness issue when \"spark.hadoopRDD.ignoreEmptySplits\" is enabled.\n<p>\nIn this class, we update the split start and length to match the target file input thus fixing\nthe issue.",
        "model_generated_comment": "DelegateSymlinkTextInputSplit.\n\n@param targetPath The input path to split."
    },
    {
        "id": 161,
        "code_snippet": "public void assertEmpty() {\n\t\tif (!isEmpty()) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(this.throwable);\n\t\t}\n\t}",
        "human_comment": "Assert that this {@code ThrowableCollector} is <em>empty</em> (i.e.,\nhas not collected any {@code Throwables}).\n\n<p>If this collector is not empty, the first collected {@code Throwable}\nwill be thrown with any additional {@code Throwables}\n{@linkplain Throwable#addSuppressed(Throwable) suppressed} in the\nfirst {@code Throwable}. Note, however, that the {@code Throwable}\nwill not be wrapped. Rather, it will be\n{@linkplain ExceptionUtils#throwAsUncheckedException masked}\nas an unchecked exception.\n\n@see #getThrowable()\n@see ExceptionUtils#throwAsUncheckedException(Throwable)",
        "model_generated_comment": "<em>Assert</em> that the supplied {@link ExceptionUtils}.\n\n@since 5.4"
    },
    {
        "id": 162,
        "code_snippet": "public IValue runMethod(String methodName, IValue... inputs) {\n    return mNativePeer.runMethod(methodName, inputs);\n  }",
        "human_comment": "Runs the specified method of this module with the specified arguments.\n\n@param methodName name of the TorchScript method to run.\n@param inputs arguments that will be passed to TorchScript method.\n@return return value from the method.",
        "model_generated_comment": "Creates a new {@link Method#runMethod} with the given method name and the supplied inputs.\n\n@param methodName the method name of the method to run\n@return a new Method"
    },
    {
        "id": 163,
        "code_snippet": "private Executions(Stream<Execution> executions, String category) {\n\t\tPreconditions.notNull(executions, \"Execution stream must not be null\");\n\n\t\tthis.executions = Collections.unmodifiableList(executions.collect(toList()));\n\t\tthis.category = category;\n\t}",
        "human_comment": "{@code Executions} is a facade that provides a fluent API for working with\n{@linkplain Execution executions}.\n\n@since 1.4",
        "model_generated_comment": "Create a new {@link Executions} with the supplied {@code execution} and the supplied category.\n\n@param executions the executions to put into the new stream; never\n{@code null} or blank\n@see #unmodifiableList(String)"
    },
    {
        "id": 164,
        "code_snippet": "void assertLinesMatch() {\n\t\t\tint expectedSize = expectedLines.size();\n\t\t\tint actualSize = actualLines.size();\n\n\t\t\tif (expectedSize > actualSize) {\n\t\t\t\tfail(\"expected %d lines, but only got %d\", expectedSize, actualSize);\n\t\t\t}\n\n\t\t\tif (expectedSize == actualSize) {\n\t\t\t\tif (IntStream.range(0, expectedSize).allMatch(i -> matches(expectedLines.get(i), actualLines.get(i)))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassertLinesMatchWithFastForward();\n\t\t}",
        "human_comment": "trivial case: when expecting more than actual lines available, something is wrong\nsimple case: both list are equally sized, compare them line-by-line\nelse fall-through to \"with fast-forward\" matching",
        "model_generated_comment": "<em>Assert</em> that {@code expectedSize} matches {@link actualSize}.\n\n@since 5.0"
    },
    {
        "id": 165,
        "code_snippet": "private static String[] parseProperty(String line) {\n            // sorry for this spaghetti code, please replace it as soon as\n            // possible with a regexp when the Java 1.3 requirement is dropped\n\n            String[] result = new String[2];\n            StringBuilder key = new StringBuilder();\n            StringBuilder value = new StringBuilder();\n\n            // state of the automaton:\n            // 0: key parsing\n            // 1: antislash found while parsing the key\n            // 2: separator crossing\n            // 3: white spaces\n            // 4: value parsing\n            int state = 0;\n\n            for (int pos = 0; pos < line.length(); pos++) {\n                char c = line.charAt(pos);\n\n                switch (state) {\n                    case 0:\n                        if (c == '\\\\') {\n                            state = 1;\n                        } else if (contains(WHITE_SPACE, c)) {\n                            // switch to the separator crossing state\n                            state = 2;\n                        } else if (contains(SEPARATORS, c)) {\n                            // switch to the value parsing state\n                            state = 3;\n                        } else {\n                            key.append(c);\n                        }\n\n                        break;\n\n                    case 1:\n                        if (contains(SEPARATORS, c) || contains(WHITE_SPACE, c)) {\n                            // this is an escaped separator or white space\n                            key.append(c);\n                        } else {\n                            // another escaped character, the '\\' is preserved\n                            key.append('\\\\');\n                            key.append(c);\n                        }\n\n                        // return to the key parsing state\n                        state = 0;\n\n                        break;\n\n                    case 2:\n                        if (contains(WHITE_SPACE, c)) {\n                            // do nothing, eat all white spaces\n                            state = 2;\n                        } else if (contains(SEPARATORS, c)) {\n                            // switch to the value parsing state\n                            state = 3;\n                        } else {\n                            // any other character indicates we encoutered the beginning of the value\n                            value.append(c);\n\n                            // switch to the value parsing state\n                            state = 4;\n                        }\n\n                        break;\n\n                    case 3:\n                        if (contains(WHITE_SPACE, c)) {\n                            // do nothing, eat all white spaces\n                            state = 3;\n                        } else {\n                            // any other character indicates we encoutered the beginning of the value\n                            value.append(c);\n\n                            // switch to the value parsing state\n                            state = 4;\n                        }\n\n                        break;\n\n                    case 4:\n                        value.append(c);\n                        break;\n\n                    default:\n                        throw new IllegalStateException();\n                }\n            }\n\n            result[0] = key.toString();\n            result[1] = value.toString();\n\n            return result;\n        }",
        "human_comment": "Parse a property line and return the key and the value in an array.\n\n@param line the line to parse\n@return an array with the property's key and value",
        "model_generated_comment": "Parses the property of the automaton.\n\n@param line The line to parse, may be <code>null</code>\n@return The property of this automaton\n@throws IllegalArgumentException if the key is null"
    },
    {
        "id": 166,
        "code_snippet": "public Builder withTimeout(long timeout, TimeUnit unit) {\n            if (timeout < 0) {\n                throw new IllegalArgumentException(\"timeout must be non-negative\");\n            }\n            if (unit == null) {\n                throw new NullPointerException(\"TimeUnit cannot be null\");\n            }\n            this.timeout = timeout;\n            this.unit = unit;\n            return this;\n        }",
        "human_comment": "Specifies the time to wait before timing out the test.\n\n<p>If this is not called, or is called with a {@code timeout} of\n{@code 0}, the returned {@code Statement} will wait forever for the\ntest to complete, however the test will still launch from a separate\nthread. This can be useful for disabling timeouts in environments\nwhere they are dynamically set based on some property.\n\n@param timeout the maximum time to wait\n@param unit the time unit of the {@code timeout} argument\n@return {@code this} for method chaining.",
        "model_generated_comment": "Creates a Builder with the specified timeout and unit.\n\n@param timeout the timeout of the builder, may be {@code null}."
    },
    {
        "id": 167,
        "code_snippet": "void throwAsUncheckedExceptionWithNullException() {\n\t\tassertThrows(PreconditionViolationException.class, () -> throwAsUncheckedException(null));\n\t}",
        "human_comment": "Unit tests for {@link ExceptionUtils}.\n\n@since 1.0",
        "model_generated_comment": "<em>Assert</em> that {@link PreconditionViolationException} throws an unchecked exception.\n\n@since 5.4"
    },
    {
        "id": 168,
        "code_snippet": "public List<String> getActiveProfiles() {\n        return Collections.unmodifiableList(new ArrayList<>(getProfileIds(pa -> pa.active())));\n    }",
        "human_comment": "Mimics the pre-Maven 4 \"active profiles\" list.\n@deprecated Use {@link #getRequiredActiveProfileIds()} and {@link #getOptionalActiveProfileIds()} instead.",
        "model_generated_comment": "Returns a list of active profiles.\n\n@param pa The active profiles\n@return a list containing active profiles"
    },
    {
        "id": 169,
        "code_snippet": "public Double finish(Average reduction) {\n      return ((double) reduction.getSum()) / reduction.getCount();\n    }",
        "human_comment": "Transform the output of the reduction",
        "model_generated_comment": "Creates a Double finish of the given reduction.\n\n@param reduction the reduction to finish."
    },
    {
        "id": 170,
        "code_snippet": "public MetadataResolutionResult addVersionRangeViolation(Exception e) {\n        versionRangeViolations = initList(versionRangeViolations);\n\n        versionRangeViolations.add(e);\n\n        exceptions = initList(exceptions);\n\n        exceptions.add(e);\n\n        return this;\n    }",
        "human_comment": "TODO this needs to accept a {@link OverConstrainedVersionException} as returned by\n{@link #getVersionRangeViolation(int)} but it's not used like that in\n{@link org.apache.maven.repository.legacy.resolver.DefaultLegacyArtifactCollector}",
        "model_generated_comment": "Add a version rangeViolation to the result.\n\n@param e the version range to add\n@return this result"
    },
    {
        "id": 171,
        "code_snippet": "public static Tensor<Boolean> create(boolean[][][][] data) {\n    return Tensor.create(data, Boolean.class);\n  }",
        "human_comment": "Creates a rank-4 tensor of {@code boolean} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array.",
        "model_generated_comment": "Creates a rank-4 tensor of {@code boolean} elements.\n\n@param data An array containing the values to put into the new tensor."
    },
    {
        "id": 172,
        "code_snippet": "void monitorChild() {\n    Process proc = childProc;\n    if (proc == null) {\n      // Process may have already been disposed of, e.g. by calling kill().\n      return;\n    }\n\n    while (proc.isAlive()) {\n      try {\n        proc.waitFor();\n      } catch (Exception e) {\n        LOG.log(Level.WARNING, \"Exception waiting for child process to exit.\", e);\n      }\n    }\n\n    synchronized (this) {\n      if (isDisposed()) {\n        return;\n      }\n\n      int ec;\n      try {\n        ec = proc.exitValue();\n      } catch (Exception e) {\n        LOG.log(Level.WARNING, \"Exception getting child process exit code, assuming failure.\", e);\n        ec = 1;\n      }\n\n      if (ec != 0) {\n        State currState = getState();\n        // Override state with failure if the current state is not final, or is success.\n        if (!currState.isFinal() || currState == State.FINISHED) {\n          setState(State.FAILED, true);\n        }\n      }\n\n      dispose();\n    }\n  }",
        "human_comment": "Wait for the child process to exit and update the handle's state if necessary, according to\nthe exit code.",
        "model_generated_comment": "Monitor the child process exit code.\n\n@param childProc The child process to exit, must not be {@code null}."
    },
    {
        "id": 173,
        "code_snippet": "public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive) {\n        Key key = new Key(project, transitive, true);\n        List<MavenProject> list = cache.get(key);\n        if (list == null) {\n            list = applyFilter(projectDependencyGraph.getUpstreamProjects(project, transitive), transitive, true);\n            cache.put(key, list);\n        }\n        return list;\n    }",
        "human_comment": "Do not use computeIfAbsent here, as the computation is recursive\nand this is not supported by computeIfAbsent.",
        "model_generated_comment": "Get upstream projects from the repository.\n\n@param project the project\n@return the list of projects to get upstream, never {@code null}"
    },
    {
        "id": 174,
        "code_snippet": "public Object setProperty(String key, String value) {\n        return this.put(key, value);\n    }",
        "human_comment": "Calls the map method put. Provided for parallelism with the getProperty method.\nEnforces use of strings for property keys and values. The value returned is the result of the map call to put.\n\n@param key the key to be placed into this property list.\n@param value the value corresponding to the key.\n@return the previous value of the specified key in this property list, or null if it did not have one.",
        "model_generated_comment": "Set the value of the property.\n\n@param key the key to set."
    },
    {
        "id": 175,
        "code_snippet": "private static List<Long> runsJDKWorstCase(int minRun, int length) {\n    List<Long> runs = new ArrayList<>();\n\n    long runningTotal = 0, Y = minRun + 4, X = minRun;\n\n    while (runningTotal + Y + X <= length) {\n      runningTotal += X + Y;\n      generateJDKWrongElem(runs, minRun, X);\n      runs.add(0, Y);\n      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}\n      X = Y + runs.get(1) + 1;\n      // Y_{i+1} = X_{i+1} + Y_i + 1\n      Y += X + 1;\n    }\n\n    if (runningTotal + X <= length) {\n      runningTotal += X;\n      generateJDKWrongElem(runs, minRun, X);\n    }\n\n    runs.add(length - runningTotal);\n    return runs;\n  }",
        "human_comment": "Fills <code>runs</code> with a sequence of run lengths of the form<br>\nY_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>\nY_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>\n... <br>\nY_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>\nThe Y_i's are chosen to satisfy the invariant throughout execution,\nbut the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)\ninto an X_i that violates the invariant.\n\n@param length The sum of all run lengths that will be added to <code>runs</code>.",
        "model_generated_comment": "Runs JDKWorstCase with the given minRun.\n\n@param minRun the minRun to run, must not be <code>length</code>.\n@return the list of runs, never {@code null}"
    },
    {
        "id": 176,
        "code_snippet": "void testFromString(NumberExpression first) {\n    final var expectedValue = first.interpret();\n    final var testStringValue = String.valueOf(expectedValue);\n    final var numberExpression = new NumberExpression(testStringValue);\n    assertEquals(expectedValue, numberExpression.interpret());\n  }",
        "human_comment": "Verify if the {@link NumberExpression#NumberExpression(String)} constructor works as expected",
        "model_generated_comment": "Unit tests for {@link NumberExpression}.\n\n@param first the first string to test."
    },
    {
        "id": 177,
        "code_snippet": "public Location lookup(Object keyBase, long keyOffset, int keyLength) {\n    safeLookup(keyBase, keyOffset, keyLength, loc,\n      Murmur3_x86_32.hashUnsafeWords(keyBase, keyOffset, keyLength, 42));\n    return loc;\n  }",
        "human_comment": "Looks up a key, and return a {@link Location} handle that can be used to test existence\nand read/write values.\n\nThis function always returns the same {@link Location} instance to avoid object allocation.\nThis function is not thread-safe.",
        "model_generated_comment": "Create a new {@link Location} with the given keyBase and keyOffset.\n\n@param keyBase the keyBase of the {@code Location}\n@return a new Location"
    },
    {
        "id": 178,
        "code_snippet": "default <A extends Annotation> List<A> findRepeatableAnnotations(Class<A> annotationType) {\n\t\treturn AnnotationSupport.findRepeatableAnnotations(getAnnotatedElement(), annotationType);\n\t}",
        "human_comment": "Find all <em>repeatable</em> {@linkplain Annotation annotations} of\n{@code annotationType} that are either <em>present</em> or\n<em>meta-present</em> on the {@link AnnotatedElement} for this context.\n\n<h4>WARNING</h4>\n<p>Favor the use of this method over directly invoking annotation lookup\nmethods in the {@link AnnotatedElement} API due to a bug in {@code javac} on JDK\nversions prior to JDK 9.\n\n@param <A> the annotation type\n@param annotationType the repeatable annotation type to search for; never\n{@code null}\n@return the list of all such annotations found; neither {@code null} nor\nmutable, but potentially empty\n@see #isAnnotated(Class)\n@see #findAnnotation(Class)\n@see java.lang.annotation.Repeatable",
        "model_generated_comment": "Find repeatable annotations for {@link Annotation#getAnnotatedElement(), annotationType}.\n\n@param annotationType the annotation type to find; never {@code null}\n@return AnnotationSupport.findRepeatableAnnotations(class, class, annotationType)"
    },
    {
        "id": 179,
        "code_snippet": "void parseClasspathResourcesWithFilePosition() {\n\t\t\tvar filePosition = FilePosition.from(12, 34);\n\t\t\tvar selector = parseIdentifier(selectClasspathResource(\"/foo/bar/spec.xml\", FilePosition.from(12, 34)));\n\t\t\tassertThat(selector) //\n\t\t\t\t\t.asInstanceOf(type(ClasspathResourceSelector.class)) //\n\t\t\t\t\t.extracting(ClasspathResourceSelector::getClasspathResourceName,\n\t\t\t\t\t\tClasspathResourceSelector::getPosition) //\n\t\t\t\t\t.containsExactly(\"foo/bar/spec.xml\", Optional.of(filePosition));\n\n\t\t\tselector = parseIdentifier(selectClasspathResource(\"A/B/C/spec.json\", FilePosition.from(12, 34)));\n\t\t\tassertThat(selector) //\n\t\t\t\t\t.asInstanceOf(type(ClasspathResourceSelector.class)) //\n\t\t\t\t\t.extracting(ClasspathResourceSelector::getClasspathResourceName,\n\t\t\t\t\t\tClasspathResourceSelector::getPosition) //\n\t\t\t\t\t.containsExactly(\"A/B/C/spec.json\", Optional.of(filePosition));\n\t\t}",
        "human_comment": "with unnecessary \"/\" prefix\nstandard use case",
        "model_generated_comment": "Unit tests for {@link ClasspathResourceSelector}.\n\n@since 5.0"
    },
    {
        "id": 180,
        "code_snippet": "public void testNormalize2() {\n        Money expected = new Money(7, \"USD\");\n        assertEquals(expected, fMB1.subtract(f12CHF));\n    }",
        "human_comment": "{[12 CHF][7 USD]} - [12 CHF] == [7 USD]",
        "model_generated_comment": "Unit tests for {@link Normalize2}.\n\n@param expected {@code USD}"
    },
    {
        "id": 181,
        "code_snippet": "public static void assertNotEquals(float unexpected, Float actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Float) unexpected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and{@code actual} float are not equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\nsupplied {@link Float#equals(Object)}\n\n@since 5.4"
    },
    {
        "id": 182,
        "code_snippet": "public static void dropSession() {\n    getSessionFactory().close();\n    sessionFactory = null;\n  }",
        "human_comment": "Drop the current connection, resulting in a create-drop clean database next time. This is\nmainly used for JUnit testing since one test should not influence the other",
        "model_generated_comment": "Sets the session of the session.\n\n@param sessionFactory the session to drop."
    },
    {
        "id": 183,
        "code_snippet": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaKLatentDirichletAllocationExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    String path = \"data/mllib/sample_lda_data.txt\";\n    JavaRDD<String> data = jsc.textFile(path);\n    JavaRDD<Vector> parsedData = data.map(s -> {\n      String[] sarray = s.trim().split(\" \");\n      double[] values = new double[sarray.length];\n      for (int i = 0; i < sarray.length; i++) {\n        values[i] = Double.parseDouble(sarray[i]);\n      }\n      return Vectors.dense(values);\n    });\n    JavaPairRDD<Long, Vector> corpus =\n      JavaPairRDD.fromJavaRDD(parsedData.zipWithIndex().map(Tuple2::swap));\n    corpus.cache();\n\n    LDAModel ldaModel = new LDA().setK(3).run(corpus);\n\n    System.out.println(\"Learned topics (as distributions over vocab of \" + ldaModel.vocabSize()\n      + \" words):\");\n    Matrix topics = ldaModel.topicsMatrix();\n    for (int topic = 0; topic < 3; topic++) {\n      System.out.print(\"Topic \" + topic + \":\");\n      for (int word = 0; word < ldaModel.vocabSize(); word++) {\n        System.out.print(\" \" + topics.apply(word, topic));\n      }\n      System.out.println();\n    }\n\n    ldaModel.save(jsc.sc(),\n      \"target/org/apache/spark/JavaLatentDirichletAllocationExample/LDAModel\");\n    DistributedLDAModel sameModel = DistributedLDAModel.load(jsc.sc(),\n      \"target/org/apache/spark/JavaLatentDirichletAllocationExample/LDAModel\");\n\n    jsc.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data\nIndex documents with unique IDs\nCluster the documents into three topics using LDA\nOutput topics. Each is a distribution over words (matching word count vectors)\n$example off$",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 184,
        "code_snippet": "void whereWithNullFunction() {\n\t\tvar exception = assertThrows(PreconditionViolationException.class, () -> FunctionUtils.where(null, o -> true));\n\t\tassertEquals(\"function must not be null\", exception.getMessage());\n\t}",
        "human_comment": "Unit tests for {@link FunctionUtils}.\n\n@since 1.0",
        "model_generated_comment": "<em>Assert</em> that {@code null} does not exist.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@link FunctionUtils}.\n\n@since 5.4"
    },
    {
        "id": 185,
        "code_snippet": "public static SelectorResolutionResult failed(Throwable throwable) {\n\t\treturn new SelectorResolutionResult(Status.FAILED, throwable);\n\t}",
        "human_comment": "Create a {@code SelectorResolutionResult} for a <em>failed</em>\nselector resolution.\n@return the {@code SelectorResolutionResult}; never {@code null}",
        "model_generated_comment": "Create a new {@code SelectorResolutionResult} for the supplied {@link Throwable}.\n\n@param throwable the throwable to be used to select; never\n{@code null}"
    },
    {
        "id": 186,
        "code_snippet": "public String nextPropertyName() {\n            final int start = idx;\n\n            while (idx < expression.length() && Character.isJavaIdentifierPart(expression.charAt(idx))) {\n                idx++;\n            }\n\n            if (idx <= start || idx > expression.length()) {\n                return null;\n            }\n\n            return expression.substring(start, idx);\n        }",
        "human_comment": "property name does not require delimiter",
        "model_generated_comment": "Creates a new property name for the specified character.\n\n@param start the character name\n@return the next property name"
    },
    {
        "id": 187,
        "code_snippet": "public void registerExecutor(String appId, ExecutorShuffleInfo executorInfo) {\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"register executor with RemoteBlockPushResolver {} local-dirs {} \"\n        + \"num sub-dirs {} shuffleManager {}\", appId, Arrays.toString(executorInfo.localDirs),\n        executorInfo.subDirsPerLocalDir, executorInfo.shuffleManager);\n    }\n    String shuffleManagerMeta = executorInfo.shuffleManager;\n    if (shuffleManagerMeta.contains(SHUFFLE_META_DELIMITER)) {\n      String mergeDirInfo =\n        shuffleManagerMeta.substring(shuffleManagerMeta.indexOf(SHUFFLE_META_DELIMITER) + 1);\n      try {\n        ObjectMapper mapper = new ObjectMapper();\n        TypeReference<Map<String, String>> typeRef\n          = new TypeReference<Map<String, String>>(){};\n        if (attemptId == UNDEFINED_ATTEMPT_ID) {\n          appsShuffleInfo.computeIfAbsent(appId, id -> {\n            AppPathsInfo appPathsInfo = new AppPathsInfo(appId, executorInfo.localDirs,\n                mergeDir, executorInfo.subDirsPerLocalDir);\n            writeAppPathsInfoToDb(appId, UNDEFINED_ATTEMPT_ID, appPathsInfo);\n            return new AppShuffleInfo(appId, UNDEFINED_ATTEMPT_ID, appPathsInfo);\n          });\n        } else {\n          AtomicReference<AppShuffleInfo> originalAppShuffleInfo = new AtomicReference<>();\n          appsShuffleInfo.compute(appId, (id, appShuffleInfo) -> {\n            if (appShuffleInfo == null || attemptId > appShuffleInfo.attemptId) {\n              originalAppShuffleInfo.set(appShuffleInfo);\n              AppPathsInfo appPathsInfo = new AppPathsInfo(appId, executorInfo.localDirs,\n                  mergeDir, executorInfo.subDirsPerLocalDir);\n              if (appShuffleInfo != null) {\n                removeAppAttemptPathInfoFromDB(appId, appShuffleInfo.attemptId);\n              }\n              writeAppPathsInfoToDb(appId, attemptId, appPathsInfo);\n              appShuffleInfo =\n                new AppShuffleInfo(\n                  appId, attemptId,\n                  new AppPathsInfo(appId, executorInfo.localDirs,\n                    mergeDir, executorInfo.subDirsPerLocalDir));\n            }\n            return appShuffleInfo;\n          });\n          if (originalAppShuffleInfo.get() != null) {\n            AppShuffleInfo appShuffleInfo = originalAppShuffleInfo.get();\n            logger.warn(\"Cleanup shuffle info and merged shuffle files for {}_{} as new \" +\n        }\n      } catch (JsonProcessingException e) {\n        logger.warn(\"Failed to get the merge directory information from ExecutorShuffleInfo: \", e);\n      }\n    } else {\n      logger.warn(\"ExecutorShuffleInfo does not have the expected merge directory information\");\n    }\n  }\n\n  @Override\n  public void close() {\n    if (!mergedShuffleCleaner.isShutdown()) {\n      // SPARK-40186\uff1aUse two phases shutdown refer to\n      // https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html\n      // Use two phases shutdown can prevent new tasks and wait for executing tasks to\n      // complete gracefully, and once timeout is reached, we want to interrupt running tasks,\n      // so that they fail. This is to prevent updates to shuffle state db after it is closed.\n      try {\n        mergedShuffleCleaner.shutdown();\n        // Wait a while for existing tasks to terminate\n        if (!mergedShuffleCleaner.awaitTermination(cleanerShutdownTimeout, TimeUnit.SECONDS)) {\n          shutdownMergedShuffleCleanerNow();\n        }\n      } catch (InterruptedException e) {\n        logger.info(\"mergedShuffleCleaner is interrupted in the process of graceful shutdown\", e);\n        shutdownMergedShuffleCleanerNow();\n        Thread.currentThread().interrupt();\n      }\n    }\n    if (db != null) {\n      try {\n        db.close();\n      } catch (IOException e) {\n        logger.error(\"Exception closing leveldb with registered app paths info and \"\n            + \"shuffle partition info\", e);\n      }\n    }\n  }\n\n  private void shutdownMergedShuffleCleanerNow() {\n    try {\n      List<Runnable> unfinishedTasks = mergedShuffleCleaner.shutdownNow();\n      logger.warn(\"There are still {} tasks not completed in mergedShuffleCleaner \" +\n        \"after {} ms.\",\n         MDC.of(LogKeys.COUNT$.MODULE$, unfinishedTasks.size()),\n         MDC.of(LogKeys.TIMEOUT$.MODULE$, cleanerShutdownTimeout * 1000L));\n      // Wait a while for tasks to respond to being cancelled\n      if (!mergedShuffleCleaner.awaitTermination(cleanerShutdownTimeout, TimeUnit.SECONDS)) {\n        logger.warn(\"mergedShuffleCleaner did not terminate in {} ms.\",\n          MDC.of(LogKeys.TIMEOUT$.MODULE$, cleanerShutdownTimeout * 1000L));\n      }\n    } catch (InterruptedException ignored) {\n      Thread.currentThread().interrupt();\n    }\n  }\n\n  private void writeAppPathsInfoToDb(String appId, int attemptId, AppPathsInfo appPathsInfo) {\n    if (db != null && AppsWithRecoveryDisabled.isRecoveryEnabledForApp(appId)) {\n      AppAttemptId appAttemptId = new AppAttemptId(appId, attemptId);\n      try {\n        byte[] key = getDbAppAttemptPathsKey(appAttemptId);\n        String valueStr = mapper.writeValueAsString(appPathsInfo);\n        byte[] value = valueStr.getBytes(StandardCharsets.UTF_8);\n        db.put(key, value);\n      } catch (Exception e) {\n        logger.error(\"Error saving registered app paths info for {}\", e,\n          MDC.of(LogKeys.APP_ATTEMPT_ID$.MODULE$, appAttemptId));\n      }\n    }\n  }\n\n  private void writeAppAttemptShuffleMergeInfoToDB(\n      AppAttemptShuffleMergeId appAttemptShuffleMergeId) {\n    if (db != null && AppsWithRecoveryDisabled.isRecoveryEnabledForApp(\n        appAttemptShuffleMergeId.appId)) {\n      // Write AppAttemptShuffleMergeId into LevelDB for finalized shuffles\n      try{\n        byte[] dbKey = getDbAppAttemptShufflePartitionKey(appAttemptShuffleMergeId);\n        db.put(dbKey, new byte[0]);\n      } catch (Exception e) {\n        logger.error(\"Error saving active app shuffle partition {}\", e,\n          MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId));\n      }\n    }\n  }\n\n  private <T> T parseDbKey(String key, String prefix, Class<T> valueType) throws IOException {\n    String json = key.substring(prefix.length() + 1);\n    return mapper.readValue(json, valueType);\n  }\n\n  private AppAttemptId parseDbAppAttemptPathsKey(String key) throws IOException {\n    return parseDbKey(key, APP_ATTEMPT_PATH_KEY_PREFIX, AppAttemptId.class);\n  }\n\n  private AppAttemptShuffleMergeId parseDbAppAttemptShufflePartitionKey(\n      String key) throws IOException {\n    return parseDbKey(\n        key, APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX, AppAttemptShuffleMergeId.class);\n  }\n\n  private byte[] getDbKey(Object key, String prefix) throws IOException {\n    // We add a common prefix on all the keys so we can find them in the DB\n    String keyJsonString = prefix + DB_KEY_DELIMITER + mapper.writeValueAsString(key);\n    return keyJsonString.getBytes(StandardCharsets.UTF_8);\n  }\n\n  private byte[] getDbAppAttemptShufflePartitionKey(\n      AppAttemptShuffleMergeId appAttemptShuffleMergeId) throws IOException {\n    return getDbKey(appAttemptShuffleMergeId, APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX);\n  }\n\n  private byte[] getDbAppAttemptPathsKey(AppAttemptId appAttemptId) throws IOException {\n    return getDbKey(appAttemptId, APP_ATTEMPT_PATH_KEY_PREFIX);\n  }\n\n  @VisibleForTesting\n  void reloadAndCleanUpAppShuffleInfo(DB db) throws IOException {\n    logger.info(\"Reload applications merged shuffle information from DB\");\n    List<byte[]> dbKeysToBeRemoved = new ArrayList<>();\n    dbKeysToBeRemoved.addAll(reloadActiveAppAttemptsPathInfo(db));\n    dbKeysToBeRemoved.addAll(reloadFinalizedAppAttemptsShuffleMergeInfo(db));\n    removeOutdatedKeyValuesInDB(dbKeysToBeRemoved);\n  }\n\n  @VisibleForTesting\n  List<byte[]> reloadActiveAppAttemptsPathInfo(DB db) throws IOException {\n    List<byte[]> dbKeysToBeRemoved = new ArrayList<>();\n    if (db != null) {\n      try (DBIterator itr = db.iterator()) {\n        itr.seek(APP_ATTEMPT_PATH_KEY_PREFIX.getBytes(StandardCharsets.UTF_8));\n        while (itr.hasNext()) {\n          Map.Entry<byte[], byte[]> entry = itr.next();\n          String key = new String(entry.getKey(), StandardCharsets.UTF_8);\n          if (!key.startsWith(APP_ATTEMPT_PATH_KEY_PREFIX)) {\n            break;\n          }\n          AppAttemptId appAttemptId = parseDbAppAttemptPathsKey(key);\n          AppPathsInfo appPathsInfo = mapper.readValue(entry.getValue(), AppPathsInfo.class);\n          logger.debug(\"Reloading Application paths info for application {}\", appAttemptId);\n          appsShuffleInfo.compute(appAttemptId.appId,\n              (appId, existingAppShuffleInfo) -> {\n                if (existingAppShuffleInfo == null ||\n                    existingAppShuffleInfo.attemptId < appAttemptId.attemptId) {\n                  if (existingAppShuffleInfo != null) {\n                    AppAttemptId existingAppAttemptId = new AppAttemptId(\n                        existingAppShuffleInfo.appId, existingAppShuffleInfo.attemptId);\n                    try {\n                      // Add the former outdated DB key to deletion list\n                      dbKeysToBeRemoved.add(getDbAppAttemptPathsKey(existingAppAttemptId));\n                    } catch (IOException e) {\n                      logger.error(\"Failed to get the DB key for {}\", e,\n                        MDC.of(LogKeys.APP_ATTEMPT_ID$.MODULE$, existingAppAttemptId));\n                    }\n                  }\n                  return new AppShuffleInfo(\n                      appAttemptId.appId, appAttemptId.attemptId, appPathsInfo);\n                } else {\n                  // Add the current DB key to deletion list as it is outdated\n                  dbKeysToBeRemoved.add(entry.getKey());\n                  return existingAppShuffleInfo;\n                }\n          });\n        }\n      }\n    }\n    return dbKeysToBeRemoved;\n  }\n\n  @VisibleForTesting\n  List<byte[]> reloadFinalizedAppAttemptsShuffleMergeInfo(DB db) throws IOException {\n    List<byte[]> dbKeysToBeRemoved = new ArrayList<>();\n    if (db != null) {\n      try (DBIterator itr = db.iterator()) {\n        itr.seek(APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX.getBytes(StandardCharsets.UTF_8));\n        while (itr.hasNext()) {\n          Map.Entry<byte[], byte[]> entry = itr.next();\n          String key = new String(entry.getKey(), StandardCharsets.UTF_8);\n          if (!key.startsWith(APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX)) {\n            break;\n          }\n          AppAttemptShuffleMergeId partitionId = parseDbAppAttemptShufflePartitionKey(key);\n          logger.debug(\"Reloading finalized shuffle info for partitionId {}\", partitionId);\n          AppShuffleInfo appShuffleInfo = appsShuffleInfo.get(partitionId.appId);\n          if (appShuffleInfo != null && appShuffleInfo.attemptId == partitionId.attemptId) {\n            appShuffleInfo.shuffles.compute(partitionId.shuffleId,\n                (shuffleId, existingMergePartitionInfo) -> {\n                  if (existingMergePartitionInfo == null ||\n                      existingMergePartitionInfo.shuffleMergeId < partitionId.shuffleMergeId) {\n                    if (existingMergePartitionInfo != null) {\n                      AppAttemptShuffleMergeId appAttemptShuffleMergeId =\n                          new AppAttemptShuffleMergeId(\n                              appShuffleInfo.appId, appShuffleInfo.attemptId,\n                              shuffleId, existingMergePartitionInfo.shuffleMergeId);\n                      try{\n                        dbKeysToBeRemoved.add(\n                            getDbAppAttemptShufflePartitionKey(appAttemptShuffleMergeId));\n                      } catch (Exception e) {\n                        logger.error(\"Error getting the DB key for {}\", e, MDC.of(\n                          LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId));\n                      }\n                    }\n                    return new AppShuffleMergePartitionsInfo(partitionId.shuffleMergeId, true);\n                  } else {\n                    dbKeysToBeRemoved.add(entry.getKey());\n                    return existingMergePartitionInfo;\n                  }\n            });\n          } else {\n            dbKeysToBeRemoved.add(entry.getKey());\n          }\n        }\n      }\n    }\n    return dbKeysToBeRemoved;\n  }\n\n  @VisibleForTesting\n  void removeOutdatedKeyValuesInDB(List<byte[]> dbKeysToBeRemoved) {\n      dbKeysToBeRemoved.forEach(\n          (key) -> {\n            try {\n              db.delete(key);\n            } catch (Exception e) {\n              logger.error(\"Error deleting dangling key {} in DB\", e,\n                MDC.of(LogKeys.KEY$.MODULE$, key));\n            }\n          }\n      );\n  }\n\n  @VisibleForTesting\n  void submitCleanupTask(Runnable task) {\n    mergedShuffleCleaner.execute(task);\n  }\n\n  @VisibleForTesting\n  boolean isCleanerShutdown() {\n    return mergedShuffleCleaner.isShutdown();\n  }\n\n  static class PushBlockStreamCallback implements StreamCallbackWithID {\n\n    private final RemoteBlockPushResolver mergeManager;\n    private final AppShuffleInfo appShuffleInfo;\n    private final String streamId;\n    private final int mapIndex;\n    private final AppShufflePartitionInfo partitionInfo;\n    private int length = 0;\n    // This indicates that this stream got the opportunity to write the blocks to the merged file.\n    // Once this is set to true and the stream encounters a failure then it will unset the\n    // currentMapId of the partition so that another stream can start merging the blocks to the\n    // partition. This is reset to false when the stream completes.\n    private boolean isWriting = false;\n    // Use on-heap instead of direct ByteBuffer since these buffers will be GC'ed very quickly\n    private List<ByteBuffer> deferredBufs;\n\n    // This collects the total pushed block bytes received in the onData method. Once these bytes\n    // are not being used, we add them to the ignoredBlockBytes of the pushMergeMetrics.\n    private long receivedBytes = 0;\n\n    private PushBlockStreamCallback(\n        RemoteBlockPushResolver mergeManager,\n        AppShuffleInfo appShuffleInfo,\n        String streamId,\n        AppShufflePartitionInfo partitionInfo,\n        int mapIndex) {\n      Preconditions.checkArgument(mergeManager != null);\n      this.mergeManager = mergeManager;\n      Preconditions.checkArgument(appShuffleInfo != null);\n      this.appShuffleInfo = appShuffleInfo;\n      this.streamId = streamId;\n      Preconditions.checkArgument(partitionInfo != null);\n      this.partitionInfo = partitionInfo;\n      this.mapIndex = mapIndex;\n      abortIfNecessary();\n    }\n\n    @Override\n    public String getID() {\n      return streamId;\n    }\n\n    @Override\n    public ByteBuffer getCompletionResponse() {\n      return SUCCESS_RESPONSE.duplicate();\n    }\n\n    private void writeBuf(ByteBuffer buf) throws IOException {\n      while (buf.hasRemaining()) {\n        long updatedPos = partitionInfo.getDataFilePos() + length;\n        logger.debug(\"{} current pos {} updated pos {}\", partitionInfo,\n          partitionInfo.getDataFilePos(), updatedPos);\n        int bytesWritten = partitionInfo.dataChannel.write(buf, updatedPos);\n        length += bytesWritten;\n        mergeManager.pushMergeMetrics.blockBytesWritten.mark(bytesWritten);\n      }\n    }\n\n    private boolean allowedToWrite() {\n      return partitionInfo.getCurrentMapIndex() < 0\n        || partitionInfo.getCurrentMapIndex() == mapIndex;\n    }\n\n    private boolean isDuplicateBlock() {\n      return (partitionInfo.getCurrentMapIndex() == mapIndex && length == 0)\n        || partitionInfo.mapTracker.contains(mapIndex);\n    }\n\n    private void writeDeferredBufs() throws IOException {\n      long totalSize = 0;\n      for (ByteBuffer deferredBuf : deferredBufs) {\n        totalSize += deferredBuf.limit();\n        writeBuf(deferredBuf);\n        mergeManager.pushMergeMetrics.deferredBlocks.mark(-1);\n      }\n      mergeManager.pushMergeMetrics.deferredBlockBytes.dec(totalSize);\n      deferredBufs = null;\n    }\n\n    private void freeDeferredBufs() {\n      if (deferredBufs != null && !deferredBufs.isEmpty()) {\n        long totalSize = 0;\n        for (ByteBuffer deferredBuf : deferredBufs) {\n          totalSize += deferredBuf.limit();\n          mergeManager.pushMergeMetrics.deferredBlocks.mark(-1);\n        }\n        mergeManager.pushMergeMetrics.deferredBlockBytes.dec(totalSize);\n      }\n      deferredBufs = null;\n    }\n\n    private void abortIfNecessary() {\n      if (partitionInfo.shouldAbort(mergeManager.ioExceptionsThresholdDuringMerge)) {\n        freeDeferredBufs();\n        throw new IllegalStateException(String.format(\"%s when merging %s\",\n          ErrorHandler.BlockPushErrorHandler.IOEXCEPTIONS_EXCEEDED_THRESHOLD_PREFIX,\n          streamId));\n      }\n    }\n\n    private void updateIgnoredBlockBytes() {\n      if (receivedBytes > 0) {\n        mergeManager.pushMergeMetrics.ignoredBlockBytes.mark(receivedBytes);\n        receivedBytes = 0;\n      }\n    }\n\n    private void incrementIOExceptionsAndAbortIfNecessary() {\n      // Update the count of IOExceptions\n      partitionInfo.incrementIOExceptions();\n      abortIfNecessary();\n    }\n\n    private boolean isStale(\n        AppShuffleMergePartitionsInfo appShuffleMergePartitionsInfo,\n        int shuffleMergeId) {\n      return null == appShuffleMergePartitionsInfo ||\n        appShuffleMergePartitionsInfo.shuffleMergeId > shuffleMergeId;\n    }\n\n    private boolean isTooLate(\n        AppShuffleMergePartitionsInfo appShuffleMergePartitionsInfo,\n        int reduceId) {\n      return null == appShuffleMergePartitionsInfo ||\n        appShuffleMergePartitionsInfo.isFinalized() ||\n        !appShuffleMergePartitionsInfo.shuffleMergePartitions.containsKey(reduceId);\n    }\n\n    @Override\n    public void onData(String streamId, ByteBuffer buf) throws IOException {\n      receivedBytes += buf.remaining();\n      // When handling the block data using StreamInterceptor, it can help to reduce the amount\n      // of data that needs to be buffered in memory since it does not wait till the completion\n      // of the frame before handling the message, thus releasing the ByteBuf earlier. However,\n      // this also means it would chunk a block into multiple buffers. Here, we want to preserve\n      // the benefit of handling the block data using StreamInterceptor as much as possible while\n      // providing the guarantee that one block would be continuously written to the merged\n      // shuffle file before the next block starts. For each shuffle partition, we would track\n      // the current map index to make sure only block matching the map index can be written to\n      // disk. If one server thread sees the block being handled is the current block, it would\n      // directly write the block to disk. Otherwise, it would buffer the block chunks in memory.\n      // If the block becomes the current block before we see the end of it, we would then dump\n      // all buffered block data to disk and write the remaining portions of the block directly\n      // to disk as well. This way, we avoid having to buffer the entirety of every blocks in\n      // memory, while still providing the necessary guarantee.\n      synchronized (partitionInfo) {\n        AppShuffleMergePartitionsInfo info =\n            appShuffleInfo.shuffles.get(partitionInfo.appAttemptShuffleMergeId.shuffleId);\n        boolean isStaleBlockPush =\n            isStale(info, partitionInfo.appAttemptShuffleMergeId.shuffleMergeId);\n        boolean isTooLateBlockPush = isTooLate(info, partitionInfo.reduceId);\n        if (isStaleBlockPush || isTooLateBlockPush) {\n          freeDeferredBufs();\n          if (isTooLateBlockPush) {\n            mergeManager.pushMergeMetrics.lateBlockPushes.mark();\n          } else {\n            mergeManager.pushMergeMetrics.staleBlockPushes.mark();\n          }\n          return;\n        }\n        // Check whether we can write to disk\n        if (allowedToWrite()) {\n          // Identify duplicate block generated by speculative tasks. We respond success to\n          // the client in cases of duplicate even though no data is written.\n          if (isDuplicateBlock()) {\n            freeDeferredBufs();\n            return;\n          }\n          abortIfNecessary();\n          logger.trace(\"{} onData writable\", partitionInfo);\n          if (partitionInfo.getCurrentMapIndex() < 0) {\n            partitionInfo.setCurrentMapIndex(mapIndex);\n          }\n\n          // If we got here, it's safe to write the block data to the merged shuffle file. We\n          // first write any deferred block.\n          isWriting = true;\n          try {\n            if (deferredBufs != null && !deferredBufs.isEmpty()) {\n              writeDeferredBufs();\n            }\n            writeBuf(buf);\n          } catch (IOException ioe) {\n            incrementIOExceptionsAndAbortIfNecessary();\n            // If the above doesn't throw a RuntimeException, then we propagate the IOException\n            // back to the client so the block could be retried.\n            throw ioe;\n          }\n        } else {\n          logger.trace(\"{} onData deferred\", partitionInfo);\n          // If we cannot write to disk, we buffer the current block chunk in memory so it could\n          // potentially be written to disk later. We take our best effort without guarantee\n          // that the block will be written to disk. If the block data is divided into multiple\n          // chunks during TCP transportation, each #onData invocation is an attempt to write\n          // the block to disk. If the block is still not written to disk after all #onData\n          // invocations, the final #onComplete invocation is the last attempt to write the\n          // block to disk. If we still couldn't write this block to disk after this, we give up\n          // on this block push request and respond failure to client. We could potentially\n          // buffer the block longer or wait for a few iterations inside #onData or #onComplete\n          // to increase the chance of writing the block to disk, however this would incur more\n          // memory footprint or decrease the server processing throughput for the shuffle\n          // service. In addition, during test we observed that by randomizing the order in\n          // which clients sends block push requests batches, only ~0.5% blocks failed to be\n          // written to disk due to this reason. We thus decide to optimize for server\n          // throughput and memory usage.\n          if (deferredBufs == null) {\n            deferredBufs = new ArrayList<>();\n          }\n          // Write the buffer to the in-memory deferred cache. Since buf is a slice of a larger\n          // byte buffer, we cache only the relevant bytes not the entire large buffer to save\n          // memory.\n          int deferredLen = buf.remaining();\n          ByteBuffer deferredBuf = ByteBuffer.allocate(deferredLen);\n          deferredBuf.put(buf);\n          deferredBuf.flip();\n          deferredBufs.add(deferredBuf);\n          mergeManager.pushMergeMetrics.deferredBlockBytes.inc(deferredLen);\n          mergeManager.pushMergeMetrics.deferredBlocks.mark();\n        }\n      }\n    }\n\n    @Override\n    public void onComplete(String streamId) throws IOException {\n      synchronized (partitionInfo) {\n        logger.trace(\"{} onComplete invoked\", partitionInfo);\n        // Initially when this request got to the server, the shuffle merge finalize request\n        // was not received yet or this was the latest stage attempt (or latest shuffleMergeId)\n        // generating shuffle output for the shuffle ID. By the time we finish reading this\n        // message, the block request is either stale or too late. We should thus respond\n        // the error code to the client.\n        AppShuffleMergePartitionsInfo info =\n            appShuffleInfo.shuffles.get(partitionInfo.appAttemptShuffleMergeId.shuffleId);\n        if (isTooLate(info, partitionInfo.reduceId)) {\n          freeDeferredBufs();\n          mergeManager.pushMergeMetrics.lateBlockPushes.mark();\n          throw new BlockPushNonFatalFailure(\n            new BlockPushReturnCode(ReturnCode.TOO_LATE_BLOCK_PUSH.id(), streamId).toByteBuffer(),\n            BlockPushNonFatalFailure.getErrorMsg(streamId, ReturnCode.TOO_LATE_BLOCK_PUSH));\n        }\n        if (isStale(info, partitionInfo.appAttemptShuffleMergeId.shuffleMergeId)) {\n          freeDeferredBufs();\n          mergeManager.pushMergeMetrics.staleBlockPushes.mark();\n          throw new BlockPushNonFatalFailure(\n            new BlockPushReturnCode(ReturnCode.STALE_BLOCK_PUSH.id(), streamId).toByteBuffer(),\n            BlockPushNonFatalFailure.getErrorMsg(streamId, ReturnCode.STALE_BLOCK_PUSH));\n        }\n\n        // Check if we can commit this block\n        if (allowedToWrite()) {\n          // Identify duplicate block generated by speculative tasks. We respond success to\n          // the client in cases of duplicate even though no data is written.\n          if (isDuplicateBlock()) {\n            freeDeferredBufs();\n            // Since we just return without throwing exception, and the received bytes are ignored,\n            // thus we need to add them to ignoredBlockBytes in pushMergeMetrics.\n            updateIgnoredBlockBytes();\n            return;\n          }\n          if (partitionInfo.getCurrentMapIndex() < 0) {\n            try {\n              if (deferredBufs != null && !deferredBufs.isEmpty()) {\n                abortIfNecessary();\n                isWriting = true;\n                writeDeferredBufs();\n              }\n            } catch (IOException ioe) {\n              incrementIOExceptionsAndAbortIfNecessary();\n              // If the above doesn't throw a RuntimeException, then we propagate the IOException\n              // back to the client so the block could be retried.\n              throw ioe;\n            }\n          }\n          long updatedPos = partitionInfo.getDataFilePos() + length;\n          boolean indexUpdated = false;\n          if (updatedPos - partitionInfo.getLastChunkOffset() >= mergeManager.minChunkSize) {\n            try {\n              partitionInfo.updateChunkInfo(updatedPos, mapIndex);\n              indexUpdated = true;\n            } catch (IOException ioe) {\n              incrementIOExceptionsAndAbortIfNecessary();\n              // If the above doesn't throw a RuntimeException, then we do not propagate the\n              // IOException to the client. This may increase the chunk size however the increase is\n              // still limited because of the limit on the number of IOExceptions for a\n              // particular shuffle partition.\n            }\n          }\n          partitionInfo.setDataFilePos(updatedPos);\n          partitionInfo.setCurrentMapIndex(-1);\n\n          // update merged results\n          partitionInfo.blockMerged(mapIndex);\n          if (indexUpdated) {\n            partitionInfo.resetChunkTracker();\n          }\n        } else {\n          freeDeferredBufs();\n          mergeManager.pushMergeMetrics.blockAppendCollisions.mark();\n          throw new BlockPushNonFatalFailure(\n            new BlockPushReturnCode(ReturnCode.BLOCK_APPEND_COLLISION_DETECTED.id(), streamId)\n              .toByteBuffer(), BlockPushNonFatalFailure.getErrorMsg(\n                streamId, ReturnCode.BLOCK_APPEND_COLLISION_DETECTED));\n        }\n      }\n      isWriting = false;\n    }\n\n    @Override\n    public void onFailure(String streamId, Throwable throwable) throws IOException {\n      if (ERROR_HANDLER.shouldLogError(throwable)) {\n        logger.error(\"Encountered issue when merging {}\", throwable,\n          MDC.of(LogKeys.STREAM_ID$.MODULE$, streamId));\n      } else {\n        logger.debug(\"Encountered issue when merging {}\", streamId, throwable);\n      }\n      // The block was received by ESS but didn't get merged, so it is considered as \"ignored\".\n      // Capturing them in ignoredBlockBytes would help measure any server side improvement.\n      updateIgnoredBlockBytes();\n      // Only update partitionInfo if the failure corresponds to a valid request. If the\n      // request is too late, i.e. received after shuffle merge finalize or stale block push,\n      // #onFailure will also be triggered, and we can just ignore. Also, if we couldn't find\n      // an opportunity to write the block data to disk, we should also ignore here.\n      if (isWriting) {\n        synchronized (partitionInfo) {\n          AppShuffleMergePartitionsInfo info =\n            appShuffleInfo.shuffles.get(partitionInfo.appAttemptShuffleMergeId.shuffleId);\n          if (!isTooLate(info, partitionInfo.reduceId) &&\n              !isStale(info, partitionInfo.appAttemptShuffleMergeId.shuffleMergeId)) {\n            logger.debug(\"{} encountered failure\", partitionInfo);\n            partitionInfo.setCurrentMapIndex(-1);\n          }\n        }\n      }\n      isWriting = false;\n    }\n\n    @VisibleForTesting\n    AppShufflePartitionInfo getPartitionInfo() {\n      return partitionInfo;\n    }\n  }\n\n  public static class AppAttemptId {\n    public final String appId;\n    public final int attemptId;\n\n    @JsonCreator\n    public AppAttemptId(\n        @JsonProperty(\"appId\") String appId,\n        @JsonProperty(\"attemptId\") int attemptId) {\n      this.appId = appId;\n      this.attemptId = attemptId;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n\n      AppAttemptId appAttemptId = (AppAttemptId) o;\n      return attemptId == appAttemptId.attemptId &&\n          Objects.equals(appId, appAttemptId.appId);\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(appId, attemptId);\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\"Application %s_%s\", appId, attemptId);\n    }\n  }\n\n  public static class AppShuffleMergePartitionsInfo {\n    // ConcurrentHashMap doesn't allow null for keys or values which is why this is required.\n    // Marker to identify finalized shuffle partitions.\n    private static final Map<Integer, AppShufflePartitionInfo> SHUFFLE_FINALIZED_MARKER =\n        Collections.emptyMap();\n    private final int shuffleMergeId;\n    private final Map<Integer, AppShufflePartitionInfo> shuffleMergePartitions;\n\n    private final AtomicReference<int[]> reduceIds = new AtomicReference<>(new int[0]);\n\n    public AppShuffleMergePartitionsInfo(int shuffleMergeId, boolean shuffleFinalized) {\n      this.shuffleMergeId = shuffleMergeId;\n      this.shuffleMergePartitions = shuffleFinalized ? SHUFFLE_FINALIZED_MARKER :\n          new ConcurrentHashMap<>();\n    }\n\n    @VisibleForTesting\n    public Map<Integer, AppShufflePartitionInfo> getShuffleMergePartitions() {\n      return shuffleMergePartitions;\n    }\n\n    public boolean isFinalized() {\n      return shuffleMergePartitions == SHUFFLE_FINALIZED_MARKER;\n    }\n\n    public void setReduceIds(int[] reduceIds) {\n      this.reduceIds.set(reduceIds);\n    }\n\n    public int[] getReduceIds() {\n      return this.reduceIds.get();\n    }\n  }\n\n  public static class AppAttemptShuffleMergeId {\n    public final String appId;\n    public final int attemptId;\n    public final int shuffleId;\n    public final int shuffleMergeId;\n\n    @JsonCreator\n    public AppAttemptShuffleMergeId(\n        @JsonProperty(\"appId\") String appId,\n        @JsonProperty(\"attemptId\") int attemptId,\n        @JsonProperty(\"shuffleId\") int shuffleId,\n        @JsonProperty(\"shuffleMergeId\") int shuffleMergeId) {\n      Preconditions.checkArgument(appId != null, \"app id is null\");\n      this.appId = appId;\n      this.attemptId = attemptId;\n      this.shuffleId = shuffleId;\n      this.shuffleMergeId = shuffleMergeId;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n\n      AppAttemptShuffleMergeId appAttemptShuffleMergeId = (AppAttemptShuffleMergeId) o;\n      return attemptId == appAttemptShuffleMergeId.attemptId &&\n          shuffleId == appAttemptShuffleMergeId.shuffleId &&\n          shuffleMergeId == appAttemptShuffleMergeId.shuffleMergeId &&\n          Objects.equals(appId, appAttemptShuffleMergeId.appId);\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(appId, attemptId, shuffleId, shuffleMergeId);\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\"Application %s_%s shuffleId %s shuffleMergeId %s\",\n        appId, attemptId, shuffleId, shuffleMergeId);\n    }\n  }\n\n    void updateChunkInfo(long chunkOffset, int mapIndex) throws IOException {\n      try {\n        logger.trace(\"{} index current {} updated {}\", this, this.lastChunkOffset,\n          chunkOffset);\n        if (indexMetaUpdateFailed) {\n          indexFile.getChannel().position(indexFile.getPos());\n        }\n        indexFile.getDos().writeLong(chunkOffset);\n        // Chunk bitmap should be written to the meta file after the index file because if there are\n        // any exceptions during writing the offset to the index file, meta file should not be\n        // updated. If the update to the index file is successful but the update to meta file isn't\n        // then the index file position is not updated.\n        writeChunkTracker(mapIndex);\n        indexFile.updatePos(8);\n        this.lastChunkOffset = chunkOffset;\n        indexMetaUpdateFailed = false;\n      } catch (IOException ioe) {\n        logger.warn(\"{} reduceId {} update to index/meta failed\",\n          MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n          MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        indexMetaUpdateFailed = true;\n        // Any exception here is propagated to the caller and the caller can decide whether to\n        // abort or not.\n        throw ioe;\n      }\n    }\n\n    private void writeChunkTracker(int mapIndex) throws IOException {\n      if (mapIndex == -1) {\n        return;\n      }\n      chunkTracker.add(mapIndex);\n      logger.trace(\"{} mapIndex {} write chunk to meta file\", this, mapIndex);\n      if (indexMetaUpdateFailed) {\n        metaFile.getChannel().position(metaFile.getPos());\n      }\n      chunkTracker.serialize(metaFile.getDos());\n      metaFile.updatePos(metaFile.getChannel().position() - metaFile.getPos());\n    }\n\n    private void incrementIOExceptions() {\n      numIOExceptions++;\n    }\n\n    private boolean shouldAbort(int ioExceptionsThresholdDuringMerge) {\n      return numIOExceptions > ioExceptionsThresholdDuringMerge;\n    }\n\n    private void finalizePartition() throws IOException {\n      if (dataFilePos != lastChunkOffset) {\n        try {\n          updateChunkInfo(dataFilePos, lastMergedMapIndex);\n        } catch (IOException ioe) {\n          // Any exceptions here while updating the meta files can be ignored. If the files\n          // aren't successfully updated they will be truncated.\n        }\n      }\n      // Get rid of any partial block data at the end of the file. This could either\n      // be due to failure, or a request still being processed when the shuffle\n      // merge gets finalized, or any exceptions while updating index/meta files.\n      logger.trace(\"{} reduceId {} truncating files data {} index {} meta {}\",\n          appAttemptShuffleMergeId, reduceId, lastChunkOffset,\n          indexFile.getPos(), metaFile.getPos());\n      dataChannel.truncate(lastChunkOffset);\n      indexFile.getChannel().truncate(indexFile.getPos());\n      metaFile.getChannel().truncate(metaFile.getPos());\n    }\n\n    private void deleteAllFiles() {\n      if (!dataFile.delete()) {\n        logger.info(\"Error deleting data file for {} reduceId {}\",\n          MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n          MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n      }\n      metaFile.delete();\n      indexFile.delete();\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\"Application %s_%s shuffleId %s shuffleMergeId %s reduceId %s\",\n          appAttemptShuffleMergeId.appId, appAttemptShuffleMergeId.attemptId,\n          appAttemptShuffleMergeId.shuffleId, appAttemptShuffleMergeId.shuffleMergeId,\n          reduceId);\n    }\n\n    @VisibleForTesting\n    MergeShuffleFile getIndexFile() {\n      return indexFile;\n    }\n\n    @VisibleForTesting\n    MergeShuffleFile getMetaFile() {\n      return metaFile;\n    }\n\n    @VisibleForTesting\n    FileChannel getDataChannel() {\n      return dataChannel;\n    }\n\n    @VisibleForTesting\n    public RoaringBitmap getMapTracker() {\n      return mapTracker;\n    }\n\n    @VisibleForTesting\n    int getNumIOExceptions() {\n      return numIOExceptions;\n    }\n\n    @VisibleForTesting\n    Cleaner.Cleanable getCleanable() {\n      return cleanable;\n    }\n\n    private record ResourceCleaner(\n        FileChannel dataChannel,\n        MergeShuffleFile indexFile,\n        MergeShuffleFile metaFile,\n        AppAttemptShuffleMergeId appAttemptShuffleMergeId,\n        int reduceId) implements Runnable {\n\n      @Override\n      public void run() {\n        closeAllFiles(dataChannel, indexFile, metaFile, appAttemptShuffleMergeId,\n          reduceId);\n      }\n\n      private void closeAllFiles(\n          FileChannel dataChannel,\n          MergeShuffleFile indexFile,\n          MergeShuffleFile metaFile,\n          AppAttemptShuffleMergeId appAttemptShuffleMergeId,\n          int reduceId) {\n        try {\n          if (dataChannel.isOpen()) {\n            dataChannel.close();\n          }\n        } catch (IOException ioe) {\n          logger.warn(\"Error closing data channel for {} reduceId {}\",\n            MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n            MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        }\n        try {\n          metaFile.close();\n        } catch (IOException ioe) {\n          logger.warn(\"Error closing meta file for {} reduceId {}\",\n            MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n            MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        }\n        try {\n          indexFile.close();\n        } catch (IOException ioe) {\n          logger.warn(\"Error closing index file for {} reduceId {}\",\n            MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n            MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        }\n      }\n    }\n  }",
        "human_comment": "Appends the chunk offset to the index file and adds the map index to the chunk tracker.\n\n@param chunkOffset the offset of the chunk in the data file.\n@param mapIndex the map index to be added to chunk tracker.",
        "model_generated_comment": "Register an executor with RemoteBlockPushResolver.\n\n@param appId The appId of the executor, may be {@code null}."
    },
    {
        "id": 188,
        "code_snippet": "public AlbumInvocationHandler(String baseUrl, HttpClient httpClient) {\n    this.restClient = new TinyRestClient(baseUrl, httpClient);\n  }",
        "human_comment": "Class constructor. It instantiates a TinyRestClient object.\n\n@param baseUrl Root url for endpoints.\n@param httpClient Handle the http communication.",
        "model_generated_comment": "Create a new {@link AlbumInvocationHandler} for the supplied baseUrl.\n\n@param baseUrl The baseUrl of the baseUrl, may be {@code null}."
    },
    {
        "id": 189,
        "code_snippet": "public static Slf4jConfiguration getConfiguration(ILoggerFactory loggerFactory) {\n        String slf4jBinding = loggerFactory.getClass().getCanonicalName();\n\n        try {\n            Enumeration<URL> resources =\n                    Slf4jConfigurationFactory.class.getClassLoader().getResources(RESOURCE);\n\n            while (resources.hasMoreElements()) {\n                URL resource = resources.nextElement();\n                try {\n                    InputStream is = resource.openStream();\n                    final Properties properties = new Properties();\n                    if (is != null) {\n                        try (InputStream in = is) {\n                            properties.load(in);\n                        }\n                    }\n                    String impl = properties.getProperty(slf4jBinding);\n                    if (impl != null) {\n                        return (Slf4jConfiguration)\n                                Class.forName(impl).getDeclaredConstructor().newInstance();\n                    }\n                } catch (IOException\n                        | ClassNotFoundException\n                        | NoSuchMethodException\n                        | InvocationTargetException\n                        | IllegalAccessException\n                        | InstantiationException ex) {\n                    // ignore and move on to the next\n                }\n            }\n        } catch (IOException ex) {\n            // ignore\n        }\n\n        return new UnsupportedSlf4jBindingConfiguration();\n    }",
        "human_comment": "Slf4jConfiguration factory, loading implementations from <code>META-INF/maven/slf4j-configuration.properties</code>\nconfiguration files in class loader: key is the class name of the ILoggerFactory, value is the class name of\nthe corresponding Slf4jConfiguration.\n\n@since 3.1.0",
        "model_generated_comment": "Slf4jConfiguration is a class that can be used to build a web page.\n\n@param loggerFactory the loggerFactory to use\n@return the class"
    },
    {
        "id": 190,
        "code_snippet": "public static Optional<String> getModuleVersion(Class<?> type) {\n\t\treturn Optional.empty();\n\t}",
        "human_comment": "Return the raw version of the module that the class or interface is a member of.\n\n@param type class or interface to analyze\n@return the raw module version; never {@code null} but potentially empty",
        "model_generated_comment": "Get the module version of the supplied {@link Optional}.\n\n@param type the type of the module to get; never {@code null} or blank"
    },
    {
        "id": 191,
        "code_snippet": "private void initParent(MavenProject project, ModelBuilderResult result) {\n            Model parentModel = result.getParentModel();\n\n            if (parentModel != null) {\n                final String parentGroupId = getGroupId(parentModel);\n                final String parentVersion = getVersion(parentModel);\n\n                project.setParentArtifact(repositorySystem.createProjectArtifact(\n                        parentGroupId, parentModel.getArtifactId(), parentVersion));\n\n                MavenProject parent = projectIndex.get(parentModel.getId());\n                if (parent == null) {\n                    request.getRemoteRepositories().addAll(project.getRemoteArtifactRepositories());\n                    Path parentPomFile = parentModel.getPomFile();\n                    if (parentPomFile != null) {\n                        project.setParentFile(parentPomFile.toFile());\n                        try {\n                            parent = build(true, parentPomFile, Sources.buildSource(parentPomFile))\n                                    .getProject();\n                        } catch (ProjectBuildingException e) {\n                            if (logger.isDebugEnabled()) {\n                                logger.warn(\"Failed to build parent project for \" + project.getId(), e);\n                            } else {\n                                logger.warn(\"Failed to build parent project for \" + project.getId());\n                            }\n                        }\n                    } else {\n                        Artifact parentArtifact = project.getParentArtifact();\n                        try {\n                            parent = build(true, parentArtifact, false).getProject();\n                        } catch (ProjectBuildingException e) {\n                            if (logger.isDebugEnabled()) {\n                                logger.warn(\"Failed to build parent project for \" + project.getId(), e);\n                            } else {\n                                logger.warn(\"Failed to build parent project for \" + project.getId());\n                            }\n                        }\n                    }\n                }\n                project.setParent(parent);\n                if (project.getParentFile() == null && parent != null) {\n                    project.setParentFile(parent.getFile());\n                }\n            }\n        }",
        "human_comment": "At this point the DefaultModelBuildingListener has fired, and it populates the\nremote repositories with those found in the pom.xml, along with the existing externally\ndefined repositories.\n\nMNG-4488 where let invalid parents slide on by\nMessage below is checked for in the MNG-2199 core IT.\nMessage below is checked for in the MNG-2199 core IT.\nMNG-4488 where let invalid parents slide on by\nMessage below is checked for in the MNG-2199 core IT.\nMessage below is checked for in the MNG-2199 core IT.",
        "model_generated_comment": "Create a new Maven project.\n\n@param project The project to build, may be {@code null}."
    },
    {
        "id": 192,
        "code_snippet": "ParquetVectorUpdater updater) {\n\n    int leftInBatch = state.rowsToReadInBatch;\n    int leftInPage = state.valuesToReadInPage;\n    long rowId = state.rowId;\n\n    DefLevelProcessor defLevelProcessor = new DefLevelProcessor(defLevelsReader, state, defLevels,\n      values, nulls, valuesReused, valueReader, updater);\n\n    while ((leftInBatch > 0 || !state.lastListCompleted) && leftInPage > 0) {\n      if (currentCount == 0 && !readNextGroup()) break;\n\n      // Values to read in the current RLE/PACKED block, must be <= what's left in the page\n      int valuesLeftInBlock = Math.min(leftInPage, currentCount);\n\n      // The current row range start and end\n      long rangeStart = state.currentRangeStart();\n      long rangeEnd = state.currentRangeEnd();\n\n      switch (mode) {\n        case RLE -> {\n          // This RLE block is consist of top-level rows, so we'll need to check\n          // if the rows should be skipped according to row indexes.\n          if (currentValue == 0) {\n            if (leftInBatch == 0) {\n              state.lastListCompleted = true;\n            } else {\n              // # of rows to read in the block, must be <= what's left in the current batch\n              int n = Math.min(leftInBatch, valuesLeftInBlock);\n\n              if (rowId + n < rangeStart) {\n                // Need to skip all rows in [rowId, rowId + n)\n                defLevelProcessor.skipValues(n);\n                rowId += n;\n                currentCount -= n;\n                leftInPage -= n;\n              } else if (rowId > rangeEnd) {\n                // The current row index already beyond the current range: move to the next range\n                // and repeat\n                state.nextRange();\n              } else {\n                // The range [rowId, rowId + n) overlaps with the current row range\n                long start = Math.max(rangeStart, rowId);\n                long end = Math.min(rangeEnd, rowId + n - 1);\n\n                // Skip the rows in [rowId, start)\n                int toSkip = (int) (start - rowId);\n                if (toSkip > 0) {\n                  defLevelProcessor.skipValues(toSkip);\n                  rowId += toSkip;\n                  currentCount -= toSkip;\n                  leftInPage -= toSkip;\n                }\n\n                // Read the rows in [start, end]\n                n = (int) (end - start + 1);\n\n                if (n > 0) {\n                  repLevels.appendInts(n, 0);\n                  defLevelProcessor.readValues(n);\n                }\n\n                rowId += n;\n                currentCount -= n;\n                leftInBatch -= n;\n                leftInPage -= n;\n              }\n            }\n          } else {\n            // Not a top-level row: just read all the repetition levels in the block if the row\n            // should be included according to row indexes, else skip the rows.\n            if (!state.shouldSkip) {\n              repLevels.appendInts(valuesLeftInBlock, currentValue);\n            }\n            state.numBatchedDefLevels += valuesLeftInBlock;\n            leftInPage -= valuesLeftInBlock;\n            currentCount -= valuesLeftInBlock;\n          }\n        }\n        case PACKED -> {\n          int i = 0;\n\n          for (; i < valuesLeftInBlock; i++) {\n            int currentValue = currentBuffer[currentBufferIdx + i];\n            if (currentValue == 0) {\n              if (leftInBatch == 0) {\n                state.lastListCompleted = true;\n                break;\n              } else if (rowId < rangeStart) {\n                // This is a top-level row, therefore check if we should skip it with row indexes\n                // the row is before the current range, skip it\n                defLevelProcessor.skipValues(1);\n              } else if (rowId > rangeEnd) {\n                // The row is after the current range, move to the next range and compare again\n                state.nextRange();\n                break;\n              } else {\n                // The row is in the current range, decrement the row counter and read it\n                leftInBatch--;\n                repLevels.appendInt(0);\n                defLevelProcessor.readValues(1);\n              }\n              rowId++;\n            } else {\n              if (!state.shouldSkip) {\n                repLevels.appendInt(currentValue);\n              }\n              state.numBatchedDefLevels += 1;\n            }\n          }\n\n          leftInPage -= i;\n          currentCount -= i;\n          currentBufferIdx += i;\n        }\n      }\n    }\n\n    // Process all the batched def levels\n    defLevelProcessor.finish();\n\n    state.rowsToReadInBatch = leftInBatch;\n    state.valuesToReadInPage = leftInPage;\n    state.rowId = rowId;\n  }",
        "human_comment": "Keep reading repetition level values from the page until either: 1) we've read enough\ntop-level rows to fill the current batch, or 2) we've drained the data page completely.\n\n@param valuesReused whether 'values' vector is reused for 'nulls'",
        "model_generated_comment": "ParquetVectorUpdater\n@param state The current RLE block, must be <= what's left in the current batch."
    },
    {
        "id": 193,
        "code_snippet": "String[] supportedCiphers, String[] defaultCiphers, String[] requestedCiphers) {\n    String[] baseCiphers = new String[]{\n    String[] enabledCiphers =\n      ((requestedCiphers == null || requestedCiphers.length == 0) ? baseCiphers : requestedCiphers);\n\n    List<String> ciphers = addIfSupported(supportedCiphers, enabledCiphers);\n    if (!ciphers.isEmpty()) {\n      return ciphers.toArray(new String[ciphers.size()]);\n    } else {\n      return defaultCiphers;\n    }\n  }\n\n  private static String[] enabledCipherSuites(SSLEngine engine, String[] requestedCiphers) {\n    return enabledCipherSuites(\n      engine.getSupportedCipherSuites(), engine.getEnabledCipherSuites(), requestedCiphers);\n  }\n\n  private static List<String> addIfSupported(String[] supported, String... names) {\n    List<String> enabled = new ArrayList<>();\n    Set<String> supportedSet = new HashSet<>(Arrays.asList(supported));\n    for (String n : names) {\n      if (supportedSet.contains(n)) {\n        enabled.add(n);\n      }\n    }\n    return enabled;\n  }\n}",
        "human_comment": "Use the default from JDK as fallback.",
        "model_generated_comment": "Add if supported and enabled ciphers to the list.\n\n@param supportedCiphers the cipher to add\n@return enabled Ciphers"
    },
    {
        "id": 194,
        "code_snippet": "default Map<NamedReference, ColumnStatistics> columnStats() {\n    return new HashMap<>();\n  }",
        "human_comment": "An interface to represent statistics for a data source, which is returned by\n{@link SupportsReportStatistics#estimateStatistics()}.\n\n@since 3.0.0",
        "model_generated_comment": "Returns a Map of all columns in a column.\n\n@param columnStatistics the column statistics\n@return a Map containing all column statistics"
    },
    {
        "id": 195,
        "code_snippet": "private SerializableValueDescription(Object value) {\n        this.value = String.valueOf(value);\n    }",
        "human_comment": "This class exists solely to provide a serializable description of a value to be serialized as a field in\n{@link AssumptionViolatedException}. Being a {@link Throwable}, it is required to be {@link Serializable}, but a\nvalue of type Object provides no guarantee to be serializable. This class works around that limitation as\n{@link AssumptionViolatedException} only every uses the string representation of the value, while still retaining\nbackwards compatibility with classes compiled against its class signature before 4.14 and/or deserialization of\npreviously serialized instances.",
        "model_generated_comment": "Description of a serializable value.\n\n@param value The value to describe."
    },
    {
        "id": 196,
        "code_snippet": "public void getReadyToTest(InputStream labelInputStream, MappedByteBuffer model) {\n    try {\n      Log.i(TAG, \"Creating detector.\");\n      detector = new OvicDetector(labelInputStream, model);\n      int[] inputDims = detector.getInputDims();\n      imgHeight = inputDims[1];\n      imgWidth = inputDims[2];\n      imgData = ByteBuffer.allocateDirect(DIM_BATCH_SIZE * imgHeight * imgWidth * DIM_PIXEL_SIZE);\n      imgData.order(ByteOrder.nativeOrder());\n      intValues = new int[imgHeight * imgWidth];\n      benchmarkStarted = false;\n    } catch (Exception e) {\n      Log.e(TAG, e.getMessage());\n      Log.e(TAG, \"Failed to initialize COCO detector for the benchmarker.\", e);\n    }\n  }",
        "human_comment": "Getting the benchmarker ready for detecting images.\n\n@param labelInputStream: an {@link InputStream} specifying where the list of labels should be\nread from.\n@param model: a {@link MappedByteBuffer} model to benchmark.",
        "model_generated_comment": "Initializes the Ovic detector.\n\n@param labelInputStream The input stream to initialize the detector."
    },
    {
        "id": 197,
        "code_snippet": "public void run() {\n      try (var socket = new DatagramSocket()) {\n            LOGGER.info(new String(reply.getData(), 0, reply.getLength()));\n          }\n\n          artificialDelayOf(100);\n        }",
        "human_comment": "Creates a new UDP logging client.\n\n@param clientName the name of the client to be sent in logging requests.\n@param port the port on which client will send logging requests.\n@throws UnknownHostException if localhost is unknown",
        "model_generated_comment": "Runs the DatagramSocket.\n\n@param socket The datagram socket to run."
    },
    {
        "id": 198,
        "code_snippet": "Stream<DynamicTest> generateDynamicTestsThatReferenceLargeAmountsOfMemory() {\n\t\treturn Stream.generate(() -> new byte[TEN_MB])//\n\t\t\t\t// The lambda Executable in the following line *must* reference\n\t\t\t\t// the `bytes` array in order to hold onto the allocated memory.\n\t\t\t\t.map(bytes -> dynamicTest(\"test\", () -> assertNotNull(bytes)))//\n\t\t\t\t.limit(200);\n\t}",
        "human_comment": "Without the fix in {@code DynamicTestTestDescriptor}, setting the\n{@code -mx200m} VM argument will cause an {@link OutOfMemoryError} before\nthe 200 limit is reached.\n\n@see <a href=\"https://github.com/junit-team/junit5/issues/1865\">Issue 1865</a>",
        "model_generated_comment": "Generate dynamic tests that reference large amounts of memory.\n\n@param byte the number of bytes to generate; never {@code null}"
    },
    {
        "id": 199,
        "code_snippet": "public synchronized int runCount() {\n        return fRunTests;\n    }",
        "human_comment": "Gets the number of run tests.",
        "model_generated_comment": "Returns a {@link #runCount()} for each run.\n\n@param fRunTests the number of runs to run."
    },
    {
        "id": 200,
        "code_snippet": "Collection<Vertex> children, Map<Vertex, DfsState> stateMap, LinkedList<String> cycle) {\n        for (Vertex v : children) {\n            DfsState state = stateMap.putIfAbsent(v, DfsState.VISITING);\n            if (state == null) {\n                cycle.addLast(v.label);\n                List<String> ret = visitCycle(v.children, stateMap, cycle);\n                if (ret != null) {\n                    return ret;\n                }\n                cycle.removeLast();\n                stateMap.put(v, DfsState.VISITED);\n            } else if (state == DfsState.VISITING) {\n                int pos = cycle.lastIndexOf(v.label);\n                List<String> ret = cycle.subList(pos, cycle.size());\n                ret.add(v.label);\n                return ret;\n            }\n        }\n        return null;\n    }",
        "human_comment": "we are already visiting this vertex, this mean we have a cycle",
        "model_generated_comment": "Remove lastIndexOf(v, DfsState) from the cycle.\n\n@param children the children of the cycle\n@return null if the cycle is null"
    },
    {
        "id": 201,
        "code_snippet": "public static void assertEquals(short expected, short actual) {\n        assertEquals(null, expected, actual);\n    }",
        "human_comment": "Asserts that two shorts are equal.",
        "model_generated_comment": "Asserts that two short {@code expected} are equal."
    },
    {
        "id": 202,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaStandardScalerExample\")\n      .getOrCreate();\n\n    Dataset<Row> dataFrame =\n      spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    StandardScaler scaler = new StandardScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\")\n      .setWithStd(true)\n      .setWithMean(false);\n\n    StandardScalerModel scalerModel = scaler.fit(dataFrame);\n\n    Dataset<Row> scaledData = scalerModel.transform(dataFrame);\n    scaledData.show();\n    spark.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nCompute summary statistics by fitting the StandardScaler\nNormalize each feature to have unit standard deviation.\n$example off$",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 203,
        "code_snippet": "public TimSort(SortDataFormat<K, Buffer> sortDataFormat) {\n    this.s = sortDataFormat;\n  }",
        "human_comment": "This is the minimum sized sequence that will be merged.  Shorter\nsequences will be lengthened by calling binarySort.  If the entire\narray is less than this length, no merges will be performed.\n\nThis constant should be a power of two.  It was 64 in Tim Peter's C\nimplementation, but 32 was empirically determined to work better in\nthis implementation.  In the unlikely event that you set this constant\nto be a number that's not a power of two, you'll need to change the\nminRunLength computation.\n\nIf you decrease this constant, you must change the stackLen\ncomputation in the TimSort constructor, or you risk an\nArrayOutOfBounds exception.  See listsort.txt for a discussion\nof the minimum stack length required as a function of the length\nof the array being sorted and the minimum merge sequence length.",
        "model_generated_comment": "Create a TimSort with the given sort dataFormat.\n\n@param sortDataFormat the sort data format to use."
    },
    {
        "id": 204,
        "code_snippet": "static Predicate<Resource> packageName(Predicate<String> packageFilter) {\n\t\treturn resource -> packageFilter.test(packageName(resource.getName()));\n\t}",
        "human_comment": "Match resources against a package filter.\n\n<p>The {@code /} separated path of a resource is rewritten to a\n{@code .} separated package names. The package filter is applied to that\npackage name.",
        "model_generated_comment": "Create a new {@link Predicate} with the given package name.\n\n@param packageFilter the package name of the {@code packageFilter} to test.\n@return a new Predicate containing the supplied package name; never {em>empty}\n@see #getName(String)"
    },
    {
        "id": 205,
        "code_snippet": "public static String getFilePath(String[] localDirs, int subDirsPerLocalDir, String filename) {\n    int hash = JavaUtils.nonNegativeHash(filename);\n    String localDir = localDirs[hash % localDirs.length];\n    int subDirId = (hash / localDirs.length) % subDirsPerLocalDir;\n    final String notNormalizedPath =\n      localDir + File.separator + String.format(\"%02x\", subDirId) + File.separator + filename;\n    // Interning the normalized path as according to measurements, in some scenarios such\n    // duplicate strings may waste a lot of memory (~ 10% of the heap).\n    // Unfortunately, we cannot just call the normalization code that java.io.File\n    // uses, since it is in the package-private class java.io.FileSystem.\n    // So we are creating a File just to get the normalized path back to intern it.\n    // We return this interned normalized path.\n    return new File(notNormalizedPath).getPath().intern();\n  }",
        "human_comment": "Hashes a filename into the corresponding local directory, in a manner consistent with\nSpark's DiskBlockManager.getFile().",
        "model_generated_comment": "Get the normalized path from the local directory.\n\n@param localDirs The local directory, may be {@code null}."
    },
    {
        "id": 206,
        "code_snippet": "public void setNull4Bytes(int ordinal) {\n    setNullBit(ordinal);\n    writeInt(getElementOffset(ordinal), 0);\n  }",
        "human_comment": "put zero into the corresponding field when set null",
        "model_generated_comment": "Sets the number of bytes in the input string.\n\n@param ordinal the string to set."
    },
    {
        "id": 207,
        "code_snippet": "public void getUserWithUserInDataSource() {\n        LoadUserCallback callback = mock(LoadUserCallback.class);\n        when(mUserDataSource.getUser()).thenReturn(USER);\n\n        mUserRepository.getUser(callback);\n\n        verify(mUserDataSource).getUser();\n        verify(callback).onUserLoaded(USER);\n    }",
        "human_comment": "Given a callback for loading the user\nAnd user in the data source\nWhen requesting a user from the repository\nThe user is requested from the user data source\nand the callback triggers correct method",
        "model_generated_comment": "Get the user in the data source.\n\n@param user the user\n@return the user"
    },
    {
        "id": 208,
        "code_snippet": "void failureInTestMethodIsRegistered() {\n\t\tEngineExecutionResults executionResults = executeTests(selectMethod(FailureTestCase.class, \"failingTest\"));\n\t\tEvents tests = executionResults.testEvents();\n\n\t\ttests.assertStatistics(stats -> stats.started(1).failed(1));\n\n\t\ttests.failed().assertEventsMatchExactly( //\n\t\t\tevent(test(\"failingTest\"),\n\t\t\t\tfinishedWithFailure(instanceOf(AssertionFailedError.class), message(\"always fails\"))));\n\t}",
        "human_comment": "Integration tests that verify correct exception handling in the {@link JupiterTestEngine}.\n\n@since 5.0",
        "model_generated_comment": "Unit tests for {@link AssertionFailedError}.\n\n@since 5.0"
    },
    {
        "id": 209,
        "code_snippet": "public static Constant<Double> create(Scope scope, double[][][][] data) {\n    return create(scope, data, Double.class);\n  }",
        "human_comment": "Creates a rank-4 constant of {@code double} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array.",
        "model_generated_comment": "Creates a rank-2 constant of {@code double} elements.\n\n@param scope An array containing the values to put into the new constant."
    },
    {
        "id": 210,
        "code_snippet": "public static void assertEquals(double expected, Double actual) {\n\t\tAssertEquals.assertEquals((Double) expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.",
        "model_generated_comment": "<em>Assert</em> that {@link Double} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n@see Double#equals(Object)}"
    },
    {
        "id": 211,
        "code_snippet": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
        "human_comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception.",
        "model_generated_comment": "<em>Assert</em> that the execution of the main {@link App} throws an exception.\n\n@param String the String to check; never {@code null}"
    },
    {
        "id": 212,
        "code_snippet": "public ExampleRemoteListenableWorker(Context appContext, WorkerParameters workerParams) {\n        super(appContext, workerParams);\n    }",
        "human_comment": "Example of implementing a RemoteListenableWorker. This worker simply returns Success.\n<p>\nUse RemoteListenableWorker if your worker is implemented in Java, otherwise use\nRemoteCoroutineWorker if your worker is implemented in Kotlin.",
        "model_generated_comment": "Creates a {@link ExampleRemoteListenableWorker}.\n\n@param appContext The context of the {@code workerParams} to be used to list the worker.\n@throws IllegalArgumentException if the worker does not exist."
    },
    {
        "id": 213,
        "code_snippet": "public List<MavenProject> markAsFinished(MavenProject mavenProject) {\n        finishedProjects.add(mavenProject);\n        return getSchedulableNewProcesses(mavenProject);\n    }",
        "human_comment": "Marks the provided project as finished. Returns a list of\n\n@param mavenProject The project\n@return The list of builds that are eligible for starting now that the provided project is done",
        "model_generated_comment": "Returns the list of finished projects.\n\n@param mavenProject The project to mark as finished.\n@return The list of completed projects"
    },
    {
        "id": 214,
        "code_snippet": "void testExtendedPluginDescriptor() {\n        ExtendedPluginDescriptor.Builder builder = new ExtendedPluginDescriptor.Builder();\n        builder.additionalField(\"additional\")\n                .groupId(\"org.apache.maven\")\n                .artifactId(\"maven-plugin-api\")\n                .version(\"1.0.0\");\n        ExtendedPluginDescriptor descriptor = builder.build();\n        assertEquals(\"additional\", descriptor.getAdditionalField());\n        assertEquals(\"org.apache.maven\", descriptor.getGroupId());\n    }",
        "human_comment": "make sure to call the subclasses' builder methods first, otherwise fluent API would not work",
        "model_generated_comment": "Test the plugin descriptor with the given groupId.\n\n@param org.apache.maven.plugin-api"
    },
    {
        "id": 215,
        "code_snippet": "protected static String buildMessage(String message, ProblemCollector<BuilderProblem> problems) {\n        StringBuilder msg = new StringBuilder(message);\n        problems.problems().forEach(problem -> msg.append(\"\\n * \")\n                .append(problem.getSeverity().name())\n                .append(\": \")\n                .append(problem.getMessage()));\n        return msg.toString();\n    }",
        "human_comment": "Formats message out of problems: problems are sorted (in natural order of {@link BuilderProblem.Severity})\nand then a list is built. These exceptions are usually thrown in \"fatal\" cases (and usually prevent Maven\nfrom starting), and these exceptions may end up very early on output.\n\n@param message the base message to enhance\n@param problems the collection of problems to include in the message\n@return a formatted message including details of all problems",
        "model_generated_comment": "Build a message from the supplied problem.\n\n@param message the message to build, may be {@code null}."
    },
    {
        "id": 216,
        "code_snippet": "void executeTestsWithDisabledTestClass() {\n\t\tEngineExecutionResults results = executeTestsForClass(DisabledTestClassTestCase.class);\n\n\t\tresults.containerEvents().assertStatistics(stats -> stats.skipped(1));\n\t\tresults.testEvents().assertStatistics(stats -> stats.started(0));\n\t}",
        "human_comment": "Integration tests that verify support for {@link Disabled @Disabled} in the\n{@link JupiterTestEngine}.\n\n@since 5.0",
        "model_generated_comment": "Unit tests for {@link DisabledTestClassTestCase}.\n\n@since 5.0"
    },
    {
        "id": 217,
        "code_snippet": "private ExecutionCondition condition = new EnabledIfEnvironmentVariableCondition() {\n\t};",
        "human_comment": "Stubbed subclass of {@link EnabledIfEnvironmentVariableCondition}.",
        "model_generated_comment": "Create a new {@link EnabledIfEnvironmentVariableCondition} that matches if and only if the environment variable is enabled.\n\n@param condition the condition to check; never {@code null}"
    },
    {
        "id": 218,
        "code_snippet": "public void populateResult(RepositorySystemSession session, ArtifactDescriptorResult result, Model model) {\n        ArtifactTypeRegistry stereotypes = session.getArtifactTypeRegistry();\n\n        for (Repository r : model.getRepositories()) {\n            result.addRepository(ArtifactDescriptorUtils.toRemoteRepository(r));\n        }\n\n        for (org.apache.maven.model.Dependency dependency : model.getDependencies()) {\n            result.addDependency(convert(dependency, stereotypes));\n        }\n\n        DependencyManagement mgmt = model.getDependencyManagement();\n        if (mgmt != null) {\n            for (org.apache.maven.model.Dependency dependency : mgmt.getDependencies()) {\n                result.addManagedDependency(convert(dependency, stereotypes));\n            }\n        }\n\n        Map<String, Object> properties = new LinkedHashMap<>();\n\n        Prerequisites prerequisites = model.getPrerequisites();\n        if (prerequisites != null) {\n            properties.put(\"prerequisites.maven\", prerequisites.getMaven());\n        }\n\n        List<License> licenses = model.getLicenses();\n        properties.put(\"license.count\", licenses.size());\n        for (int i = 0; i < licenses.size(); i++) {\n            License license = licenses.get(i);\n            properties.put(\"license.\" + i + \".name\", license.getName());\n            properties.put(\"license.\" + i + \".url\", license.getUrl());\n            properties.put(\"license.\" + i + \".comments\", license.getComments());\n            properties.put(\"license.\" + i + \".distribution\", license.getDistribution());\n        }\n\n        result.setProperties(properties);\n\n        setArtifactProperties(result, model);\n    }",
        "human_comment": "Populates Aether {@link ArtifactDescriptorResult} from Maven project {@link Model}.\n<p>\n<strong>Note:</strong> This class is part of work in progress and can be changed or removed without notice.\n@since 3.2.4\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead",
        "model_generated_comment": "Create a new {@link RepositorySystem} with the specified session.\n\n@param session the session to create the new repository, may be {@code null}."
    },
    {
        "id": 219,
        "code_snippet": "public static Field makeAccessible(Field field) {\n\t\treturn ReflectionUtils.makeAccessible(Preconditions.notNull(field, \"field must not be null\"));\n\t}",
        "human_comment": "Make the supplied field accessible via reflection.\n\n<p>If you're looking for similar functionality for constructors or\nmethods, consider using {@link #newInstance(Class, Object...)} or\n{@link #invokeMethod(Method, Object, Object...)}.\n\n@param field the field to make accessible; never {@code null}\n@return the supplied field\n@since 1.12\n@see Field#setAccessible(boolean)",
        "model_generated_comment": "Make the supplied {@link Field} accessible to the supplied\n{@link ReflectionUtils}.\n\n@param field the field to make accessible; never {@code null} or blank"
    },
    {
        "id": 220,
        "code_snippet": "if (mergePartitionsInfo == null) {\n          logger.info(\"{} attempt {} shuffle {} shuffleMerge {}: creating a new shuffle \" +\n          int latestShuffleMergeId = mergePartitionsInfo.shuffleMergeId;\n          if (latestShuffleMergeId > shuffleMergeId) {\n            // Reject the request as we have already seen a higher shuffleMergeId than the one\n            // in the current request.\n            throw new BlockPushNonFatalFailure(\n              new BlockPushReturnCode(ReturnCode.STALE_BLOCK_PUSH.id(), blockId).toByteBuffer(),\n              BlockPushNonFatalFailure.getErrorMsg(blockId, ReturnCode.STALE_BLOCK_PUSH));\n          } else if (latestShuffleMergeId < shuffleMergeId){\n            // Higher shuffleMergeId seen for the shuffle ID meaning new stage attempt is being\n            // run for the shuffle ID. Close and clean up old shuffleMergeId files,\n            // happens in the indeterminate stage retries\n            AppAttemptShuffleMergeId currentAppAttemptShuffleMergeId =\n                new AppAttemptShuffleMergeId(appShuffleInfo.appId, appShuffleInfo.attemptId,\n                    shuffleId, latestShuffleMergeId);\n            logger.info(\"{}: creating a new shuffle merge metadata since received \" +\n              MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$,\n                currentAppAttemptShuffleMergeId),\n              MDC.of(LogKeys.SHUFFLE_MERGE_ID$.MODULE$, shuffleMergeId),\n              MDC.of(LogKeys.LATEST_SHUFFLE_MERGE_ID$.MODULE$, latestShuffleMergeId));\n            submitCleanupTask(() ->\n                closeAndDeleteOutdatedPartitions(currentAppAttemptShuffleMergeId,\n                    mergePartitionsInfo.shuffleMergePartitions));\n            return new AppShuffleMergePartitionsInfo(shuffleMergeId, false);\n          } else {\n            // The request is for block with same shuffleMergeId as the latest shuffleMergeId\n            if (mergePartitionsInfo.isFinalized()) {\n              throw new BlockPushNonFatalFailure(\n                  new BlockPushReturnCode(\n                      ReturnCode.TOO_LATE_BLOCK_PUSH.id(), blockId).toByteBuffer(),\n                  BlockPushNonFatalFailure.getErrorMsg(blockId, ReturnCode.TOO_LATE_BLOCK_PUSH));\n            }\n            return mergePartitionsInfo;\n          }\n        }",
        "human_comment": "Given the appShuffleInfo, shuffleId, shuffleMergeId and reduceId that uniquely identifies\na given shuffle partition of an application, retrieves the associated metadata. If not\npresent and the corresponding merged shuffle does not exist, initializes the metadata.",
        "model_generated_comment": "Create a new shuffle with the given shuffle ID.\n\n@param shuffleMergeId The shuffle ID of the request\n@return the shuffle ID\n@throws BlockPushNonFatalFailure if the request is not received"
    },
    {
        "id": 221,
        "code_snippet": "protected AbstractArtifactMetadata(Artifact artifact) {\n        this.artifact = artifact;\n    }",
        "human_comment": "Common elements of artifact metadata.",
        "model_generated_comment": "<em>Metadata</em> for <a href=\"https://issues.apache.org/jira/browse/Artifact\">Artifact</a>."
    },
    {
        "id": 222,
        "code_snippet": "public void onCreate(Bundle savedInstanceState) {\n    Log.i(TAG, \"Create benchmark accuracy activity.\");\n    super.onCreate(savedInstanceState);\n\n    Intent intent = getIntent();\n    Bundle bundle = intent.getExtras();\n    String[] tfliteSettingsJsonFiles = bundle.getStringArray(TFLITE_SETTINGS_FILES_INTENT_KEY_0);\n    new BenchmarkAccuracyImpl().benchmark(this, tfliteSettingsJsonFiles);\n  }",
        "human_comment": "{@link Activity} class for Delegate Performance Accuracy Benchmark.\n\n<p>This Activity receives test arguments via a command line specified in an intent extra. It\nperforms accuracy benchmark tests via TFLite MiniBenchmark based on the input arguments. Please\ncheck the test example in\ntensorflow/lite/tools/benchmark/experimental/delegate_performance/android/README.md.",
        "model_generated_comment": "Create a BenchmarkAccuracyImpl with the savedInstanceState."
    },
    {
        "id": 223,
        "code_snippet": "void testDepthReversed() {\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a2n, a2n, a1n);\n    }",
        "human_comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\nb:1.0 -&gt; a:2.0\na:1.0\n</pre>",
        "model_generated_comment": "Unit tests for {@link ResolutionNode}.\n\n@since 5.0"
    },
    {
        "id": 224,
        "code_snippet": "public static void assertEquals(long expected, Long actual, String message) {\n\t\tAssertEquals.assertEquals((Long) expected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 225,
        "code_snippet": "public Iterator<Operation> operations() {\n    return new OperationIterator(this);\n  }",
        "human_comment": "Iterator over all the {@link Operation}s in the graph.\n\n<p>The order of iteration is unspecified. Consumers of the iterator will receive no\nnotification should the underlying graph change during iteration.",
        "model_generated_comment": "Creates a new Iterator with the specified operations.\n\n@param operations An array containing the operations to put into the new iterator."
    },
    {
        "id": 226,
        "code_snippet": "protected PathSource(Path path, String location) {\n            this.path = requireNonNull(path, \"path\").normalize();\n            this.location = location != null ? location : this.path.toString();\n        }",
        "human_comment": "Constructs a new PathSource with the specified path and location.\n\n@param path the filesystem path to the source content\n@param location the logical location of the source, used for reporting purposes.\nIf null, the path string representation is used",
        "model_generated_comment": "Creates a {@link PathSource} with the given path and location.\n\n@param path The path to the source, may be {@code null}."
    },
    {
        "id": 227,
        "code_snippet": "public static TestClassLoader forClasses(Class<?>... classes) {\n\t\tPredicate<String> classNameFilter = name -> Arrays.stream(classes).map(Class::getName).anyMatch(name::equals);\n\t\treturn new TestClassLoader(getCodeSourceUrl(stackWalker.getCallerClass()), classNameFilter);\n\t}",
        "human_comment": "Create a {@link TestClassLoader} that filters the provided classes.\n\n@see #forClasses(List)\n@see #forClassNamePrefix(String)",
        "model_generated_comment": "Create a new {@link TestClassLoader} for the supplied classes.\n\n@param classes the classes to use; never {@code null}\n@return a new classLoader"
    },
    {
        "id": 228,
        "code_snippet": "public int toIntExact() {\n    IntWrapper result = new IntWrapper();\n    if (toInt(result, false)) {\n      return result.value;\n    }\n    throw new NumberFormatException(\"invalid input syntax for type numeric: '\" + this + \"'\");\n  }",
        "human_comment": "Parses UTF8String(trimmed if needed) to int. This method is used when ANSI is enabled.\n\n@return If string contains valid numeric value then it returns the int value otherwise a\nNumberFormatException  is thrown.",
        "model_generated_comment": "Returns the value of the input string.\n\n@param result The result string to return."
    },
    {
        "id": 229,
        "code_snippet": "public Builder<T> addClassContainerSelectorResolver(Predicate<Class<?>> classFilter) {\n\t\t\tPreconditions.notNull(classFilter, \"classFilter must not be null\");\n\t\t\treturn addClassContainerSelectorResolverWithContext(__ -> classFilter);\n\t\t}",
        "human_comment": "Add a predefined resolver that resolves {@link ClasspathRootSelector\nClasspathRootSelectors}, {@link ModuleSelector ModuleSelectors}, and\n{@link PackageSelector PackageSelectors} into {@link ClassSelector\nClassSelectors} by scanning for classes that satisfy the supplied\npredicate in the respective class containers to this builder.\n\n@param classFilter predicate the resolved classes must satisfy; never\n{@code null}\n@return this builder for method chaining",
        "model_generated_comment": "Add a {@link ClassContainerSelectorResolver} to the supplied container.\n\n@param classFilter the class to add; never {@code null} or blank\n@return the builder instance"
    },
    {
        "id": 230,
        "code_snippet": "public static Namespace create(Object... parts) {\n\t\t\tPreconditions.notEmpty(parts, \"parts array must not be null or empty\");\n\t\t\tPreconditions.containsNoNullElements(parts, \"individual parts must not be null\");\n\t\t\treturn new Namespace(new ArrayList<>(Arrays.asList(parts)));\n\t\t}",
        "human_comment": "Create a namespace which restricts access to data to all extensions\nwhich use the same sequence of {@code parts} for creating a namespace.\n\n<p>The order of the {@code parts} is significant.\n\n<p>Internally the {@code parts} are compared using {@link Object#equals(Object)}.",
        "model_generated_comment": "Create a new {@link Namespace} with the supplied {@code parts}.\n\n@since 5.4"
    },
    {
        "id": 231,
        "code_snippet": "public static Constant<Float> create(Scope scope, float[][][][][] data) {\n    return create(scope, data, Float.class);\n  }",
        "human_comment": "Creates a rank-5 constant of {@code float} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array.",
        "model_generated_comment": "Creates a rank-4 constant of {@code float} elements.\n\n@param scope An array containing the values to put into the new constant."
    },
    {
        "id": 232,
        "code_snippet": "public void change(String seg) {\n        Path newCwd = resolve(seg);\n        if (Files.isDirectory(newCwd)) {\n            this.directory = newCwd;\n        } else {\n            throw new IllegalArgumentException(\"Directory '\" + directory + \"' does not exist\");\n        }\n    }",
        "human_comment": "Changes current cwd, if the new path is existing directory.\n\n@throws NullPointerException if {@code seg} is {@code null}.\n@throws IllegalArgumentException if {@code seg} leads to non-existent directory.",
        "model_generated_comment": "Change the name of the directory.\n\n@param seg The directory to change, may be {@code null}."
    },
    {
        "id": 233,
        "code_snippet": "public List<MavenProject> getActiveDependencies(MavenProject p) {\n        List<MavenProject> activeDependencies = projectDependencyGraph.getUpstreamProjects(p, false);\n        activeDependencies.removeAll(finishedProjects);\n        return activeDependencies;\n    }",
        "human_comment": "For the given {@link MavenProject} {@code p} return {@code p}'s uncompleted dependencies.\n\n@param p\n@return List of uncompleted prerequisite projects",
        "model_generated_comment": "Returns a list of active dependencies.\n\n@param p the project name\n@return an active dependency graph"
    },
    {
        "id": 234,
        "code_snippet": "private List<String> extractReactorBuildOrder(List<String> loadedLines) {\n        List<String> resultingLines = new LinkedList<>();\n        boolean start = false;\n        for (String line : loadedLines) {\n            if (start) {\n                if (line.startsWith(\"[INFO] -------------\")) {\n                    start = false;\n                } else if (!line.endsWith(\"[INFO] \")) {\n                    resultingLines.add(line);\n                }\n            } else {\n                if (line.startsWith(\"[INFO] Reactor Summary\")) {\n                    start = true;\n                    resultingLines.add(line);\n                }\n            }\n        }\n        return resultingLines;\n    }",
        "human_comment": "Extract the lines at the end of the Maven output:\n\n<pre>\n[INFO] Reactor Summary..: XXX\n[INFO]\n[INFO] ...SUCCESS [  0.035 s]\n[INFO] ...SUCCESS [  0.035 s]\n[INFO] ...SUCCESS [  0.035 s]\n</pre>",
        "model_generated_comment": "Extract ReactorBuildOrder from a list of loaded lines.\n\n@param loadedLines The loaded lines to extract, may be {@code null}."
    },
    {
        "id": 235,
        "code_snippet": "public static void assertEquals(Long expected, long actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Long) actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 236,
        "code_snippet": "private static Logger getLogger() {\n\t\treturn LoggerFactory.getLogger(ServiceLoaderRegistry.class);\n\t}",
        "human_comment": "Not a constant to avoid problems with building GraalVM native images",
        "model_generated_comment": "Get the {@link LoggerFactory} for the supplied {@code ServiceLoaderRegistry}.\n\n@since 5.4"
    },
    {
        "id": 237,
        "code_snippet": "public void flirt(Queen queen) {\n    var flirtStatus = queen.getFlirted(this);\n    if (!flirtStatus) {\n      this.makeUnhappy();\n    } else {\n      this.makeHappy();\n    }\n  }",
        "human_comment": "Method to flirt to a queen.\n\n@param queen Queen which should be flirted.",
        "model_generated_comment": "Sets the flirt status of the queen.\n\n@param queen the queen to flirt with.\n@return The flirtStatus of this queen."
    },
    {
        "id": 238,
        "code_snippet": "public Runner feed(String operation, Tensor<?> t) {\n      return feed(parseOutput(operation), t);\n    }",
        "human_comment": "Avoid evaluating {@code operation} and substitute {@code t} for the value it produces.\n\n@param operation Is either the string name of the operation, in which case this method is a\nshorthand for {@code feed(operation, 0)}, or it is a string of the form\n<tt>operation_name:output_index</tt> , in which case this method acts like {@code\nfeed(operation_name, output_index)}. These colon-separated names are commonly used in the\n{@code SignatureDef} protocol buffer messages that are included in {@link\nSavedModelBundle#metaGraphDef()}.",
        "model_generated_comment": "Sets the output of the given operation.\n\n@param operation the operation to put into the Runner."
    },
    {
        "id": 239,
        "code_snippet": "public static Result runClasses(Class<?>... classes) {\n        return runClasses(defaultComputer(), classes);\n    }",
        "human_comment": "Run the tests contained in <code>classes</code>. Write feedback while the tests\nare running and write stack traces for all failed tests after all tests complete. This is\nsimilar to {@link #main(String[])}, but intended to be used programmatically.\n\n@param classes Classes in which to find tests\n@return a {@link Result} describing the details of the test run and the failed tests.",
        "model_generated_comment": "Run all classes of the class.\n\n@param classes the classes to run.\n@return a Result if the classes are run."
    },
    {
        "id": 240,
        "code_snippet": "public static Saga create() {\n    return new Saga();\n  }",
        "human_comment": "Saga representation. Saga consists of chapters. Every ChoreographyChapter is executed a certain\nservice.",
        "model_generated_comment": "Creates a new Saga.\n\n@param Saga the Saga to create."
    },
    {
        "id": 241,
        "code_snippet": "@Override public Object evaluate(Row buffer) {\n    if (buffer.isNullAt(0)) {\n      return null;\n    } else {\n      return buffer.getDouble(0);\n    }\n  }",
        "human_comment": "If the buffer value is still null, we return null.\nOtherwise, the intermediate sum is the final result.",
        "model_generated_comment": "Evaluates the buffer.\n\n@param buffer The buffer to evaluate.\n@return null if the buffer is null."
    },
    {
        "id": 242,
        "code_snippet": "public static LotteryNumbers createRandom() {\n    return new LotteryNumbers();\n  }",
        "human_comment": "Creates a random lottery number.\n\n@return random LotteryNumbers",
        "model_generated_comment": "Creates random numbers.\n\n@param LotteryNumbers the random number.\n@return random numbers"
    },
    {
        "id": 243,
        "code_snippet": "public int portMaxRetries() {\n    return conf.getInt(\"spark.port.maxRetries\", 16);\n  }",
        "human_comment": "Maximum number of retries when binding to a port before giving up.",
        "model_generated_comment": "Returns the maximum retries of the port.\n\n@param portMaxRetries the max retries"
    },
    {
        "id": 244,
        "code_snippet": "public void nodeSkipped(JupiterEngineExecutionContext context, TestDescriptor descriptor, SkipResult result) {\n\t\t/* no-op */\n\t}",
        "human_comment": "Override {@link TestMethodTestDescriptor#nodeSkipped} as a no-op, since\nthe {@code TestWatcher} API is not supported for {@code @TestFactory}\ncontainers.\n\n@since 5.4",
        "model_generated_comment": "Create a new {@link JupiterEngineExecutionContext} with the supplied\n{@link TestDescriptor} descriptor.\n\n@param context the context of the descriptor; never {@code null}\n@return a new node"
    },
    {
        "id": 245,
        "code_snippet": "public void after(JupiterEngineExecutionContext context) {\n\t\tthis.invocationContext = null;\n\t}",
        "human_comment": "forget invocationContext so it can be garbage collected",
        "model_generated_comment": "Create a new {@link JupiterEngineExecutionContext} with the supplied {@code context}.\n\n@since 5.4"
    },
    {
        "id": 246,
        "code_snippet": "public static void assertEquals(String message, double expected, double actual, double delta) {\n        if (Double.compare(expected, actual) == 0) {\n            return;\n        }\n        if (!(Math.abs(expected - actual) <= delta)) {\n            failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));\n        }\n    }",
        "human_comment": "Asserts that two doubles are equal concerning a delta.  If they are not\nan AssertionFailedError is thrown with the given message.  If the expected\nvalue is infinity then the delta value is ignored.",
        "model_generated_comment": "Asserts that two double double are equal. If they are not, they are considered equal.\n\n@param message The expected message to check. If the expected message is <code>null</code>, the failure message will be retrieved lazily from the supplied {@code Double}."
    },
    {
        "id": 247,
        "code_snippet": "default Resolution resolve(PackageSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
        "human_comment": "Resolve the supplied {@link PackageSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)",
        "model_generated_comment": "Resolve the supplied {@link PackageSelector} using the supplied\n{@link Context}.\n\n@param selector the selector to be resolved; never {@code null}\n@return the resolved\n@see #resolve(DiscoverySelector)"
    },
    {
        "id": 248,
        "code_snippet": "private DeleteColumn(String[] fieldNames, Boolean ifExists) {\n      this.fieldNames = fieldNames;\n      this.ifExists = ifExists;\n    }",
        "human_comment": "A TableChange to delete a field.\n<p>\nIf the field does not exist, the change must result in an {@link IllegalArgumentException}.",
        "model_generated_comment": "Sets the field names of the column.\n\n@param fieldNames fieldNames the fields to delete, may be {@code null}."
    },
    {
        "id": 249,
        "code_snippet": "public static Finder specializedFinder(String... queries) {\n    var finder = identMult();\n\n    for (String query : queries) {\n      finder = finder.and(Finder.contains(query));\n    }\n    return finder;\n  }",
        "human_comment": "Specialized query. Every next query is looked in previous result.\n\n@param queries array with queries\n@return new finder",
        "model_generated_comment": "Creates a new {@link Finder} for the given query.\n\n@param queries The query to use, may be {@code null}."
    },
    {
        "id": 250,
        "code_snippet": "public List<MavenProject> getRootSchedulableBuilds() {\n        Set<MavenProject> result = new LinkedHashSet<>();\n        for (ProjectSegment projectBuild : projectBuilds) {\n            if (projectDependencyGraph\n                    .getUpstreamProjects(projectBuild.getProject(), false)\n                    .isEmpty()) {\n                result.add(projectBuild.getProject());\n            }\n        }\n        if (result.isEmpty() && projectBuilds.size() > 0) {\n            // Must return at least one project\n            result.add(projectBuilds.get(0).getProject());\n        }\n        return new ArrayList<>(result);\n    }",
        "human_comment": "Gets all the builds that have no reactor-dependencies\n\n@return A set of all the initial builds",
        "model_generated_comment": "Returns a list of <code>RootSchedulableBuilds</code>.\n\n@param projectBuild The project to return\n@return The list of root projects, never {@code null}."
    },
    {
        "id": 251,
        "code_snippet": "for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        ArrayKeyIndexType o = new ArrayKeyIndexType();\n        o.key = new int[] { i, j, 0 };\n        o.id = new String[] { \"things\" };\n        o.key = new int[] { i, j, 1 };\n        o.id = new String[] { \"more things\" };\n    }\n\n    ArrayKeyIndexType o = new ArrayKeyIndexType();\n    o.key = new int[] { 2, 2, 2 };\n    o.id = new String[] { \"things\" };\n      ImmutableSet.of(new int[] {0, 0, 0}, new int[] { 2, 2, 2 }));\n      ImmutableSet.of(new String[] { \"things\" }));\n      ImmutableSet.of(new String[] { \"more things\" }));\n\n  @Test\n  public void testSkip() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      db.write(createCustomType1(i));\n    }\n\n    try (KVStoreIterator<CustomType1> it = db.view(CustomType1.class).closeableIterator()) {\n      assertTrue(it.hasNext());\n      assertTrue(it.skip(5));\n      assertEquals(\"key5\", it.next().key);\n      assertTrue(it.skip(3));\n      assertEquals(\"key9\", it.next().key);\n      assertFalse(it.hasNext());\n    }\n  }\n\n  @Test\n  public void testNegativeIndexValues() throws Exception {\n    List<Integer> expected = Arrays.asList(-100, -50, 0, 50, 100);\n\n    expected.forEach(i -> {\n      try {\n        db.write(createCustomType1(i));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    try (KVStoreIterator<CustomType1> iterator =\n      db.view(CustomType1.class).index(\"int\").closeableIterator()) {\n      List<Integer> results = StreamSupport\n        .stream(Spliterators.spliteratorUnknownSize(iterator, 0), false)\n        .map(e -> e.num)\n        .collect(Collectors.toList());\n\n      assertEquals(expected, results);\n    }\n  }\n\n  @Test\n  public void testCloseLevelDBIterator() throws Exception {\n    File dbPathForCloseTest = File\n      .createTempFile(\n        \"test_db_close.\",\n        \".ldb\");\n    dbPathForCloseTest.delete();\n    LevelDB dbForCloseTest = new LevelDB(dbPathForCloseTest);\n    for (int i = 0; i < 8192; i++) {\n      dbForCloseTest.write(createCustomType1(i));\n    }\n    String key = dbForCloseTest\n      .view(CustomType1.class).iterator().next().key;\n    assertEquals(\"key0\", key);\n    Iterator<CustomType1> it0 = dbForCloseTest\n      .view(CustomType1.class).max(1).iterator();\n    while (it0.hasNext()) {\n      it0.next();\n    }\n    System.gc();\n    Iterator<CustomType1> it1 = dbForCloseTest\n      .view(CustomType1.class).iterator();\n    assertEquals(\"key0\", it1.next().key);\n    try (KVStoreIterator<CustomType1> it2 = dbForCloseTest\n      .view(CustomType1.class).closeableIterator()) {\n      assertEquals(\"key0\", it2.next().key);\n    }\n    dbForCloseTest.close();\n    assertTrue(dbPathForCloseTest.exists());\n    FileUtils.deleteQuietly(dbPathForCloseTest);\n    assertTrue(!dbPathForCloseTest.exists());\n  }\n\n  @Test\n  public void testHasNextAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertFalse(iter.hasNext());\n  }\n\n  @Test\n  public void testHasNextAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    db.close();\n    assertFalse(iter.hasNext());\n  }\n\n  @Test\n  public void testNextAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertThrows(NoSuchElementException.class, iter::next);\n  }\n\n  @Test\n  public void testNextAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertThrows(NoSuchElementException.class, iter::next);\n  }\n\n  @Test\n  public void testSkipAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    iter.close();\n    assertFalse(iter.skip(0));\n    assertFalse(iter.skip(1));\n  }\n\n  @Test\n  public void testSkipAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    db.close();\n    assertFalse(iter.skip(0));\n    assertFalse(iter.skip(1));\n  }\n\n  @Test\n  public void testResourceCleaner() throws Exception {\n    File dbPathForCleanerTest = File.createTempFile(\n      \"test_db_cleaner.\", \".rdb\");\n    dbPathForCleanerTest.delete();\n\n    LevelDB dbForCleanerTest = new LevelDB(dbPathForCleanerTest);\n    try {\n      for (int i = 0; i < 8192; i++) {\n        dbForCleanerTest.write(createCustomType1(i));\n      }\n      LevelDBIterator<CustomType1> levelDBIterator =\n        (LevelDBIterator<CustomType1>) dbForCleanerTest.view(CustomType1.class).iterator();\n      Reference<LevelDBIterator<?>> reference = new WeakReference<>(levelDBIterator);\n      assertNotNull(reference);\n      LevelDBIterator.ResourceCleaner resourceCleaner = levelDBIterator.getResourceCleaner();\n      assertFalse(resourceCleaner.isCompleted());\n      levelDBIterator = null;\n      int count = 0;\n      while (count < 100 && !reference.refersTo(null)) {\n        System.gc();\n        count++;\n        Thread.sleep(100);\n      }\n      assertTrue(reference.refersTo(null));\n      assertTrue(resourceCleaner.isCompleted());\n    } finally {\n      dbForCleanerTest.close();\n      FileUtils.deleteQuietly(dbPathForCleanerTest);\n    }\n  }\n\n  @Test\n  public void testMultipleTypesWriteAll() throws Exception {\n\n    List<CustomType1> type1List = Arrays.asList(\n      createCustomType1(1),\n      createCustomType1(2),\n      createCustomType1(3),\n      createCustomType1(4)\n    );\n\n    List<CustomType2> type2List = Arrays.asList(\n      createCustomType2(10),\n      createCustomType2(11),\n      createCustomType2(12),\n      createCustomType2(13)\n    );\n\n    List fullList = new ArrayList();\n    fullList.addAll(type1List);\n    fullList.addAll(type2List);\n\n    db.writeAll(fullList);\n    for (CustomType1 value : type1List) {\n      assertEquals(value, db.read(value.getClass(), value.key));\n    }\n    for (CustomType2 value : type2List) {\n      assertEquals(value, db.read(value.getClass(), value.key));\n    }\n  }\n\n\n  private CustomType1 createCustomType1(int i) {\n    CustomType1 t = new CustomType1();\n    t.key = \"key\" + i;\n    t.id = \"id\" + i;\n    t.name = \"name\" + i;\n    t.num = i;\n    t.child = \"child\" + i;\n    return t;\n  }\n\n  private CustomType2 createCustomType2(int i) {\n    CustomType2 t = new CustomType2();\n    t.key = \"key\" + i;\n    t.id = \"id\" + i;\n    t.parentId = \"parent_id\" + (i / 2);\n    return t;\n  }\n\n  private int countKeys(Class<?> type) throws Exception {\n    byte[] prefix = db.getTypeInfo(type).keyPrefix();\n    int count = 0;\n\n    try (DBIterator it = db.db().iterator()) {\n      it.seek(prefix);\n\n      while (it.hasNext()) {\n        byte[] key = it.next().getKey();\n        if (LevelDBIterator.startsWith(key, prefix)) {\n          count++;\n        }\n      }\n    }\n\n    return count;\n  }\n}",
        "human_comment": "Look into the actual DB and make sure that all the keys related to the type have been\nremoved.\nThere should be one \"id\" index entry with two values.\nDelete the first entry; now there should be 3 remaining keys, since one of the \"name\"\nindex entries should have been removed.\nMake sure there's a single entry in the \"id\" index now.\nDelete the remaining entry, make sure all data is gone.\nSPARK-31929: test when LevelDB.close() is called, related LevelDBIterators\nare closed. And files opened by iterators are also closed.\niter should be true\nclose iter\niter.hasNext should be false after iter close\niter should be true\nclose db\niter.hasNext should be false after db close\niter should be true\nclose iter\niter.next should throw NoSuchElementException after iter close\niter should be true\nclose db\niter.next should throw NoSuchElementException after db close\nclose iter\nskip should always return false after iter close\niter should be true\nclose db\nskip should always return false after db close\nManually set levelDBIterator to null, to be GC.\n100 times gc, the levelDBIterator should be GCed.\ncheck rocksDBIterator should be GCed\nVerify that the Cleaner will be executed after a period of time, isAllocated is true.",
        "model_generated_comment": "Creates a new {@link CustomType1}.\n\n@param i a {@code null}\n@return a new `customType1`.\n@throws Exception if the `key` is null"
    },
    {
        "id": 252,
        "code_snippet": "void whenPerformTestTransaction_andPersistFails_thenThrowsException() {\n    // Arrange\n    doThrow(new RuntimeException()).when(entityManager).persist(any(HealthCheck.class));\n\n    // Act & Assert\n    assertThrows(RuntimeException.class, () -> healthCheckRepository.performTestTransaction());\n\n    // Verify that remove is not called if persist fails\n    verify(entityManager, never()).remove(any(HealthCheck.class));\n  }",
        "human_comment": "Test case for the `performTestTransaction()` method when the persist operation fails.\n\n<p>Asserts that when the `performTestTransaction()` method is called and the persist operation\nfails, it throws a RuntimeException.",
        "model_generated_comment": "Perform a test transaction with the health check repository.\n\n@param healthCheckRepository.performTestTransaction.PersistFails."
    },
    {
        "id": 253,
        "code_snippet": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 2);\n\n    DecisionTreeClassifier dt = new DecisionTreeClassifier()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String impurity : DecisionTreeClassifier.supportedImpurities()) {\n      dt.setImpurity(impurity);\n    }\n    DecisionTreeClassificationModel model = dt.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.numNodes();\n    model.depth();\n    model.toDebugString();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model3.save(sc.sc(), path);\n      DecisionTreeClassificationModel sameModel =\n        DecisionTreeClassificationModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model3, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
        "human_comment": "This tests setters. Training with various options is tested in Scala.\nTODO: Add test once save/load are implemented.  SPARK-6725",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 254,
        "code_snippet": "public AlbumListPage cancelChanges() {\n    var cancelButton = (HtmlSubmitInput) page.getElementById(\"cancelButton\");\n    try {\n      cancelButton.click();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return new AlbumListPage(webClient);\n  }",
        "human_comment": "Cancel changes made by clicking the cancel button\n\n@return {@link AlbumListPage}",
        "model_generated_comment": "Cancel changes to the AlbumListPage.\n\n@param cancelButton the list of changes to cancel"
    },
    {
        "id": 255,
        "code_snippet": "public EngineDescriptor(UniqueId uniqueId, String displayName) {\n\t\tsuper(uniqueId, displayName);\n\t}",
        "human_comment": "Create a new {@code EngineDescriptor} with the supplied {@link UniqueId}\nnever {@code null}\n@param displayName the display name for the described {@code TestEngine};\nnever {@code null} or blank\n@see org.junit.platform.engine.TestEngine#getId()\n@see org.junit.platform.engine.TestDescriptor#getDisplayName()",
        "model_generated_comment": "Create a new {@link EngineDescriptor} with the supplied {@code uniqueId} and the supplied display name."
    },
    {
        "id": 256,
        "code_snippet": "public Factory(@NonNull Application application, int productId) {\n            mApplication = application;\n            mProductId = productId;\n            mRepository = ((BasicApp) application).getRepository();\n        }",
        "human_comment": "A creator is used to inject the product ID into the ViewModel\n<p>\nThis creator is to showcase how to inject dependencies into ViewModels. It's not\nactually necessary in this case, as the product ID can be passed in a public method.",
        "model_generated_comment": "Creates a factory with the supplied application.\n\n@param application the application to create the factory, may be {@code null}."
    },
    {
        "id": 257,
        "code_snippet": "public SuiteLauncherDiscoveryRequestBuilder suite(Class<?> suiteClass) {\n\t\tPreconditions.notNull(suiteClass, \"Suite class must not be null\");\n\t\tapplyConfigurationParametersFromSuite(suiteClass);\n\t\tapplySelectorsAndFiltersFromSuite(suiteClass);\n\t\treturn this;\n\t}",
        "human_comment": "Apply a suite's annotation-based configuration, selectors, and filters to\nthis builder.\n\n@param suiteClass the class to apply the annotations from; never {@code null}\n@return this builder for method chaining\n@see org.junit.platform.suite.api.Suite\n@deprecated as of JUnit Platform 1.11 in favor of\n{@link #applyConfigurationParametersFromSuite} and\n{@link #applySelectorsAndFiltersFromSuite}",
        "model_generated_comment": "Create a new {@link SuiteLauncherDiscoveryRequestBuilder} for the supplied suite.\n\n@param suiteClass the class to use; never {@code null}\n@return this builder"
    },
    {
        "id": 258,
        "code_snippet": "void testWatcherSemanticsWhenRegisteredAtMethodLevel() {\n\t\tClass<?> testClass = MethodLevelTestWatcherTestCase.class;\n\t\tassertStatsForAbstractDisabledMethodsTestCase(testClass);\n\n\t\tassertThat(TrackingTestWatcher.results.get(\"testDisabled\")).containsExactly(\"test\", \"repeatedTest\");\n\t}",
        "human_comment": "We get \"testDisabled\" events for the @Test method and the @RepeatedTest container.",
        "model_generated_comment": "Unit tests for {@link TestWatcher}.\n\n@since 5.4"
    },
    {
        "id": 259,
        "code_snippet": "public static void assumeFalse(String message, boolean b) {\n        assumeTrue(message, !b);\n    }",
        "human_comment": "The inverse of {@link #assumeTrue(String, boolean)}.",
        "model_generated_comment": "<em>Assert</em> that the given message is false.\n\n@param message The message to check, may be {@code null}."
    },
    {
        "id": 260,
        "code_snippet": "public Optional<ModernOrder> findOrderInLegacySystem(String id) {\n\n    return legacyShop\n        .findOrder(id)\n        .map(\n            o ->\n                new ModernOrder(\n                    o.getId(),\n                    new Customer(o.getCustomer()),\n                    new Shipment(o.getItem(), o.getQty(), o.getPrice()),\n                    \"\"));\n  }",
        "human_comment": "The method converts the order from the legacy system to the modern system.\n\n@param id the id of the order\n@return the order in the modern system",
        "model_generated_comment": "Find the order in the legacy system.\n\n@param id The id of the order to find\n@return The order, never {@code null}"
    },
    {
        "id": 261,
        "code_snippet": "public MavenITmng2739RequiredRepositoryElementsTest() {\n        super(\"(2.0.9,)\"); // only test in 2.0.9+\n    }",
        "human_comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-2739\">MNG-2739</a>.\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey",
        "model_generated_comment": "Test for <a href=\"https://issues.apache.org/jira/browse/MNG2739\">MNG-2739</a>."
    },
    {
        "id": 262,
        "code_snippet": "public static OutputMode Update() {\n    return InternalOutputModes.Update$.MODULE$;\n  }",
        "human_comment": "OutputMode in which only the rows that were updated in the streaming DataFrame/Dataset will\nbe written to the sink every time there are some updates. If the query doesn't contain\naggregations, it will be equivalent to `Append` mode.\n\n@since 2.1.1",
        "model_generated_comment": "Update the internal output mode.\n\n@param OutputMode The output mode to update."
    },
    {
        "id": 263,
        "code_snippet": "public SimplexTransferListener(TransferListener delegate) {\n        this(delegate, QUEUE_SIZE, BATCH_MAX_SIZE, true);\n    }",
        "human_comment": "Constructor that makes passed in delegate run on single thread, and will block on last event.",
        "model_generated_comment": "Create a SimplexTransferListener with the given delegate.\n\n@param delegate the delegate to add to theListener.\n@return {@code Simplex}"
    },
    {
        "id": 264,
        "code_snippet": "public ChunkFetchSuccess(StreamChunkId streamChunkId, ManagedBuffer buffer) {\n    super(buffer, true);\n    this.streamChunkId = streamChunkId;\n  }",
        "human_comment": "Response to {@link ChunkFetchRequest} when a chunk exists and has been successfully fetched.\n\nNote that the server-side encoding of this messages does NOT include the buffer itself, as this\nmay be written by Netty in a more efficient manner (i.e., zero-copy write).\nSimilarly, the client-side decoding will reuse the Netty ByteBuf as the buffer.",
        "model_generated_comment": "Creates a new {@link ChunkFetchSuccess} with the given buffer.\n\n@param streamChunkId The buffer to fetch the chunk, must not be <code>null</code>."
    },
    {
        "id": 265,
        "code_snippet": "public Ansi cursorUpLine(final int n) {\n        return n < 0 ? cursorDownLine(-n) : appendEscapeSequence('F', n);\n    }",
        "human_comment": "Moves the cursor to the beginning of the n-th line above. If the parameter n is negative it\nmoves the cursor to the beginning of the n-th line below.\n\n@param n the number of lines to move the cursor\n@return this Ansi instance",
        "model_generated_comment": "Creates an instance of {@link Ansi}.\n\n@param n Ansi {@code n}\n@return Ansi instance"
    },
    {
        "id": 266,
        "code_snippet": "public void validateRawModel(Model m, int validationLevel, ModelProblemCollector problems) {\n        String minVersion = new MavenModelVersion().getModelVersion(m);\n        if (m.getModelVersion() != null && compareModelVersions(minVersion, m.getModelVersion()) > 0) {\n            addViolation(\n                    problems,\n                    Severity.FATAL,\n                    Version.V40,\n                    \"model\",\n                    null,\n                    \"the model contains elements that require a model version of \" + minVersion,\n                    m);\n        }\n\n        Parent parent = m.getParent();\n\n        if (parent != null) {\n            validateStringNotEmpty(\n                    \"parent.groupId\", problems, Severity.FATAL, Version.BASE, parent.getGroupId(), parent);\n\n            validateStringNotEmpty(\n                    \"parent.artifactId\", problems, Severity.FATAL, Version.BASE, parent.getArtifactId(), parent);\n\n            validateStringNotEmpty(\n                    \"parent.version\", problems, Severity.FATAL, Version.BASE, parent.getVersion(), parent);\n\n            if (equals(parent.getGroupId(), m.getGroupId()) && equals(parent.getArtifactId(), m.getArtifactId())) {\n                addViolation(\n                        problems,\n                        Severity.FATAL,\n                        Version.BASE,\n                        \"parent.artifactId\",\n                        null,\n                        \"must be changed\"\n                                + \", the parent element cannot have the same groupId:artifactId as the project.\",\n                        parent);\n            }\n\n            if (equals(\"LATEST\", parent.getVersion()) || equals(\"RELEASE\", parent.getVersion())) {\n                addViolation(\n                        problems,\n                        Severity.WARNING,\n                        Version.BASE,\n                        \"parent.version\",\n                        null,\n                        \"is either LATEST or RELEASE (both of them are being deprecated)\",\n                        parent);\n            }\n        }\n    }",
        "human_comment": "Check that the model version is correctly set wrt the model definition, i.e., that the\nuser does not use an attribute or element that is not available in the modelVersion used.",
        "model_generated_comment": "Validate the raw model.\n\n@param m the model to validate, may be <code>null</code>\n@return The raw model\n@throws NullPointerException if the model does not exist"
    },
    {
        "id": 267,
        "code_snippet": "public Thread newThread(Runnable r) {\n\t\t\treturn new Thread(r, \"junit-timeout-thread-\" + threadNumber.getAndIncrement());\n\t\t}",
        "human_comment": "The thread factory used for preemptive timeout.\n\n<p>The factory creates threads with meaningful names, helpful for debugging\npurposes.",
        "model_generated_comment": "Create a new {@link Thread} for the supplied thread.\n\n@param r the thread to be used; never {@code null} or blank"
    },
    {
        "id": 268,
        "code_snippet": "default String canonicalName() {\n    // by default, use a random UUID so a function is never equivalent to another, even itself.\n    // this method is not required so that generated implementations (or careless ones) are not\n    // added and forgotten. for example, returning \"\" as a place-holder could cause unnecessary\n    // bugs if not replaced before release.\n    return UUID.randomUUID().toString();\n  }",
        "human_comment": "Returns the canonical name of this function, used to determine if functions are equivalent.\n<p>\nThe canonical name is used to determine whether two functions are the same when loaded by\ndifferent catalogs. For example, the same catalog implementation may be used for by two\nenvironments, \"prod\" and \"test\". Functions produced by the catalogs may be equivalent, but\nloaded using different names, like \"test.func_name\" and \"prod.func_name\".\n<p>\nNames returned by this function should be unique and unlikely to conflict with similar\nfunctions in other catalogs. For example, many catalogs may define a \"bucket\" function with a\ndifferent implementation. Adding context, like \"com.mycompany.bucket(string)\", is recommended\nto avoid unintentional collisions.\n\n@return a canonical name for this function",
        "model_generated_comment": "Returns the canonical name of a function.\n\n@param canonicalName the name of the function."
    },
    {
        "id": 269,
        "code_snippet": "private Location with(Object base, long offset, int length) {\n      this.isDefined = true;\n      this.memoryPage = null;\n      baseObject = base;\n      int uaoSize = UnsafeAlignedOffset.getUaoSize();\n      keyOffset = offset + uaoSize;\n      keyLength = UnsafeAlignedOffset.getSize(base, offset);\n      valueOffset = offset + uaoSize + keyLength;\n      valueLength = length - uaoSize - keyLength;\n      return this;\n    }",
        "human_comment": "This is only used for spilling",
        "model_generated_comment": "Create a new Location with the given base object.\n\n@param base the base object, may be {@code null}.\n@return this Location"
    },
    {
        "id": 270,
        "code_snippet": "public MojoExecution(Plugin plugin, String goal, String executionId) {\n        this.plugin = plugin;\n        this.goal = goal;\n        this.executionId = executionId;\n    }",
        "human_comment": "The executions to fork before this execution, indexed by the groupId:artifactId:version of the project on which\nthe forked execution are to be run and in reactor build order.",
        "model_generated_comment": "Creates a {@link MojoExecution} with the given plugin and executionId.\n\n@param plugin The plugin to execute, may be {@code null}."
    },
    {
        "id": 271,
        "code_snippet": "LauncherDiscoveryListener NOOP = new LauncherDiscoveryListener() {\n\n\t@API(status = STABLE, since = \"1.10\")\n\tdefault void launcherDiscoveryStarted(LauncherDiscoveryRequest request) {\n\t}\n\n\t@API(status = STABLE, since = \"1.10\")\n\tdefault void launcherDiscoveryFinished(LauncherDiscoveryRequest request) {\n\t}\n\n\tdefault void engineDiscoveryStarted(UniqueId engineId) {\n\t}\n\n\tdefault void engineDiscoveryFinished(UniqueId engineId, EngineDiscoveryResult result) {\n\t}\n\n}",
        "human_comment": "Called when test discovery has finished for an engine.\n\n<p>Exceptions thrown by implementations of this method will cause the\ncomplete test discovery to be aborted.\n\n@param engineId the unique ID of the engine descriptor\n@param result the discovery result of the supplied engine\n@see EngineDiscoveryResult",
        "model_generated_comment": "Create a new {@link LauncherDiscoveryListener} for the supplied launcher.\n\n@param request the launcher to be created; never {@code null}\n@return a new launcher"
    },
    {
        "id": 272,
        "code_snippet": "void ensureAllTestMethodsAreCovered() {\n\t\tPredicate<Method> isTestMethod = method -> method.isAnnotationPresent(Test.class);\n\n\t\tList<String> methodsToTest = findMethods(getTestClass(), isTestMethod, TOP_DOWN).stream()//\n\t\t\t\t.map(Method::getName).sorted().toList();\n\n\t\tList<String> localTestMethods = findMethods(getClass(), isTestMethod, TOP_DOWN).stream()//\n\t\t\t\t.map(Method::getName).sorted().toList();\n\n\t\tassertThat(localTestMethods).containsExactlyElementsOf(methodsToTest);\n\t}",
        "human_comment": "Abstract base class for unit testing a concrete {@link ExecutionCondition}\nimplementation.\n\n<p><strong>WARNING</strong>: this abstract base class currently does not\nsupport tests in {@code @Nested} test classes within the\n{@linkplain #getTestClass() test class}, since {@link #beforeEach(TestInfo)}\ninstantiates the test class using the no-args default constructor.\n\n@since 5.1",
        "model_generated_comment": "Unit tests for {@link Method#getTestClass()}.\n\n@since 5.4"
    },
    {
        "id": 273,
        "code_snippet": "private void insertNewChild(T valToInsert) {\n    if (this.isLessThanOrEqualTo(valToInsert)) {\n      this.setRight(new TreeNode<>(valToInsert));\n    } else {\n      this.setLeft(new TreeNode<>(valToInsert));\n    }\n  }",
        "human_comment": "Add a new Child TreeNode of given value to self. WARNING: This method is destructive (will\noverwrite existing tree structure, if any), and should be called only by this class's insert()\nmethod.\n\n@param valToInsert Value of the new TreeNode to be inserted",
        "model_generated_comment": "Inserts a new child.\n\n@param valToInsert the new child\n@return The new child"
    },
    {
        "id": 274,
        "code_snippet": "public File sslRpcKeyStore() {\n    String keyStore = conf.get(\"spark.ssl.rpc.keyStore\", null);\n    if (keyStore != null) {\n      return new File(keyStore);\n    } else {\n      return null;\n    }\n  }",
        "human_comment": "The key-store file; can be relative to the current directory",
        "model_generated_comment": "Creates a new {@link File} with the supplied key.\n\n@param keyStore The key to store, may be {@code null}."
    },
    {
        "id": 275,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaQuantileDiscretizerExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(0, 18.0),\n      RowFactory.create(1, 19.0),\n      RowFactory.create(2, 8.0),\n      RowFactory.create(3, 5.0),\n      RowFactory.create(4, 2.2)\n    );\n\n    StructType schema = new StructType(new StructField[]{\n\n    Dataset<Row> df = spark.createDataFrame(data, schema);\n    df = df.repartition(1);\n    QuantileDiscretizer discretizer = new QuantileDiscretizer()\n      .setInputCol(\"hour\")\n      .setOutputCol(\"result\")\n      .setNumBuckets(3);\n\n    Dataset<Row> result = discretizer.fit(df).transform(df);\n    result.show(false);\n    spark.stop();\n  }\n}",
        "human_comment": "$example on$\n$example off$\n$example on$\n$example off$\nOutput of QuantileDiscretizer for such small datasets can depend on the number of\npartitions. Here we force a single partition to ensure consistent results.\nNote this is not necessary for normal use cases\n$example on$\n$example off$",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 276,
        "code_snippet": "public static <T> T notNull(T value, String message) {\n        if (value == null) {\n            throw new NullPointerException(message);\n        }\n        return value;\n    }",
        "human_comment": "Checks that the given value is not {@code null}, using the given message\nas the exception message if an exception is thrown.\n\n@param value object reference to check\n@param message message to use if {@code value} is {@code null}\n@return the passed-in value, if not {@code null}\n@throws NullPointerException if {@code value} is {@code null}",
        "model_generated_comment": "Returns the value of the given {@code value}.\n\n@param value the value to check\n@return the value"
    },
    {
        "id": 277,
        "code_snippet": "public Map<String, List<File>> getCollisions() {\n        return collisions;\n    }",
        "human_comment": "Gets the POM files of the projects that collided.\n\n@return The POM files of the projects that collided, indexed by their g:a:v, never {@code null}.",
        "model_generated_comment": "Returns a map of collisions.\n\n@param list of collisions\n@return a Map of collisions"
    },
    {
        "id": 278,
        "code_snippet": "public static void main(String[] args) {\n    var form = new RegisterWorkerForm(NAME, OCCUPATION, DATE_OF_BIRTH);\n    form.submit();\n  }",
        "human_comment": "The notification pattern captures information passed between layers, validates the information,\nand returns any errors to the presentation layer if needed.\n\n<p>In this code, this pattern is implemented through the example of a form being submitted to\nregister a worker. The worker inputs their name, occupation, and date of birth to the\nRegisterWorkerForm (which acts as our presentation layer), and passes it to the RegisterWorker\nclass (our domain layer) which validates it. Any errors caught by the domain layer are then\npassed back to the presentation layer through the RegisterWorkerDto.",
        "model_generated_comment": "Create a new {@link RegisterWorker} with the given name.\n\n@param args The name of the {@code org.apache.maven.services.RegisterWorker}.\n@throws IllegalArgumentException if the name is invalid."
    },
    {
        "id": 279,
        "code_snippet": "public void encode(ByteBuf buf) {\n    super.encode(buf);\n    buf.writeInt(shuffleMergeId);\n    Encoders.IntArrays.encode(buf, reduceIds);\n    buf.writeInt(chunkIds.length);\n    for (int[] ids: chunkIds) {\n      Encoders.IntArrays.encode(buf, ids);\n    }\n  }",
        "human_comment": "Even though reduceIds.length == chunkIds.length, we are explicitly setting the length in the\ninterest of forward compatibility.",
        "model_generated_comment": "Encodes a chunk of bytes into a buffer.\n\n@param buf The buf to encode, may be {@code null}."
    },
    {
        "id": 280,
        "code_snippet": "protected String convertSchemaPattern(final String pattern) {\n    if ((pattern == null) || pattern.isEmpty()) {\n      return convertPattern(\"%\", true);\n    } else {\n      return convertPattern(pattern, true);\n    }\n  }",
        "human_comment": "Convert wildchars and escape sequence of schema pattern from JDBC format to datanucleous/regex\nThe schema pattern treats empty string also as wildchar",
        "model_generated_comment": "Convert a pattern into a pattern.\n\n@param pattern the pattern to convert\n@return a new pattern"
    },
    {
        "id": 281,
        "code_snippet": "public final Void getRawResult() {\n\t\t\treturn null;\n\t\t}",
        "human_comment": "Always returns {@code null}.\n\n@return {@code null} always",
        "model_generated_comment": "Get the raw result of the {@link RawResult}.\n\n@param null the result; never {@code null}"
    },
    {
        "id": 282,
        "code_snippet": "public DefaultModelPathTranslator(PathTranslator pathTranslator) {\n        this.pathTranslator = pathTranslator;\n    }",
        "human_comment": "Resolves relative paths within a model against a specific base directory.",
        "model_generated_comment": "Creates a new {@link DefaultModelPathTranslator} for the specified path.\n\n@param pathTranslator The path to which the path is to be written.\n@return a new Default Model PathTranslator"
    },
    {
        "id": 283,
        "code_snippet": "public Period extractAsPeriod() { return Period.of(0, months, days); }",
        "human_comment": "Extracts the date part of the interval.\n@return an instance of {@code java.time.Period} based on the months and days fields\nof the given interval, not null.",
        "model_generated_comment": "Extracts a period from the given period.\n\n@param period the period to extract; never {@code null}"
    },
    {
        "id": 284,
        "code_snippet": "private static CommandLine getLikelyExecutedCommand(final CommandLine commandLine) {\n\t\treturn Optional.ofNullable(commandLine.getParseResult().subcommand()) //\n\t\t\t\t.map(parseResult -> parseResult.commandSpec().commandLine()) //\n\t\t\t\t.orElse(commandLine);\n\t}",
        "human_comment": "Get the most likely executed subcommand, if any, or the main command otherwise.\n@see <a href=\"https://picocli.info/#_executing_commands_with_subcommands\">Executing Commands with Subcommands</a>",
        "model_generated_comment": "Get the {@link CommandLine} of the given command line.\n\n@param commandLine the command line to be retrieved; never {@code null}\n@return the supplied command line"
    },
    {
        "id": 285,
        "code_snippet": "void before() {\n\t\t\tcountBeforeInvoked++;\n\t\t\tthis.throwExceptionInAfterMethod = false;\n\t\t}",
        "human_comment": "Reset state, since the test instance is retained across all test methods;\notherwise, after() always throws an exception.",
        "model_generated_comment": "Unit tests for {@link BeforeMethod}.\n\n@since 5.4"
    },
    {
        "id": 286,
        "code_snippet": "public static String nullSafeToString(Class<?>... classes) {\n\t\treturn nullSafeToString(Class::getName, classes);\n\t}",
        "human_comment": "Generate a comma-separated list of fully qualified class names for the\nsupplied classes.\n\n@param classes the classes whose names should be included in the\ngenerated string\n@return a comma-separated list of fully qualified class names, or an empty\nstring if the supplied class array is {@code null} or empty\n@see #nullSafeToString(Function, Class...)\n@see StringUtils#nullSafeToString(Object)",
        "model_generated_comment": "Create a new {@link String} with the supplied {@code classes}.\n\n@param classes the classes to create the new String; never\n{@code null}\n@see #getName(Class)"
    },
    {
        "id": 287,
        "code_snippet": "private void concatPath(StringBuilder url, String path) {\n            if (path.length() > 0) {\n                boolean initialUrlEndsWithSlash = url.charAt(url.length() - 1) == '/';\n                boolean pathStartsWithSlash = path.charAt(0) == '/';\n\n                if (pathStartsWithSlash) {\n                    if (initialUrlEndsWithSlash) {\n                        url.setLength(url.length() - 1);\n                    }\n                } else if (!initialUrlEndsWithSlash) {\n                    url.append('/');\n                }\n\n                url.append(path);\n\n                if (initialUrlEndsWithSlash && !path.endsWith(\"/\")) {\n                    url.append('/');\n                }\n            }\n        }",
        "human_comment": "1 extra '/' to remove\nadd missing '/' between url and path\nensure resulting url ends with slash if initial url was",
        "model_generated_comment": "Creates a concat path for the given url.\n\n@param url The url to concat, may be {@code null}."
    },
    {
        "id": 288,
        "code_snippet": "public int find(UTF8String str, int start) {\n    assert (str.numBytes > 0);\n    while (start <= numBytes - str.numBytes) {\n      if (ByteArrayMethods.arrayEquals(base, offset + start, str.base, str.offset, str.numBytes)) {\n        return start;\n      }\n      start += 1;\n    }\n    return -1;\n  }",
        "human_comment": "Find the `str` from left to right.",
        "model_generated_comment": "Finds the start of a string.\n\n@param str the string to find\n@return The start of the string."
    },
    {
        "id": 289,
        "code_snippet": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 2);\n\n    GBTClassifier rf = new GBTClassifier()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setSubsamplingRate(1.0)\n      .setSeed(1234)\n      .setMaxIter(3)\n      .setStepSize(0.1)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String lossType : GBTClassifier.supportedLossTypes()) {\n      rf.setLossType(lossType);\n    }\n    GBTClassificationModel model = rf.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.totalNumNodes();\n    model.toDebugString();\n    model.trees();\n    model.treeWeights();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model3.save(sc.sc(), path);\n      GBTClassificationModel sameModel = GBTClassificationModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model3, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
        "human_comment": "This tests setters. Training with various options is tested in Scala.\nTODO: Add test once save/load are implemented.  SPARK-6725",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 290,
        "code_snippet": "public DuplicateArtifactAttachmentException(MavenProject project, Artifact artifact) {\n        super(constructMessage(project, artifact));\n        this.project = project;\n        this.artifact = artifact;\n    }",
        "human_comment": "This exception is thrown if an application attempts to attach\ntwo of the same artifacts to a single project.\n\nTODO Make this a checked exception, and modify the API of MavenProjectHelper.\nCurrently, this modification would create compatibility problems for existing plugins.",
        "model_generated_comment": "Creates a {@link DuplicateArtifactAttachmentException} with the given project and artifact.\n\n@param project the project to check for\n@return a Duplicate artifact exception"
    },
    {
        "id": 291,
        "code_snippet": "void setUp() {\n\t\twhen(configuration.getDefaultDisplayNameGenerator()).thenReturn(new DisplayNameGenerator.Standard());\n\t\twhen(configuration.getDefaultExecutionMode()).thenReturn(ExecutionMode.SAME_THREAD);\n\t\twhen(configuration.getDefaultClassesExecutionMode()).thenReturn(ExecutionMode.SAME_THREAD);\n\t\twhen(configuration.getOutputDirectoryProvider()).thenReturn(dummyOutputDirectoryProvider());\n\t}",
        "human_comment": "Unit tests for concrete implementations of {@link ExtensionContext}:\n{@link JupiterEngineExtensionContext}, {@link ClassExtensionContext}, and\n{@link MethodExtensionContext}.\n\n@since 5.0",
        "model_generated_comment": "Set up the {@link DisplayNameGenerator} for the specified configuration.\n\n@param configuration the configuration to set up; never {@code null}"
    },
    {
        "id": 292,
        "code_snippet": "public void accept(Visitor visitor) {\n\t\tgetRoots().forEach(it -> accept(visitor, it));\n\t}",
        "human_comment": "Accept the supplied {@link Visitor} for a depth-first traversal of the\ntest plan.\n\n@param visitor the visitor to accept; never {@code null}\n@since 1.10",
        "model_generated_comment": "<em>Assert</em> that the supplied {@link Visitor} has been accepted.\n\n@param visitor the visitor to be accepted; never {@code null}\n@see #accept(Visitor)"
    },
    {
        "id": 293,
        "code_snippet": "public AssertionFailureBuilder cause(Throwable cause) {\n\t\tthis.cause = cause;\n\t\treturn this;\n\t}",
        "human_comment": "Set the cause of the assertion failure.\n\n@param cause the failure cause; may be {@code null}\n@return this builder for method chaining",
        "model_generated_comment": "Create a new {@link AssertionFailureBuilder} with the supplied cause.\n\n@param cause the {@code cause} to be used to build this builder.\n@return this builder for constructing the new builder."
    },
    {
        "id": 294,
        "code_snippet": "public int indexOfEmpty(int start) {\n    return 0; // TODO: Fix this behaviour (SPARK-48284)\n  }",
        "human_comment": "Returns the (default) position of the first occurrence of an empty substr in the current\nstring from the specified position (0-based index).\n\n@param start the start position of the current string for searching\n@return the position of the first occurrence of the empty substr (now, always 0)",
        "model_generated_comment": "Sets the index of empty objects.\n\n@param start the start of the index."
    },
    {
        "id": 295,
        "code_snippet": "public void whatHappensWhenASuiteContainsItselfIndirectly() {\n        Result result = JUnitCore.runClasses(Hydra.class);\n        assertEquals(2, result.getFailureCount());\n    }",
        "human_comment": "The interesting case here is that Hydra indirectly contains two copies of\nitself (if it only contains one, Java's StackOverflowError eventually\nbails us out)",
        "model_generated_comment": "Unit tests for {@link #ASuiteContainsItselfIndirectly()}.\n\n@since 5.0"
    },
    {
        "id": 296,
        "code_snippet": "public boolean isCancellable() {\n      return allowCancellation != null && allowCancellation;\n    }",
        "human_comment": "Advanced: Returns whether the interpreter is able to be cancelled.\n\n<p>Interpreters may have an experimental API <a\nhref=\"https://www.tensorflow.org/lite/api_docs/java/org/tensorflow/lite/Interpreter#setCancelled(boolean)\">setCancelled(boolean)</a>.\nIf this interpreter is cancellable and such a method is invoked, a cancellation flag will be\nset to true. The interpreter will check the flag between Op invocations, and if it's {@code\ntrue}, the interpreter will stop execution. The interpreter will remain a cancelled state\nuntil explicitly \"uncancelled\" by {@code setCancelled(false)}.",
        "model_generated_comment": "Returns whether the boolean is null.\n\n@param boolean isCancellable"
    },
    {
        "id": 297,
        "code_snippet": "static ArgumentSet argumentSet(String name, Object... arguments) {\n\t\treturn new ArgumentSet(name, arguments);\n\t}",
        "human_comment": "Factory method for creating an {@link ArgumentSet} based on the supplied\n{@code name} and {@code arguments}.\n\n<p>Favor this method over {@link Arguments#of Arguments.of(...)} and\n{@link Arguments#arguments arguments(...)} when you wish to assign a name\nto the entire set of arguments.\n\n<p>This method is well suited to be used as a static import &mdash; for\nexample, via:\n{@code import static org.junit.jupiter.params.provider.Arguments.argumentSet;}.\n\n@param name the name of the argument set; must not be {@code null} or blank\n@param arguments the arguments to be used for an invocation of the test\nmethod; must not be {@code null}\n@return an {@code ArgumentSet}; never {@code null}\n@since 5.11\n@see ArgumentSet\n@see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_PLACEHOLDER\n@see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER",
        "model_generated_comment": "Create a new {@link ArgumentSet} with the given name and arguments.\n\n@param name the name of the argument; never {@code null}\n@return a new ArgumentSet"
    },
    {
        "id": 298,
        "code_snippet": "protected String escapeSpecialCharsForLikePattern(String str) {\n    StringBuilder builder = new StringBuilder();\n\n    for (char c : str.toCharArray()) {\n      switch (c) {\n        case '_' -> builder.append(\"\\\\_\");\n        case '%' -> builder.append(\"\\\\%\");\n        default -> builder.append(c);\n      }\n    }\n\n    return builder.toString();\n  }",
        "human_comment": "Escape the special chars for like pattern.\n\nNote: This method adopts the escape representation within Spark and is not bound to any JDBC\ndialect. JDBC dialect should overwrite this API if the underlying database have more special\nchars other than _ and %.",
        "model_generated_comment": "escape special chars for likePatterns.\n\n@param str the string to be escaped\n@return {@code true}"
    },
    {
        "id": 299,
        "code_snippet": "public static <T extends Throwable> Matcher<T> isThrowable(Matcher<T> throwableMatcher) {\n        return StacktracePrintingMatcher.isThrowable(throwableMatcher);\n    }",
        "human_comment": "@return A matcher that delegates to throwableMatcher and in addition\nappends the stacktrace of the actual Throwable in case of a mismatch.",
        "model_generated_comment": "Returns a {@link ThrowableMatcher} that matches if and only if the given throwable is thrown."
    },
    {
        "id": 300,
        "code_snippet": "public PrefixedConfigurationParameters(ConfigurationParameters delegate, String prefix) {\n\t\tthis.delegate = Preconditions.notNull(delegate, \"delegate must not be null\");\n\t\tthis.prefix = Preconditions.notBlank(prefix, \"prefix must not be null or blank\");\n\t}",
        "human_comment": "Create a new view of the supplied {@link ConfigurationParameters} that\n{@code null}\n@param prefix the prefix to apply to all queries; never {@code null} or\nblank",
        "model_generated_comment": "Create a {@link PrefixedConfigurationParameters} for the specified configuration parameters.\n\n@param delegate the configuration parameters to be used; never {@code null}\n@return a Prefixed ConfigurationParameters"
    },
    {
        "id": 301,
        "code_snippet": "public UserAccount updateDb(final UserAccount userAccount) {\n    return writeToDb(userAccount);\n  }",
        "human_comment": "Update reecord in DB.\n\n@param userAccount {@link UserAccount}\n@return {@link UserAccount}",
        "model_generated_comment": "Update the user account.\n\n@param userAccount The user account to update."
    },
    {
        "id": 302,
        "code_snippet": "public static long timeStringAs(String str, TimeUnit unit) {\n    String lower = str.toLowerCase(Locale.ROOT).trim();\n\n    try {\n      Matcher m = TIME_STRING_PATTERN.matcher(lower);\n      if (!m.matches()) {\n        throw new NumberFormatException(\"Failed to parse time string: \" + str);\n      }\n\n      long val = Long.parseLong(m.group(1));\n      String suffix = m.group(2);\n\n      // Check for invalid suffixes\n      if (suffix != null && !timeSuffixes.containsKey(suffix)) {\n        throw new NumberFormatException(\"Invalid suffix: \\\"\" + suffix + \"\\\"\");\n      }\n\n      // If suffix is valid use that, otherwise none was provided and use the default passed\n      return unit.convert(val, suffix != null ? timeSuffixes.get(suffix) : unit);\n    } catch (NumberFormatException e) {\n      String timeError = \"Time must be specified as seconds (s), \" +\n              \"milliseconds (ms), microseconds (us), minutes (m or min), hour (h), or day (d). \" +\n              \"E.g. 50s, 100ms, or 250us.\";\n\n      throw new NumberFormatException(timeError + \"\\n\" + e.getMessage());\n    }\n  }",
        "human_comment": "Convert a passed time string (e.g. 50s, 100ms, or 250us) to a time count in the given unit.\nThe unit is also considered the default if the given string does not specify a unit.",
        "model_generated_comment": "Returns a string with the given time string.\n\n@param str the string to parse, may be {@code null}."
    },
    {
        "id": 303,
        "code_snippet": "void updateUserName(String userName, UpdateUserCallback callback) {\n        final WeakReference<UpdateUserCallback> updateUserCallback = new WeakReference<>(callback);\n\n        final User user = mCachedUser == null\n                ? new User(userName)\n                : new User(mCachedUser.getId(), userName);\n\n        // update the user on the I/O thread\n        mAppExecutors.diskIO().execute(() -> {\n            mUserDataSource.insertOrUpdateUser(user);\n            mCachedUser = user;\n            // notify on the main thread\n            mAppExecutors.mainThread().execute(() -> {\n                UpdateUserCallback userCallback = updateUserCallback.get();\n                if (userCallback != null) {\n                    userCallback.onUserUpdated(user);\n                }\n            });\n        });\n    }",
        "human_comment": "Insert an new user or update the name of the user.\n\n@param userName the user name\n@param callback callback that gets triggered when the user was updated.",
        "model_generated_comment": "Update the user name.\n\n@param userName the name of the user to update\n@return The user name"
    },
    {
        "id": 304,
        "code_snippet": "public boolean onKeyDown(int keyCode, KeyEvent event) {\n    int moveOffset = 0;\n    switch (keyCode) {\n      case KeyEvent.KEYCODE_DPAD_LEFT:\n        moveOffset = -1;\n        break;\n      case KeyEvent.KEYCODE_DPAD_RIGHT:\n        moveOffset = 1;\n        break;\n      case KeyEvent.KEYCODE_DPAD_UP:\n        moveOffset = -1 * grid.getNumColumns();\n        break;\n      case KeyEvent.KEYCODE_DPAD_DOWN:\n        moveOffset = grid.getNumColumns();\n        break;\n      default:\n        return super.onKeyDown(keyCode, event);\n    }\n\n    int currentSelect = 0;\n    float highestValue = 0;\n    for (int i = 0; i < adapter.getCount(); i++) {\n      if (adapter.items[i].value > highestValue) {\n        currentSelect = i;\n        highestValue = adapter.items[i].value;\n      }\n    }\n    setStyle(adapter.items[(currentSelect + moveOffset + adapter.getCount()) % adapter.getCount()], 1);\n\n    return true;\n  }",
        "human_comment": "get the highest selected style",
        "model_generated_comment": "Sets the position of the key.\n\n@param keyCode The key to move, must not be <code>null</code>.\n@return true if the key is null."
    },
    {
        "id": 305,
        "code_snippet": "public static StructType createStructType(List<StructField> fields) {\n    return createStructType(fields.toArray(new StructField[fields.size()]));\n  }",
        "human_comment": "Creates a StructType with the given list of StructFields ({@code fields}).",
        "model_generated_comment": "Creates a struct type from a list of {@link StructField} fields.\n\n@param fields fields the fields to create the struct type.\n@return a new struct type"
    },
    {
        "id": 306,
        "code_snippet": "public TestIdentifier getTestIdentifier(UniqueId uniqueId) {\n\t\tPreconditions.notNull(uniqueId, () -> \"uniqueId must not be null\");\n\t\treturn Preconditions.notNull(allIdentifiers.get(uniqueId),\n\t\t\t() -> \"No TestIdentifier with unique ID [\" + uniqueId + \"] has been added to this TestPlan.\");\n\t}",
        "human_comment": "Get the {@link TestIdentifier} with the supplied unique ID.\n\n@param uniqueId the unique ID to look up the identifier for; never\n{@code null}\n@return the identifier with the supplied unique ID; never {@code null}\n@throws PreconditionViolationException if no {@code TestIdentifier}\nwith the supplied unique ID is present in this test plan",
        "model_generated_comment": "Get a {@link TestIdentifier} with the given identifier.\n\n@param uniqueId the identifier; never {@code null}"
    },
    {
        "id": 307,
        "code_snippet": "public OffHeapColumnVector(int capacity, DataType type) {\n    super(capacity, type);\n\n    nulls = 0;\n    data = 0;\n    lengthData = 0;\n    offsetData = 0;\n\n    reserveInternal(capacity);\n    reset();\n  }",
        "human_comment": "The data stored in these two allocations need to maintain binary compatible. We can\ndirectly pass this buffer to external components.\nOnly set if type is Array or Map.",
        "model_generated_comment": "Creates an OffHeapColumnVector with the specified capacity and type.\n\n@param capacity The capacity of the vector, may be {@code null}."
    },
    {
        "id": 308,
        "code_snippet": "void testWatcherSemanticsWhenRegisteredAtInstanceLevelWithTestInstanceLifecyclePerMethod() {\n\t\tClass<?> testClass = TestInstancePerMethodInstanceLevelTestWatcherTestCase.class;\n\t\tassertStatsForAbstractDisabledMethodsTestCase(testClass);\n\n\t\tassertThat(TrackingTestWatcher.results.get(\"testDisabled\")).containsExactly(\"test\");\n\t}",
        "human_comment": "Since the TestWatcher is registered at the instance level with test instance\nlifecycle per-method semantics, we get a \"testDisabled\" event only for the @Test\nmethod and NOT for the @RepeatedTest container.",
        "model_generated_comment": "Unit tests for {@link TestInstancePerMethodInstanceLevelTestWatcherTestCase}.\n\n@since 5.4"
    },
    {
        "id": 309,
        "code_snippet": "public static ConditionEvaluationResult enabled(String reason) {\n\t\treturn new ConditionEvaluationResult(true, reason);\n\t}",
        "human_comment": "Factory for creating <em>enabled</em> results.\n\n@param reason the reason why the container or test should be enabled\n@return an enabled {@code ConditionEvaluationResult} with the given reason",
        "model_generated_comment": "Create a new {@link ConditionEvaluationResult} with the supplied reason.\n\n@param reason the reason to check; never {@code null}"
    },
    {
        "id": 310,
        "code_snippet": "public ColumnarBatch(ColumnVector[] columns, int numRows) {\n    this.columns = columns;\n    this.numRows = numRows;\n    this.row = new ColumnarBatchRow(columns);\n  }",
        "human_comment": "Create a new batch from existing column vectors.\n@param columns The columns of this batch\n@param numRows The number of rows in this batch",
        "model_generated_comment": "Creates a new {@link ColumnarBatchRow} with the specified columns.\n\n@param columns the columns to be searched, may be {@code null}."
    },
    {
        "id": 311,
        "code_snippet": "private static File getLocalRepoFile(Verifier verifier) {\n        return new File(verifier.getArtifactPath(\"org.apache.maven\", \"maven-core-it-support\", \"1.0-SNAPSHOT\", \"jar\"));\n    }",
        "human_comment": "this is to delete metadata - TODO: incorporate into deleteArtifact in verifier",
        "model_generated_comment": "Get local RepoFile from the given verifier.\n\n@param verifier The verifier to get the local repo file\n@return a new {@link File}"
    },
    {
        "id": 312,
        "code_snippet": "default Optional<String> getString(@Nonnull URI relativeSource) {\n        return getString(relativeSource, StandardCharsets.UTF_8);\n    }",
        "human_comment": "GETs the source URI content as string using UTF8 charset. The source MUST BE relative from the\n{@link RemoteRepository#getUrl()} root.\n\n@return the string if operation succeeded, {@code null} if source does not exist.\n@throws RuntimeException If failed (and not due source not exists).",
        "model_generated_comment": "Returns the string of the given URI.\n\n@param relativeSource The URI to get the string from.\n@return the string"
    },
    {
        "id": 313,
        "code_snippet": "void allAreIn(JavaClasses classes) {\n\t\tassertTrue(classes.size() > 800, \"expected more than 800 classes, got: \" + classes.size());\n\t}",
        "human_comment": "about 928 classes found in all jars",
        "model_generated_comment": "Unit tests for {@link JavaClasses}.\n\n@since 5.0"
    },
    {
        "id": 314,
        "code_snippet": "public LifecyclePhaseNotFoundException(String message, String lifecyclePhase) {\n        super(message);\n        this.lifecyclePhase = (lifecyclePhase != null) ? lifecyclePhase : \"\";\n    }",
        "human_comment": "Creates a new exception to indicate that the specified lifecycle phase is not defined by any known lifecycle.\n\n@param message The detail message, may be {@code null}.\n@param lifecyclePhase The name of the lifecycle phase that could not be located, may be {@code null}.",
        "model_generated_comment": "Sets if the lifecycle phase is not found.\n\n@param message The message to check."
    },
    {
        "id": 315,
        "code_snippet": "public static Tensor<Float> create(float data) {\n    return Tensor.create(data, Float.class);\n  }",
        "human_comment": "Creates a scalar tensor containing a single {@code float} element.\n\n@param data The value to put into the new scalar tensor.",
        "model_generated_comment": "Creates a tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor."
    },
    {
        "id": 316,
        "code_snippet": "public Car(String manufacturer, String model, int noOfPassengers, int engineCapacity) {\n    super(manufacturer, model, noOfPassengers);\n    this.engineCapacity = engineCapacity;\n  }",
        "human_comment": "A class that extends the PassengerVehicle class and provides the concrete inheritance\nimplementation of the Car.\n\n@see PassengerVehicle PassengerVehicle\n@see Vehicle Vehicle",
        "model_generated_comment": "Creates a new car with the specified engine capacity.\n\n@param manufacturer the manufacturer of the car."
    },
    {
        "id": 317,
        "code_snippet": "public static void main(String[] args) {\n    BlocUi blocUi = new BlocUi();\n    blocUi.createAndShowUi();\n  }",
        "human_comment": "The entry point of the application. Initializes the GUI.\n\n@param args command-line arguments (not used in this example)",
        "model_generated_comment": "Creates a new {@link BlocUi} instance.\n\n@param args The args to create the new instance."
    },
    {
        "id": 318,
        "code_snippet": "private void testAllDaysWithoutDefaultObserver(final Weekday specialDay, final Event event) {\n    final var observer1 = mock(EventObserver.class);\n    final var observer2 = mock(EventObserver.class);\n\n    final var emitter = this.factoryWithoutDefaultObserver.get();\n    emitter.registerObserver(observer1, event);\n    emitter.registerObserver(observer2, event);\n\n    testAllDays(specialDay, event, emitter, observer1, observer2);\n  }",
        "human_comment": "Go over every day of the month, and check if the event is emitted on the given day. Use an\nevent emitter without a default observer\n\n@param specialDay The special day on which an event is emitted\n@param event The expected event emitted by the test object",
        "model_generated_comment": "Unit tests for {@link EventObserver}.\n\n@param specialDay the special day to test, may be {@code null}."
    },
    {
        "id": 319,
        "code_snippet": "static DiscoveryIssueReporter forwarding(EngineDiscoveryListener engineDiscoveryListener, UniqueId engineId) {\n\t\tPreconditions.notNull(engineDiscoveryListener, \"engineDiscoveryListener must not be null\");\n\t\tPreconditions.notNull(engineId, \"engineId must not be null\");\n\t\treturn issue -> engineDiscoveryListener.issueEncountered(engineId, issue);\n\t}",
        "human_comment": "Create a new {@code DiscoveryIssueReporter} that reports issues to the\n\n@param engineDiscoveryListener the listener to report issues to; never\n{@code null}\n@param engineId the unique identifier of the engine; never {@code null}",
        "model_generated_comment": "Create a new {@link DiscoveryIssueReporter}.\n\n@param engineDiscoveryListener the {@code engine} that will be used to retrieve the supplied issue.\n@return a new\n{@link #issuesReporter} with the same name as the engine\n@see #issueEncountered(engine, engineId)"
    },
    {
        "id": 320,
        "code_snippet": "private void assertChecksum(String checksum, Properties checksums) {\n        assertEquals(checksum, checksums.getProperty(\"dep-0.1.jar\").toLowerCase(java.util.Locale.ENGLISH));\n    }",
        "human_comment": "Verify that repositories declared in the POM are accessed in their declaration order.\n\n@throws Exception in case of failure",
        "model_generated_comment": "Asserts that {@link Dep-0.1.jar}.\n\n@param checksum the checksum to check."
    },
    {
        "id": 321,
        "code_snippet": "private void gameLoop() {\n    while (isRunning) {\n      processInput();\n      update();\n      render();\n    }\n  }",
        "human_comment": "Main game loop. This loop will always run until the game is over. For each loop it will process\nuser input, update internal status, and render the next frames. For more detail please refer to\nthe game-loop pattern.",
        "model_generated_comment": "Creates a new game loop.\n\n@param gameLoop the game loop\n@return a game loop"
    },
    {
        "id": 322,
        "code_snippet": "public void setExecutions(java.util.List<Execution> executions) {\n        this.executions = executions;\n    } // -- void setExecutions( java.util.List )",
        "human_comment": "Set the goals to execute within the phase.\n\n@param executions a executions object.",
        "model_generated_comment": "Set the executions of the given {@link java.util.List}.\n\n@param executions the {@code executions} to set."
    },
    {
        "id": 323,
        "code_snippet": "public ModelBuildingException(Model model, String modelId, List<ModelProblem> problems) {\n        super(toMessage(modelId, problems));\n\n        if (model != null) {\n            DefaultModelBuildingResult tmp = new DefaultModelBuildingResult();\n            if (modelId == null) {\n                modelId = \"\";\n            }\n            tmp.addModelId(modelId);\n            tmp.setRawModel(modelId, model);\n            tmp.setProblems(problems);\n            result = tmp;\n        } else {\n            result = null;\n        }\n    }",
        "human_comment": "Creates a new exception with the specified problems.\n\n@param model The model that could not be built, may be {@code null}.\n@param modelId The identifier of the model that could not be built, may be {@code null}.\n@param problems The problems that causes this exception, may be {@code null}.\n@deprecated Use {@link #ModelBuildingException(ModelBuildingResult)} instead.",
        "model_generated_comment": "Creates a new {@link ModelBuildingResult} for the specified model.\n\n@param model the model to build, must not be {@code null}."
    },
    {
        "id": 324,
        "code_snippet": "public static void assertEquals(String message, double expected, double actual, double delta) {\n        Assert.assertEquals(message, expected, actual, delta);\n    }",
        "human_comment": "Asserts that two doubles are equal concerning a delta.  If they are not\nan AssertionFailedError is thrown with the given message.  If the expected\nvalue is infinity then the delta value is ignored.",
        "model_generated_comment": "Asserts that two double double are equal. If they are not, the failure message will be retrieved lazily from the supplied delta."
    },
    {
        "id": 325,
        "code_snippet": "public Variant getElementAtIndex(int index) {\n    return handleArray(value, pos, (size, offsetSize, offsetStart, dataStart) -> {\n      if (index < 0 || index >= size) return null;\n      int offset = readUnsigned(value, offsetStart + offsetSize * index, offsetSize);\n      return new Variant(value, metadata, dataStart + offset);\n    });\n  }",
        "human_comment": "Get the array element at the `index` slot. Return null if `index` is out of the bound of\n`[0, arraySize())`.\nIt is only legal to call it when `getType()` is `Type.ARRAY`.",
        "model_generated_comment": "Returns a Variant with the given index.\n\n@param index The index of the Variant, may be {@code null}."
    },
    {
        "id": 326,
        "code_snippet": "public static void assertNotEquals(Double unexpected, Double actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and {@link actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@link Double#equals(Object)}\n\n@since 5.4"
    },
    {
        "id": 327,
        "code_snippet": "public void setStringToIntColumn(java.util.Map<java.lang.String,java.lang.Integer> value) {\n    this.string_to_int_column = value;\n  }",
        "human_comment": "Sets the value of the 'string_to_int_column' field.\n@param value the value to set.",
        "model_generated_comment": "Sets the value of the string to put into the column.\n\n@param value the value to set."
    },
    {
        "id": 328,
        "code_snippet": "public void write(Object data, SelectionKey key) {\n    super.write(data, key);\n  }",
        "human_comment": "Writes the outgoing {@link DatagramPacket} to the channel. The intended receiver of the\ndatagram packet must be set in the <code>data</code> using {@link\nDatagramPacket#setReceiver(SocketAddress)}.",
        "model_generated_comment": "Creates a new {@link #write(Object)}.\n\n@param data The data to write."
    },
    {
        "id": 329,
        "code_snippet": "protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n        validateZeroArgConstructor(errors);\n    }",
        "human_comment": "Adds to {@code errors} if the test class has more than one constructor,\nor if the constructor takes parameters. Override if a subclass requires\ndifferent validation rules.",
        "model_generated_comment": "Sets the number of errors in the constructor.\n\n@param errors the errors to validate, may be {@code null}."
    },
    {
        "id": 330,
        "code_snippet": "public final int getRemainingElementsCount() {\n    var counter = 0;\n    for (var ignored : this) {\n      counter++;\n    }\n    return counter;\n  }",
        "human_comment": "Find the count of remaining objects of current iterable.\n\n@return the count of remaining objects of the current Iterable",
        "model_generated_comment": "Returns the count of the remaining elements.\n\n@param counter the number of elements to count\n@return the count"
    },
    {
        "id": 331,
        "code_snippet": "public static OS current() {\n\t\treturn CURRENT_OS;\n\t}",
        "human_comment": "Get the current operating system.\n\n@since 5.9",
        "model_generated_comment": "Create a new {@link OS} with the given name.\n\n@param current_OS the name of the OS; never {@code null}"
    },
    {
        "id": 332,
        "code_snippet": "public void testErrorRetry() {\n    ErrorHandler.BlockPushErrorHandler pushHandler = new ErrorHandler.BlockPushErrorHandler();\n    assertFalse(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.TOO_LATE_BLOCK_PUSH, \"\")));\n    assertFalse(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.TOO_OLD_ATTEMPT_PUSH, \"\")));\n    assertFalse(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.STALE_BLOCK_PUSH, \"\")));\n    assertFalse(pushHandler.shouldRetryError(new RuntimeException(new ConnectException())));\n    assertTrue(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.BLOCK_APPEND_COLLISION_DETECTED, \"\")));\n    assertTrue(pushHandler.shouldRetryError(new Throwable()));\n\n    ErrorHandler.BlockFetchErrorHandler fetchHandler = new ErrorHandler.BlockFetchErrorHandler();\n    assertFalse(fetchHandler.shouldRetryError(new RuntimeException(\n      ErrorHandler.BlockFetchErrorHandler.STALE_SHUFFLE_BLOCK_FETCH)));\n  }",
        "human_comment": "Test suite for {@link ErrorHandler}",
        "model_generated_comment": "Unit tests for BlockPushErrorHandler.\n\n@param pushHandler the pushHandler to check\n@return ErrorHandler."
    },
    {
        "id": 333,
        "code_snippet": "protected final boolean getLookingForStuckThread() {\n        return lookForStuckThread;\n    }",
        "human_comment": "Gets whether this {@code Timeout} will look for a stuck thread\nwhen the test times out.\n\n@since 4.12",
        "model_generated_comment": "Returns the {@link #getLookingForStuckThread()} method."
    },
    {
        "id": 334,
        "code_snippet": "public record RetryParams(int numOfRetries, long retryDuration) {\n  public static final RetryParams DEFAULT = new RetryParams(3, 30000L);\n}",
        "human_comment": "Record to hold the parameters related to retries.\n\n@param numOfRetries number of retries\n@param retryDuration retry duration",
        "model_generated_comment": "Create a new {@link RetryParams} with the given numOfRetries, long retryDuration.\n\n<p>If the num of retries is <3, 30000L>, the retry will be aborted."
    },
    {
        "id": 335,
        "code_snippet": "void postProcessorAndPreDestroyCallbacks() {\n\t\t// @formatter:off\n\t\tassertPostProcessorAndPreDestroyCallbacks(TopLevelTestCase.class,\n\t\t\t\"fooPostProcessTestInstance\",\n\t\t\t\"barPostProcessTestInstance\",\n\t\t\t\t\"test-1\",\n\t\t\t\"barPreDestroyTestInstance\",\n\t\t\t\"fooPreDestroyTestInstance\"\n\t\t);\n\t\t// @formatter:on\n\t}",
        "human_comment": "Integration tests that verify support for {@link TestInstancePostProcessor}\nand {@link TestInstancePreDestroyCallback} in the {@link JupiterTestEngine}.\n\n@since 5.6",
        "model_generated_comment": "Unit tests for {@link PostProcessor}.\n\n@since 5.0"
    },
    {
        "id": 336,
        "code_snippet": "public static void assertNotEquals(Short unexpected, Short actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and {@link actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 337,
        "code_snippet": "public FluentIterable<E> last(int count) {\n    return new LazyFluentIterable<>() {\n        return new DecoratingIterator<>(iterable.iterator()) {\n            if (currentIndex >= stopIndex && fromIterator.hasNext()) {\n              return fromIterator.next();\n            }\n            return null;\n          }\n\n          private void initialize() {\n            if (list == null) {\n              list = new ArrayList<>();\n              iterable.forEach(list::add);\n              totalElementsCount = list.size();\n              stopIndex = totalElementsCount - count;\n            }\n          }\n        };\n      }",
        "human_comment": "Can be used to collect objects from the Iterable. Is a terminating operation. This operation is\nmemory intensive, because the contents of this Iterable are collected into a List, when the\nnext object is requested.\n\n@param count defines the number of objects to return\n@return the same FluentIterable with a collection decimated to a maximum of 'count' last\nobjects",
        "model_generated_comment": "Creates a FluentIterable with the given count.\n\n@param count the count of the iterable, must not be <code>null</code>."
    },
    {
        "id": 338,
        "code_snippet": "public static void main(String[] args) {\n    Function<Integer, Integer> timesTwo = x -> x * 2;\n    Function<Integer, Integer> square = x -> x * x;\n\n    Function<Integer, Integer> composedFunction =\n        FunctionComposer.composeFunctions(timesTwo, square);\n\n    int result = composedFunction.apply(3);\n    LOGGER.info(\"Result of composing 'timesTwo' and 'square' functions applied to 3 is: \" + result);\n  }",
        "human_comment": "Main method to demonstrate function composition using FunctionComposer.\n\n@param args command line arguments (not used)",
        "model_generated_comment": "Creates a new {@link FunctionComposer} with the given values.\n\n@param args The args to compose the new function, must not be <code>null</code>."
    },
    {
        "id": 339,
        "code_snippet": "public void testSimpleBagAdd() {\n        IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n        assertEquals(expected, f14CHF.add(fMB1));\n    }",
        "human_comment": "[14 CHF] + {[12 CHF][7 USD]} == {[26 CHF][7 USD]}",
        "model_generated_comment": "Creates a new {@link MoneyBag} with the given CHF.\n\n@param expected CHF the CHF to add\n@throws IllegalArgumentException if no CHF is found"
    },
    {
        "id": 340,
        "code_snippet": "public void testSuiteStarted(Description description) {\n\t\tRunnerTestDescriptor runnerTestDescriptor = testRun.getRunnerTestDescriptor();\n\t\tif (!runnerTestDescriptor.getDescription().equals(description)) {\n\t\t\ttestStarted(lookupOrRegisterNextTestDescriptor(description), EventType.REPORTED);\n\t\t}\n\t}",
        "human_comment": "runnerTestDescriptor is reported in testRunStarted",
        "model_generated_comment": "Unit tests for {@link RunnerTestDescriptor}.\n\n@since 5.0"
    },
    {
        "id": 341,
        "code_snippet": "public static void assertTimeoutPreemptively(Duration timeout, Executable executable, String message) {\n\t\tAssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable, message);\n\t}",
        "human_comment": "<em>Assert</em> that execution of the supplied {@code executable}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>See the {@linkplain Assertions Preemptive Timeouts} section of the\nclass-level Javadoc for further details.\n\n<p>Fails with the supplied failure {@code message}.\n\n@see #assertTimeoutPreemptively(Duration, Executable)\n@see #assertTimeoutPreemptively(Duration, Executable, Supplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, String)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeout(Duration, Executable, String)",
        "model_generated_comment": "<em>Assert</em> that {@code timeout} is not exceeded.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@link Executable}.\n\n@since 5.4"
    },
    {
        "id": 342,
        "code_snippet": "public int hashCode() {\n        return Objects.hash(\n                directory,\n                includes,\n                excludes,\n                scope,\n                language,\n                moduleName,\n                targetVersion,\n                targetPath,\n                stringFiltering,\n                enabled);\n    }",
        "human_comment": "{@return a hash code value computed from all properties}.",
        "model_generated_comment": "Returns the hash code of the given module.\n\n@param scope The scope of the module, must not be <code>null</code>."
    },
    {
        "id": 343,
        "code_snippet": "public static void assertNotEquals(Double unexpected, Double actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and {@link actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 344,
        "code_snippet": "public VectorizedRleValuesReader() {\n    this.fixedWidth = false;\n    this.readLength = false;\n  }",
        "human_comment": "A values reader for Parquet's run-length encoded data. This is based off of the version in\nparquet-mr with these changes:\n- Supports the vectorized interface.\n- Works on byte arrays(byte[]) instead of making byte streams.\n\nThis encoding is used in multiple places:\n- Definition/Repetition levels\n- Dictionary ids.\n- Boolean type values of Parquet DataPageV2",
        "model_generated_comment": "Creates a Vectorized RleValuesReader.\n\n@param value the value to read."
    },
    {
        "id": 345,
        "code_snippet": "private static String getOsFamily() {\n        return Stream.of(\n                        FAMILY_DOS,\n                        FAMILY_MAC,\n                        FAMILY_NETWARE,\n                        FAMILY_NT,\n                        FAMILY_OPENVMS,\n                        FAMILY_OS2,\n                        FAMILY_OS400,\n                        FAMILY_TANDEM,\n                        FAMILY_UNIX,\n                        FAMILY_WIN9X,\n                        FAMILY_WINDOWS,\n                        FAMILY_ZOS,\n                        FAMILY_UNKNOWN)\n                .filter(Os::isFamily)\n                .findFirst()\n                .orElse(null);\n    }",
        "human_comment": "Helper method to determine the current OS family.\n\n@return name of current OS family.",
        "model_generated_comment": "Returns the name of the family.\n\n@param Os the family to return\n@return The family name"
    },
    {
        "id": 346,
        "code_snippet": "public boolean verboseMetrics() {\n    return conf.getBoolean(SPARK_NETWORK_VERBOSE_METRICS, false);\n  }",
        "human_comment": "Whether to track Netty memory detailed metrics. If true, the detailed metrics of Netty\nPoolByteBufAllocator will be gotten, otherwise only general memory usage will be tracked.",
        "model_generated_comment": "Returns a boolean metric for verbose metrics.\n\n@param verboseMetrics the metric to check"
    },
    {
        "id": 347,
        "code_snippet": "static Builder mvnenc(@Nonnull String[] args, @Nonnull MessageBuilderFactory messageBuilderFactory) {\n        return mvnenc(Arrays.asList(args), messageBuilderFactory);\n    }",
        "human_comment": "Creates a new Builder instance for constructing a Maven Encrypting Tool ParserRequest.\n\n@param args the command-line arguments\n@param messageBuilderFactory the factory for creating message builders\n@return a new Builder instance",
        "model_generated_comment": "Creates a new {@code mvnenc} with the specified args.\n\n@param args the args to use\n@return a new mavenenc"
    },
    {
        "id": 348,
        "code_snippet": "void testToString() {\n    var heroStatA = HeroStat.valueOf(3, 9, 2);\n    var heroStatB = HeroStat.valueOf(3, 9, 2);\n    var heroStatC = HeroStat.valueOf(3, 9, 8);\n    assertEquals(heroStatA.toString(), heroStatB.toString());\n    assertNotEquals(heroStatA.toString(), heroStatC.toString());\n  }",
        "human_comment": "The toString() for two equal values must be the same. For two non-equal values it must be\ndifferent.",
        "model_generated_comment": "Unit tests for {@link HeroStat}.\n\n@param heroStatA {@code HeroStatB}"
    },
    {
        "id": 349,
        "code_snippet": "public <V> Promise<V> thenApply(Function<? super T, V> func) {\n    Promise<V> dest = new Promise<>();\n    fulfillmentAction = new TransformAction<>(this, dest, func);\n    return dest;\n  }",
        "human_comment": "Returns a new promise that, when this promise is fulfilled normally, is fulfilled with result\nof this promise as argument to the function provided.\n\n@param func function to be executed.\n@return a new promise.",
        "model_generated_comment": "Apply {@link Promise} to the given {@code T} object.\n\n@param func the function to apply\n@return a Promise with the specified value."
    },
    {
        "id": 350,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaRobustScalerExample\")\n      .getOrCreate();\n\n    Dataset<Row> dataFrame =\n      spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    RobustScaler scaler = new RobustScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\")\n      .setWithScaling(true)\n      .setWithCentering(false)\n      .setLower(0.25)\n      .setUpper(0.75);\n\n    RobustScalerModel scalerModel = scaler.fit(dataFrame);\n\n    Dataset<Row> scaledData = scalerModel.transform(dataFrame);\n    scaledData.show();\n    spark.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nCompute summary statistics by fitting the RobustScaler\nTransform each feature to have unit quantile range.\n$example off$",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 351,
        "code_snippet": "private RenameColumn(String[] fieldNames, String newName) {\n      this.fieldNames = fieldNames;\n      this.newName = newName;\n    }",
        "human_comment": "A TableChange to rename a field.\n<p>\nThe name is used to find the field to rename. The new name will replace the leaf field name.\nFor example, renameColumn(\"a.b.c\", \"x\") should produce column a.b.x.\n<p>\nIf the field does not exist, the change must result in an {@link IllegalArgumentException}.",
        "model_generated_comment": "Constructs a new {@link RenameColumn} with the given field names.\n\n@param fieldNames the field names to use, may be {@code null}."
    },
    {
        "id": 352,
        "code_snippet": "public static TwoPartSplitResult splitIntoTwo(String separator, String value) {\n\t\tPreconditions.notNull(separator, \"separator must not be null\");\n\t\tPreconditions.notNull(value, \"value must not be null\");\n\t\treturn splitIntoTwo(value, value.indexOf(separator), separator.length());\n\t}",
        "human_comment": "Split the supplied {@link String} into up to two parts using the supplied\nseparator string.\n\n@param separator the separator string; never {@code null}\n@param value the value to split; never {@code null}\n@since 1.11",
        "model_generated_comment": "Create a {@link TwoPartSplitResult} with the supplied separator and the supplied value.\n\n@param separator the separator to be split into; never {@code null}\n@return a two-partSplitResult with the same separator, but without the additional\n{@link Value#indexOf(separator)}.\n@see #splitIntoTwo(String)"
    },
    {
        "id": 353,
        "code_snippet": "public static LoggingListener forBiConsumer(BiConsumer<Throwable, Supplier<String>> logger) {\n\t\treturn new LoggingListener(logger);\n\t}",
        "human_comment": "Create a {@code LoggingListener} which delegates to the supplied\n{@link BiConsumer} for consumption of logging messages.\n\n<p>The {@code BiConsumer's} arguments are a {@link Throwable} (potentially\n{@code null}) and a {@link Supplier} (never {@code null}) for the log\nmessage.\n\n@param logger a logger implemented as a {@code BiConsumer};\nnever {@code null}\n\n@see #forJavaUtilLogging()\n@see #forJavaUtilLogging(Level)",
        "model_generated_comment": "Create a new {@link LoggingListener} for the supplied {@code logger}.\n\n@since 5.4"
    },
    {
        "id": 354,
        "code_snippet": "public static void assertTrue(BooleanSupplier booleanSupplier, Supplier<String> messageSupplier) {\n\t\tAssertTrue.assertTrue(booleanSupplier, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that the boolean condition supplied by {@code booleanSupplier} is {@code true}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "<em>Assert</em> that {@code booleanSupplier} is true.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@linkplain messageSupplier}.\n\n@since 5.4"
    },
    {
        "id": 355,
        "code_snippet": "default CustomTaskMetric[] currentMetricsValues() {\n    return new CustomTaskMetric[]{};\n}",
        "human_comment": "Returns an array of custom task metrics. By default it returns empty array. Note that it is\nnot recommended to put heavy logic in this method as it may affect writing performance.",
        "model_generated_comment": "Create a new {@link CustomTaskMetric[]} based on the current metrics values.\n\n@param currentMetricsValues the values to use\n@return a new custom task metric"
    },
    {
        "id": 356,
        "code_snippet": "public MultiModuleCollectionStrategy(ModelProcessor modelProcessor, ProjectsSelector projectsSelector) {\n        this.modelProcessor = modelProcessor;\n        this.projectsSelector = projectsSelector;\n    }",
        "human_comment": "Strategy for collecting Maven projects from the multi-module project root, even when executed in a submodule.",
        "model_generated_comment": "Creates a new collection strategy based on the supplied model.\n\n@param modelProcessor The model processor, may be {@code null}."
    },
    {
        "id": 357,
        "code_snippet": "public static boolean isAssignableTo(Object obj, Class<?> targetType) {\n\t\tPreconditions.notNull(targetType, \"target type must not be null\");\n\n\t\tif (obj == null) {\n\t\t\treturn !targetType.isPrimitive();\n\t\t}\n\n\t\tif (targetType.isInstance(obj)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (targetType.isPrimitive()) {\n\t\t\tClass<?> sourceType = obj.getClass();\n\t\t\treturn sourceType == primitiveToWrapperMap.get(targetType) || isWideningConversion(sourceType, targetType);\n\t\t}\n\n\t\treturn false;\n\t}",
        "human_comment": "Determine if the supplied object can be assigned to the supplied target\ntype for the purpose of reflective method invocations.\n\n<p>In contrast to {@link Class#isInstance(Object)}, this method returns\n{@code true} if the target type represents a primitive type whose wrapper\nmatches the supplied object's type. In addition, this method also supports\n<a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2\">\nwidening conversions</a> for primitive types and their corresponding\nwrapper types.\n\n<p>If the supplied object is {@code null} and the supplied type does not\nrepresent a primitive type, this method returns {@code true}.\n\n@param obj the object to test for assignment compatibility; potentially {@code null}\n@param targetType the type to check against; never {@code null}\n@return {@code true} if the object is assignment compatible\n@see Class#isInstance(Object)\n@see Class#isAssignableFrom(Class)\n@see #isAssignableTo(Class, Class)",
        "model_generated_comment": "Unit tests for {@link AssignableTo(Object)}.\n\n@since 5.0"
    },
    {
        "id": 358,
        "code_snippet": "public void moveBullet(float offset) {\n    var currentPosition = bullet.getPosition();\n    bullet.setPosition(currentPosition + offset);\n  }",
        "human_comment": "Move bullet position by the provided offset.\n\n@param offset moving offset",
        "model_generated_comment": "Move the bullet to its current position.\n\n@param offset the offset of the bullet."
    },
    {
        "id": 359,
        "code_snippet": "public UTF8String substring(final int start, final int until) {\n    if (until <= start || start >= numBytes) {\n      return EMPTY_UTF8;\n    }\n\n    int i = 0;\n    int c = 0;\n    while (i < numBytes && c < start) {\n      i += numBytesForFirstByte(getByte(i));\n      c += 1;\n    }\n\n    int j = i;\n    while (i < numBytes && c < until) {\n      i += numBytesForFirstByte(getByte(i));\n      c += 1;\n    }\n\n    if (i > j) {\n      byte[] bytes = new byte[i - j];\n      copyMemory(base, offset + j, bytes, BYTE_ARRAY_OFFSET, i - j);\n      return fromBytes(bytes);\n    } else {\n      return EMPTY_UTF8;\n    }\n  }",
        "human_comment": "Returns a substring of this.\n@param start the position of first code point\n@param until the position after last code point, exclusive.",
        "model_generated_comment": "A substring for UTF8 string.\n\n@param start the start of the string\n@return the substring, never {@code null}"
    },
    {
        "id": 360,
        "code_snippet": "public void beforeAll(ExtensionContext context) {\n\t\tinstallFailureTracker(context);\n\t\tinjectStaticFields(context, context.getRequiredTestClass());\n\t}",
        "human_comment": "Perform field injection for non-private, {@code static} fields (i.e.,\nclass fields) of type {@link Path} or {@link File} that are annotated with\n{@link TempDir @TempDir}.",
        "model_generated_comment": "Unit tests for {@link #installFailureTracker(ExtensionContext)}.\n\n@since 5.4"
    },
    {
        "id": 361,
        "code_snippet": "public MavenITmng3710PollutedClonedPluginsTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
        "human_comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3710\">MNG-3710</a>.\n\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey",
        "model_generated_comment": "Test for <a href=\"https://issues.apache.org/jira/browse/MNG3710\">MNG-3710</a>."
    },
    {
        "id": 362,
        "code_snippet": "public void process() {\n    if (realVideoObject == null) {\n      realVideoObject = new RealVideoObject();\n    }\n    realVideoObject.process();\n  }",
        "human_comment": "A proxy class for the real video object, providing a layer of control over the object\ninstantiation.",
        "model_generated_comment": "Processes a video object.\n\n@param realVideoObject the object to process, may be {@code null}."
    },
    {
        "id": 363,
        "code_snippet": "static final Migration MIGRATION_1_2 = new Migration(1, 2) {\n    };",
        "human_comment": "Migrate from:\nversion 1 - using the SQLiteDatabase API\nto\nversion 2 - using Room",
        "model_generated_comment": "Create a new {@link Migration}.\n\n@param new Migration The {@code MIGRATION} to create.\n@return a new Migration"
    },
    {
        "id": 364,
        "code_snippet": "public ShuffleSecretManager() {\n    shuffleSecretMap = new ConcurrentHashMap<>();\n  }",
        "human_comment": "A class that manages shuffle secret used by the external shuffle service.",
        "model_generated_comment": "Creates a new shuffle secret manager.\n\n@param shuffleSecretManager\n@return {@link ShuffleSecretManager}"
    },
    {
        "id": 365,
        "code_snippet": "public final String getMethodParameterTypes() {\n\t\treturn this.methodParameterTypes;\n\t}",
        "human_comment": "Get the method parameter types of this source.",
        "model_generated_comment": "Get the {@link MethodParameterTypes} for the given method.\n\n@return this.methodParameterTypes; never {@code null}"
    },
    {
        "id": 366,
        "code_snippet": "protected void processImage() {\n    if (desiredSize != initializedSize) {\n      LOGGER.i(\n          \"Initializing at size preview size %dx%d, stylize size %d\",\n          previewWidth, previewHeight, desiredSize);\n\n      rgbFrameBitmap = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);\n      croppedBitmap = Bitmap.createBitmap(desiredSize, desiredSize, Config.ARGB_8888);\n      frameToCropTransform = ImageUtils.getTransformationMatrix(\n          previewWidth, previewHeight,\n          desiredSize, desiredSize,\n          sensorOrientation, true);\n\n      cropToFrameTransform = new Matrix();\n      frameToCropTransform.invert(cropToFrameTransform);\n      intValues = new int[desiredSize * desiredSize];\n      floatValues = new float[desiredSize * desiredSize * 3];\n      initializedSize = desiredSize;\n    }\n    rgbFrameBitmap.setPixels(getRgbBytes(), 0, previewWidth, 0, 0, previewWidth, previewHeight);\n    final Canvas canvas = new Canvas(croppedBitmap);\n    canvas.drawBitmap(rgbFrameBitmap, frameToCropTransform, null);\n\n    if (SAVE_PREVIEW_BITMAP) {\n      ImageUtils.saveBitmap(croppedBitmap);\n    }\n\n    runInBackground(\n        new Runnable() {\n        });\n    if (desiredSize != initializedSize) {\n      resetPreviewBuffers();\n    }\n  }",
        "human_comment": "For examining the actual TF input.",
        "model_generated_comment": "Processes the image of the desired size.\n\n@param desiredSize The desired size of the image, must not be <code>null</code>."
    },
    {
        "id": 367,
        "code_snippet": "public void deactivateOptionalProject(String selector) {\n        this.activations.add(new ProjectActivationSettings(selector, ActivationSettings.deactivatedOpt()));\n    }",
        "human_comment": "Mark a project as optional and deactivated.\n@param selector The selector of the project.",
        "model_generated_comment": "Deactivate an optional project.\n\n@param selector The selector to deactivate.\n@return An activated project."
    },
    {
        "id": 368,
        "code_snippet": "static ClassNameFilter excludeClassNamePatterns(String... patterns) {\n\t\treturn new ExcludeClassNameFilter(patterns);\n\t}",
        "human_comment": "Create a new <em>exclude</em> {@link ClassNameFilter} based on the\n@see Class#getName()\n@see #includeClassNamePatterns(String...)",
        "model_generated_comment": "Create a new {@link ExcludeClassNameFilter} for the supplied {@code patterns}.\n\n@since 5.4"
    },
    {
        "id": 369,
        "code_snippet": "public ColumnarArray(ColumnVector data, int offset, int length) {\n    this.data = data;\n    this.offset = offset;\n    this.length = length;\n  }",
        "human_comment": "Array abstraction in {@link ColumnVector}.",
        "model_generated_comment": "Creates a ColumnarArray with the given data and offset.\n\n@param data The data to put into the column array, may be {@code null}."
    },
    {
        "id": 370,
        "code_snippet": "public static void assertEquals(Integer expected, int actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Integer) actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and{@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\nsupplied {@link Supplier}.\n\n@since 5.4"
    },
    {
        "id": 371,
        "code_snippet": "public static void assertEquals(float expected, float actual, float delta) {\n        assertEquals(null, expected, actual, delta);\n    }",
        "human_comment": "Asserts that two floats are equal to within a positive delta.\nIf they are not, an {@link AssertionError} is thrown. If the expected\nvalue is infinity then the delta value is ignored. NaNs are considered\nequal: <code>assertEquals(Float.NaN, Float.NaN, *)</code> passes\n\n@param expected expected value\n@param actual the value to check against <code>expected</code>\n@param delta the maximum delta between <code>expected</code> and\n<code>actual</code> for which both numbers are still\nconsidered equal.",
        "model_generated_comment": "Asserts that two floats are equal. If they are not, they are considered equal."
    },
    {
        "id": 372,
        "code_snippet": "public MyDoubleAvg() {\n    List<StructField> inputFields = new ArrayList<>();\n    inputFields.add(DataTypes.createStructField(\"inputDouble\", DataTypes.DoubleType, true));\n    _inputDataType = DataTypes.createStructType(inputFields);\n\n    // The buffer has two values, bufferSum for storing the current sum and\n    // bufferCount for storing the number of non-null input values that have been contributed\n    // to the current sum.\n    List<StructField> bufferFields = new ArrayList<>();\n    bufferFields.add(DataTypes.createStructField(\"bufferSum\", DataTypes.DoubleType, true));\n    bufferFields.add(DataTypes.createStructField(\"bufferCount\", DataTypes.LongType, true));\n    _bufferSchema = DataTypes.createStructType(bufferFields);\n\n    _returnDataType = DataTypes.DoubleType;\n  }",
        "human_comment": "An example {@link UserDefinedAggregateFunction} to calculate a special average value of a\n{@link org.apache.spark.sql.types.DoubleType} column. This special average value is the sum\nof the average value of input values and 100.0.",
        "model_generated_comment": "Creates a new {@link DoubleAvg} buffer with two values.\n\n@param inputFields The buffer with the values to store, must not be {@code null}."
    },
    {
        "id": 373,
        "code_snippet": "Handler repoHandler = new AbstractHandler() {\n                    response.setStatus(HttpServletResponse.SC_OK);\n                    response.getWriter().println(\"<project>\");\n                    response.getWriter().println(\"  <modelVersion>4.0.0</modelVersion>\");\n                    response.getWriter().println(\"  <groupId>org.apache.maven.its.mng3461</groupId>\");\n                    response.getWriter().println(\"  <artifactId>b</artifactId>\");\n                    response.getWriter().println(\"  <version>0.1</version>\");\n                    response.getWriter().println(\"</project>\");\n                } else {\n                    response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                }",
        "human_comment": "Test that mirror definitions are properly evaluated. In particular, the wildcard external:* should not\nmatch file:// and localhost repos but only external repos.\n\n@throws Exception in case of failure",
        "model_generated_comment": "Create a new repo handler for the given project.\n\n@param repoHandler The repo handler\n@return A new repoHandler"
    },
    {
        "id": 374,
        "code_snippet": "private UsersDatabase getMigratedRoomDatabase() {\n        UsersDatabase database = Room.databaseBuilder(ApplicationProvider.getApplicationContext(),\n                UsersDatabase.class, TEST_DB_NAME)\n                .addMigrations(MIGRATION_1_2, MIGRATION_2_3)\n                .build();\n        // close the database and release any stream resources when the test finishes\n        mMigrationTestHelper.closeWhenFinished(database);\n        return database;\n    }",
        "human_comment": "Test the migration from versions 1 and 2, to version 3.",
        "model_generated_comment": "Get the Migrated RoomDatabase.\n\n@param UsersDatabase the Migrate RoomDatabase\n@return the Migrations RoomDatabase"
    },
    {
        "id": 375,
        "code_snippet": "public static synchronized MaintenanceLock getInstance() {\n    if (instance == null) {\n      instance = new MaintenanceLock();\n    }\n    return instance;\n  }",
        "human_comment": "Get the instance of MaintenanceLock.\n\n@return singleton instance of MaintenanceLock",
        "model_generated_comment": "Returns an instance of {@link MaintenanceLock}.\n\n@param instance the instance to retrieve\n@return an instance"
    },
    {
        "id": 376,
        "code_snippet": "public Runner addTarget(Operation operation) {\n      if (!(operation instanceof GraphOperation)) {\n        throw new IllegalArgumentException(\n            \"Operation of type \"\n                + operation.getClass().getName()\n                + \" is not supported in graph sessions\");\n      }\n      targets.add((GraphOperation) operation);\n      return this;\n    }",
        "human_comment": "Make {@link #run()} execute {@code operation}, but not return any evaluated {@link Tensor\nTensors}.\n\n@throws IllegalArgumentException if the operation is not a {@link GraphOperation}",
        "model_generated_comment": "Add a target to a graph session.\n\n@param operation operation the operation to add\n@return this target"
    },
    {
        "id": 377,
        "code_snippet": "private int hash(long item, int count) {\n    long hash = hashA[count] * item;\n    hash += hash >> 32;\n    hash &= PRIME_MODULUS;\n    return ((int) hash) % width;\n  }",
        "human_comment": "A super fast way of computing x mod 2^p-1\nSee http://www.cs.princeton.edu/courses/archive/fall09/cos521/Handouts/universalclasses.pdf\npage 149, right after Proposition 7.\nDoing \"%\" after (int) conversion is ~2x faster than %'ing longs.",
        "model_generated_comment": "Creates a hash of the given item.\n\n@param item The item to hash."
    },
    {
        "id": 378,
        "code_snippet": "protected ConfiguredGoalSupport(MessageBuilderFactory messageBuilderFactory, SecDispatcher secDispatcher) {\n        super(messageBuilderFactory, secDispatcher);\n    }",
        "human_comment": "The support class for goal implementations that requires valid/workable config.",
        "model_generated_comment": "Configured goal support for {@link ConfiguredGoalSupport}.\n\n@param messageBuilderFactory the {@code SecDispatcher} to configure."
    },
    {
        "id": 379,
        "code_snippet": "public int nextCapacity(int currentCapacity) {\n      assert (currentCapacity > 0);\n      int doubleCapacity = currentCapacity * 2;\n      // Guard against overflow\n      return (doubleCapacity > 0 && doubleCapacity <= ARRAY_MAX) ? doubleCapacity : ARRAY_MAX;\n    }",
        "human_comment": "Double the size of the hash map every time.",
        "model_generated_comment": "Creates a new {@code nextCapacity} with the given current capacity.\n\n@param currentCapacity The current capacity of the current capacity, may be 0."
    },
    {
        "id": 380,
        "code_snippet": "public void createObjectFromXml(Node node) {\n    name = node.getAttributes().getNamedItem(\"name\").getNodeValue();\n    NodeList childNodes = node.getChildNodes();\n    iterateXmlForAnimalAndPlants(childNodes, animalsEaten, plantsEaten);\n  }",
        "human_comment": "Parses the Animal Object from the input XML Node.\n\n@param node the XML Node from which the Animal Object is to be parsed",
        "model_generated_comment": "Creates an object from Xml.\n\n@param node The node to create the object from."
    },
    {
        "id": 381,
        "code_snippet": "private void addChildrenRecursively(VintageTestDescriptor parent) {\n\t\tif (parent.getDescription().isTest()) {\n\t\t\treturn;\n\t\t}\n\t\tList<Description> children = parent.getDescription().getChildren();\n\t\tMap<String, List<Description>> childrenByUniqueId = children.stream().collect(\n\t\t\tgroupingBy(uniqueIdReader.andThen(uniqueIdStringifier), LinkedHashMap::new, toCollection(ArrayList::new)));\n\t\tfor (Entry<String, List<Description>> entry : childrenByUniqueId.entrySet()) {\n\t\t\tString uniqueId = entry.getKey();\n\t\t\tList<Description> childrenWithSameUniqueId = entry.getValue();\n\t\t\tIntFunction<String> uniqueIdGenerator = determineUniqueIdGenerator(uniqueId, childrenWithSameUniqueId);\n\t\t\tfor (int index = 0; index < childrenWithSameUniqueId.size(); index++) {\n\t\t\t\tString reallyUniqueId = uniqueIdGenerator.apply(index);\n\t\t\t\tDescription description = childrenWithSameUniqueId.get(index);\n\t\t\t\tUniqueId id = parent.getUniqueId().append(VintageTestDescriptor.SEGMENT_TYPE_TEST, reallyUniqueId);\n\t\t\t\tVintageTestDescriptor child = new VintageTestDescriptor(id, description,\n\t\t\t\t\ttestSourceProvider.findTestSource(description));\n\t\t\t\tparent.addChild(child);\n\t\t\t\taddChildrenRecursively(child);\n\t\t\t}\n\t\t}\n\t}",
        "human_comment": "Use LinkedHashMap to preserve order, ArrayList for fast access by index",
        "model_generated_comment": "Create a new {@link VintageTestDescriptor}.\n\n@since 5.0"
    },
    {
        "id": 382,
        "code_snippet": "void testRoundTripProfiles() {\n        Random entropy = new Random();\n        ActivationFile af = ActivationFile.newBuilder()\n                .exists(\"exists\" + Long.toHexString(entropy.nextLong()))\n                .missing(\"missing\" + Long.toHexString(entropy.nextLong()))\n                .build();\n        ActivationProperty ap = ActivationProperty.newBuilder()\n                .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                .value(\"value\" + Long.toHexString(entropy.nextLong()))\n                .build();\n        ActivationOS ao = ActivationOS.newBuilder()\n                .arch(\"arch\" + Long.toHexString(entropy.nextLong()))\n                .family(\"family\" + Long.toHexString(entropy.nextLong()))\n                .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                .version(\"version\" + Long.toHexString(entropy.nextLong()))\n                .build();\n        Activation a = Activation.newBuilder()\n                .activeByDefault(entropy.nextBoolean())\n                .jdk(\"jdk\" + Long.toHexString(entropy.nextLong()))\n                .file(af)\n                .property(ap)\n                .os(ao)\n                .packaging(\"pom\")\n                .build();\n        Map<String, String> props = new HashMap<>();\n        int count = entropy.nextInt(10);\n        for (int i = 0; i < count; i++) {\n            props.put(\"name\" + Long.toHexString(entropy.nextLong()), \"value\" + Long.toHexString(entropy.nextLong()));\n        }\n        count = entropy.nextInt(3);\n        List<Repository> repos = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            Repository r = Repository.newBuilder()\n                    .id(\"id\" + Long.toHexString(entropy.nextLong()))\n                    .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                    .url(\"url\" + Long.toHexString(entropy.nextLong()))\n                    .build();\n            repos.add(r);\n        }\n        count = entropy.nextInt(3);\n        List<Repository> pluginRepos = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            Repository r = Repository.newBuilder()\n                    .id(\"id\" + Long.toHexString(entropy.nextLong()))\n                    .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                    .url(\"url\" + Long.toHexString(entropy.nextLong()))\n                    .build();\n            pluginRepos.add(r);\n        }\n        Profile p = Profile.newBuilder()\n                .id(\"id\" + Long.toHexString(entropy.nextLong()))\n                .activation(a)\n                .properties(props)\n                .repositories(repos)\n                .pluginRepositories(pluginRepos)\n                .build();\n\n        Profile clone = SettingsUtilsV4.convertToSettingsProfile(SettingsUtilsV4.convertFromSettingsProfile(p));\n\n        assertEquals(p.getId(), clone.getId());\n        assertEquals(p.getActivation().getJdk(), clone.getActivation().getJdk());\n        assertEquals(\n                p.getActivation().getFile().getExists(),\n                clone.getActivation().getFile().getExists());\n        assertEquals(\n                p.getActivation().getFile().getMissing(),\n                clone.getActivation().getFile().getMissing());\n        assertEquals(\n                p.getActivation().getProperty().getName(),\n                clone.getActivation().getProperty().getName());\n        assertEquals(\n                p.getActivation().getProperty().getValue(),\n                clone.getActivation().getProperty().getValue());\n        assertEquals(\n                p.getActivation().getOs().getArch(),\n                clone.getActivation().getOs().getArch());\n        assertEquals(\n                p.getActivation().getOs().getFamily(),\n                clone.getActivation().getOs().getFamily());\n        assertEquals(\n                p.getActivation().getOs().getName(),\n                clone.getActivation().getOs().getName());\n        assertEquals(\n                p.getActivation().getOs().getVersion(),\n                clone.getActivation().getOs().getVersion());\n        assertEquals(p.getActivation().getPackaging(), clone.getActivation().getPackaging());\n        assertEquals(p.getProperties(), clone.getProperties());\n        assertEquals(p.getRepositories().size(), clone.getRepositories().size());\n        assertEquals(\n                p.getPluginRepositories().size(), clone.getPluginRepositories().size());\n    }",
        "human_comment": "TODO deep compare the lists\nTODO deep compare the lists",
        "model_generated_comment": "Tests that we have the following properties:\n\n<p>\nThis is a test set for <a href=\"https://issues.apache.org/jira/browse/Activation\">Activation</a>."
    },
    {
        "id": 383,
        "code_snippet": "public static List<Object[]> dataProvider() {\n    return List.of(\n        new Object[] {new Item(ItemType.POTION, \"Potion of courage\")},\n        new Object[] {new Item(ItemType.RING, \"Ring of shadows\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of wisdom\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of blood\")},\n        new Object[] {new Item(ItemType.WEAPON, \"Sword of silver +1\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of rust\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of healing\")},\n        new Object[] {new Item(ItemType.RING, \"Ring of armor\")},\n        new Object[] {new Item(ItemType.WEAPON, \"Steel halberd\")},\n        new Object[] {new Item(ItemType.WEAPON, \"Dagger of poison\")});\n\n  @ParameterizedTest\n  @MethodSource(\"dataProvider\")\n  void testIterator(Item expectedItem) {\n    final var chest = new TreasureChest();\n    final var iterator = chest.iterator(expectedItem.getType());\n    assertNotNull(iterator);\n\n    while (iterator.hasNext()) {\n      final var item = iterator.next();\n      assertNotNull(item);\n      assertEquals(expectedItem.getType(), item.getType());\n\n      final var name = item.toString();\n      assertNotNull(name);\n      if (expectedItem.toString().equals(name)) {\n        return;\n      }\n    }\n\n    fail(\"Expected to find item [\" + expectedItem + \"] using iterator, but we didn't.\");\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"dataProvider\")\n  void testGetItems(Item expectedItem) {\n    final var chest = new TreasureChest();\n    final var items = chest.getItems();\n    assertNotNull(items);\n\n    for (final var item : items) {\n      assertNotNull(item);\n      assertNotNull(item.getType());\n      assertNotNull(item.toString());\n\n      final var sameType = expectedItem.getType() == item.getType();\n      final var sameName = expectedItem.toString().equals(item.toString());\n      if (sameType && sameName) {\n        return;\n      }\n    }\n\n    fail(\"Expected to find item [\" + expectedItem + \"] in the item list, but we didn't.\");\n  }\n}",
        "human_comment": "Test if the expected item can be retrieved from the chest using the {@link\nTreasureChest#getItems()} method",
        "model_generated_comment": "Returns a list of items that are expected to be retrieved.\n\n@param dataProvider the data provider\n@return the list"
    },
    {
        "id": 384,
        "code_snippet": "static TableChange addConstraint(Constraint constraint, String validatedTableVersion) {\n    return new AddConstraint(constraint, validatedTableVersion);\n  }",
        "human_comment": "Create a TableChange for adding a new table constraint",
        "model_generated_comment": "Add a new constraint to the supplied table.\n\n@param constraint the constraint to add.\n@return a new TableChange"
    },
    {
        "id": 385,
        "code_snippet": "protected LayeredOptions(List<O> options) {\n        this.options = new ArrayList<>(options);\n    }",
        "human_comment": "Options that are \"layered\" by precedence order.\n\n@param <O> The type of options.",
        "model_generated_comment": "Create a new {@link LayeredOptions} with the specified options.\n\n@param options The {@code options} to use, may be <code>null</code>."
    },
    {
        "id": 386,
        "code_snippet": "public static boolean isPublic(Class<?> clazz) {\n\t\treturn ReflectionUtils.isPublic(clazz);\n\t}",
        "human_comment": "Determine if the supplied class is {@code public}.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is {@code public}\n@see java.lang.reflect.Modifier#isPublic(int)",
        "model_generated_comment": "<em>Assert</em> that the supplied class is public.\n\n@param clazz the class to check; never {@code null} or blank"
    },
    {
        "id": 387,
        "code_snippet": "final int collationId) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType && !collation.supportsSpaceTrimming) {\n        return execBinary(srcString, trimString);\n      }\n\n      if (collation.isUtf8BinaryType) {\n        return execBinaryTrim(srcString, trimString, collationId);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(srcString, trimString, collationId);\n      } else {\n        return execICU(srcString, trimString, collationId);\n      }\n    }",
        "human_comment": "special handling needed for utf8_binary_rtrim collation.",
        "model_generated_comment": "Fetch collation ID from collation.\n\n@param collationId the collation id\n@return execBinary(srcString)"
    },
    {
        "id": 388,
        "code_snippet": "protected Module getCustomModule(C context, CoreExports exports) {\n        return new AbstractModule() {\n        };\n    }",
        "human_comment": "Note: overriding this method should be avoided. Preferred way to replace Maven components is the \"normal\" way\nwhere the components are on index (are annotated with JSR330 annotations and Sisu index is created) and, they\nhave priorities set.",
        "model_generated_comment": "Get the custom module from the supplied context.\n\n@param context The context of the module\n@return The custom module"
    },
    {
        "id": 389,
        "code_snippet": "public void sendHeartbeatInvokeMessage(int currentId) {\n    var nextInstance = this.findNextInstance(currentId);\n    var heartbeatInvokeMessage = new Message(MessageType.HEARTBEAT_INVOKE, \"\");\n    nextInstance.onMessage(heartbeatInvokeMessage);\n  }",
        "human_comment": "Send heartbeat invoke message to the next instance.\n\n@param currentId Instance ID of which sends this message.",
        "model_generated_comment": "Send the heartbeat message to the next instance.\n\n@param currentId the current ID of the heartbeat\n@return The heartbeat message"
    },
    {
        "id": 390,
        "code_snippet": "private DropConstraint(String name, boolean ifExists, Mode mode) {\n      this.name = name;\n      this.ifExists = ifExists;\n      this.mode = mode;\n    }",
        "human_comment": "Defines modes for dropping a constraint.\n<p>\nRESTRICT - Prevents dropping a constraint if it is referenced by other objects.\nCASCADE - Automatically drops objects that depend on the constraint.",
        "model_generated_comment": "Constraint that matches if and only if the given name is used.\n\n@param name the name of the input string, may be {@code null}."
    },
    {
        "id": 391,
        "code_snippet": "public static EngineFilter includeEngines(List<String> engineIds) {\n\t\treturn new EngineFilter(engineIds, Type.INCLUDE);\n\t}",
        "human_comment": "Create a new <em>include</em> {@code EngineFilter} based on the\n<em>included</em> within the test discovery and execution.\n\n@param engineIds the list of engine IDs to match against; never {@code null}\nor empty; individual IDs must also not be null or blank\n@see #includeEngines(String...)",
        "model_generated_comment": "Create a new {@link EngineFilter} with the supplied engine ids.\n\n@param engineIds the list of engines to include; never {@code null} or blank"
    },
    {
        "id": 392,
        "code_snippet": "void assertNotEqualsByte() {\n\t\t\tbyte unexpected = 1;\n\t\t\tbyte actual = 2;\n\t\t\tassertNotEquals(unexpected, actual);\n\t\t\tassertNotEquals(unexpected, actual, \"message\");\n\t\t\tassertNotEquals(unexpected, actual, () -> \"message\");\n\t\t}",
        "human_comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0",
        "model_generated_comment": "Unit tests for {@link Assertions}.\n\n@since 5.4"
    },
    {
        "id": 393,
        "code_snippet": "private void mergeSessions(List<SessionAcc> sessionAccs, GroupState<Sessions> state) {\n\n            int curIdx = 0;\n            while (curIdx < sessionAccs.size() - 1) {\n              SessionAcc curSession = sessionAccs.get(curIdx);\n              SessionAcc nextSession = sessionAccs.get(curIdx + 1);\n\n              if (curSession.endTime().getTime() > nextSession.startTime().getTime()) {\n                List<SessionEvent> accumulatedEvents = new ArrayList<>(curSession.getEvents());\n                accumulatedEvents.addAll(nextSession.getEvents());\n                accumulatedEvents.sort(\n                    Comparator.comparingLong(e -> e.getStartTimestamp().getTime()));\n\n                List<SessionAcc> newSessions = new ArrayList<>();\n                List<SessionEvent> eventsForCurSession = new ArrayList<>();\n                for (SessionEvent event : accumulatedEvents) {\n                  eventsForCurSession.add(event);\n                  if (event.eventType == EventTypes.CLOSE_SESSION) {\n                    SessionAcc newSessionAcc = SessionAcc.newInstance(eventsForCurSession);\n                    newSessions.add(newSessionAcc);\n                    eventsForCurSession = new ArrayList<>();\n                  }\n                }\n                if (!eventsForCurSession.isEmpty()) {\n                  SessionAcc newSessionAcc = SessionAcc.newInstance(eventsForCurSession);\n                  newSessions.add(newSessionAcc);\n                }\n\n                sessionAccs.remove(curIdx + 1);\n                sessionAccs.set(curIdx, newSessions.get(0));\n                if (newSessions.size() > 1) {\n                  sessionAccs.addAll(curIdx + 1,\n                      newSessions.stream().skip(1).collect(Collectors.toList()));\n                }\n\n                curIdx += newSessions.size() - 1;\n              } else {\n                curIdx++;\n              }\n            }\n\n            state.update(Sessions.newInstance(sessionAccs));\n          }",
        "human_comment": "we sorted sessionAccs by timestamp\nCurrent session and next session can be merged\nreplace current session and next session with new session(s)\nmove the cursor to the last new session(s)\nmove to the next session\nupdate state",
        "model_generated_comment": "Merges sessionAccs into a new session.\n\n@param sessionAcc The session to merge, may be {@code null}."
    },
    {
        "id": 394,
        "code_snippet": "public Object createTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext extensionContext) {\n\t\t\treturn \"bogus\";\n\t\t}",
        "human_comment": "{@link TestInstanceFactory} that returns an object of a type that does\nnot match the supplied test class.",
        "model_generated_comment": "Creates a new {@link TestInstanceFactory} using the supplied {@code factoryContext} and the supplied extensionContext.\n\n@param factoryContext the factoryContext to use; never {code null} or blank\n@return a new instance"
    },
    {
        "id": 395,
        "code_snippet": "public static void assertNotEquals(short unexpected, short actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and {@link actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 396,
        "code_snippet": "protected void runChild(final FrameworkMethod method, RunNotifier notifier) {\n        Description description = describeChild(method);\n        if (isIgnored(method)) {\n            notifier.fireTestIgnored(description);\n        } else {\n            Statement statement = new Statement() {\n            };\n            runLeaf(statement, description, notifier);\n        }\n    }",
        "human_comment": "Creates a BlockJUnit4ClassRunner to run {@code testClass}.\n\n@throws InitializationError if the test class is malformed.\n@since 4.13",
        "model_generated_comment": "Runs the child of the given method.\n\n@param method the method to run, may be {@code null}."
    },
    {
        "id": 397,
        "code_snippet": "public static Optional<? extends DiscoverySelector> parse(String identifier) {\n\t\treturn DiscoverySelectorIdentifierParsers.parse(identifier);\n\t}",
        "human_comment": "Parse the supplied string representation of a {@link DiscoverySelectorIdentifier}.\n\n@param identifier the string representation of a {@code DiscoverySelectorIdentifier};\nnever {@code null} or blank\n@return an {@link Optional} containing the corresponding {@link DiscoverySelector};\nnever {@code null} but potentially empty\n@since 1.11\n@see DiscoverySelectorIdentifierParser",
        "model_generated_comment": "Create a new {@link DiscoverySelectorIdentifier}.\n\n@param identifier the identifier to parse; never {@code null}"
    },
    {
        "id": 398,
        "code_snippet": "void executionsFromSucceededTestEvents() {\n\t\tvar testEvents = getTestEvents();\n\n\t\tassertThat(testEvents.executions().succeeded().count()).isEqualTo(1);\n\t\tassertThat(testEvents.succeeded().executions().count()).isEqualTo(0);\n\t}",
        "human_comment": "We expect 1 if the executions are created BEFORE filtering out \"finished\" events.\nWe expect 0 if the executions are created AFTER filtering out \"finished\" events.",
        "model_generated_comment": "<em>Assert</em> that {@code executionsFromSucceededTestEvents()}.\n\n@since 5.4"
    },
    {
        "id": 399,
        "code_snippet": "private ArtifactRepository createLocalArtifactRepository(Path baseDirectory) {\n        DefaultRepositoryLayout layout = new DefaultRepositoryLayout();\n        ArtifactRepositoryPolicy blah = new ArtifactRepositoryPolicy(\n                true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE);\n        return new MavenArtifactRepository(\n                \"local\", \"file://\" + baseDirectory.toUri().getRawPath(), layout, blah, blah);\n    }",
        "human_comment": "TODO: get rid of this!!!",
        "model_generated_comment": "Creates a new MavenArtifactRepository.\n\n@param baseDirectory The base directory of the repository\n@return a Maven ArtifactRepository"
    },
    {
        "id": 400,
        "code_snippet": "public Builder assureDeletion() {\n            this.assureDeletion = true;\n            return this;\n        }",
        "human_comment": "Setting this flag assures that no resources are left undeleted. Failure\nto fulfill the assurance results in failure of tests with an\n{@link AssertionError}.\n\n@return this",
        "model_generated_comment": "<em>Assert</em> that {@link AssureDeletion} is true."
    },
    {
        "id": 401,
        "code_snippet": "void testMergeModelModelVersion() {\n        Model parent = Model.newBuilder().modelVersion(\"4.0.0\").build();\n        Model model = Model.newInstance();\n        Model.Builder builder = Model.newBuilder(model);\n        modelMerger.mergeModel_ModelVersion(builder, model, parent, false, null);\n        assertNull(builder.build().getModelVersion());\n\n        model = Model.newBuilder().modelVersion(\"5.0.0\").build();\n        builder = Model.newBuilder(model);\n        modelMerger.mergeModel_ModelVersion(builder, model, parent, false, null);\n        assertEquals(\"5.0.0\", builder.build().getModelVersion());\n    }",
        "human_comment": "modelVersion is neither inherited nor injected",
        "model_generated_comment": "TestMergeModelVersion()\n\n@param model the model to be merged\n@return The merged model"
    },
    {
        "id": 402,
        "code_snippet": "Stream<DynamicTest> dynamicTestsFromStreamFactoryMethodWithNames() {\n\t\tvar inputStream = Stream.of(\n\t\t\tnamed(\"racecar is a palindrome\", \"racecar\"),\n\t\t\tnamed(\"radar is also a palindrome\", \"radar\"),\n\t\t\tnamed(\"mom also seems to be a palindrome\", \"mom\"),\n\t\t\tnamed(\"dad is yet another palindrome\", \"dad\")\n\t\t);\n\n\t\treturn DynamicTest.stream(inputStream, text -> assertTrue(isPalindrome(text)));\n\t}",
        "human_comment": "tag::user_guide[]\nStream of palindromes to check\nend::user_guide[]\n@formatter:off\ntag::user_guide[]\nend::user_guide[]\n@formatter:on\ntag::user_guide[]\nReturns a stream of dynamic tests.",
        "model_generated_comment": "<em>Assert</em> that the supplied {@link DynamicTest} is a palindrome."
    },
    {
        "id": 403,
        "code_snippet": "private Map<String, BuildStep> merge(Map<String, BuildStep> org, Map<String, BuildStep> add) {\n        List<BuildStep> lasts =\n                org.values().stream().filter(b -> b.successors.isEmpty()).toList();\n        List<BuildStep> firsts =\n                add.values().stream().filter(b -> b.predecessors.isEmpty()).toList();\n        firsts.stream()\n                .filter(addNode -> !org.containsKey(addNode.name))\n                .forEach(addNode -> lasts.forEach(orgNode -> addNode.executeAfter(orgNode)));\n        add.forEach((name, node) -> org.merge(name, node, this::merge));\n        return org;\n    }",
        "human_comment": "all new phases should be added after the existing ones",
        "model_generated_comment": "Merges a build step with the given builder.\n\n@param org The builder to merge, may be {@code null}."
    },
    {
        "id": 404,
        "code_snippet": "default MessageBuilder a(CharSequence value) {\n        return append(value);\n    }",
        "human_comment": "Append content to the message buffer.\n\n@param value the content to append\n@return the current builder",
        "model_generated_comment": "Creates a new {@link MessageBuilder} with the given value.\n\n@param value the value to append.\n@return a new MessageBuilder"
    },
    {
        "id": 405,
        "code_snippet": "public Loader withConfigProto(byte[] configProto) {\n      this.configProto = configProto;\n      return this;\n    }",
        "human_comment": "Set configuration of the <code>Session</code> object created when loading the model.\n\n@param configProto Serialized <a\nhref=\"https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto\">ConfigProto\nprotocol buffer</a>.",
        "model_generated_comment": "Creates a {@link Loader}.\n\n@param configProto The config to load\n@return this {@code Loader}"
    },
    {
        "id": 406,
        "code_snippet": "private static void runJsonDatasetExample(SparkSession spark) {\n    Dataset<Row> people = spark.read().json(\"examples/src/main/resources/people.json\");\n\n    people.printSchema();\n\n    people.createOrReplaceTempView(\"people\");\n\n    Dataset<Row> namesDF = spark.sql(\"SELECT name FROM people WHERE age BETWEEN 13 AND 19\");\n    namesDF.show();\n\n    List<String> jsonData = Arrays.asList(\n            \"{\\\"name\\\":\\\"Yin\\\",\\\"address\\\":{\\\"city\\\":\\\"Columbus\\\",\\\"state\\\":\\\"Ohio\\\"}}\");\n    Dataset<String> anotherPeopleDataset = spark.createDataset(jsonData, Encoders.STRING());\n    Dataset<Row> anotherPeople = spark.read().json(anotherPeopleDataset);\n    anotherPeople.show();\n  }",
        "human_comment": "$example on:json_dataset$\nA JSON dataset is pointed to by path.\nThe path can be either a single text file or a directory storing text files\nThe inferred schema can be visualized using the printSchema() method\nroot\n|-- age: long (nullable = true)\n|-- name: string (nullable = true)\nCreates a temporary view using the DataFrame\nSQL statements can be run by using the sql methods provided by spark\n+------+\n|  name|\n+------+\n|Justin|\n+------+\nAlternatively, a DataFrame can be created for a JSON dataset represented by\na Dataset<String> storing one JSON object per string.\n+---------------+----+\n|        address|name|\n+---------------+----+\n|[Columbus,Ohio]| Yin|\n+---------------+----+\n$example off:json_dataset$",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 407,
        "code_snippet": "public SuiteLauncherDiscoveryRequestBuilder configurationParameter(String key, String value) {\n\t\tthis.delegate.configurationParameter(key, value);\n\t\treturn this;\n\t}",
        "human_comment": "Add the supplied <em>configuration parameter</em> to the request.\n\n@param key the configuration parameter key under which to store the\nvalue; never {@code null} or blank\n@param value the value to store\n@return this builder for method chaining",
        "model_generated_comment": "Create a new {@link SuiteLauncherDiscoveryRequestBuilder} with the supplied configuration parameter.\n\n@param key the key to use; never {@code null}\n@return this builder instance"
    },
    {
        "id": 408,
        "code_snippet": "public long runtime(TimeUnit unit) {\n        return unit.convert(getNanos(), TimeUnit.NANOSECONDS);\n    }",
        "human_comment": "Gets the runtime for the test.\n\n@param unit time unit for returned runtime\n@return runtime measured during the test",
        "model_generated_comment": "Convert a unit to a runtime.\n\n@param unit the unit to convert."
    },
    {
        "id": 409,
        "code_snippet": "public static String showVersion(String commandLine, String terminal) {\n        final String ls = System.lineSeparator();\n        Properties properties = getBuildProperties();\n        StringBuilder version = new StringBuilder(256);\n        version.append(MessageUtils.builder().strong(createMavenVersionString(properties)))\n                .append(ls);\n        version.append(reduce(properties.getProperty(\"distributionShortName\") + \" home: \"\n                        + System.getProperty(\"maven.home\", \"<unknown Maven \" + \"home>\")))\n                .append(ls);\n        version.append(\"Java version: \")\n                .append(System.getProperty(\"java.version\", \"<unknown Java version>\"))\n                .append(\", vendor: \")\n                .append(System.getProperty(\"java.vendor\", \"<unknown vendor>\"))\n                .append(\", runtime: \")\n                .append(System.getProperty(\"java.home\", \"<unknown runtime>\"))\n                .append(ls);\n        version.append(\"Default locale: \")\n                .append(Locale.getDefault())\n                .append(\", platform encoding: \")\n                .append(System.getProperty(\"file.encoding\", \"<unknown encoding>\"))\n                .append(ls);\n        version.append(\"OS name: \\\"\")\n                .append(Os.OS_NAME)\n                .append(\"\\\", version: \\\"\")\n                .append(Os.OS_VERSION)\n                .append(\"\\\", arch: \\\"\")\n                .append(Os.OS_ARCH)\n                .append(\"\\\", family: \\\"\")\n                .append(Os.OS_FAMILY)\n                .append('\\\"');\n        if (commandLine != null) {\n            version.append(ls).append(\"Command line: \").append(commandLine);\n        }\n        if (terminal != null) {\n            version.append(ls).append(\"Terminal: \").append(terminal);\n        }\n        return version.toString();\n    }",
        "human_comment": "Add process information using modern Java API",
        "model_generated_comment": "Creates a Maven version string with the given command line and terminal.\n\n@param commandLine The command line to be used to create the version string\n@return The version string, never {@code null}"
    },
    {
        "id": 410,
        "code_snippet": "public static List<Resource> findAllResourcesInModule(String moduleName, Predicate<Resource> resourceFilter) {\n\t\treturn ReflectionUtils.findAllResourcesInModule(moduleName, resourceFilter);\n\t}",
        "human_comment": "Find all {@linkplain Resource resources} in the supplied {@code moduleName}\nthat match the specified {@code resourceFilter} predicate.\n\n<p>The module-path scanning algorithm searches recursively in all\npackages contained in the module.\n\n@param moduleName the name of the module to scan; never {@code null} or\n<em>empty</em>\n@param resourceFilter the resource type filter; never {@code null}\n@return an immutable list of all such resources found; never {@code null}\nbut potentially empty\n@since 1.11\n@see #findAllResourcesInClasspathRoot(URI, Predicate)\n@see #findAllResourcesInPackage(String, Predicate)",
        "model_generated_comment": "Find all resources in a module.\n\n@param moduleName the module name; never {@code null}\n@return a list of all resources found in the module."
    },
    {
        "id": 411,
        "code_snippet": "public void testQueueStream() {\n    ssc.stop();\n    SparkConf conf = new SparkConf()\n        .setMaster(\"local[2]\")\n        .setAppName(\"test\")\n        .set(\"spark.streaming.clock\", \"org.apache.spark.util.ManualClock\");\n    ssc = new JavaStreamingContext(conf, new Duration(1000));\n\n    List<List<Integer>> expected = Arrays.asList(\n        Arrays.asList(1,2,3),\n        Arrays.asList(4,5,6),\n        Arrays.asList(7,8,9));\n\n    JavaSparkContext jsc = new JavaSparkContext(ssc.ssc().sc());\n    JavaRDD<Integer> rdd1 = jsc.parallelize(Arrays.asList(1, 2, 3));\n    JavaRDD<Integer> rdd2 = jsc.parallelize(Arrays.asList(4, 5, 6));\n    JavaRDD<Integer> rdd3 = jsc.parallelize(Arrays.asList(7,8,9));\n\n    Queue<JavaRDD<Integer>> rdds = new LinkedList<>();\n    rdds.add(rdd1);\n    rdds.add(rdd2);\n    rdds.add(rdd3);\n\n    JavaDStream<Integer> stream = ssc.queueStream(rdds);\n    JavaTestUtils.attachTestOutputStream(stream);\n    List<List<Integer>> result = JavaTestUtils.runStreams(ssc, 3, 3);\n    Assertions.assertEquals(expected, result);\n  }",
        "human_comment": "Create a new JavaStreamingContext without checkpointing",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 412,
        "code_snippet": "protected void evaluateState() {\n    if (failureCount >= failureThreshold) { // Then something is wrong with remote service\n      if ((System.nanoTime() - lastFailureTime) > retryTimePeriod) {\n        state = State.HALF_OPEN;\n      } else {\n        state = State.OPEN;\n      }\n    } else {\n      state = State.CLOSED;\n    }\n  }",
        "human_comment": "Evaluate the current state based on failureThreshold, failureCount and lastFailureTime.\nWe have waited long enough and should try checking if service is up\nService would still probably be down\nEverything is working fine",
        "model_generated_comment": "Evaluates the state of the remote service.\n\n@param failureThreshold The failure threshold to evaluate, may be {@code null}."
    },
    {
        "id": 413,
        "code_snippet": "public synchronized Enumeration<TestFailure> failures() {\n        return Collections.enumeration(fFailures);\n    }",
        "human_comment": "Returns an Enumeration for the failures.",
        "model_generated_comment": "Returns a {@link Enumeration} for the given failure.\n\n@param failures the failure to check."
    },
    {
        "id": 414,
        "code_snippet": "public static String comparableQualifier(String qualifier) {\n            if (RELEASE_QUALIFIERS.contains(qualifier)) {\n                return String.valueOf(QUALIFIERS.indexOf(\"\"));\n            }\n\n            int i = QUALIFIERS.indexOf(qualifier);\n\n            // Just returning an Integer with the index here is faster, but requires a lot of if/then/else to check for\n            // -1\n            //  or QUALIFIERS.size and then resort to lexical ordering. Most comparisons are decided by the first\n            // character,\n            // so this is still fast. If more characters are needed then it requires a lexical sort anyway.\n            return i == -1 ? (QUALIFIERS.size() + \"-\" + qualifier) : String.valueOf(i);\n        }",
        "human_comment": "Returns a comparable value for a qualifier.\n<p>\nThis method takes into account the ordering of known qualifiers then unknown qualifiers with lexical\nordering.\n<p>\n\n@param qualifier\n@return an equivalent value that can be used with lexical comparison",
        "model_generated_comment": "Returns a comparable qualifier with the given index.\n\n@param qualifier The qualifier to compare, must not be <code>null</code>."
    },
    {
        "id": 415,
        "code_snippet": "public void setClassRealm(ClassRealm classRealm) {\n        this.classRealm = classRealm;\n    }",
        "human_comment": "Sets the project's class realm. <strong>Warning:</strong> This is an internal utility method that is only public\nfor technical reasons, it is not part of the public API. In particular, this method can be changed or deleted\nwithout prior notice and must not be used by plugins.\n\n@param classRealm The class realm hosting the build extensions of this project, may be {@code null}.",
        "model_generated_comment": "Set the class value of {@link ClassRealm}.\n\n@param classRealm The class value to set."
    },
    {
        "id": 416,
        "code_snippet": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn parameterContext.getParameter().getType() == Double.class;\n\t}",
        "human_comment": "Example {@link ParameterResolver} that always resolves a {@link Double}\nparameter to {@code 42.0}.\n\n@since 5.0",
        "model_generated_comment": "<em>Assert</em> that the supplied {@code parameterContext} is a {@link Double}.\n\n@since 5.4"
    },
    {
        "id": 417,
        "code_snippet": "public boolean hasMetadataResolutionExceptions() {\n        return metadataResolutionExceptions != null;\n    }",
        "human_comment": "------------------------------------------------------------------------\nMetadata Resolution Exceptions: ArtifactResolutionExceptions\n------------------------------------------------------------------------",
        "model_generated_comment": "Returns a boolean that matches if and only if the given exception is null.\n\n@param metadataResolutionExceptions the exception to check"
    },
    {
        "id": 418,
        "code_snippet": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
        "human_comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp#main(String[])} throws an exception.",
        "model_generated_comment": "<em>Assert</em> that the execution of the main {@link App} throws an exception.\n\n@param String the String to check; never {@code null}"
    },
    {
        "id": 419,
        "code_snippet": "public static <T> void assertThat(T actual, Matcher<? super T> matcher) {\n        assertThat(\"\", actual, matcher);\n    }",
        "human_comment": "Asserts that <code>actual</code> satisfies the condition specified by\n<code>matcher</code>. If not, an {@link AssertionError} is thrown with\ninformation about the matcher and failing value. Example:\n\n<pre>\nassertThat(0, is(1)); // fails:\n// failure message:\n// expected: is &lt;1&gt;\n// got value: &lt;0&gt;\nassertThat(0, is(not(1))) // passes\n</pre>\n\n<code>org.hamcrest.Matcher</code> does not currently document the meaning\nof its type parameter <code>T</code>.  This method assumes that a matcher\ntyped as <code>Matcher&lt;T&gt;</code> can be meaningfully applied only\nto values that could be assigned to a variable of type <code>T</code>.\n\n@param <T> the static type accepted by the matcher (this can flag obvious\ncompile-time problems such as {@code assertThat(1, is(\"a\"))}\n@param actual the computed value being compared\n@param matcher an expression, built of {@link Matcher}s, specifying allowed\nvalues\n@see org.hamcrest.CoreMatchers\n@deprecated use {@code org.hamcrest.MatcherAssert.assertThat()}",
        "model_generated_comment": "<em>Assert</em> that {@code actual} is a <code>matcher</code>.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@link Matcher}."
    },
    {
        "id": 420,
        "code_snippet": "public TcpLoggingClient(String clientName, int serverPort) {\n      this.clientName = clientName;\n      this.serverPort = serverPort;\n    }",
        "human_comment": "Creates a new TCP logging client.\n\n@param clientName the name of the client to be sent in logging requests.\n@param serverPort the port on which client will send logging requests.",
        "model_generated_comment": "Create a new {@link TcpLoggingClient} with the given client name.\n\n@param clientName the client name\n@return a new Tcp LoggingClient"
    },
    {
        "id": 421,
        "code_snippet": "protected void prepareOptions(org.apache.commons.cli.Options options) {\n            options.addOption(Option.builder(HELP)\n                    .longOpt(\"help\")\n                    .desc(\"Display help information\")\n                    .build());\n            options.addOption(Option.builder(USER_PROPERTY)\n                    .numberOfArgs(2)\n                    .valueSeparator('=')\n                    .desc(\"Define a user property\")\n                    .build());\n            options.addOption(Option.builder(SHOW_VERSION_AND_EXIT)\n                    .longOpt(\"version\")\n                    .desc(\"Display version information\")\n                    .build());\n            options.addOption(Option.builder(QUIET)\n                    .longOpt(\"quiet\")\n                    .desc(\"Quiet output - only show errors\")\n                    .build());\n            options.addOption(Option.builder(VERBOSE)\n                    .longOpt(\"verbose\")\n                    .desc(\"Produce execution verbose output\")\n                    .build());\n            options.addOption(Option.builder(SHOW_ERRORS)\n                    .longOpt(\"errors\")\n                    .desc(\"Produce execution error messages\")\n                    .build());\n            options.addOption(Option.builder(BATCH_MODE)\n                    .longOpt(\"batch-mode\")\n                    .desc(\"Run in non-interactive mode. Alias for --non-interactive (kept for backwards compatability)\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(NON_INTERACTIVE)\n                    .desc(\"Run in non-interactive mode. Alias for --batch-mode\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(FORCE_INTERACTIVE)\n                    .desc(\n                            \"Run in interactive mode. Overrides, if applicable, the CI environment variable and --non-interactive/--batch-mode options\")\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_USER_SETTINGS)\n                    .longOpt(\"settings\")\n                    .desc(\"Alternate path for the user settings file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_PROJECT_SETTINGS)\n                    .longOpt(\"project-settings\")\n                    .desc(\"Alternate path for the project settings file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_INSTALLATION_SETTINGS)\n                    .longOpt(\"install-settings\")\n                    .desc(\"Alternate path for the installation settings file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_USER_TOOLCHAINS)\n                    .longOpt(\"toolchains\")\n                    .desc(\"Alternate path for the user toolchains file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_INSTALLATION_TOOLCHAINS)\n                    .longOpt(\"install-toolchains\")\n                    .desc(\"Alternate path for the installation toolchains file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(FAIL_ON_SEVERITY)\n                    .longOpt(\"fail-on-severity\")\n                    .desc(\"Configure which severity of logging should cause the build to fail\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(LOG_FILE)\n                    .longOpt(\"log-file\")\n                    .hasArg()\n                    .desc(\"Log file where all build output will go (disables output color)\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(RAW_STREAMS)\n                    .desc(\"Do not decorate standard output and error streams\")\n                    .build());\n            options.addOption(Option.builder(SHOW_VERSION)\n                    .longOpt(\"show-version\")\n                    .desc(\"Display version information WITHOUT stopping build\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(COLOR)\n                    .hasArg()\n                    .optionalArg(true)\n                    .desc(\"Defines the color mode of the output. Supported are 'auto', 'always', 'never'.\")\n                    .build());\n            options.addOption(Option.builder(OFFLINE)\n                    .longOpt(\"offline\")\n                    .desc(\"Work offline\")\n                    .build());\n\n            options.addOption(Option.builder()\n                    .longOpt(DEBUG)\n                    .desc(\"Launch the JVM in debug mode (script option).\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(ENC)\n                    .desc(\"Launch the Maven Encryption tool (script option).\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(SHELL)\n                    .desc(\"Launch the Maven Shell tool (script option).\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(YJP)\n                    .desc(\"Launch the JVM with Yourkit profiler (script option).\")\n                    .build());\n\n            options.addOption(Option.builder(ALTERNATE_GLOBAL_SETTINGS)\n                    .longOpt(\"global-settings\")\n                    .desc(\"<deprecated> Alternate path for the global settings file.\")\n                    .hasArg()\n                    .deprecated(DeprecatedAttributes.builder()\n                            .setForRemoval(true)\n                            .setSince(\"4.0.0\")\n                            .setDescription(\"Use -is,--install-settings instead.\")\n                            .get())\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_GLOBAL_TOOLCHAINS)\n                    .longOpt(\"global-toolchains\")\n                    .desc(\"<deprecated> Alternate path for the global toolchains file.\")\n                    .hasArg()\n                    .deprecated(DeprecatedAttributes.builder()\n                            .setForRemoval(true)\n                            .setSince(\"4.0.0\")\n                            .setDescription(\"Use -it,--install-toolchains instead.\")\n                            .get())\n                    .build());\n        }",
        "human_comment": "Parameters handled by script\nDeprecated",
        "model_generated_comment": "Sets the options for the given user property.\n\n@param options the options to add\n@return Options for the specified user property, may be {@code null}."
    },
    {
        "id": 422,
        "code_snippet": "public File get(String groupId, String artifactId, String version) {\n        return pomFiles.get(new CacheKey(groupId, artifactId, version));\n    }",
        "human_comment": "Holds all POM files that are known to the reactor. This allows the project builder to resolve imported POMs from the\nreactor when building another project's effective model.",
        "model_generated_comment": "Sets the groupId of the artifact.\n\n@param groupId The artifactId\n@return The groupId"
    },
    {
        "id": 423,
        "code_snippet": "static void afterMethodsOfAllRulesWereExecuted() {\n\t\tif (!asList(initEvents.get(2), initEvents.get(3), initEvents.get(0), initEvents.get(1)).equals(afterEvents))\n\t\t\tfail();\n\t}",
        "human_comment": "beforeEach methods of rules from methods are run before those from fields but in reverse order",
        "model_generated_comment": "{@link AfterMethodsOfAllRulesWereExecuted()}.\n\n@since 5.4"
    },
    {
        "id": 424,
        "code_snippet": "public Store getStore(StoreScope scope, Namespace namespace) {\n\t\tswitch (scope) {\n\t\t\tcase LAUNCHER_SESSION:\n\t\t\t\treturn launcherStoreFacade.getSessionLevelStore(namespace);\n\t\t\tcase EXECUTION_REQUEST:\n\t\t\t\treturn launcherStoreFacade.getRequestLevelStore(namespace);\n\t\t\tcase EXTENSION_CONTEXT:\n\t\t\t\treturn getStore(namespace);\n\t\t}\n\t\tthrow new JUnitException(\"Unknown StoreScope: \" + scope);\n\t}",
        "human_comment": "TODO [#4246] Use switch expression",
        "model_generated_comment": "Get the {@link StoreScope} from the supplied {@code namespace}.\n\n@param scope the scope to get the store from; never\n{@code null}\n@return the store"
    },
    {
        "id": 425,
        "code_snippet": "public static Transform apply(String name, Expression... args) {\n    return LogicalExpressions.apply(name,\n        CollectionConverters.asScala(Arrays.asList(args)).toSeq());\n  }",
        "human_comment": "Create a logical transform for applying a named transform.\n<p>\nThis transform can represent applying any named transform.\n\n@param name the transform name\n@param args expression arguments to the transform\n@return a logical transform",
        "model_generated_comment": "Apply a Transform to a given expression.\n\n@param name the name of the expression\n@return a Transform that applies the Transform to the given expression"
    },
    {
        "id": 426,
        "code_snippet": "public void updateAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        User updatedUser = new User(USER.getId(), \"new username\", USER.getDate());\n        mDataSource.insertOrUpdateUser(updatedUser);\n\n        User dbUser = mDataSource.getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), \"new username\");\n    }",
        "human_comment": "Given that we have a user in the data source\nWhen we are updating the name of the user\nThe retrieved user has the updated username",
        "model_generated_comment": "Update and update the user.\n\n@param user The user to update."
    },
    {
        "id": 427,
        "code_snippet": "public void getUserName_whenUserSaved() {\n        User user = new User(\"user name\");\n        when(mDataSource.getUser()).thenReturn(Flowable.just(user));\n\n        mViewModel.getUserName()\n                .test()\n                .assertValue(\"user name\");\n    }",
        "human_comment": "Given that the UserDataSource returns a user\nWhen getting the user name\nThe correct user name is emitted",
        "model_generated_comment": "Returns the user name when the user is saved."
    },
    {
        "id": 428,
        "code_snippet": "public ShuffleIndexRecord getIndex(int startReduceId, int endReduceId) {\n    long offset = offsets.get(startReduceId);\n    long nextOffset = offsets.get(endReduceId);\n    return new ShuffleIndexRecord(offset, nextOffset - offset);\n  }",
        "human_comment": "Get index offset for the reducer range of [startReduceId, endReduceId).",
        "model_generated_comment": "Get the index of the Shuffle.\n\n@param startReduceId the start and end of the shuffle.\n@return the index record"
    },
    {
        "id": 429,
        "code_snippet": "void findMethodsDoesNotReturnOverriddenMethods() {\n\t\t\tPredicate<Method> isSpecial = method -> method.isAnnotationPresent(Special.class);\n\n\t\t\t// Search for all @Special methods.\n\t\t\tvar methods = findMethods(SuperclassWithInstanceMethods.class, isSpecial);\n\n\t\t\tassertThat(signaturesOf(methods))//\n\t\t\t\t\t.containsExactlyInAnyOrder(\"specialFoo()\", \"specialFoo(int)\", \"specialFoo(char)\", \"specialBar()\",\n\t\t\t\t\t\t\"specialBaz()\");\n\n\t\t\t// Search for all @Special methods.\n\t\t\tmethods = findMethods(SubclassWithOverriddenInstanceMethods.class, isSpecial);\n\n\t\t\tassertThat(signaturesOf(methods))//\n\t\t\t\t\t.containsExactlyInAnyOrder(\"foo()\", \"specialFoo()\", \"specialFoo(int)\", \"specialBar()\");\n\t\t}",
        "human_comment": "In legacy mode, \"static hiding\" occurs.",
        "model_generated_comment": "Find all @Special methods.\n\n@param method the method to find; never {@code null}\n@return the supplied method"
    },
    {
        "id": 430,
        "code_snippet": "public static boolean isLuhnNumber(UTF8String numberString) {\n    String digits = numberString.toString();\n    // Empty string is not a valid Luhn number.\n    if (digits.isEmpty()) return false;\n    int checkSum = 0;\n    boolean isSecond = false;\n    for (int i = digits.length() - 1; i >= 0; i--) {\n      char ch = digits.charAt(i);\n      if (!Character.isDigit(ch)) return false;\n\n      int digit = Character.getNumericValue(ch);\n      // Double the digit if it's the second digit in the sequence.\n      int doubled = isSecond ? digit * 2 : digit;\n      // Add the two digits of the doubled number to the sum.\n      checkSum += doubled % 10 + doubled / 10;\n      // Toggle the isSecond flag for the next iteration.\n      isSecond = !isSecond;\n    }\n    // Check if the final sum is divisible by 10.\n    return checkSum % 10 == 0;\n  }",
        "human_comment": "Function to check if a given number string is a valid Luhn number\n@param numberString\nthe number string to check\n@return\ntrue if the number string is a valid Luhn number, false otherwise.",
        "model_generated_comment": "Test whether the given string is a Luhn number.\n\n@param numberString the string to check.\n@return true if the string contains the given number."
    },
    {
        "id": 431,
        "code_snippet": "private void addDelegates(InterpreterImpl.Options options) {\n    if (originalGraphHasUnresolvedFlexOp) {\n      Delegate optionalFlexDelegate = maybeCreateFlexDelegate(options.getDelegates());\n      if (optionalFlexDelegate != null) {\n        ownedDelegates.add(optionalFlexDelegate);\n        delegates.add(optionalFlexDelegate);\n      }\n    }\n    addUserProvidedDelegates(options);\n    for (DelegateFactory delegateFactory : options.getDelegateFactories()) {\n      Delegate delegate = delegateFactory.create(RUNTIME_FLAVOR);\n      ownedDelegates.add(delegate);\n      delegates.add(delegate);\n    }\n    if (options.getUseNNAPI()) {\n      NnApiDelegate optionalNnApiDelegate = new NnApiDelegate();\n      ownedDelegates.add(optionalNnApiDelegate);\n      delegates.add(optionalNnApiDelegate);\n    }\n  }",
        "human_comment": "Add all the delegates specified in the options (other than XNNPACK) to this.delegates.\nFirst add the flex delegate if necessary. This ensures the graph is fully resolved before\napplying other delegates.\nNow add the user-supplied delegates.",
        "model_generated_comment": "Add delegates to the {@link InterpreterImpl}.\n\n@param options the options to add delegates."
    },
    {
        "id": 432,
        "code_snippet": "public InMemoryProductRepository() {\n    products.put(\"1\", new Product(\"1\", \"Laptop\", LAPTOP_PRICE));\n    products.put(\"2\", new Product(\"2\", \"Smartphone\", SMARTPHONE_PRICE));\n  }",
        "human_comment": "Constructs an {@code InMemoryProductRepository} and initializes it with some example products.",
        "model_generated_comment": "Creates a new {@link InMemoryProductRepository}.\n\n@param products The {@code InMemory ProductRepository} to create.\n@return a new repository containing the {@codes InMemory} products."
    },
    {
        "id": 433,
        "code_snippet": "public static boolean consumerPom(@Nullable Map<String, String> userProperties, boolean def) {\n        return doGet(userProperties, Constants.MAVEN_CONSUMER_POM, def);\n    }",
        "human_comment": "Check if the consumer POM feature is active.",
        "model_generated_comment": "Returns a boolean value for the supplied user properties.\n\n@param userProperties The user properties\n@return the boolean value"
    },
    {
        "id": 434,
        "code_snippet": "public static Queen createFlirtyQueen() {\n    var queen = new Queen();\n    queen.setFlirtiness(true);\n    return queen;\n  }",
        "human_comment": "Method to create a flirty queen.\n\n@return A flirty {@link com.iluwatar.objectmother.Queen}.",
        "model_generated_comment": "Creates a flirty queen.\n\n@param queen the queen to create."
    },
    {
        "id": 435,
        "code_snippet": "public double calculateTotal(final String userId) {\n    return userCarts.getOrDefault(userId, new ArrayList<>()).stream()\n        .mapToDouble(Cart::getTotalPrice)\n        .sum();\n  }",
        "human_comment": "Calculates the total price of items in the user's cart.\n\n@param userId The ID of the user.\n@return The total price of the cart.",
        "model_generated_comment": "Calculates the total price of the user's cart.\n\n@param userId The user ID\n@return The total price"
    },
    {
        "id": 436,
        "code_snippet": "public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof DefaultSourceRoot other) {\n            return directory.equals(other.directory)\n                    && includes.equals(other.includes)\n                    && excludes.equals(other.excludes)\n                    && Objects.equals(scope, other.scope)\n                    && Objects.equals(language, other.language)\n                    && Objects.equals(moduleName, other.moduleName)\n                    && Objects.equals(targetVersion, other.targetVersion)\n                    && stringFiltering == other.stringFiltering\n                    && enabled == other.enabled;\n        }\n        return false;\n    }",
        "human_comment": "{@return whether the two objects are of the same class with equal property values}.\n\n@param obj the other object to compare with this object, or {@code null}",
        "model_generated_comment": "equals the given object.\n\n@param obj The object to check, may be {@code null}.\n@return true"
    },
    {
        "id": 437,
        "code_snippet": "static TableChange removeProperty(String property) {\n    return new RemoveProperty(property);\n  }",
        "human_comment": "Create a TableChange for removing a table property.\n<p>\nIf the property does not exist, the change will succeed.\n\n@param property the property name\n@return a TableChange for the addition",
        "model_generated_comment": "Remove a property from the table.\n\n@param property The property to remove."
    },
    {
        "id": 438,
        "code_snippet": "void execution() {\n\t\tLauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()\n\t\t\t.selectors(\n\t\t\t\tselectPackage(\"com.example.mytests\"),\n\t\t\t\tselectClass(MyTestClass.class)\n\t\t\t)\n\t\t\t.filters(\n\t\t\t\tincludeClassNamePatterns(\".*Tests\")\n\t\t\t)\n\t\t\t.configurationParameter(\"enableHttpServer\", \"false\")\n\t\t\t.build();\n\n\t\tSummaryGeneratingListener listener = new SummaryGeneratingListener();\n\n\t\ttry (LauncherSession session = LauncherFactory.openSession()) {\n\t\t\tLauncher launcher = session.getLauncher();\n\t\t\tlauncher.registerTestExecutionListeners(listener);\n\t\t\tTestPlan testPlan = launcher.discover(request);\n\t\t\tlauncher.execute(testPlan);\n\t\t\tlauncher.execute(request);\n\t\t}\n\n\t\tTestExecutionSummary summary = listener.getSummary();\n\n\t}",
        "human_comment": "@formatter:off\ntag::execution[]\nend::execution[]\ntag::execution[]\nRegister a listener of your choice\nDiscover tests and build a test plan\nExecute test plan\nAlternatively, execute the request directly\nDo something with the summary...\nend::execution[]\n@formatter:on",
        "model_generated_comment": "Unit tests for {@link LauncherDiscoveryRequestBuilder}.\n\n@since 5.0"
    },
    {
        "id": 439,
        "code_snippet": "default boolean isPartiallyPushed() { return true; }\n}",
        "human_comment": "Whether the LIMIT is partially pushed or not. If it returns true, then Spark will do LIMIT\nagain. This method will only be called when {@link #pushLimit} returns true.",
        "model_generated_comment": "{@link boolean isPartiallyPushed()}.\n\n@param true the boolean to check; never {@code null}"
    },
    {
        "id": 440,
        "code_snippet": "public MavenITmng3723ConcreteParentProjectTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
        "human_comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3723\">MNG-3723</a>.\n\nTests that the parent MavenProject instance of the current project has been\ntransitioned into a concrete state before a mojo is executed. If this is true,\nthen injecting ${project} into the mojo and traversing to project.getParent().getBasedir()\nshould retrieve a File instance that is interpolated and exists (since we're\ngoing to be using a parent-child project set in the projects directory).\n\n@author jdcasey",
        "model_generated_comment": "MNG-3723ConcreteParentProjectTest"
    },
    {
        "id": 441,
        "code_snippet": "void validate(TestEngine testEngine, TestDescriptor root) {\n\t\tPreconditions.notNull(root,\n\t\t\t() -> String.format(\n\t\t\t\t\"The discover() method for TestEngine with ID '%s' must return a non-null root TestDescriptor.\",\n\t\t\t\ttestEngine.getId()));\n\t\tOptional<String> cyclicGraphInfo = getCyclicGraphInfo(root);\n\t\tPreconditions.condition(!cyclicGraphInfo.isPresent(),\n\t\t\t() -> String.format(\"The discover() method for TestEngine with ID '%s' returned a cyclic graph; %s\",\n\t\t\t\ttestEngine.getId(), cyclicGraphInfo.get()));\n\t}",
        "human_comment": "Perform common validation checks.\n\n@throws org.junit.platform.commons.PreconditionViolationException if any check fails",
        "model_generated_comment": "Unit tests for {@link TestDescriptor}.\n\n@since 5.0"
    },
    {
        "id": 442,
        "code_snippet": "final AppExecutors executors) {\n        return Room.databaseBuilder(appContext, AppDatabase.class, DATABASE_NAME)\n                .addCallback(new Callback() {\n                    }\n                })",
        "human_comment": "Build the database. {@link Builder#build()} only sets up the database configuration and\ncreates a new instance of the database.\nThe SQLite database is only created when it's accessed for the first time.",
        "model_generated_comment": "Creates a new {@link AppExecutors}.\n\n@param executors the executors\n@return {@code AppExecutor}"
    },
    {
        "id": 443,
        "code_snippet": "static String findJarsDir(String sparkHome, String scalaVersion, boolean failIfNotFound) {\n    // TODO: change to the correct directory once the assembly build is changed.\n    File libdir = new File(sparkHome, \"jars\");\n    if (!libdir.isDirectory()) {\n      libdir = new File(sparkHome, String.format(\"assembly/target/scala-%s/jars\", scalaVersion));\n      if (!libdir.isDirectory()) {\n        checkState(!failIfNotFound,\n          \"Library directory '%s' does not exist; make sure Spark is built.\",\n          libdir.getAbsolutePath());\n        return null;\n      }\n    }\n    return libdir.getAbsolutePath();\n  }",
        "human_comment": "Find the location of the Spark jars dir, depending on whether we're looking at a build\nor a distribution directory.",
        "model_generated_comment": "Find the Jars directory.\n\n@param sparkHome The spark home, may be {@code null}."
    },
    {
        "id": 444,
        "code_snippet": "public T setMaster(String master) {\n    checkNotNull(master, \"master\");\n    builder.master = master;\n    return self();\n  }",
        "human_comment": "Set the Spark master for the application.\n\n@param master Spark master.\n@return This launcher.",
        "model_generated_comment": "Set the master of the builder.\n\n@param master the builder to set."
    },
    {
        "id": 445,
        "code_snippet": "private SetProperty(String property, String value) {\n      this.property = property;\n      this.value = value;\n    }",
        "human_comment": "A TableChange to set a table property.\n<p>\nIf the property already exists, it must be replaced with the new value.",
        "model_generated_comment": "Set the value of the property.\n\n@param property the property to set."
    },
    {
        "id": 446,
        "code_snippet": "public static OrcColumnStatistics readStatistics(Reader orcReader) {\n    TypeDescription orcSchema = orcReader.getSchema();\n    ColumnStatistics[] orcStatistics = orcReader.getStatistics();\n    StructType sparkSchema = OrcUtils.toCatalystSchema(orcSchema);\n    return convertStatistics(sparkSchema, new LinkedList<>(Arrays.asList(orcStatistics)));\n  }",
        "human_comment": "Read the columns statistics from ORC file footer.\n\n@param orcReader the reader to read ORC file footer.\n@return Statistics for all columns in the file.",
        "model_generated_comment": "Read statistics from an OrcReader.\n\n@param orcReader The OrcReader to read statistics from.\n@return OrcStatistics"
    },
    {
        "id": 447,
        "code_snippet": "default boolean mayReturnZeroTestTemplateInvocationContexts(ExtensionContext context) {\n\t\treturn false;\n\t}",
        "human_comment": "Signal that this provider may provide zero\n{@linkplain TestTemplateInvocationContext invocation contexts} for the test\ntemplate method represented by the supplied {@code context}.\n\n<p>If this method returns {@code false} (which is the default) and the\nprovider returns an empty stream from\n{@link #provideTestTemplateInvocationContexts}, this will be considered\nan execution error. Override this method to return {@code true} to ignore\nthe absence of invocation contexts for this provider.\n\n@param context the extension context for the test template method about\nto be invoked; never {@code null}\n@return {@code true} to allow zero contexts, {@code false} to fail\nexecution in case of zero contexts\n\n@since 5.12",
        "model_generated_comment": "Create a new {@link #returnZeroTestTemplateInvocationContexts(ExtensionContext context)}.\n\n@param context the context to return; never {@code null}"
    },
    {
        "id": 448,
        "code_snippet": "void beforeAllAndAfterAllAsMetaAnnotations() {\n\t\texecuteTestsForClass(TestCase.class).testEvents().assertStatistics(stats -> stats.started(1).succeeded(1));\n\n\t\tassertThat(methodsInvoked).containsExactly(\"beforeAll\", \"test\", \"afterAll\");\n\t}",
        "human_comment": "Integration tests that verify support for {@link BeforeAll} and {@link AfterAll}\nwhen used as meta-annotations in the {@link JupiterTestEngine}.\n\n@since 5.0\n@see BeforeEachAndAfterEachComposedAnnotationTests",
        "model_generated_comment": "{@link BeforeAllAndAfterAllAsMetaAnnotations()}.\n\n@since 5.4"
    },
    {
        "id": 449,
        "code_snippet": "public static void assertEquals(char expected, Character actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals((Character) expected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "<em>Assert</em> that two characters are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@since 5.4"
    },
    {
        "id": 450,
        "code_snippet": "protected SettingsReader newSettingsReader() {\n        return new DefaultSettingsReader();\n    }",
        "human_comment": "A factory to create settings builder instances when no dependency injection is available. <em>Note:</em> This class\nis only meant as a utility for developers that want to employ the settings builder outside of the Maven build system,\nMaven plugins should always acquire settings builder instances via dependency injection. Developers might want to\nsubclass this factory to provide custom implementations for some of the components used by the settings builder.\n\n@deprecated since 4.0.0, use {@link org.apache.maven.api.services.SettingsBuilder} instead",
        "model_generated_comment": "Creates a new {@link SettingsReader} for the specified settings.\n\n@param settingsReader the {@code DefaultSettingsReader}\n@return a new SettingsReader"
    },
    {
        "id": 451,
        "code_snippet": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaCorrelationsExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    JavaDoubleRDD seriesX = jsc.parallelizeDoubles(\n      Arrays.asList(1.0, 2.0, 3.0, 3.0, 5.0));  // a series\n\n    JavaDoubleRDD seriesY = jsc.parallelizeDoubles(\n      Arrays.asList(11.0, 22.0, 33.0, 33.0, 555.0));\n\n    double correlation = Statistics.corr(seriesX.srdd(), seriesY.srdd(), \"pearson\");\n    System.out.println(\"Correlation is: \" + correlation);\n\n    JavaRDD<Vector> data = jsc.parallelize(\n      Arrays.asList(\n        Vectors.dense(1.0, 10.0, 100.0),\n        Vectors.dense(2.0, 20.0, 200.0),\n        Vectors.dense(5.0, 33.0, 366.0)\n      )\n    );\n\n    Matrix correlMatrix = Statistics.corr(data.rdd(), \"pearson\");\n    System.out.println(correlMatrix.toString());\n\n    jsc.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nmust have the same number of partitions and cardinality as seriesX\ncompute the correlation using Pearson's method. Enter \"spearman\" for Spearman's method.\nIf a method is not specified, Pearson's method will be used by default.\nnote that each Vector is a row and not a column\ncalculate the correlation matrix using Pearson's method.\nUse \"spearman\" for Spearman's method.\nIf a method is not specified, Pearson's method will be used by default.\n$example off$",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 452,
        "code_snippet": "default Map<String, String> properties() {\n    return Collections.emptyMap();\n  }",
        "human_comment": "Returns the string map of table properties.",
        "model_generated_comment": "Returns a Map of properties.\n\n@param properties The properties of the properties."
    },
    {
        "id": 453,
        "code_snippet": "public static Condition<Throwable> rootCause(Condition<Throwable>... conditions) {\n\t\tList<Condition<Throwable>> list = Arrays.stream(conditions)//\n\t\t\t\t.map(TestExecutionResultConditions::rootCause)//\n\t\t\t\t.collect(toList());\n\n\t\treturn Assertions.allOf(list);\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if a\nall supplied conditions.\n\n@since 1.11\n@see #cause(Condition...)\n@see #suppressed(int, Condition...)",
        "model_generated_comment": "Create a new {@link Condition} with the supplied conditions.\n\n@param conditions the conditions to create the new condition; never {@code null}\n@return the new Condition"
    },
    {
        "id": 454,
        "code_snippet": "public synchronized void start() {\n    int i = 0;\n    try {\n      for (int n = serviceList.size(); i < n; i++) {\n        Service service = serviceList.get(i);\n        service.start();\n      }\n      super.start();\n    } catch (Throwable e) {\n      LOG.error(\"Error starting services {}\", e, MDC.of(LogKeys.SERVICE_NAME$.MODULE$, getName()));\n      stop(i);\n      throw new ServiceException(\"Failed to Start \" + getName(), e);\n    }\n\n  }",
        "human_comment": "Note that the state of the failed service is still INITED and not\nSTARTED. Even though the last service is not started completely, still\ncall stop() on all services including failed service to make sure cleanup\nhappens.",
        "model_generated_comment": "Starts a service with the given name.\n\n@param i the name of the service, may be {@code null}.\n@throws ServiceException if the name is null."
    },
    {
        "id": 455,
        "code_snippet": "public static void assertTimeout(Duration timeout, Executable executable, Supplier<String> messageSupplier) {\n\t\tAssertTimeout.assertTimeout(timeout, executable, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that execution of the supplied {@code executable}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>Note: the {@code executable} will be executed in the same thread as that\nof the calling code. Consequently, execution of the {@code executable} will\nnot be preemptively aborted if the timeout is exceeded.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@see #assertTimeout(Duration, Executable)\n@see #assertTimeout(Duration, Executable, String)\n@see #assertTimeout(Duration, ThrowingSupplier)\n@see #assertTimeout(Duration, ThrowingSupplier, String)\n@see #assertTimeout(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeoutPreemptively(Duration, Executable, Supplier)",
        "model_generated_comment": "<em>Assert</em> that the {@code Executable} is running at the specified time.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@link Executable}.\n\n@since 5.4"
    },
    {
        "id": 456,
        "code_snippet": "public List<Lifecycle> getLifeCycles() {\n        List<String> lifecycleIds = Arrays.asList(STANDARD_LIFECYCLES);\n\n        Comparator<String> comparator = (l, r) -> {\n            int lx = lifecycleIds.indexOf(l);\n            int rx = lifecycleIds.indexOf(r);\n\n            if (lx < 0 || rx < 0) {\n                return rx - lx;\n            } else {\n                return lx - rx;\n            }\n        };\n\n        Map<String, Lifecycle> lifecyclesMap = lookupLifecycles();\n\n        // ensure canonical order of standard lifecycles\n        return lifecyclesMap.values().stream()\n                .peek(l -> Objects.requireNonNull(l.getId(), \"A lifecycle must have an id.\"))\n                .sorted(Comparator.comparing(Lifecycle::getId, comparator))\n                .collect(Collectors.toList());\n    }",
        "human_comment": "Returns an ordered list of lifecycles",
        "model_generated_comment": "Get lifecycles from the lifecycle.\n\n@param lifecycleIds The lifecycle id, must not be <code>null</code>.\n@return lifecycle"
    },
    {
        "id": 457,
        "code_snippet": "default boolean shouldLogError(Throwable t) {\n    return true;\n  }",
        "human_comment": "Plugs into {@link RetryingBlockTransferor} to further control when an exception should be retried\nand logged.\nNote: {@link RetryingBlockTransferor} will delegate the exception to this handler only when\n- remaining retries  &lt; max retries\n- exception is an IOException\n\n@since 3.1.0",
        "model_generated_comment": "Returns true if a throwable isLogError."
    },
    {
        "id": 458,
        "code_snippet": "public ColumnVector column(int ordinal) { return columns[ordinal]; }",
        "human_comment": "Returns the column at `ordinal`.",
        "model_generated_comment": "Returns a column vector with the given ordinal value.\n\n@param ordinal the column vector to return; never {@code null}"
    },
    {
        "id": 459,
        "code_snippet": "private List<String> findReadOnlyWarning(List<String> logLines) {\n        Pattern pattern = Pattern.compile(\".* Parameter .* is read-only.*\");\n        List<String> result = new ArrayList<>();\n        for (String line : logLines) {\n            if (pattern.matcher(line).matches()) {\n                result.add(line);\n            }\n        }\n        return result;\n    }",
        "human_comment": "Test that ensures that warning is printed for read-only parameter set by plugin configuration.",
        "model_generated_comment": "Find the read-only warning for the given line.\n\n@param logLines the log line to check."
    },
    {
        "id": 460,
        "code_snippet": "public static boolean arraysSame(int[] a1, int[] a2) {\n    // compares if 2 arrays have the same value\n    if (a1.length != a2.length) {\n      return false;\n    } else {\n      var answer = false;\n      for (var i = 0; i < a1.length; i++) {\n        if (a1[i] == a2[i]) {\n          answer = true;\n        } else {\n          answer = false;\n          break;\n        }\n      }\n      return answer;\n    }\n  }",
        "human_comment": "Method arraysSame compares 2 arrays @param a1 and @param a2 and @return whether their values\nare equal (boolean).",
        "model_generated_comment": "Returns true if two arrays have the same value.\n\n@param a1 The array to compare, must not be <code>null</code>."
    },
    {
        "id": 461,
        "code_snippet": "void testSystemTimeAlignment() {\n        Instant monotonic = MonotonicClock.now();\n        Instant system = Instant.now();\n\n        Duration difference = Duration.between(monotonic, system).abs();\n        assertTrue(difference.getSeconds() <= 1, \"Monotonic time should be reasonably aligned with system time\");\n    }",
        "human_comment": "The difference should be relatively small (allow for 1 second max)",
        "model_generated_comment": "Test whether monotonic time is aligned with system time."
    },
    {
        "id": 462,
        "code_snippet": "public boolean hasMetadataResolutionExceptions() {\n        return metadataResolutionExceptions != null;\n    }",
        "human_comment": "------------------------------------------------------------------------\nMetadata Resolution Exceptions: ArtifactResolutionExceptions\n------------------------------------------------------------------------",
        "model_generated_comment": "Returns a boolean that matches if and only if the given exception is null.\n\n@param metadataResolutionExceptions the exception to check"
    },
    {
        "id": 463,
        "code_snippet": "void whenHealthCheckThrowsException_thenReturnsDown() {\n    // Arrange\n    Supplier<Health> healthSupplier =\n        () -> {\n          throw new RuntimeException(\"Health check failed\");\n        };\n    // Act\n    CompletableFuture<Health> healthFuture = healthChecker.performCheck(healthSupplier, 10);\n    // Assert\n    Health health = healthFuture.join();\n    assertEquals(Status.DOWN, health.getStatus());\n    String errorMessage = health.getDetails().get(\"error\").toString();\n    assertTrue(errorMessage.contains(\"Health check failed\"));\n  }",
        "human_comment": "Tests that the {@link performCheck()} method returns a healthy health status when the health\nsupplier returns a healthy status.\n\n<p>Given a health supplier that throws a RuntimeException, the test verifies that the {@link\nperformCheck()} method returns a health object with a status of DOWN and an error message\ncontaining the exception message.",
        "model_generated_comment": "Asserts that when the health check throws an exception, it returns down."
    },
    {
        "id": 464,
        "code_snippet": "public SaslClientBootstrap(TransportConf conf, String appId, SecretKeyHolder secretKeyHolder) {\n    this.conf = conf;\n    this.appId = appId;\n    this.secretKeyHolder = secretKeyHolder;\n  }",
        "human_comment": "Bootstraps a {@link TransportClient} by performing SASL authentication on the connection. The\nserver should be setup with a {@link SaslRpcHandler} with matching keys for the given appId.",
        "model_generated_comment": "Creates a new {@link SaslClientBootstrap} with the supplied {@code conf} and the\n{@link SecretKeyHolder}.\n\n@param conf the conf to bootstrap from\n@return a new bootstrap"
    },
    {
        "id": 465,
        "code_snippet": "public static IterationSelector selectIteration(DiscoverySelector parentSelector, int... iterationIndices) {\n\t\tPreconditions.notNull(parentSelector, \"Parent selector must not be null\");\n\t\tPreconditions.notEmpty(iterationIndices, \"iteration indices must not be empty\");\n\t\treturn new IterationSelector(parentSelector, iterationIndices);\n\t}",
        "human_comment": "Create an {@code IterationSelector} for the supplied parent selector and\niteration indices.\n\n@param parentSelector the parent selector to select iterations for; never\n{@code null}\n@param iterationIndices the iteration indices to select; never {@code null}\nor empty\n@since 1.9\n@see IterationSelector",
        "model_generated_comment": "Create a new {@link IterationSelector}.\n\n@param parentSelector the selector to select; never {@code null} or blank\n@return a new selector"
    },
    {
        "id": 466,
        "code_snippet": "private byte[] makeValidBytes() {\n    assert(numBytesValid > 0);\n    byte[] bytes = new byte[numBytesValid];\n    int byteIndex = 0, byteIndexValid = 0;\n    while (byteIndex < numBytes) {\n      // Read the first byte.\n      byte firstByte = getByte(byteIndex);\n      int expectedLen = bytesOfCodePointInUTF8[firstByte & 0xFF];\n      int codePointLen = Math.min(expectedLen, numBytes - byteIndex);\n      // 0B UTF-8 sequence (invalid first byte).\n      if (codePointLen == 0) {\n        insertReplacementCharacter(bytes, byteIndexValid);\n        byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        ++byteIndex;\n        continue;\n      }\n      // 1B UTF-8 sequence (ASCII or truncated).\n      if (codePointLen == 1) {\n        if (firstByte >= 0) {\n          bytes[byteIndexValid++] = firstByte;\n        }\n        else {\n          insertReplacementCharacter(bytes, byteIndexValid);\n          byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        }\n        ++byteIndex;\n        continue;\n      }\n      // Read the second byte.\n      byte secondByte = getByte(byteIndex + 1);\n      if (!isValidSecondByte(secondByte, firstByte)) {\n        insertReplacementCharacter(bytes, byteIndexValid);\n        byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        ++byteIndex;\n        continue;\n      }\n      // Read remaining continuation bytes.\n      int continuationBytes = 2;\n      for (; continuationBytes < codePointLen; ++continuationBytes) {\n        byte nextByte = getByte(byteIndex + continuationBytes);\n        if (!isValidContinuationByte(nextByte)) {\n          break;\n        }\n      }\n      // Invalid UTF-8 sequence (not enough continuation bytes).\n      if (continuationBytes < expectedLen) {\n        insertReplacementCharacter(bytes, byteIndexValid);\n        byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        byteIndex += continuationBytes;\n        continue;\n      }\n      // Valid UTF-8 sequence.\n      for (int i = 0; i < codePointLen; ++i) {\n        bytes[byteIndexValid++] = getByte(byteIndex + i);\n      }\n      byteIndex += codePointLen;\n    }\n    return bytes;\n  }",
        "human_comment": "Private helper method to create a valid UTF-8 byte sequence from the current UTF8String.\nIn order to use this method, the number of bytes of the validated version of the current\nstring (after possible replacement) must be evaluated first by calling `getIsValid`.",
        "model_generated_comment": "Make valid bytes from the first byte.\n\n@param numBytesValid the valid first byte\n@return valid byte"
    },
    {
        "id": 467,
        "code_snippet": "public DefaultSourceRoot(final Session session, final Path baseDir, final Source source) {\n        includes = source.getIncludes();\n        excludes = source.getExcludes();\n        stringFiltering = source.isStringFiltering();\n        enabled = source.isEnabled();\n        moduleName = nonBlank(source.getModule());\n\n        String value = nonBlank(source.getScope());\n        scope = (value != null) ? session.requireProjectScope(value) : ProjectScope.MAIN;\n\n        value = nonBlank(source.getLang());\n        language = (value != null) ? session.requireLanguage(value) : Language.JAVA_FAMILY;\n\n        value = nonBlank(source.getDirectory());\n        if (value != null) {\n            directory = baseDir.resolve(value);\n        } else {\n            directory = baseDir.resolve(\"src\").resolve(scope.id()).resolve(language.id());\n        }\n\n        value = nonBlank(source.getTargetVersion());\n        targetVersion = (value != null) ? session.parseVersion(value) : null;\n\n        value = nonBlank(source.getTargetPath());\n        targetPath = (value != null) ? baseDir.resolve(value) : null;\n    }",
        "human_comment": "Creates a new instance from the given model.\n\n@param session the session of resolving extensible enumerations\n@param baseDir the base directory for resolving relative paths\n@param source a source element from the model",
        "model_generated_comment": "Creates a new {@link DefaultSourceRoot} for the specified source.\n\n@param session the session to use, may be {@code null}."
    },
    {
        "id": 468,
        "code_snippet": "public static File getTestFile(String path) {\n        return new File(getBasedir(), path);\n    }",
        "human_comment": "Creates a File object for a path relative to the base directory.\n\n@param path The relative path\n@return A File object representing the path",
        "model_generated_comment": "Get a test file from the given directory.\n\n@param path The path to get the test file.\n@return The test file"
    },
    {
        "id": 469,
        "code_snippet": "public EagerOperationBuilder setAttr(String name, Tensor<?>[] values) {\n    throw new UnsupportedOperationException(\n        \"Tensor list attributes are not supported in eager mode\");\n  }",
        "human_comment": "TODO (karllessard) could be supported by adding this attribute type in the eager C API",
        "model_generated_comment": "Set the Attr for the supplied operation.\n\n@param name the name of the operation\n@throws UnsupportedOperationException if the operation is not supported in eager mode."
    },
    {
        "id": 470,
        "code_snippet": "void closeIterator(RocksIterator it) {\n    notifyIteratorClosed(it);\n    synchronized (this._db) {\n      org.rocksdb.RocksDB _db = this._db.get();\n      if (_db != null) {\n        it.close();\n      }\n    }\n  }",
        "human_comment": "Closes the given iterator if the DB is still open. Trying to close a JNI RocksDB handle\nwith a closed DB can cause JVM crashes, so this ensures that situation does not happen.",
        "model_generated_comment": "Close the iterator.\n\n@param it the iterator to close."
    },
    {
        "id": 471,
        "code_snippet": "public static NestedClassSelector selectNestedClass(List<Class<?>> enclosingClasses, Class<?> nestedClass) {\n\t\tPreconditions.notEmpty(enclosingClasses, \"Enclosing classes must not be null or empty\");\n\t\tPreconditions.notNull(nestedClass, \"Nested class must not be null\");\n\t\treturn new NestedClassSelector(enclosingClasses, nestedClass);\n\t}",
        "human_comment": "Create a {@code NestedClassSelector} for the supplied nested {@link Class} and its\nenclosing classes.\n\n@param enclosingClasses the path to the nested class to select; never {@code null} or empty\n@param nestedClass the nested class to select; never {@code null}\n@since 1.6\n@see NestedClassSelector",
        "model_generated_comment": "Create a new {@link NestedClassSelector} for the supplied {@code enclosingClasses}.\n\n@since 5.4"
    },
    {
        "id": 472,
        "code_snippet": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaSummaryStatisticsExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    JavaRDD<Vector> mat = jsc.parallelize(\n      Arrays.asList(\n        Vectors.dense(1.0, 10.0, 100.0),\n        Vectors.dense(2.0, 20.0, 200.0),\n        Vectors.dense(3.0, 30.0, 300.0)\n      )\n    ); // an RDD of Vectors\n\n    MultivariateStatisticalSummary summary = Statistics.colStats(mat.rdd());\n    System.out.println(summary.mean());  // a dense vector containing the mean value for each column\n    System.out.println(summary.variance());  // column-wise variance\n    System.out.println(summary.numNonzeros());  // number of nonzeros in each column\n\n    jsc.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nCompute column summary statistics.\n$example off$",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 473,
        "code_snippet": "public static void main(String[] args) {\n\n    if (args.length < 2) {\n      System.err.println(\"Usage: JavaHdfsLR <file> <iters>\");\n      System.exit(1);\n    }\n\n    showWarning();\n\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaHdfsLR\")\n      .getOrCreate();\n\n    JavaRDD<String> lines = spark.read().textFile(args[0]).javaRDD();\n    JavaRDD<DataPoint> points = lines.map(new ParsePoint()).cache();\n    int ITERATIONS = Integer.parseInt(args[1]);\n\n    double[] w = new double[D];\n    for (int i = 0; i < D; i++) {\n      w[i] = 2 * rand.nextDouble() - 1;\n    }\n\n    System.out.print(\"Initial w: \");\n    printWeights(w);\n\n    for (int i = 1; i <= ITERATIONS; i++) {\n      System.out.println(\"On iteration \" + i);\n\n      double[] gradient = points.map(\n        new ComputeGradient(w)\n      ).reduce(new VectorSum());\n\n      for (int j = 0; j < D; j++) {\n        w[j] -= gradient[j];\n      }\n\n    }\n\n    System.out.print(\"Final w: \");\n    printWeights(w);\n    spark.stop();\n  }",
        "human_comment": "Initialize w to a random value",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 474,
        "code_snippet": "public List<Exception> validateTestClass(TestClass testClass) {\n        List<Exception> validationErrors= new ArrayList<Exception>();\n        for (AnnotatableValidator<?> validator : VALIDATORS) {\n            List<Exception> additionalErrors= validator\n                    .validateTestClass(testClass);\n            validationErrors.addAll(additionalErrors);\n        }\n        return validationErrors;\n    }",
        "human_comment": "Validate all annotations of the specified test class that are be\nannotated with {@link ValidateWith}.\n\n@param testClass\nthe {@link TestClass} that is validated.\n@return the errors found by the validator.",
        "model_generated_comment": "<em>Assert</em> that the test class is valid.\n\n@param testClass The test class to validate, may be {@code null}."
    },
    {
        "id": 475,
        "code_snippet": "public static void assertEquals(float expected, float actual, float delta) {\n        Assert.assertEquals(expected, actual, delta);\n    }",
        "human_comment": "Asserts that two floats are equal concerning a delta. If the expected\nvalue is infinity then the delta value is ignored.",
        "model_generated_comment": "Asserts that two floats are equal. If they are not they are considered equal."
    },
    {
        "id": 476,
        "code_snippet": "public static void assertEquals(byte expected, Byte actual, String message) {\n\t\tAssertEquals.assertEquals((Byte) expected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "<em>Assert</em> that two bytes are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code message}.\n\n@since 5.4"
    },
    {
        "id": 477,
        "code_snippet": "public static DirectorySelector selectDirectory(String path) {\n\t\tPreconditions.notBlank(path, \"Directory path must not be null or blank\");\n\t\treturn new DirectorySelector(path);\n\t}",
        "human_comment": "Create a {@code DirectorySelector} for the supplied directory path.\n\n<p>This method selects the directory using the supplied path <em>as is</em>,\nwithout verifying if the directory exists.\n\n@param path the path to the directory to select; never {@code null} or blank\n@see DirectorySelector\n@see #selectDirectory(File)\n@see #selectFile(String)\n@see #selectFile(File)",
        "model_generated_comment": "Create a new {@link DirectorySelector} based on the supplied path.\n\n@param path the path to select; never {@code null} or blank\n@return a new directorySelector\n@see #selectDirectory(String)"
    },
    {
        "id": 478,
        "code_snippet": "protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        applyValidators(errors);\n    }",
        "human_comment": "Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\nDefault implementation adds an error for each method annotated with\n{@code @BeforeClass} or {@code @AfterClass} that is not\n{@code public static void} with no arguments.",
        "model_generated_comment": "CollectInitializationErrors from the supplied list.\n\n@param errors The list of errors to collect."
    },
    {
        "id": 479,
        "code_snippet": "public ShuffleIndexRecord getIndex(int reduceId) {\n    return getIndex(reduceId, reduceId + 1);\n  }",
        "human_comment": "Get index offset for a particular reducer.",
        "model_generated_comment": "Get the index of the shuffle.\n\n@param reduceId the reduceId to get the index."
    },
    {
        "id": 480,
        "code_snippet": "public void runSuite() {\n        // Targeting Test:\n        Result testResult= JUnitCore.runClasses(MultiCategorySuite.class);\n\n        assertThat(\"unexpected run count\", testResult.getRunCount(), is(equalTo(2)));\n        assertThat(\"unexpected failure count\", testResult.getFailureCount(), is(equalTo(0)));\n        assertThat(\"unexpected failure count\", testResult.getIgnoreCount(), is(equalTo(0)));\n    }",
        "human_comment": "This test is mentioned in {@code Categories} and any changes\nmust be reflected.",
        "model_generated_comment": "Runs a multi-Category suite.\n\n@param runSuite the suite to run\n@return a {@link #runSuite}"
    },
    {
        "id": 481,
        "code_snippet": "private int getNumChars() {\n    int len = 0;\n    for (int i = 0; i < numBytes; i += numBytesForFirstByte(getByte(i))) {\n      len += 1;\n    }\n    return len;\n  }",
        "human_comment": "Private helper method to calculate the number of code points in the UTF-8 string. Counting\nthe code points is a linear time operation, as we need to scan the entire UTF-8 string.\nHence, this method should generally only be called once for non-empty UTF-8 strings.",
        "model_generated_comment": "Gets the number of bytes in the first byte.\n\n@param len The number of bits in the second byte."
    },
    {
        "id": 482,
        "code_snippet": "public VideoStreamingService getBusinessService(String movie) {\n    if (movie.toLowerCase(Locale.ROOT).contains(\"die hard\")) {\n      return netflixService;\n    } else {\n      return youTubeService;\n    }\n  }",
        "human_comment": "Gets service instance based on given movie search string.\n\n@param movie Search string for the movie.\n@return Service instance.",
        "model_generated_comment": "Returns the BusinessService for the supplied movie.\n\n@param movie The movie to stream.\n@return BusinessService"
    },
    {
        "id": 483,
        "code_snippet": "public void setArray(ColumnarArray value) {\n    arrayData = value;\n  }",
        "human_comment": "Sets the `ColumnarArray` `value` for all rows",
        "model_generated_comment": "Sets the value of the array.\n\n@param value the value to set."
    },
    {
        "id": 484,
        "code_snippet": "private void showToast(final String text) {\n    final Activity activity = getActivity();\n    if (activity != null) {\n      activity.runOnUiThread(\n          new Runnable() {\n          });\n    }\n  }",
        "human_comment": "Shows a {@link Toast} on the UI thread.\n\n@param text The message to show",
        "model_generated_comment": "This is a test set for {@link Runnable#getActivity()}.\n\n@param text the text to show to the test set\n@return The test set"
    },
    {
        "id": 485,
        "code_snippet": "public void selfSpillIsLowestPriorities() {\n    final TestMemoryManager memoryManager = new TestMemoryManager(new SparkConf());\n    memoryManager.limit(100);\n    final TaskMemoryManager manager = new TaskMemoryManager(memoryManager, 0);\n\n    TestMemoryConsumer c1 = new TestMemoryConsumer(manager);\n    TestMemoryConsumer c2 = new TestMemoryConsumer(manager);\n    TestMemoryConsumer c3 = new TestMemoryConsumer(manager);\n\n    c1.use(50);\n    c2.use(40);\n    c3.use(10);\n    c1.use(50);\n    Assertions.assertEquals(100, c1.getUsed());\n    Assertions.assertEquals(0, c2.getUsed());\n    Assertions.assertEquals(0, c3.getUsed());\n    c1.use(50);\n    Assertions.assertEquals(50, c1.getUsed());\n    c2.use(10);\n    c1.use(60);\n    Assertions.assertEquals(60, c1.getUsed());\n    Assertions.assertEquals(0, c2.getUsed());\n\n    c1.free(c1.getUsed());\n\n    c1.use(50);\n    c2.use(40);\n    c3.use(10);\n    c3.use(50);\n    Assertions.assertEquals(0, c1.getUsed());\n    Assertions.assertEquals(40, c2.getUsed());\n    Assertions.assertEquals(60, c3.getUsed());\n  }",
        "human_comment": "Test that requesting memory consumer (a \"self-spill\") is chosen last to spill.\nSelf-spill is the lowest priority: c2 and c3 are spilled first even though they have less\nmemory.\nForce a self-spill.\nForce a self-spill after c2 is spilled.\nRedo a similar scenario but with a different memory requester.",
        "model_generated_comment": "Self-spill is low.\n\n@param memoryManager the memory manager to use\n@return true"
    },
    {
        "id": 486,
        "code_snippet": "public ModelBuildingException(ModelBuildingResult result) {\n        super(toMessage(result));\n        this.result = result;\n    }",
        "human_comment": "Creates a new exception from the specified interim result and its associated problems.\n\n@param result The interim result, may be {@code null}.",
        "model_generated_comment": "Creates a {@link ModelBuildingException} with the given result.\n\n@param result The result of the {@code ModelBuildingResult}"
    },
    {
        "id": 487,
        "code_snippet": "public MavenProject getTopLevelProject() {\n        return sortedProjects.stream()\n                .filter(MavenProject::isExecutionRoot)\n                .findFirst()\n                .orElse(null);\n    }",
        "human_comment": "TODO !![jc; 28-jul-2005] check this; if we're using '-r' and there are aggregator tasks, this will result in\nweirdness.",
        "model_generated_comment": "Get the top level project of the project.\n\n@param topLevelProject the project to get"
    },
    {
        "id": 488,
        "code_snippet": "void testMissingArtifactMessageFormat() {\n        String message = \"Missing artifact\";\n        String indentation = \"  \";\n        String groupId = \"aGroupId\";\n        String artifactId = \"anArtifactId\";\n        String version = \"aVersion\";\n        String type = \"jar\";\n        String classifier = \"aClassifier\";\n        String downloadUrl = \"http://somewhere.com/download\";\n        List<String> path = Arrays.asList(\"dependency1\", \"dependency2\");\n        String expected = \"Missing artifact\" + LS + LS + \"  Try downloading the file manually from: \" + LS\n                + \"      http://somewhere.com/download\" + LS + LS + \"  Then, install it using the command: \" + LS\n                + \"      mvn install:install-file -DgroupId=aGroupId -DartifactId=anArtifactId -Dversion=aVersion \"\n                + \"-Dclassifier=aClassifier -Dpackaging=jar -Dfile=/path/to/file\" + LS + LS\n                + \"  Alternatively, if you host your own repository you can deploy the file there: \" + LS\n                + \"      mvn deploy:deploy-file -DgroupId=aGroupId -DartifactId=anArtifactId\"\n                + \" -Dversion=aVersion -Dclassifier=aClassifier -Dpackaging=jar -Dfile=/path/to/file\"\n                + \" -Durl=[url] -DrepositoryId=[id]\" + LS + LS + \"  Path to dependency: \" + LS + \"  \\t1) dependency1\"\n                + LS + \"  \\t2) dependency2\" + LS + LS;\n        String actual = AbstractArtifactResolutionException.constructMissingArtifactMessage(\n                message, indentation, groupId, artifactId, version, type, classifier, downloadUrl, path);\n        assertEquals(expected, actual);\n    }",
        "human_comment": "Test the artifact resolution exception message",
        "model_generated_comment": "Tests if the artifact is missing.\n\n@param groupId The groupId of the artifact, may be {@code null}."
    },
    {
        "id": 489,
        "code_snippet": "public static void assertEquals(byte expected, Byte actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals((Byte) expected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and{@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\nsupplied\nsupplier.\n\n@since 5.4"
    },
    {
        "id": 490,
        "code_snippet": "public static void assertEquals(Character expected, Character actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@link Assertion#equals(Object)}\n\n@since 5.4"
    },
    {
        "id": 491,
        "code_snippet": "void testFormatRateEdgeCases() {\n        FileSizeFormat format = new FileSizeFormat();\n\n        MessageBuilder builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 0.0);\n        assertEquals(\"0.0 B/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000.0);\n        assertEquals(\"1.0 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000000.0);\n        assertEquals(\"1.0 MB/s\", builder.build());\n    }",
        "human_comment": "Test zero rate\nTest rate at exactly 1000 (1 kB/s)\nTest rate at exactly 1000000 (1 MB/s)",
        "model_generated_comment": "Unit tests for {@link FormatRateEdgeCases}.\n\n@since 5.0"
    },
    {
        "id": 492,
        "code_snippet": "public void preferNewTestsOverTestsThatFailed() {\n        Request one = Request.method(TwoTests.class, \"dontSucceed\");\n        fMax.run(one);\n        Request two = Request.aClass(TwoTests.class);\n        List<Description> things = fMax.sortedLeavesForTest(two);\n        Description succeed = Description.createTestDescription(TwoTests.class,\n                \"succeed\");\n        assertEquals(succeed, things.get(0));\n        assertEquals(2, things.size());\n    }",
        "human_comment": "This covers a seemingly-unlikely case, where you had a test that failed\non the\nlast run and you also introduced new tests. In such a case it pretty much\ndoesn't matter\nwhich order they run, you just want them both to be early in the sequence",
        "model_generated_comment": "Creates a new list of tests that fail.\n\n@param things the tests that failed\n@return a list of test types"
    },
    {
        "id": 493,
        "code_snippet": "public Requirement clone() {\n        try {\n            return (Requirement) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e);\n        }\n    }",
        "human_comment": "Creates a shallow copy of this requirement.",
        "model_generated_comment": "Creates a new {@link Requirement} with the specified\n{@link #cloneNotSupportedException}.\n\n@param request The {@code Requirement}; must not be <code>null</code>."
    },
    {
        "id": 494,
        "code_snippet": "public static void assertTrue(boolean condition, String message) {\n\t\tAssertTrue.assertTrue(condition, message);\n\t}",
        "human_comment": "<em>Assert</em> that the supplied {@code condition} is {@code true}.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "<em>Assert</em> that {@code condition} is true.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 495,
        "code_snippet": "public Action(GiantModel giant) {\n    this.giant = giant;\n  }",
        "human_comment": "Instantiates a new Action.\n\n@param giant the giant",
        "model_generated_comment": "Creates a new {@link org.apache.maven.Model}.\n\n@param giant The {@code giant} to build."
    },
    {
        "id": 496,
        "code_snippet": "public Try<V> orElse(Supplier<Try<V>> supplier) {\n\t\t\treturn this;\n\t\t}",
        "human_comment": "don't call supplier because this Try is a success",
        "model_generated_comment": "Create a new {@code Try} for the supplied {@link Supplier}.\n\n@param supplier the supplier to use; never\n{@code null}"
    },
    {
        "id": 497,
        "code_snippet": "public String toString() {\n    return new String(getBytes(), StandardCharsets.UTF_8);\n  }",
        "human_comment": "Returns a string representation of this UTF8String object. The string representation consists\nof the string's characters encoded in UTF-8 and the result of this method is always a valid\nUTF-8 string. However, if the current UTF8String contains illegal UTF-8 byte sequences, the\nmethod will replace the illegal byte sequences with the Unicode replacement character U+FFFD,\naccording to Java specification. Using this method with invalid UTF8Strings is NOT RECOMMENDED.",
        "model_generated_comment": "Creates a new String from the supplied UTF-8 string.\n\n@param bytes the string to put into the new String."
    },
    {
        "id": 498,
        "code_snippet": "Stream<CompositeTestSource> createSerializableInstances() {\n\t\tvar fileSource = FileSource.from(new File(\"sample.instance\"));\n\t\tvar classSource = ClassSource.from(getClass());\n\t\tvar sources = List.of(fileSource, classSource);\n\t\treturn Stream.of(CompositeTestSource.from(sources));\n\t}",
        "human_comment": "Unit tests for {@link CompositeTestSource}.\n\n@since 1.0",
        "model_generated_comment": "Create a new {@link CompositeTestSource} using the supplied\n{@link ClassSource}.\n\n@since 5.4"
    },
    {
        "id": 499,
        "code_snippet": "void blankness() {\n\t\t// @formatter:off\n\t\tassertAll(\"Blankness\",\n\t\t\t() -> assertTrue(isBlank(null)),\n\t\t\t() -> assertTrue(isBlank(\"\")),\n\t\t\t() -> assertTrue(isBlank(\" \\t\\n\\r\")),\n\t\t\t() -> assertTrue(isNotBlank(\".\"))\n\t\t);\n\t\t// @formatter:on\n\t}",
        "human_comment": "Unit tests for {@link StringUtils}.\n\n@since 1.0",
        "model_generated_comment": "Unit tests for {@linkplain Blankness}.\n\n@since 5.0"
    },
    {
        "id": 500,
        "code_snippet": "public static Condition<Event> nestedContainer(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(clazz.getEnclosingClass(), () -> clazz.getName() + \" must be a nested class\");\n\n\t\tList<String> classNames = new ArrayList<>();\n\t\tfor (Class<?> current = clazz; current != null; current = current.getEnclosingClass()) {\n\t\t\tclassNames.add(0, current.getSimpleName());\n\t\t}\n\n\t\treturn allOf(container(), uniqueIdSubstrings(classNames));\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if an\na {@linkplain TestDescriptor#isContainer() container} and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the\nsimple names of the supplied {@link Class} and all of its\n{@linkplain Class#getEnclosingClass() enclosing classes}.\n\n<p>Please note that this method does not differentiate between static\nnested classes and non-static member classes (e.g., inner classes).\n\n@see #nestedContainer(Class, Condition)",
        "model_generated_comment": "Create a new {@link Condition} for the supplied container.\n\n@param clazz the container to create; never {@code null}\n@return a new Condition"
    },
    {
        "id": 501,
        "code_snippet": "public void removeCIEnvironmentVariables() {\n        environmentVariables.putAll(Map.of(\n                \"CIRCLECI\", \"\",\n                \"CI\", \"false\",\n                \"GITHUB_ACTIONS\", \"\",\n                \"WORKSPACE\", \"\",\n                \"TEAMCITY_VERSION\", \"\",\n                \"TRAVIS\", \"\"));\n    }",
        "human_comment": "This method renders all env variables that are used for CI detection (by all known detector) to not trigger.",
        "model_generated_comment": "Remove all {@link CI} environment variables.\n\n@param environmentVariables\n@return {@code CI}"
    },
    {
        "id": 502,
        "code_snippet": "public Result run(junit.framework.Test test) {\n        return run(new JUnit38ClassRunner(test));\n    }",
        "human_comment": "Run all the tests contained in JUnit 3.8.x <code>test</code>. Here for backward compatibility.\n\n@param test the old-style test\n@return a {@link Result} describing the details of the test run and the failed tests.",
        "model_generated_comment": "Runs the {@link JUnit38ClassRunner} method.\n\n@param test the test to run\n@return The {@code Result} method"
    },
    {
        "id": 503,
        "code_snippet": "protected void printDefectHeader(TestFailure booBoo, int count) {\n        getWriter().print(count + \") \" + booBoo.failedTest());\n    }",
        "human_comment": "I feel like making this a println, then adding a line giving the throwable a chance to print something\nbefore we get to the stack trace.",
        "model_generated_comment": "Prints the header of the test.\n\n@param booBoo the number of failed tests\n@return the header"
    },
    {
        "id": 504,
        "code_snippet": "public void close() {\n\t\tif (!this.closed) {\n\t\t\ttry {\n\t\t\t\tif (this.closeAction != null) {\n\t\t\t\t\tThrowableCollector throwableCollector = new ThrowableCollector(__ -> false);\n\t\t\t\t\tthis.storedValues.entrySet().stream() //\n\t\t\t\t\t\t\t.map(e -> e.getValue().evaluateSafely(e.getKey())) //\n\t\t\t\t\t\t\t.filter(it -> it != null && it.value != null) //\n\t\t\t\t\t\t\t.sorted(EvaluatedValue.REVERSE_INSERT_ORDER) //\n\t\t\t\t\t\t\t.forEach(it -> throwableCollector.execute(() -> it.close(this.closeAction)));\n\t\t\t\t\tthrowableCollector.assertEmpty();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.closed = true;\n\t\t\t}\n\t\t}\n\t}",
        "human_comment": "If a {@link CloseAction} is configured, it will be called with all successfully\nstored values in reverse insertion order.\n\n<p>Closing a store does not close its parent or any of its children.\n\n<p>Invocations of this method after the store has already been closed will\nbe ignored.\n\n@see #isClosed()",
        "model_generated_comment": "Close the supplied {@link ThrowableCollector}.\n\n@since 5.4"
    },
    {
        "id": 505,
        "code_snippet": "public void testNoOOMDuringReset() {\n    final SparkConf sparkConf = new SparkConf();\n    sparkConf.set(package$.MODULE$.MEMORY_OFFHEAP_ENABLED(), false);\n\n    final TestMemoryManager testMemoryManager =\n            new TestMemoryManager(sparkConf);\n    final TaskMemoryManager memoryManager = new TaskMemoryManager(\n            testMemoryManager, 0);\n    final TestMemoryConsumer consumer = new TestMemoryConsumer(memoryManager);\n\n    final PrefixComparator prefixComparator = PrefixComparators.LONG;\n    final RecordComparator recordComparator = new RecordComparator() {\n    };\n    UnsafeInMemorySorter sorter = new UnsafeInMemorySorter(consumer, memoryManager,\n            recordComparator, prefixComparator, 100, shouldUseRadixSort());\n\n    testMemoryManager.markconsequentOOM(Integer.MAX_VALUE);\n    sorter.freeMemory();\n    testMemoryManager.resetConsequentOOM();\n    Assertions.assertFalse(sorter.hasSpaceForAnotherRecord());\n\n    LongArray array = consumer.allocateArray(1000);\n    sorter.expandPointerArray(array);\n\n    testMemoryManager.markconsequentOOM(Integer.MAX_VALUE);\n    sorter.freeMemory();\n    sorter.freeMemory();\n    testMemoryManager.resetConsequentOOM();\n    Assertions.assertFalse(sorter.hasSpaceForAnotherRecord());\n\n    assertEquals(0L, memoryManager.cleanUpAllAllocatedMemory());\n  }",
        "human_comment": "Use integer comparison for comparing prefixes (which are partition ids, in this case)\nEnsure that the sorter does not OOM while freeing its memory.\nGet the sorter in an usable state again by allocating a new pointer array.\nEnsure that it is safe to call freeMemory() multiple times.",
        "model_generated_comment": "testNoOOM duringReset() {@link UnsafeInMemorySorter}"
    },
    {
        "id": 506,
        "code_snippet": "public BuildResumptionPersistenceException(String message, Throwable cause) {\n        super(message, cause);\n    }",
        "human_comment": "This exception will be thrown when something fails while persisting build resumption data.\n@see BuildResumptionDataRepository#persistResumptionData",
        "model_generated_comment": "Creates a {@link BuildResumptionPersistenceException} with the given message.\n\n@param message The message to throw.\n@return {@code BuildResistenceException}."
    },
    {
        "id": 507,
        "code_snippet": "public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n    if (roundEnv.processingOver()) {\n      return false;\n    }\n\n    if (annotations.size() == 0) {\n      return false;\n    }\n\n    if (annotations.size() != 1) {\n      throw new IllegalStateException(\n          \"Unexpected - multiple annotations registered: \" + annotations);\n    }\n    TypeElement annotation = annotations.iterator().next();\n    Set<? extends Element> annotated = roundEnv.getElementsAnnotatedWith(annotation);\n\n    if (annotated.size() == 0) {\n      return false;\n    }\n\n    if (hasRun) {\n      for (Element e : annotated) {\n        error(\n            e,\n            \"The Operator processor has already processed @Operator annotated sources\\n\"\n                + \"and written out an Ops API. It cannot process additional @Operator sources.\\n\"\n                + \"One reason this can happen is if other annotation processors generate\\n\"\n                + \"new @Operator source files.\");\n      }\n      return false;\n    }\n\n    Multimap<String, MethodSpec> groupedMethods = HashMultimap.create();\n    if (!collectOpsMethods(roundEnv, groupedMethods, annotation)) {\n      return false;\n    }\n\n    if (groupedMethods.isEmpty()) {\n      return false;\n    }\n\n    writeApi(groupedMethods);\n\n    hasRun = true;\n    return false;\n  }",
        "human_comment": "Nothing needs to be done at the end of all rounds.\nNothing to look at in this round.\nWe expect to be registered for exactly one annotation.\nIf there are no annotated elements, claim the annotation but do nothing.\nThis processor has to aggregate all op classes in one round, as it generates a single Ops\nAPI class which cannot be modified once generated. If we find an annotation after we've\ngenerated our code, flag the location of each such class.\nCollect all classes tagged with our annotation.\nNothing to do when there are no tagged classes.\nValidate operator classes and generate Op API.",
        "model_generated_comment": "Processes annotated sources.\n\n@param annotations the annotations to process.\n@return true if the annotations are processed."
    },
    {
        "id": 508,
        "code_snippet": "void testEquality() {\n\n    /* Create some students */\n    final var firstStudent = new Student(1, \"Adam\", 'A');\n    final var secondStudent = new Student(2, \"Donald\", 'B');\n    final var secondSameStudent = new Student(2, \"Donald\", 'B');\n\n    /* Check equals functionality: should return 'true' */\n    assertEquals(firstStudent, firstStudent);\n\n    /* Check equals functionality: should return 'false' */\n    assertNotEquals(firstStudent, secondStudent);\n\n    /* Check equals functionality: should return 'true' */\n    assertEquals(secondStudent, secondSameStudent);\n  }",
        "human_comment": "This API tests the equality behaviour of Student object Object Equality should work as per\nlogic defined in equals method\n\n@throws Exception if any execution error during test",
        "model_generated_comment": "Unit tests for {@link Assertions}.\n\n@param firstStudent {@code Adam}\n@return true"
    },
    {
        "id": 509,
        "code_snippet": "long checksumByReader) {\n    Cause cause;\n    long duration = -1L;\n    long checksumByWriter = -1L;\n    long checksumByReCalculation = -1L;\n    try {\n      long diagnoseStartNs = System.nanoTime();\n      // Try to get the checksum instance before reading the checksum file so that\n      // `UnsupportedOperationException` can be thrown first before `FileNotFoundException`\n      // when the checksum algorithm isn't supported.\n      Checksum checksumAlgo = getChecksumByAlgorithm(algorithm);\n      checksumByWriter = readChecksumByReduceId(checksumFile, reduceId);\n      checksumByReCalculation = calculateChecksumForPartition(partitionData, checksumAlgo);\n      duration = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - diagnoseStartNs);\n      if (checksumByWriter != checksumByReCalculation) {\n        cause = Cause.DISK_ISSUE;\n      } else if (checksumByWriter != checksumByReader) {\n        cause = Cause.NETWORK_ISSUE;\n      } else {\n        cause = Cause.CHECKSUM_VERIFY_PASS;\n      }\n    } catch (UnsupportedOperationException e) {\n      cause = Cause.UNSUPPORTED_CHECKSUM_ALGORITHM;\n    } catch (FileNotFoundException e) {\n      // Even if checksum is enabled, a checksum file may not exist if error throws during writing.\n      logger.warn(\"Checksum file {} doesn't exit\",\n        MDC.of(LogKeys.PATH$.MODULE$, checksumFile.getName()));\n      cause = Cause.UNKNOWN_ISSUE;\n    } catch (Exception e) {\n      logger.warn(\"Unable to diagnose shuffle block corruption\", e);\n      cause = Cause.UNKNOWN_ISSUE;\n    }\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Shuffle corruption diagnosis took {} ms, checksum file {}, cause {}, \" +\n        \"checksumByReader {}, checksumByWriter {}, checksumByReCalculation {}\",\n        duration, checksumFile.getAbsolutePath(), cause,\n        checksumByReader, checksumByWriter, checksumByReCalculation);\n    } else {\n      logger.info(\"Shuffle corruption diagnosis took {} ms, checksum file {}, cause {}\",\n        MDC.of(LogKeys.TIME$.MODULE$, duration),\n        MDC.of(LogKeys.PATH$.MODULE$, checksumFile.getAbsolutePath()),\n        MDC.of(LogKeys.REASON$.MODULE$, cause));\n    }\n    return cause;\n  }",
        "human_comment": "Diagnose the possible cause of the shuffle data corruption by verifying the shuffle checksums.\n\nThere're 3 different kinds of checksums for the same shuffle partition:\n- checksum (c1) that is calculated by the shuffle data reader\n- checksum (c2) that is calculated by the shuffle data writer and stored in the checksum file\n- checksum (c3) that is recalculated during diagnosis\n\nAnd the diagnosis mechanism works like this:\nIf c2 != c3, we suspect the corruption is caused by the DISK_ISSUE. Otherwise, if c1 != c3,\nwe suspect the corruption is caused by the NETWORK_ISSUE. Otherwise, the cause remains\nCHECKSUM_VERIFY_PASS. In case of the any other failures, the cause remains UNKNOWN_ISSUE.\n\n@param algorithm The checksum algorithm that is used for calculating checksum value\nof partitionData\n@param checksumFile The checksum file that written by the shuffle writer\n@param reduceId The reduceId of the shuffle block\n@param partitionData The partition data of the shuffle block\n@param checksumByReader The checksum value that calculated by the shuffle data reader\n@return The cause of data corruption",
        "model_generated_comment": "If the checksum is enabled, the checkum file may not exist.\n\n@param checksum instance The checkum instance to read, may be {@code null}."
    },
    {
        "id": 510,
        "code_snippet": "public static Constant<Double> create(Scope scope, long[] shape, DoubleBuffer data) {\n    try (Tensor<Double> value = Tensor.create(shape, data)) {\n      return createWithTensor(scope, value);\n    }\n  }",
        "human_comment": "Create a {@link DataType#DOUBLE} constant with data from the given buffer.\n\n<p>Creates a constant with the given shape by copying elements from the buffer (starting from\nits current position) into the tensor. For example, if {@code shape = {2,3} } (which represents\na 2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param scope is a scope used to add the underlying operation.\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@return a double constant\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer",
        "model_generated_comment": "Creates a rank-2 constant of {@code scope} elements.\n\n@param shape The shape of the new constant.\n@return The new constant"
    },
    {
        "id": 511,
        "code_snippet": "private ReceiptViewModel purchase(Db.User user, Db.Account account, String itemName) {\n    Db.Product item = Db.getInstance().findProductByItemName(itemName);\n    if (item == null) {\n      return new OutOfStock(user.getUserName(), itemName);\n    }\n\n    ReceiptDto receipt = user.purchase(item);\n    MoneyTransaction transaction = account.withdraw(receipt.getPrice());\n    if (transaction == null) {\n      return new InsufficientFunds(user.getUserName(), account.getAmount(), itemName);\n    }\n\n    return receipt;\n  }",
        "human_comment": "Domain purchase with user, account and itemName, with validation for whether product is out of\nstock and whether user has insufficient funds in the account.\n\n@param user in Db\n@param account in Db\n@param itemName of the item\n@return instance of ReceiptViewModel",
        "model_generated_comment": "Returns a ReceiptViewModel with the user's name and the item name.\n\n@param user the user to purchase, must not be {@code null}."
    },
    {
        "id": 512,
        "code_snippet": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
        "human_comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception.",
        "model_generated_comment": "<em>Assert</em> that the execution of the main {@link App} throws an exception.\n\n@param String the String to check; never {@code null}"
    },
    {
        "id": 513,
        "code_snippet": "default String extractCatalog(CaseInsensitiveStringMap options) {\n    return CatalogManager.SESSION_CATALOG_NAME();\n  }",
        "human_comment": "Return the name of a catalog that can be used to check the existence of, load, and create\na table for this DataSource given the identifier that will be extracted by\n{@link #extractIdentifier(CaseInsensitiveStringMap) extractIdentifier}. A `null` value can\nbe used to defer to the V2SessionCatalog.\n\n@param options the user-specified options that can identify a table, e.g. file path, Kafka\ntopic name, etc. It's an immutable case-insensitive string-to-string map.",
        "model_generated_comment": "Extracts a catalog from the supplied data source.\n\n@param options the data source to extract.\n@return {@link #extractCatalog(CaseInsensitiveStringMap)}."
    },
    {
        "id": 514,
        "code_snippet": "public static void assertEquals(float expected, Float actual, String message) {\n\t\tAssertEquals.assertEquals((Float) expected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "<em>Assert</em> that two floats are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code message}.\n\n@since 5.4"
    },
    {
        "id": 515,
        "code_snippet": "public void setConfiguration(Object configuration) {\n        this.configuration = configuration;\n    } // -- void setConfiguration( Object )",
        "human_comment": "Set configuration to pass to all goals run in this phase.\n\n@param configuration a configuration object.",
        "model_generated_comment": "Set configuration for the configuration object.\n\n@param configuration The configuration object to set."
    },
    {
        "id": 516,
        "code_snippet": "public String getProperty(String key) {\n        return this.get(key);\n    }",
        "human_comment": "Searches for the property with the specified key in this property list.\n\n@param key the property key.\n@return the value in this property list with the specified key value.",
        "model_generated_comment": "Get the property of the property.\n\n@param key The key to get.\n@return this property."
    },
    {
        "id": 517,
        "code_snippet": "public <T> void checkThat(final String reason, final T value, final Matcher<T> matcher) {\n        checkSucceeds(new Callable<Object>() {\n        });\n    }",
        "human_comment": "Adds a failure with the given {@code reason}\nto the table if {@code matcher} does not match {@code value}.\nExecution continues, but the test will fail at the end if the match fails.",
        "model_generated_comment": "Checks if the given value is valid.\n\n@param reason the reason to check, may be {@code null}."
    },
    {
        "id": 518,
        "code_snippet": "public int[] getInts(int rowId, int count) {\n    int[] res = new int[count];\n    for (int i = 0; i < count; i++) {\n      res[i] = getInt(rowId + i);\n    }\n    return res;\n  }",
        "human_comment": "Gets int type values from {@code [rowId, rowId + count)}. The return values for the null slots\nare undefined and can be anything.",
        "model_generated_comment": "Get the ints of the row.\n\n@param rowId the row ID to get, must not be <code>null</code>."
    },
    {
        "id": 519,
        "code_snippet": "protected Map<String, String> populateSystemProperties(LocalContext context) {\n        Properties systemProperties = new Properties();\n\n\n        EnvironmentUtils.addEnvVars(systemProperties);\n        SystemProperties.addSystemProperties(systemProperties);\n\n\n        Properties buildProperties = CLIReportingUtils.getBuildProperties();\n\n        String mavenVersion = buildProperties.getProperty(CLIReportingUtils.BUILD_VERSION_PROPERTY);\n        systemProperties.setProperty(Constants.MAVEN_VERSION, mavenVersion);\n\n        boolean snapshot = mavenVersion.endsWith(\"SNAPSHOT\");\n        if (snapshot) {\n            mavenVersion = mavenVersion.substring(0, mavenVersion.length() - \"SNAPSHOT\".length());\n            if (mavenVersion.endsWith(\"-\")) {\n                mavenVersion = mavenVersion.substring(0, mavenVersion.length() - 1);\n            }\n        }\n        String[] versionElements = mavenVersion.split(\"\\\\.\");\n        if (versionElements.length != 3) {\n            throw new IllegalStateException(\"Maven version is expected to have 3 segments: '\" + mavenVersion + \"'\");\n        }\n        systemProperties.setProperty(Constants.MAVEN_VERSION_MAJOR, versionElements[0]);\n        systemProperties.setProperty(Constants.MAVEN_VERSION_MINOR, versionElements[1]);\n        systemProperties.setProperty(Constants.MAVEN_VERSION_PATCH, versionElements[2]);\n        systemProperties.setProperty(Constants.MAVEN_VERSION_SNAPSHOT, Boolean.toString(snapshot));\n\n        String mavenBuildVersion = CLIReportingUtils.createMavenVersionString(buildProperties);\n        systemProperties.setProperty(Constants.MAVEN_BUILD_VERSION, mavenBuildVersion);\n\n        Map<String, String> result = toMap(systemProperties);\n        result.putAll(context.systemPropertiesOverrides);\n        return result;\n    }",
        "human_comment": "----------------------------------------------------------------------\nLoad environment and system properties\n----------------------------------------------------------------------\n----------------------------------------------------------------------\nProperties containing info about the currently running version of Maven\nThese override any corresponding properties set on the command line\n----------------------------------------------------------------------",
        "model_generated_comment": "Create a new {@link SystemProperties}.\n\n@param context The context of the {@code systemProperties} to populate.\n@return a Map containing the properties to populate\n@throws IllegalStateException if the system is expected to have 3 segments"
    },
    {
        "id": 520,
        "code_snippet": "default boolean viewExists(Identifier ident) {\n    try {\n      return loadView(ident) != null;\n    } catch (NoSuchViewException e) {\n      return false;\n    }\n  }",
        "human_comment": "Test whether a view exists using an {@link Identifier identifier} from the catalog.\n<p>\nIf the catalog supports views and contains a view for the identifier and not a table,\nthis must return false.\n\n@param ident a view identifier\n@return true if the view exists, false otherwise",
        "model_generated_comment": "Loads the view of the given ident.\n\n@param ident the ident to load the view.\n@return true if the view exists."
    },
    {
        "id": 521,
        "code_snippet": "private void skipValues(int total) {\n    readValues(total, null, -1, (w, r, v) -> {});\n  }",
        "human_comment": "Read the values but don't write them out (the writer output method is a no-op)",
        "model_generated_comment": "Saves the values of the given value.\n\n@param total the total value to skip."
    },
    {
        "id": 522,
        "code_snippet": "public void executionSkipped(TestDescriptor testDescriptor, String reason) {\n\t\tthis.events.add(Event.executionSkipped(testDescriptor, reason));\n\t}",
        "human_comment": "Record an {@link Event} for a container or test that was skipped.",
        "model_generated_comment": "<em>ExecutionSkipped</em> for {@link TestDescriptor}.\n\n@since 5.4"
    },
    {
        "id": 523,
        "code_snippet": "void testWatcherSemanticsWhenRegisteredAtInstanceLevelWithTestInstanceLifecyclePerClass() {\n\t\tClass<?> testClass = TestInstancePerClassInstanceLevelTestWatcherTestCase.class;\n\t\tassertStatsForAbstractDisabledMethodsTestCase(testClass);\n\n\t\tassertThat(TrackingTestWatcher.results.get(\"testDisabled\")).containsExactly(\"test\", \"repeatedTest\");\n\t}",
        "human_comment": "We get \"testDisabled\" events for the @Test method and the @RepeatedTest container.",
        "model_generated_comment": "Unit tests for {@link TestInstancePerClassInstanceLevelTestWatcherTestCase}.\n\n@since 5.4"
    },
    {
        "id": 524,
        "code_snippet": "handle.addListener(new SparkAppHandle.Listener() {\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });",
        "human_comment": "Make sure the server matched the client to the handle.\nLauncherServer will immediately close the server-side socket when the timeout is set\nto 0.",
        "model_generated_comment": "Add a listener to the SparkAppHandle.\n\n@param handle the listener to add\n@return The listener"
    },
    {
        "id": 525,
        "code_snippet": "void testMultiply_NegativeFactor() {\n    Money money = new Money(100.00, \"USD\");\n\n    assertThrows(IllegalArgumentException.class, () -> money.multiply(-2));\n  }",
        "human_comment": "Test multiplying by a negative factor",
        "model_generated_comment": "Unit tests for Multiply_NegativeFactor."
    },
    {
        "id": 526,
        "code_snippet": "static TableChange updateColumnDefaultValue(String[] fieldNames, String newDefaultValue) {\n    return new UpdateColumnDefaultValue(fieldNames, newDefaultValue);\n  }",
        "human_comment": "Create a TableChange for updating the default value of a field.\n<p>\nThe name is used to find the field to update.\n<p>\nIf the field does not exist, the change will result in an {@link IllegalArgumentException}.\n\n@param fieldNames field names of the column to update\n@param newDefaultValue the new default value SQL string (Spark SQL dialect).\n@return a TableChange for the update",
        "model_generated_comment": "Update the column default value.\n\n@param fieldNames fieldNames the field names to update."
    },
    {
        "id": 527,
        "code_snippet": "public void error(String msg) {\n        out.print(ERROR);\n        out.println(msg);\n    }",
        "human_comment": "These are the only methods we need in our primordial logger",
        "model_generated_comment": "Prints an error with the given message.\n\n@param msg The message to print."
    },
    {
        "id": 528,
        "code_snippet": "private String toString(Object obj) {\n        String str;\n        if (obj != null && obj.getClass().isArray()) {\n            int n = Array.getLength(obj);\n            StringBuilder buf = new StringBuilder(256);\n            buf.append('[');\n            for (int i = 0; i < n; i++) {\n                if (i > 0) {\n                    buf.append(\", \");\n                }\n                buf.append(Array.get(obj, i));\n            }\n            buf.append(']');\n            str = buf.toString();\n        } else {\n            str = String.valueOf(obj);\n        }\n        return str;\n    }",
        "human_comment": "Creates a human-friendly string representation of the specified object.\n\n@param obj The object to create a string representation for, may be <code>null</code>.\n@return The string representation, never <code>null</code>.",
        "model_generated_comment": "Creates a string from the given object.\n\n@param obj The object to be used to add the string\n@return the string"
    },
    {
        "id": 529,
        "code_snippet": "public void set(final String userId, final UserAccount userAccount) {\n    cache.set(userId, userAccount);\n  }",
        "human_comment": "Delegate to backing cache store.\n\n@param userId {@link String}\n@param userAccount {@link UserAccount}",
        "model_generated_comment": "Sets the user ID of the user.\n\n@param userId the user account to set."
    },
    {
        "id": 530,
        "code_snippet": "public void free(MemoryBlock memory) {\n    assert (memory.obj != null) :\n      \"baseObject was null; are you trying to use the on-heap allocator to free off-heap memory?\";\n    assert (memory.pageNumber != MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER) :\n      \"page has already been freed\";\n    assert ((memory.pageNumber == MemoryBlock.NO_PAGE_NUMBER)\n            || (memory.pageNumber == MemoryBlock.FREED_IN_TMM_PAGE_NUMBER)) :\n      \"TMM-allocated pages must first be freed via TMM.freePage(), not directly in allocator \" +\n        \"free()\";\n\n    final long size = memory.size();\n    if (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) {\n      memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_FREED_VALUE);\n    }\n\n    memory.pageNumber = MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER;\n\n    long[] array = (long[]) memory.obj;\n    memory.setObjAndOffset(null, 0);\n\n    long alignedSize = ((size + 7) / 8) * 8;\n    if (shouldPool(alignedSize)) {\n      synchronized (this) {\n        LinkedList<WeakReference<long[]>> pool =\n          bufferPoolsBySize.computeIfAbsent(alignedSize, k -> new LinkedList<>());\n        pool.add(new WeakReference<>(array));\n      }\n    }\n  }",
        "human_comment": "Mark the page as freed (so we can detect double-frees).\nAs an additional layer of defense against use-after-free bugs, we mutate the\nMemoryBlock to null out its reference to the long[] array.",
        "model_generated_comment": "Free a page from the memory block.\n\n@param memoryBlock The memory block to free."
    },
    {
        "id": 531,
        "code_snippet": "public static Queen createNotFlirtyQueen() {\n    return new Queen();\n  }",
        "human_comment": "Method to create a not flirty queen.\n\n@return A not flirty {@link com.iluwatar.objectmother.Queen}.",
        "model_generated_comment": "Creates a new {@link Queen} for the given person.\n\n@param Queen the {@code FlirtyQueen} to create."
    },
    {
        "id": 532,
        "code_snippet": "public static UnspecifiedDistribution unspecified() {\n    return LogicalDistributions.unspecified();\n  }",
        "human_comment": "Creates a distribution where no promises are made about co-location of data.",
        "model_generated_comment": "Returns an instance of {@link UnspecifiedDistribution}."
    },
    {
        "id": 533,
        "code_snippet": "default DiscoveryIssue withMessage(UnaryOperator<String> messageModifier) {\n\t\tString oldMessage = message();\n\t\tString newMessage = messageModifier.apply(oldMessage);\n\t\tif (oldMessage.equals(newMessage)) {\n\t\t\treturn this;\n\t\t}\n\t\treturn DiscoveryIssue.builder(severity(), newMessage) //\n\t\t\t\t.source(source()) //\n\t\t\t\t.cause(cause()) //\n\t\t\t\t.build();\n\t}",
        "human_comment": "Create a copy of this issue with the modified message produced by the\nsupplied operator.",
        "model_generated_comment": "Create a new {@link DiscoveryIssue} for the supplied {@code messageModifier}.\n\n@since 5.0"
    },
    {
        "id": 534,
        "code_snippet": "private void checkVersionsArrayEqual(String[] array) {\n        for (int i = 0; i < array.length; ++i) {\n            for (int j = i; j < array.length; ++j) {\n                checkVersionsEqual(array[i], array[j]);\n            }\n        }\n    }",
        "human_comment": "compare against each other (including itself)",
        "model_generated_comment": "CheckVersionsEqual(String[]).\n\n@param array The array to check, may be {@code null}."
    },
    {
        "id": 535,
        "code_snippet": "public AlbumListPage navigateToPage() {\n    try {\n      page = this.webClient.getPage(PAGE_URL);\n    } catch (IOException e) {\n      LOGGER.error(\"An error occurred on navigateToPage.\", e);\n    }\n    return this;\n  }",
        "human_comment": "Navigates to the Album List Page.\n\n@return {@link AlbumListPage}",
        "model_generated_comment": "Navigates to the AlbumListPage."
    },
    {
        "id": 536,
        "code_snippet": "public boolean saslEncryption() {\n    return conf.getBoolean(\"spark.authenticate.enableSaslEncryption\", false);\n  }",
        "human_comment": "Whether to enable SASL-based encryption when authenticating using SASL.",
        "model_generated_comment": "Sasl Encryption is enabled by default."
    },
    {
        "id": 537,
        "code_snippet": "void setTo(Object src) {\n    if (src == null) {\n      if (hasDelegateBufferHandle(nativeHandle)) {\n        return;\n      }\n      throw new IllegalArgumentException(\n          \"Null inputs are allowed only if the Tensor is bound to a buffer handle.\");\n    }\n    throwIfTypeIsIncompatible(src);\n    throwIfSrcShapeIsIncompatible(src);\n    if (isBuffer(src)) {\n      setTo((Buffer) src);\n    } else if (dtype == DataType.STRING && shapeCopy.length == 0) {\n      // Update scalar string input with 1-d byte array.\n      writeScalar(nativeHandle, src);\n    } else if (src.getClass().isArray()) {\n      writeMultiDimensionalArray(nativeHandle, src);\n    } else {\n      writeScalar(nativeHandle, src);\n    }\n  }",
        "human_comment": "Copies the contents of the provided {@code src} object to the Tensor.\n\n<p>The {@code src} should either be a (multi-dimensional) array with a shape matching that of\nthis tensor, a {@link ByteBuffer} of compatible primitive type with a matching flat size, or\n{@code null} iff the tensor has an underlying delegate buffer handle.\n\n@throws IllegalArgumentException if the tensor is a scalar or if {@code src} is not compatible\nwith the tensor (for example, mismatched data types or shapes).",
        "model_generated_comment": "Sets the scalar string input to a buffer handle.\n\n@param src the buffer handle to set to."
    },
    {
        "id": 538,
        "code_snippet": "public UnsafeRow getRow() {\n    row.setTotalSize(totalSize());\n    return row;\n  }",
        "human_comment": "Updates total size of the UnsafeRow using the size collected by BufferHolder, and returns\nthe UnsafeRow created at a constructor",
        "model_generated_comment": "Sets the total size of the row.\n\n@param row The row to get."
    },
    {
        "id": 539,
        "code_snippet": "default void info(@Nonnull String message) {\n        log(Level.INFO, message);\n    }",
        "human_comment": "Logs an info message without an associated exception.\n\n@param message the info message to be logged",
        "model_generated_comment": "Logs a message to the server.\n\n@param message The message to log."
    },
    {
        "id": 540,
        "code_snippet": "void annotationOnField() {\n\t\texecuteTestsForClass(AnnotationOnFieldTestCase.class).testEvents()//\n\t\t\t\t.assertStatistics(stats -> stats.started(1).succeeded(1));\n\t}",
        "human_comment": "Integration tests for the use of {@link TempDir} as a meta-annotation.\n\n@since 5.10",
        "model_generated_comment": "Unit tests for {@link AnnotationOnFieldTestCase}.\n\n@since 5.0"
    },
    {
        "id": 541,
        "code_snippet": "private ByteBuffer createHeaderByteBuffer() {\n            ByteBuffer encrypterHeader = encrypter.getHeader();\n            return ByteBuffer\n                    .allocate(encrypterHeader.remaining() + LENGTH_HEADER_BYTES)\n                    .putLong(encryptedCount)\n                    .put(encrypterHeader)\n                    .flip();\n        }",
        "human_comment": "If the ciphertext buffer cannot be fully written the target, transferTo may\nreturn with it containing some unwritten data. The initial call we'll explicitly\nset its limit to 0 to indicate the first call to transferTo.\nThe format of the output is:\n[8 byte length][Internal IV and header][Ciphertext][Auth Tag]",
        "model_generated_comment": "Creates a new header buffer.\n\n@param encrypter the header buffer\n@return a new ByteBuffer"
    },
    {
        "id": 542,
        "code_snippet": "public InitializationError(List<Throwable> errors) {\n        this.fErrors = errors;\n    }",
        "human_comment": "Construct a new {@code InitializationError} with one or more",
        "model_generated_comment": "Initializes a {@link InitializationError} with the given list of errors.\n\n@param errors The errors to check."
    },
    {
        "id": 543,
        "code_snippet": "public Saga setInValue(Object value) {\n    if (chapters.isEmpty()) {\n      return this;\n    }\n    chapters.get(chapters.size() - 1).setInValue(value);\n    return this;\n  }",
        "human_comment": "set value to last chapter.\n\n@param value invalue\n@return this",
        "model_generated_comment": "Set the value of the Saga.\n\n@param value the value to set.\n@return this value."
    },
    {
        "id": 544,
        "code_snippet": "protected Filter createFilter(List<Class<?>> categories) {\n        return new IncludesAny(categories);\n    }",
        "human_comment": "Creates a {@link Filter} which is only passed by tests that are\ncategorized with any of the specified categories.\n\n@param categories Category classes.",
        "model_generated_comment": "Create a {@link Filter} for a list of categories.\n\n@param categories The categories to create a filter.\n@return a filter containing all the categories in the list."
    },
    {
        "id": 545,
        "code_snippet": "public void testNormalize4() {\n        IMoney ms1 = MoneyBag.create(new Money(12, \"CHF\"), new Money(3, \"USD\"));\n        Money expected = new Money(-3, \"USD\");\n        assertEquals(expected, f12CHF.subtract(ms1));\n    }",
        "human_comment": "[12 CHF] - {[12 CHF][3 USD]} == [-3 USD]",
        "model_generated_comment": "Unit tests for {@link MoneyBag}.\n\n@since 5.0"
    },
    {
        "id": 546,
        "code_snippet": "public static Tensor<Integer> create(int[][][] data) {\n    return Tensor.create(data, Integer.class);\n  }",
        "human_comment": "Creates a rank-3 tensor of {@code int} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array.",
        "model_generated_comment": "Creates a rank-4 tensor of {@code int} elements.\n\n@param data An array containing the values to put into the new tensor."
    },
    {
        "id": 547,
        "code_snippet": "public Keypoint(final float x, final float y) {\n      this.x = x;\n      this.y = y;\n      this.score = 0;\n      this.type = -1;\n    }",
        "human_comment": "A simple class that records keypoint information, which includes\nlocal location, score and type. This will be used in calculating\nFrameChange.",
        "model_generated_comment": "Creates a new Keypoint for the given float.\n\n@param x the float to use, may be {@code null}."
    },
    {
        "id": 548,
        "code_snippet": "public static String[] parseFullyQualifiedMethodName(String fullyQualifiedMethodName) {\n\t\tPreconditions.notBlank(fullyQualifiedMethodName, \"fullyQualifiedMethodName must not be null or blank\");\n\n\t\tint indexOfFirstHashtag = fullyQualifiedMethodName.indexOf('#');\n\t\tboolean validSyntax = (indexOfFirstHashtag > 0)\n\t\t\t\t&& (indexOfFirstHashtag < fullyQualifiedMethodName.length() - 1);\n\n\t\tPreconditions.condition(validSyntax,\n\t\t\t() -> \"[\" + fullyQualifiedMethodName + \"] is not a valid fully qualified method name: \"\n\t\t\t\t\t+ \"it must start with a fully qualified class name followed by a '#' \"\n\t\t\t\t\t+ \"and then the method name, optionally followed by a parameter list enclosed in parentheses.\");\n\n\t\tString className = fullyQualifiedMethodName.substring(0, indexOfFirstHashtag);\n\t\tString methodPart = fullyQualifiedMethodName.substring(indexOfFirstHashtag + 1);\n\t\tString methodName = methodPart;\n\t\tString methodParameters = \"\";\n\n\t\tif (methodPart.endsWith(\"()\")) {\n\t\t\tmethodName = methodPart.substring(0, methodPart.length() - 2);\n\t\t}\n\t\telse if (methodPart.endsWith(\")\")) {\n\t\t\tint indexOfLastOpeningParenthesis = methodPart.lastIndexOf('(');\n\t\t\tif ((indexOfLastOpeningParenthesis > 0) && (indexOfLastOpeningParenthesis < methodPart.length() - 1)) {\n\t\t\t\tmethodName = methodPart.substring(0, indexOfLastOpeningParenthesis);\n\t\t\t\tmethodParameters = methodPart.substring(indexOfLastOpeningParenthesis + 1, methodPart.length() - 1);\n\t\t\t}\n\t\t}\n\t\treturn new String[] { className, methodName, methodParameters };\n\n\t@API(status = INTERNAL, since = \"1.11\")\n\tpublic static String[] parseFullyQualifiedFieldName(String fullyQualifiedFieldName) {\n\t\tPreconditions.notBlank(fullyQualifiedFieldName, \"fullyQualifiedFieldName must not be null or blank\");\n\n\t\tint indexOfHashtag = fullyQualifiedFieldName.indexOf('#');\n\t\tboolean validSyntax = (indexOfHashtag > 0) && (indexOfHashtag < fullyQualifiedFieldName.length() - 1);\n\t\tPreconditions.condition(validSyntax,\n\t\t\t() -> \"[\" + fullyQualifiedFieldName + \"] is not a valid fully qualified field name: \"\n\t\t\t\t\t+ \"it must start with a fully qualified class name followed by a '#' \"\n\t\t\t\t\t+ \"and then the field name.\");\n\t\treturn fullyQualifiedFieldName.split(\"#\");\n\t}\n\n\tpublic static Set<Path> getAllClasspathRootDirectories() {\n\t\t// This is quite a hack, since sometimes the classpath is quite different\n\t\tString fullClassPath = System.getProperty(\"java.class.path\");\n\t\t// @formatter:off\n\t\treturn Arrays.stream(fullClassPath.split(File.pathSeparator))\n\t\t\t\t.map(Paths::get)\n\t\t\t\t.filter(Files::isDirectory)\n\t\t\t\t.collect(toSet());\n\t\t// @formatter:on\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInClasspathRoot(URI root, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\t// unmodifiable since returned by public, non-internal method(s)\n\t\treturn findAllClassesInClasspathRoot(root, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInClasspathRoot(URI root, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\treturn streamAllClassesInClasspathRoot(root, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInClasspathRoot(URI root, ClassFilter classFilter) {\n\t\treturn Collections.unmodifiableList(classpathScanner.scanForClassesInClasspathRoot(root, classFilter));\n\t}\n\n\tpublic static List<Resource> findAllResourcesInClasspathRoot(URI root, Predicate<Resource> resourceFilter) {\n\t\treturn Collections.unmodifiableList(classpathScanner.scanForResourcesInClasspathRoot(root, resourceFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInClasspathRoot(URI root, ClassFilter classFilter) {\n\t\treturn findAllClassesInClasspathRoot(root, classFilter).stream();\n\t}\n\n\tpublic static Stream<Resource> streamAllResourcesInClasspathRoot(URI root, Predicate<Resource> resourceFilter) {\n\t\treturn findAllResourcesInClasspathRoot(root, resourceFilter).stream();\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInPackage(String basePackageName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\t// unmodifiable since returned by public, non-internal method(s)\n\t\treturn findAllClassesInPackage(basePackageName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInPackage(String basePackageName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\treturn streamAllClassesInPackage(basePackageName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInPackage(String basePackageName, ClassFilter classFilter) {\n\t\treturn Collections.unmodifiableList(classpathScanner.scanForClassesInPackage(basePackageName, classFilter));\n\t}\n\n\tpublic static List<Resource> findAllResourcesInPackage(String basePackageName, Predicate<Resource> resourceFilter) {\n\t\treturn Collections.unmodifiableList(\n\t\t\tclasspathScanner.scanForResourcesInPackage(basePackageName, resourceFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInPackage(String basePackageName, ClassFilter classFilter) {\n\t\treturn findAllClassesInPackage(basePackageName, classFilter).stream();\n\t}\n\n\tpublic static Stream<Resource> streamAllResourcesInPackage(String basePackageName,\n\t\t\tPredicate<Resource> resourceFilter) {\n\t\treturn findAllResourcesInPackage(basePackageName, resourceFilter).stream();\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInModule(String moduleName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\t// unmodifiable since returned by public, non-internal method(s)\n\t\treturn findAllClassesInModule(moduleName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInModule(String moduleName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\treturn streamAllClassesInModule(moduleName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInModule(String moduleName, ClassFilter classFilter) {\n\t\treturn Collections.unmodifiableList(ModuleUtils.findAllClassesInModule(moduleName, classFilter));\n\t}\n\n\tpublic static List<Resource> findAllResourcesInModule(String moduleName, Predicate<Resource> resourceFilter) {\n\t\treturn Collections.unmodifiableList(ModuleUtils.findAllResourcesInModule(moduleName, resourceFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInModule(String moduleName, ClassFilter classFilter) {\n\t\treturn findAllClassesInModule(moduleName, classFilter).stream();\n\t}\n\n\tpublic static Stream<Resource> streamAllResourcesInModule(String moduleName, Predicate<Resource> resourceFilter) {\n\t\treturn findAllResourcesInModule(moduleName, resourceFilter).stream();\n\t}\n\n\tpublic static List<Class<?>> findNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\tSet<Class<?>> candidates = new LinkedHashSet<>();\n\t\tvisitNestedClasses(clazz, predicate, nestedClass -> {\n\t\t\tcandidates.add(nestedClass);\n\t\t\treturn true;\n\t\t});\n\t\treturn Collections.unmodifiableList(new ArrayList<>(candidates));\n\t}\n\n\t@API(status = INTERNAL, since = \"1.13\")\n\tpublic static boolean isNestedClassPresent(Class<?> clazz, Predicate<Class<?>> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\tboolean visitorWasNotCalled = visitNestedClasses(clazz, predicate, __ -> false);\n\t\treturn !visitorWasNotCalled;\n\t}\n\n\tpublic static Stream<Class<?>> streamNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate) {\n\t\treturn findNestedClasses(clazz, predicate).stream();\n\t}\n\n\tprivate static boolean visitNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate,\n\t\t\tVisitor<Class<?>> visitor) {\n\t\tif (!isSearchable(clazz)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isInnerClass(clazz) && predicate.test(clazz)) {\n\t\t\tdetectInnerClassCycle(clazz);\n\t\t}\n\n\t\ttry {\n\t\t\t// Candidates in current class\n\t\t\tfor (Class<?> nestedClass : clazz.getDeclaredClasses()) {\n\t\t\t\tif (predicate.test(nestedClass)) {\n\t\t\t\t\tdetectInnerClassCycle(nestedClass);\n\t\t\t\t\tboolean shouldContinue = visitor.accept(nestedClass);\n\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoClassDefFoundError error) {\n\t\t\tlogger.debug(error, () -> \"Failed to retrieve declared classes for \" + clazz.getName());\n\t\t}\n\n\t\t// Search class hierarchy\n\t\tboolean shouldContinue = visitNestedClasses(clazz.getSuperclass(), predicate, visitor);\n\t\tif (!shouldContinue) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Search interface hierarchy\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tshouldContinue = visitNestedClasses(ifc, predicate, visitor);\n\t\t\tif (!shouldContinue) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static void detectInnerClassCycle(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tString className = clazz.getName();\n\n\t\tif (noCyclesDetectedCache.contains(className)) {\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (isInnerClass(clazz) && isSearchable(superclass)) {\n\t\t\tfor (Class<?> enclosing = clazz.getEnclosingClass(); enclosing != null; enclosing = enclosing.getEnclosingClass()) {\n\t\t\t\tif (superclass.equals(enclosing)) {\n\t\t\t\t\tthrow new JUnitException(String.format(\"Detected cycle in inner class hierarchy between %s and %s\",\n\t\t\t\t\t\tclassName, enclosing.getName()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnoCyclesDetectedCache.add(className);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> Constructor<T> getDeclaredConstructor(Class<T> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\tConstructor<?>[] constructors = Arrays.stream(clazz.getDeclaredConstructors())//\n\t\t\t\t\t.filter(ctor -> !ctor.isSynthetic())//\n\t\t\t\t\t.toArray(Constructor[]::new);\n\n\t\t\tPreconditions.condition(constructors.length == 1,\n\t\t\t\t() -> String.format(\"Class [%s] must declare a single constructor\", clazz.getName()));\n\n\t\t\treturn (Constructor<T>) constructors[0];\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\n\t\t}\n\t}\n\n\tpublic static List<Constructor<?>> findConstructors(Class<?> clazz, Predicate<Constructor<?>> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\ttry {\n\t\t\t// @formatter:off\n\t\t\treturn Arrays.stream(clazz.getDeclaredConstructors())\n\t\t\t\t\t.filter(predicate)\n\t\t\t\t\t.collect(toUnmodifiableList());\n\t\t\t// @formatter:on\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\n\t\t}\n\t}\n\n\tpublic static List<Field> findFields(Class<?> clazz, Predicate<Field> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\treturn streamFields(clazz, predicate, traversalMode).collect(toUnmodifiableList());\n\t}\n\n\tpublic static Stream<Field> streamFields(Class<?> clazz, Predicate<Field> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\treturn findAllFieldsInHierarchy(clazz, traversalMode).stream()\n\t\t\t\t.filter(predicate)\n\t\t\t\t.distinct();\n\t\t// @formatter:on\n\t}\n\n\tprivate static List<Field> findAllFieldsInHierarchy(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\tField[] localFields = getDeclaredFields(clazz).stream()\n\t\t\t\t.filter(field -> !field.isSynthetic())\n\t\t\t\t.toArray(Field[]::new);\n\t\tField[] superclassFields = getSuperclassFields(clazz, traversalMode).stream()\n\t\t\t\t.filter(field -> isNotShadowedByLocalFields(field, localFields))\n\t\t\t\t.toArray(Field[]::new);\n\t\tField[] interfaceFields = getInterfaceFields(clazz, traversalMode).stream()\n\t\t\t\t.filter(field -> isNotShadowedByLocalFields(field, localFields))\n\t\t\t\t.toArray(Field[]::new);\n\t\t// @formatter:on\n\n\t\tList<Field> fields = new ArrayList<>(superclassFields.length + interfaceFields.length + localFields.length);\n\t\tif (traversalMode == TOP_DOWN) {\n\t\t\tCollections.addAll(fields, superclassFields);\n\t\t\tCollections.addAll(fields, interfaceFields);\n\t\t}\n\t\tCollections.addAll(fields, localFields);\n\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\tCollections.addAll(fields, interfaceFields);\n\t\t\tCollections.addAll(fields, superclassFields);\n\t\t}\n\t\treturn fields;\n\t}\n\n\tpublic static boolean isMethodPresent(Class<?> clazz, Predicate<Method> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\treturn findMethod(clazz, predicate).isPresent();\n\t}\n\n\t@API(status = DEPRECATED, since = \"1.4\")\n\t@Deprecated\n\tstatic Optional<Method> getMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\treturn tryToGetMethod(clazz, methodName, parameterTypes).toOptional();\n\t}\n\n\t@API(status = INTERNAL, since = \"1.4\")\n\tpublic static Try<Method> tryToGetMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\n\t\treturn Try.call(() -> clazz.getMethod(methodName, parameterTypes));\n\t}\n\n\t@API(status = INTERNAL, since = \"1.11\")\n\tpublic static Method getInterfaceMethodIfPossible(Method method, Class<?> targetClass) {\n\t\tif (!isPublic(method) || method.getDeclaringClass().isInterface()) {\n\t\t\treturn method;\n\t\t}\n\t\t// Try cached version of method in its declaring class\n\t\tMethod result = interfaceMethodCache.computeIfAbsent(method,\n\t\t\tm -> findInterfaceMethodIfPossible(m, m.getParameterTypes(), m.getDeclaringClass(), Object.class));\n\t\tif (result == method && targetClass != null) {\n\t\t\t// No interface method found yet -> try given target class (possibly a subclass of the\n\t\t\t// declaring class, late-binding a base class method to a subclass-declared interface:\n\t\t\t// see e.g. HashMap.HashIterator.hasNext)\n\t\t\tresult = findInterfaceMethodIfPossible(method, method.getParameterTypes(), targetClass,\n\t\t\t\tmethod.getDeclaringClass());\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static Method findInterfaceMethodIfPossible(Method method, Class<?>[] parameterTypes, Class<?> startClass,\n\t\t\tClass<?> endClass) {\n\n\t\tClass<?> current = startClass;\n\t\twhile (current != null && current != endClass) {\n\t\t\tfor (Class<?> ifc : current.getInterfaces()) {\n\t\t\t\ttry {\n\t\t\t\t\treturn ifc.getMethod(method.getName(), parameterTypes);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.getSuperclass();\n\t\t}\n\t\treturn method;\n\t}\n\n\tpublic static Optional<Method> findMethod(Class<?> clazz, String methodName, String parameterTypeNames) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\t\treturn findMethod(clazz, methodName, resolveParameterTypes(clazz, methodName, parameterTypeNames));\n\t}\n\n\t@API(status = INTERNAL, since = \"1.10\")\n\tpublic static Class<?>[] resolveParameterTypes(Class<?> clazz, String methodName, String parameterTypeNames) {\n\t\tif (StringUtils.isBlank(parameterTypeNames)) {\n\t\t\treturn EMPTY_CLASS_ARRAY;\n\t\t}\n\n\t\t// @formatter:off\n\t\treturn Arrays.stream(parameterTypeNames.split(\",\"))\n\t\t\t\t.map(String::trim)\n\t\t\t\t.map(typeName -> loadRequiredParameterType(clazz, methodName, typeName))\n\t\t\t\t.toArray(Class[]::new);\n\t\t// @formatter:on\n\t}\n\n\tprivate static Class<?> loadRequiredParameterType(Class<?> clazz, String methodName, String typeName) {\n\t\tClassLoader classLoader = ClassLoaderUtils.getClassLoader(clazz);\n\n\t\t// @formatter:off\n\t\treturn tryToLoadClass(typeName, classLoader)\n\t\t\t\t.getOrThrow(cause -> new JUnitException(\n\t\t\t\t\t\tString.format(\"Failed to load parameter type [%s] for method [%s] in class [%s].\",\n\t\t\t\t\t\t\t\ttypeName, methodName, clazz.getName()), cause));\n\t\t// @formatter:on\n\t}\n\n\tpublic static Optional<Method> findMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\t\tPreconditions.notNull(parameterTypes, \"Parameter types array must not be null\");\n\t\tPreconditions.containsNoNullElements(parameterTypes, \"Individual parameter types must not be null\");\n\n\t\treturn findMethod(clazz, method -> hasCompatibleSignature(method, methodName, parameterTypes));\n\t}\n\n\tprivate static Optional<Method> findMethod(Class<?> clazz, Predicate<Method> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\tfor (Class<?> current = clazz; isSearchable(current); current = current.getSuperclass()) {\n\t\t\t// Search for match in current type\n\t\t\tList<Method> methods = current.isInterface() ? getMethods(current) : getDeclaredMethods(current, BOTTOM_UP);\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (predicate.test(method)) {\n\t\t\t\t\treturn Optional.of(method);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Search for match in interfaces implemented by current type\n\t\t\tfor (Class<?> ifc : current.getInterfaces()) {\n\t\t\t\tOptional<Method> optional = findMethod(ifc, predicate);\n\t\t\t\tif (optional.isPresent()) {\n\t\t\t\t\treturn optional;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Optional.empty();\n\t}\n\n\t@API(status = STABLE, since = \"1.7\")\n\tpublic static Method getRequiredMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\treturn ReflectionUtils.findMethod(clazz, methodName, parameterTypes).orElseThrow(\n\t\t\t() -> new JUnitException(format(\"Could not find method [%s] in class [%s]\", methodName, clazz.getName())));\n\t}\n\n\tpublic static List<Method> findMethods(Class<?> clazz, Predicate<Method> predicate) {\n\t\treturn findMethods(clazz, predicate, TOP_DOWN);\n\t}\n\n\tpublic static List<Method> findMethods(Class<?> clazz, Predicate<Method> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\treturn streamMethods(clazz, predicate, traversalMode).collect(toUnmodifiableList());\n\t}\n\n\tpublic static Stream<Method> streamMethods(Class<?> clazz, Predicate<Method> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\treturn findAllMethodsInHierarchy(clazz, traversalMode).stream()\n\t\t\t\t.filter(predicate)\n\t\t\t\t.distinct();\n\t\t// @formatter:on\n\t}\n\n\tprivate static List<Method> findAllMethodsInHierarchy(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\tMethod[] localMethods = getDeclaredMethods(clazz, traversalMode).stream()\n\t\t\t\t.filter(method -> !method.isSynthetic())\n\t\t\t\t.toArray(Method[]::new);\n\t\tMethod[] superclassMethods = getSuperclassMethods(clazz, traversalMode).stream()\n\t\t\t\t.filter(method -> isNotOverriddenByLocalMethods(method, localMethods))\n\t\t\t\t.toArray(Method[]::new);\n\t\tMethod[] interfaceMethods = getInterfaceMethods(clazz, traversalMode).stream()\n\t\t\t\t.filter(method -> isNotOverriddenByLocalMethods(method, localMethods))\n\t\t\t\t.toArray(Method[]::new);\n\t\t// @formatter:on\n\n\t\tList<Method> methods = new ArrayList<>(\n\t\t\tsuperclassMethods.length + interfaceMethods.length + localMethods.length);\n\t\tif (traversalMode == TOP_DOWN) {\n\t\t\tCollections.addAll(methods, superclassMethods);\n\t\t\tCollections.addAll(methods, interfaceMethods);\n\t\t}\n\t\tCollections.addAll(methods, localMethods);\n\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\tCollections.addAll(methods, interfaceMethods);\n\t\t\tCollections.addAll(methods, superclassMethods);\n\t\t}\n\t\treturn methods;\n\t}\n\n\tprivate static List<Field> getFields(Class<?> clazz) {\n\t\treturn toSortedMutableList(clazz.getFields());\n\t}\n\n\tprivate static List<Field> getDeclaredFields(Class<?> clazz) {\n\t\treturn toSortedMutableList(clazz.getDeclaredFields());\n\t}\n\n\tprivate static List<Method> getMethods(Class<?> clazz) {\n\t\treturn toSortedMutableList(clazz.getMethods());\n\t}\n\n\tprivate static List<Method> getDeclaredMethods(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\t// Note: getDefaultMethods() already sorts the methods,\n\t\tList<Method> defaultMethods = getDefaultMethods(clazz);\n\t\tList<Method> declaredMethods = toSortedMutableList(clazz.getDeclaredMethods());\n\n\t\t// Take the traversal mode into account in order to retain the inherited\n\t\t// nature of interface default methods.\n\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\tdeclaredMethods.addAll(defaultMethods);\n\t\t\treturn declaredMethods;\n\t\t}\n\t\telse {\n\t\t\tdefaultMethods.addAll(declaredMethods);\n\t\t\treturn defaultMethods;\n\t\t}\n\t}\n\n\tprivate static List<Method> getDefaultMethods(Class<?> clazz) {\n\t\t// @formatter:off\n\t\t// Visible default methods are interface default methods that have not\n\t\t// been overridden.\n\t\tList<Method> visibleDefaultMethods = Arrays.stream(clazz.getMethods())\n\t\t\t\t.filter(Method::isDefault)\n\t\t\t\t.collect(toCollection(ArrayList::new));\n\t\tif (visibleDefaultMethods.isEmpty()) {\n\t\t\treturn visibleDefaultMethods;\n\t\t}\n\t\treturn Arrays.stream(clazz.getInterfaces())\n\t\t\t\t.map(ReflectionUtils::getMethods)\n\t\t\t\t.flatMap(List::stream)\n\t\t\t\t.filter(visibleDefaultMethods::contains)\n\t\t\t\t.collect(toCollection(ArrayList::new));\n\t\t// @formatter:on\n\t}\n\n\tprivate static List<Field> toSortedMutableList(Field[] fields) {\n\t\treturn toSortedMutableList(fields, ReflectionUtils::defaultFieldSorter);\n\t}\n\n\tprivate static List<Method> toSortedMutableList(Method[] methods) {\n\t\treturn toSortedMutableList(methods, ReflectionUtils::defaultMethodSorter);\n\t}\n\n\tprivate static <T> List<T> toSortedMutableList(T[] items, Comparator<? super T> comparator) {\n\t\tList<T> result = new ArrayList<>(items.length);\n\t\tCollections.addAll(result, items);\n\t\tresult.sort(comparator);\n\t\treturn result;\n\t}\n\n\tprivate static int defaultFieldSorter(Field field1, Field field2) {\n\t\treturn Integer.compare(field1.getName().hashCode(), field2.getName().hashCode());\n\t}\n\n\tprivate static int defaultMethodSorter(Method method1, Method method2) {\n\t\tString name1 = method1.getName();\n\t\tString name2 = method2.getName();\n\t\tint comparison = Integer.compare(name1.hashCode(), name2.hashCode());\n\t\tif (comparison == 0) {\n\t\t\tcomparison = name1.compareTo(name2);\n\t\t\tif (comparison == 0) {\n\t\t\t\tcomparison = method1.toString().compareTo(method2.toString());\n\t\t\t}\n\t\t}\n\t\treturn comparison;\n\t}\n\n\tprivate static List<Method> getInterfaceMethods(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tList<Method> allInterfaceMethods = new ArrayList<>();\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\n\t\t\t// @formatter:off\n\t\t\tMethod[] localInterfaceMethods = getMethods(ifc).stream()\n\t\t\t\t\t.filter(m -> !isAbstract(m))\n\t\t\t\t\t.toArray(Method[]::new);\n\n\t\t\tMethod[] superinterfaceMethods = getInterfaceMethods(ifc, traversalMode).stream()\n\t\t\t\t\t.filter(method -> isNotOverriddenByLocalMethods(method, localInterfaceMethods))\n\t\t\t\t\t.toArray(Method[]::new);\n\t\t\t// @formatter:on\n\n\t\t\tif (traversalMode == TOP_DOWN) {\n\t\t\t\tCollections.addAll(allInterfaceMethods, superinterfaceMethods);\n\t\t\t}\n\t\t\tCollections.addAll(allInterfaceMethods, localInterfaceMethods);\n\t\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\t\tCollections.addAll(allInterfaceMethods, superinterfaceMethods);\n\t\t\t}\n\t\t}\n\t\treturn allInterfaceMethods;\n\t}\n\n\tprivate static List<Field> getInterfaceFields(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tList<Field> allInterfaceFields = new ArrayList<>();\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tField[] localInterfaceFields = ifc.getFields();\n\t\t\tArrays.sort(localInterfaceFields, ReflectionUtils::defaultFieldSorter);\n\n\t\t\t// @formatter:off\n\t\t\tField[] superinterfaceFields = getInterfaceFields(ifc, traversalMode).stream()\n\t\t\t\t\t.filter(field -> isNotShadowedByLocalFields(field, localInterfaceFields))\n\t\t\t\t\t.toArray(Field[]::new);\n\t\t\t// @formatter:on\n\n\t\t\tif (traversalMode == TOP_DOWN) {\n\t\t\t\tCollections.addAll(allInterfaceFields, superinterfaceFields);\n\t\t\t}\n\t\t\tCollections.addAll(allInterfaceFields, localInterfaceFields);\n\t\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\t\tCollections.addAll(allInterfaceFields, superinterfaceFields);\n\t\t\t}\n\t\t}\n\t\treturn allInterfaceFields;\n\t}\n\n\tprivate static List<Field> getSuperclassFields(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (!isSearchable(superclass)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn findAllFieldsInHierarchy(superclass, traversalMode);\n\t}\n\n\tprivate static boolean isNotShadowedByLocalFields(Field field, Field[] localFields) {\n\t\tif (useLegacySearchSemantics) {\n\t\t\tfor (Field local : localFields) {\n\t\t\t\tif (local.getName().equals(field.getName())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static List<Method> getSuperclassMethods(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (!isSearchable(superclass)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn findAllMethodsInHierarchy(superclass, traversalMode);\n\t}\n\n\tprivate static boolean isNotOverriddenByLocalMethods(Method method, Method[] localMethods) {\n\t\tfor (Method local : localMethods) {\n\t\t\tif (isMethodOverriddenBy(method, local)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static boolean isMethodOverriddenBy(Method upper, Method lower) {\n\t\t// If legacy search semantics are enabled, skip to hasCompatibleSignature() check.\n\t\tif (!useLegacySearchSemantics) {\n\t\t\t// A static method cannot override anything.\n\t\t\tif (Modifier.isStatic(lower.getModifiers())) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Cannot override a private, static, or final method.\n\t\t\tint modifiers = upper.getModifiers();\n\t\t\tif (Modifier.isPrivate(modifiers) || Modifier.isStatic(modifiers) || Modifier.isFinal(modifiers)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Cannot override a package-private method in another package.\n\t\t\tif (isPackagePrivate(upper) && !declaredInSamePackage(upper, lower)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn hasCompatibleSignature(upper, lower.getName(), lower.getParameterTypes());\n\t}\n\n\tprivate static boolean isPackagePrivate(Member member) {\n\t\tint modifiers = member.getModifiers();\n\t\treturn !(Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers) || Modifier.isPrivate(modifiers));\n\t}\n\n\tprivate static boolean declaredInSamePackage(Method m1, Method m2) {\n\t\treturn getPackageName(m1.getDeclaringClass()).equals(getPackageName(m2.getDeclaringClass()));\n\t}\n\n\tprivate static boolean hasCompatibleSignature(Method candidate, String methodName, Class<?>[] parameterTypes) {\n\t\tif (!methodName.equals(candidate.getName())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (parameterTypes.length != candidate.getParameterCount()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?>[] candidateParameterTypes = candidate.getParameterTypes();\n\t\t// trivial case: parameter types exactly match\n\t\tif (Arrays.equals(parameterTypes, candidateParameterTypes)) {\n\t\t\treturn true;\n\t\t}\n\t\t// param count is equal, but types do not match exactly: check for method sub-signatures\n\t\t// https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.2\n\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\tClass<?> lowerType = parameterTypes[i];\n\t\t\tClass<?> upperType = candidateParameterTypes[i];\n\t\t\tif (!upperType.isAssignableFrom(lowerType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t// lower is sub-signature of upper: check for generics in upper method\n\t\tif (isGeneric(candidate)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean isGeneric(Method method) {\n\t\treturn isGeneric(method.getGenericReturnType())\n\t\t\t\t|| Arrays.stream(method.getGenericParameterTypes()).anyMatch(ReflectionUtils::isGeneric);\n\t}\n\n\tprivate static boolean isGeneric(Type type) {\n\t\treturn type instanceof TypeVariable || type instanceof GenericArrayType;\n\t}\n\n\t@API(status = INTERNAL, since = \"1.11\")\n\t@SuppressWarnings(\"deprecation\") // \"AccessibleObject.isAccessible()\" is deprecated in Java 9\n\tpublic static <T extends Executable> T makeAccessible(T executable) {\n\t\tif ((!isPublic(executable) || !isPublic(executable.getDeclaringClass())) && !executable.isAccessible()) {\n\t\t\texecutable.setAccessible(true);\n\t\t}\n\t\treturn executable;\n\t}\n\n\t@API(status = INTERNAL, since = \"1.12\")\n\t@SuppressWarnings(\"deprecation\") // \"AccessibleObject.isAccessible()\" is deprecated in Java 9\n\tpublic static Field makeAccessible(Field field) {\n\t\tif ((!isPublic(field) || !isPublic(field.getDeclaringClass()) || isFinal(field)) && !field.isAccessible()) {\n\t\t\tfield.setAccessible(true);\n\t\t}\n\t\treturn field;\n\t}\n\n\tpublic static Set<Class<?>> getAllAssignmentCompatibleClasses(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\n\t\tSet<Class<?>> result = new LinkedHashSet<>();\n\t\tgetAllAssignmentCompatibleClasses(clazz, result);\n\t\treturn result;\n\t}\n\n\tprivate static void getAllAssignmentCompatibleClasses(Class<?> clazz, Set<Class<?>> result) {\n\t\tfor (Class<?> current = clazz; current != null; current = current.getSuperclass()) {\n\t\t\tresult.add(current);\n\t\t\tfor (Class<?> interfaceClass : current.getInterfaces()) {\n\t\t\t\tif (!result.contains(interfaceClass)) {\n\t\t\t\t\tgetAllAssignmentCompatibleClasses(interfaceClass, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static boolean isSearchable(Class<?> clazz) {\n\t\treturn (clazz != null && clazz != Object.class);\n\t}\n\n\tprivate static Throwable getUnderlyingCause(Throwable t) {\n\t\tif (t instanceof InvocationTargetException) {\n\t\t\treturn getUnderlyingCause(((InvocationTargetException) t).getTargetException());\n\t\t}\n\t\treturn t;\n\t}\n\n\tprivate static boolean getLegacySearchSemanticsFlag() {\n\t\tString rawValue = System.getProperty(USE_LEGACY_SEARCH_SEMANTICS_PROPERTY_NAME);\n\t\tif (StringUtils.isBlank(rawValue)) {\n\t\t\treturn false;\n\t\t}\n\t\tString value = rawValue.trim().toLowerCase();\n\t\tboolean isTrue = \"true\".equals(value);\n\t\tPreconditions.condition(isTrue || \"false\".equals(value), () -> USE_LEGACY_SEARCH_SEMANTICS_PROPERTY_NAME\n\t\t\t\t+ \" property must be 'true' or 'false' (ignoring case): \" + rawValue);\n\t\treturn isTrue;\n\t}\n\n\tprivate interface Visitor<T> {\n\n\t\tboolean accept(T value);\n\n\t}\n\n}",
        "human_comment": "@return {@code true} if the visitor should continue searching;\n{@code false} if the visitor should stop",
        "model_generated_comment": "Parses the fully qualified method name from the supplied class name.\n\n@param fullyQualifiedMethodName the name of the method to parse; never {@code null} or blank\n@return a fully qualified {@linkplain String}\n@see #parseFullyQualifiedFieldName(String)"
    },
    {
        "id": 549,
        "code_snippet": "private static Method getPublicMethod(Class<?> clazz, String name, Class<?>... paramTypes) {\n        // if this class is public, then try to get it\n        if ((clazz.getModifiers() & Modifier.PUBLIC) != 0) {\n            try {\n                return clazz.getMethod(name, paramTypes);\n            } catch (NoSuchMethodException e) {\n                // If the class does not have the method, then neither its superclass\n                // nor any of its interfaces has it so quickly return null.\n                return null;\n            }\n        }\n\n        //  try the superclass\n        Class<?> superclazz = clazz.getSuperclass();\n\n        if (superclazz != null) {\n            Method superclazzMethod = getPublicMethod(superclazz, name, paramTypes);\n\n            if (superclazzMethod != null) {\n                return superclazzMethod;\n            }\n        }\n\n        // and interfaces\n        Class<?>[] interfaces = clazz.getInterfaces();\n\n        for (Class<?> anInterface : interfaces) {\n            Method interfaceMethod = getPublicMethod(anInterface, name, paramTypes);\n\n            if (interfaceMethod != null) {\n                return interfaceMethod;\n            }\n        }\n\n        return null;\n    }",
        "human_comment": "Looks up the method with specified name and signature in the first public\nsuperclass or implemented interface of the class.\n\n@param clazz      the class whose method is sought\n@param name       the name of the method\n@param paramTypes the classes of method parameters",
        "model_generated_comment": "Returns the public method for the given class.\n\n@param name the name of the class\n@return The public method, never {@code null}."
    },
    {
        "id": 550,
        "code_snippet": "static ProjectBuilderRequest build(@Nonnull Session session, @Nonnull Path path) {\n        return builder()\n                .session(requireNonNull(session, \"session cannot be null\"))\n                .path(requireNonNull(path, \"path cannot be null\"))\n                .build();\n    }",
        "human_comment": "Creates a new ProjectBuilderRequest with the specified session and path.\n\n@param session the Maven session\n@param path the path to the project to build\n@return a new ProjectBuilderRequest\n@throws NullPointerException if session or path is null",
        "model_generated_comment": "Creates a new ProjectBuilderRequest with the specified session and path.\n\n@param session The session to build the project, may be {@code null}."
    },
    {
        "id": 551,
        "code_snippet": "public static void disableRecoveryOfApp(String appId) {\n    Preconditions.checkNotNull(appId);\n    INSTANCE.appsWithRecoveryDisabled.add(appId);\n  }",
        "human_comment": "Add an application for which recovery is disabled.\n@param appId application id",
        "model_generated_comment": "Disable the recovery of the supplied app.\n\n@param appId the app ID to disable."
    },
    {
        "id": 552,
        "code_snippet": "public Builder filter(MetricFilter filter) {\n            this.filter = filter;\n            return this;\n        }",
        "human_comment": "Only report metrics which match the given filter.\n\n@param filter a {@link MetricFilter}\n@return {@code this}",
        "model_generated_comment": "Creates a new {@link MetricFilter} with the specified filter.\n\n@param filter The filter to use, may be {@code null}.\n@return this builder"
    },
    {
        "id": 553,
        "code_snippet": "public long getTotalMemoryConsumption() {\n    long totalDataPagesSize = 0L;\n    for (MemoryBlock dataPage : dataPages) {\n      totalDataPagesSize += dataPage.size();\n    }\n    return totalDataPagesSize + ((longArray != null) ? longArray.memoryBlock().size() : 0L);\n  }",
        "human_comment": "Returns the total amount of memory, in bytes, consumed by this map's managed structures.",
        "model_generated_comment": "Returns the total memory consumption of the data pages.\n\n@param dataPages The data pages to be consumed, may be {@code null}."
    },
    {
        "id": 554,
        "code_snippet": "public static void assertEquals(Short expected, Short actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@link Assertion#equals(Object)}\n\n@since 5.4"
    },
    {
        "id": 555,
        "code_snippet": "public void setProjectBuildingRequest(ProjectBuildingRequest projectBuildingRequest) {\n        this.projectBuilderConfiguration = projectBuildingRequest;\n    }",
        "human_comment": "Sets the project building request from which this project instance was created. <strong>Warning:</strong> This is\na utility method that is meant to assist integrators of Maven, it must not be used by Maven plugins.\n\n@param projectBuildingRequest The project building request, may be {@code null}.\n@since 2.1",
        "model_generated_comment": "Set the project building request.\n\n@param projectBuildingRequest The request to set."
    },
    {
        "id": 556,
        "code_snippet": "public static String replaceIsoControlCharacters(String str, String replacement) {\n\t\tPreconditions.notNull(replacement, \"replacement must not be null\");\n\t\treturn str == null ? null : ISO_CONTROL_PATTERN.matcher(str).replaceAll(replacement);\n\t}",
        "human_comment": "Replace all ISO control characters in the supplied {@link String}.\n\n@param str the string in which to perform the replacement; may be {@code null}\n@param replacement the replacement string; never {@code null}\n@return the supplied string with all control characters replaced, or\n{@code null} if the supplied string was {@code null}\n@since 1.4",
        "model_generated_comment": "Create a new {@link String} with the supplied characters.\n\n@param str the string to replace; never {@code null}"
    },
    {
        "id": 557,
        "code_snippet": "public ParallelExecutionConfiguration createConfiguration(ConfigurationParameters configurationParameters) {\n\t\t\tBigDecimal factor = configurationParameters.get(CONFIG_DYNAMIC_FACTOR_PROPERTY_NAME,\n\t\t\t\tBigDecimal::new).orElse(BigDecimal.ONE);\n\n\t\t\tPreconditions.condition(factor.compareTo(BigDecimal.ZERO) > 0,\n\t\t\t\t() -> String.format(\"Factor '%s' specified via configuration parameter '%s' must be greater than 0\",\n\t\t\t\t\tfactor, CONFIG_DYNAMIC_FACTOR_PROPERTY_NAME));\n\n\t\t\tint parallelism = Math.max(1,\n\t\t\t\tfactor.multiply(BigDecimal.valueOf(Runtime.getRuntime().availableProcessors())).intValue());\n\n\t\t\tint maxPoolSize = configurationParameters.get(CONFIG_DYNAMIC_MAX_POOL_SIZE_FACTOR_PROPERTY_NAME,\n\t\t\t\tBigDecimal::new).map(maxPoolSizeFactor -> {\n\t\t\t\t\tPreconditions.condition(maxPoolSizeFactor.compareTo(BigDecimal.ONE) >= 0,\n\t\t\t\t\t\t() -> String.format(\n\t\t\t\t\t\t\t\"Factor '%s' specified via configuration parameter '%s' must be greater than or equal to 1\",\n\t\t\t\t\t\t\tfactor, CONFIG_DYNAMIC_MAX_POOL_SIZE_FACTOR_PROPERTY_NAME));\n\t\t\t\t\treturn maxPoolSizeFactor.multiply(BigDecimal.valueOf(parallelism)).intValue();\n\t\t\t\t}).orElseGet(() -> 256 + parallelism);\n\n\t\t\tboolean saturate = configurationParameters.get(CONFIG_DYNAMIC_SATURATE_PROPERTY_NAME,\n\t\t\t\tBoolean::valueOf).orElse(true);\n\n\t\t\treturn new DefaultParallelExecutionConfiguration(parallelism, parallelism, maxPoolSize, parallelism,\n\t\t\t\tKEEP_ALIVE_SECONDS, __ -> saturate);\n\t\t}",
        "human_comment": "Computes the desired parallelism based on the number of available\nprocessors/cores multiplied by the {@value #CONFIG_DYNAMIC_FACTOR_PROPERTY_NAME}\nconfiguration parameter.",
        "model_generated_comment": "Create a new ParallelExecutionConfiguration with the supplied configuration parameters.\n\n@param configurationParameters configurationParameters the configuration parameters to create the configuration; never {@code null}\n@return the new configuration"
    },
    {
        "id": 558,
        "code_snippet": "public void beforeEach(ExtensionContext context) {\n\t\tinstallFailureTracker(context);\n\t\tcontext.getRequiredTestInstances().getAllInstances() //\n\t\t\t\t.forEach(instance -> injectInstanceFields(context, instance));\n\t}",
        "human_comment": "Perform field injection for non-private, non-static fields (i.e.,\ninstance fields) of type {@link Path} or {@link File} that are annotated\nwith {@link TempDir @TempDir}.",
        "model_generated_comment": "Unit tests for {@link ExtensionContext}.\n\n@since 5.0"
    },
    {
        "id": 559,
        "code_snippet": "public static void assertEquals(short expected, short actual) {\n        Assert.assertEquals(expected, actual);\n    }",
        "human_comment": "Asserts that two shorts are equal.",
        "model_generated_comment": "Asserts that two short {@code expected} are equal. If they are not they are considered equal."
    },
    {
        "id": 560,
        "code_snippet": "Model transformFileToRaw(Model model) {\n            if (model.getDependencies().isEmpty()) {\n                return model;\n            }\n            List<Dependency> newDeps = new ArrayList<>(model.getDependencies().size());\n            boolean changed = false;\n            for (Dependency dep : model.getDependencies()) {\n                Dependency newDep = null;\n                if (dep.getVersion() == null) {\n                    newDep = inferDependencyVersion(model, dep);\n                    if (newDep != null) {\n                        changed = true;\n                    }\n                }\n                newDeps.add(newDep == null ? dep : newDep);\n            }\n            return changed ? model.withDependencies(newDeps) : model;\n        }",
        "human_comment": "Transform raw model to build pom.\nInfer inner reactor dependencies version",
        "model_generated_comment": "Transform the file to Raw.\n\n@param model The model to transform, may be {@code null}."
    },
    {
        "id": 561,
        "code_snippet": "public String toString() {\n        return fFailedTest + \": \" + fThrownException.getMessage();\n    }",
        "human_comment": "Returns a short description of the failure.",
        "model_generated_comment": "Returns a string representation of the given test.\n\n@param String the string representation"
    },
    {
        "id": 562,
        "code_snippet": "public static Stream<? extends DiscoverySelector> parseAll(Collection<DiscoverySelectorIdentifier> identifiers) {\n\t\treturn DiscoverySelectorIdentifierParsers.parseAll(identifiers);\n\t}",
        "human_comment": "Parse the supplied {@link DiscoverySelectorIdentifier\nDiscoverySelectorIdentifiers}.\n\n@param identifiers the {@code DiscoverySelectorIdentifiers} to parse;\nnever {@code null}\n@return a stream of the corresponding {@link DiscoverySelector DiscoverySelectors};\nnever {@code null} but potentially empty\n@since 1.11\n@see DiscoverySelectorIdentifierParser",
        "model_generated_comment": "Returns a stream of {@link DiscoverySelectorIdentifier} identifiers.\n\n@param identifiers the identifiers to parse; never {@code null}\n@return a stream containing all of the identifiers; never{@code blank}"
    },
    {
        "id": 563,
        "code_snippet": "protected String processArguments(String[] args) {\n        String suiteName = null;\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].equals(\"-noloading\")) {\n                setLoading(false);\n            } else if (args[i].equals(\"-nofilterstack\")) {\n                fgFilterStack = false;\n            } else if (args[i].equals(\"-c\")) {\n                if (args.length > i + 1) {\n                    suiteName = extractClassName(args[i + 1]);\n                } else {\n                    System.out.println(\"Missing Test class name\");\n                }\n                i++;\n            } else {\n                suiteName = args[i];\n            }\n        }\n        return suiteName;\n    }",
        "human_comment": "Processes the command line arguments and\nreturns the name of the suite class to run or null",
        "model_generated_comment": "Sets the name of the test class.\n\n@param args The args to process, may be {@code null}."
    },
    {
        "id": 564,
        "code_snippet": "private Mapper() {\n    throw new UnsupportedOperationException(\n        \"Mapper is a utility class and cannot be instantiated.\");\n  }",
        "human_comment": "The Mapper class is responsible for processing an input string and generating a map of word\noccurrences.",
        "model_generated_comment": "Creates a new {@link Mapper} instance.\n\n@param Mapper the Mapper instance\n@throws UnsupportedOperationException"
    },
    {
        "id": 565,
        "code_snippet": "@Override public void merge(MutableAggregationBuffer buffer1, Row buffer2) {\n    if (!buffer2.isNullAt(0)) {\n      if (buffer1.isNullAt(0)) {\n        buffer1.update(0, buffer2.getDouble(0));\n      } else {\n        Double newValue = buffer2.getDouble(0) + buffer1.getDouble(0);\n        buffer1.update(0, newValue);\n      }\n    }\n  }",
        "human_comment": "buffer1 and buffer2 have the same structure.\nWe only update the buffer1 when the input buffer2's value is not null.\nIf the buffer value (intermediate result of the sum) is still null,\nwe set the it as the input buffer's value.\nOtherwise, we add the input buffer's value (buffer1) to the mutable\nbuffer's value (buffer2).",
        "model_generated_comment": "Merges the buffer into a single buffer.\n\n@param buffer1 The buffer to merge into, may be {@code null}."
    },
    {
        "id": 566,
        "code_snippet": "public Scope withName(String opName) {\n    return new Scope(env, nameScope.withName(opName), controlDependencies);\n  }",
        "human_comment": "Return a new scope that uses the provided name for an op.\n\n<p>Operations created within this scope will have a name of the form {@code\nname/opName[_suffix]}. This lets you name a specific operator more meaningfully.\n\n<p>Names must match the regular expression {@code [A-Za-z0-9.][A-Za-z0-9_.\\-]*}\n\n@param opName name for an operator in the returned scope\n@return a new Scope that uses opName for operations.\n@throws IllegalArgumentException if the name is invalid",
        "model_generated_comment": "Creates a new {@link Scope} with the given name.\n\n@param opName the name of the {@code Scope} to use."
    },
    {
        "id": 567,
        "code_snippet": "public static Optional<Method> findMethod(Class<?> clazz, String methodName, String parameterTypeNames) {\n\t\treturn ReflectionUtils.findMethod(clazz, methodName, parameterTypeNames);\n\t}",
        "human_comment": "Find the first {@link Method} of the supplied class or interface that\nmeets the specified criteria, beginning with the specified class or\ninterface and traversing up the type hierarchy until such a method is\nfound or the type hierarchy is exhausted.\n\n<p>As of JUnit Platform 1.10, this method uses the {@link ClassLoader} of\nthe supplied {@code clazz} to load parameter types instead of using the\n<em>default</em> {@code ClassLoader}, which allows parameter types to be\nresolved in different {@code ClassLoader} arrangements.\n\n<p>The algorithm does not search for methods in {@link java.lang.Object}.\n\n@param clazz the class or interface in which to find the method; never {@code null}\n@param methodName the name of the method to find; never {@code null} or empty\n@param parameterTypeNames the fully qualified names of the types of parameters\naccepted by the method, if any, provided as a comma-separated list\n@return an {@code Optional} containing the method found; never {@code null}\nbut potentially empty if no such method could be found\n@see #findMethod(Class, String, Class...)",
        "model_generated_comment": "Find a {@link Optional} for the given class.\n\n@param clazz the class to find; never {@code null} or blank\n@return an Optional with the same name as the class\n@see #findMethod(Class)"
    },
    {
        "id": 568,
        "code_snippet": "public AlbumPage changeNumberOfSongs(int numberOfSongs) {\n    var numberOfSongsNumberField = (HtmlNumberInput) page.getElementById(\"numberOfSongs\");\n    numberOfSongsNumberField.setText(Integer.toString(numberOfSongs));\n    return this;\n  }",
        "human_comment": "Sets the number of songs number input field.\n\n@param numberOfSongs the new number of songs value to be set\n@return {@link AlbumPage}",
        "model_generated_comment": "Change the number of songs in the AlbumPage.\n\n@param numberOfSongs the number to change\n@return this AlbumPage"
    },
    {
        "id": 569,
        "code_snippet": "public Object exists(List<Object> args) {\n        if (args.size() != 1) {\n            throw new IllegalArgumentException(\"exists function requires exactly one argument\");\n        }\n        String path = ConditionParser.toString(args.get(0));\n        return context.exists(path, true);\n    }",
        "human_comment": "Checks if a file or directory exists at the given path.\n\n@param args A list containing a single string argument representing the path\n@return {@code true} if the file or directory exists, {@code false} otherwise\n@throws IllegalArgumentException if the number of arguments is not exactly one\n@throws ModelBuilderException if a problem occurs while walking the file system\n@throws InterpolatorException if an error occurs during interpolation",
        "model_generated_comment": "Returns whether the given object exists.\n\n@param args The list of arguments to check\n@return true if the object exists\n@throws IllegalArgumentException if the argument is not exactly one"
    },
    {
        "id": 570,
        "code_snippet": "static Injector create() {\n        return new InjectorImpl();\n    }",
        "human_comment": "Creates a new Injector instance with default settings.\n\n@return a new Injector instance",
        "model_generated_comment": "Creates a new {@link Injector} object.\n\n@param injector"
    },
    {
        "id": 571,
        "code_snippet": "public void setPassword(String password) {\n        this.password = password;\n    }",
        "human_comment": "Set the user's password which is used when connecting to the repository.\n\n@param password password of the user",
        "model_generated_comment": "Set the password of the user.\n\n@param password the password to set."
    },
    {
        "id": 572,
        "code_snippet": "public void deactivateRequiredProject(String selector) {\n        this.activations.add(new ProjectActivationSettings(selector, ActivationSettings.deactivated()));\n    }",
        "human_comment": "Mark a project as required and deactivated.\n@param selector The selector of the project.",
        "model_generated_comment": "Deactivate theRequired Project.\n\n@param selector the selector to deactivate.\n@return TheRequired Project"
    },
    {
        "id": 573,
        "code_snippet": "public static Condition<Event> nestedContainer(Class<?> clazz, Condition<Event> condition) {\n\t\treturn allOf(nestedContainer(clazz), condition);\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if an\n{@linkplain Event#getTestDescriptor() test descriptor} is\na {@linkplain TestDescriptor#isContainer() container}, and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the\nsimple names of the supplied {@link Class} and all of its\n{@linkplain Class#getEnclosingClass() enclosing classes}.\n\n<p>For example, {@code nestedContainer(MyNestedTests.class, displayName(\"my display name\"))}\ncan be used to match against a nested container with the given display name.\n\n<p>Please note that this method does not differentiate between static\nnested classes and non-static member classes (e.g., inner classes).\n\n@since 1.8\n@see #nestedContainer(Class)",
        "model_generated_comment": "Create a new {@link Condition} for the supplied container.\n\n@param clazz the container to use; never {@code null}"
    },
    {
        "id": 574,
        "code_snippet": "public void beforeAllMethodsExecuted(boolean beforeAllMethodsExecuted) {\n\t\tthis.beforeAllMethodsExecuted = beforeAllMethodsExecuted;\n\t}",
        "human_comment": "Track that an attempt was made to execute {@code @BeforeAll} methods.",
        "model_generated_comment": "Create a new {@link BeforeAllMethodsExecuted} for the supplied method.\n\n<p>The method must not be {@code null}.\n\n@since 5.4"
    },
    {
        "id": 575,
        "code_snippet": "record TransferResourceIdentifier(String repositoryId, String repositoryUrl, String resourceName, @Nullable File file) {\n    TransferResourceIdentifier(TransferResource resource) {\n        this(resource.getRepositoryId(), resource.getRepositoryUrl(), resource.getResourceName(), resource.getFile());\n    }\n}",
        "human_comment": "Immutable identifier of a {@link TransferResource}.\nThe {@link TransferResource} is not immutable and does not implement {@code Objects#equals} and {@code Objects#hashCode} methods,\nmaking it not very suitable for usage in collections.",
        "model_generated_comment": "Create a {@link TransferResourceIdentifier} for the given resource.\n\n@param repositoryId The repository ID of the resource, may be {@code null}."
    },
    {
        "id": 576,
        "code_snippet": "public static ResolverTrace enter(Session session, Object data) {\n        InternalSession iSession = InternalSession.from(session);\n        org.apache.maven.api.services.RequestTrace trace = data instanceof Request<?> req && req.getTrace() != null\n                ? req.getTrace()\n                : new org.apache.maven.api.services.RequestTrace(iSession.getCurrentTrace(), data);\n        iSession.setCurrentTrace(trace);\n        return new ResolverTrace(session, trace.context(), toResolver(trace), trace);\n    }",
        "human_comment": "Creates a new trace entry and updates the session's current trace\n@param session The current Maven session\n@param data The data object to associate with the trace\n@return A new ResolverTrace containing both Maven and Resolver trace information",
        "model_generated_comment": "Create a new {@link ResolverTrace} for the supplied session.\n\n@param session The session to enter, may be {@code null}."
    },
    {
        "id": 577,
        "code_snippet": "public void checkAuthorization(TransportClient client, long streamId) { }",
        "human_comment": "Verify that the client is authorized to read from the given stream.\n\n@throws SecurityException If client is not authorized.",
        "model_generated_comment": "Check the authorization of the TransportClient.\n\n@param client the client to check; never {@code null}"
    },
    {
        "id": 578,
        "code_snippet": "public static synchronized PhaseId of(String phase) {\n        return INSTANCES.computeIfAbsent(phase, PhaseId::new);\n    }",
        "human_comment": "Parses the phase identifier.\n\n@param phase the phase identifier.\n@return the {@link PhaseId}.",
        "model_generated_comment": "Creates a new {@link PhaseId} of the given phase.\n\n@param phase the phase ID of the new phase."
    },
    {
        "id": 579,
        "code_snippet": "public UTF8String makeValid() {\n    if (isValid()) return this;\n    return UTF8String.fromBytes(makeValidBytes());\n  }",
        "human_comment": "Returns a validated version of the current UTF-8 string by replacing invalid UTF-8 sequences\nwith the Unicode replacement character (U+FFFD), as per the rules defined in the Unicode\nstandard 15, Section 3.9, Paragraph D86, Table 3-7. This behaviour is consistent with the\nbehaviour of `UnicodeString` in ICU4C.\n\n@return A new UTF8String that is a valid UTF8 string.",
        "model_generated_comment": "Make valid UTF8 string.\n\n@param makeValidBytes\n@return this string"
    },
    {
        "id": 580,
        "code_snippet": "public static DoubleBuffer allocateDoubleBuffer(int numElements) {\n    return ByteBuffer.allocateDirect(numElements * DOUBLE_SIZE_BYTES)\n        .order(ByteOrder.nativeOrder())\n        .asDoubleBuffer();\n  }",
        "human_comment": "Allocates a new direct {@link java.nio.DoubleBuffer} with native byte order with specified\n\n@param numElements capacity (number of elements) of result buffer.",
        "model_generated_comment": "Allocate a double buffer.\n\n@param numElements The number of bytes to allocate."
    },
    {
        "id": 581,
        "code_snippet": "public static ByteBuffer stringToBytes(String s) {\n    return ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8));\n  }",
        "human_comment": "Convert the given string to a byte buffer. The resulting buffer can be\nconverted back to the same string through {@link #bytesToString(ByteBuffer)}.",
        "model_generated_comment": "Returns the string to bytes.\n\n@param s The string to put into the buffer."
    },
    {
        "id": 582,
        "code_snippet": "public static int hashUnsafeBytes2(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes >= 0): \"lengthInBytes cannot be negative\";\n    int lengthAligned = lengthInBytes - lengthInBytes % 4;\n    int h1 = hashBytesByInt(base, offset, lengthAligned, seed);\n    int k1 = 0;\n    for (int i = lengthAligned, shift = 0; i < lengthInBytes; i++, shift += 8) {\n      k1 ^= (Platform.getByte(base, offset + i) & 0xFF) << shift;\n    }\n    h1 ^= mixK1(k1);\n    return fmix(h1, lengthInBytes);\n  }",
        "human_comment": "This is compatible with original and another implementations.\nUse this method for new components after Spark 2.3.",
        "model_generated_comment": "Creates a new hash of bytes.\n\n@param base the base of the hash, may be {@code 0xFF}."
    },
    {
        "id": 583,
        "code_snippet": "public Object parse(String expression) {\n        this.tokens = tokenize(expression);\n        this.current = 0;\n        return parseExpression();\n    }",
        "human_comment": "Parses the given expression and returns the result of the evaluation.\n\n@param expression the expression to be parsed\n@return the result of parsing and evaluating the expression",
        "model_generated_comment": "Parses the given expression.\n\n@param expression The expression to parse.\n@return The parsed expression."
    },
    {
        "id": 584,
        "code_snippet": "public static UTF8String getSparkVersion() {\n    String shortVersion = VersionUtils.shortVersion(SparkBuildInfo.spark_version());\n    String revision = SparkBuildInfo.spark_revision();\n    return UTF8String.fromString(shortVersion + \" \" + revision);\n  }",
        "human_comment": "Function to return the Spark version.\n@return\nSpace separated version and revision.",
        "model_generated_comment": "Returns a UTF8 string with the given version.\n\n@param shortVersion The version of the Spark."
    },
    {
        "id": 585,
        "code_snippet": "public String aggregateTaskMetrics(long[] taskMetrics) {\n    if (taskMetrics.length > 0) {\n      long sum = 0L;\n      for (long taskMetric : taskMetrics) {\n        sum += taskMetric;\n      }\n      double average = ((double) sum) / taskMetrics.length;\n      return new DecimalFormat(\"#0.000\").format(average);\n    } else {\n      return \"0\";\n    }\n  }",
        "human_comment": "Built-in `CustomMetric` that computes average of metric values. Note that please extend this\nclass and override `name` and `description` to create your custom metric for real usage.\n\n@since 3.2.0",
        "model_generated_comment": "Returns the aggregate task metrics of the given task.\n\n@param taskMetrics The task metrics to check, may be {@code null}."
    },
    {
        "id": 586,
        "code_snippet": "public void setOrder(Object rule, int order) {\n        orderValues.put(rule, order);\n    }",
        "human_comment": "Sets order value for the specified rule.",
        "model_generated_comment": "Sets the order values of the given object.\n\n@param rule The rule to set."
    },
    {
        "id": 587,
        "code_snippet": "default void testDisabled(ExtensionContext context, Optional<String> reason) {\n\t\t/* no-op */\n\t}",
        "human_comment": "Invoked after a disabled test has been skipped.\n\n<p>The default implementation does nothing. Concrete implementations can\noverride this method as appropriate.\n\n@param context the current extension context; never {@code null}\n@param reason the reason the test is disabled; never {@code null} but\npotentially <em>empty</em>",
        "model_generated_comment": "Unit tests for {@link TestDisabled(ExtensionContext)}.\n\n@param context the context of the test; may be {@code null}.\n@since 5.4"
    },
    {
        "id": 588,
        "code_snippet": "static Object asSerializableValue(Object value) {\n        if (value == null || value instanceof Serializable) {\n            return value;\n        } else {\n            return new SerializableValueDescription(value);\n        }\n    }",
        "human_comment": "Factory method that checks to see if the value is already serializable.\n@param value the value to make serializable\n@return The provided value if it is null or already serializable,\nthe SerializableValueDescription representation of it if it is not.",
        "model_generated_comment": "Returns the Serializable value for the given object.\n\n@param value the value to return\n@return The SerializableValue"
    },
    {
        "id": 589,
        "code_snippet": "public void testwithColumns() {\n    Dataset<Row> df = spark.table(\"testData2\");\n    Map<String, Column> colMaps = new HashMap<>();\n    colMaps.put(\"a1\", col(\"a\"));\n    colMaps.put(\"b1\", col(\"b\"));\n\n    StructType expected = df.withColumn(\"a1\", col(\"a\")).withColumn(\"b1\", col(\"b\")).schema();\n    StructType actual = df.withColumns(colMaps).schema();\n    Assertions.assertEquals(expected, actual);\n    Assertions.assertArrayEquals(actual.fieldNames(), new String[] {\"a\", \"b\", \"a1\", \"b1\"});\n\n  @Test\n  public void testSampleByColumn() {\n    Dataset<Row> df = spark.range(0, 100, 1, 2).select(col(\"id\").mod(3).as(\"key\"));\n    Dataset<Row> sampled = df.stat().sampleBy(col(\"key\"), ImmutableMap.of(0, 0.1, 1, 0.2), 0L);\n    List<Row> actual = sampled.groupBy(\"key\").count().orderBy(\"key\").collectAsList();\n    Assertions.assertEquals(0, actual.get(0).getLong(0));\n    Assertions.assertTrue(0 <= actual.get(0).getLong(1) && actual.get(0).getLong(1) <= 8);\n    Assertions.assertEquals(1, actual.get(1).getLong(0));\n    Assertions.assertTrue(2 <= actual.get(1).getLong(1) && actual.get(1).getLong(1) <= 13);\n  }\n\n  @Test\n  public void pivot() {\n    Dataset<Row> df = spark.table(\"courseSales\");\n    List<Row> actual = df.groupBy(\"year\")\n      .pivot(\"course\", Arrays.asList(\"dotNET\", \"Java\"))\n      .agg(sum(\"earnings\")).orderBy(\"year\").collectAsList();\n\n    Assertions.assertEquals(2012, actual.get(0).getInt(0));\n    Assertions.assertEquals(15000.0, actual.get(0).getDouble(1), 0.01);\n    Assertions.assertEquals(20000.0, actual.get(0).getDouble(2), 0.01);\n\n    Assertions.assertEquals(2013, actual.get(1).getInt(0));\n    Assertions.assertEquals(48000.0, actual.get(1).getDouble(1), 0.01);\n    Assertions.assertEquals(30000.0, actual.get(1).getDouble(2), 0.01);\n  }\n\n  @Test\n  public void pivotColumnValues() {\n    Dataset<Row> df = spark.table(\"courseSales\");\n    List<Row> actual = df.groupBy(\"year\")\n      .pivot(col(\"course\"), Arrays.asList(lit(\"dotNET\"), lit(\"Java\")))\n      .agg(sum(\"earnings\")).orderBy(\"year\").collectAsList();\n\n    Assertions.assertEquals(2012, actual.get(0).getInt(0));\n    Assertions.assertEquals(15000.0, actual.get(0).getDouble(1), 0.01);\n    Assertions.assertEquals(20000.0, actual.get(0).getDouble(2), 0.01);\n\n    Assertions.assertEquals(2013, actual.get(1).getInt(0));\n    Assertions.assertEquals(48000.0, actual.get(1).getDouble(1), 0.01);\n    Assertions.assertEquals(30000.0, actual.get(1).getDouble(2), 0.01);\n  }\n\n  private String getResource(String resource) {\n    try {\n      URL url = Thread.currentThread().getContextClassLoader().getResource(resource);\n      return url.toURI().getPath();\n    } catch (URISyntaxException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Test\n  public void testGenericLoad() {\n    Dataset<Row> df1 = spark.read().format(\"text\").load(getResource(\"test-data/text-suite.txt\"));\n    Assertions.assertEquals(4L, df1.count());\n\n    Dataset<Row> df2 = spark.read().format(\"text\").load(\n      getResource(\"test-data/text-suite.txt\"),\n      getResource(\"test-data/text-suite2.txt\"));\n    Assertions.assertEquals(5L, df2.count());\n  }\n\n  @Test\n  public void testTextLoad() {\n    Dataset<String> ds1 = spark.read().textFile(getResource(\"test-data/text-suite.txt\"));\n    Assertions.assertEquals(4L, ds1.count());\n\n    Dataset<String> ds2 = spark.read().textFile(\n      getResource(\"test-data/text-suite.txt\"),\n      getResource(\"test-data/text-suite2.txt\"));\n    Assertions.assertEquals(5L, ds2.count());\n  }\n\n  @Test\n  public void testCountMinSketch() {\n    Dataset<Long> df = spark.range(1000);\n\n    CountMinSketch sketch1 = df.stat().countMinSketch(\"id\", 10, 20, 42);\n    Assertions.assertEquals(1000, sketch1.totalCount());\n    Assertions.assertEquals(10, sketch1.depth());\n    Assertions.assertEquals(20, sketch1.width());\n\n    CountMinSketch sketch2 = df.stat().countMinSketch(col(\"id\"), 10, 20, 42);\n    Assertions.assertEquals(1000, sketch2.totalCount());\n    Assertions.assertEquals(10, sketch2.depth());\n    Assertions.assertEquals(20, sketch2.width());\n\n    CountMinSketch sketch3 = df.stat().countMinSketch(\"id\", 0.001, 0.99, 42);\n    Assertions.assertEquals(1000, sketch3.totalCount());\n    Assertions.assertEquals(0.001, sketch3.relativeError(), 1.0e-4);\n    Assertions.assertEquals(0.99, sketch3.confidence(), 5.0e-3);\n\n    CountMinSketch sketch4 = df.stat().countMinSketch(col(\"id\"), 0.001, 0.99, 42);\n    Assertions.assertEquals(1000, sketch4.totalCount());\n    Assertions.assertEquals(0.001, sketch4.relativeError(), 1.0e-4);\n    Assertions.assertEquals(0.99, sketch4.confidence(), 5.0e-3);\n  }\n\n  @Test\n  public void testBloomFilter() {\n    Dataset<Long> df = spark.range(1000);\n\n    BloomFilter filter1 = df.stat().bloomFilter(\"id\", 1000, 0.03);\n    Assertions.assertTrue(filter1.expectedFpp() - 0.03 < 1e-3);\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter1.mightContain(i));\n    }\n\n    BloomFilter filter2 = df.stat().bloomFilter(col(\"id\").multiply(3), 1000, 0.03);\n    Assertions.assertTrue(filter2.expectedFpp() - 0.03 < 1e-3);\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter2.mightContain(i * 3));\n    }\n\n    BloomFilter filter3 = df.stat().bloomFilter(\"id\", 1000, 64 * 5);\n    Assertions.assertEquals(64 * 5, filter3.bitSize());\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter3.mightContain(i));\n    }\n\n    BloomFilter filter4 = df.stat().bloomFilter(col(\"id\").multiply(3), 1000, 64 * 5);\n    Assertions.assertEquals(64 * 5, filter4.bitSize());\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter4.mightContain(i * 3));\n    }\n  }\n\n  public static class BeanWithoutGetter implements Serializable {\n    private String a;\n\n    public void setA(String a) {\n      this.a = a;\n    }\n  }\n\n  @Test\n  public void testBeanWithoutGetter() {\n    BeanWithoutGetter bean = new BeanWithoutGetter();\n    List<BeanWithoutGetter> data = Arrays.asList(bean);\n    Dataset<Row> df = spark.createDataFrame(data, BeanWithoutGetter.class);\n    Assertions.assertEquals(0, df.schema().length());\n    Assertions.assertEquals(1, df.collectAsList().size());\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @Test\n  public void testJsonRDDToDataFrame() {\n    JavaRDD<String> rdd = jsc.parallelize(Arrays.asList(\"{\\\"a\\\": 2}\"));\n    Dataset<Row> df = spark.read().json(rdd);\n    Assertions.assertEquals(1L, df.count());\n    Assertions.assertEquals(2L, df.collectAsList().get(0).getLong(0));\n  }\n\n  public class CircularReference1Bean implements Serializable {\n    private CircularReference2Bean child;\n\n    public CircularReference2Bean getChild() {\n      return child;\n    }\n\n    public void setChild(CircularReference2Bean child) {\n      this.child = child;\n    }\n  }\n\n  public class CircularReference2Bean implements Serializable {\n    private CircularReference1Bean child;\n\n    public CircularReference1Bean getChild() {\n      return child;\n    }\n\n    public void setChild(CircularReference1Bean child) {\n      this.child = child;\n    }\n  }\n\n  @Test\n  public void testCircularReferenceBean() {\n    CircularReference1Bean bean = new CircularReference1Bean();\n    Assertions.assertThrows(UnsupportedOperationException.class,\n      () -> spark.createDataFrame(Arrays.asList(bean), CircularReference1Bean.class));\n  }\n\n  @Test\n  public void testUDF() {\n    UserDefinedFunction foo = udf((Integer i, String s) -> i.toString() + s, DataTypes.StringType);\n    Dataset<Row> df = spark.table(\"testData\").select(foo.apply(col(\"key\"), col(\"value\")));\n    String[] result = df.collectAsList().stream().map(row -> row.getString(0))\n      .toArray(String[]::new);\n    String[] expected = spark.table(\"testData\").collectAsList().stream()\n      .map(row -> row.get(0).toString() + row.getString(1)).toArray(String[]::new);\n    Assertions.assertArrayEquals(expected, result);\n  }\n\n  @Test\n  public void testTransformBase() {\n    Dataset<Integer> ds = spark.createDataset(Arrays.asList(1,2), Encoders.INT());\n    Dataset<Integer> transformed = ds.transform((Dataset<Integer> d) ->\n            ds.selectExpr(\"(value + 1) value\").as(Encoders.INT()));\n    Integer[] expected = {2, 3};\n    Integer[] got = transformed.collectAsList().toArray(new Integer[0]);\n    Arrays.sort(got);\n    Assertions.assertArrayEquals(expected, got);\n  }\n\n  @Test\n  public void testTransformAsClassic() {\n    org.apache.spark.sql.classic.Dataset<Integer> ds =\n            spark.createDataset(Arrays.asList(1,2), Encoders.INT());\n    org.apache.spark.sql.classic.Dataset<Integer> transformed =\n            ds.transform((Dataset<Integer> d) ->\n              ds.selectExpr(\"(value + 1) value\").as(Encoders.INT()));\n    Integer[] expected = {2, 3};\n    Integer[] got = transformed.collectAsList().toArray(new Integer[0]);\n    Arrays.sort(got);\n    Assertions.assertArrayEquals(expected, got);\n  }\n}",
        "human_comment": "Validate geting same result with withColumn loop call\nValidate the col names\nThe following \"getResource\" has different behaviors in SBT and Maven.\nWhen running in Jenkins, the file path may contain \"@\" when there are multiple\nSparkPullRequestBuilders running in the same worker\n(e.g., /home/jenkins/workspace/SparkPullRequestBuilder@2)\nWhen running in SBT, \"@\" in the file path will be returned as \"@\", however,\nwhen running in Maven, \"@\" will be encoded as \"%40\".\nTherefore, we convert it to URI then call \"getPath\" to decode it back so that it can both\nwork both in SBT and Maven.\nThis is a test for the deprecated API in SPARK-15615.\nChecks a simple case for DataFrame here and put exhaustive tests for the issue\nof circular references in `JavaDatasetSuite`.\nSPARK-49961 - transform must have the correct type\nSPARK-49961 - transform must have the correct type",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 590,
        "code_snippet": "public void setAddDefaultEntities(boolean addDefaultEntities) {\n        delegate.setAddLocationInformation(addDefaultEntities);\n    } // -- void setAddDefaultEntities( boolean )",
        "human_comment": "Sets the state of the \"add default entities\" flag.\n\n@param addDefaultEntities a addDefaultEntities object.",
        "model_generated_comment": "Sets the number of {@link DefaultEntities} in the delegate.\n\n@param addDefaultEntities the {@code boolean} to set."
    },
    {
        "id": 591,
        "code_snippet": "protected Instance findNextInstance(int currentId) {\n    Instance result = null;\n    var candidateList =\n        instanceMap.keySet().stream()\n            .filter((i) -> i > currentId && instanceMap.get(i).isAlive())\n            .sorted()\n            .toList();\n    if (candidateList.isEmpty()) {\n      var index =\n          instanceMap.keySet().stream()\n              .filter((i) -> instanceMap.get(i).isAlive())\n              .sorted()\n              .toList()\n              .get(0);\n      result = instanceMap.get(index);\n    } else {\n      var index = candidateList.get(0);\n      result = instanceMap.get(index);\n    }\n    return result;\n  }",
        "human_comment": "Find the next instance with the smallest ID.\n\n@return The next instance.",
        "model_generated_comment": "Find the next instance of {@link Instance}.\n\n@param currentId the current id of the instance\n@return the Instance"
    },
    {
        "id": 592,
        "code_snippet": "protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        if (!areAllChildrenIgnored()) {\n            statement = withBeforeClasses(statement);\n            statement = withAfterClasses(statement);\n            statement = withClassRules(statement);\n            statement = withInterruptIsolation(statement);\n        }\n        return statement;\n    }",
        "human_comment": "Constructs a {@code Statement} to run all of the tests in the test class.\nOverride to add pre-/post-processing. Here is an outline of the\nimplementation:\n<ol>\n<li>Determine the children to be run using {@link #getChildren()}\n(subject to any imposed filter and sort).</li>\n<li>If there are any children remaining after filtering and ignoring,\nconstruct a statement that will:\n<ol>\n<li>Apply all {@code ClassRule}s on the test-class and superclasses.</li>\n<li>Run all non-overridden {@code @BeforeClass} methods on the test-class\nand superclasses; if any throws an Exception, stop execution and pass the\nexception on.</li>\n<li>Run all remaining tests on the test-class.</li>\n<li>Run all non-overridden {@code @AfterClass} methods on the test-class\nand superclasses: exceptions thrown by previous steps are combined, if\nnecessary, with exceptions from AfterClass methods into a\n{@link org.junit.runners.model.MultipleFailureException}.</li>\n</ol>\n</li>\n</ol>\n\n@return {@code Statement}",
        "model_generated_comment": "Create a new {@link Statement} with the given notifier.\n\n@param notifier the notifier to create the statement\n@return a new Statement"
    },
    {
        "id": 593,
        "code_snippet": "public Author getAuthorByUsername(String username) {\n    Author authorDto;\n    try (var session = sessionFactory.openSession()) {\n      Query<Author> sqlQuery =\n          session.createQuery(\n              \"select new com.iluwatar.cqrs.dto.Author(a.name, a.email, a.username)\"\n                  + \" from com.iluwatar.cqrs.domain.model.Author a where a.username=:username\");\n      sqlQuery.setParameter(AppConstants.USER_NAME, username);\n      authorDto = sqlQuery.uniqueResult();\n    }\n    return authorDto;\n  }",
        "human_comment": "This class is an implementation of {@link QueryService}. It uses Hibernate native queries to\nreturn DTOs from the database.",
        "model_generated_comment": "Get the username of the given user.\n\n@param username the username for the user."
    },
    {
        "id": 594,
        "code_snippet": "public void allocate(int num_bins) {\n    nbins = num_bins;\n    bins = new ArrayList<>();\n    nusedbins = 0;\n  }",
        "human_comment": "Sets the number of histogram bins to use for approximating data.\n\n@param num_bins Number of non-uniform-width histogram bins to use",
        "model_generated_comment": "Sets the number of bins in the given array.\n\n@param num_bins the number to allocate."
    },
    {
        "id": 595,
        "code_snippet": "public Model expandPluginConfiguration(Model model, ModelBuilderRequest request, ModelProblemCollector problems) {\n        Build build = model.getBuild();\n        if (build != null) {\n            build = build.withPlugins(expandPlugin(build.getPlugins()));\n            PluginManagement pluginManagement = build.getPluginManagement();\n            if (pluginManagement != null) {\n                build = build.withPluginManagement(\n                        pluginManagement.withPlugins(expandPlugin(pluginManagement.getPlugins())));\n            }\n            model = model.withBuild(build);\n        }\n        Reporting reporting = model.getReporting();\n        if (reporting != null) {\n            expandReport(reporting.getPlugins());\n        }\n        return model.withBuild(build);\n    }",
        "human_comment": "Handles expansion of general build plugin configuration into individual executions.",
        "model_generated_comment": "Expand the plugin configuration.\n\n@param model the model to expand, may be {@code null}."
    },
    {
        "id": 596,
        "code_snippet": "public static void assertArrayEquals(byte[] expected, byte[] actual, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} byte arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "<em>Assert</em> that two arrays are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code message}.\n\n@since 5.4"
    },
    {
        "id": 597,
        "code_snippet": "public File locatePom(File projectDirectory) {\n        return new File(projectDirectory, \"pom.xml\");\n    }",
        "human_comment": "Locates a POM file within a project base directory.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead",
        "model_generated_comment": "Finds the location of the POM.\n\n@param projectDirectory The project directory to locate."
    },
    {
        "id": 598,
        "code_snippet": "private static boolean isCompatibleContainerType(Method method, DiscoveryIssueReporter issueReporter) {\n\t\tType genericReturnType = method.getGenericReturnType();\n\n\t\tif (genericReturnType instanceof ParameterizedType) {\n\t\t\tType[] typeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();\n\t\t\tif (typeArguments.length == 1) {\n\t\t\t\tType typeArgument = typeArguments[0];\n\t\t\t\tif (typeArgument instanceof Class) {\n\t\t\t\t\treturn DynamicNode.class.isAssignableFrom((Class<?>) typeArgument);\n\t\t\t\t}\n\t\t\t\tif (typeArgument instanceof WildcardType) {\n\t\t\t\t\tWildcardType wildcardType = (WildcardType) typeArgument;\n\t\t\t\t\tType[] upperBounds = wildcardType.getUpperBounds();\n\t\t\t\t\tType[] lowerBounds = wildcardType.getLowerBounds();\n\t\t\t\t\tif (upperBounds.length == 1 && lowerBounds.length == 0 && upperBounds[0] instanceof Class) {\n\t\t\t\t\t\tClass<?> upperBound = (Class<?>) upperBounds[0];\n\t\t\t\t\t\tif (Object.class.equals(upperBound)) { // Stream<?> etc.\n\t\t\t\t\t\t\tissueReporter.reportIssue(createTooGenericReturnTypeIssue(method));\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn DynamicNode.class.isAssignableFrom(upperBound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tissueReporter.reportIssue(createTooGenericReturnTypeIssue(method));\n\t\treturn true;\n\t}",
        "human_comment": "Stream<DynamicNode> etc.\nStream<? extends DynamicNode> etc.\nRaw Stream etc. without type argument",
        "model_generated_comment": "Create a new {@link #compatibleContainerType} for the supplied container type.\n\n@param method the method to create the container type; never {@code null}"
    },
    {
        "id": 599,
        "code_snippet": "public static void loadNativeLibs() {\n    try {\n      NativeLoader.loadLibrary(\"torch-code-gen\");\n    } catch (Throwable t) {\n    }\n  }",
        "human_comment": "Loading the codegen lib is best-effort since it's only there for query based builds.",
        "model_generated_comment": "Loads all the native libs.\n\n@param t the directory to load, may be {@code null}.\n@return {@link NativeLoader}"
    },
    {
        "id": 600,
        "code_snippet": "void cleanupModeDefaultParameter() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(DefaultParameterCase.class, \"testDefaultParameter\", \"java.nio.file.Path\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(defaultParameterDir).doesNotExist();\n\t\t}",
        "human_comment": "Ensure the cleanup mode defaults to ALWAYS for parameters.\n<p/>\nExpect the TempDir to be cleaned up.",
        "model_generated_comment": "Unit tests for {@link DefaultParameterCase}.\n\n@since 5.0"
    },
    {
        "id": 601,
        "code_snippet": "protected ThrowableCollector.Factory createThrowableCollectorFactory(ExecutionRequest request) {\n\t\treturn OpenTest4JAwareThrowableCollector::new;\n\t}",
        "human_comment": "Create the {@linkplain ThrowableCollector.Factory factory} for creating\n{@link ThrowableCollector} instances used to handle exceptions that occur\nduring execution of this engine's tests.\n\n<p>An engine may use the information in the supplied <em>request</em>\nsuch as the contained\n{@linkplain ExecutionRequest#getConfigurationParameters() configuration parameters}\nto decide what kind of factory to return or how to configure it.\n\n<p>By default, this method returns a factory that always creates instances of\n{@link OpenTest4JAwareThrowableCollector}.\n\n@param request the request about to be executed\n@since 1.3\n@see OpenTest4JAwareThrowableCollector\n@see ThrowableCollector",
        "model_generated_comment": "Create a {@link ThrowableCollectorFactory} for the supplied execution request.\n\n@param request the request to create; never {@code null}"
    },
    {
        "id": 602,
        "code_snippet": "public long mergedIndexCacheSize() {\n    return JavaUtils.byteStringAsBytes(\n      conf.get(\"spark.shuffle.push.server.mergedIndexCacheSize\", \"100m\"));\n  }",
        "human_comment": "The maximum size of cache in memory which is used in push-based shuffle for storing merged\nindex files. This cache is in addition to the one configured via\nspark.shuffle.service.index.cache.size.",
        "model_generated_comment": "Merges index cache size to 100m.\n\n@param mergedIndexCacheSize the index size of the server."
    },
    {
        "id": 603,
        "code_snippet": "private static DefinitionOrigin getDefinitionOrigin(int collationId) {\n        return DefinitionOrigin.values()[SpecifierUtils.getSpecValue(collationId,\n          DEFINITION_ORIGIN_OFFSET, DEFINITION_ORIGIN_MASK)];\n      }",
        "human_comment": "Utility function to retrieve `DefinitionOrigin` enum instance from collation ID.",
        "model_generated_comment": "Returns the definition of a {@link DefinitionOrigin}.\n\n@param collationId The collation ID of the {@code DefinitionOrigin}\n@return the definition"
    },
    {
        "id": 604,
        "code_snippet": "public static void main(String[] args) {\n    SpringApplication.run(SingleTableInheritance.class, args);\n  }",
        "human_comment": "The entry point of the Spring Boot Application.\n\n@param args program runtime arguments",
        "model_generated_comment": "Creates a new {@link main} instance of the SpringApplication.\n\n@param args The args to run\n@return a new main instance"
    },
    {
        "id": 605,
        "code_snippet": "public String getLocation() {\n        return this.location;\n    } // -- String getLocation()",
        "human_comment": "Get the path/URL of the POM or {@code null} if unknown.\n\n@return String",
        "model_generated_comment": "Returns the location of the given location."
    },
    {
        "id": 606,
        "code_snippet": "public void publish(Message message) {\n    for (Subscriber subscriber : subscribers) {\n      CompletableFuture.runAsync(() -> subscriber.onMessage(message));\n    }\n  }",
        "human_comment": "Publish a message to subscribers.\n\n@param message message with content to publish",
        "model_generated_comment": "Publish a message to the specified subscriber.\n\n@param message the message to publish."
    },
    {
        "id": 607,
        "code_snippet": "public void testCodePointFrom() {\n    String str = \"abcde\";\n    UTF8String s = fromString(str);\n    for (int i = 0; i < str.length(); ++i) {\n      assertEquals(str.charAt(i), s.codePointFrom(i));\n    }\n    assertThrows(IndexOutOfBoundsException.class, () -> s.codePointFrom(-1));\n    assertThrows(IndexOutOfBoundsException.class, () -> s.codePointFrom(str.length()));\n    assertThrows(IndexOutOfBoundsException.class, () -> s.codePointFrom(str.length() + 1));\n\n    byte[] invalidString = new byte[] {(byte) 0x41, (byte) 0x42, (byte) 0x80};\n        assertEquals(0, invalidUTF8String.codePointFrom(i));\n      }",
        "human_comment": "Valid UTF-8 string\nValid character index handling\nInvalid character index handling\nInvalid UTF-8 string",
        "model_generated_comment": "Unit tests for UTF8String.\n\n@param str the string to test\n@throws IllegalArgumentException if the string is invalid"
    },
    {
        "id": 608,
        "code_snippet": "public static void assertEquals(Byte expected, byte actual) {\n\t\tAssertEquals.assertEquals(expected, (Byte) actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code byte}.\n\n@since 5.4"
    },
    {
        "id": 609,
        "code_snippet": "public void testStreamingContextTransform() {\n    List<List<Integer>> stream1input = Arrays.asList(\n      Arrays.asList(1),\n      Arrays.asList(2)\n    );\n\n    List<List<Integer>> stream2input = Arrays.asList(\n      Arrays.asList(3),\n      Arrays.asList(4)\n    );\n\n    List<List<Tuple2<Integer, String>>> pairStream1input = Arrays.asList(\n      Arrays.asList(new Tuple2<>(1, \"x\")),\n      Arrays.asList(new Tuple2<>(2, \"y\"))\n    );\n\n    List<List<Tuple2<Integer, Tuple2<Integer, String>>>> expected = Arrays.asList(\n      Arrays.asList(new Tuple2<>(1, new Tuple2<>(1, \"x\"))),\n      Arrays.asList(new Tuple2<>(2, new Tuple2<>(2, \"y\")))\n    );\n\n    JavaDStream<Integer> stream1 = JavaTestUtils.attachTestInputStream(ssc, stream1input, 1);\n    JavaDStream<Integer> stream2 = JavaTestUtils.attachTestInputStream(ssc, stream2input, 1);\n    JavaPairDStream<Integer, String> pairStream1 = JavaPairDStream.fromJavaDStream(\n      JavaTestUtils.attachTestInputStream(ssc, pairStream1input, 1));\n\n    List<JavaDStream<?>> listOfDStreams1 = Arrays.asList(stream1, stream2);\n\n    JavaDStream<Long> transformed1 = ssc.transform(\n      listOfDStreams1, (List<JavaRDD<?>> listOfRDDs, Time time) -> {\n      Assertions.assertEquals(2, listOfRDDs.size());\n      return null;\n    });\n\n    List<JavaDStream<?>> listOfDStreams2 =\n      Arrays.asList(stream1, stream2, pairStream1.toJavaDStream());\n\n    JavaPairDStream<Integer, Tuple2<Integer, String>> transformed2 = ssc.transformToPair(\n      listOfDStreams2, (List<JavaRDD<?>> listOfRDDs, Time time) -> {\n      Assertions.assertEquals(3, listOfRDDs.size());\n      JavaRDD<Integer> rdd1 = (JavaRDD<Integer>) listOfRDDs.get(0);\n      JavaRDD<Integer> rdd2 = (JavaRDD<Integer>) listOfRDDs.get(1);\n      JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>) listOfRDDs.get(2);\n      JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3);\n      PairFunction<Integer, Integer, Integer> mapToTuple =\n        (Integer i) -> new Tuple2<>(i, i);\n      return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3);\n    });\n    JavaTestUtils.attachTestOutputStream(transformed2);\n    List<List<Tuple2<Integer, Tuple2<Integer, String>>>> result =\n      JavaTestUtils.runStreams(ssc, 2, 2);\n    Assertions.assertEquals(expected, result);\n  }",
        "human_comment": "This is just to test whether this transform to JavaStream compiles",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 610,
        "code_snippet": "public MethodValidator(TestClass testClass) {\n        this.testClass = testClass;\n    }",
        "human_comment": "@deprecated Included for backwards compatibility with JUnit 4.4. Will be\nremoved in the next major release. Please use\n{@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.",
        "model_generated_comment": "Creates a new {@link MethodValidator} for the supplied test class.\n\n@param testClass the test class to use\n@return a new method"
    },
    {
        "id": 611,
        "code_snippet": "private static boolean checkCombineLines(String line) {\n            int bsCount = 0;\n            for (int idx = line.length() - 1; idx >= 0 && line.charAt(idx) == '\\\\'; idx--) {\n                bsCount++;\n            }\n\n            return bsCount % 2 != 0;\n        }",
        "human_comment": "Checks if the passed in line should be combined with the following.\nThis is true, if the line ends with an odd number of backslashes.\n\n@param line the line\n@return a flag if the lines should be combined",
        "model_generated_comment": "Check whether two lines are equal.\n\n@param line The line to check, may be {@code null}."
    },
    {
        "id": 612,
        "code_snippet": "public ConsolePasswordPrompt(Prompter prompter) {\n        this.prompter = prompter;\n    }",
        "human_comment": "Trivial master password source using Maven {@link Prompter} service.",
        "model_generated_comment": "Create a new {@link ConsolePasswordPrompt} for the given password."
    },
    {
        "id": 613,
        "code_snippet": "private long cpuTime(Thread thr) {\n        ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n        if (mxBean.isThreadCpuTimeSupported()) {\n            try {\n                return mxBean.getThreadCpuTime(thr.getId());\n            } catch (UnsupportedOperationException e) {\n            }\n        }\n        return 0;\n    }",
        "human_comment": "Returns the CPU time used by a thread, if possible.\n@param thr The thread to query.\n@return The CPU time used by {@code thr}, or 0 if it cannot be determined.",
        "model_generated_comment": "Returns the cpu time of the ThreadMXBean.\n\n@param thr the thread to use\n@return the cpuTime"
    },
    {
        "id": 614,
        "code_snippet": "public Message retrieveMsg() {\n    try {\n      return blkQueue.poll();\n    } catch (Exception e) {\n      LOGGER.error(e.getMessage());\n    }\n    return null;\n  }",
        "human_comment": "All the messages will be retrieved by the ServiceExecutor by calling this method and process\nthem. Retrieves and removes the head of this queue, or returns null if this queue is empty.",
        "model_generated_comment": "Returns the message of the message.\n\n@param e the message to retrieve.\n@return null if the message is not retrieved."
    },
    {
        "id": 615,
        "code_snippet": "private void installIntoProjectLocalRepository(MavenProject project) {\n        if (\"pom\".equals(project.getPackaging())\n                        && !\"clean\".equals(getLifecycles(project).peekLast())\n                || hasBeenPackagedDuringThisSession(project)) {\n            getProjectArtifacts(project).filter(this::isRegularFile).forEach(this::installIntoProjectLocalRepository);\n        }\n    }",
        "human_comment": "Copy packaged and attached artifacts from this project to the\nproject local repository.\nThis allows a subsequent build to resume while still being able\nto locate attached artifacts.\n\n@param project the project to copy artifacts from",
        "model_generated_comment": "This is a test set for {@link MavenProject}.\n\n@param project The project to install, may be {@code null}."
    },
    {
        "id": 616,
        "code_snippet": "public SettingsBuildingException(List<SettingsProblem> problems) {\n        super(toMessage(problems));\n\n        this.problems = new ArrayList<>();\n        if (problems != null) {\n            this.problems.addAll(problems);\n        }\n    }",
        "human_comment": "Creates a new exception with the specified problems.\n\n@param problems The problems that cause this exception, may be {@code null}.",
        "model_generated_comment": "Creates a new {@link SettingsProblem} with the specified problems.\n\n@param problems the problems to add\n@return {@code Settings}"
    },
    {
        "id": 617,
        "code_snippet": "private void addUserProvidedDelegates(Options options) {\n    for (Delegate delegate : options.getDelegates()) {\n      if (options.getRuntime() != TfLiteRuntime.FROM_APPLICATION_ONLY\n          && !(delegate instanceof NnApiDelegate)) {\n        throw new IllegalArgumentException(\n            \"Instantiated delegates (other than NnApiDelegate) are not allowed when using TF Lite\"\n                + \" from Google Play Services. Please use\"\n                + \" InterpreterApi.Options.addDelegateFactory() with an appropriate DelegateFactory\"\n                + \" instead.\");\n      }\n      delegates.add(delegate);\n    }\n  }",
        "human_comment": "NnApiDelegate is compatible with both the system and built-in runtimes and therefore can be\nadded directly even when using TF Lite from the system.",
        "model_generated_comment": "Add user-provided delegates to TF Lite.\n\n@param options the delegate to add.\n@throws IllegalArgumentException if the delegate does not exist."
    },
    {
        "id": 618,
        "code_snippet": "Artifact originatingArtifact, Map<String, Artifact> managedVersions) {\n        ManagedVersionMap versionMap;\n        if (managedVersions instanceof ManagedVersionMap managedVersionMap) {\n            versionMap = managedVersionMap;\n        } else {\n            versionMap = new ManagedVersionMap(managedVersions);\n        }\n\n        // remove the originating artifact if it is also in managed versions to avoid being modified during resolution\n        Artifact managedOriginatingArtifact = versionMap.get(originatingArtifact.getDependencyConflictId());\n\n        if (managedOriginatingArtifact != null) {\n            // TODO we probably want to warn the user that he is building an artifact with\n            // different values than in dependencyManagement\n            if (managedVersions instanceof ManagedVersionMap) {\n                /* avoid modifying the managedVersions parameter creating a new map */\n                versionMap = new ManagedVersionMap(managedVersions);\n            }\n            versionMap.remove(originatingArtifact.getDependencyConflictId());\n        }\n\n        return versionMap;\n    }",
        "human_comment": "Get the map of managed versions, removing the originating artifact if it is also in managed versions\n\n@param originatingArtifact artifact we are processing\n@param managedVersions original managed versions",
        "model_generated_comment": "Remove the originating artifact from the managed version map.\n\n@param originatingArtifact The artifact to remove, may be {@code null}."
    },
    {
        "id": 619,
        "code_snippet": "public JavaCustomReceiver(String host_ , int port_) {\n    super(StorageLevel.MEMORY_AND_DISK_2());\n    host = host_;\n    port = port_;\n  }",
        "human_comment": "Create the context with a 1 second batch size\nCreate an input stream with the custom receiver on target ip:port and count the\nwords in input stream of \\n delimited text (e.g. generated by 'nc')\n============= Receiver code that receives data over a socket ==============",
        "model_generated_comment": "Creates a custom receiver with the specified host and port.\n\n@param host_ The host of the custom receiver, may be {@code null}."
    },
    {
        "id": 620,
        "code_snippet": "public ConditionFunctions(ProfileActivationContext context, VersionParser versionParser) {\n        this.context = context;\n        this.versionParser = versionParser;\n    }",
        "human_comment": "Constructs a new ConditionFunctions instance.\n\n@param context The profile activation context\n@param versionParser The version parser for comparing versions",
        "model_generated_comment": "Unit tests for {@link ConditionFunctions}.\n\n@param context The context of the test, may be {@code null}."
    },
    {
        "id": 621,
        "code_snippet": "public ByteBuffer getByteBuffer() {\n    if (base instanceof byte[] bytes && offset >= BYTE_ARRAY_OFFSET) {\n\n      // the offset includes an object header... this is only needed for unsafe copies\n      final long arrayOffset = offset - BYTE_ARRAY_OFFSET;\n\n      // verify that the offset and length points somewhere inside the byte array\n      // and that the offset can safely be truncated to a 32-bit integer\n      if ((long) bytes.length < arrayOffset + numBytes) {\n        throw new ArrayIndexOutOfBoundsException();\n      }\n\n      return ByteBuffer.wrap(bytes, (int) arrayOffset, numBytes);\n    } else {\n      return ByteBuffer.wrap(getBytes());\n    }\n  }",
        "human_comment": "Returns a {@link ByteBuffer} wrapping the base object if it is a byte array\nor a copy of the data if the base object is not a byte array.\n\nUnlike getBytes this will not create a copy the array if this is a slice.",
        "model_generated_comment": "Returns the byte array with the given offset and length.\n\n@param byte arrayOffset the offset and the length of the array\n@return The byte array"
    },
    {
        "id": 622,
        "code_snippet": "public MavenExecutionPlan calculateExecutionPlan(MavenSession session, String... tasks) {\n        return new MavenExecutionPlan(null, new DefaultLifecycles());\n    }",
        "human_comment": "A stub implementation that assumes an empty lifecycle to bypass interaction with the plugin manager and to avoid\nplugin artifact resolution from repositories.",
        "model_generated_comment": "Creates a new MavenExecutionPlan for the specified session.\n\n@param session The session to calculate the execution plan."
    },
    {
        "id": 623,
        "code_snippet": "public void closeIfFreeable() {\n    // By default, we just call close() for all column vectors. If a column vector is writable or\n    // constant, it should override this method and do nothing.\n    close();\n  }",
        "human_comment": "Cleans up memory for this column vector if it's resources are freeable between batches.\nThe column vector is not usable after this.\n\nIf this is a writable column vector or constant column vector, it is a no-op.",
        "model_generated_comment": "Close if a column vector is writable or not."
    },
    {
        "id": 624,
        "code_snippet": "public static Predicate<Event> byTestDescriptor(Predicate<? super TestDescriptor> testDescriptorPredicate) {\n\t\treturn where(Event::getTestDescriptor, testDescriptorPredicate);\n\t}",
        "human_comment": "Create a {@link Predicate} for {@linkplain Event events} whose\n{@link TestDescriptor TestDescriptors} match the supplied\n{@code testDescriptorPredicate}.\n\n@param testDescriptorPredicate a {@code Predicate} to match against test\ndescriptors\n@return the resulting {@link Predicate}",
        "model_generated_comment": "Create a new {@code Predicate} for the supplied {@link Event}.\n\n@since 5.4"
    },
    {
        "id": 625,
        "code_snippet": "public int accumulateSum(int... nums) {\n    LOGGER.info(SOURCE_MODULE, VERSION);\n    return Arrays.stream(nums).reduce(0, Integer::sum);\n  }",
        "human_comment": "New source. Completely covers functionalities of old source with new techniques and also has some\nnew features.",
        "model_generated_comment": "Reduce the number of integers in the accumulator.\n\n@param nums the nums to accumulate."
    },
    {
        "id": 626,
        "code_snippet": "public ProjectBuilderRequest build() {\n            return new DefaultProjectBuilderRequest(\n                    session, trace, path, source, allowStubModel, recursive, processPlugins, repositories);\n        }",
        "human_comment": "Builds a new ProjectBuilderRequest with the current builder settings.\n\n@return a new ProjectBuilderRequest instance",
        "model_generated_comment": "Creates a new {@link ProjectBuilderRequest} for the specified project.\n\n@param build the project to build.\n@return a new Project BuilderRequest"
    },
    {
        "id": 627,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaVectorIndexerExample\")\n      .getOrCreate();\n\n    Dataset<Row> data = spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    VectorIndexer indexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexed\")\n      .setMaxCategories(10);\n    VectorIndexerModel indexerModel = indexer.fit(data);\n\n    Map<Integer, Map<Double, Integer>> categoryMaps = indexerModel.javaCategoryMaps();\n    System.out.print(\"Chose \" + categoryMaps.size() + \" categorical features:\");\n\n    for (Integer feature : categoryMaps.keySet()) {\n      System.out.print(\" \" + feature);\n    }\n    System.out.println();\n\n    Dataset<Row> indexedData = indexerModel.transform(data);\n    indexedData.show();\n    spark.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nCreate new column \"indexed\" with categorical values transformed to indices\n$example off$",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 628,
        "code_snippet": "private static Logger getLogger() {\n\t\treturn LoggerFactory.getLogger(ServiceLoaderTestEngineRegistry.class);\n\t}",
        "human_comment": "Not a constant to avoid problems with building GraalVM native images",
        "model_generated_comment": "Get the {@link LoggerFactory} for the supplied service loader.\n\n@param Logger the name of the service loader; never {@code null} or blank\n@return the supplied logger"
    },
    {
        "id": 629,
        "code_snippet": "public static <V> V fail() {\n\t\tAssertionUtils.fail();\n\t\treturn null; // appeasing the compiler: this line will never be executed.\n\t}",
        "human_comment": "<em>Fail</em> the test <em>without</em> a failure message.\n\n<p>Although failing <em>with</em> an explicit failure message is recommended,\nthis method may be useful when maintaining legacy code.\n\n<p>See Javadoc for {@link #fail(String)} for an explanation of this method's\ngeneric return type {@code V}.",
        "model_generated_comment": "<em>Fails</em> with the supplied {@link AssertionUtils.fail();}.\n\n@since 5.4"
    },
    {
        "id": 630,
        "code_snippet": "public void put(int field$, java.lang.Object value$) {\n    switch (field$) {\n    case 0: maybe_bool_column = (java.lang.Boolean)value$; break;\n    case 1: maybe_int_column = (java.lang.Integer)value$; break;\n    case 2: maybe_long_column = (java.lang.Long)value$; break;\n    case 3: maybe_float_column = (java.lang.Float)value$; break;\n    case 4: maybe_double_column = (java.lang.Double)value$; break;\n    case 5: maybe_binary_column = (java.nio.ByteBuffer)value$; break;\n    case 6: maybe_string_column = (java.lang.String)value$; break;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
        "human_comment": "Used by DatumReader.  Applications should not call.",
        "model_generated_comment": "Sets the value of the given field.\n\n@param field the field to put into the new field."
    },
    {
        "id": 631,
        "code_snippet": "final UTF8String getUTF8String(int rowId) {\n      accessor.get(rowId, stringResult);\n      if (stringResult.isSet == 0) {\n        return null;\n      } else {\n        return UTF8String.fromAddress(null,\n          stringResult.buffer.memoryAddress() + stringResult.start,\n          (int)(stringResult.end - stringResult.start));\n      }\n    }",
        "human_comment": "A single string cannot be larger than the max integer size, so the conversion is safe",
        "model_generated_comment": "Get the UTF8 string from the memory address.\n\n@param rowId the rowId of the string\n@return the string"
    },
    {
        "id": 632,
        "code_snippet": "public Events started() {\n\t\treturn new Events(eventsByType(EventType.STARTED), this.category + \" Started\");\n\t}",
        "human_comment": "Get the started {@link Events} contained in this {@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}",
        "model_generated_comment": "Create a new {@link Events} with the given name.\n\n@param started the {@code Events} to create; never {@return null}"
    },
    {
        "id": 633,
        "code_snippet": "public boolean isChildOfRootNode() {\n        return parent != null && parent.parent == null;\n    }",
        "human_comment": "Test whether the node is direct or transitive dependency.\n\n@return whether the node is direct or transitive dependency",
        "model_generated_comment": "Returns the child of the root node."
    },
    {
        "id": 634,
        "code_snippet": "static RuntimeException handleCsvException(Throwable throwable, Annotation annotation) {\n\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(throwable);\n\t\tif (throwable instanceof PreconditionViolationException) {\n\t\t\tthrow (PreconditionViolationException) throwable;\n\t\t}\n\t\tthrow new CsvParsingException(\"Failed to parse CSV input configured via \" + annotation, throwable);\n\t}",
        "human_comment": "@return this method always throws an exception and therefore never\nreturns anything; the return type is merely present to allow this\nmethod to be supplied as the operand in a {@code throw} statement",
        "model_generated_comment": "Handles the {@link Throwable} throwable.\n\n@param throwable the throwable to be thrown; never {@code null}\n@return the thrown exception"
    },
    {
        "id": 635,
        "code_snippet": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn int[].class == parameterContext.getParameter().getType();\n\t}",
        "human_comment": "Example {@link ParameterResolver} that resolves arrays of primitive integers.\n\n@since 5.0",
        "model_generated_comment": "Unit tests for {@link ParameterContext}.\n\n@param parameterContext the parameter to check; never {@code null}\n@return true if the parameter is <em>null</em>"
    },
    {
        "id": 636,
        "code_snippet": "static ReadLimit minRows(long rows, long maxTriggerDelayMs) {\n    return new ReadMinRows(rows, maxTriggerDelayMs);\n  }",
        "human_comment": "Interface representing limits on how much to read from a {@link MicroBatchStream} when it\nimplements {@link SupportsAdmissionControl}. There are several child interfaces representing\nvarious kinds of limits.\n\n@see SupportsAdmissionControl#latestOffset(Offset, ReadLimit)\n@see ReadAllAvailable\n@see ReadMaxRows\n@since 3.0.0",
        "model_generated_comment": "Create a new {@link ReadLimit} for the specified rows.\n\n@param rows the rows to read.\n@return a new ReadLimit"
    },
    {
        "id": 637,
        "code_snippet": "public int find(long key) {\n    long h = hash(key);\n    int step = 0;\n    int idx = (int) h & (numBuckets - 1);\n    while (step < maxSteps) {\n      if (buckets[idx] == -1) {\n        return idx;\n      } else if (equals(idx, key)) {\n        return idx;\n      }\n      idx = (idx + 1) & (numBuckets - 1);\n      step++;\n    }\n    return -1;\n  }",
        "human_comment": "Return bucket index if it's either an empty slot or already contains the key\nDidn't find it",
        "model_generated_comment": "Finds the key of the given key.\n\n@param key the key to find\n@return -1"
    },
    {
        "id": 638,
        "code_snippet": "public MojoFailureException(Object source, String shortMessage, String longMessage) {\n        super(shortMessage);\n        this.source = source;\n        this.longMessage = longMessage;\n    }",
        "human_comment": "Construct a new <code>MojoFailureException</code> exception providing the source and a short and long message:\nthese messages are used to improve the message written at the end of Maven build.\n\n@param source\n@param shortMessage\n@param longMessage",
        "model_generated_comment": "Creates a MojoFailureException with the supplied {@code source} message.\n\n@param shortMessage the short message to throw."
    },
    {
        "id": 639,
        "code_snippet": "void testFailure_HalfOpenStateTransition() {\n    assertEquals(\"Delayed service is down\", monitoringService.delayedServiceResponse());\n    assertEquals(\"OPEN\", delayedServiceCircuitBreaker.getState());\n\n    try {\n      LOGGER.info(\"Waiting 2s for delayed service to become responsive\");\n      Thread.sleep(2000);\n    } catch (InterruptedException e) {\n      LOGGER.error(\"An error occurred: \", e);\n    }\n    assertEquals(\"HALF_OPEN\", delayedServiceCircuitBreaker.getState());\n  }",
        "human_comment": "Calling delayed service, which will be unhealthy till 4 seconds\nAs failure threshold is \"1\", the circuit breaker is changed to OPEN\nWaiting for recovery period of 2 seconds for circuit breaker to retry service.\nAfter 2 seconds, the circuit breaker should move to \"HALF_OPEN\" state and retry fetching\nresponse from service again",
        "model_generated_comment": "Unit tests for {@link HALF_OPEN}.\n\n@param delayedServiceCircuitBreaker.getState()"
    },
    {
        "id": 640,
        "code_snippet": "public <T extends Annotation> T getAnnotation(Class<T> annotationType) {\n        for (Annotation each : fAnnotations) {\n            if (each.annotationType().equals(annotationType)) {\n                return annotationType.cast(each);\n            }\n        }\n        return null;\n    }",
        "human_comment": "@return the annotation of type annotationType that is attached to this description node,\nor null if none exists",
        "model_generated_comment": "Gets the annotation type of the given class.\n\n@param annotationType the annotationType of the class\n@return Annotation"
    },
    {
        "id": 641,
        "code_snippet": "public UserAccount readFromDb(final String userId) {\n    var iterable =\n        db.getCollection(CachingConstants.USER_ACCOUNT).find(new Document(USER_ID, userId));\n    if (iterable.first() == null) {\n      return null;\n    }\n    Document doc = iterable.first();\n    if (doc != null) {\n      String userName = doc.getString(USER_NAME);\n      String appInfo = doc.getString(ADD_INFO);\n      return new UserAccount(userId, userName, appInfo);\n    } else {\n      return null;\n    }\n  }",
        "human_comment": "Read data from DB.\n\n@param userId {@link String}\n@return {@link UserAccount}",
        "model_generated_comment": "Reads the user account from the database.\n\n@param userId the user ID to read from\n@return The user account"
    },
    {
        "id": 642,
        "code_snippet": "public String put(String key, List<String> commentLines, List<String> valueLines) {\n        commentLines = new ArrayList<>(commentLines);\n        valueLines = new ArrayList<>(valueLines);\n        String escapedKey = escapeKey(key);\n        StringBuilder sb = new StringBuilder();\n        if (valueLines.isEmpty()) {\n            valueLines.add(escapedKey + \"=\");\n            sb.append(escapedKey).append(\"=\");\n        } else {\n            String val0 = valueLines.get(0);\n            String rv0 = typed ? val0 : escapeJava(val0);\n            if (!val0.trim().startsWith(escapedKey)) {\n                valueLines.set(0, escapedKey + \" = \" + rv0 /*+ (0 < lastLine? \"\\\\\": \"\")*/);\n                sb.append(escapedKey).append(\" = \").append(rv0);\n            } else {\n                valueLines.set(0, rv0 /*+ (0 < lastLine? \"\\\\\": \"\")*/);\n                sb.append(rv0);\n            }\n        }\n        for (int i = 1; i < valueLines.size(); i++) {\n            String val = valueLines.get(i);\n            valueLines.set(i, typed ? val : escapeJava(val) /*+ (i < lastLine? \"\\\\\": \"\")*/);\n            while (!val.isEmpty() && Character.isWhitespace(val.charAt(0))) {\n                val = val.substring(1);\n            }\n            sb.append(val);\n        }\n        String[] property = PropertiesReader.parseProperty(sb.toString());\n        this.layout.put(key, new Layout(commentLines, valueLines));\n        return storage.put(key, property[1]);\n    }",
        "human_comment": "int lastLine = valueLines.size() - 1;",
        "model_generated_comment": "Sets the key of the given string.\n\n@param key the string to put into the string\n@return the string, never {@code null}"
    },
    {
        "id": 643,
        "code_snippet": "public static ClassSelector selectClass(ClassLoader classLoader, String className) {\n\t\tPreconditions.notBlank(className, \"Class name must not be null or blank\");\n\t\treturn new ClassSelector(classLoader, className);\n\t}",
        "human_comment": "Create a {@code ClassSelector} for the supplied class name and class loader.\n\n@param classLoader the class loader to use to load the class, or {@code null}\nto signal that the default {@code ClassLoader} should be used\n@param className the fully qualified name of the class to select; never\n{@code null} or blank\n@since 1.10\n@see ClassSelector",
        "model_generated_comment": "Create a new {@link ClassSelector}.\n\n@param classLoader the class loader to select; never {@code null} or blank\n@return a new classSelector"
    },
    {
        "id": 644,
        "code_snippet": "public void launcherSessionOpened(LauncherSession session) {\n\t\tsession.getLauncher().registerTestExecutionListeners(new TestExecutionListener() {\n\t\t\t\tNamespacedHierarchicalStore<Namespace> store = session.getStore(); // <1>\n\t\t\t\tstore.getOrComputeIfAbsent(Namespace.GLOBAL, \"httpServer\", key -> { // <2>\n\t\t\t\t\tInetSocketAddress address = new InetSocketAddress(getLoopbackAddress(), 0);\n\t\t\t\t\tHttpServer server;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tserver = HttpServer.create(address, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t\tthrow new UncheckedIOException(\"Failed to start HTTP server\", e);\n\t\t\t\t\t}\n\t\t\t\t\tserver.createContext(\"/test\", exchange -> {\n\t\t\t\t\t\texchange.sendResponseHeaders(204, -1);\n\t\t\t\t\t\texchange.close();\n\t\t\t\t\t});\n\t\t\t\t\tExecutorService executorService = Executors.newCachedThreadPool();\n\t\t\t\t\tserver.setExecutor(executorService);\n\t\t\t\t\tserver.start(); // <3>\n\n\t\t\t\t\treturn new CloseableHttpServer(server, executorService);\n\t\t\t\t});\n\t\t\t}\n\t\t});",
        "human_comment": "tag::user_guide[]\nAvoid setup for test discovery by delaying it until tests are about to be executed\ntag::user_guide[]",
        "model_generated_comment": "Create a new {@link LauncherSession} for the supplied session.\n\n@param session the session to create; never {@code null}\n@return a new launcher session"
    },
    {
        "id": 645,
        "code_snippet": "public static Tensor fromBlob(IntBuffer data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_BUFFER_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.capacity(), shape);\n    checkArgument(data.isDirect(), ERROR_MSG_DATA_BUFFER_MUST_BE_DIRECT);\n    checkArgument(\n        (data.order() == ByteOrder.nativeOrder()),\n        ERROR_MSG_DATA_BUFFER_MUST_HAVE_NATIVE_BYTE_ORDER);\n    return new Tensor_int32(data, shape, memoryFormat);\n  }",
        "human_comment": "Creates a new Tensor instance with dtype torch.int32 with specified shape and data.\n\n@param data Direct buffer with native byte order that contains {@code Tensor.numel(shape)}\nelements. The buffer is used directly without copying, and changes to its content will\nchange the tensor.\n@param shape Tensor shape",
        "model_generated_comment": "Creates a new Tensor with the supplied data.\n\n@param data The data to put into the Tensor, may be {@code null}."
    },
    {
        "id": 646,
        "code_snippet": "public static void assertNotEquals(Byte unexpected, byte actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Byte) actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and {@link actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code messageSupplier}."
    },
    {
        "id": 647,
        "code_snippet": "void resetStatics() {\n\t\tthrowExceptionBeforeAll = true;\n\t\tthrowExceptionBeforeEach = true;\n\t\tthrowExceptionAfterEach = true;\n\t\tthrowExceptionAfterAll = true;\n\t\thandlerCalls.clear();\n\n\t\tSwallowExceptionHandler.callCounter.reset();\n\n\t\tRethrowExceptionHandler.callCounter.reset();\n\n\t\tConvertExceptionHandler.callCounter.reset();\n\n\t\tUnrecoverableExceptionHandler.callCounter.reset();\n\n\t\tShouldNotBeCalledHandler.callCounter.reset();\n\t}",
        "human_comment": "Tests that verify the support for lifecycle method execution exception handling\nvia {@link LifecycleMethodExecutionExceptionHandler}\n\n@since 5.5",
        "model_generated_comment": "Unit tests for {@link ThrowableExceptionHandler}.\n\n@since 5.4"
    },
    {
        "id": 648,
        "code_snippet": "public static Artifact toPomArtifact(Artifact artifact) {\n        Artifact pomArtifact = artifact;\n\n        if (!pomArtifact.getClassifier().isEmpty() || !\"pom\".equals(pomArtifact.getExtension())) {\n            pomArtifact =\n                    new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), \"pom\", artifact.getVersion());\n        }\n\n        return pomArtifact;\n    }",
        "human_comment": "<strong>Warning:</strong> This is an internal utility class that is only public for technical reasons, it is not part\nof the public API. In particular, this class can be changed or deleted without prior notice.",
        "model_generated_comment": "Creates a new Artifact with the given artifact.\n\n@param artifact the artifact to add to the new artifact\n@return a new artifact"
    },
    {
        "id": 649,
        "code_snippet": "default DependencyResolverResult collect(@Nonnull DependencyResolverRequest request) {\n        if (request.getRequestType() != DependencyResolverRequest.RequestType.COLLECT) {\n            throw new IllegalArgumentException(\"requestType should be COLLECT when calling collect()\");\n        }\n        return resolve(request);\n    }",
        "human_comment": "Collects the transitive dependencies and builds a dependency graph.\nNote that this operation is only concerned about determining the coordinates of the\ntransitive dependencies and does not actually resolve the artifact files.\n\n@param request the dependency collection request, must not be {@code null}\n@return the collection result, never {@code null}\n@throws DependencyResolverException if the dependency tree could not be built\n@throws IllegalArgumentException if an argument is null or invalid\n\n@see DependencyResolver#collect(Session, Project, PathScope)\n@see DependencyResolver#collect(Session, DependencyCoordinates, PathScope)\n@see DependencyResolver#collect(Session, Artifact, PathScope)",
        "model_generated_comment": "Collects a DependencyResolverResult from the supplied request.\n\n@param request The request to collect, may be {@code null}."
    },
    {
        "id": 650,
        "code_snippet": "public void setMaybeStringColumn(java.lang.String value) {\n    this.maybe_string_column = value;\n  }",
        "human_comment": "Sets the value of the 'maybe_string_column' field.\n@param value the value to set.",
        "model_generated_comment": "Sets the value of the `maybe_string_column` column.\n\n@param value the value to set."
    },
    {
        "id": 651,
        "code_snippet": "public final List<TestSource> getSources() {\n\t\treturn this.sources;\n\t}",
        "human_comment": "Get an immutable list of the {@linkplain TestSource sources} stored in this\n{@code CompositeTestSource}.\n\n@return the sources stored in this {@code CompositeTestSource}; never {@code null}",
        "model_generated_comment": "Get the sources of the supplied {@link TestSource}.\n\n@return this.sources; never {@code null}\n@see #getSources()"
    },
    {
        "id": 652,
        "code_snippet": "protected Object createTest() {\n            final CreateTestDefersToNoArgCreateTestTest obj = new CreateTestDefersToNoArgCreateTestTest();\n\n            obj.createTestCalled = true;\n\n            return obj;\n        }",
        "human_comment": "Runner for testing override of {@link org.junit.runners.BlockJUnit4ClassRunner#createTest()}\nis still called by default if no other {@code createTest} method override\nis in place. This is tested by setting a boolean flag in a field of the\ntest class so it can be checked to confirm that the createTest method was\ncalled.",
        "model_generated_comment": "Creates a new test instance.\n\n@param obj the test instance\n@return a new Test instance"
    },
    {
        "id": 653,
        "code_snippet": "public void setNestedIntsColumn(java.util.List<java.lang.Integer> value) {\n    this.nested_ints_column = value;\n  }",
        "human_comment": "Sets the value of the 'nested_ints_column' field.\n@param value the value to set.",
        "model_generated_comment": "Sets the value of the nested ints column.\n\n@param value the value to set."
    },
    {
        "id": 654,
        "code_snippet": "public UserPresenter(UserRepository dataSource, @Nullable UserView view) {\n        mDataSource = dataSource;\n        mView = view;\n\n        mLoadUserCallback = createLoadUserCallback();\n        mUpdateUserCallback = createUpdateUserCallback();\n    }",
        "human_comment": "Listens for users's actions from the UI {@link UserActivity}, retrieves the data and updates\nthe UI as required.",
        "model_generated_comment": "Create a {@link UserPresenter} with the supplied data source and view.\n\n@param dataSource The data source of the user, may be {@code null}."
    },
    {
        "id": 655,
        "code_snippet": "public void onCreate() {\n        super.onCreate();\n\n        mAppExecutors = new AppExecutors();\n    }",
        "human_comment": "Android Application class. Used for accessing singletons.",
        "model_generated_comment": "Create a new {@link AppExecutors}.\n\n@param onCreate() {@code onCreate}"
    },
    {
        "id": 656,
        "code_snippet": "public static <T> Predicate<Event> byPayload(Class<T> payloadType, Predicate<? super T> payloadPredicate) {\n\t\treturn event -> event.getPayload(payloadType).filter(payloadPredicate).isPresent();\n\t}",
        "human_comment": "Create a {@link Predicate} for {@linkplain Event events} whose payload\ntypes match the supplied {@code payloadType} and whose payloads match the\nsupplied {@code payloadPredicate}.\n\n@param payloadType the required payload type\n@param payloadPredicate a {@code Predicate} to match against payloads\n@return the resulting {@code Predicate}",
        "model_generated_comment": "Create a {@link Predicate} with the supplied payload type.\n\n@param payloadType the payload type to use; never {@code null}\n@return an {@see Predicate#getPayload(payloadType)"
    },
    {
        "id": 657,
        "code_snippet": "public static void assertNotEquals(float unexpected, float actual, float delta, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, delta, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal\nwithin the given {@code delta}.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and {@link actual} float are not equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 658,
        "code_snippet": "void testFormatRateThresholds() {\n        FileSizeFormat format = new FileSizeFormat();\n\n        MessageBuilder builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 45.0); // 45 B/s\n        assertEquals(\"45.0 B/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 15000.0); // 15 kB/s\n        assertEquals(\"15.0 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 5500.0); // 5.5 kB/s\n        assertEquals(\"5.5 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000.0); // 1 kB/s\n        assertEquals(\"1.0 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000000.0); // 1 MB/s\n        assertEquals(\"1.0 MB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000000000.0); // 1 GB/s\n        assertEquals(\"1.0 GB/s\", builder.build());\n    }",
        "human_comment": "Test value less than 0.05\nTest exact unit thresholds\nTest value greater than or equal to 10\nTest value between 0.05 and 10\nTest exact unit thresholds",
        "model_generated_comment": "Test the format rate thresholds in milliseconds.\n\n@param builder the builder to test"
    },
    {
        "id": 659,
        "code_snippet": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 0);\n\n    DecisionTreeRegressor dt = new DecisionTreeRegressor()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String impurity : DecisionTreeRegressor.supportedImpurities()) {\n      dt.setImpurity(impurity);\n    }\n    DecisionTreeRegressionModel model = dt.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.numNodes();\n    model.depth();\n    model.toDebugString();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model2.save(sc.sc(), path);\n      DecisionTreeRegressionModel sameModel = DecisionTreeRegressionModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model2, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
        "human_comment": "This tests setters. Training with various options is tested in Scala.\nTODO: Add test once save/load are implemented.   SPARK-6725",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 660,
        "code_snippet": "default Predicate<T> toPredicate() {\n\t\treturn object -> apply(object).included();\n\t}",
        "human_comment": "Return a {@link Predicate} that returns {@code true} if this filter\n<em>includes</em> the object supplied to the predicate's\n{@link Predicate#test test} method.",
        "model_generated_comment": "<em>Apply</em> to the supplied {@link Predicate}.\n\n@param object the {@code Predicate} to apply to; never\n{@code null}"
    },
    {
        "id": 661,
        "code_snippet": "void verbose_default() {\n\t\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\tTestExecutionListener listener = new VerboseTreePrintingListener(out, ColorPalette.DEFAULT, 16,\n\t\t\t\tTheme.ASCII);\n\n\t\t\tdemoTestRun(listener);\n\n\t\t\tassertDoesNotThrow(out::flush);\n\t\t}",
        "human_comment": "TODO Actually assert something in these \"demo\" tests and stop printing to SYSOUT.",
        "model_generated_comment": "Unit tests for {@link VerboseTreePrintingListener}.\n\n@since 5.4"
    },
    {
        "id": 662,
        "code_snippet": "private void validateOptionalProfiles(MavenSession session, ProfileActivation profileActivation) {\n        final Set<String> allAvailableProfiles = getAllProfiles(session);\n\n        final Set<String> optionalProfiles = new HashSet<>();\n        optionalProfiles.addAll(profileActivation.getOptionalActiveProfileIds());\n        optionalProfiles.addAll(profileActivation.getOptionalInactiveProfileIds());\n\n        final Set<String> notFoundOptionalProfiles = optionalProfiles.stream()\n                .filter(rap -> !allAvailableProfiles.contains(rap))\n                .collect(toSet());\n\n        if (!notFoundOptionalProfiles.isEmpty()) {\n            logger.info(\n                    \"The requested optional profiles {} could not be activated or deactivated because they do not\"\n                            + \" exist.\",\n                    notFoundOptionalProfiles);\n        }\n    }",
        "human_comment": "Check whether any of the requested optional profiles were not activated or deactivated.\n@param session the Maven session.\n@param profileActivation the requested optional and required profiles.",
        "model_generated_comment": "Validate optional profiles for Maven.\n\n@param session the session to validate, may be {@code null}."
    },
    {
        "id": 663,
        "code_snippet": "public static Condition<Event> result(Condition<TestExecutionResult> condition) {\n\t\treturn new Condition<>(byPayload(TestExecutionResult.class, condition::matches), \"event with result where %s\",\n\t\t\tcondition);\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if an\n{@link TestExecutionResult} that matches the supplied {@code Condition}.",
        "model_generated_comment": "Create a new {@link Condition} based on the supplied condition.\n\n@param condition the condition to check; never {@code null}\n@return a new{@code Condition} if the condition contains the supplied\n{@linkplain TestExecutionResult}.\n@since 5.4"
    },
    {
        "id": 664,
        "code_snippet": "public void setIntArraysColumn(java.util.List<java.util.List<java.lang.Integer>> value) {\n    this.int_arrays_column = value;\n  }",
        "human_comment": "Sets the value of the 'int_arrays_column' field.\n@param value the value to set.",
        "model_generated_comment": "Sets the value of the array.\n\n@param value the value to set."
    },
    {
        "id": 665,
        "code_snippet": "public int rfind(UTF8String str, int start) {\n    assert (str.numBytes > 0);\n    while (start >= 0) {\n      if (ByteArrayMethods.arrayEquals(base, offset + start, str.base, str.offset, str.numBytes)) {\n        return start;\n      }\n      start -= 1;\n    }\n    return -1;\n  }",
        "human_comment": "Find the `str` from right to left.",
        "model_generated_comment": "Returns the value of the given string.\n\n@param str the string to find\n@return The value of this string."
    },
    {
        "id": 666,
        "code_snippet": "public TestClassPredicates(DiscoveryIssueReporter issueReporter) {\n\t\tthis.isTestOrTestFactoryOrTestTemplateMethod = new IsTestMethod(issueReporter) //\n\t\t\t\t.or(new IsTestFactoryMethod(issueReporter)) //\n\t\t\t\t.or(new IsTestTemplateMethod(issueReporter));\n\t\tthis.isValidNestedTestClass = isNotPrivateUnlessAbstract(\"@Nested\", issueReporter) //\n\t\t\t\t.and(isInner(issueReporter));\n\t\tthis.isValidStandaloneTestClass = isNotPrivateUnlessAbstract(\"Test\", issueReporter) //\n\t\t\t\t.and(isNotLocal(issueReporter)) //\n\t\t\t\t.and(isNotInner(issueReporter)) // or should be annotated with @Nested!\n\t\t\t\t.and(isNotAnonymous(issueReporter));\n\t}",
        "human_comment": "Predicates for determining whether a class is a JUnit Jupiter test class.\n\n@since 5.13",
        "model_generated_comment": "Create a new {@link TestClassPredicates(DiscoveryIssueReporter)}.\n\n@param issueReporter the issue to annotate; never {@code null}"
    },
    {
        "id": 667,
        "code_snippet": "public void onSuccess(ByteBuffer response) {\n      BlockPushReturnCode pushResponse =\n        (BlockPushReturnCode) BlockTransferMessage.Decoder.fromByteBuffer(response);\n      ReturnCode returnCode = BlockPushNonFatalFailure.getReturnCode(pushResponse.returnCode);\n      if (returnCode != ReturnCode.SUCCESS) {\n        String blockId = pushResponse.failureBlockId;\n        Preconditions.checkArgument(!blockId.isEmpty());\n        checkAndFailRemainingBlocks(index, new BlockPushNonFatalFailure(returnCode,\n          BlockPushNonFatalFailure.getErrorMsg(blockId, returnCode)));\n      } else {\n        listener.onBlockPushSuccess(blockId, new NioManagedBuffer(ByteBuffer.allocate(0)));\n      }\n    }",
        "human_comment": "If the return code is not SUCCESS, the server has responded some error code. Handle\nthe error accordingly.\nOn receipt of a successful block push",
        "model_generated_comment": "Check if the block is empty.\n\n@param response the response to check\n@return the return code of the block"
    },
    {
        "id": 668,
        "code_snippet": "public void setStringToIntsColumn(java.util.Map<java.lang.String,java.util.List<java.lang.Integer>> value) {\n    this.string_to_ints_column = value;\n  }",
        "human_comment": "Sets the value of the 'string_to_ints_column' field.\n@param value the value to set.",
        "model_generated_comment": "Set the string to ints column.\n\n@param value the value to set."
    },
    {
        "id": 669,
        "code_snippet": "public static void checkState(boolean expression) {\n    if (!expression) {\n      throw new IllegalStateException();\n    }\n  }",
        "human_comment": "Ensures the truth of an expression involving the state of the calling instance, but not\ninvolving any parameters to the calling method.\n\n@param expression a boolean expression\n@throws IllegalStateException if {@code expression} is false",
        "model_generated_comment": "Check the state of an expression.\n\n@param expression The expression to check.\n@return The state of the expression."
    },
    {
        "id": 670,
        "code_snippet": "public WashingMachine(DelayProvider delayProvider) {\n    this.delayProvider = delayProvider;\n    this.washingMachineState = WashingMachineState.ENABLED;\n  }",
        "human_comment": "Creates a new instance of WashingMachine using provided delayProvider. This constructor is used\nonly for unit testing purposes.",
        "model_generated_comment": "Creates a new WashingMachine instance.\n\n@param delayProvider the delayProvider\n@return a Washing Machine instance"
    },
    {
        "id": 671,
        "code_snippet": "public void onUserLoaded_updatesView() {\n        mPresenter.start();\n        verify(mUserRepository).getUser(mLoadUserCallbackArgumentCaptor.capture());\n\n        User user = new User(\"user name\");\n        mLoadUserCallbackArgumentCaptor.getValue().onUserLoaded(user);\n\n        verify(mView).showUserName(\"user name\");\n    }",
        "human_comment": "Given that start is called\nCallback is captured\nWhen the user is loaded\nThe view is updated with the correct user name",
        "model_generated_comment": "Check if the user has been loaded.\n\n@param user the user to check."
    },
    {
        "id": 672,
        "code_snippet": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
        "human_comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception.",
        "model_generated_comment": "<em>Assert</em> that the execution of the main {@link App} throws an exception.\n\n@param String the String to check; never {@code null}"
    },
    {
        "id": 673,
        "code_snippet": "public static XmlNode merge(XmlNode dominant, XmlNode recessive) {\n        return XmlService.merge(dominant, recessive);\n    }",
        "human_comment": "Merge two DOMs, with one having dominance in the case of collision. Merge mechanisms (vs. override for nodes, or\nvs. append for children) is determined by attributes of the dominant root node.\n\n@see XmlService#CHILDREN_COMBINATION_MODE_ATTRIBUTE\n@see XmlService#SELF_COMBINATION_MODE_ATTRIBUTE\n@param dominant The dominant DOM into which the recessive value/attributes/children will be merged\n@param recessive The recessive DOM, which will be merged into the dominant DOM\n@return merged DOM\n\n@deprecated use {@link XmlService#merge(XmlNode, XmlNode, Boolean)} instead",
        "model_generated_comment": "Merges two Xml nodes.\n\n@param dominant the dominant node and recessive the recessive node.\n@return the merged XmlNode"
    },
    {
        "id": 674,
        "code_snippet": "public static void assertNotEquals(byte unexpected, Byte actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Byte) unexpected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and {@link actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code messageSupplier}.\n\n@since 5.4"
    },
    {
        "id": 675,
        "code_snippet": "public static Tensor<Boolean> create(boolean data) {\n    return Tensor.create(data, Boolean.class);\n  }",
        "human_comment": "Creates a scalar tensor containing a single {@code boolean} element.\n\n@param data The value to put into the new scalar tensor.",
        "model_generated_comment": "Creates a rank-4 tensor of {@code boolean} elements.\n\n@param data An array containing the values to put into the new tensor."
    },
    {
        "id": 676,
        "code_snippet": "private void registerAfterEachMethodAdapters(ExtensionRegistrar registrar) {\n\t\tList<Method> afterEachMethods = new ArrayList<>(this.lifecycleMethods.afterEach);\n\n\t\tCollections.reverse(afterEachMethods);\n\n\t\tregisterMethodsAsExtensions(afterEachMethods, registrar, this::synthesizeAfterEachMethodAdapter);\n\t}",
        "human_comment": "Make a local copy since findAfterEachMethods() returns an immutable list.\nSince the bottom-up ordering of afterEachMethods will later be reversed when the\nsynthesized AfterEachMethodAdapters are executed within TestMethodTestDescriptor,\nwe have to reverse the afterEachMethods list to put them in top-down order before\nwe register them as synthesized extensions.",
        "model_generated_comment": "Register the {@link AfterEachMethodAdapters} as extensions.\n\n@param registrar the registrar to register the extensions; never {@code null}\n@return the list of extensions"
    },
    {
        "id": 677,
        "code_snippet": "void beforeAllCallbackThrowsAnException() {\n\t\tassertBeforeAllAndAfterAllCallbacks(ExceptionInBeforeAllCallbackTestCase.class, 0, 0,\n\t\t\t\"fooBeforeAllCallback\",\n\t\t\t\"exceptionThrowingBeforeAllCallback\", // throws an exception.\n\t\t\t\"fooAfterAllCallback\"\n\t\t);\n\n\t\tassertThat(actualExceptionInAfterAllCallback).containsInstanceOf(EnigmaException.class);\n\t}",
        "human_comment": "@formatter:off\nbeforeAllMethod should not get invoked.\ntest should not get invoked.\nafterAllMethod should not get invoked.\n@formatter:on",
        "model_generated_comment": "Unit tests for {@link ExceptionThrowingBeforeAllCallback}.\n\n@since 5.0"
    },
    {
        "id": 678,
        "code_snippet": "public void reset() {\n    updatePeakMemoryUsed();\n    numKeys = 0;\n    numValues = 0;\n    freeArray(longArray);\n    longArray = null;\n    while (dataPages.size() > 0) {\n      MemoryBlock dataPage = dataPages.removeLast();\n      freePage(dataPage);\n    }\n    allocate(initialCapacity);\n    canGrowArray = true;\n    currentPage = null;\n    pageCursor = 0;\n  }",
        "human_comment": "Reset this map to initialized state.",
        "model_generated_comment": "Resets the memory used by the data page.\n\n@param dataPage The data page to reset, may be {@code null}."
    },
    {
        "id": 679,
        "code_snippet": "static WeaponFactory factory(Consumer<Builder> consumer) {\n    var map = new HashMap<WeaponType, Supplier<Weapon>>();\n    consumer.accept(map::put);\n    return name -> map.get(name).get();\n  }",
        "human_comment": "Creates an instance of the given type.\n\n@param name representing enum of an object type to be created.\n@return new instance of a requested class implementing {@link Weapon} interface.\n\n@param consumer for the new builder to the factory.\n@return factory with specified {@link Builder}s",
        "model_generated_comment": "Creates a factory with the supplied weapon type.\n\n@param consumer The weapon type\n@return a factory instance"
    },
    {
        "id": 680,
        "code_snippet": "boolean detectByteBuffer(ByteBuffer imgData, int imageId) {\n    if (tflite == null) {\n      throw new RuntimeException(TAG + \": Detector has not been initialized; Failed.\");\n    }\n\n    Object[] inputArray = {imgData};\n    tflite.runForMultipleInputsOutputs(inputArray, outputMap);\n\n    Long latencyMilli = getLastNativeInferenceLatencyMilliseconds();\n    Long latencyNano = getLastNativeInferenceLatencyNanoseconds();\n\n    // Update the results.\n    result.resetTo(latencyMilli, latencyNano, imageId);\n    for (int i = 0; i < NUM_RESULTS; i++) {\n      // The model returns normalized coordinates [start_y, start_x, end_y, end_x].\n      // The boxes expect pixel coordinates [x1, y1, x2, y2].\n      // The height and width of the input are in inputDims[1] and inputDims[2].\n      // The following command converts between model outputs to bounding boxes.\n      result.addBox(\n          outputLocations[0][i][1] * inputDims[2],\n          outputLocations[0][i][0] * inputDims[1],\n          outputLocations[0][i][3] * inputDims[2],\n          outputLocations[0][i][2] * inputDims[1],\n          Math.round(outputClasses[0][i] + 1 /* Label offset */),\n          outputScores[0][i]);\n    }\n    return true;  // Marks that the result is available.\n  }",
        "human_comment": "The interface to run the detection. This method currently only support float mobilenet_ssd\nmodel. The quantized models will be added in the future.\n\n@param imgData The image buffer in ByteBuffer format.\n@return boolean indicator of whether detection was a success. If success, the detection results\nis available in the result member variable.\nSee OvicDetectionResult.java for details.",
        "model_generated_comment": "Sets the input data into a single buffer.\n\n@param imgData The input data, may be {@code null}.\n@return true if the result is available."
    },
    {
        "id": 681,
        "code_snippet": "public String alignToBaseDirectory(String path, File basedir) {\n        String result = path;\n\n        if (path != null && basedir != null) {\n            path = path.replace('\\\\', File.separatorChar).replace('/', File.separatorChar);\n\n            File file = new File(path);\n            if (file.isAbsolute()) {\n                // path was already absolute, just normalize file separator and we're done\n                result = file.getPath();\n            } else if (file.getPath().startsWith(File.separator)) {\n                // drive-relative Windows path, don't align with project directory but with drive root\n                result = file.getAbsolutePath();\n            } else {\n                // an ordinary relative path, align with project directory\n                result = new File(new File(basedir, path).toURI().normalize()).getAbsolutePath();\n            }\n        }\n\n        return result;\n    }",
        "human_comment": "Resolves relative paths against a specific base directory.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead",
        "model_generated_comment": "Convert the given path to the given basedir.\n\n@param path the path to align to the base directory\n@return true if the path is absolute"
    },
    {
        "id": 682,
        "code_snippet": "protected TransportVehicle(String manufacturer, String model, int loadCapacity) {\n    super(manufacturer, model);\n    this.loadCapacity = loadCapacity;\n  }",
        "human_comment": "An abstract class that extends the Vehicle class and provides properties for the Transport type\nof Vehicles.\n\n@see Vehicle",
        "model_generated_comment": "Creates a TransportVehicle with the specified manufacturer and loadCapacity.\n\n@param manufacturer the manufacturer of the vehicle."
    },
    {
        "id": 683,
        "code_snippet": "private static void closeAll(List<CloseablePath> paths) {\n\t\tvar throwableCollector = new OpenTest4JAwareThrowableCollector();\n\t\tpaths.forEach(closeablePath -> throwableCollector.execute(closeablePath::close));\n\t\tthrowableCollector.assertEmpty();\n\t}",
        "human_comment": "Close all but the first path\nClose last remaining path",
        "model_generated_comment": "Close all {@link CloseablePath} of the supplied path.\n\n@param paths the paths to close; never {@code null}\n@see #closeAll(CloseablePath)"
    },
    {
        "id": 684,
        "code_snippet": "public void insertAndGetUser() {\n        mDatabase.userDao().insertUser(USER).blockingAwait();\n\n        mDatabase.userDao().getUser()\n                .test()\n                .assertValue(user -> {\n                    return user != null && user.getId().equals(USER.getId()) &&\n                            user.getUserName().equals(USER.getUserName());\n                });\n    }",
        "human_comment": "When inserting a new user in the data source\nWhen subscribing to the emissions of the user\nassertValue asserts that there was only one emission of the user\nThe emitted user is the expected one",
        "model_generated_comment": "Inserts the user into the database.\n\n@param user the user to insert\n@return The user"
    },
    {
        "id": 685,
        "code_snippet": "public UniqueId appendEngine(String engineId) {\n\t\treturn append(new Segment(ENGINE_SEGMENT_TYPE, engineId));\n\t}",
        "human_comment": "Construct a new {@code UniqueId} by appending a new {@link Segment}, based\n\n<p>This {@code UniqueId} will not be modified.\n\n<p>The engine ID will be stored in a {@link Segment} with\n{@link Segment#getType type} {@value #ENGINE_SEGMENT_TYPE}.\n\n@param engineId the engine ID; never {@code null} or blank\n\n@since 1.8",
        "model_generated_comment": "Append a {@link UniqueId} to the supplied engine.\n\n@param engineId the engine ID to append; never {@code null} or blank"
    },
    {
        "id": 686,
        "code_snippet": "public void throwsTestTimedOutExceptionWithMeaningfulMessage() {\n        Exception e = assertThrows(\n                TestTimedOutException.class,\n                run(failAfter50Ms(new RunForASecond())));\n        assertEquals(\"test timed out after 50 milliseconds\", e.getMessage());\n    }",
        "human_comment": "test is successful when no exception is thrown",
        "model_generated_comment": "<em>Assert</em> that the test timed out after 50 milliseconds."
    },
    {
        "id": 687,
        "code_snippet": "public void onResume() {\n    super.onResume();\n    startBackgroundThread();\n\n    if (textureView.isAvailable()) {\n      camera.startPreview();\n    } else {\n      textureView.setSurfaceTextureListener(surfaceTextureListener);\n    }\n  }",
        "human_comment": "When the screen is turned off and turned back on, the SurfaceTexture is already\navailable, and \"onSurfaceTextureAvailable\" will not be called. In that case, we can open\na camera and start preview from here (otherwise, we wait until the surface is ready in\nthe SurfaceTextureListener).",
        "model_generated_comment": "Creates a new {@link TextureView} for the camera.\n\n@param camera the camera to watch."
    },
    {
        "id": 688,
        "code_snippet": "private void setVariable(final Double variable) {\n    model = new CalculatorModel(variable, model.getOutput());\n  }",
        "human_comment": "Set new calculator model variable.\n\n@param variable -> value of new calculator model variable.",
        "model_generated_comment": "Set the variable value of the variable.\n\n@param variable the variable variable to set."
    },
    {
        "id": 689,
        "code_snippet": "public UnknownRepositoryLayoutException(String repositoryId, String layoutId) {\n        super(\"Cannot find ArtifactRepositoryLayout instance for: \" + layoutId, repositoryId);\n        this.layoutId = layoutId;\n    }",
        "human_comment": "Exception which is meant to occur when a layout specified for a particular\nrepository doesn't have a corresponding {@link org.apache.maven.artifact.repository.layout.ArtifactRepositoryLayout}\ncomponent in the current container.",
        "model_generated_comment": "Creates an exception for {@link ArtifactRepositoryLayout}.\n\n@param repositoryId The repository ID of the repository, may be {@code null}."
    },
    {
        "id": 690,
        "code_snippet": "public void vectorIndexerAPI() {\n    List<FeatureData> points = Arrays.asList(\n      new FeatureData(Vectors.dense(0.0, -2.0)),\n      new FeatureData(Vectors.dense(1.0, 3.0)),\n      new FeatureData(Vectors.dense(1.0, 4.0))\n    );\n    Dataset<Row> data = spark.createDataFrame(jsc.parallelize(points, 2), FeatureData.class);\n    VectorIndexer indexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexed\")\n      .setMaxCategories(2);\n    VectorIndexerModel model = indexer.fit(data);\n    Assertions.assertEquals(2, model.numFeatures());\n    Map<Integer, Map<Double, Integer>> categoryMaps = model.javaCategoryMaps();\n    Assertions.assertEquals(1, categoryMaps.size());\n    Dataset<Row> indexedData = model.transform(data);\n  }",
        "human_comment": "The tests are to check Java compatibility.",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 691,
        "code_snippet": "private boolean acquireNewPage(long required) {\n    try {\n      currentPage = allocatePage(required);\n    } catch (SparkOutOfMemoryError e) {\n      return false;\n    }\n    dataPages.add(currentPage);\n    UnsafeAlignedOffset.putSize(currentPage.getBaseObject(), currentPage.getBaseOffset(), 0);\n    pageCursor = UnsafeAlignedOffset.getUaoSize();\n    return true;\n  }",
        "human_comment": "Acquire a new page from the memory manager.\n@return whether there is enough space to allocate the new page.",
        "model_generated_comment": "Retrieves a new page.\n\n@param required the required page to acquire.\n@return true if the new page is not available."
    },
    {
        "id": 692,
        "code_snippet": "public void tfIdfMinimumDocumentFrequency() {\n    HashingTF tf = new HashingTF();\n    JavaRDD<List<String>> documents = jsc.parallelize(Arrays.asList(\n      Arrays.asList(\"this is a sentence\".split(\" \")),\n      Arrays.asList(\"this is another sentence\".split(\" \")),\n      Arrays.asList(\"this is still a sentence\".split(\" \"))), 2);\n    JavaRDD<Vector> termFreqs = tf.transform(documents);\n    termFreqs.collect();\n    IDF idf = new IDF(2);\n    JavaRDD<Vector> tfIdfs = idf.fit(termFreqs).transform(termFreqs);\n    List<Vector> localTfIdfs = tfIdfs.collect();\n    int indexOfThis = tf.indexOf(\"this\");\n    for (Vector v : localTfIdfs) {\n      Assertions.assertEquals(0.0, v.apply(indexOfThis), 1e-15);\n    }\n  }",
        "human_comment": "The tests are to check Java compatibility.",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 693,
        "code_snippet": "public static List<String> getModelsAfter2000(List<Car> cars) {\n    return cars.stream()\n        .filter(car -> car.year() > 2000)\n        .sorted(Comparator.comparing(Car::year))\n        .map(Car::model)\n        .toList();\n  }",
        "human_comment": "Method to get models using for collection pipeline.\n\n@param cars {@link List} of {@link Car} to be used for filtering\n@return {@link List} of {@link String} representing models built after year 2000",
        "model_generated_comment": "Returns a list of models after 2000.\n\n@param cars The cars to get, must not be <code>null</code>."
    },
    {
        "id": 694,
        "code_snippet": "public T setMainClass(String mainClass) {\n    checkNotNull(mainClass, \"mainClass\");\n    builder.mainClass = mainClass;\n    return self();\n  }",
        "human_comment": "Sets the application class name for Java/Scala applications.\n\n@param mainClass Application's main class.\n@return This launcher.",
        "model_generated_comment": "Set the main class.\n\n@param mainClass the class to set."
    },
    {
        "id": 695,
        "code_snippet": "private List<String> getProjects(Properties props) {\n        List<String> projects = new ArrayList<>();\n\n        for (Object o : props.keySet()) {\n            String key = o.toString();\n            if (key.startsWith(\"project.collectedProjects.\") && !key.endsWith(\".size\")) {\n                projects.add(props.getProperty(key));\n            }\n        }\n\n        Collections.sort(projects);\n\n        return projects;\n    }",
        "human_comment": "Verify that MavenProject.getCollectedProjects() provides access to the direct and indirect modules\nof the current project.\n\n@throws Exception in case of failure",
        "model_generated_comment": "Get the projects of the given project.\n\n@param props The props to get the projects from.\n@return the projects, never {@code null}"
    },
    {
        "id": 696,
        "code_snippet": "public Optional<Throwable> getError() {\n    return redirector != null ? Optional.ofNullable(redirector.getError()) : Optional.empty();\n  }",
        "human_comment": "Parses the logs of {@code spark-submit} and returns the last exception thrown.\n<p>\nSince {@link SparkLauncher} runs {@code spark-submit} in a sub-process, it's difficult to\naccurately retrieve the full {@link Throwable} from the {@code spark-submit} process.\nThis method parses the logs of the sub-process and provides a best-effort attempt at\nreturning the last exception thrown by the {@code spark-submit} process. Only the exception\nmessage is parsed, the associated stacktrace is meaningless.\n\n@return an {@link Optional} containing a {@link RuntimeException} with the parsed\nexception, otherwise returns a {@link Optional#EMPTY}",
        "model_generated_comment": "Returns an exception for the supplied {@link Throwable}.\n\n@param redirector The {@code Throwable} to be retrieved.\n@return an exception"
    },
    {
        "id": 697,
        "code_snippet": "default void attachArtifact(@Nonnull Session session, @Nonnull Project project, @Nonnull Path path) {\n        String name = path.getFileName().toString();\n        int dot = name.lastIndexOf('.');\n        String ext = dot >= 1 ? name.substring(dot + 1) : \"\";\n        ProducedArtifact artifact = session.createProducedArtifact(\n                project.getGroupId(), project.getArtifactId(), project.getVersion(), ext);\n        attachArtifact(project, artifact, path);\n    }",
        "human_comment": "Attaches an artifact to the project using the given file path. The artifact type will be\ndetermined from the file extension. This method is thread-safe and ensures proper\nsynchronization of the project's artifact state.\n\n@param session the current build session\n@param project the project to attach the artifact to\n@param path the path to the artifact file",
        "model_generated_comment": "Asserts that an artifact has been created.\n\n@param session The session to attach the artifact to, may be {@code null}."
    },
    {
        "id": 698,
        "code_snippet": "public ModelResolverException(String message, String groupId, String artifactId, String version) {\n        super(message);\n        this.groupId = (groupId != null) ? groupId : \"\";\n        this.artifactId = (artifactId != null) ? artifactId : \"\";\n        this.version = (version != null) ? version : \"\";\n    }",
        "human_comment": "Creates a new exception with specified detail message.\n\n@param message The detail message, may be {@code null}.\n@param groupId The group id of the unresolvable model, may be {@code null}.\n@param artifactId The artifact id of the unresolvable model, may be {@code null}.\n@param version The version of the unresolvable model, may be {@code null}.",
        "model_generated_comment": "Creates a {@link ModelResolverException} with the given message.\n\n@param message the message to throw.\n@return {@code true} if the message is null."
    },
    {
        "id": 699,
        "code_snippet": "void testSuccessfulTaskWithCallback() {\n    assertTimeout(\n        ofMillis(3000),\n        () -> {\n          // Instantiate a new executor and start a new 'null' task ...\n          final var executor = new ThreadAsyncExecutor();\n\n          final var result = new Object();\n          when(task.call()).thenReturn(result);\n\n          final var asyncResult = executor.startProcess(task, callback);\n          assertNotNull(asyncResult);\n          asyncResult.await(); // Prevent timing issues, and wait until the result is available\n          assertTrue(asyncResult.isCompleted());\n\n          // Our task should only execute once ...\n          verify(task, times(1)).call();\n\n          // ... same for the callback, we expect our object\n          verify(callback, times(1)).onComplete(eq(result));\n          verify(callback, times(0)).onError(exceptionCaptor.capture());\n\n          // ... and the result should be exactly the same object\n          assertSame(result, asyncResult.getValue());\n        });\n  }",
        "human_comment": "Test used to verify the happy path of {@link ThreadAsyncExecutor#startProcess(Callable,\nAsyncCallback)}",
        "model_generated_comment": "Test the execution of the task with the callback.\n\n@param callback the callback to check."
    },
    {
        "id": 700,
        "code_snippet": "public static void mute(CheckedRunnable runnable) {\n    try {\n      runnable.run();\n    } catch (Exception e) {\n      throw new AssertionError(e);\n    }\n  }",
        "human_comment": "Executes the <code>runnable</code> and throws the exception occurred within a {@link\nAssertionError}. This method should be utilized to mute the operations that are guaranteed not\nto throw an exception. For instance {@link ByteArrayOutputStream#write(byte[])} declares in its\nsignature that it can throw an {@link IOException}, but in reality it cannot. This is because\nthe bulk write method is not overridden in {@link ByteArrayOutputStream}.\n\n@param runnable a runnable that should never throw an exception on execution.",
        "model_generated_comment": "Moves the runnable to mute."
    },
    {
        "id": 701,
        "code_snippet": "public synchronized boolean isAlive() {\n    return getHealth() > 0;\n  }",
        "human_comment": "Checks if the creature is still alive.\n\n@return true of creature is alive.",
        "model_generated_comment": "Returns the health of the user.\n\n@param health the health to check."
    },
    {
        "id": 702,
        "code_snippet": "public static Timeout millis(long millis) {\n        return new Timeout(millis, TimeUnit.MILLISECONDS);\n    }",
        "human_comment": "Creates a {@link Timeout} that will timeout a test after the\ngiven duration, in milliseconds.\n\n@since 4.12",
        "model_generated_comment": "Creates a new Timeout for the given time interval.\n\n@param millis The time interval to put into the new timeout."
    },
    {
        "id": 703,
        "code_snippet": "public String getMethodName() {\n        return methodAndClassNamePatternGroupOrDefault(1, null);\n    }",
        "human_comment": "@return If this describes a method invocation,\nthe name of the method (or null if not)",
        "model_generated_comment": "Returns the name of the method.\n\n@param method the class name\n@return the method name"
    },
    {
        "id": 704,
        "code_snippet": "public void standardScaler() {\n    List<VectorIndexerSuite.FeatureData> points = Arrays.asList(\n      new VectorIndexerSuite.FeatureData(Vectors.dense(0.0, -2.0)),\n      new VectorIndexerSuite.FeatureData(Vectors.dense(1.0, 3.0)),\n      new VectorIndexerSuite.FeatureData(Vectors.dense(1.0, 4.0))\n    );\n    Dataset<Row> dataFrame = spark.createDataFrame(jsc.parallelize(points, 2),\n      VectorIndexerSuite.FeatureData.class);\n    StandardScaler scaler = new StandardScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\")\n      .setWithStd(true)\n      .setWithMean(false);\n\n    StandardScalerModel scalerModel = scaler.fit(dataFrame);\n\n    Dataset<Row> scaledData = scalerModel.transform(dataFrame);\n    scaledData.count();\n  }",
        "human_comment": "The tests are to check Java compatibility.\nCompute summary statistics by fitting the StandardScaler\nNormalize each feature to have unit standard deviation.",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 705,
        "code_snippet": "public static void assertNotEquals(Short unexpected, short actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Short) actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and{@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@link #equals(Short, Long)}.\n\n@since 5.4"
    },
    {
        "id": 706,
        "code_snippet": "public static UTF8String exec(final UTF8String v, final int collationId, boolean useICU) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType) {\n        return useICU ? execBinaryICU(v) : execBinary(v);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(v);\n      } else {\n        return execICU(v, collationId);\n      }\n    }",
        "human_comment": "Space trimming does not affect the output of this expression.",
        "model_generated_comment": "Creates a UTF8String with the given collation id.\n\n@param v The collation ID of the collation, must not be <code>null</code>."
    },
    {
        "id": 707,
        "code_snippet": "private LatencyCriteria tryLoadLatencyCriteria(String fileBasename) {\n    try {\n      return loadLatencyCriteria(fileBasename);\n    } catch (IOException e) {\n      Log.w(\n          TAG,\n          \"Failed to load the latency criteria of \"\n              + fileBasename\n              + \". Fallback to the default latency criteria.\");\n    }\n    return defaultLatencyCriteria;\n  }",
        "human_comment": "Tries to load the model-specific latency criteria file by the model name.\n\n<p>Returns the latency criteria for the specific model if the loading was successful.\nOtherwise, returns the default latency criteria.",
        "model_generated_comment": "Try to load the latency criteria of {@link LatencyCriteria}.\n\n@param fileBasename the name of the file to load, may be {@code null}."
    },
    {
        "id": 708,
        "code_snippet": "public static void main(String[] args) {\n\n    // Demonstrates the PropertiesFeatureToggleVersion running with properties\n    // that set the feature toggle to enabled.\n\n    final var properties = new Properties();\n    properties.put(\"enhancedWelcome\", true);\n    var service = new PropertiesFeatureToggleVersion(properties);\n    final var welcomeMessage = service.getWelcomeMessage(new User(\"Jamie No Code\"));\n    LOGGER.info(welcomeMessage);\n\n    // Demonstrates the PropertiesFeatureToggleVersion running with properties\n    // that set the feature toggle to disabled. Note the difference in the printed welcome message\n    // where the username is not included.\n\n    final var turnedOff = new Properties();\n    turnedOff.put(\"enhancedWelcome\", false);\n    var turnedOffService = new PropertiesFeatureToggleVersion(turnedOff);\n    final var welcomeMessageturnedOff =\n        turnedOffService.getWelcomeMessage(new User(\"Jamie No Code\"));\n    LOGGER.info(welcomeMessageturnedOff);\n\n    // Demonstrates the TieredFeatureToggleVersion setup with\n    // two users: one on the free tier and the other on the paid tier. When the\n    // Service#getWelcomeMessage(User) method is called with the paid user, the welcome\n    // message includes their username. In contrast, calling the same service with the free tier\n    // user results\n    // in a more generic welcome message without the username.\n\n    var service2 = new TieredFeatureToggleVersion();\n\n    final var paidUser = new User(\"Jamie Coder\");\n    final var freeUser = new User(\"Alan Defect\");\n\n    UserGroup.addUserToPaidGroup(paidUser);\n    UserGroup.addUserToFreeGroup(freeUser);\n\n    final var welcomeMessagePaidUser = service2.getWelcomeMessage(paidUser);\n    final var welcomeMessageFreeUser = service2.getWelcomeMessage(freeUser);\n    LOGGER.info(welcomeMessageFreeUser);\n    LOGGER.info(welcomeMessagePaidUser);\n  }",
        "human_comment": "Block 1 shows the {@link PropertiesFeatureToggleVersion} being run with {@link Properties}\nsetting the feature toggle to enabled.\n\n<p>Block 2 shows the {@link PropertiesFeatureToggleVersion} being run with {@link Properties}\nsetting the feature toggle to disabled. Notice the difference with the printed welcome message\nthe username is not included.\n\n<p>Block 3 shows the {@link\ncom.iluwatar.featuretoggle.pattern.tieredversion.TieredFeatureToggleVersion} being set up with\ntwo users on who is on the free level, while the other is on the paid level. When the {@link\nService#getWelcomeMessage(User)} is called with the paid {@link User} note that the welcome\nmessage contains their username, while the same service call with the free tier user is more\ngeneric. No username is printed.\n\n@see User\n@see UserGroup\n@see Service\n@see PropertiesFeatureToggleVersion\n@see com.iluwatar.featuretoggle.pattern.tieredversion.TieredFeatureToggleVersion",
        "model_generated_comment": "$example on$\n$example off$\nLoad the PropertiesFeatureToggleVersion with the specified properties.\n\n@param args the properties to load, may be {@code null}."
    },
    {
        "id": 709,
        "code_snippet": "public String[] getSupportedProtocols() {\n        return new String[] {\"a\"};\n}",
        "human_comment": "Wagon for testing, for protocol <code>a</code>",
        "model_generated_comment": "Get supported implementations of {@link String}.\n\n@since 5.0"
    },
    {
        "id": 710,
        "code_snippet": "public ThreadFactoryWithGarbageCleanup(String threadPoolName) {\n    namePrefix = threadPoolName;\n  }",
        "human_comment": "A ThreadFactory for constructing new HiveServer2 threads that lets you plug\nin custom cleanup code to be called before this thread is GC-ed.\nCurrently cleans up the following:\n1. ThreadLocal RawStore object:\nIn case of an embedded metastore, HiveServer2 threads (foreground and background)\nend up caching a ThreadLocal RawStore object. The ThreadLocal RawStore object has\nan instance of PersistenceManagerFactory and PersistenceManager.\nThe PersistenceManagerFactory keeps a cache of PersistenceManager objects,\nwhich are only removed when PersistenceManager#close method is called.\nHiveServer2 uses ExecutorService for managing thread pools for foreground and background threads.\nExecutorService unfortunately does not provide any hooks to be called,\nwhen a thread from the pool is terminated.\nAs a solution, we're using this ThreadFactory to keep a cache of RawStore objects per thread.\nAnd we are doing clean shutdown in the finalizer for each thread.",
        "model_generated_comment": "Create a new {@link ThreadFactory} that cleans up garbage.\n\n@param threadPoolName the name of the thread to clean up."
    },
    {
        "id": 711,
        "code_snippet": "void assertDoesNotThrowWithMethodReferenceForNonVoidReturnType() {\n\t\tFutureTask<String> future = new FutureTask<>(() -> {\n\t\tfuture.run();\n\n\t\tString result;\n\n\t\t// Current compiler's type inference: does NOT compile since the compiler\n\t\t// cannot figure out which overloaded variant of assertDoesNotThrow() to\n\t\t// invoke (i.e., Executable vs. ThrowingSupplier).\n\t\t//\n\t\t// result = assertDoesNotThrow(future::get);\n\n\t\t// Explicitly as an Executable\n\t\tassertDoesNotThrow((Executable) future::get);\n\n\t\t// Explicitly as a ThrowingSupplier\n\t\tresult = assertDoesNotThrow((ThrowingSupplier<String>) future::get);\n\t\tassertEquals(\"foo\", result);\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithMethodReferenceForVoidReturnType() {\n\t\tvar foo = new Foo();\n\n\t\t// Note: the following does not compile since the compiler cannot properly\n\t\t// perform type inference for a method reference for an overloaded method\n\t\t// that has a void return type such as Foo.overloaded(...), IFF the\n\t\t// compiler is simultaneously trying to pick which overloaded variant\n\t\t// of assertDoesNotThrow() to invoke.\n\t\t//\n\t\t// assertDoesNotThrow(foo::overloaded);\n\n\t\t// Current compiler's type inference\n\t\tassertDoesNotThrow(foo::normalMethod);\n\n\t\t// Explicitly as an Executable\n\t\tassertDoesNotThrow(foo::normalMethod);\n\t\tassertDoesNotThrow((Executable) foo::overloaded);\n\t}\n\n\t// --- executable ----------------------------------------------------------\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithExecutable() {\n\t\tassertDoesNotThrow(nix);\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithExecutableAndMessage() {\n\t\tassertDoesNotThrow(nix, \"message\");\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithExecutableAndMessageSupplier() {\n\t\tassertDoesNotThrow(nix, () -> \"message\");\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsACheckedException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IOException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IOException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsACheckedExceptionWithMessage() {\n\t\tString message = \"Checked exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IOException(message);\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IOException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsARuntimeException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsARuntimeExceptionWithMessage() {\n\t\tString message = \"Runtime exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Unexpected exception thrown: \" + IllegalStateException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnError() {\n\t\ttry {\n\t\t\tassertDoesNotThrow(AssertionTestUtils::recurseIndefinitely);\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + StackOverflowError.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageString() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageWithMessageString() {\n\t\tString message = \"Runtime exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t}, \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Custom message ==> Unexpected exception thrown: \"\n\t\t\t\t\t+ IllegalStateException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageSupplier() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, () -> \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageWithMessageSupplier() {\n\t\tString message = \"Runtime exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t}, () -> \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Custom message ==> Unexpected exception thrown: \"\n\t\t\t\t\t+ IllegalStateException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t// --- supplier ------------------------------------------------------------\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithSupplier() {\n\t\tassertEquals(\"enigma\", assertDoesNotThrow(something));\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithSupplierAndMessage() {\n\t\tassertEquals(\"enigma\", assertDoesNotThrow(something, \"message\"));\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithSupplierAndMessageSupplier() {\n\t\tassertEquals(\"enigma\", assertDoesNotThrow(something, () -> \"message\"));\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsACheckedException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IOException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IOException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsARuntimeException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsAnError() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new StackOverflowError();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + StackOverflowError.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsAnExceptionWithMessageString() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsAnExceptionWithMessageSupplier() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, () -> \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\tprivate static class Foo {\n\n\t\tvoid normalMethod() {\n\t\t}\n\n\t\tvoid overloaded() {\n\t\t}\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tvoid overloaded(int i) {\n\t\t}\n\n\t}\n\n}",
        "human_comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.2",
        "model_generated_comment": "assertDoesNotThrowWithMethodReferenceForNonVoidReturnType() {@link AssertionError}.\n\n@since 5.0"
    },
    {
        "id": 712,
        "code_snippet": "static String quoteForBatchScript(String arg) {\n\n    boolean needsQuotes = false;\n    for (int i = 0; i < arg.length(); i++) {\n      int c = arg.codePointAt(i);\n      if (Character.isWhitespace(c) || c == '\"' || c == '=' || c == ',' || c == ';') {\n        needsQuotes = true;\n        break;\n      }\n    }\n    if (!needsQuotes) {\n      return arg;\n    }\n    StringBuilder quoted = new StringBuilder();\n    quoted.append(\"\\\"\");\n    for (int i = 0; i < arg.length(); i++) {\n      int cp = arg.codePointAt(i);\n      switch (cp) {\n        case '\"' -> quoted.append('\"');\n        default -> {}\n      }\n      quoted.appendCodePoint(cp);\n    }\n    if (arg.codePointAt(arg.length() - 1) == '\\\\') {\n      quoted.append(\"\\\\\");\n    }\n    quoted.append(\"\\\"\");\n    return quoted.toString();\n  }",
        "human_comment": "Quote a command argument for a command to be run by a Windows batch script, if the argument\nneeds quoting. Arguments only seem to need quotes in batch scripts if they have certain\nspecial characters, some of which need extra (and different) escaping.\n\nFor example:\noriginal single argument: ab=\"cde fgh\"\nquoted: \"ab^=\"\"cde fgh\"\"\"",
        "model_generated_comment": "$example on$\n$example off$\n<p>If the quote is `\\\"`, then the quote will be returned.\n\n@param arg The character to quote, may be {@code null}.\n@return the quote"
    },
    {
        "id": 713,
        "code_snippet": "List<MojoExecution> getExecutions(MavenExecutionPlan mavenExecutionPlan) {\n        List<MojoExecution> result = new ArrayList<>();\n        for (ExecutionPlanItem executionPlanItem : mavenExecutionPlan) {\n            result.add(executionPlanItem.getMojoExecution());\n        }\n        return result;\n    }",
        "human_comment": "-----------------------------------------------------------------------------------------------\nTests which exercise the lifecycle executor when it is dealing with default lifecycle phases.\n-----------------------------------------------------------------------------------------------\nWe are doing something like \"mvn resources:resources\" where no version is specified but this\nproject we are working on has the version specified in the POM so the version should come from there.\nWe are doing something like \"mvn clean:clean\" where no version is specified but this\nproject we are working on has the version specified in the POM so the version should come from there.\nWe are doing something like \"mvn clean:clean\" where no version is specified but this\nproject we are working on has the version specified in the POM so the version should come from there.",
        "model_generated_comment": "Returns the {@link MojoExecution} object.\n\n@param mavenExecutionPlan The {@code mojoexecution}."
    },
    {
        "id": 714,
        "code_snippet": "synchronized boolean initiateRetry(Throwable e) {\n    if (enableSaslRetries && e instanceof SaslTimeoutException) {\n      saslRetryCount += 1;\n    }\n    retryCount += 1;\n    currentListener = new RetryingBlockTransferListener();\n\n    logger.info(\"Retrying {} ({}/{}) for {} outstanding blocks after {} ms\",\n      MDC.of(LogKeys.TRANSFER_TYPE$.MODULE$, listener.getTransferType()),\n      MDC.of(LogKeys.NUM_RETRY$.MODULE$, retryCount),\n      MDC.of(LogKeys.MAX_ATTEMPTS$.MODULE$, maxRetries),\n      MDC.of(LogKeys.NUM_BLOCKS$.MODULE$, outstandingBlocksIds.size()),\n      MDC.of(LogKeys.RETRY_WAIT_TIME$.MODULE$, retryWaitTime));\n\n    try {\n      executorService.execute(() -> {\n        Uninterruptibles.sleepUninterruptibly(retryWaitTime, TimeUnit.MILLISECONDS);\n        transferAllOutstanding();\n      });\n    } catch (Throwable t) {\n      logger.error(\"Exception while trying to initiate retry\", t);\n      return false;\n    }\n\n    return true;\n  }",
        "human_comment": "Lightweight method which initiates a retry in a different thread. The retry will involve\ncalling transferAllOutstanding() after a configured wait time.\nReturns true if the retry was successfully initiated, false otherwise.",
        "model_generated_comment": "Initializes a {@link RetryingBlockTransferListener}.\n\n@param e the throwable to initiate retry, may be {@code null}."
    },
    {
        "id": 715,
        "code_snippet": "public int compare(final Size lhs, final Size rhs) {\n      // We cast here to ensure the multiplications won't overflow\n      return Long.signum(\n          (long) lhs.getWidth() * lhs.getHeight() - (long) rhs.getWidth() * rhs.getHeight());\n    }",
        "human_comment": "Compares two {@code Size}s based on their areas.",
        "model_generated_comment": "Computes the dimensions of the given size.\n\n@param lhs The size of the size to compare.\n@return a compare of the dimensions."
    },
    {
        "id": 716,
        "code_snippet": "public static void assertEquals(int expected, int actual) {\n        assertEquals(null, expected, actual);\n    }",
        "human_comment": "Asserts that two ints are equal.",
        "model_generated_comment": "Asserts that two ints are equal. If they are not, they are considered equal."
    },
    {
        "id": 717,
        "code_snippet": "public void testFinalizationResultIsEmptyWhenTheServerDidNotReceiveAnyBlocks() {\n    MergeStatuses statuses = pushResolver.finalizeShuffleMerge(\n        new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 1, 0));\n    assertEquals(0, statuses.reduceIds.length, \"no partitions were merged\");\n    RemoteBlockPushResolver.AppShuffleInfo appShuffleInfo =\n        pushResolver.validateAndGetAppShuffleInfo(TEST_APP);\n    assertTrue(appShuffleInfo.getShuffles().get(1).isFinalized(),\n      \"shuffle 1 should be marked finalized\");\n    removeApplication(TEST_APP);\n  }",
        "human_comment": "For the previous merge id\nstream 2 now completes\nshuffle 1 0 is finalized even though the server didn't receive any blocks for it.",
        "model_generated_comment": "Test that the finalization result is empty when the server did not receive any blocks."
    },
    {
        "id": 718,
        "code_snippet": "public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        Activation activation = profile.getActivation();\n\n        if (activation == null) {\n            return false;\n        }\n\n        ActivationProperty property = activation.getProperty();\n\n        if (property == null) {\n            return false;\n        }\n\n        String name = property.getName();\n        boolean reverseName = false;\n\n        if (name != null && name.startsWith(\"!\")) {\n            reverseName = true;\n            name = name.substring(1);\n        }\n\n        if (name == null || name.isEmpty()) {\n            problems.add(\n                    BuilderProblem.Severity.ERROR,\n                    ModelProblem.Version.BASE,\n                    \"The property name is required to activate the profile \" + profile.getId(),\n                    property.getLocation(\"\"));\n            return false;\n        }\n\n        String sysValue = context.getUserProperty(name);\n        if (sysValue == null && \"packaging\".equals(name)) {\n            sysValue = context.getModelPackaging();\n        }\n        if (sysValue == null) {\n            sysValue = context.getSystemProperty(name);\n        }\n\n        String propValue = property.getValue();\n        if (propValue != null && !propValue.isEmpty()) {\n            boolean reverseValue = false;\n            if (propValue.startsWith(\"!\")) {\n                reverseValue = true;\n                propValue = propValue.substring(1);\n            }\n\n            // we have a value, so it has to match the system value...\n            return reverseValue != propValue.equals(sysValue);\n        } else {\n            return reverseName != (sysValue != null && !sysValue.isEmpty());\n        }\n    }",
        "human_comment": "Determines profile activation based on the existence or value of some execution property.\n\n@see ActivationProperty",
        "model_generated_comment": "The profile is active.\n\n@param profile the profile to activate, may be {@code null}."
    },
    {
        "id": 719,
        "code_snippet": "public static UTF8String fromBytes(byte[] bytes) {\n    if (bytes != null) {\n      return new UTF8String(bytes, BYTE_ARRAY_OFFSET, bytes.length);\n    } else {\n      return null;\n    }\n  }",
        "human_comment": "Creates an UTF8String from byte array, which should be encoded in UTF-8.\n\nNote: `bytes` will be hold by returned UTF8String.",
        "model_generated_comment": "Creates a UTF8String from bytes.\n\n@param bytes bytes The bytes to put into the new string."
    },
    {
        "id": 720,
        "code_snippet": "public Location lookup(Object keyBase, long keyOffset, int keyLength, int hash) {\n    safeLookup(keyBase, keyOffset, keyLength, loc, hash);\n    return loc;\n  }",
        "human_comment": "Looks up a key, and return a {@link Location} handle that can be used to test existence\nand read/write values.\n\nThis function always returns the same {@link Location} instance to avoid object allocation.\nThis function is not thread-safe.",
        "model_generated_comment": "Finds the location of the given key.\n\n@param keyBase the key to look up\n@return the location"
    },
    {
        "id": 721,
        "code_snippet": "public static MethodSource from(String className, String methodName, String methodParameterTypes) {\n\t\treturn new MethodSource(className, methodName, methodParameterTypes);\n\t}",
        "human_comment": "Create a new {@code MethodSource} using the supplied class name, method\n@param methodName the method name; must not be {@code null} or blank\n@param methodParameterTypes a comma-separated list of fully qualified\nclass names representing the method parameter types",
        "model_generated_comment": "Create a new {@code MethodSource} using the supplied {@link ClassName} and\n{@link MethodParameterTypes}.\n\n@param className the class name of the method to use; never{@code null} or blank\n@since 5.4"
    },
    {
        "id": 722,
        "code_snippet": "public static Constant<Float> create(Scope scope, long[] shape, FloatBuffer data) {\n    try (Tensor<Float> value = Tensor.create(shape, data)) {\n      return createWithTensor(scope, value);\n    }\n  }",
        "human_comment": "Create a {@link DataType#FLOAT} constant with data from the given buffer.\n\n<p>Creates a constant with the given shape by copying elements from the buffer (starting from\nits current position) into the tensor. For example, if {@code shape = {2,3} } (which represents\na 2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param scope is a scope used to add the underlying operation.\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@return a float constant\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer",
        "model_generated_comment": "Creates a rank-2 constant of {@code shape} elements.\n\n@param scope The scope to put into the new constant.\n@return The rank-1 constant of the given shape."
    },
    {
        "id": 723,
        "code_snippet": "protected String visitContains(String l, String r) {\n    String value = r.substring(1, r.length() - 1);\n    return l + \" LIKE '%\" + escapeSpecialCharsForLikePattern(value) + \"%' ESCAPE '\\\\'\";\n  }",
        "human_comment": "Remove quotes at the beginning and end.\ne.g. converts \"'str'\" to \"str\".",
        "model_generated_comment": "Visits the given string.\n\n@param l The string to visit.\n@return the visit string."
    },
    {
        "id": 724,
        "code_snippet": "public void afterProjectExecutionFailure(ProjectExecutionEvent projectExecutionEvent) {\n        MavenSession session = projectExecutionEvent.getSession();\n        boolean halted;\n        ReactorBuildStatus status =\n                (ReactorBuildStatus) session.getRepositorySession().getData().get(ReactorBuildStatus.class);\n        if (status != null) {\n            halted = status.isHalted();\n        } else {\n            Throwable t = projectExecutionEvent.getCause();\n            halted = (t instanceof RuntimeException || !(t instanceof Exception))\n                    || !MavenExecutionRequest.REACTOR_FAIL_NEVER.equals(session.getReactorFailureBehavior())\n                            && !MavenExecutionRequest.REACTOR_FAIL_AT_END.equals(session.getReactorFailureBehavior());\n        }\n        Throwable cause = projectExecutionEvent.getCause();\n        buildEventListener.executionFailure(\n                projectExecutionEvent.getProject().getArtifactId(), halted, cause != null ? cause.toString() : null);\n    }",
        "human_comment": "The ReactorBuildStatus is only available if the SmartBuilder is used\nassume sensible default",
        "model_generated_comment": "This method is used to check if the project is still alive.\n\n@param projectExecutionEvent The project to check, may be {@code null}."
    },
    {
        "id": 725,
        "code_snippet": "public static Condition<Event> test(String uniqueIdSubstring) {\n\t\treturn test(uniqueIdSubstring(uniqueIdSubstring));\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if an\na {@linkplain TestDescriptor#isTest() test} and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the supplied\n{@link String}.\n\n@see #test()\n@see #uniqueIdSubstring(String)",
        "model_generated_comment": "Create a new {@link Condition} that matches if and only if the supplied {@code uniqueIdSubstring} matches the supplied\n{@linkplain Event}.\n\n@since 5.4"
    },
    {
        "id": 726,
        "code_snippet": "public void setInterval(int ordinal, CalendarInterval value) {\n    assertIndexIsValid(ordinal);\n    long cursor = getLong(ordinal) >>> 32;\n    assert cursor > 0 : \"invalid cursor \" + cursor;\n    if (value == null) {\n      setNullAt(ordinal);\n      Platform.putLong(baseObject, baseOffset + cursor, 0L);\n      Platform.putLong(baseObject, baseOffset + cursor + 8, 0L);\n      Platform.putLong(baseObject, getFieldOffset(ordinal), (cursor << 32) | 16L);\n    } else {\n      long longVal =\n        ((long) value.months & 0xFFFFFFFFL) | (((long) value.days << 32) & 0xFFFFFFFF00000000L);\n      Platform.putLong(baseObject, baseOffset + cursor, longVal);\n      Platform.putLong(baseObject, baseOffset + cursor + 8, value.microseconds);\n      setLong(ordinal, (cursor << 32) | 16L);\n    }\n  }",
        "human_comment": "zero-out the bytes\nkeep the offset for future update",
        "model_generated_comment": "Sets the index of the cursor.\n\n@param ordinal the value to set, may be {@code null}."
    },
    {
        "id": 727,
        "code_snippet": "public static ReportEntry from(Map<String, String> keyValuePairs) {\n\t\tPreconditions.notNull(keyValuePairs, \"keyValuePairs must not be null\");\n\n\t\tReportEntry reportEntry = new ReportEntry();\n\t\tkeyValuePairs.forEach(reportEntry::add);\n\t\treturn reportEntry;\n\t}",
        "human_comment": "Factory for creating a new {@code ReportEntry} from a map of key-value pairs.\n{@code null} or blank",
        "model_generated_comment": "Create a new {@link ReportEntry} with the supplied key values.\n\n@param keyValuePairs the key values to add; never {@code null}"
    },
    {
        "id": 728,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaMinHashLSHExample\")\n      .getOrCreate();\n\n    // $example on$\n    List<Row> dataA = Arrays.asList(\n      RowFactory.create(0, Vectors.sparse(6, new int[]{0, 1, 2}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(1, Vectors.sparse(6, new int[]{2, 3, 4}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(2, Vectors.sparse(6, new int[]{0, 2, 4}, new double[]{1.0, 1.0, 1.0}))\n      RowFactory.create(0, Vectors.sparse(6, new int[]{1, 3, 5}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(1, Vectors.sparse(6, new int[]{2, 3, 5}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(2, Vectors.sparse(6, new int[]{1, 2, 4}, new double[]{1.0, 1.0, 1.0}))\n    StructType schema = new StructType(new StructField[]{\n    Dataset<Row> dfA = spark.createDataFrame(dataA, schema);\n    Dataset<Row> dfB = spark.createDataFrame(dataB, schema);\n\n    int[] indices = {1, 3};\n    double[] values = {1.0, 1.0};\n    Vector key = Vectors.sparse(6, indices, values);\n\n    MinHashLSH mh = new MinHashLSH()\n      .setNumHashTables(5)\n      .setInputCol(\"features\")\n      .setOutputCol(\"hashes\");\n\n    MinHashLSHModel model = mh.fit(dfA);\n\n    // Feature Transformation\n    System.out.println(\"The hashed dataset where hashed values are stored in the column 'hashes':\");\n    model.transform(dfA).show();\n\n    // Compute the locality sensitive hashes for the input rows, then perform approximate\n    // similarity join.\n    // We could avoid computing hashes by passing in the already-transformed dataset, e.g.\n    // `model.approxSimilarityJoin(transformedA, transformedB, 0.6)`\n    System.out.println(\"Approximately joining dfA and dfB on Jaccard distance smaller than 0.6:\");\n    model.approxSimilarityJoin(dfA, dfB, 0.6, \"JaccardDistance\")\n      .select(col(\"datasetA.id\").alias(\"idA\"),\n        col(\"datasetB.id\").alias(\"idB\"),\n        col(\"JaccardDistance\")).show();\n\n    // Compute the locality sensitive hashes for the input rows, then perform approximate nearest\n    // neighbor search.\n    // We could avoid computing hashes by passing in the already-transformed dataset, e.g.\n    // `model.approxNearestNeighbors(transformedA, key, 2)`\n    // It may return less than 2 rows when not enough approximate near-neighbor candidates are\n    // found.\n    System.out.println(\"Approximately searching dfA for 2 nearest neighbors of the key:\");\n    model.approxNearestNeighbors(dfA, key, 2).show();\n    // $example off$\n\n    spark.stop();\n  }\n}",
        "human_comment": "An example demonstrating MinHashLSH.\nRun with:\nbin/run-example ml.JavaMinHashLSHExample",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 729,
        "code_snippet": "protected MavenOptions parseMavenConfigOptions(Path configFile) {\n        try (Stream<String> lines = Files.lines(configFile, Charset.defaultCharset())) {\n            List<String> args =\n                    lines.filter(arg -> !arg.isEmpty() && !arg.startsWith(\"#\")).toList();\n            MavenOptions options = parseArgs(\"maven.config\", args);\n            if (options.goals().isPresent()) {\n                throw new IllegalArgumentException(\"Unrecognized entries in maven.config (\" + configFile + \") file: \"\n                        + options.goals().get());\n            }\n            return options;\n        } catch (ParseException e) {\n            throw new IllegalArgumentException(\n                    \"Failed to parse arguments from maven.config file (\" + configFile + \"): \" + e.getMessage(),\n                    e.getCause());\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Error reading config file: \" + configFile, e);\n        }\n    }",
        "human_comment": "This file can only contain options, not args (goals or phases)",
        "model_generated_comment": "Parses Maven options to the specified config file.\n\n@param configFile The config file to parse, may be {@code null}."
    },
    {
        "id": 730,
        "code_snippet": "public Builder enablePostDiscoveryFilterAutoRegistration(boolean enabled) {\n\t\t\tthis.postDiscoveryFilterAutoRegistrationEnabled = enabled;\n\t\t\treturn this;\n\t\t}",
        "human_comment": "Configure the auto-registration flag for post discovery filters.\n\n<p>Defaults to {@code true}.\n\n@param enabled {@code true} if post discovery filters should be automatically\nregistered\n@return this builder for method chaining\n@since 1.7",
        "model_generated_comment": "Enable the auto registration of {@link PostDiscoveryFilterAutoRegistration}.\n\n@since 5.4"
    },
    {
        "id": 731,
        "code_snippet": "public static Object[] data() {\n\t\treturn new Object[] { 1, 2, 3 };\n\n\tpublic JUnit4ParameterizedTestCase(int i) {\n\t}\n\n\t@Test\n\tpublic void test1() {\n\t\tfail(\"this test should fail\");\n\t}\n\n\t@Test\n\tpublic void endingIn_test1() {\n\t\tfail(\"this test should fail\");\n\t}\n\n\t@Test\n\tpublic void test1_atTheBeginning() {\n\t\tfail(\"this test should fail\");\n\t}\n\n\t@Test\n\tpublic void test2() {\n\t\t/* always succeeds */\n\t}\n\n}",
        "human_comment": "Test case used in {@link JUnit4ParameterizedTests}.\n\n@since 4.12",
        "model_generated_comment": "Unit tests for {@link JUnit4ParameterizedTestCase}.\n\n@since 5.0"
    },
    {
        "id": 732,
        "code_snippet": "byte[] childPrefix(Object value) {\n      Preconditions.checkState(parent == null, \"Not a parent index.\");\n      return buildKey(name, toParentKey(value));\n    }",
        "human_comment": "Creates a key prefix for child indices of this index. This allows the prefix to be\ncalculated only once, avoiding redundant work when multiple child indices of the\nsame parent index exist.",
        "model_generated_comment": "Constructs a prefix with the given value.\n\n@param value the value to build the prefix\n@return a new prefix"
    },
    {
        "id": 733,
        "code_snippet": "public void composeUi(String path, Map<String, String> params) {\n    // Fetch data dynamically based on the route and parameters\n    String data = apiGateway.handleRequest(path, params);\n    LOGGER.info(\"Composed UI Component for path '\" + path + \"':\");\n    LOGGER.info(data);\n  }",
        "human_comment": "Composes the user interface dynamically by fetching data from different frontend components\nbased on provided parameters.\n\n@param path the route of the frontend component\n@param params a map of dynamic parameters to influence the data fetching",
        "model_generated_comment": "Creates a Ui with the specified path and params.\n\n@param path the path to compose the Ui."
    },
    {
        "id": 734,
        "code_snippet": "public SparkLauncher redirectError(File errFile) {\n    errorStream = ProcessBuilder.Redirect.to(errFile);\n    return this;\n  }",
        "human_comment": "Redirects error output to the specified File.\n\n@param errFile The file to which stderr is written.\n@return This launcher.",
        "model_generated_comment": "Redirects an error to the Spark Launcher.\n\n@param errFile The error file to be redirected to.\n@return {@link SparkLauncher}"
    },
    {
        "id": 735,
        "code_snippet": "public boolean append(Object kbase, long koff, int klen, Object vbase, long voff, int vlen) {\n      assert (klen % 8 == 0);\n      assert (vlen % 8 == 0);\n      assert (longArray != null);\n\n      // We should not increase number of keys to be MAX_CAPACITY. The usage pattern of this map is\n      // lookup + append. If we append key until the number of keys to be MAX_CAPACITY, next time\n      // the call of lookup will hang forever because it cannot find an empty slot.\n      if (numKeys == MAX_CAPACITY - 1\n        // The map could be reused from last spill (because of no enough memory to grow),\n        // then we don't try to grow again if hit the `growthThreshold`.\n        || !canGrowArray && numKeys >= growthThreshold) {\n        return false;\n      }\n\n      // Here, we'll copy the data into our data pages. Because we only store a relative offset from\n      // the key address instead of storing the absolute address of the value, the key and value\n      // must be stored in the same memory page.\n      // (total length) (key length) (key) (value) (8 byte pointer to next value)\n      int uaoSize = UnsafeAlignedOffset.getUaoSize();\n      final long recordLength = (2L * uaoSize) + klen + vlen + 8;\n      if (currentPage == null || currentPage.size() - pageCursor < recordLength) {\n        if (!acquireNewPage(recordLength + uaoSize)) {\n          return false;\n        }\n      }\n\n      // --- Append the key and value data to the current data page --------------------------------\n      final Object base = currentPage.getBaseObject();\n      long offset = currentPage.getBaseOffset() + pageCursor;\n      final long recordOffset = offset;\n      UnsafeAlignedOffset.putSize(base, offset, klen + vlen + uaoSize);\n      UnsafeAlignedOffset.putSize(base, offset + uaoSize, klen);\n      offset += (2L * uaoSize);\n      Platform.copyMemory(kbase, koff, base, offset, klen);\n      offset += klen;\n      Platform.copyMemory(vbase, voff, base, offset, vlen);\n      offset += vlen;\n      // put this value at the beginning of the list\n      Platform.putLong(base, offset, isDefined ? longArray.get(pos * 2) : 0);\n\n      // --- Update bookkeeping data structures ----------------------------------------------------\n      offset = currentPage.getBaseOffset();\n      UnsafeAlignedOffset.putSize(base, offset, UnsafeAlignedOffset.getSize(base, offset) + 1);\n      pageCursor += recordLength;\n      final long storedKeyAddress = taskMemoryManager.encodePageNumberAndOffset(\n        currentPage, recordOffset);\n      longArray.set(pos * 2, storedKeyAddress);\n      updateAddressesAndSizes(storedKeyAddress);\n      numValues++;\n      if (!isDefined) {\n        numKeys++;\n        longArray.set(pos * 2 + 1, keyHashcode);\n        isDefined = true;\n\n        // If the map has reached its growth threshold, try to grow it.\n        if (numKeys >= growthThreshold) {\n          // We use two array entries per key, so the array size is twice the capacity.\n          // We should compare the current capacity of the array, instead of its size.\n          if (longArray.size() / 2 < MAX_CAPACITY) {\n            try {\n              growAndRehash();\n            } catch (SparkOutOfMemoryError oom) {\n              canGrowArray = false;\n            }\n          } else {\n            // The map is already at MAX_CAPACITY and cannot grow. Instead, we prevent it from\n            // accepting any more new elements to make sure we don't exceed the load factor. If we\n            // need to spill later, this allows UnsafeKVExternalSorter to reuse the array for\n            // sorting.\n            canGrowArray = false;\n          }\n        }\n      }\n      return true;\n    }",
        "human_comment": "Append a new value for the key. This method could be called multiple times for a given key.\nThe return value indicates whether the put succeeded or whether it failed because additional\nmemory could not be acquired.\n<p>\nIt is only valid to call this method immediately after calling `lookup()` using the same key.\n</p>\n<p>\nThe key and value must be word-aligned (that is, their sizes must be a multiple of 8).\n</p>\n<p>\nAfter calling this method, calls to `get[Key|Value]Address()` and `get[Key|Value]Length`\nwill return information on the data stored by this `append` call.\n</p>\n<p>\nAs an example usage, here's the proper way to store a new key:\n</p>\n<pre>\nLocation loc = map.lookup(keyBase, keyOffset, keyLength);\nif (!loc.isDefined()) {\nif (!loc.append(keyBase, keyOffset, keyLength, ...)) {\n// handle failure to grow map (by spilling, for example)\n}\n}\n</pre>\n<p>\nUnspecified behavior if the key is not defined.\n</p>\n\n@return true if the put() was successful and false if the put() failed because memory could\nnot be acquired.",
        "model_generated_comment": "Append the key and value to the current data page.\n\n@param kbase the kbase object to append, may be {@code null}."
    },
    {
        "id": 736,
        "code_snippet": "public static String formatLocation(ModelProblem problem, String projectId) {\n        StringBuilder buffer = new StringBuilder(256);\n\n        if (!problem.getModelId().equals(projectId)) {\n            buffer.append(problem.getModelId());\n            if (!problem.getSource().isEmpty()) {\n                if (!buffer.isEmpty()) {\n                    buffer.append(\", \");\n                }\n                buffer.append(problem.getSource());\n            }\n        }\n\n        if (problem.getLineNumber() > 0) {\n            if (!buffer.isEmpty()) {\n                buffer.append(\", \");\n            }\n            buffer.append(\"line \").append(problem.getLineNumber());\n        }\n\n        if (problem.getColumnNumber() > 0) {\n            if (!buffer.isEmpty()) {\n                buffer.append(\", \");\n            }\n            buffer.append(\"column \").append(problem.getColumnNumber());\n        }\n\n        return buffer.toString();\n    }",
        "human_comment": "Creates a string with all location details for the specified model problem. If the project identifier is\nprovided, the generated location will omit the model id and source information and only give line/column\ninformation for problems originating directly from this POM.\n\n@param problem The problem whose location should be formatted, must not be {@code null}.\n@param projectId The {@code <groupId>:<artifactId>:<version>} of the corresponding project, may be {@code null}\nto force output of model id and source.\n@return The formatted problem location or an empty string if unknown, never {@code null}.",
        "model_generated_comment": "Creates a new format location for the specified problem.\n\n@param problem the problem to format, may be {@code null}."
    },
    {
        "id": 737,
        "code_snippet": "public OrderService(Map<Integer, Product> cart) {\n    this.cart = cart;\n  }",
        "human_comment": "Instantiates a new Order service.\n\n@param cart the cart",
        "model_generated_comment": "Order service for the supplied {@code Integer} object.\n\n@param cart The object to order.\n@return An OrderService for the specified object."
    },
    {
        "id": 738,
        "code_snippet": "private long relativeOffset(int numFields) {\n    return 8 + numFields * 8L;\n  }",
        "human_comment": "Compute the relative offset of variable-length values.\nAll the UnsafeRows in this suite contains less than 64 columns, so the bitSetSize shall\nalways be 8.",
        "model_generated_comment": "Returns the relativeOffset of the {@code numFields} field."
    },
    {
        "id": 739,
        "code_snippet": "while (nettyBufReadableBytes > 0 && !completed) {\n                    int readableBytes = Integer.min(\n                            nettyBufReadableBytes,\n                            ciphertextBuffer.remaining());\n                    int expectedRemaining = (int) (expectedLength - ciphertextRead);\n                    int bytesToRead = Integer.min(readableBytes, expectedRemaining);\n                    ciphertextBuffer.limit(ciphertextBuffer.position() + bytesToRead);\n                    ciphertextNettyBuf.readBytes(ciphertextBuffer);\n                    ciphertextRead += bytesToRead;\n                    if (ciphertextRead == expectedLength) {\n                        completed = true;\n                    } else if (ciphertextRead > expectedLength) {\n                        throw new IllegalStateException(\"Read more ciphertext than expected.\");\n                    }\n                    if (ciphertextBuffer.limit() == ciphertextBuffer.capacity() || completed) {\n                        ByteBuffer plaintextBuffer = ByteBuffer.allocate(plaintextSegmentSize);\n                        ciphertextBuffer.flip();\n                        decrypter.decryptSegment(\n                                ciphertextBuffer,\n                                segmentNumber,\n                                completed,\n                                plaintextBuffer);\n                        segmentNumber++;\n                        ciphertextBuffer.clear();\n                        plaintextBuffer.flip();\n                        ctx.fireChannelRead(Unpooled.wrappedBuffer(plaintextBuffer));\n                    } else {\n                        ciphertextBuffer.limit(ciphertextBuffer.capacity());\n                    }\n                    nettyBufReadableBytes = ciphertextNettyBuf.readableBytes();\n                }",
        "human_comment": "Read the ciphertext into the local buffer\nThe smallest ciphertext size is 16 bytes for the auth tag\nCheck if this is the last segment\nIf the ciphertext buffer is full, or this is the last segment,\nthen decrypt it and fire a read.\nClear the ciphertext buffer because it's been read\nSet the ciphertext buffer up to read the next chunk",
        "model_generated_comment": "Read more ciphertext than expected.\n\n@param expectedLength The expected length of the ciphertext, must not be <code>null</code>."
    },
    {
        "id": 740,
        "code_snippet": "public Double finish(Average reduction) {\n      return ((double) reduction.getSum()) / reduction.getCount();\n    }",
        "human_comment": "Transform the output of the reduction",
        "model_generated_comment": "Creates a Double finish of the given reduction.\n\n@param reduction the reduction to finish."
    },
    {
        "id": 741,
        "code_snippet": "public T setRemote(String remote) {\n    checkNotNull(remote, \"remote\");\n    builder.remote = remote;\n    return self();\n  }",
        "human_comment": "Set the Spark master for the application.\n\n@param remote Spark remote url.\n@return This launcher.",
        "model_generated_comment": "Set the remote of the builder.\n\n@param remote the remote to set.\n@return {@code true} if the remote is null."
    },
    {
        "id": 742,
        "code_snippet": "private boolean isAlreadyRegistered(Class<? extends Extension> extensionType) {\n\t\treturn this.registeredExtensionTypes.contains(extensionType);\n\t}",
        "human_comment": "Determine if the supplied type is already registered in this registry or in a\nparent registry.",
        "model_generated_comment": "Create a new {@code boolean} that matches if and only if an extension type is registered.\n\n@param extensionType the extension type to check\n@return this new boolean"
    },
    {
        "id": 743,
        "code_snippet": "public final int getElementsAppended() { return elementsAppended; }",
        "human_comment": "Returns the elements appended. This is useful",
        "model_generated_comment": "Get the elements of the given {@code elementsAppended} from the array.\n\n@return the array containing the elements."
    },
    {
        "id": 744,
        "code_snippet": "public String delayedServiceResponse() {\n    try {\n      return this.delayedService.attemptRequest();\n    } catch (RemoteServiceException e) {\n      return e.getMessage();\n    }\n  }",
        "human_comment": "Fetch response from the delayed service (with some simulated startup time).\n\n@return response string",
        "model_generated_comment": "Returns the delayed service response.\n\n@param delayedServiceResponse The response to receive."
    },
    {
        "id": 745,
        "code_snippet": "public static void assertTimeoutPreemptively(Duration timeout, Executable executable) {\n\t\tAssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable);\n\t}",
        "human_comment": "<em>Assert</em> that execution of the supplied {@code executable}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>See the {@linkplain Assertions Preemptive Timeouts} section of the\nclass-level Javadoc for further details.\n\n@see #assertTimeoutPreemptively(Duration, Executable, String)\n@see #assertTimeoutPreemptively(Duration, Executable, Supplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, String)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeout(Duration, Executable)",
        "model_generated_comment": "<em>Assert</em> that the given {@code timeout} is not exceeded.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@link Executable}.\n\n@since 5.4"
    },
    {
        "id": 746,
        "code_snippet": "public byte[] getBinary(int rowId) {\n    if (isNullAt(rowId)) return null;\n    if (dictionary == null) {\n      return arrayData().getBytes(getArrayOffset(rowId), getArrayLength(rowId));\n    } else {\n      return dictionary.decodeToBinary(dictionaryIds.getDictId(rowId));\n    }\n  }",
        "human_comment": "Gets the values of bytes from [rowId, rowId + count), as a UTF8String.\nThis method is similar to {@link ColumnVector#getBytes(int, int)}, but can save data copy as\nUTF8String is used as a pointer.",
        "model_generated_comment": "Get the dictionary of the given row.\n\n@param rowId The row id of the dictionary.\n@return the dictionary"
    },
    {
        "id": 747,
        "code_snippet": "private int getUsableCapacity() {\n    return (int) (array.size() / (useRadixSort ? 2 : 1.5));\n  }",
        "human_comment": "Radix sort requires same amount of used memory as buffer, Tim sort requires\nhalf of the used memory as buffer.",
        "model_generated_comment": "Get the maximum capacity of the given array.\n\n@param int the array to get."
    },
    {
        "id": 748,
        "code_snippet": "public UserRepository(AppExecutors appExecutors, UserDataSource userDataSource) {\n        mAppExecutors = appExecutors;\n        mUserDataSource = userDataSource;\n    }",
        "human_comment": "The repository is responsible of handling user data operations.",
        "model_generated_comment": "Creates a repository for the supplied user data.\n\n@param appExecutors The appexecutors, may be {@code null}."
    },
    {
        "id": 749,
        "code_snippet": "public void testTypedAggregationAverage() {\n    KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset();\n    Dataset<Tuple2<String, Double>> aggregated = grouped.agg(\n      org.apache.spark.sql.expressions.javalang.typed.avg(v -> (double)(v._2() * 2)));\n    Assertions.assertEquals(\n        Arrays.asList(new Tuple2<>(\"a\", 3.0), new Tuple2<>(\"b\", 6.0)),\n        aggregated.collectAsList());\n  }",
        "human_comment": "Suite that replicates tests in JavaDatasetAggregatorSuite using lambda syntax.",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 750,
        "code_snippet": "public long toLongExact() {\n    LongWrapper result = new LongWrapper();\n    if (toLong(result, false)) {\n      return result.value;\n    }\n    throw new NumberFormatException(\"invalid input syntax for type numeric: '\" + this + \"'\");\n  }",
        "human_comment": "Parses UTF8String(trimmed if needed) to long. This method is used when ANSI is enabled.\n\n@return If string contains valid numeric value then it returns the long value otherwise a\nNumberFormatException  is thrown.",
        "model_generated_comment": "Returns the value of the input string.\n\n@param result The input string, may be {@code null}."
    },
    {
        "id": 751,
        "code_snippet": "public static Trigger ProcessingTime(long intervalMs) {\n      return ProcessingTimeTrigger.create(intervalMs, TimeUnit.MILLISECONDS);\n  }",
        "human_comment": "A trigger policy that runs a query periodically based on an interval in processing time.\nIf `interval` is 0, the query will run as fast as possible.\n\n@since 2.2.0",
        "model_generated_comment": "Creates a {@link ProcessingTimeTrigger}.\n\n@param intervalMs the intervalMs to trigger.\n@return {@code Trigger}"
    },
    {
        "id": 752,
        "code_snippet": "default Optional<String> getVersion() {\n\t\tOptional<String> standalone = PackageUtils.getAttribute(getClass(), \"Engine-Version-\" + getId());\n\t\tif (standalone.isPresent()) {\n\t\t\treturn standalone;\n\t\t}\n\t\treturn Optional.of(PackageUtils.getModuleOrImplementationVersion(getClass()).orElse(\"DEVELOPMENT\"));\n\t}",
        "human_comment": "Get the version of this test engine.\n\n<p>This information is used solely for debugging and reporting purposes.\n\n<p>Initially, the default implementation tries to retrieve the engine\nversion from the manifest attribute named: {@code \"Engine-Version-\" + getId()}\n\n<p>Then the default implementation attempts to query the\n{@linkplain Package#getImplementationVersion() implementation version}\nfrom the package attributes for the {@link Package} in which the engine\nresides. Note that a package only has attributes if the information is\ndefined in the {@link java.util.jar.Manifest Manifest} of the JAR\ncontaining that package, and if the class loader created the\n{@link Package} instance with the attributes from the manifest.\n\n<p>If the implementation version cannot be queried from the package\nattributes, the default implementation returns {@code \"DEVELOPMENT\"}.\n\n<p>Concrete test engine implementations may override this method to\ndetermine the version by some other means.\n\n<p>implNote: Since JUnit Platform version 1.1 this default implementation\nhonors the \"raw version\" information stored in the module (modular jar\non the module-path) of this test engine.\n\n@return an {@code Optional} containing the version; never {@code null}\nbut potentially empty if the version is unknown\n@see Class#getPackage()\n@see Package#getImplementationVersion()\n@see #getGroupId()\n@see #getArtifactId()",
        "model_generated_comment": "Get the {@link ModuleOrImplementationVersion} of the supplied module.\n\n@param standalone the module or implementation version; never {@code null} or blank\n@return the supplied version"
    },
    {
        "id": 753,
        "code_snippet": "private void setCurrentNamePattern(OperationLog.LoggingLevel mode) {\n      if (mode == OperationLog.LoggingLevel.VERBOSE) {\n        this.namePattern = verboseExcludeNamePattern;\n      } else if (mode == OperationLog.LoggingLevel.EXECUTION) {\n        this.namePattern = executionIncludeNamePattern;\n      } else if (mode == OperationLog.LoggingLevel.PERFORMANCE) {\n        this.namePattern = performanceIncludeNamePattern;\n      }\n    }",
        "human_comment": "A log filter that filters messages coming from the logger with the given names.\nIt be used as a white list filter or a black list filter.\nWe apply black list filter on the Loggers used by the log diversion stuff, so that\nthey don't generate more logs for themselves when they process logs.\nWhite list filter is used for less verbose log collection",
        "model_generated_comment": "Set the current name pattern.\n\n@param mode The mode to set the name pattern, may be {@code null}."
    },
    {
        "id": 754,
        "code_snippet": "public void remove(final Node node) {\n    if (node.previous != null) {\n      node.previous.next = node.next;\n    } else {\n      head = node.next;\n    }\n    if (node.next != null) {\n      node.next.previous = node.previous;\n    } else {\n      end = node.previous;\n    }\n  }",
        "human_comment": "Remove node from linked list.\n\n@param node {@link Node}",
        "model_generated_comment": "Remove the node from the node.\n\n@param node the node to remove\n@return The node, never {@code null}"
    },
    {
        "id": 755,
        "code_snippet": "public Options setPrecisionLossAllowed(boolean precisionLossAllowed) {\n      this.precisionLossAllowed = precisionLossAllowed;\n      return this;\n    }",
        "human_comment": "Sets whether precision loss is allowed.\n\n@param precisionLossAllowed When `true` (default), the GPU may quantify tensors, downcast\nvalues, process in FP16. When `false`, computations are carried out in 32-bit floating\npoint.",
        "model_generated_comment": "Sets the precision of {@code precisionLossAllowed}."
    },
    {
        "id": 756,
        "code_snippet": "public <T> AssumptionViolatedException(String message, T expected, Matcher<T> matcher) {\n        super(message, expected, matcher);\n    }",
        "human_comment": "An assumption exception with a message with the given <i>actual</i> value and a\n<i>matcher</i> describing the expectation that failed.",
        "model_generated_comment": "<em>AssumptionViolatedException</em> is thrown with the given message.\n\n@param expected the expected message to throw."
    },
    {
        "id": 757,
        "code_snippet": "public static void assertNotEquals(Long unexpected, Long actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and {@link actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 758,
        "code_snippet": "private static void disableProgressBarAnimation(ProgressBar progressBar) {\n        progressBar.setIndeterminateDrawable(new ColorDrawable(Color.BLUE));\n    }",
        "human_comment": "necessary to run tests on older API levels where progress bar uses handler loop to animate.\n\n@param progressBar The progress bar whose animation will be swapped with a drawable",
        "model_generated_comment": "Determine if the progress bar is disabled.\n\n@param progressBar The progress bar to disable."
    },
    {
        "id": 759,
        "code_snippet": "private List<Runner> runners(Class<?>[] children) {\n        List<Runner> runners = new ArrayList<Runner>();\n        for (Class<?> each : children) {\n            Runner childRunner = safeRunnerForClass(each);\n            if (childRunner != null) {\n                runners.add(childRunner);\n            }\n        }\n        return runners;\n    }",
        "human_comment": "Constructs and returns a list of Runners, one for each child class in\n{@code children}.  Care is taken to avoid infinite recursion:\nthis builder will throw an exception if it is requested for another\nrunner for {@code parent} before this call completes.",
        "model_generated_comment": "Returns a list of runners for the given class.\n\n@param children the children of the class\n@return a list containing the runners"
    },
    {
        "id": 760,
        "code_snippet": "default Optional<Version> getHighestVersion() {\n        return getVersions().isEmpty()\n                ? Optional.empty()\n                : Optional.of(getVersions().get(getVersions().size() - 1));\n    }",
        "human_comment": "Gets the highest version matching the requested range.\n\n@return An Optional containing the highest matching version, or empty Optional if no versions\nmatched the requested range",
        "model_generated_comment": "Returns the maximum version of the given version.\n\n@param version the version to get\n@return The maximum version"
    },
    {
        "id": 761,
        "code_snippet": "public static List<Car> getSedanCarsOwnedSortedByDate(List<Person> persons) {\n    return persons.stream()\n        .map(Person::cars)\n        .flatMap(List::stream)\n        .filter(car -> Category.SEDAN.equals(car.category()))\n        .sorted(Comparator.comparing(Car::year))\n        .toList();\n  }",
        "human_comment": "Method to get all Sedan cars belonging to a group of persons sorted by year of manufacture.\n\n@param persons {@link List} of {@link Person} to be used\n@return {@link List} of {@link Car} to belonging to the group",
        "model_generated_comment": "Returns a list of cars that have been sorted by date.\n\n@param persons the persons to be sorted by, may be {@code null}."
    },
    {
        "id": 762,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaTokenizerExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(0, \"Hi I heard about Spark\"),\n      RowFactory.create(1, \"I wish Java could use case classes\"),\n      RowFactory.create(2, \"Logistic,regression,models,are,neat\")\n    );\n\n    StructType schema = new StructType(new StructField[]{\n\n    Dataset<Row> sentenceDataFrame = spark.createDataFrame(data, schema);\n\n    Tokenizer tokenizer = new Tokenizer().setInputCol(\"sentence\").setOutputCol(\"words\");\n\n    RegexTokenizer regexTokenizer = new RegexTokenizer()\n        .setInputCol(\"sentence\")\n        .setOutputCol(\"words\")\n        .setPattern(\"\\\\W\");  // alternatively .setPattern(\"\\\\w+\").setGaps(false);\n\n    spark.udf().register(\n      \"countTokens\", (Seq<?> words) -> words.size(), DataTypes.IntegerType);\n\n    Dataset<Row> tokenized = tokenizer.transform(sentenceDataFrame);\n    tokenized.select(\"sentence\", \"words\")\n        .withColumn(\"tokens\", call_udf(\"countTokens\", col(\"words\")))\n        .show(false);\n\n    Dataset<Row> regexTokenized = regexTokenizer.transform(sentenceDataFrame);\n    regexTokenized.select(\"sentence\", \"words\")\n        .withColumn(\"tokens\", call_udf(\"countTokens\", col(\"words\")))\n        .show(false);\n\n    spark.stop();\n  }\n}",
        "human_comment": "$example on$\ncol(\"...\") is preferable to df.col(\"...\")\n$example off$\n$example on$\n$example off$",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 763,
        "code_snippet": "public void error(String format, Object arg1, Object arg2) {\n        super.error(format, arg1, arg2);\n        logLevelRecorder.record(Level.ERROR);\n    }",
        "human_comment": "Perform double parameter substitution before logging the message of level\nERROR according to the format outlined above.",
        "model_generated_comment": "Logs a LevelRecorder error with the given format.\n\n@param format The format of the error."
    },
    {
        "id": 764,
        "code_snippet": "public final void addElementsAppended(int num) {\n    elementsAppended += num;\n  }",
        "human_comment": "Increment number of elements appended by 'num'.\n\nThis is useful when one wants to use the 'putXXX' API to add new elements to the vector, but\nstill want to keep count of how many elements have been added (since the 'putXXX' APIs don't\nincrement count).",
        "model_generated_comment": "Add the elements to the list.\n\n@param num the num to add."
    },
    {
        "id": 765,
        "code_snippet": "if (loggerName == null && (outputToLog || errorToLog)) {\n      String appName;\n      if (builder.appName != null) {\n        appName = builder.appName;\n      } else if (builder.mainClass != null) {\n        int dot = builder.mainClass.lastIndexOf(\".\");\n        if (dot >= 0 && dot < builder.mainClass.length() - 1) {\n          appName = builder.mainClass.substring(dot + 1, builder.mainClass.length());\n        } else {\n          appName = builder.mainClass;\n        }\n      } else if (builder.appResource != null) {\n        appName = new File(builder.appResource).getName();\n      } else {\n        appName = String.valueOf(COUNTER.incrementAndGet());\n      }\n      String loggerPrefix = getClass().getPackage().getName();\n      loggerName = String.format(\"%s.app.%s\", loggerPrefix, appName);\n    }",
        "human_comment": "Only setup stderr + stdout to logger redirection if user has not otherwise configured output\nredirection.",
        "model_generated_comment": "LoggerName is the name of the logger.\n\n@param loggerName The name of this logger, may be {@code null}."
    },
    {
        "id": 766,
        "code_snippet": "private void updateUserName() {\n        String userName = mUserNameInput.getText().toString();\n        mUpdateButton.setEnabled(false);\n        mDisposable.add(mViewModel.updateUserName(userName)\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(() -> mUpdateButton.setEnabled(true),\n                        throwable -> Log.e(TAG, \"Unable to update username\", throwable)));\n    }",
        "human_comment": "Disable the update button until the user name update has been done\nSubscribe to updating the user name.\nRe-enable the button once the user name has been updated",
        "model_generated_comment": "Update the user name.\n\n@param userName The user name to update."
    },
    {
        "id": 767,
        "code_snippet": "static Identifier of(String[] namespace, String name) {\n    return new IdentifierImpl(namespace, name);\n  }",
        "human_comment": "Identifies an object in a catalog.\n\n@since 3.0.0",
        "model_generated_comment": "Creates a new {@link IdentifierImpl} for the given namespace.\n\n@param namespace the namespace to use\n@return a new Identifier"
    },
    {
        "id": 768,
        "code_snippet": "public DefaultProfileActivationContext setActiveProfileIds(List<String> activeProfileIds) {\n        if (activeProfileIds != null) {\n            this.activeProfileIds = Collections.unmodifiableList(activeProfileIds);\n        } else {\n            this.activeProfileIds = Collections.emptyList();\n        }\n\n        return this;\n    }",
        "human_comment": "Sets the identifiers of those profiles that should be activated by explicit demand.\n\n@param activeProfileIds The identifiers of those profiles to activate, may be {@code null}.\n@return This context, never {@code null}.",
        "model_generated_comment": "Set the active profile ids of the {@link DefaultProfileActivationContext}.\n\n@param activeProfileIds the list of active profiles to set\n@return this instance"
    },
    {
        "id": 769,
        "code_snippet": "public List evaluate(Object o) {\n    return Collections.singletonList(\"data1\");\n  }",
        "human_comment": "UDF that returns a raw (non-parameterized) java List.",
        "model_generated_comment": "Evaluates a collection of data.\n\n@param o the collection to evaluate."
    },
    {
        "id": 770,
        "code_snippet": "public static void main(String[] args) {\n    HiveConf.setLoadHiveServer2Config(true);\n    ServerOptionsProcessor oproc = new ServerOptionsProcessor(\"hiveserver2\");\n    ServerOptionsProcessorResponse oprocResponse = oproc.parse(args);\n\n    HiveStringUtils.startupShutdownMessage(HiveServer2.class, args, LOG.getSlf4jLogger());\n\n    oprocResponse.getServerOptionsExecutor().execute();\n  }",
        "human_comment": "Call the executor which will execute the appropriate command based on the parsed options",
        "model_generated_comment": "Load the HiveServer2 configuration.\n\n@param args The args to load."
    },
    {
        "id": 771,
        "code_snippet": "public void populateResult(InternalSession session, ArtifactDescriptorResult result, Model model) {\n        ArtifactTypeRegistry stereotypes = session.getSession().getArtifactTypeRegistry();\n\n        for (Repository r : model.getRepositories()) {\n            result.addRepository(session.toRepository(\n                    session.getService(RepositoryFactory.class).createRemote(r)));\n        }\n\n        for (org.apache.maven.api.model.Dependency dependency : model.getDependencies()) {\n            result.addDependency(convert(dependency, stereotypes));\n        }\n\n        DependencyManagement mgmt = model.getDependencyManagement();\n        if (mgmt != null) {\n            for (org.apache.maven.api.model.Dependency dependency : mgmt.getDependencies()) {\n                result.addManagedDependency(convert(dependency, stereotypes));\n            }\n        }\n\n        Map<String, Object> properties = new LinkedHashMap<>();\n\n        Prerequisites prerequisites = model.getPrerequisites();\n        if (prerequisites != null) {\n            properties.put(\"prerequisites.maven\", prerequisites.getMaven());\n        }\n\n        List<License> licenses = model.getLicenses();\n        properties.put(\"license.count\", licenses.size());\n        for (int i = 0; i < licenses.size(); i++) {\n            License license = licenses.get(i);\n            properties.put(\"license.\" + i + \".name\", license.getName());\n            properties.put(\"license.\" + i + \".url\", license.getUrl());\n            properties.put(\"license.\" + i + \".comments\", license.getComments());\n            properties.put(\"license.\" + i + \".distribution\", license.getDistribution());\n        }\n\n        result.setProperties(properties);\n\n        setArtifactProperties(result, model);\n    }",
        "human_comment": "Populates Aether {@link ArtifactDescriptorResult} from Maven project {@link Model}.\n<p>\n<strong>Note:</strong> This class is part of work in progress and can be changed or removed without notice.\n@since 3.2.4",
        "model_generated_comment": "Create a new {@link ArtifactDescriptorResult} from the supplied session.\n\n@param session the session to create, may be {@code null}."
    },
    {
        "id": 772,
        "code_snippet": "public void testNormalize3() {\n        IMoney ms1 = MoneyBag.create(new Money(12, \"CHF\"), new Money(3, \"USD\"));\n        Money expected = new Money(4, \"USD\");\n        assertEquals(expected, fMB1.subtract(ms1));\n    }",
        "human_comment": "{[12 CHF][7 USD]} - {[12 CHF][3 USD]} == [4 USD]",
        "model_generated_comment": "Unit tests for {@link MoneyBag}."
    },
    {
        "id": 773,
        "code_snippet": "void shouldUseIdentityComparison() {\n        String key1 = new String(\"key\");\n        String key2 = new String(\"key\");\n\n        assertTrue(key1.equals(key2), \"Sanity check: keys should be equal\");\n        assertNotSame(key1, key2, \"Sanity check: keys should be distinct objects\");\n\n        AtomicInteger computeCount = new AtomicInteger(0);\n\n        map.computeIfAbsent(key1, k -> {\n            computeCount.incrementAndGet();\n            return \"value1\";\n        });\n\n        map.computeIfAbsent(key2, k -> {\n            computeCount.incrementAndGet();\n            return \"value2\";\n        });\n\n        assertEquals(1, computeCount.get(), \"Should compute once for equal but distinct keys\");\n    }",
        "human_comment": "Create two equal but distinct keys",
        "model_generated_comment": "Should use IdentityComparison() to compare two keys.\n\n@param key the key to compare, may be {@code null}."
    },
    {
        "id": 774,
        "code_snippet": "public DefaultProfileActivationContext setProjectDirectory(File projectDirectory) {\n        this.projectDirectory = projectDirectory;\n\n        return this;\n    }",
        "human_comment": "Sets the base directory of the current project.\n\n@param projectDirectory The base directory of the current project, may be {@code null} if profile activation\nhappens in the context of metadata retrieval rather than project building.\n@return This context, never {@code null}.",
        "model_generated_comment": "Set the project directory.\n\n@param projectDirectory The project directory to set."
    },
    {
        "id": 775,
        "code_snippet": "protected void failed(Throwable e, Description description) {\n    }",
        "human_comment": "Invoked when a test fails",
        "model_generated_comment": "Returns the failed {@link Throwable} with the given description.\n\n@param e The description of the failed throwable."
    },
    {
        "id": 776,
        "code_snippet": "public UnsafeRow getAggregationBuffer(InternalRow groupingKey) {\n    final UnsafeRow unsafeGroupingKeyRow = this.groupingKeyProjection.apply(groupingKey);\n\n    return getAggregationBufferFromUnsafeRow(unsafeGroupingKeyRow);\n  }",
        "human_comment": "Return the aggregation buffer for the current group. For efficiency, all calls to this method\nreturn the same object. If additional memory could not be allocated, then this method will\nsignal an error by returning null.",
        "model_generated_comment": "Get the AggregationBuffer from the UnsafeRow."
    },
    {
        "id": 777,
        "code_snippet": "public static TestExecutionResult successful() {\n\t\treturn SUCCESSFUL_RESULT;\n\t}",
        "human_comment": "Create a {@code TestExecutionResult} for a <em>successful</em> execution\nof a test or container.\n\n@return the {@code TestExecutionResult}; never {@code null}",
        "model_generated_comment": "Create a new {@link TestExecutionResult} that matches the supplied {@code success}.\n\n@since 5.4"
    },
    {
        "id": 778,
        "code_snippet": "void getWithTypeSafety() {\n\t\t\tInteger key = 42;\n\t\t\tString value = \"enigma\";\n\t\t\tstore.put(namespace, key, value);\n\n\t\t\tString requiredTypeValue = store.get(namespace, key, String.class);\n\t\t\tassertEquals(value, requiredTypeValue);\n\t\t}",
        "human_comment": "The fact that we can declare this as a String suffices for testing the required type.",
        "model_generated_comment": "Unit tests for {@link #getWithTypeSafety()}.\n\n@since 5.4"
    },
    {
        "id": 779,
        "code_snippet": "public static void assertNotEquals(short unexpected, Short actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Short) unexpected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4",
        "model_generated_comment": "<em>Assert</em> that {@code expected} and{@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@link Supplier}."
    },
    {
        "id": 780,
        "code_snippet": "public synchronized void hit(int damage) {\n    if (damage < 0) {\n      throw new IllegalArgumentException(\"Damage cannot be a negative number\");\n    }\n    if (isAlive()) {\n      setHealth(getHealth() - damage);\n      if (!isAlive()) {\n        kill();\n      }\n    }\n  }",
        "human_comment": "When a creature gets hit it removed the amount of damage from the creature's life.\n\n@param damage as the damage that was taken.",
        "model_generated_comment": "Sets the health of the target.\n\n@param damage the damage to hit.\n@throws IllegalArgumentException if the target is alive."
    },
    {
        "id": 781,
        "code_snippet": "default Transform[] inferPartitioning(CaseInsensitiveStringMap options) {\n    return new Transform[0];\n  }",
        "human_comment": "Infer the partitioning of the table identified by the given options.\n<p>\nBy default this method returns empty partitioning, please override it if this source support\npartitioning.\n\n@param options an immutable case-insensitive string-to-string map that can identify a table,\ne.g. file path, Kafka topic name, etc.",
        "model_generated_comment": "Implementation of {@link Transform#getPartitioning(CaseInsensitiveStringMap)}.\n\n@param options the options to infer partitioning.\n@return {@code Transform}"
    },
    {
        "id": 782,
        "code_snippet": "public Request complete(UUID uuid) {\n    Optional<Request> optReq = requestRepository.findById(uuid);\n    if (optReq.isEmpty()) {\n      throw new RequestNotFoundException(uuid);\n    }\n    return requestRepository.save(requestStateMachine.next(optReq.get(), Request.Status.COMPLETED));\n  }",
        "human_comment": "Complete the Request assigned with the given UUID.\n\n@param uuid The unique identifier for the Request.\n@return The completed Request.\n@throws RequestNotFoundException if a Request with the given UUID is not found.",
        "model_generated_comment": "Returns the complete request.\n\n@param uuid The uuid of the request\n@return The complete request"
    },
    {
        "id": 783,
        "code_snippet": "public static UTF8String toTitleCaseICU(UTF8String source) {\n    // In the default UTF8String implementation, `toLowerCase` method implicitly does UTF8String\n    // validation (replacing invalid UTF-8 byte sequences with Unicode replacement character\n    // U+FFFD), but now we have to do the validation manually.\n    source = source.makeValid();\n\n    // Building the title cased source with 'sb'.\n    UTF8StringBuilder sb = new UTF8StringBuilder();\n\n    // 'isNewWord' is true if the current character is the beginning of a word, false otherwise.\n    boolean isNewWord = true;\n    // We are maintaining if the current character is preceded by a cased letter.\n    // This is used when lowercasing capital Greek letter sigma ('\u03a3'), to figure out if it should be\n    // lowercased into \u03c3 or \u03c2.\n    boolean precededByCasedLetter = false;\n\n    // 'offset' is a byte offset in source's byte array pointing to the beginning of the character\n    // that we need to process next.\n    int offset = 0;\n    int len = source.numBytes();\n\n    while (offset < len) {\n      // We will actually call 'codePointFrom()' 2 times for each character in the worst case (once\n      // here, and once in 'followedByCasedLetter'). Example of a string where we call it 2 times\n      // for almost every character is '\u03a3\u03a3\u03a3\u03a3\u03a3' (a string consisting only of Greek capital sigma)\n      // and '\u03a3`````' (a string consisting of a Greek capital sigma, followed by case-ignorable\n      // characters).\n      int codepoint = source.codePointFrom(offset);\n      // Appending the correctly cased character onto 'sb'.\n      appendTitleCasedCodepoint(sb, codepoint, isNewWord, precededByCasedLetter, source, offset);\n      // Updating 'isNewWord', 'precededByCasedLetter' and 'offset' to be ready for the next\n      // character that we will process.\n      isNewWord = (codepoint == SpecialCodePointConstants.ASCII_SPACE);\n      if (!UCharacter.hasBinaryProperty(codepoint, UProperty.CASE_IGNORABLE)) {\n        precededByCasedLetter = UCharacter.hasBinaryProperty(codepoint, UProperty.CASED);\n      }\n      offset += UTF8String.numBytesForFirstByte(source.getByte(offset));\n    }\n    return sb.build();\n  }",
        "human_comment": "Title-casing a string using ICU case mappings. Iterates over the string and title-cases\nthe first character in each word, and lowercases every other character. Handles lowercasing\ncapital Greek letter sigma ('\u03a3') separately, taking into account if it should be a small final\nGreek sigma ('\u03c2') or small non-final Greek sigma ('\u03c3'). Words are separated by ASCII\nspace(\\u0020).\n\n@param source UTF8String to be title cased\n@return title cased source",
        "model_generated_comment": "Converts the supplied UTF8String into a title-case ICU.\n\n@param source The source to convert to, may be {@code null}."
    },
    {
        "id": 784,
        "code_snippet": "private record RowRange(long start, long end) {\n  }",
        "human_comment": "Helper struct to represent a range of row indexes `[start, end]`.",
        "model_generated_comment": "Sets the length of a row.\n\n@param start the start of the row."
    },
    {
        "id": 785,
        "code_snippet": "public static void assertEquals(Long expected, long actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Long) actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\nsupplied\n{@code messageSupplier}.\n\n@since 5.4"
    },
    {
        "id": 786,
        "code_snippet": "private static int numDimensions(Object o, DataType dtype) {\n    int ret = numArrayDimensions(o);\n    if (dtype == DataType.STRING && ret > 0) {\n      return ret - 1;\n    }\n    return ret;\n  }",
        "human_comment": "Return the number of dimensions of the tensor that object {@code o} represents as a tensor\nwhose datatype is {@code dtype}. Normally this is the same as the number of dimensions of o\nitself, but is one smaller for tensors of strings.\n\n@param o The object to inspect. It must be a valid representation of the given data type.\n@param dtype The expected data type of the tensor.",
        "model_generated_comment": "Creates a new num array with the given data type.\n\n@param o the data type to put into the num array."
    },
    {
        "id": 787,
        "code_snippet": "public static String truncate(String s) {\n        if (fgMaxMessageLength != -1 && s.length() > fgMaxMessageLength) {\n            s = s.substring(0, fgMaxMessageLength) + \"...\";\n        }\n        return s;\n    }",
        "human_comment": "Truncates a String to the maximum length.",
        "model_generated_comment": "Creates a truncate string with the given length.\n\n@param s the string to truncate\n@return the truncated string"
    },
    {
        "id": 788,
        "code_snippet": "public static Shape make(long firstDimensionSize, long... otherDimensionSizes) {\n    long[] shape = new long[otherDimensionSizes.length + 1];\n    shape[0] = firstDimensionSize;\n    System.arraycopy(otherDimensionSizes, 0, shape, 1, otherDimensionSizes.length);\n    return new Shape(shape);\n  }",
        "human_comment": "Create a Shape representing an N-dimensional value.\n\n<p>Creates a Shape representing an N-dimensional value (N being at least 1), with the provided\nsize for each dimension. A -1 indicates that the size of the corresponding dimension is\nunknown. For example:\n\n<pre>{@code\n// A 2-element vector.\nShape vector = Shape.create(2);\n\n// A 2x3 matrix.\nShape matrix = Shape.create(2, 3);\n\n// A matrix with 4 columns but an unknown number of rows.\n// This is typically used to indicate the shape of tensors that represent\n// a variable-sized batch of values. The Shape below might represent a\n// variable-sized batch of 4-element vectors.\nShape batch = Shape.create(-1, 4);\n}</pre>",
        "model_generated_comment": "Creates a new {@link Shape} with the given first dimension size.\n\n@param firstDimensionSize The first dimension of the first dimension, must not be <code>null</code>."
    },
    {
        "id": 789,
        "code_snippet": "public int ioExceptionsThresholdDuringMerge() {\n    return conf.getInt(\"spark.shuffle.push.server.ioExceptionsThresholdDuringMerge\", 4);\n  }",
        "human_comment": "The threshold for number of IOExceptions while merging shuffle blocks to a shuffle partition.\nWhen the number of IOExceptions while writing to merged shuffle data/index/meta file exceed\nthis threshold then the shuffle server will respond back to client to stop pushing shuffle\nblocks for this shuffle partition.",
        "model_generated_comment": "Sets the threshold during merge.\n\n@param ioExceptionsThresholdDuringMerge"
    },
    {
        "id": 790,
        "code_snippet": "static void registerExtensionsFromStaticFields(ExtensionRegistrar registrar, Class<?> clazz) {\n\t\tstreamExtensionRegisteringFields(clazz, ModifierSupport::isStatic) //\n\t\t\t\t.forEach(field -> {\n\t\t\t\t\tList<Class<? extends Extension>> extensionTypes = streamDeclarativeExtensionTypes(field).collect(\n\t\t\t\t\t\ttoList());\n\t\t\t\t\tboolean isExtendWithPresent = !extensionTypes.isEmpty();\n\n\t\t\t\t\tif (isExtendWithPresent) {\n\t\t\t\t\t\textensionTypes.forEach(registrar::registerExtension);\n\t\t\t\t\t}\n\t\t\t\t\tif (isAnnotated(field, RegisterExtension.class)) {\n\t\t\t\t\t\tExtension extension = readAndValidateExtensionFromField(field, null, extensionTypes);\n\t\t\t\t\t\tregistrar.registerExtension(extension, field);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}",
        "human_comment": "Register extensions using the supplied registrar from static fields in\nthe supplied class that are annotated with {@link ExtendWith @ExtendWith}\nor {@link RegisterExtension @RegisterExtension}.\n\n<p>The extensions will be sorted according to {@link Order @Order} semantics\nprior to registration.\n\n@param registrar the registrar with which to register the extensions; never {@code null}\n@param clazz the class or interface in which to find the fields; never {@code null}\n@since 5.11",
        "model_generated_comment": "Register extensions from {@link ExtensionRegistrar}.\n\n@param registrar the registrar to register extensions from; never {@code null}\n@return a list of extension types"
    },
    {
        "id": 791,
        "code_snippet": "public void forkStarted(ExecutionEvent event) {\n        if (logger.isInfoEnabled()) {\n            init();\n            logger.info(\"\");\n\n            MessageBuilder buffer = builder().strong(\">>> \");\n            append(buffer, event.getMojoExecution());\n            buffer.strong(\" > \");\n            appendForkInfo(buffer, event.getMojoExecution().getMojoDescriptor());\n            append(buffer, event.getProject());\n            buffer.strong(\" >>>\");\n\n            logger.info(buffer.toString());\n        }\n    }",
        "human_comment": "<pre>&gt;&gt;&gt; mojo-artifactId:version:goal (mojo-executionId) &gt; :forked-goal @ project-artifactId &gt;&gt;&gt;</pre>\n<pre>&gt;&gt;&gt; mojo-artifactId:version:goal (mojo-executionId) &gt; [lifecycle]phase @ project-artifactId &gt;&gt;&gt;</pre>",
        "model_generated_comment": "Initializes the fork.\n\n@param event the event to fork\n@return the fork"
    },
    {
        "id": 792,
        "code_snippet": "public UnresolvableModelException(Throwable cause, String groupId, String artifactId, String version) {\n        super(cause);\n        this.groupId = groupId;\n        this.artifactId = artifactId;\n        this.version = version;\n    }",
        "human_comment": "Creates a new exception with specified cause\n\n@param cause\n@param groupId\n@param artifactId\n@param version",
        "model_generated_comment": "Creates a {@link UnresolvableModelException} with the given cause.\n\n@param cause the cause to throw, may be {@code null}."
    },
    {
        "id": 793,
        "code_snippet": "public static boolean isAssignableTo(Class<?> sourceType, Class<?> targetType) {\n\t\tPreconditions.notNull(sourceType, \"source type must not be null\");\n\t\tPreconditions.condition(!sourceType.isPrimitive(), \"source type must not be a primitive type\");\n\t\tPreconditions.notNull(targetType, \"target type must not be null\");\n\n\t\tif (targetType.isAssignableFrom(sourceType)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (targetType.isPrimitive()) {\n\t\t\treturn sourceType == primitiveToWrapperMap.get(targetType) || isWideningConversion(sourceType, targetType);\n\t\t}\n\n\t\treturn false;\n\t}",
        "human_comment": "Determine if an object of the supplied source type can be assigned to the\nsupplied target type for the purpose of reflective method invocations.\n\n<p>In contrast to {@link Class#isAssignableFrom(Class)}, this method\nreturns {@code true} if the target type represents a primitive type whose\nwrapper matches the supplied source type. In addition, this method also supports\n<a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2\">\nwidening conversions</a> for primitive target types.\n\n@param sourceType the non-primitive target type; never {@code null}\n@param targetType the target type; never {@code null}\n@return {@code true} if an object of the source type is assignment compatible\nwith the target type\n@since 1.8\n@see Class#isInstance(Object)\n@see Class#isAssignableFrom(Class)\n@see #isAssignableTo(Object, Class)",
        "model_generated_comment": "<em>AssignableTo(Class<?> sourceType, Class<?> targetType) {@code null}\n@since 5.4"
    },
    {
        "id": 794,
        "code_snippet": "static final Migration MIGRATION_2_3 = new Migration(2, 3) {\n    };",
        "human_comment": "Migrate from:\nversion 2 - using Room\nto\nversion 3 - using Room where the {@link User} has an extra field: date",
        "model_generated_comment": "Create a new {@link Migration}.\n\n@param new Migration The {@code MIGRATION_2_3}\n@return a new Migration"
    },
    {
        "id": 795,
        "code_snippet": "public static <T> CombinableBothMatcher<T> both(Matcher<? super T> matcher) {\n        return CoreMatchers.both(matcher);\n    }",
        "human_comment": "This is useful for fluently combining matchers that must both pass.  For example:\n<pre>\nassertThat(string, both(containsString(\"a\")).and(containsString(\"b\")));\n</pre>\n\n@deprecated Please use {@link CoreMatchers#both(Matcher)} instead.",
        "model_generated_comment": "Creates a CombinableBothMatcher that matches both matcher.\n\n@param matcher the matcher to match."
    },
    {
        "id": 796,
        "code_snippet": "void setUp() {\n    parameterObject = ParameterObject.newBuilder().withType(\"sneakers\").build();\n\n    searchService = new SearchService();\n  }",
        "human_comment": "Creating parameter object with default values set",
        "model_generated_comment": "Set up the parameter object.\n\n@param parameterObject The parameter object to set up."
    },
    {
        "id": 797,
        "code_snippet": "public static void assertEquals(Double expected, double actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Double) actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "<em>Assert</em> that {@link Double} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\nsupplied\n{@code messageSupplier}.\n\n@since 5.4"
    },
    {
        "id": 798,
        "code_snippet": "void testCaseWithDeclaredInterruptCallbackThrowsException() {\n\t\tinterruptCallbackShallThrowException.set(true);\n\t\tEvents tests = executeTestsForClass(DefaultPreInterruptCallbackWithExplicitCallbackTestCase.class).testEvents();\n\t\ttests.failed().assertEventsMatchExactly(event(test(TC),\n\t\t\tfinishedWithFailure(instanceOf(TimeoutException.class), message(TIMEOUT_ERROR_MSG),\n\t\t\t\tsuppressed(0, instanceOf(InterruptedException.class)),\n\t\t\t\tsuppressed(1, instanceOf(IllegalStateException.class)))));\n\t\tassertTrue(interruptedTest.get());\n\t\tPreInterruptContext preInterruptContext = calledPreInterruptContext.get();\n\t\tassertNotNull(preInterruptContext);\n\t\tassertNotNull(preInterruptContext.getThreadToInterrupt());\n\t\tassertEquals(preInterruptContext.getThreadToInterrupt(), interruptedTestThread.get());\n\t}",
        "human_comment": "Wait until the real test thread was interrupted due to executor.shutdown(), otherwise the asserts below will be flaky.",
        "model_generated_comment": "Unit tests for {@link PreInterruptCallback}.\n\n@since 5.0"
    },
    {
        "id": 799,
        "code_snippet": "private TreeNode<T> traverseOneLevelDown(T value) {\n    if (this.isGreaterThan(value)) {\n      return this.left;\n    }\n    return this.right;\n  }",
        "human_comment": "Returns left or right child of self based on a value that would be inserted; maintaining the\nintegrity of the BST.\n\n@param value The value of the TreeNode that would be inserted beneath self\n@return The child TreeNode of self which represents the subtree where `value` would be inserted",
        "model_generated_comment": "A TreeNode that traverses one level down.\n\n@param value The value to traverse.\n@return this TreeNode"
    },
    {
        "id": 800,
        "code_snippet": "public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2) {\n        try {\n            ArtifactVersion version1 = node1.getArtifact().getSelectedVersion();\n            ArtifactVersion version2 = node2.getArtifact().getSelectedVersion();\n\n            return version1.compareTo(version2) > 0 ? node1 : node2;\n        } catch (OverConstrainedVersionException exception) {\n            // TODO log message or throw exception?\n\n            return null;\n        }\n    }",
        "human_comment": "Resolves conflicting artifacts by always selecting the <em>newest</em> declaration. Newest is defined as the\ndeclaration whose version is greater according to <code>ArtifactVersion.compareTo</code>.\n\n@see ArtifactVersion#compareTo\n@since 3.0",
        "model_generated_comment": "Resolve a conflict between two ResolutionNode nodes.\n\n@param node1 ResolutionNode the ResolutionNode to resolve the conflict\n@return null"
    },
    {
        "id": 801,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaVectorSlicerExample\")\n      .getOrCreate();\n\n    Attribute[] attrs = {\n      NumericAttribute.defaultAttr().withName(\"f1\"),\n      NumericAttribute.defaultAttr().withName(\"f2\"),\n      NumericAttribute.defaultAttr().withName(\"f3\")\n    };\n    AttributeGroup group = new AttributeGroup(\"userFeatures\", attrs);\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(Vectors.sparse(3, new int[]{0, 1}, new double[]{-2.0, 2.3})),\n    vectorSlicer.setIndices(new int[]{1}).setNames(new String[]{\"f3\"});\n}",
        "human_comment": "$example on$\n$example off$\n$example on$\nor slicer.setIndices(new int[]{1, 2}), or slicer.setNames(new String[]{\"f2\", \"f3\"})",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 802,
        "code_snippet": "public static Credentials of(final String username, final String password) {\n      return new Credentials(username, password);\n   }",
        "human_comment": "Construct an immutable Credentials object with the supplied username and password.\n\n@param username the username\n@param password the password\n@return a new Credentials object",
        "model_generated_comment": "Creates a new <em>Credentials</em> of the given username.\n\n@param username the username of the username\n@return a new {@code Credentials} of the supplied password"
    },
    {
        "id": 803,
        "code_snippet": "public BuildPlan buildInitialPlan(List<TaskSegment> taskSegments) {\n            int nThreads = Math.min(\n                    session.getRequest().getDegreeOfConcurrency(),\n                    session.getProjects().size());\n            boolean parallel = nThreads > 1;\n            session.setParallel(parallel);\n\n            ProjectDependencyGraph dependencyGraph = session.getProjectDependencyGraph();\n            MavenProject rootProject = session.getTopLevelProject();\n\n            Map<MavenProject, List<MavenProject>> allProjects = new LinkedHashMap<>();\n            dependencyGraph\n                    .getSortedProjects()\n                    .forEach(p -> allProjects.put(p, dependencyGraph.getUpstreamProjects(p, false)));\n\n            BuildPlan plan = new BuildPlan(allProjects);\n            for (TaskSegment taskSegment : taskSegments) {\n                Map<MavenProject, List<MavenProject>> projects = taskSegment.isAggregating()\n                        ? Collections.singletonMap(rootProject, allProjects.get(rootProject))\n                        : allProjects;\n\n                BuildPlan segment = calculateMojoExecutions(projects, taskSegment.getTasks());\n                plan.then(segment);\n            }\n\n            for (MavenProject project : plan.getAllProjects().keySet()) {\n                BuildStep pplan = new BuildStep(PLAN, project, null);\n                pplan.status.set(PLANNING); // the plan step always need planning\n                BuildStep setup = new BuildStep(SETUP, project, null);\n                BuildStep teardown = new BuildStep(TEARDOWN, project, null);\n                teardown.executeAfter(setup);\n                setup.executeAfter(pplan);\n                plan.steps(project).forEach(step -> {\n                    if (step.predecessors.stream().noneMatch(s -> s.project == project)) {\n                        step.executeAfter(setup);\n                    } else if (step.successors.stream().noneMatch(s -> s.project == project)) {\n                        teardown.executeAfter(step);\n                    }\n                });\n                Stream.of(pplan, setup, teardown).forEach(step -> plan.addStep(project, step.name, step));\n            }\n\n            return plan;\n        }",
        "human_comment": "Propagate the parallel flag to the root session\nCreate plan, setup and teardown",
        "model_generated_comment": "$example on$\n$example off$\nCreate a build plan for the given taskSegment.\n\n@param taskSegments the task segments to build, must not be <code>null</code>."
    },
    {
        "id": 804,
        "code_snippet": "public MojoExecutionException(Object source, String shortMessage, String longMessage) {\n        super(shortMessage);\n        this.source = source;\n        this.longMessage = longMessage;\n    }",
        "human_comment": "Construct a new <code>MojoExecutionException</code> exception providing the source and a short and long message:\nthese messages are used to improve the message written at the end of Maven build.\n\n@param source\n@param shortMessage\n@param longMessage",
        "model_generated_comment": "Creates a MojoExecutionException with the supplied {@code source} message.\n\n@param shortMessage the short message to throw."
    },
    {
        "id": 805,
        "code_snippet": "public static UTF8String exec(final UTF8String v, final int collationId, boolean useICU) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType) {\n        return useICU ? execBinaryICU(v) : execBinary(v);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(v);\n      } else {\n        return execICU(v, collationId);\n      }\n    }",
        "human_comment": "Space trimming does not affect the output of this expression.",
        "model_generated_comment": "Creates a UTF8String with the given collation id.\n\n@param v The collation ID of the collation, must not be <code>null</code>."
    },
    {
        "id": 806,
        "code_snippet": "protected MemoryConsumer(TaskMemoryManager taskMemoryManager, long pageSize, MemoryMode mode) {\n    this.taskMemoryManager = taskMemoryManager;\n    this.pageSize = pageSize;\n    this.mode = mode;\n  }",
        "human_comment": "A memory consumer of {@link TaskMemoryManager} that supports spilling.\n\nNote: this only supports allocation / spilling of Tungsten memory.",
        "model_generated_comment": "Creates a new {@link MemoryConsumer} that stores the memory of the given task.\n\n@param taskMemoryManager The task to store the memory, must not be {@code null}."
    },
    {
        "id": 807,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaModelSelectionViaCrossValidationExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Prepare training documents, which are labeled.\n    Dataset<Row> training = spark.createDataFrame(Arrays.asList(\n      new JavaLabeledDocument(0L, \"a b c d e spark\", 1.0),\n      new JavaLabeledDocument(1L, \"b d\", 0.0),\n      new JavaLabeledDocument(2L,\"spark f g h\", 1.0),\n      new JavaLabeledDocument(3L, \"hadoop mapreduce\", 0.0),\n      new JavaLabeledDocument(4L, \"b spark who\", 1.0),\n      new JavaLabeledDocument(5L, \"g d a y\", 0.0),\n      new JavaLabeledDocument(6L, \"spark fly\", 1.0),\n      new JavaLabeledDocument(7L, \"was mapreduce\", 0.0),\n      new JavaLabeledDocument(8L, \"e spark program\", 1.0),\n      new JavaLabeledDocument(9L, \"a e c l\", 0.0),\n      new JavaLabeledDocument(10L, \"spark compile\", 1.0),\n      new JavaLabeledDocument(11L, \"hadoop software\", 0.0)\n    ), JavaLabeledDocument.class);\n\n    // Configure an ML pipeline, which consists of three stages: tokenizer, hashingTF, and lr.\n    Tokenizer tokenizer = new Tokenizer()\n      .setInputCol(\"text\")\n      .setOutputCol(\"words\");\n    HashingTF hashingTF = new HashingTF()\n      .setNumFeatures(1000)\n      .setInputCol(tokenizer.getOutputCol())\n      .setOutputCol(\"features\");\n    LogisticRegression lr = new LogisticRegression()\n      .setMaxIter(10)\n      .setRegParam(0.01);\n    Pipeline pipeline = new Pipeline()\n      .setStages(new PipelineStage[] {tokenizer, hashingTF, lr});\n      .addGrid(hashingTF.numFeatures(), new int[] {10, 100, 1000})\n      .addGrid(lr.regParam(), new double[] {0.1, 0.01})\n    // $example off$\n\n    spark.stop();\n  }",
        "human_comment": "Java example for Model Selection via Cross Validation.",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 808,
        "code_snippet": "protected void write(StringBuilder buf, Throwable t) {\n        PrintStream targetStream = CONFIG_PARAMS.outputChoice.getTargetPrintStream();\n\n        synchronized (CONFIG_PARAMS) {\n            targetStream.println(buf.toString());\n            writeThrowable(t, targetStream);\n            targetStream.flush();\n        }\n    }",
        "human_comment": "To avoid intermingling of log messages and associated stack traces, the two\noperations are done in a synchronized block.\n\n@param buf   The StringBuilder containing the log message to be written\n@param t     The Throwable object whose stack trace should be written, may be null",
        "model_generated_comment": "Writes a string to the target stream.\n\n@param buf The string to write the string to, may be {@code null}."
    },
    {
        "id": 809,
        "code_snippet": "public UserRepository(AppExecutors appExecutors, UserDataSource userDataSource) {\n        mAppExecutors = appExecutors;\n        mUserDataSource = userDataSource;\n    }",
        "human_comment": "The repository is responsible of handling user data operations.",
        "model_generated_comment": "Creates a repository for the supplied user data.\n\n@param appExecutors The appexecutors, may be {@code null}."
    },
    {
        "id": 810,
        "code_snippet": "public DefaultModelUrlNormalizer(UrlNormalizer urlNormalizer) {\n        this.urlNormalizer = urlNormalizer;\n    }",
        "human_comment": "Normalizes URLs to remove the ugly parent references \"../\" that got potentially inserted by URL adjustment during\nmodel inheritance.",
        "model_generated_comment": "Creates a new {@link DefaultModelUrlNormalizer} for the specified url.\n\n@param urlNormalizer The url to use, may be {@code null}."
    },
    {
        "id": 811,
        "code_snippet": "public void onChannelReadEvent(AbstractNioChannel channel, Object readObject, SelectionKey key) {\n    executorService.execute(() -> channel.getHandler().handleChannelRead(channel, readObject, key));\n  }",
        "human_comment": "Submits the work of dispatching the read event to worker pool, where it gets picked up by\nworker threads. <br>\nNote that this is a non-blocking call and returns immediately. It is not guaranteed that the\nevent has been handled by associated handler.",
        "model_generated_comment": "Handle the channel read event.\n\n@param channel The channel to read.\n@return The channel read object."
    },
    {
        "id": 812,
        "code_snippet": "public static SelectorResolutionResult resolved() {\n\t\treturn RESOLVED_RESULT;\n\t}",
        "human_comment": "Create a {@code SelectorResolutionResult} for a <em>resolved</em>\nselector.\n@return the {@code SelectorResolutionResult}; never {@code null}",
        "model_generated_comment": "Create a new {@link SelectorResolutionResult} that matches the supplied {@code resolved} result.\n\n@param resolved the result to use; never\n{@code null}"
    },
    {
        "id": 813,
        "code_snippet": "void executionsFromStartedTestEvents() {\n\t\tvar testEvents = getTestEvents();\n\n\t\tassertThat(testEvents.executions().started().count()).isEqualTo(3);\n\t\tassertThat(testEvents.started().executions().count()).isEqualTo(0);\n\t}",
        "human_comment": "We expect 3 if the executions are created BEFORE filtering out \"finished\" events.\nWe expect 0 if the executions are created AFTER filtering out \"finished\" events.",
        "model_generated_comment": "Unit tests for {@link TestEvents}.\n\n@since 5.0"
    },
    {
        "id": 814,
        "code_snippet": "public void collectLog(LogEntry logEntry) {\n    if (logEntry.getLevel() == null || minLogLevel == null) {\n      LOGGER.warn(\"Log level or threshold level is null. Skipping.\");\n      return;\n    }\n\n    if (logEntry.getLevel().compareTo(minLogLevel) < 0) {\n      LOGGER.debug(\"Log level below threshold. Skipping.\");\n      return;\n    }\n\n    buffer.offer(logEntry);\n\n    if (logCount.incrementAndGet() >= BUFFER_THRESHOLD) {\n      flushBuffer();\n    }\n  }",
        "human_comment": "Collects a given log entry, and filters it by the defined log level.\n\n@param logEntry The log entry to collect.",
        "model_generated_comment": "Collects the log from the log entry.\n\n@param logEntry The log entry to collect.\n@return {@link LogEntry}"
    },
    {
        "id": 815,
        "code_snippet": "static Arguments toArguments(Object item) {\n\t\t// Nothing to do except cast.\n\t\tif (item instanceof Arguments) {\n\t\t\treturn (Arguments) item;\n\t\t}\n\n\t\t// Pass all multidimensional arrays \"as is\", in contrast to Object[].\n\t\t// See https://github.com/junit-team/junit5/issues/1665\n\t\tif (ReflectionUtils.isMultidimensionalArray(item)) {\n\t\t\treturn arguments(item);\n\t\t}\n\n\t\t// Special treatment for one-dimensional reference arrays.\n\t\t// See https://github.com/junit-team/junit5/issues/1665\n\t\tif (item instanceof Object[]) {\n\t\t\treturn arguments((Object[]) item);\n\t\t}\n\n\t\t// Pass everything else \"as is\".\n\t\treturn arguments(item);\n\t}",
        "human_comment": "Convert the supplied object into an {@link Arguments} instance.",
        "model_generated_comment": "<em>Assert</em> that the supplied {@link Arguments} are multidimensional arrays.\n\n@param item the {@code item} to be used for the\n{@link AssertionUtils#isMultidimensionalArray(Object)}\n@return the array containing the arguments\n@see #excludeArguments(Object)"
    },
    {
        "id": 816,
        "code_snippet": "public record ShuffleIndexRecord(long offset, long length) {\n}",
        "human_comment": "Contains offset and length of the shuffle block data.",
        "model_generated_comment": "Create a new {@link ShuffleIndexRecord} with the specified offset and length.\n\n@param offset the offset of the record; never {@code null}"
    },
    {
        "id": 817,
        "code_snippet": "public boolean equals(Object other) {\n    if (other instanceof VariantVal o) {\n      return Arrays.equals(value, o.value) && Arrays.equals(metadata, o.metadata);\n    } else {\n      return false;\n    }\n  }",
        "human_comment": "Compare two variants in bytes. The variant equality is more complex than it, and we haven't\nsupported it in the user surface yet. This method is only intended for tests.",
        "model_generated_comment": "Asserts that two instances of VariantVal are equal. If they are not, they are considered equal.\n\n@param other instanceof VariantVal\n@return true if they are equal"
    },
    {
        "id": 818,
        "code_snippet": "public ConditionParser(Map<String, ExpressionFunction> functions, UnaryOperator<String> propertyResolver) {\n        this.functions = functions;\n        this.propertyResolver = propertyResolver;\n    }",
        "human_comment": "Constructs a new {@code ConditionParser} with the given function mappings.\n@param propertyResolver the property resolver",
        "model_generated_comment": "Constructs a {@link ConditionParser}.\n\n@param functions The functions to parse, may be {@code null}."
    },
    {
        "id": 819,
        "code_snippet": "default Set<? extends TestDescriptor> getDescendants() {\n\t\tSet<TestDescriptor> descendants = new LinkedHashSet<>();\n\t\tdescendants.addAll(getChildren());\n\t\tfor (TestDescriptor child : getChildren()) {\n\t\t\tdescendants.addAll(child.getDescendants());\n\t\t}\n\t\treturn Collections.unmodifiableSet(descendants);\n\t}",
        "human_comment": "Get the immutable set of all <em>descendants</em> of this descriptor.\n\n<p>A <em>descendant</em> is a child of this descriptor or a child of one of\nits children, recursively.\n\n@see #getChildren()",
        "model_generated_comment": "Create a new {@link TestDescriptor} with the supplied children.\n\n@param descendants the children to be used to create the new set; never {@code null}"
    },
    {
        "id": 820,
        "code_snippet": "public void describeTo(Description description) {\n        if (fAssumption != null) {\n            description.appendText(fAssumption);\n        }\n\n        if (fValueMatcher) {\n            if (fAssumption != null) {\n                description.appendText(\": \");\n            }\n\n            description.appendText(\"got: \");\n            description.appendValue(fValue);\n\n            if (fMatcher != null) {\n                description.appendText(\", expected: \");\n                description.appendDescriptionOf(fMatcher);\n            }\n        }\n    }",
        "human_comment": "a value was passed in when this instance was constructed; print it",
        "model_generated_comment": "Append a description to the given description.\n\n@param description the description to append."
    },
    {
        "id": 821,
        "code_snippet": "public boolean hasReachedMaxLevel() {\n        return maxReached.get().ordinal() > maxAllowed.ordinal();\n    }",
        "human_comment": "Responsible for keeping state of whether the threshold of the --fail-on-severity flag has been hit.",
        "model_generated_comment": "Returns the maximum level for the given max level.\n\n@param maxLevel the max level to check."
    },
    {
        "id": 822,
        "code_snippet": "public static Condition<Throwable> cause(Condition<Throwable>... conditions) {\n\t\tList<Condition<Throwable>> list = Arrays.stream(conditions)//\n\t\t\t\t.map(TestExecutionResultConditions::cause)//\n\t\t\t\t.collect(toList());\n\n\t\treturn Assertions.allOf(list);\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if a\nsupplied conditions.\n\n@see #rootCause(Condition...)\n@see #suppressed(int, Condition...)",
        "model_generated_comment": "Create a new {@link Condition} with the supplied {@code conditions} and\nthe supplied\n{@linkplain TestExecutionResultConditions}.\n\n@param conditions the conditions to be used to create the new condition; never {em>{@code null} or blank\n@return the new Condition"
    },
    {
        "id": 823,
        "code_snippet": "public Executions finished() {\n\t\treturn new Executions(finishedExecutions(), this.category + \" Finished\");\n\t}",
        "human_comment": "Get the finished {@link Executions} contained in this {@code Executions} object.\n\n@return the filtered {@code Executions}; never {@code null}",
        "model_generated_comment": "Create a new {@link Executions} with the given {@code finished} name.\n\n@param finishedExecutions the name of the\n{@code Executions}."
    },
    {
        "id": 824,
        "code_snippet": "public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2) {\n        return node1.getDepth() <= node2.getDepth() ? node1 : node2;\n    }",
        "human_comment": "Resolves conflicting artifacts by always selecting the <em>nearest</em> declaration. Nearest is defined as the\ndeclaration that has the least transitive steps away from the project being built.\n\n@since 3.0",
        "model_generated_comment": "Resolve a conflict between two ResolutionNode nodes.\n\n@param node1 ResolutionNode The ResolutionNode to resolve the conflict."
    },
    {
        "id": 825,
        "code_snippet": "private static boolean checkCombineLines(String line) {\n            int bsCount = 0;\n            for (int idx = line.length() - 1; idx >= 0 && line.charAt(idx) == '\\\\'; idx--) {\n                bsCount++;\n            }\n\n            return bsCount % 2 != 0;\n        }",
        "human_comment": "Checks if the passed in line should be combined with the following.\nThis is true, if the line ends with an odd number of backslashes.\n\n@param line the line\n@return a flag if the lines should be combined",
        "model_generated_comment": "Check whether two lines are equal.\n\n@param line The line to check, may be {@code null}."
    },
    {
        "id": 826,
        "code_snippet": "public long doRemoteFunction(int value) {\n\n    long waitTime = (long) Math.floor(randomProvider.random() * 1000);\n\n    try {\n      sleep(waitTime);\n    } catch (InterruptedException e) {\n      LOGGER.error(\"Thread sleep state interrupted\", e);\n      Thread.currentThread().interrupt();\n    }\n    return waitTime <= THRESHOLD\n        ? value * 10\n        : RemoteServiceStatus.FAILURE.getRemoteServiceStatusValue();\n  }",
        "human_comment": "Remote function takes a value and multiplies it by 10 taking a random amount of time. Will\nsometimes return -1. This imitates connectivity issues a client might have to account for.\n\n@param value integer value to be multiplied.\n@return if waitTime is less than {@link RemoteService#THRESHOLD}, it returns value * 10,\notherwise {@link RemoteServiceStatus#FAILURE}.",
        "model_generated_comment": "Determine if the current thread is interrupted.\n\n@param value the value to do the remote function.\n@return The current thread state."
    },
    {
        "id": 827,
        "code_snippet": "public T setDeployMode(String mode) {\n    checkNotNull(mode, \"mode\");\n    builder.deployMode = mode;\n    return self();\n  }",
        "human_comment": "Set the deploy mode for the application.\n\n@param mode Deploy mode.\n@return This launcher.",
        "model_generated_comment": "Set the deployment mode.\n\n@param mode The mode to set."
    },
    {
        "id": 828,
        "code_snippet": "public static void assertArrayEquals(short[] expected, short[] actual, Supplier<String> messageSupplier) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} short arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "<em>Assert</em> that two short arrays are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@since 5.4"
    },
    {
        "id": 829,
        "code_snippet": "byte[] toParentKey(Object value) {\n      return toKey(value, SECONDARY_IDX_PREFIX);\n    }",
        "human_comment": "Remove a value from the index.\n\n@param batch Write batch with other related changes.\n@param entity The entity being removed, to identify the index entry to modify.\n@param naturalKey The value's natural key (to avoid re-computing it for every index).\n@param prefix The parent index prefix, if this is a child index.",
        "model_generated_comment": "Returns the parent key of the key.\n\n@param value the value to return."
    },
    {
        "id": 830,
        "code_snippet": "public Injector getInjector() {\n        if (injector == null) {\n            setupContainer();\n        }\n        return injector;\n    }",
        "human_comment": "Returns the DI injector, creating it if necessary.\n\n@return The configured injector instance",
        "model_generated_comment": "Get the injector from the container.\n\n@param injector the {@link Injector}\n@return The injector"
    },
    {
        "id": 831,
        "code_snippet": "public void setAspectRatio(int width, int height) {\n    if (width < 0 || height < 0) {\n      throw new IllegalArgumentException(\"Size cannot be negative.\");\n    }\n    mRatioWidth = width;\n    mRatioHeight = height;\n    requestLayout();\n  }",
        "human_comment": "Sets the aspect ratio for this view. The size of the view will be measured based on the ratio\ncalculated from the parameters. Note that the actual sizes of parameters don't matter, that is,\ncalling setAspectRatio(2, 3) and setAspectRatio(4, 6) make the same result.\n\n@param width Relative horizontal size\n@param height Relative vertical size",
        "model_generated_comment": "Sets the height of the given {@code width} element.\n\n@param width the width of the element\n@throws IllegalArgumentException if the height is negative."
    },
    {
        "id": 832,
        "code_snippet": "public static FileSource from(File file) {\n\t\treturn new FileSource(file);\n\t}",
        "human_comment": "Create a new {@code FileSource} using the supplied {@link File file}.",
        "model_generated_comment": "Create a new {@link FileSource} from the supplied file.\n\n@param file the file to create; never {@code null}"
    },
    {
        "id": 833,
        "code_snippet": "private SetProperty(String property, String value) {\n      this.property = property;\n      this.value = value;\n    }",
        "human_comment": "A NamespaceChange to set a namespace property.\n<p>\nIf the property already exists, it must be replaced with the new value.",
        "model_generated_comment": "Set the value of the property.\n\n@param property the property to set."
    },
    {
        "id": 834,
        "code_snippet": "public static <T> T assertInstanceOf(Class<T> expectedType, Object actualValue) {\n\t\treturn AssertInstanceOf.assertInstanceOf(expectedType, actualValue);\n\t}",
        "human_comment": "<em>Assert</em> that the supplied {@code actualValue} is an instance of the\n{@code expectedType}.\n\n<p>Like the {@code instanceof} operator a {@code null} value is not\nconsidered to be of the {@code expectedType} and does not pass the assertion.\n\n@since 5.8",
        "model_generated_comment": "<em>Assert</em> that {@code expectedType} is an instance of {@link Object}.\n\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@link AssertInstanceOf(Object)} object.\n\n@since 5.4"
    },
    {
        "id": 835,
        "code_snippet": "void testHandleExceptionLoopInCause() {\n        AtomicReference<Throwable> causeRef = new AtomicReference<>(null);\n        Exception cause2 = new RuntimeException(\"loop\") {\n        };\n        causeRef.set(cause2);\n\n        Plugin plugin = new Plugin();\n        Exception cause = new PluginContainerException(plugin, null, null, cause2);\n        cause2.initCause(cause);\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n        MojoDescriptor mojoDescriptor = new MojoDescriptor();\n        mojoDescriptor.setPluginDescriptor(pluginDescriptor);\n        MojoExecution mojoExecution = new MojoExecution(mojoDescriptor);\n        Throwable exception = new PluginExecutionException(mojoExecution, null, cause);\n\n        DefaultExceptionHandler handler = new DefaultExceptionHandler();\n        ExceptionSummary summary = handler.handleException(exception);\n\n        String expectedReference = \"http://cwiki.apache.org/confluence/display/MAVEN/PluginContainerException\";\n        assertEquals(expectedReference, summary.getReference());\n    }",
        "human_comment": "Some broken exception that does return \"this\" as getCause",
        "model_generated_comment": "Unit tests for {@link PluginContainerException}.\n\n@param cause the cause of the exception\n@throws Exception if the cause is {@code null}."
    },
    {
        "id": 836,
        "code_snippet": "public OverlayView(final Context context, final AttributeSet attrs) {\n    super(context, attrs);\n  }",
        "human_comment": "A simple View providing a render callback to other classes.",
        "model_generated_comment": "Creates a new OverlayView with the supplied context.\n\n@param context The context to view the view."
    },
    {
        "id": 837,
        "code_snippet": "public static _Fields findByName(String name) {\n      return byName.get(name);\n    }",
        "human_comment": "Find the _Fields constant that matches name, or null if its not found.",
        "model_generated_comment": "Finds the name of the given field.\n\n@param name the field to find.\n@return {@code true} if the field matches the given name."
    },
    {
        "id": 838,
        "code_snippet": "private boolean containsPatches(Set<PathType> types) {\n        for (PathType type : types) {\n            if (type instanceof JavaPathType.Modular modular) {\n                type = modular.rawType();\n            }\n            if (JavaPathType.PATCH_MODULE.equals(type)) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "human_comment": "Returns whether the given set of path types contains at least one patch for a module.",
        "model_generated_comment": "Returns true if the given path type containspatches.\n\n@param types The type of the path type to check\n@return true if this path type haspatches"
    },
    {
        "id": 839,
        "code_snippet": "public void testSimpleNegate() {\n        Money expected = new Money(-14, \"CHF\");\n        assertEquals(expected, f14CHF.negate());\n    }",
        "human_comment": "[14 CHF] negate == [-14 CHF]",
        "model_generated_comment": "Unit tests for {@link SimpleNegate}.\n\n@param expected {@code CHF}."
    },
    {
        "id": 840,
        "code_snippet": "void testNullTaskWithNullCallback() {\n    assertTimeout(\n        ofMillis(3000),\n        () -> {\n          // Instantiate a new executor and start a new 'null' task ...\n          final var executor = new ThreadAsyncExecutor();\n          final var asyncResult = executor.startProcess(null, null);\n\n          assertNotNull(\n              asyncResult,\n              \"The AsyncResult should not be 'null', even though the task and callback were 'null'.\");\n          asyncResult.await(); // Prevent timing issues, and wait until the result is available\n          assertTrue(asyncResult.isCompleted());\n\n          try {\n            asyncResult.getValue();\n            fail(\"Expected ExecutionException with NPE as cause\");\n          } catch (final ExecutionException e) {\n            assertNotNull(e.getMessage());\n            assertNotNull(e.getCause());\n            assertEquals(NullPointerException.class, e.getCause().getClass());\n          }\n        });\n  }",
        "human_comment": "Test used to verify the behaviour of {@link ThreadAsyncExecutor#startProcess(Callable,\nAsyncCallback)} when both the callable and the asynchronous callback are 'null'",
        "model_generated_comment": "Unit tests for {@link ThreadAsyncExecutor}.\n\n@since 5.0"
    },
    {
        "id": 841,
        "code_snippet": "public List<UserAccount> getCacheDataInListForm() {\n    var listOfCacheData = new ArrayList<UserAccount>();\n    var temp = head;\n    while (temp != null) {\n      listOfCacheData.add(temp.userAccount);\n      temp = temp.next;\n    }\n    return listOfCacheData;\n  }",
        "human_comment": "Returns cache data in list form.\n\n@return {@link List}",
        "model_generated_comment": "Get the cache data from the user account.\n\n@param userAccount The user account, may be {@code null}."
    },
    {
        "id": 842,
        "code_snippet": "public final Optional<FilePosition> getPosition() {\n\t\treturn Optional.ofNullable(this.filePosition);\n\t}",
        "human_comment": "Get the {@link FilePosition}, if available.",
        "model_generated_comment": "Get the position of the supplied {@link FilePosition}.\n\n@param filePosition the position to get; never {@code null}\n@return the position"
    },
    {
        "id": 843,
        "code_snippet": "public static FilePosition from(int line, int column) {\n\t\treturn new FilePosition(line, column);\n\t}",
        "human_comment": "Create a new {@code FilePosition} using the supplied {@code line} and\n\n@param line the line number; must be greater than zero\n@param column the column number; must be greater than zero\n@return a {@link FilePosition} with the given line and column numbers",
        "model_generated_comment": "Create a new {@link FilePosition} for the supplied {@code line}.\n\n@param line the line to put into the new position; never\n{@code null} or blank"
    },
    {
        "id": 844,
        "code_snippet": "public LoginPage enterUsername(String username) {\n    var usernameInputTextField = (HtmlTextInput) page.getElementById(\"username\");\n    usernameInputTextField.setText(username);\n    return this;\n  }",
        "human_comment": "Enters the username into the username input text field.\n\n@param username the username to enter\n@return {@link LoginPage}",
        "model_generated_comment": "Enter the username of the user.\n\n@param username the username to enter."
    },
    {
        "id": 845,
        "code_snippet": "public Order checkout(final String userId) {\n    List<Cart> items = cartRepository.getItemsInCart(userId);\n    String orderId = \"ORDER-\" + System.currentTimeMillis();\n    Order order = new Order(orderId, items);\n    orderRepository.saveOrder(order);\n    cartRepository.clearCart(userId);\n    return order;\n  }",
        "human_comment": "Checks out the user's cart and creates an order.\n\n<p>This method retrieves the cart items, generates an order ID, creates a new order, saves it,\nand clears the cart.\n\n@param userId The ID of the user.\n@return The created order containing purchased items.",
        "model_generated_comment": "Creates a new Order for the supplied user ID.\n\n@param userId The user ID of the user ID\n@return an Order"
    },
    {
        "id": 846,
        "code_snippet": "public static ArrayType createArrayType(DataType elementType) {\n    if (elementType == null) {\n      throw new IllegalArgumentException(\"elementType should not be null.\");\n    }\n    return new ArrayType(elementType, true);\n  }",
        "human_comment": "Creates an ArrayType by specifying the data type of elements ({@code elementType}).\nThe field of {@code containsNull} is set to {@code true}.",
        "model_generated_comment": "Creates a new {@link ArrayType} with the given data type.\n\n@param elementType The data type to put into the new array.\n@return a new ArrayType"
    },
    {
        "id": 847,
        "code_snippet": "public void registerGateway(String key, Gateway gateway) {\n    gateways.put(key, gateway);\n  }",
        "human_comment": "The \"GatewayFactory\" class is responsible for providing different external services in this\nGateway design pattern example. It allows clients to register and retrieve specific gateways\nbased on unique keys.",
        "model_generated_comment": "Register a gateway using the supplied key.\n\n@param key the key to register."
    },
    {
        "id": 848,
        "code_snippet": "public ShuffleSorterIterator getSortedIterator() {\n    int offset = 0;\n    if (useRadixSort) {\n      offset = RadixSort.sort(\n        array, pos,\n        PackedRecordPointer.PARTITION_ID_START_BYTE_INDEX,\n        PackedRecordPointer.PARTITION_ID_END_BYTE_INDEX, false, false);\n    } else {\n      MemoryBlock unused = new MemoryBlock(\n        array.getBaseObject(),\n        array.getBaseOffset() + pos * 8L,\n        (array.size() - pos) * 8L);\n      LongArray buffer = new LongArray(unused);\n      Sorter<PackedRecordPointer, LongArray> sorter =\n        new Sorter<>(new ShuffleSortDataFormat(buffer));\n\n      sorter.sort(array, 0, pos, SORT_COMPARATOR);\n    }\n    return new ShuffleSorterIterator(pos, array, offset);\n  }",
        "human_comment": "Return an iterator over record pointers in sorted order.",
        "model_generated_comment": "Get a ShuffleSorterIterator from the PackedRecordPointer.\n\n@param array the array to get sorted, may be {@code null}."
    },
    {
        "id": 849,
        "code_snippet": "private Builder(Mode mode, String name, DataType dataType) {\n      this.mode = mode;\n      this.name = name;\n      this.dataType = dataType;\n    }",
        "human_comment": "An enum representing procedure parameter modes.",
        "model_generated_comment": "Creates a Builder for the specified mode and data type.\n\n@param mode the mode to build, may be {@code null}."
    },
    {
        "id": 850,
        "code_snippet": "public static void assertEquals(Character expected, char actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Character) actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "<em>Assert</em> that {@link expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied\n{@code message}.\n\n@since 5.4"
    },
    {
        "id": 851,
        "code_snippet": "public int storeData(Data data) {\n    var shardId = allocateShard(data);\n    lookupMap.put(data.getKey(), shardId);\n    var shard = shardMap.get(shardId);\n    shard.storeData(data);\n    LOGGER.info(data + \" is stored in Shard \" + shardId);\n    return shardId;\n  }",
        "human_comment": "ShardManager with lookup strategy. In this strategy the sharding logic implements a map that\nroutes a request for data to the shard that contains that data by using the shard key.",
        "model_generated_comment": "Store data in a shard.\n\n@param data The data to store, may be {@code null}."
    },
    {
        "id": 852,
        "code_snippet": "public TempDirectory(JupiterConfiguration configuration) {\n\t\tthis.configuration = configuration;\n\t}",
        "human_comment": "{@code TempDirectory} is a JUnit Jupiter extension that creates and cleans\nup temporary directories if a field in a test class or a parameter in a\ntest class constructor, lifecycle method, or test method is annotated with\n{@code @TempDir}.\n\n<p>Consult the Javadoc for {@link TempDir} for details on the contract.\n\n@since 5.4\n@see TempDir @TempDir\n@see Files#createTempDirectory",
        "model_generated_comment": "Create a new {@link TempDirectory} with the specified configuration.\n\n@param configuration the configuration; never {@code null}\n@return a new TempDirectory"
    },
    {
        "id": 853,
        "code_snippet": "public static void main(String[] args) {\n    SparkConf conf = new SparkConf().setAppName(\"Java Collaborative Filtering Example\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    String path = \"data/mllib/als/test.data\";\n    JavaRDD<String> data = jsc.textFile(path);\n    JavaRDD<Rating> ratings = data.map(s -> {\n      String[] sarray = s.split(\",\");\n      return new Rating(Integer.parseInt(sarray[0]),\n        Integer.parseInt(sarray[1]),\n        Double.parseDouble(sarray[2]));\n    });\n\n    int rank = 10;\n    int numIterations = 10;\n    MatrixFactorizationModel model = ALS.train(JavaRDD.toRDD(ratings), rank, numIterations, 0.01);\n\n    JavaRDD<Tuple2<Object, Object>> userProducts =\n      ratings.map(r -> new Tuple2<>(r.user(), r.product()));\n    JavaPairRDD<Tuple2<Integer, Integer>, Double> predictions = JavaPairRDD.fromJavaRDD(\n      model.predict(JavaRDD.toRDD(userProducts)).toJavaRDD()\n          .map(r -> new Tuple2<>(new Tuple2<>(r.user(), r.product()), r.rating()))\n    );\n    JavaRDD<Tuple2<Double, Double>> ratesAndPreds = JavaPairRDD.fromJavaRDD(\n        ratings.map(r -> new Tuple2<>(new Tuple2<>(r.user(), r.product()), r.rating())))\n      .join(predictions).values();\n    double MSE = ratesAndPreds.mapToDouble(pair -> {\n      double err = pair._1() - pair._2();\n      return err * err;\n    }).mean();\n    System.out.println(\"Mean Squared Error = \" + MSE);\n\n    model.save(jsc.sc(), \"target/tmp/myCollaborativeFilter\");\n    MatrixFactorizationModel sameModel = MatrixFactorizationModel.load(jsc.sc(),\n      \"target/tmp/myCollaborativeFilter\");\n\n    jsc.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data\nBuild the recommendation model using ALS\nEvaluate the model on rating data\nSave and load model\n$example off$",
        "model_generated_comment": "$example on$\n$example off$"
    },
    {
        "id": 854,
        "code_snippet": "public void setConfigurableField(String configurableField) {\n        this.configurableField = configurableField;\n    }",
        "human_comment": "A field that can be configured in the Wagon\n\n@component.configuration default=\"configurableField\"",
        "model_generated_comment": "Set configurable field for configurable fields.\n\n@param configurableField the field to set, may be {@code null}."
    },
    {
        "id": 855,
        "code_snippet": "public InternalRow copy() {\n    GenericInternalRow row = new GenericInternalRow(numFields);\n    for (int i = 0; i < numFields(); i++) {\n      if (isNullAt(i)) {\n        row.setNullAt(i);\n      } else {\n        DataType dt = data.getChild(i).dataType();\n        PhysicalDataType pdt = PhysicalDataType.apply(dt);\n        if (pdt instanceof PhysicalBooleanType) {\n          row.setBoolean(i, getBoolean(i));\n        } else if (pdt instanceof PhysicalByteType) {\n          row.setByte(i, getByte(i));\n        } else if (pdt instanceof PhysicalShortType) {\n          row.setShort(i, getShort(i));\n        } else if (pdt instanceof PhysicalIntegerType) {\n          row.setInt(i, getInt(i));\n        } else if (pdt instanceof PhysicalLongType) {\n          row.setLong(i, getLong(i));\n        } else if (pdt instanceof PhysicalFloatType) {\n          row.setFloat(i, getFloat(i));\n        } else if (pdt instanceof PhysicalDoubleType) {\n          row.setDouble(i, getDouble(i));\n        } else if (pdt instanceof PhysicalStringType) {\n          row.update(i, getUTF8String(i).copy());\n        } else if (pdt instanceof PhysicalBinaryType) {\n          row.update(i, getBinary(i));\n        } else if (pdt instanceof PhysicalDecimalType t) {\n          row.setDecimal(i, getDecimal(i, t.precision(), t.scale()), t.precision());\n        } else if (pdt instanceof PhysicalStructType t) {\n          row.update(i, getStruct(i, t.fields().length).copy());\n        } else if (pdt instanceof PhysicalArrayType) {\n          row.update(i, getArray(i).copy());\n        } else if (pdt instanceof PhysicalMapType) {\n          row.update(i, getMap(i).copy());\n        } else {\n          throw new RuntimeException(\"Not implemented. \" + dt);\n        }\n      }\n    }\n    return row;\n  }",
        "human_comment": "Revisit this. This is expensive. This is currently only used in test paths.",
        "model_generated_comment": "Creates a new {@code InternalRow} with the given num fields.\n\n@param numFields the num fields to copy\n@return a new InternalRow"
    },
    {
        "id": 856,
        "code_snippet": "public AlbumPage changeAlbumRating(String albumRating) {\n    var albumRatingInputTextField = (HtmlTextInput) page.getElementById(\"albumRating\");\n    albumRatingInputTextField.setText(albumRating);\n    return this;\n  }",
        "human_comment": "Sets the album rating input text field\n\n@param albumRating the new album rating value to set\n@return {@link AlbumPage}",
        "model_generated_comment": "Change the album rating input text field.\n\n@param albumRating The album rating to change.\n@return {@link AlbumPage}"
    },
    {
        "id": 857,
        "code_snippet": "public static <T> Result<T> error(Iterable<? extends ModelProblem> problems) {\n        return error(null, problems);\n    }",
        "human_comment": "Error with problems describing the cause\n\n@param problems",
        "model_generated_comment": "Returns an error with the given problems.\n\n@param problems the problems to check.\n@return an error if the problems are {@code null}."
    },
    {
        "id": 858,
        "code_snippet": "public static XmlNode merge(XmlNode dominant, XmlNode recessive) {\n        return merge(dominant, recessive, null);\n    }",
        "human_comment": "Convenience method to merge two XML nodes using default settings.",
        "model_generated_comment": "Merges two Xml nodes.\n\n@param dominant the dominant node, may be {@code null}."
    },
    {
        "id": 859,
        "code_snippet": "static boolean isCommentLine(String line) {\n        String s = line.trim();\n        // blank lines are also treated as comment lines\n        return s.isEmpty() || COMMENT_CHARS.indexOf(s.charAt(0)) >= 0;\n    }",
        "human_comment": "Tests whether a line is a comment, i.e. whether it starts with a comment\ncharacter.\n\n@param line the line\n@return a flag if this is a comment line",
        "model_generated_comment": "Returns whether a line is a comment line.\n\n@param line the line to check\n@return true if the line is comment"
    },
    {
        "id": 860,
        "code_snippet": "void selectClasspathResourcesWithFilePosition() {\n\t\t\tvar filePosition = FilePosition.from(12, 34);\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(null, filePosition));\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(\"\", filePosition));\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(\"    \", filePosition));\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(\"\\t\", filePosition));\n\n\t\t\tvar selector = selectClasspathResource(\"/foo/bar/spec.xml\", filePosition);\n\t\t\tassertEquals(\"foo/bar/spec.xml\", selector.getClasspathResourceName());\n\t\t\tassertEquals(FilePosition.from(12, 34), selector.getPosition().orElseThrow());\n\n\t\t\tselector = selectClasspathResource(\"A/B/C/spec.json\", filePosition);\n\t\t\tassertEquals(\"A/B/C/spec.json\", selector.getClasspathResourceName());\n\t\t\tassertEquals(filePosition, selector.getPosition().orElseThrow());\n\t\t}",
        "human_comment": "with unnecessary \"/\" prefix\nstandard use case",
        "model_generated_comment": "Unit tests for {@link ClasspathResourcesWithFilePosition()}.\n\n@since 5.0"
    },
    {
        "id": 861,
        "code_snippet": "public Count(Expression column, boolean isDistinct) {\n    this.input = column;\n    this.isDistinct = isDistinct;\n  }",
        "human_comment": "An aggregate function that returns the number of the specific row in a group.\n\n@since 3.2.0",
        "model_generated_comment": "Creates a Count of {@link Column} elements.\n\n@param column The column to count, may be {@code null}."
    },
    {
        "id": 862,
        "code_snippet": "public List<Artifact> getAttachedArtifacts() {\n        if (attachedArtifacts == null) {\n            attachedArtifacts = new ArrayList<>();\n        }\n        return Collections.unmodifiableList(attachedArtifacts);\n    }",
        "human_comment": "Returns a read-only list of the attached artifacts to this project.\n\n@return the attached artifacts of this project",
        "model_generated_comment": "Get the attached artifacts from the given collection.\n\n@param attachedArtifacts\n@return the list of artifacts"
    },
    {
        "id": 863,
        "code_snippet": "private String makeMethodKey(Method method) {\n        Class<?>[] parameterTypes = method.getParameterTypes();\n\n        StringBuilder methodKey = new StringBuilder(method.getName());\n\n        for (Class<?> parameterType : parameterTypes) {\n            // If the argument type is primitive then we want\n            // to convert our primitive type signature to the\n            // corresponding Object type so introspection for\n            // methods with primitive types will work correctly.\n            if (parameterType.isPrimitive()) {\n                if (parameterType.equals(Boolean.TYPE)) {\n                    methodKey.append(\"java.lang.Boolean\");\n                } else if (parameterType.equals(Byte.TYPE)) {\n                    methodKey.append(\"java.lang.Byte\");\n                } else if (parameterType.equals(Character.TYPE)) {\n                    methodKey.append(\"java.lang.Character\");\n                } else if (parameterType.equals(Double.TYPE)) {\n                    methodKey.append(\"java.lang.Double\");\n                } else if (parameterType.equals(Float.TYPE)) {\n                    methodKey.append(\"java.lang.Float\");\n                } else if (parameterType.equals(Integer.TYPE)) {\n                    methodKey.append(\"java.lang.Integer\");\n                } else if (parameterType.equals(Long.TYPE)) {\n                    methodKey.append(\"java.lang.Long\");\n                } else if (parameterType.equals(Short.TYPE)) {\n                    methodKey.append(\"java.lang.Short\");\n                }\n            } else {\n                methodKey.append(parameterType.getName());\n            }\n        }\n\n        return methodKey.toString();\n    }",
        "human_comment": "Make a methodKey for the given method using\nthe concatenation of the name and the\ntypes of the method parameters.",
        "model_generated_comment": "Make a method key for the given parameter type.\n\n@param method The method type to make the method key, must not be <code>null</code>."
    },
    {
        "id": 864,
        "code_snippet": "protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main_activity);\n\n        final RecyclerView list = findViewById(R.id.list);\n        list.setLayoutManager(new LinearLayoutManager(list.getContext()));\n        mCheeseAdapter = new CheeseAdapter();\n        list.setAdapter(mCheeseAdapter);\n\n        LoaderManager.getInstance(this).initLoader(LOADER_CHEESES, null, mLoaderCallbacks);\n    }",
        "human_comment": "Not very relevant to Room. This just shows data from {@link SampleContentProvider}.\n\n<p>Since the data is exposed through the ContentProvider, other apps can read and write the\ncontent in a similar manner to this.</p>",
        "model_generated_comment": "Create a new {@link RecyclerView} from the savedInstanceState."
    },
    {
        "id": 865,
        "code_snippet": "public String getVersion() {\n        return (version != null) ? version : \"\";\n    }",
        "human_comment": "Gets the effective version of the model.\n\n@return The effective version of the model or an empty string if unknown, never {@code null}.",
        "model_generated_comment": "Returns the version of the given version."
    },
    {
        "id": 866,
        "code_snippet": "public void testShow() {\n    Dataset<Row> df = spark.table(\"testData\");\n    df.show();\n    df.show(1000);\n  }",
        "human_comment": "This test case is intended ignored, but to make sure it compiles correctly",
        "model_generated_comment": "Determine if the test data is true.\n\n@param df The test data to check."
    },
    {
        "id": 867,
        "code_snippet": "protected void printErrors(C context, boolean showStackTrace, List<Logger.Entry> entries, Logger logger) {\n        if (logger instanceof AccumulatingLogger) {\n            logger = new SystemLogger(context.invokerRequest.stdErr().orElse(null));\n        }\n        logger.error(\"Error executing \" + context.invokerRequest.parserRequest().commandName() + \".\");\n        for (Logger.Entry entry : entries) {\n            if (showStackTrace) {\n                logger.log(entry.level(), entry.message(), entry.error());\n            } else {\n                logger.error(entry.message());\n                for (Throwable cause = entry.error();\n                        cause != null && cause != cause.getCause();\n                        cause = cause.getCause()) {\n                    logger.log(entry.level(), \"Caused by: \" + cause.getMessage());\n                }\n            }\n        }\n    }",
        "human_comment": "if accumulating logger passed, this is \"early failure\", swap logger for stdErr and use that to emit log\nthis is important message; many Maven IT assert for presence of this message",
        "model_generated_comment": "Prints errors to the supplied {@link SystemLogger}.\n\n@param context the context to print errors to, may be {@code null}."
    },
    {
        "id": 868,
        "code_snippet": "public TransportConf(String module, ConfigProvider conf) {\n    this.module = module;\n    this.conf = conf;\n    SPARK_NETWORK_IO_MODE_KEY = getConfKey(\"io.mode\");\n    SPARK_NETWORK_IO_PREFERDIRECTBUFS_KEY = getConfKey(\"io.preferDirectBufs\");\n    SPARK_NETWORK_IO_CONNECTIONTIMEOUT_KEY = getConfKey(\"io.connectionTimeout\");\n    SPARK_NETWORK_IO_CONNECTIONCREATIONTIMEOUT_KEY = getConfKey(\"io.connectionCreationTimeout\");\n    SPARK_NETWORK_IO_BACKLOG_KEY = getConfKey(\"io.backLog\");\n    SPARK_NETWORK_IO_NUMCONNECTIONSPERPEER_KEY =  getConfKey(\"io.numConnectionsPerPeer\");\n    SPARK_NETWORK_IO_SERVERTHREADS_KEY = getConfKey(\"io.serverThreads\");\n    SPARK_NETWORK_IO_CLIENTTHREADS_KEY = getConfKey(\"io.clientThreads\");\n    SPARK_NETWORK_IO_RECEIVEBUFFER_KEY = getConfKey(\"io.receiveBuffer\");\n    SPARK_NETWORK_IO_SENDBUFFER_KEY = getConfKey(\"io.sendBuffer\");\n    SPARK_NETWORK_SASL_TIMEOUT_KEY = getConfKey(\"sasl.timeout\");\n    SPARK_NETWORK_IO_MAXRETRIES_KEY = getConfKey(\"io.maxRetries\");\n    SPARK_NETWORK_IO_RETRYWAIT_KEY = getConfKey(\"io.retryWait\");\n    SPARK_NETWORK_IO_LAZYFD_KEY = getConfKey(\"io.lazyFD\");\n    SPARK_NETWORK_VERBOSE_METRICS = getConfKey(\"io.enableVerboseMetrics\");\n    SPARK_NETWORK_IO_ENABLETCPKEEPALIVE_KEY = getConfKey(\"io.enableTcpKeepAlive\");\n  }",
        "human_comment": "A central location that tracks all the settings we expose to users.",
        "model_generated_comment": "TODO: This is a test set for TCP connections.\n\n@param module the module to use, may be {@code null}."
    },
    {
        "id": 869,
        "code_snippet": "public Result run(Request request) {\n        return run(request, new JUnitCore());\n    }",
        "human_comment": "Run all the tests contained in <code>request</code>.\n\n@param request the request describing tests\n@return a {@link Result} describing the details of the test run and the failed tests.",
        "model_generated_comment": "Runs a test request.\n\n@param request The request to run.\n@return The test result."
    },
    {
        "id": 870,
        "code_snippet": "private void updateQueue(QueueTask qt) {\n    if (System.currentTimeMillis() - qt.order.createdTime >= this.queueTime) {\n      LOG.trace(ORDER_ID + \": Queue time for order over, failed..\", qt.order.id);\n      return;\n    } else if (qt.taskType.equals(TaskType.PAYMENT) && !qt.order.paid.equals(PaymentStatus.TRYING)\n        || qt.taskType.equals(TaskType.MESSAGING)\n            && (qt.messageType == 1 && !qt.order.messageSent.equals(MessageSent.NONE_SENT)\n                || qt.order.messageSent.equals(MessageSent.PAYMENT_FAIL)\n                || qt.order.messageSent.equals(MessageSent.PAYMENT_SUCCESSFUL))\n        || qt.taskType.equals(TaskType.EMPLOYEE_DB) && qt.order.addedToEmployeeHandle) {\n      LOG.trace(ORDER_ID + \": Not queueing task since task already done..\", qt.order.id);\n      return;\n    }\n    var list = queue.exceptionsList;\n    Thread t =\n        new Thread(\n            () -> {\n              Retry.Operation op =\n                  list1 -> {\n                    if (!list1.isEmpty()) {\n                      LOG.warn(\n                          ORDER_ID + \": Error in connecting to queue db, trying again..\",\n                          qt.order.id);\n                      throw list1.remove(0);\n                    }\n                    queue.add(qt);\n                    queueItems++;\n                    LOG.info(ORDER_ID + \": {}\" + \" task enqueued..\", qt.order.id, qt.getType());\n                    tryDoingTasksInQueue();\n                  };\n              Retry.HandleErrorIssue<QueueTask> handleError =\n                  (qt1, err) -> {\n                    if (qt1.taskType.equals(TaskType.PAYMENT)) {\n                      qt1.order.paid = PaymentStatus.NOT_DONE;\n                      sendPaymentFailureMessage(qt1.order);\n                      LOG.error(\n                          ORDER_ID + \": Unable to enqueue payment task,\" + \" payment failed..\",\n                          qt1.order.id);\n                    }\n                    LOG.error(\n                        ORDER_ID\n                            + \": Unable to enqueue task of type {}\"\n                            + \", trying to add to employee handle..\",\n                        qt1.order.id,\n                        qt1.getType());\n                    employeeHandleIssue(qt1.order);\n                  };\n              var r =\n                  new Retry<>(\n                      op,\n                      handleError,\n                      numOfRetries,\n                      retryDuration,\n                      e -> DatabaseUnavailableException.class.isAssignableFrom(e.getClass()));\n              try {\n                r.perform(list, qt);\n              } catch (Exception e1) {\n                LOG.error(DEFAULT_EXCEPTION_MESSAGE, e1);\n              }\n            });\n    t.start();\n  }",
        "human_comment": "since payment time is lesser than queuetime it would have already failed..\nadditional check not needed",
        "model_generated_comment": "Update queue time for the given task.\n\n@param qt the task to update\n@return the queue time"
    },
    {
        "id": 871,
        "code_snippet": "public static void main(String... args) {\n\t\tCommandFacade facade = newCommandFacade(CustomClassLoaderCloseStrategy.KEEP_OPEN);\n\t\tCommandResult<?> result = facade.run(args);\n\t\tSystem.exit(result.getExitCode());\n\t}",
        "human_comment": "The {@code ConsoleLauncher} is a stand-alone application for launching the\nJUnit Platform from the console.\n\n@since 1.0",
        "model_generated_comment": "Create a new {@link CommandFacade} with the supplied args.\n\n@param args the args to run; never {@code null}"
    },
    {
        "id": 872,
        "code_snippet": "public ExecutionPlanItem(MojoExecution mojoExecution) {\n        this.mojoExecution = mojoExecution;\n    }",
        "human_comment": "<p>\nWraps individual MojoExecutions, containing information about completion status and scheduling.\n</p>\n<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 3.0",
        "model_generated_comment": "Creates a new {@link ExecutionPlanItem}.\n\n@param mojoExecution The mojo execution plan."
    },
    {
        "id": 873,
        "code_snippet": "default NamedReference[] references() {\n    // SPARK-40398: Replace `Arrays.stream()...distinct()`\n    // to this for perf gain, the result order is not important.\n    Set<NamedReference> set = new HashSet<>();\n    for (Expression e : children()) {\n      Collections.addAll(set, e.references());\n    }\n    return set.toArray(EMPTY_NAMED_REFERENCE);\n  }",
        "human_comment": "List of fields or columns that are referenced by this expression.",
        "model_generated_comment": "Returns a list of references to the given array.\n\n@param references The names of the references to be searched.\n@return A list of names to search."
    },
    {
        "id": 874,
        "code_snippet": "public static void assertEquals(Object expected, Object actual) {\n        Assert.assertEquals(expected, actual);\n    }",
        "human_comment": "Asserts that two objects are equal. If they are not\nan AssertionFailedError is thrown.",
        "model_generated_comment": "Asserts that two objects are equal. If they are not they are considered equal."
    },
    {
        "id": 875,
        "code_snippet": "for (Callback callback : callbacks) {\n        if (callback instanceof NameCallback nc) {\n          logger.trace(\"SASL server callback: setting username\");\n          nc.setName(encodeIdentifier(secretKeyHolder.getSaslUser(secretKeyId)));\n        } else if (callback instanceof PasswordCallback pc) {\n          logger.trace(\"SASL server callback: setting password\");\n          pc.setPassword(encodePassword(secretKeyHolder.getSecretKey(secretKeyId)));\n        } else if (callback instanceof RealmCallback rc) {\n          logger.trace(\"SASL server callback: setting realm\");\n          rc.setText(rc.getDefaultText());\n        } else if (callback instanceof AuthorizeCallback ac) {\n          String authId = ac.getAuthenticationID();\n          String authzId = ac.getAuthorizationID();\n          ac.setAuthorized(authId.equals(authzId));\n          if (ac.isAuthorized()) {\n            ac.setAuthorizedID(authzId);\n          }\n          logger.debug(\"SASL Authorization complete, authorized set to {}\", ac.isAuthorized());\n        } else {\n          throw new UnsupportedCallbackException(callback, \"Unrecognized SASL DIGEST-MD5 Callback\");\n        }\n      }",
        "human_comment": "Implementation of javax.security.auth.callback.CallbackHandler for SASL DIGEST-MD5 mechanism.",
        "model_generated_comment": "Set the name of the callback.\n\n@param callback the callback instance\n@return The callback instance"
    },
    {
        "id": 876,
        "code_snippet": "static <T> Trampoline<T> done(final T result) {\n    return () -> result;\n  }",
        "human_comment": "Created a completed Trampoline.\n\n@param result Completed result\n@return Completed Trampoline",
        "model_generated_comment": "Creates a new Trampoline with the given result.\n\n@param result The result of the test.\n@return The result, never {@code null}"
    },
    {
        "id": 877,
        "code_snippet": "public void setFooter(List<String> footer) {\n        this.footer = footer;\n    }",
        "human_comment": "Set the comment footer.\n\n@param footer the footer to use",
        "model_generated_comment": "Set the {@link Footer} of the given list.\n\n@param footer The {@code footer} to set."
    },
    {
        "id": 878,
        "code_snippet": "public DefaultProjectsSelector(ProjectBuilder projectBuilder) {\n        this.projectBuilder = projectBuilder;\n    }",
        "human_comment": "Utility to select projects for a given set of pom.xml files.",
        "model_generated_comment": "Creates a {@link DefaultProjectsSelector} for the specified project."
    },
    {
        "id": 879,
        "code_snippet": "public void deleteAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        mDataSource.deleteAllUsers();\n\n        User dbUser = mDataSource.getUser();\n        assertNull(dbUser);\n    }",
        "human_comment": "Given that we have a user in the data source\nWhen we are deleting all users\nThe user is no longer in the data source",
        "model_generated_comment": "Delete all users in the data source.\n\n@param user The user to delete."
    },
    {
        "id": 880,
        "code_snippet": "public static boolean unaligned() {\n    return unaligned;\n  }",
        "human_comment": "@return true when running JVM is having sun's Unsafe package available in it and underlying\nsystem having unaligned-access capability.",
        "model_generated_comment": "Returns an unaligned {@link Unaligned} boolean.\n\n@param unaligned the boolean to check."
    },
    {
        "id": 881,
        "code_snippet": "public static ClassSource from(URI uri) {\n\t\tPreconditions.notNull(uri, \"URI must not be null\");\n\t\tPreconditions.condition(CLASS_SCHEME.equals(uri.getScheme()),\n\t\t\t() -> \"URI [\" + uri + \"] must have [\" + CLASS_SCHEME + \"] scheme\");\n\n\t\tString className = uri.getSchemeSpecificPart();\n\t\tFilePosition filePosition = null;\n\t\tint indexOfQuery = className.indexOf('?');\n\t\tif (indexOfQuery >= 0) {\n\t\t\tfilePosition = FilePosition.fromQuery(className.substring(indexOfQuery + 1)).orElse(null);\n\t\t\tclassName = className.substring(0, indexOfQuery);\n\t\t}\n\n\t\treturn ClassSource.from(className, filePosition);\n\t}",
        "human_comment": "Create a new {@code ClassSource} from the supplied {@link URI}.\nThe {@linkplain URI#getQuery() query} component of the {@code URI}, if\npresent, will be used to retrieve the {@link FilePosition} via\n{@link FilePosition#fromQuery(String)}. For example, line 42 and column\n13 can be referenced in class {@code org.example.MyType} via the following\nURI: {@code class:com.example.MyType?line=42&column=13}. The URI fragment,\nif present, will be ignored.\n\n@param uri the {@code URI} for the class source; never {@code null}\n@return a new {@code ClassSource}; never {@code null}\n{@code null}, if the scheme of the supplied {@code URI} is not equal\nto the {@link #CLASS_SCHEME}, or if the specified class name is empty\n@since 1.8\n@see #CLASS_SCHEME",
        "model_generated_comment": "Create a new {@link ClassSource} from the supplied URI.\n\n@param uri the URI to use; never {@code null}"
    },
    {
        "id": 882,
        "code_snippet": "private String convertPattern(final String pattern, boolean datanucleusFormat) {\n    String wStr;\n    if (datanucleusFormat) {\n      wStr = \"*\";\n    } else {\n      wStr = \".*\";\n    }\n    return pattern\n        .replaceAll(\"([^\\\\\\\\])%\", \"$1\" + wStr).replaceAll(\"\\\\\\\\%\", \"%\").replaceAll(\"^%\", wStr)\n        .replaceAll(\"([^\\\\\\\\])_\", \"$1.\").replaceAll(\"\\\\\\\\_\", \"_\").replaceAll(\"^_\", \".\");\n  }",
        "human_comment": "Convert a pattern containing JDBC catalog search wildcards into\nJava regex patterns.\n\n@param pattern input which may contain '%' or '_' wildcard characters, or\nthese characters escaped using {@link #getSearchStringEscape()}.\n@return replace %/_ with regex search characters, also handle escaped\ncharacters.\n\nThe datanucleus module expects the wildchar as '*'. The columns search on the\nother hand is done locally inside the hive code and that requires the regex wildchar\nformat '.*'  This is driven by the datanucleusFormat flag.",
        "model_generated_comment": "Convert a pattern to a datanucleus format.\n\n@param pattern The pattern to convert, may be {@code null}."
    },
    {
        "id": 883,
        "code_snippet": "private Stream<org.apache.maven.artifact.Artifact> getProjectArtifacts(MavenProject project) {\n        return Stream.concat(Stream.of(project.getArtifact()), project.getAttachedArtifacts().stream());\n    }",
        "human_comment": "Retrieve a stream of the project's artifacts.\nDo not include the POM artifact as the file can't be set anyway.",
        "model_generated_comment": "Creates a new {@link Stream} for the given project.\n\n@param project The project to put into the new Stream.\n@return a new Stream"
    },
    {
        "id": 884,
        "code_snippet": "public Request filterWith(Filter filter) {\n        return new FilterRequest(this, filter);\n    }",
        "human_comment": "Returns a Request that only contains those tests that should run when\n<code>filter</code> is applied\n\n@param filter The {@link Filter} to apply to this Request\n@return the filtered Request",
        "model_generated_comment": "Create a new Request with the supplied filter.\n\n@param filter The filter to add to the request.\n@return A new Request containing the filtered filter."
    },
    {
        "id": 885,
        "code_snippet": "public static List<ModuleSelector> selectModules(Set<String> moduleNames) {\n\t\tPreconditions.notNull(moduleNames, \"Module names must not be null\");\n\t\tPreconditions.containsNoNullElements(moduleNames, \"Individual module name must not be null\");\n\n\t\t// @formatter:off\n\t\treturn moduleNames.stream()\n\t\t\t\t.map(DiscoverySelectors::selectModule)\n\t\t\t\t// unmodifiable since this is a public, non-internal method\n\t\t\t\t.collect(toUnmodifiableList());\n\t\t// @formatter:on\n\t}",
        "human_comment": "Create a list of {@code ModuleSelectors} for the supplied module names.\n\n<p>The unnamed module is not supported.\n\n@param moduleNames the module names to select; never {@code null}, never\ncontaining {@code null} or blank\n@since 1.1\n@see ModuleSelector",
        "model_generated_comment": "<em>select</em> modules from the supplied list.\n\n@param moduleNames the module names to select; never {@code null}\n@return a list of {@linkplain DiscoverySelectors}.\n@since 5.4"
    }
]