[
    {
        "id": 0,
        "code_snippet": "public static void assertFalse(boolean condition) {\n        assertFalse(null, condition);\n    }",
        "human_comment": "Asserts that a condition is false. If it isn't it throws\nan AssertionFailedError.",
        "model_generated_comment": "p>Assert/p> that @code boolean is false."
    },
    {
        "id": 1,
        "code_snippet": "public final void assertEventsMatchLoosely(Condition<? super Event>... conditions) {\n\t\tPreconditions.notNull(conditions, \"conditions must not be null\");\n\t\tPreconditions.containsNoNullElements(conditions, \"conditions must not contain null elements\");\n\t\tassertEventsMatchLoosely(this.events, conditions);\n\t}",
        "human_comment": "Assert that all provided conditions are matched by an {@linkplain Event event}\ncontained in this {@code Events} object, regardless of order.\n\n<p>Note that this method performs a partial match. Thus, some events may\nnot match any of the provided conditions.\n\n<p>Conditions can be imported statically from {@link EventConditions}\nand {@link TestExecutionResultConditions}.\n\n<h4>Example</h4>\n\n<pre class=\"code\">\nexecutionResults.testEvents().assertEventsMatchLoosely(\nevent(test(\"exampleTestMethod\"), started()),\nevent(test(\"exampleTestMethod\"), finishedSuccessfully())\n);\n</pre>\n\n@param conditions the conditions to match against; never {@code null}\n@since 1.7\n@see #assertEventsMatchExactly(Condition...)\n@see #assertEventsMatchLooselyInOrder(Condition...)\n@see EventConditions\n@see TestExecutionResultConditions",
        "model_generated_comment": "p>Conditions/p>AssertEventsMatchLoosely(this.events, conditions). @param condition @code null if null if the event is matched with a null element if it's matched."
    },
    {
        "id": 2,
        "code_snippet": "private List<String> extractReactorBuildOrder(List<String> loadedLines) {\n        List<String> resultingLines = new LinkedList<>();\n        boolean start = false;\n        for (String line : loadedLines) {\n            if (start) {\n                if (line.startsWith(\"[INFO] -------------\")) {\n                    start = false;\n                } else if (!line.endsWith(\"[INFO] \")) {\n                    resultingLines.add(line);\n                }\n            } else {\n                if (line.startsWith(\"[INFO] Reactor Build Order:\")) {\n                    start = true;\n                }\n            }\n        }\n        return resultingLines;\n    }",
        "human_comment": "Extract the lines at the beginning of the Maven output:\n\n<pre>\n[INFO] Reactor Build Order:\n[INFO]\n[INFO] module-1\n[INFO] module-2\n[INFO] base-project\n[INFO]\n</pre>",
        "model_generated_comment": "@link ReactorBuildOrder @param loadedLines @return a LinkedList/@link Resulting Lines/#return the resulting Lines if a line starts with a loaded line, if the line ends with an empty line, or if it's a new line, the line will be merged with the new line."
    },
    {
        "id": 3,
        "code_snippet": "public T addSparkArg(String name, String value) {\n    SparkSubmitOptionParser validator = new ArgumentValidator(true);\n    if (validator.MASTER.equals(name)) {\n      setMaster(value);\n    } else if (validator.REMOTE.equals(name)) {\n      setRemote(value);\n    } else if (validator.PROPERTIES_FILE.equals(name)) {\n      setPropertiesFile(value);\n    } else if (validator.CONF.equals(name)) {\n      String[] vals = value.split(\"=\", 2);\n      setConf(vals[0], vals[1]);\n    } else if (validator.CLASS.equals(name)) {\n      setMainClass(value);\n    } else if (validator.JARS.equals(name)) {\n      builder.jars.clear();\n      for (String jar : value.split(\",\")) {\n        addJar(jar);\n      }\n    } else if (validator.FILES.equals(name)) {\n      builder.files.clear();\n      for (String file : value.split(\",\")) {\n        addFile(file);\n      }\n    } else if (validator.PY_FILES.equals(name)) {\n      builder.pyFiles.clear();\n      for (String file : value.split(\",\")) {\n        addPyFile(file);\n      }\n    } else {\n      validator.parse(Arrays.asList(name, value));\n      builder.userArgs.add(name);\n      builder.userArgs.add(value);\n    }\n    return self();\n  }",
        "human_comment": "Adds an argument with a value to the Spark invocation. If the argument name corresponds to\na known argument, the code validates that the argument actually expects a value, and throws\nan exception otherwise.\n<p>\nIt is safe to add arguments modified by other methods in this class (such as\n{@link #setMaster(String)} - the last invocation will be the one to take effect.\n<p>\nUse this method with caution. It is possible to create an invalid Spark command by passing\nunknown arguments to this method, since those are allowed for forward compatibility.\n\n@since 1.5.0\n@param name Name of argument to add.\n@param value Value of the argument.\n@return This launcher.",
        "model_generated_comment": "p>SparkSubmitOptionParser/p> if the @link jar is a jar file, it should be clear."
    },
    {
        "id": 4,
        "code_snippet": "public void zip() {\n    JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1, 2, 3, 4, 5));\n    JavaDoubleRDD doubles = rdd.mapToDouble(x -> 1.0 * x);\n    JavaPairRDD<Integer, Double> zipped = rdd.zip(doubles);\n    zipped.count();\n  }",
        "human_comment": "Try reading the output back as an object file",
        "model_generated_comment": "p>Assembles a @link /p> em>JavaRDD. a>/a> rdd@code doubles if it is a double."
    },
    {
        "id": 5,
        "code_snippet": "public String execute(Order order) {\n    var result = super.execute(order);\n    var name = order.getName();\n    if (name == null || name.isEmpty() || name.matches(\".*[^\\\\w|\\\\s]+.*\")) {\n      return result + \"Invalid name! \";\n    } else {\n      return result;\n    }\n  }",
        "human_comment": "Concrete implementation of filter. This filter checks if the input in the Name field is valid.\n(alphanumeric)",
        "model_generated_comment": "@link Executes the order. @param name the name of the order; if the order is empty, the name will be returned."
    },
    {
        "id": 6,
        "code_snippet": "default Map<String, String> init(SparkContext sc, PluginContext pluginContext) {\n    return Collections.emptyMap();\n  }",
        "human_comment": "Initialize the plugin.\n<p>\nThis method is called early in the initialization of the Spark driver. Explicitly, it is\ncalled before the Spark driver's task scheduler is initialized. This means that a lot\nof other Spark subsystems may yet not have been initialized. This call also blocks driver\ninitialization.\n<p>\nIt's recommended that plugins be careful about what operations are performed in this call,\npreferably performing expensive operations in a separate thread, or postponing them until\nthe application has fully started.\n\n@param sc The SparkContext loading the plugin.\n@param pluginContext Additional plugin-specific about the Spark application where the plugin\nis running.\n@return A map that will be provided to the {@link ExecutorPlugin#init(PluginContext,Map)}\nmethod.",
        "model_generated_comment": "Returns @link PluginContext. @param SparkContext sc/@link Collections."
    },
    {
        "id": 7,
        "code_snippet": "public static DynamicTest dynamicTest(String displayName, Executable executable) {\n\t\treturn new DynamicTest(displayName, null, executable);\n\t}",
        "human_comment": "Factory for creating a new {@code DynamicTest} for the supplied display\n@param executable the executable code block for the dynamic test;\nnever {@code null}\n@see #stream(Iterator, Function, ThrowingConsumer)",
        "model_generated_comment": "Returns a static DynamicTest. @param displayName, null, executable @code displayName @return a dynamicTest with a null display name. @example displayName is the name of the executable that is used to test the dynamic test."
    },
    {
        "id": 8,
        "code_snippet": "public void setProjects(List<MavenProject> projects) {\n        if (!projects.isEmpty()) {\n            MavenProject first = projects.get(0);\n            this.currentProject = ThreadLocal.withInitial(() -> first);\n            this.topLevelProject = projects.stream()\n                    .filter(project -> project.isExecutionRoot())\n                    .findFirst()\n                    .orElse(first);\n        } else {\n            this.currentProject = new ThreadLocal<>();\n            this.topLevelProject = null;\n        }\n        this.projects = projects;\n    }",
        "human_comment": "Plugin context keyed by project ({@link MavenProject#getId()}) and by plugin lookup key\n({@link PluginDescriptor#getPluginLookupKey()}). Plugin contexts itself are mappings of {@link String} keys to\n{@link Object} values.",
        "model_generated_comment": "p>MavenProject/p> if @link ThreadLocal is empty. @param projects.getEmpty() if the current project is empty if it's not already empty."
    },
    {
        "id": 9,
        "code_snippet": "void testGetColumnNumber() {\n        DefaultProblem problem = new DefaultProblem(null, null, null, -1, -1, null);\n        assertEquals(-1, problem.getColumnNumber());\n\n        problem = new DefaultProblem(null, null, null, -1, 42, null);\n        assertEquals(42, problem.getColumnNumber());\n\n        problem = new DefaultProblem(null, null, null, -1, Integer.MAX_VALUE, null);\n        assertEquals(Integer.MAX_VALUE, problem.getColumnNumber());\n\n        problem = new DefaultProblem(null, null, null, -1, Integer.MIN_VALUE, null);\n        assertEquals(Integer.MIN_VALUE, problem.getColumnNumber());\n    }",
        "human_comment": "this case is not specified, might also return -1",
        "model_generated_comment": "@code null @param null the number of columns in a given column. p>Assert/p> that the column number of a column is equal to the value of the column."
    },
    {
        "id": 10,
        "code_snippet": "public AssumptionViolatedException(Object value, Matcher<?> matcher) {\n        this(null, true, value, matcher);\n    }",
        "human_comment": "An assumption exception with the given <i>value</i> (String or\nThrowable) and an additional failing {@link Matcher}.\n\n@deprecated Please use {@link org.junit.AssumptionViolatedException} instead.",
        "model_generated_comment": "p>AssumptionViolatedException/p> if @code null is the value of the matcher. @param value, matcher The value of a matcher if the value is null."
    },
    {
        "id": 11,
        "code_snippet": "public List<Exception> validateAnnotatedClass(TestClass testClass) {\n        return NO_VALIDATION_ERRORS;\n    }",
        "human_comment": "Validates annotation on the given class.\n\n@param testClass that is being validated\n@return A list of exceptions. Default behavior is to return an empty list.\n\n@since 4.12",
        "model_generated_comment": "@link TestClass/@link Validate a class with a test class. @param testClass the class with which the test class is validated. @return a validated class if the class is not valid."
    },
    {
        "id": 12,
        "code_snippet": "public void run() {\n    var count = this.msgCount;\n\n    try {\n      while (count > 0) {\n        var statusMsg = \"Message-\" + count + \" submitted by \" + Thread.currentThread().getName();\n        this.submit(new Message(statusMsg));\n\n        LOGGER.info(statusMsg);\n\n        // reduce the message count.\n        count--;\n\n        // Make the current thread to sleep after every Message submission.\n        Thread.sleep(1000);\n      }\n    } catch (Exception e) {\n      LOGGER.error(e.getMessage());\n    }\n  }",
        "human_comment": "Each TaskGenerator thread will submit all the messages to the Queue. After every message\nsubmission TaskGenerator thread will sleep for 1 second.",
        "model_generated_comment": "@link MessageCount @param 0 Message count > 0 The current thread is to sleep after every Message submission. @return the current thread to sleep if a Message is submitted."
    },
    {
        "id": 13,
        "code_snippet": "protected void processGameLoop() {\n    var lastFrameTime = System.currentTimeMillis();\n    while (isGameRunning()) {\n      processInput();\n      var currentFrameTime = System.currentTimeMillis();\n      var elapsedTime = currentFrameTime - lastFrameTime;\n      update(elapsedTime);\n      lastFrameTime = currentFrameTime;\n      render();\n    }\n  }",
        "human_comment": "The variable-step game loop chooses a time step to advance based on how much real time passed\nsince the last frame. The longer the frame takes, the bigger steps the game takes. It always\nkeeps up with real time because it will take bigger and bigger steps to get there.",
        "model_generated_comment": "p>Also, if the @link system.currentTimeMillis() is called, the current frame time will be updated. @param lastFrameTime the last frame time elapsed in the system."
    },
    {
        "id": 14,
        "code_snippet": "private static boolean isValidContinuationByte(byte b) {\n     return b >= (byte) 0x80 && b <= (byte) 0xBF;\n  }",
        "human_comment": "Utility methods and constants for UTF-8 string validation.",
        "model_generated_comment": "@code byte b/code b> if a byte is not a valid byte, it will be discarded. @param byte the byte of the current byte. @return a static boolean with a value of 0x80."
    },
    {
        "id": 15,
        "code_snippet": "void testGatewayFactoryRegistrationAndRetrieval() {\n    Gateway serviceA = gatewayFactory.getGateway(\"ServiceA\");\n    Gateway serviceB = gatewayFactory.getGateway(\"ServiceB\");\n    Gateway serviceC = gatewayFactory.getGateway(\"ServiceC\");\n\n    assertTrue(\n        serviceA instanceof ExternalServiceA, \"ServiceA should be an instance of ExternalServiceA\");\n    assertTrue(\n        serviceB instanceof ExternalServiceB, \"ServiceB should be an instance of ExternalServiceB\");\n    assertTrue(\n        serviceC instanceof ExternalServiceC, \"ServiceC should be an instance of ExternalServiceC\");\n  }",
        "human_comment": "Check if the retrieved instances match their expected types",
        "model_generated_comment": "@link GatewayFactoryRegistrationAndRetrieval. @param serviceA instanceof ExternalServiceA, \"ServiceA should be an instance of ExternalServiceB\" p>Also, if you want to retrieve a service from external service, you need to create a new service."
    },
    {
        "id": 16,
        "code_snippet": "public Builder privateKeyPassword(String privateKeyPassword) {\n      this.privateKeyPassword = privateKeyPassword;\n      return this;\n    }",
        "human_comment": "Sets the private key password\n\n@param privateKeyPassword The password for the private key\n@return The builder object",
        "model_generated_comment": "@link PrivateKeyPassword @return the private keyPassword of a private keypassword. @param privateKeypassword = private KeyPassword."
    },
    {
        "id": 17,
        "code_snippet": "void metadataPath4(ExecutorHelper.Mode mode) {\n        ExecutorHelper helper = new HelperImpl(\n                mode,\n                mvn4ExecutorRequestBuilder().build().installationDirectory(),\n                userHome,\n                MavenExecutorTestSupport.EMBEDDED_MAVEN_EXECUTOR,\n                MavenExecutorTestSupport.FORKED_MAVEN_EXECUTOR);\n        String path = new ToolboxTool(helper).metadataPath(helper.executorRequest(), \"aopalliance\", \"someremote\");\n        assertTrue(path.endsWith(\"aopalliance\" + File.separator + \"maven-metadata-someremote.xml\"), \"path=\" + path);\n    }",
        "human_comment": "split repository: assert \"ends with\" as split may introduce prefixes",
        "model_generated_comment": "@link ExecutorHelper/@link MavenExecutorTestSupport. @param mode aopalliance mvn4/maven-metadata-someremote.xml> p>MAVEN_EXECUTOR/p>"
    },
    {
        "id": 18,
        "code_snippet": "private static String[] doCleanArgs(String[] args) {\n        List<String> cleaned = new ArrayList<>();\n\n        StringBuilder currentArg = null;\n\n        for (String arg : args) {\n            boolean addedToBuffer = false;\n\n            if (arg.startsWith(\"\\\"\")) {\n                if (currentArg != null) {\n                    cleaned.add(currentArg.toString());\n                }\n\n                currentArg = new StringBuilder(arg.substring(1));\n                addedToBuffer = true;\n            }\n\n            if (addedToBuffer && arg.endsWith(\"\\\"\")) {\n                if (!currentArg.isEmpty()) {\n                    currentArg.setLength(currentArg.length() - 1);\n                }\n\n                cleaned.add(currentArg.toString());\n\n                currentArg = null;\n                continue;\n            }\n\n            if (!addedToBuffer) {\n                if (currentArg != null) {\n                    currentArg.append(' ').append(arg);\n                } else {\n                    cleaned.add(arg);\n                }\n            }\n        }\n\n        if (currentArg != null) {\n            cleaned.add(currentArg.toString());\n        }\n\n        int cleanedSz = cleaned.size();\n\n        String[] cleanArgs;\n\n        if (cleanedSz == 0) {\n            cleanArgs = args;\n        } else {\n            cleanArgs = cleaned.toArray(new String[0]);\n        }\n\n        return cleanArgs;\n    }",
        "human_comment": "if we're in the process of building up another arg, push it and start over.\nthis is for the case: \"-Dfoo=bar \"-Dfoo2=bar two\" (note the first unterminated quote)\nstart building an argument here.\nthis has to be a separate \"if\" statement, to capture the case of: \"-Dfoo=bar\"\nif we're building an argument, keep doing so.\nif this is the case of \"-Dfoo=bar\", then we need to adjust the buffer.\nif we haven't added this arg to the buffer, and we ARE building an argument\nbuffer, then append it with a preceding space...again, not sure what else to\ndo other than collapse whitespace.\nNOTE: The case of a trailing quote is handled by nullifying the arg buffer.",
        "model_generated_comment": "p>If @link args/p> the current arg is empty, it will be removed. @param currentArgs the arg to be removed from the ArrayList. @return null if it is not null."
    },
    {
        "id": 19,
        "code_snippet": "public GraphOperation operation(String name) {\n    synchronized (nativeHandleLock) {\n      long oph = operation(nativeHandle, name);\n      if (oph == 0) {\n        return null;\n      }\n      return new GraphOperation(this, oph);\n    }\n  }",
        "human_comment": "Returns the operation (node in the Graph) with the provided name.\n\n<p>Or {@code null} if no such operation exists in the Graph.",
        "model_generated_comment": "Returns a @link GraphOperation. @param name of the Graph Operation. @return null if the name is not synchronized with the corresponding handleLock operation."
    },
    {
        "id": 20,
        "code_snippet": "public Object getConfiguration() {\n        return this.configuration;\n    } // -- Object getConfiguration()",
        "human_comment": "Get configuration to pass to all goals run in this phase.\n\n@return Object",
        "model_generated_comment": "p>Object getConfiguration/p>. @param this.configuration the configuration of the object."
    },
    {
        "id": 21,
        "code_snippet": "public int hashCode() {\n    return Murmur3_x86_32.hashUnsafeBytes(baseObject, baseOffset, sizeInBytes, 42);\n  }",
        "human_comment": "This `hashCode` computation could consume much processor time for large data.\nIf the computation becomes a bottleneck, we can use a light-weight logic; the first fixed bytes\nare used to compute `hashCode` (See `Vector.hashCode`).\nThe same issue exists in `UnsafeRow.hashCode`.",
        "model_generated_comment": "p>Murmur3_x86_32.hashCode/p>HashCode is a @link Murmur3 function."
    },
    {
        "id": 22,
        "code_snippet": "static long plusMillis(long time, long millis) {\n      return CLOCK.plusMillis0(time, millis);\n   }",
        "human_comment": "Return the specified opaque time-stamp plus the specified number of milliseconds.\n\n@param time an opaque time-stamp\n@param millis milliseconds to add\n@return a new opaque time-stamp",
        "model_generated_comment": "CLOCK.plusMillis(long time, long millis) p>CLOCK the number of milliseconds in a given time."
    },
    {
        "id": 23,
        "code_snippet": "private String escapeSlashes(String name) {\n        return SLASHES.matcher(name).replaceAll(\"_\");\n    }",
        "human_comment": "ganglia metric names can't contain slashes.",
        "model_generated_comment": "Returns the name of the @link SLASHES matcher."
    },
    {
        "id": 24,
        "code_snippet": "public KVStoreView<T> index(String name) {\n    this.index = Preconditions.checkNotNull(name);\n    return this;\n  }",
        "human_comment": "Iterates according to the given index.",
        "model_generated_comment": "Returns the name of the KVStoreView."
    },
    {
        "id": 25,
        "code_snippet": "protected static Size chooseOptimalSize(final Size[] choices, final int width, final int height) {\n    final int minSize = Math.max(Math.min(width, height), MINIMUM_PREVIEW_SIZE);\n    final Size desiredSize = new Size(width, height);\n\n    // Collect the supported resolutions that are at least as big as the preview Surface\n    boolean exactSizeFound = false;\n    final List<Size> bigEnough = new ArrayList<Size>();\n    final List<Size> tooSmall = new ArrayList<Size>();\n    for (final Size option : choices) {\n      if (option.equals(desiredSize)) {\n        // Set the size but don't return yet so that remaining sizes will still be logged.\n        exactSizeFound = true;\n      }\n\n      if (option.getHeight() >= minSize && option.getWidth() >= minSize) {\n        bigEnough.add(option);\n      } else {\n        tooSmall.add(option);\n      }\n    }\n\n    LOGGER.i(\"Desired size: \" + desiredSize + \", min size: \" + minSize + \"x\" + minSize);\n    LOGGER.i(\"Valid preview sizes: [\" + TextUtils.join(\", \", bigEnough) + \"]\");\n    LOGGER.i(\"Rejected preview sizes: [\" + TextUtils.join(\", \", tooSmall) + \"]\");\n\n    if (exactSizeFound) {\n      LOGGER.i(\"Exact size match found.\");\n      return desiredSize;\n    }\n\n    // Pick the smallest of those, assuming we found any\n    if (bigEnough.size() > 0) {\n      final Size chosenSize = Collections.min(bigEnough, new CompareSizesByArea());\n      LOGGER.i(\"Chosen size: \" + chosenSize.getWidth() + \"x\" + chosenSize.getHeight());\n      return chosenSize;\n    } else {\n      LOGGER.e(\"Couldn't find any suitable preview size\");\n      return choices[0];\n    }\n  }",
        "human_comment": "Given {@code choices} of {@code Size}s supported by a camera, chooses the smallest one whose\nwidth and height are at least as large as the minimum of both, or an exact match if possible.\n\n@param choices The list of sizes that the camera supports for the intended output class\n@param width The minimum desired width\n@param height The minimum desired height\n@return The optimal {@code Size}, or an arbitrary one if none were big enough",
        "model_generated_comment": "p>Sizes that are at least as big as the preview Surface /p>. @param width, x, minSize, maxSize> @code width/code height>. @return the size of the smallest of the supported resolutions, assuming we found any."
    },
    {
        "id": 26,
        "code_snippet": "static String quoteForCommandString(String s) {\n    StringBuilder quoted = new StringBuilder().append('\"');\n    for (int i = 0; i < s.length(); i++) {\n      int cp = s.codePointAt(i);\n      if (cp == '\"' || cp == '\\\\') {\n        quoted.appendCodePoint('\\\\');\n      }\n      quoted.appendCodePoint(cp);\n    }\n    return quoted.append('\"').toString();\n  }",
        "human_comment": "Quotes a string so that it can be used in a command string.\nBasically, just add simple escapes. E.g.:\noriginal single argument : ab \"cd\" ef\nafter: \"ab \\\"cd\\\" ef\"\n\nThis can be parsed back into a single argument by python's \"shlex.split()\" function.",
        "model_generated_comment": "p>StringBuilder/p>Create a new @codePoint. @param '' if a string is not quoted, it will not be quoted."
    },
    {
        "id": 27,
        "code_snippet": "private Saga() {\n    this.chapters = new ArrayList<>();\n  }",
        "human_comment": "Saga representation. Saga consists of chapters. Every ChoreographyChapter is executed by a\ncertain service.",
        "model_generated_comment": "p>Saga/p>Analyzes the @link ArrayList."
    },
    {
        "id": 28,
        "code_snippet": "public Events succeeded() {\n\t\treturn new Events(finishedEventsByStatus(Status.SUCCESSFUL), this.category + \" Successful\");\n\t}",
        "human_comment": "Get the succeeded {@link Events} contained in this {@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}",
        "model_generated_comment": "@link EventsByStatus/@link Successful. @param successFullEventsByCategory @return a failed event."
    },
    {
        "id": 29,
        "code_snippet": "Boolean validateProduct() {\n    try {\n      ResponseEntity<Boolean> productValidationResult =\n          restTemplateBuilder\n              .build()\n              .postForEntity(\n                  \"http://localhost:30302/product/validate\", \"validating product\", Boolean.class);\n      LOGGER.info(\"Product validation result: {}\", productValidationResult.getBody());\n      return productValidationResult.getBody();\n    } catch (ResourceAccessException | HttpClientErrorException e) {\n      LOGGER.error(\"Error communicating with product service: {}\", e.getMessage());\n      return false;\n    }\n  }",
        "human_comment": "Validates the product by calling the respective microservice.\n\n@return true if the product is valid, false otherwise.",
        "model_generated_comment": "@link ProductValidationResult @return a validated product. @param \"http://localhost:30302/product/validate\" p>Returns a product validation result that is not valid."
    },
    {
        "id": 30,
        "code_snippet": "public void initDb() {\n        // using an in-memory database because the information stored here disappears when the\n        // process is killed\n        mDatabase = Room.inMemoryDatabaseBuilder(ApplicationProvider.getApplicationContext(),\n                UsersDatabase.class)\n                // allowing main thread queries, just for testing\n                .allowMainThreadQueries()\n                .build();\n    }",
        "human_comment": "Test the implementation of {@link UserDao}",
        "model_generated_comment": "p>ApplicationProvider/p> is used to build an in-memory database."
    },
    {
        "id": 31,
        "code_snippet": "void testSmokeEveryThingThroughInjectionFramework() {\n\n    List<Class<? extends Tobacco>> tobaccos =\n        List.of(OldTobyTobacco.class, RivendellTobacco.class, SecondBreakfastTobacco.class);\n\n    // Configure the tobacco in the injection framework ...\n    // ... and create a new wizard with it\n    // Verify if the wizard is smoking the correct tobacco ...\n    tobaccos.forEach(\n        tobaccoClass -> {\n          final var injector =\n              Guice.createInjector(\n                  new AbstractModule() {\n                  });\n          final var guiceWizard = injector.getInstance(GuiceWizard.class);\n          guiceWizard.smoke();\n          String lastMessage = appender.getLastMessage();\n          assertEquals(\"GuiceWizard smoking \" + tobaccoClass.getSimpleName(), lastMessage);\n        });\n\n    // ... and nothing else is happening.\n    assertEquals(tobaccos.size(), appender.getLogSize());\n  }",
        "human_comment": "Test if the {@link GuiceWizard} smokes whatever instance of {@link Tobacco} is passed to him\nthrough the Guice google inject framework",
        "model_generated_comment": "Tests if the wizard is smoking the correct tobacco in the injection framework. @param a @link GuiceWizard/@link RivendellTobacco.class, secondbreakfasttobacco class, and if it is not, it will not be able to create a new wizard with it... and nothing else is happening."
    },
    {
        "id": 32,
        "code_snippet": "public Type getType() {\n        String type = dependency.getArtifact().getProperty(ArtifactProperties.TYPE, getExtension());\n        return session.requireType(type);\n    }",
        "human_comment": "{@return the type of the wrapped dependency}\nThe default implementation infers the type from the properties associated to the Eclipse Aether artifact.",
        "model_generated_comment": "@link ArtifactProperties.TYPE @param artifactproperties.type @return a type that is not a dependency."
    },
    {
        "id": 33,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaLogisticRegressionSummaryExample\")\n      .getOrCreate();\n\n    Dataset<Row> training = spark.read().format(\"libsvm\")\n      .load(\"data/mllib/sample_libsvm_data.txt\");\n\n    LogisticRegression lr = new LogisticRegression()\n      .setMaxIter(10)\n      .setRegParam(0.3)\n      .setElasticNetParam(0.8);\n\n    LogisticRegressionModel lrModel = lr.fit(training);\n\n    BinaryLogisticRegressionTrainingSummary trainingSummary = lrModel.binarySummary();\n\n    double[] objectiveHistory = trainingSummary.objectiveHistory();\n    for (double lossPerIteration : objectiveHistory) {\n      System.out.println(lossPerIteration);\n    }\n\n    Dataset<Row> roc = trainingSummary.roc();\n    roc.show();\n    roc.select(\"FPR\").show();\n    System.out.println(trainingSummary.areaUnderROC());\n\n    Dataset<Row> fMeasure = trainingSummary.fMeasureByThreshold();\n    double maxFMeasure = fMeasure.select(functions.max(\"F-Measure\")).head().getDouble(0);\n    double bestThreshold = fMeasure.where(fMeasure.col(\"F-Measure\").equalTo(maxFMeasure))\n      .select(\"threshold\").head().getDouble(0);\n    lrModel.setThreshold(bestThreshold);\n\n    spark.stop();\n  }",
        "human_comment": "$example on$\n$example off$\nLoad training data\nFit the model\n$example on$\nExtract the summary from the returned LogisticRegressionModel instance trained in the earlier\nexample\nObtain the loss per iteration.\nObtain the receiver-operating characteristic as a dataframe and areaUnderROC.\nGet the threshold corresponding to the maximum F-Measure and rerun LogisticRegression with\nthis selected threshold.\n$example off$",
        "model_generated_comment": "@link LogisticRegressionSummaryExample @param lossPerIteration : lossPerIntroduction @return a logisticregression-summary-example if a data set is created using a SparkSession."
    },
    {
        "id": 34,
        "code_snippet": "public void setArtifactFilter(ArtifactFilter artifactFilter) {\n        this.artifactFilter = artifactFilter;\n        this.artifacts = null;\n        this.artifactMap = null;\n    }",
        "human_comment": "Sets the scope filter to select the artifacts being exposed to the currently executed mojo.\n<strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not\npart of the public API. In particular, this method can be changed or deleted without prior notice and must not be\nused by plugins.\n\n@param artifactFilter The artifact filter, may be {@code null} to exclude all artifacts.",
        "model_generated_comment": "ArtifactFilter @link artifactfilter. p>Artifacts/p>Attachment/a> www.artifact.org/wp-content/href=\"https://docs.microsoft.com/docs/articles/index.cfm\">Analyze if a filter is used to filter /www>."
    },
    {
        "id": 35,
        "code_snippet": "public void putSource(String groupId, String artifactId, ModelSource source) {\n            mappedSources\n                    .computeIfAbsent(new GAKey(groupId, artifactId), k -> new HashSet<>())\n                    .add(source);\n            if (groupId != null) {\n                putSource(null, artifactId, source);\n            }\n        }",
        "human_comment": "Also  register the source under the null groupId",
        "model_generated_comment": "p>Assembles the source of the model. @param groupId, artifactId and @code modelSource/code model."
    },
    {
        "id": 36,
        "code_snippet": "public InterpreterApi create(@NonNull ByteBuffer byteBuffer, InterpreterApi.Options options) {\n    return InterpreterApi.create(byteBuffer, options);\n  }",
        "human_comment": "Constructs an {@link InterpreterApi} instance, using the specified model and options. The model\nwill be read from a {@code ByteBuffer}.\n\n@param byteBuffer A pre-trained TF Lite model, in binary serialized form. The ByteBuffer should\nnot be modified after the construction of an {@link InterpreterApi} instance. The {@code\nByteBuffer} can be either a {@code MappedByteBuffer} that memory-maps a model file, or a\ndirect {@code ByteBuffer} of nativeOrder() that contains the bytes content of a model.\n@param options A set of options for customizing interpreter behavior.\n@throws IllegalArgumentException if {@code byteBuffer} is not a {@code MappedByteBuffer} nor a\ndirect {@code ByteBuffer} of nativeOrder.",
        "model_generated_comment": "@link ByteBuffer/@link InterpreterApi.Options @param byteBuffer, interpreterapi.options/www.interpreterapi.com/create/create. p>An interpreter that creates a new interpreter."
    },
    {
        "id": 37,
        "code_snippet": "public Avg(Expression column, boolean isDistinct) {\n    this.input = column;\n    this.isDistinct = isDistinct;\n  }",
        "human_comment": "An aggregate function that returns the mean of all the values in a group.\n\n@since 3.3.0",
        "model_generated_comment": "@code isDistinct. @param column is a boolean expression of a column."
    },
    {
        "id": 38,
        "code_snippet": "public CartController(final ShoppingCartService shoppingCart) {\n    this.shoppingCartUseCase = shoppingCart;\n  }",
        "human_comment": "Constructs a CartController with the specified shopping cart service.\n\n@param shoppingCart The shopping cart service to handle cart operations.",
        "model_generated_comment": "@link ShoppingCartUseCase a shopping cart service."
    },
    {
        "id": 39,
        "code_snippet": "public KVStoreView<T> last(Object value) {\n    this.last = value;\n    return this;\n  }",
        "human_comment": "Stops iteration at the given value of the chosen index (inclusive).",
        "model_generated_comment": "Returns the value of a KVStoreView object."
    },
    {
        "id": 40,
        "code_snippet": "public XXH64(long seed) {\n    super();\n    this.seed = seed;\n  }",
        "human_comment": "xxHash64. A high quality and fast 64 bit hash code by Yann Colet and Mathias Westerdahl. The\nclass below is modelled like its Murmur3_x86_32 cousin.\n<p/>\nThis was largely based on the following (original) C and Java implementations:\nhttps://github.com/Cyan4973/xxHash/blob/master/xxhash.c\nhttps://github.com/OpenHFT/Zero-Allocation-Hashing/blob/master/src/main/java/net/openhft/hashing/XxHash_r39.java\nhttps://github.com/airlift/slice/blob/master/src/main/java/io/airlift/slice/XxHash64.java",
        "model_generated_comment": "XXH64 @link Long seed @param long seed the seed of a long seed. @return the seed if the seed is long."
    },
    {
        "id": 41,
        "code_snippet": "public ReactorBuildStatus(ProjectDependencyGraph projectDependencyGraph) {\n        this.projectDependencyGraph = projectDependencyGraph;\n    }",
        "human_comment": "Contains status information that is global to an entire reactor build.\n\n@since 3.0",
        "model_generated_comment": "ReactorBuildStatus(ProjectDependencyGraph)/a> p>Realizes a @link ReactStatement with a dependency graph."
    },
    {
        "id": 42,
        "code_snippet": "public static void assertEquals(Integer expected, Integer actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n\n@since 5.4",
        "model_generated_comment": "Asserts that the expected and actual values are equal."
    },
    {
        "id": 43,
        "code_snippet": "public boolean isUpdateRequired(RepositoryMetadata metadata, ArtifactRepository repository, File file) {\n        ArtifactRepositoryPolicy policy = metadata.getPolicy(repository);\n\n        if (!policy.isEnabled()) {\n            if (getLogger().isDebugEnabled()) {\n                getLogger()\n                        .debug(\"Skipping update check for \" + metadata.getKey() + \" (\" + file + \") from \"\n                                + repository.getId() + \" (\" + repository.getUrl() + \")\");\n            }\n\n            return false;\n        }\n\n        if (getLogger().isDebugEnabled()) {\n            getLogger()\n                    .debug(\"Determining update check for \" + metadata.getKey() + \" (\" + file + \") from \"\n                            + repository.getId() + \" (\" + repository.getUrl() + \")\");\n        }\n\n        if (file == null) {\n            return true;\n        }\n\n        Date lastCheckDate = readLastUpdated(metadata, repository, file);\n\n        return (lastCheckDate == null) || policy.checkOutOfDate(lastCheckDate);\n    }",
        "human_comment": "Here, we need to determine which policy to use. Release updateInterval will be used when\nthe metadata refers to a release artifact or meta-version, and snapshot updateInterval will be used when\nit refers to a snapshot artifact or meta-version.\nNOTE: Release metadata includes version information about artifacts that have been released, to allow\nmeta-versions like RELEASE and LATEST to resolve, and also to allow retrieval of the range of valid, released\nartifacts available.\nTODO throw something instead?",
        "model_generated_comment": "p>Skipping update check for \" + metadata.getKey() + \" + file + \") from \" + repository.getUrl() + )/p> @param repository metadata, artifactrepository repository, @link @return a boolean isUpdateRequired if (returns a log file) /a> if a Logger is enabled, the Logger will be able to check if the repository is updated  @code repository is  i +"
    },
    {
        "id": 44,
        "code_snippet": "public static RuleChain outerRule(TestRule outerRule) {\n        return emptyRuleChain().around(outerRule);\n    }",
        "human_comment": "Returns a {@code RuleChain} with a single {@link TestRule}. This method\nis the usual starting point of a {@code RuleChain}.\n\n@param outerRule the outer rule of the {@code RuleChain}.\n@return a {@code RuleChain} with a single {@link TestRule}.",
        "model_generated_comment": "Returns a @link RuleChain that contains a test rule."
    },
    {
        "id": 45,
        "code_snippet": "public static void assertEquals(char expected, Character actual, String message) {\n\t\tAssertEquals.assertEquals((Character) expected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 46,
        "code_snippet": "public Builder certChain(File certChain) {\n      this.certChain = certChain;\n      return this;\n    }",
        "human_comment": "Sets a X.509 certificate chain file in PEM format\n\n@param certChain The certificate chain file to use\n@return The builder object",
        "model_generated_comment": "p>Create a new certChain/p>."
    },
    {
        "id": 47,
        "code_snippet": "public void then(BuildPlan step) {\n        step.plan.forEach((k, v) -> plan.merge(k, v, this::merge));\n        aliases.putAll(step.aliases);\n    }",
        "human_comment": "add a follow-up plan to this one",
        "model_generated_comment": "p>BuildPlan/p>Always @link BuildPlan. @param k, v, this::merge."
    },
    {
        "id": 48,
        "code_snippet": "public SagaOrchestrator(Saga saga, ServiceDiscoveryService sd) {\n    this.saga = saga;\n    this.sd = sd;\n    this.state = new CurrentState();\n  }",
        "human_comment": "Create a new service to orchetrate sagas.\n\n@param saga saga to process\n@param sd service discovery @see {@link ServiceDiscoveryService}",
        "model_generated_comment": "p>SagaOrchestrator/p>. @param saga sd @code CurrentState/@code ServiceDiscoveryService. @return the current state of a Saga instance."
    },
    {
        "id": 49,
        "code_snippet": "public Builder enableTestEngineAutoRegistration(boolean enabled) {\n\t\t\tthis.engineAutoRegistrationEnabled = enabled;\n\t\t\treturn this;\n\t\t}",
        "human_comment": "Configure the auto-registration flag for test engines.\n\n<p>Defaults to {@code true}.\n\n@param enabled {@code true} if test engines should be automatically\nregistered\n@return this builder for method chaining",
        "model_generated_comment": "TestEngineAutoRegistrationEnabled @link TestEngine AutoRegistration Enabled. @param enabled a test engine to be registered. @return this if the test engine is registered."
    },
    {
        "id": 50,
        "code_snippet": "void expectedExceptionIsProcessedCorrectly() {\n\t\tEvents tests = executeTestsForClass(ExpectedExceptionTestCase.class);\n\n\t\ttests.assertStatistics(stats -> stats.started(4).succeeded(1).aborted(0).failed(3));\n\n\t\ttests.succeeded().assertThatEvents().have(\n\t\t\tevent(test(\"correctExceptionExpectedThrown\"), finishedSuccessfully()));\n\n\t\ttests.failed().assertThatEvents()//\n\t\t\t\t.haveExactly(1, //\n\t\t\t\t\tevent(test(\"noExceptionExpectedButThrown\"), //\n\t\t\t\t\t\tfinishedWithFailure(message(\"no exception expected\")))) //\n\t\t\t\t.haveExactly(1, //\n\t\t\t\t\tevent(test(\"exceptionExpectedButNotThrown\"), //\n\t\t\t\t\t\tfinishedWithFailure(instanceOf(AssertionError.class), //\n\t\t\t\t\t\t\tmessage(\"Expected test to throw an instance of java.lang.RuntimeException\")))) //\n\t\t\t\t.haveExactly(1, //\n\t\t\t\t\tevent(test(\"wrongExceptionExpected\"), //\n\t\t\t\t\t\tfinishedWithFailure(instanceOf(AssertionError.class), //\n\t\t\t\t\t\t\tmessage(value -> value.contains(\"Expected: an instance of java.io.IOException\")))));\n\t}",
        "human_comment": "Integration tests for {@link ExpectedExceptionSupport}.\n\n@since 5.0",
        "model_generated_comment": "@code java.lang.RuntimeException if an exception is encountered. @param testExceptionExceptionException thrown by a test case."
    },
    {
        "id": 51,
        "code_snippet": "public static String bytesToString(ByteBuffer b) {\n    return StandardCharsets.UTF_8.decode(b.slice()).toString();\n  }",
        "human_comment": "Convert the given byte buffer to a string. The resulting string can be\nconverted back to the same byte buffer through {@link #stringToBytes(String)}.",
        "model_generated_comment": "@link StandardCharsets.UTF_8.decode(ByteBuffer b)/. @return a string containing a b bytes to be encoded."
    },
    {
        "id": 52,
        "code_snippet": "public Set<Artifact> getArtifacts() {\n        if (artifacts == null) {\n            if (artifactFilter == null || resolvedArtifacts == null) {\n                artifacts = new LinkedHashSet<>();\n            } else {\n                artifacts = new LinkedHashSet<>(resolvedArtifacts.size() * 2);\n                for (Artifact artifact : resolvedArtifacts) {\n                    if (artifactFilter.include(artifact)) {\n                        artifacts.add(artifact);\n                    }\n                }\n            }\n        }\n        return artifacts;\n    }",
        "human_comment": "All dependencies that this project has, including transitive ones. Contents are lazily populated, so depending on\nwhat phases have run dependencies in some scopes won't be included. e.g. if only compile phase has run,\ndependencies with scope test won't be included.\n\n@return {@link Set} &lt; {@link Artifact} &gt;\n@see #getDependencyArtifacts() to get only direct dependencies",
        "model_generated_comment": "Sets LinkedHashSets with @link Artifacts."
    },
    {
        "id": 53,
        "code_snippet": "public Map<String, Lifecycle> getPhaseToLifecycleMap() {\n        return defaultLifeCycles.getPhaseToLifecycleMap();\n    }",
        "human_comment": "USED BY MAVEN HELP PLUGIN",
        "model_generated_comment": "p>Returns a @link LifeCycles/p>Map of a lifecycle."
    },
    {
        "id": 54,
        "code_snippet": "void resetForNewPage(int totalValuesInPage, long pageFirstRowIndex) {\n    this.valuesToReadInPage = totalValuesInPage;\n    this.rowId = pageFirstRowIndex;\n  }",
        "human_comment": "Must be called at the beginning of reading a new page.",
        "model_generated_comment": "p>Reset/p> for new pages. @param pageFirstRowIndex the first row of a new page."
    },
    {
        "id": 55,
        "code_snippet": "public ProjectBuilderRequestBuilder processPlugins(boolean processPlugins) {\n            this.processPlugins = processPlugins;\n            return this;\n        }",
        "human_comment": "Sets whether plugins should be processed during project building.\nWhen true, the builder will process plugin information which may include\nresolving plugin dependencies and executing plugin goals that participate in project building.\n\n@param processPlugins true if plugins should be processed, false otherwise\n@return this builder instance",
        "model_generated_comment": "@link ProjectBuilderRequestBuilder/@link ProcessPlugins. @param processPlugins a boolean request builder. @return this if the request is a process."
    },
    {
        "id": 56,
        "code_snippet": "public void preDestroyTestInstance(ExtensionContext context) {\n\t\tThrowableCollector throwableCollector = new ThrowableCollector(__ -> false);\n\t\tTestInstancePreDestroyCallback.preDestroyTestInstances(context,\n\t\t\ttestInstance -> closeFields(testInstance.getClass(), testInstance, throwableCollector));\n\t\tthrowableCollector.assertEmpty();\n\t}",
        "human_comment": "{@code AutoCloseExtension} is a JUnit Jupiter extension that closes resources\nif a field in a test class is annotated with {@link AutoClose @AutoClose}.\n\n<p>Consult the Javadoc for {@code @AutoClose} for details on the contract.\n\n@since 5.11\n@see AutoClose",
        "model_generated_comment": "TestInstancePreDestroyTestInstances() @link ThrowableCollector. @param testInstance.getClass() -> throwablecollector()"
    },
    {
        "id": 57,
        "code_snippet": "public static Expression getOperatorInstance(String s, Expression left, Expression right) {\n    return switch (s) {\n      case \"+\" -> new PlusExpression(left, right);\n      case \"-\" -> new MinusExpression(left, right);\n      default -> new MultiplyExpression(left, right);\n    };\n  }",
        "human_comment": "Returns correct expression based on the parameters.\n\n@param s input string\n@param left expression\n@param right expression\n@return expression",
        "model_generated_comment": "Returns a @link Expression. @param Expression s, Expression left, Expression right."
    },
    {
        "id": 58,
        "code_snippet": "public void safeLookup(Object keyBase, long keyOffset, int keyLength, Location loc, int hash) {\n    assert(longArray != null);\n\n    numKeyLookups++;\n\n    int pos = hash & mask;\n    int step = 1;\n    while (true) {\n      numProbes++;\n      if (longArray.get(pos * 2) == 0) {\n        // This is a new key.\n        loc.with(pos, hash, false);\n        return;\n      } else {\n        long stored = longArray.get(pos * 2 + 1);\n        if ((int) (stored) == hash) {\n          // Full hash code matches.  Let's compare the keys for equality.\n          loc.with(pos, hash, true);\n          if (loc.getKeyLength() == keyLength) {\n            final boolean areEqual = ByteArrayMethods.arrayEquals(\n              keyBase,\n              keyOffset,\n              loc.getKeyBase(),\n              loc.getKeyOffset(),\n              keyLength\n            );\n            if (areEqual) {\n              return;\n            }\n          }\n        }\n      }\n      pos = (pos + step) & mask;\n      step++;\n    }\n  }",
        "human_comment": "Looks up a key, and saves the result in provided `loc`.\n\nThis is a thread-safe version of `lookup`, could be used by multiple threads.",
        "model_generated_comment": "@link KeyLookups @param keyBase, long keyOffset, int keyLength, Location loc @return 0 if the key is equal to 0."
    },
    {
        "id": 59,
        "code_snippet": "public KVStoreView<T> max(long max) {\n    Preconditions.checkArgument(max > 0L, \"max must be positive.\");\n    this.max = max;\n    return this;\n  }",
        "human_comment": "Stops iteration after a number of elements has been retrieved.",
        "model_generated_comment": "@link KVStoreView @param max 0L, \"max must be positive\" @return this if the max value is not positive"
    },
    {
        "id": 60,
        "code_snippet": "public static String getClassName(TestPlan testPlan, TestIdentifier testIdentifier) {\n\t\treturn org.junit.platform.launcher.listeners.LegacyReportingUtils.getClassName(testPlan, testIdentifier);\n\t}",
        "human_comment": "Get the class name for the supplied {@link TestIdentifier} using the\nsupplied {@link TestPlan}.\n\n<p>This implementation attempts to find the closest test identifier with\na {@link ClassSource} by traversing the hierarchy upwards towards the\nroot starting with the supplied test identifier. In case no such source\nis found, it falls back to using the parent's\n{@linkplain TestIdentifier#getLegacyReportingName legacy reporting name}.\n\n@param testPlan the test plan that contains the {@code TestIdentifier};\nnever {@code null}\n@param testIdentifier the identifier to determine the class name for;\nnever {@code null}\n@see TestIdentifier#getLegacyReportingName",
        "model_generated_comment": "p>If a test plan is @code testIdentifier, the test plan should be /p> a jira.js.platform.launcher.listeners.LegacyReportingUtils."
    },
    {
        "id": 61,
        "code_snippet": "protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main_activity);\n\n        if (savedInstanceState == null) {\n            ProductListFragment fragment = new ProductListFragment();\n\n            getSupportFragmentManager().beginTransaction()\n                    .add(R.id.fragment_container, fragment, ProductListFragment.TAG).commit();\n        }\n    }",
        "human_comment": "Add product list fragment if this is first creation",
        "model_generated_comment": "@code null if the current state of the instance is null. @param null the current instance state."
    },
    {
        "id": 62,
        "code_snippet": "void testADependencies() {\n        final List<MavenProject> mavenProjects = stub.getUpstreamProjects(ProjectDependencyGraphStub.A, false);\n        assertEquals(0, mavenProjects.size());\n    }",
        "human_comment": "Tests the stub. Yeah, I know.",
        "model_generated_comment": "p>MavenProjects/p> @link ProjectDependencies/@link UpstreamProjectSize/PAGE/A>."
    },
    {
        "id": 63,
        "code_snippet": "protected void after() {\n        // do nothing\n    }",
        "human_comment": "Override to tear down your specific external resource.",
        "model_generated_comment": "p>Doesn't/p> a @link /. @param after() a protected void after()."
    },
    {
        "id": 64,
        "code_snippet": "public void setConfigurationParameters2(Map<String, String> keyValuePairs) {\n\t\t\tsetConfigurationParameters(keyValuePairs);\n\t\t}",
        "human_comment": "Implementation note: the @Option annotation is on a setter method to allow validation.",
        "model_generated_comment": "Sets the configuration parameters for the keyValuePairs."
    },
    {
        "id": 65,
        "code_snippet": "public ObjectField(String fieldName, VariantSchema schema) {\n      this.fieldName = fieldName;\n      this.schema = schema;\n    }",
        "human_comment": "Defines a valid shredding schema, as described in\nhttps://github.com/apache/parquet-format/blob/master/VariantShredding.md.\nA shredding schema contains a value and optional typed_value field.\nIf a typed_value is an array or struct, it recursively contain its own shredding schema for\nelements and fields, respectively.\nThe schema also contains a metadata field at the top level, but not in recursively shredded\nfields.",
        "model_generated_comment": "p>An @link VariantSchema /p> if a field is a schema, it should be a valid field."
    },
    {
        "id": 66,
        "code_snippet": "void testWeapon() {\n    var weapon = factory.create(WeaponType.SWORD);\n    verifyWeapon(weapon, Sword.class);\n  }",
        "human_comment": "Testing {@link WeaponFactory} to produce a SWORD asserting that the Weapon is an instance of\n{@link Sword}",
        "model_generated_comment": "Tests if a weapon is a Sword."
    },
    {
        "id": 67,
        "code_snippet": "public ProjectBuildFailureException(String projectId, MojoFailureException cause) {\n        super(\"Build for project: \" + projectId + \" failed during execution of mojo.\", cause);\n\n        this.projectId = projectId;\n    }",
        "human_comment": "Exception which occurs when a normal (i.e. non-aggregator) mojo fails to\nexecute. In this case, the mojo failed while executing against a particular\nproject instance, so we can wrap the {@link MojoFailureException} with context\ninformation including projectId that caused the failure.",
        "model_generated_comment": "@link ProjectBuildFailureException. @param projectId the project Id of a project."
    },
    {
        "id": 68,
        "code_snippet": "void performTest() {\n    Retry.Operation op =\n        (l) -> {\n          if (!l.isEmpty()) {\n            throw l.remove(0);\n          }\n        };\n    Retry.HandleErrorIssue<Order> handleError = (o, e) -> {};\n    var r1 =\n        new Retry<>(\n            op,\n            handleError,\n            3,\n            30000,\n            e -> DatabaseUnavailableException.class.isAssignableFrom(e.getClass()));\n    var r2 =\n        new Retry<>(\n            op,\n            handleError,\n            3,\n            30000,\n            e -> DatabaseUnavailableException.class.isAssignableFrom(e.getClass()));\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    var arr1 =\n        new ArrayList<>(\n            List.of(new ItemUnavailableException(), new DatabaseUnavailableException()));\n    try {\n      r1.perform(arr1, order);\n    } catch (Exception e1) {\n      LOG.error(\"An exception occurred\", e1);\n    }\n    var arr2 =\n        new ArrayList<>(\n            List.of(new DatabaseUnavailableException(), new ItemUnavailableException()));\n    try {\n      r2.perform(arr2, order);\n    } catch (Exception e1) {\n      LOG.error(\"An exception occurred\", e1);\n    }\n    assertTrue(arr1.size() == 1 && arr2.isEmpty());\n  }",
        "human_comment": "r1 stops at ItemUnavailableException, r2 retries because it encounters\nDatabaseUnavailableException",
        "model_generated_comment": "@link Retry.Operation op/. @param handleErrorIssue/@link DatabaseUnavailableException.class.isAssignableFrom(e.getClass())/a> p>An exception occurred/p>"
    },
    {
        "id": 69,
        "code_snippet": "public MyDoubleSum() {\n    List<StructField> inputFields = new ArrayList<>();\n    inputFields.add(DataTypes.createStructField(\"inputDouble\", DataTypes.DoubleType, true));\n    _inputDataType = DataTypes.createStructType(inputFields);\n\n    List<StructField> bufferFields = new ArrayList<>();\n    bufferFields.add(DataTypes.createStructField(\"bufferDouble\", DataTypes.DoubleType, true));\n    _bufferSchema = DataTypes.createStructType(bufferFields);\n\n    _returnDataType = DataTypes.DoubleType;\n  }",
        "human_comment": "An example {@link UserDefinedAggregateFunction} to calculate the sum of a\n{@link org.apache.spark.sql.types.DoubleType} column.",
        "model_generated_comment": "p>DataTypes.createStructField/p>. @param inputDoubleType @code ArrayList ArraySum. @return data types that are used by data types to create a single structure."
    },
    {
        "id": 70,
        "code_snippet": "public static Constant<String> create(Scope scope, String data, Charset charset) {\n    try (Tensor<String> value = Tensor.create(data.getBytes(charset), String.class)) {\n      return createWithTensor(scope, value);\n    }\n  }",
        "human_comment": "Creates a {@code String} constant using a specified encoding.\n\n@param scope is a scope used to add the underlying operation.\n@param charset The encoding from String to bytes.\n@param data The string to put into the new constant.\n@return a string constant",
        "model_generated_comment": "Creates a new Tensor with @link String. @param scope scope charset the scope of the Tension."
    },
    {
        "id": 71,
        "code_snippet": "private void deleteParentIndex(Object key) {\n      if (hasNaturalParentIndex) {\n        for (NaturalKeys v : parentToChildrenMap.values()) {\n          if (v.remove(asKey(key)) != null) {\n            break;\n          }\n        }\n      }\n    }",
        "human_comment": "`v` can be empty after removing the natural key and we can remove it from\n`parentToChildrenMap`. However, `parentToChildrenMap` is a ConcurrentMap and such\nchecking and deleting can be slow.\nThis method is to delete one object with certain key, let's make it simple here.",
        "model_generated_comment": "@link parentToChildrenMap.values @param key the parent of a childs child's child."
    },
    {
        "id": 72,
        "code_snippet": "public static void assertArrayEquals(double[] expected, double[] actual, double delta) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, delta);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} double arrays are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.",
        "model_generated_comment": "Asserts that a @link expected array is equal. @param expected the expected and actual arrays are equal."
    },
    {
        "id": 73,
        "code_snippet": "void getUser(final LoadUserCallback callback) {\n        final WeakReference<LoadUserCallback> loadUserCallback = new WeakReference<>(callback);\n\n        // request the user on the I/O thread\n        mAppExecutors.diskIO().execute(() -> {\n            final User user = mUserDataSource.getUser();\n            // notify on the main thread\n            mAppExecutors.mainThread().execute(() -> {\n                final LoadUserCallback userCallback = loadUserCallback.get();\n                if (userCallback == null) {\n                    return;\n                }\n                if (user == null) {\n                    userCallback.onDataNotAvailable();\n                } else {\n                    mCachedUser = user;\n                    userCallback.onUserLoaded(mCachedUser);\n                }\n            });\n        });\n    }",
        "human_comment": "Get the user from the data source, cache it and notify via the callback that the user has\nbeen retrieved.\n\n@param callback callback that gets called when the user was retrieved from the data source.",
        "model_generated_comment": "@link LoadUserCallback/@link mAppExecutors.diskIO().executes the user on the main I/O thread. @param user if the user is not available. @return the user, if it is not, the user will be removed from the main thread."
    },
    {
        "id": 74,
        "code_snippet": "private String determineReactorFailureBehaviour(final CommandLine commandLine) {\n        if (commandLine.hasOption(CLIManager.FAIL_FAST)) {\n            return MavenExecutionRequest.REACTOR_FAIL_FAST;\n        } else if (commandLine.hasOption(CLIManager.FAIL_AT_END)) {\n            return MavenExecutionRequest.REACTOR_FAIL_AT_END;\n        } else if (commandLine.hasOption(CLIManager.FAIL_NEVER)) {\n            return MavenExecutionRequest.REACTOR_FAIL_NEVER;\n        } else {\n            return MavenExecutionRequest.REACTOR_FAIL_FAST;\n        }\n    }",
        "human_comment": "this is the default behavior.",
        "model_generated_comment": "@link MavenExecutionRequest/@link CLIManager/www.climanager.com>. @param commandLine if a Maven Execution Requires a ReactorFailureBehaviour to be notified of a failure. @return a re-run of the request if the request is rerun at the end of the command line if it is not redirected to a new command line"
    },
    {
        "id": 75,
        "code_snippet": "private static Method getPublicMethod(Class<?> clazz, String name, Class<?>... paramTypes) {\n        // if this class is public, then try to get it\n        if ((clazz.getModifiers() & Modifier.PUBLIC) != 0) {\n            try {\n                return clazz.getMethod(name, paramTypes);\n            } catch (NoSuchMethodException e) {\n                // If the class does not have the method, then neither its superclass\n                // nor any of its interfaces has it so quickly return null.\n                return null;\n            }\n        }\n\n        //  try the superclass\n        Class<?> superclazz = clazz.getSuperclass();\n\n        if (superclazz != null) {\n            Method superclazzMethod = getPublicMethod(superclazz, name, paramTypes);\n\n            if (superclazzMethod != null) {\n                return superclazzMethod;\n            }\n        }\n\n        // and interfaces\n        Class<?>[] interfaces = clazz.getInterfaces();\n\n        for (Class<?> anInterface : interfaces) {\n            Method interfaceMethod = getPublicMethod(anInterface, name, paramTypes);\n\n            if (interfaceMethod != null) {\n                return interfaceMethod;\n            }\n        }\n\n        return null;\n    }",
        "human_comment": "Looks up the method with specified name and signature in the first public\nsuperclass or implemented interface of the class.\n\n@param clazz      the class whose method is sought\n@param name       the name of the method\n@param paramTypes the classes of method parameters",
        "model_generated_comment": "p>If the class is public, then the method will be @code null. @param name, class name, paramTypes/p>. @return null if the class does not have a superclazzMethod; if it does not, it will return null."
    },
    {
        "id": 76,
        "code_snippet": "public static <V> V fail(String message, Throwable cause) {\n\t\tAssertionUtils.fail(message, cause);\n\t\treturn null; // appeasing the compiler: this line will never be executed.\n\t}",
        "human_comment": "<em>Fail</em> the test with the given failure {@code message} as well\nas the underlying {@code cause}.\n\n<p>See Javadoc for {@link #fail(String)} for an explanation of this method's\ngeneric return type {@code V}.",
        "model_generated_comment": "p>AssertionUtils.fail/p>This line will never be executed."
    },
    {
        "id": 77,
        "code_snippet": "public static void assertNotEquals(Double unexpected, double actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Double) actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4",
        "model_generated_comment": "Asserts that @code unexpected and/@code actual are equal. @param unexpected, double actual are not equal."
    },
    {
        "id": 78,
        "code_snippet": "public ColumnarMap(ColumnVector keys, ColumnVector values, int offset, int length) {\n    this.length = length;\n    this.keys = new ColumnarArray(keys, offset, length);\n    this.values = new ColumnarArray(values, offset, length);\n  }",
        "human_comment": "Map abstraction in {@link ColumnVector}.",
        "model_generated_comment": "@link ColumnarMap @param keys, ColumnVector values, offset, int length  @code ColumnarArray @return a columnar array with the values of the columns in the column."
    },
    {
        "id": 79,
        "code_snippet": "public static Map<String, Integer> map(String input) {\n    Map<String, Integer> wordCount = new HashMap<>();\n    String[] words = input.split(\"\\\\s+\");\n    for (String word : words) {\n      word = word.toLowerCase().replaceAll(\"[^a-z]\", \"\");\n      if (!word.isEmpty()) {\n        wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n      }\n    }\n    return wordCount;\n  }",
        "human_comment": "Splits a given input string into words and counts their occurrences.\n\n@param input The input string to be mapped.\n@return A map where keys are words and values are their respective counts.",
        "model_generated_comment": "p>Assembles a HashMap/p> with a @link Integer."
    },
    {
        "id": 80,
        "code_snippet": "public static void assertEquals(Short expected, Short actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.\n\n@since 5.4",
        "model_generated_comment": "Asserts that @code expected and /code actual are equal."
    },
    {
        "id": 81,
        "code_snippet": "public static Constant<Long> create(Scope scope, long[] data) {\n    return create(scope, data, Long.class);\n  }",
        "human_comment": "Creates a rank-1 constant of {@code long} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array.",
        "model_generated_comment": "Creates a new Constant with a long data scope. @param scope scope the scope of the object."
    },
    {
        "id": 82,
        "code_snippet": "public Filter intersect(final Filter second) {\n        if (second == this || second == ALL) {\n            return this;\n        }\n        final Filter first = this;\n        return new Filter() {\n\n            @Override\n            public String describe() {\n                return first.describe() + \" and \" + second.describe();\n            }\n        };\n    }",
        "human_comment": "Returns a new Filter that accepts the intersection of the tests accepted\nby this Filter and {@code second}",
        "model_generated_comment": "Returns a new Filter. @Override @link Filter. @param second Filter == second == ALL. @return a Filter with a description of the second filter."
    },
    {
        "id": 83,
        "code_snippet": "public int getNnapiErrno() {\n    checkNotClosed();\n    return getNnapiErrno(delegateHandle);\n  }",
        "human_comment": "Returns the latest error code returned by an NNAPI call or zero if NO calls to NNAPI failed.\nThe error code is reset when the delegate is associated with an <a\nhref=https://www.tensorflow.org/lite/api_docs/java/org/tensorflow/lite/Interpreter>interpreter</a>.\n\n<p>For details on NNAPI error codes see <a\nhref=\"https://developer.android.com/ndk/reference/group/neural-networks#resultcode\">the NNAPI\ndocumentation</a>.\n\n@throws IllegalStateException if the method is called after {@link #close() close}.",
        "model_generated_comment": "Returns a @link GetNnapiErrno from a delegate."
    },
    {
        "id": 84,
        "code_snippet": "void testAbortedExceptionInBeforeAll() {\n\t\tEngineExecutionResults results = executeTestsForClass(TestAbortedExceptionInBeforeAllTestCase.class);\n\n\t\tresults.containerEvents().assertStatistics(stats -> stats.aborted(1));\n\t\tresults.testEvents().assertStatistics(stats -> stats.started(0));\n\t}",
        "human_comment": "Integration tests that verify support for failed assumptions in the\n{@link JupiterTestEngine}.\n\n@since 5.4",
        "model_generated_comment": "TestAbortedExceptionInBeforeAllTestCase.class p>Test aborted exception @code /code @param stats -> stats.started()"
    },
    {
        "id": 85,
        "code_snippet": "public static Tensor<Float> create(float[][] data) {\n    return Tensor.create(data, Float.class);\n  }",
        "human_comment": "Creates a rank-2 tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array.",
        "model_generated_comment": "Creates a static Tensor using @link Float. @param data a float of a data float. @return a dynamic tensor with a class of data /."
    },
    {
        "id": 86,
        "code_snippet": "static void registerExtensionsFromExecutableParameters(ExtensionRegistrar registrar, Executable executable) {\n\t\tPreconditions.notNull(registrar, \"ExtensionRegistrar must not be null\");\n\t\tPreconditions.notNull(executable, \"Executable must not be null\");\n\n\t\tAtomicInteger index = new AtomicInteger();\n\n\t\t// @formatter:off\n\t\tArrays.stream(executable.getParameters())\n\t\t\t\t.map(parameter -> findRepeatableAnnotations(parameter, index.getAndIncrement(), ExtendWith.class))\n\t\t\t\t.flatMap(ExtensionUtils::streamDeclarativeExtensionTypes)\n\t\t\t\t.forEach(registrar::registerExtension);\n\t\t// @formatter:on\n\t}",
        "human_comment": "Register extensions using the supplied registrar from parameters in the\nsupplied {@link Executable} (i.e., a {@link java.lang.reflect.Constructor}\nor {@link java.lang.reflect.Method}) that are annotated with\n{@link ExtendWith @ExtendWith}.\n\n@param registrar the registrar with which to register the extensions; never {@code null}\n@param executable the constructor or method whose parameters should be searched; never {@code null}\n@since 5.8",
        "model_generated_comment": "p>ExecutableParameters/p>. @param registrar @code Executable. @formatter:on http://www.extensionregistrar.org/extensions/registerExtensionTypes /code ExtendWith.class/extendInteger/programExtensionRegistrar/executable/ProgramExtendFromExecuted/docs/index.html> wwwwww.exeex\u00e9cutableExecutionExe"
    },
    {
        "id": 87,
        "code_snippet": "static void mergeEnvPathList(Map<String, String> userEnv, String envKey, String pathList) {\n    if (!isEmpty(pathList)) {\n      String current = firstNonEmpty(userEnv.get(envKey), System.getenv(envKey));\n      userEnv.put(envKey, join(File.pathSeparator, current, pathList));\n    }\n  }",
        "human_comment": "Updates the user environment, appending the given pathList to the existing value of the given\nenvironment variable (or setting it if it hasn't yet been set).",
        "model_generated_comment": "p>Assembles a @link envPathList/p> userEnv/a>. @param pathList the pathList of the user Env."
    },
    {
        "id": 88,
        "code_snippet": "public Decimal getDecimal(int rowId, int precision, int scale) {\n    if (precision <= Decimal.MAX_INT_DIGITS()) {\n      return Decimal.createUnsafe(getInt(rowId), precision, scale);\n    } else if (precision <= Decimal.MAX_LONG_DIGITS()) {\n      return Decimal.createUnsafe(getLong(rowId), precision, scale);\n    } else {\n      byte[] bytes = getBinary(rowId);\n      BigInteger bigInteger = new BigInteger(bytes);\n      BigDecimal javaDecimal = new BigDecimal(bigInteger, scale);\n      return Decimal.apply(javaDecimal, precision, scale);\n    }\n  }",
        "human_comment": "copy and modify from WritableColumnVector",
        "model_generated_comment": "@link Decimal @param rowId, precision, scale. @return Decimal.Max_Long_DIGITS() if the row Id is int precision, int scale, and if it is not, it will be used to create a new decimal if a row is not int byte length, or if there is a javaDecimal with a precision greater than the bytelength of the row, if not more than the number of byte"
    },
    {
        "id": 89,
        "code_snippet": "protected void handleElectionInvokeMessage() {\n    if (!isLeader()) {\n      LOGGER.info(INSTANCE + localId + \"- Start election.\");\n      boolean electionResult = messageManager.sendElectionMessage(localId, String.valueOf(localId));\n      if (electionResult) {\n        LOGGER.info(INSTANCE + localId + \"- Succeed in election. Start leader notification.\");\n        leaderId = localId;\n        messageManager.sendLeaderMessage(localId, localId);\n        messageManager.sendHeartbeatInvokeMessage(localId);\n      }\n    }\n  }",
        "human_comment": "Process election invoke message. Send election message to all the instances with smaller ID. If\nany one of them is alive, do nothing. If no instance alive, send leader message to all the\nalive instance and restart heartbeat.",
        "model_generated_comment": "p>Succeed in election. Start leader notification/p>"
    },
    {
        "id": 90,
        "code_snippet": "static void reportAndClear(List<DiscoveryIssue> issues, DiscoveryIssueReporter reporter) {\n\t\tissues.forEach(reporter::reportIssue);\n\t\tissues.clear();\n\t}",
        "human_comment": "Report and clear the given list of {@link DiscoveryIssue}s using the\nsupplied {@link DiscoveryIssueReporter}.",
        "model_generated_comment": "Reports @link DiscoveryIssueReporter for each issue."
    },
    {
        "id": 91,
        "code_snippet": "public Executions debug() {\n\t\tdebug(System.out);\n\t\treturn this;\n\t}",
        "human_comment": "Print all executions to {@link System#out}.\n\n@return this {@code Executions} object for method chaining; never {@code null}",
        "model_generated_comment": "p>Debug()/p> @link System.out if the system is not working."
    },
    {
        "id": 92,
        "code_snippet": "static MethodFilter excludeMethodNamePatterns(List<String> patterns) {\n\t\treturn excludeMethodNamePatterns(patterns.toArray(new String[0]));\n\t}",
        "human_comment": "Create a new <em>exclude</em> {@link MethodFilter} based on the\n@see Class#getName()\n@see Method#getName()\n@see #excludeMethodNamePatterns(String...)\n@see #includeMethodNamePatterns(String...)",
        "model_generated_comment": "Returns @link MethodFilter that excludes the names of the patterns in the list. @param patterns the name of the pattern in which the pattern is located. @returns a method whose name is not included in a list."
    },
    {
        "id": 93,
        "code_snippet": "public static Transform bucket(int numBuckets, String... columns) {\n    NamedReference[] references = Arrays.stream(columns)\n      .map(Expressions::column)\n      .toArray(NamedReference[]::new);\n    return LogicalExpressions.bucket(numBuckets, references);\n  }",
        "human_comment": "Create a bucket transform for one or more columns.\n<p>\nThis transform represents a logical mapping from a value to a bucket id in [0, numBuckets)\nbased on a hash of the value.\n<p>\nThe name reported by transforms created with this method is \"bucket\".\n\n@param numBuckets the number of output buckets\n@param columns input columns for the bucket transform\n@return a logical bucket transform with name \"bucket\"",
        "model_generated_comment": "@code NamedReference[]] @param numBuckets, String... columns @return a list of names and references to a bucket."
    },
    {
        "id": 94,
        "code_snippet": "public boolean isSuccess() {\n      return result == ChapterResult.SUCCESS;\n    }",
        "human_comment": "the result for chapter is good.\n\n@return true if is good otherwise bad",
        "model_generated_comment": "Returns a boolean @link ChapterResult.SUCCESS if a Chapter is successful."
    },
    {
        "id": 95,
        "code_snippet": "public static Constant<Integer> create(Scope scope, int[] data) {\n    return create(scope, data, Integer.class);\n  }",
        "human_comment": "Creates a rank-1 constant of {@code int} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array.",
        "model_generated_comment": "Creates a new Constant from @link Integer."
    },
    {
        "id": 96,
        "code_snippet": "public MultiBoxTracker(final Context context) {\n    this.context = context;\n    for (final int color : COLORS) {\n      availableColors.add(color);\n    }\n\n    boxPaint.setColor(Color.RED);\n    boxPaint.setStyle(Style.STROKE);\n    boxPaint.setStrokeWidth(12.0f);\n    boxPaint.setStrokeCap(Cap.ROUND);\n    boxPaint.setStrokeJoin(Join.ROUND);\n    boxPaint.setStrokeMiter(100);\n\n    textSizePx =\n        TypedValue.applyDimension(\n            TypedValue.COMPLEX_UNIT_DIP, TEXT_SIZE_DIP, context.getResources().getDisplayMetrics());\n    borderedText = new BorderedText(textSizePx);\n  }",
        "human_comment": "A tracker wrapping ObjectTracker that also handles non-max suppression and matching existing\nobjects to new detections.",
        "model_generated_comment": "@link MultiBoxTracker. @param color : COLORS. @return a multiboxTracker with a COLOR based on the color of the corresponding box. @context : color of a box."
    },
    {
        "id": 97,
        "code_snippet": "private static Settings adaptSettings(MavenExecutionRequest request) {\n        File localRepo = request.getLocalRepositoryPath();\n        return new Settings(org.apache.maven.api.settings.Settings.newBuilder()\n                .localRepository(localRepo != null ? localRepo.getAbsolutePath() : null)\n                .interactiveMode(request.isInteractiveMode())\n                .offline(request.isOffline())\n                .proxies(request.getProxies().stream().map(Proxy::getDelegate).collect(Collectors.toList()))\n                .servers(request.getServers().stream().map(Server::getDelegate).collect(Collectors.toList()))\n                .mirrors(request.getMirrors().stream().map(Mirror::getDelegate).collect(Collectors.toList()))\n                .profiles(request.getProfiles().stream()\n                        .map(Profile::getDelegate)\n                        .map(SettingsUtilsV4::convertToSettingsProfile)\n                        .collect(Collectors.toList()))\n                .activeProfiles(request.getActiveProfiles())\n                .pluginGroups(request.getPluginGroups())\n                .build());\n    }",
        "human_comment": "Adapt a {@link MavenExecutionRequest} to a {@link Settings} object for use in the Maven core.\nWe want to make sure that what is ask for in the execution request overrides what is in the settings.\nThe CLI feeds into an execution request so if a particular value is present in the execution request\nthen we will take that over the value coming from the user settings.",
        "model_generated_comment": "p>MavenExecutionRequest/p>Returns a @link LocalRepositoryPath or http://docs.apache.maven.api.settings.Settings. @param localRepo the local repository path /a>. @return a new local repositorypath if the path is not defined in a local repository. @converts to a native repository if it is not  @conversions"
    },
    {
        "id": 98,
        "code_snippet": "public EventDispatcher() {\n    handlers = new HashMap<>();\n  }",
        "human_comment": "Handles the routing of {@link Event} messages to associated handlers. A {@link HashMap} is used\nto store the association between events and their respective handlers.",
        "model_generated_comment": "@link EventDispatcher/@link HashMap/>p>/p>Assert/P> that a hashmap is created for a given event."
    },
    {
        "id": 99,
        "code_snippet": "void testEqualReversed() {\n        ResolutionNode a2n = createResolutionNode(a2);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a2n, a2n, a1n);\n    }",
        "human_comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\na:2.0\na:1.0\n</pre>",
        "model_generated_comment": "p>Assert/p> that the @link ResolutionNode is a resolution node."
    },
    {
        "id": 100,
        "code_snippet": "public DefaultSettingsDecrypter(MavenSecDispatcher securityDispatcher) {\n        this.securityDispatcher = securityDispatcher;\n    }",
        "human_comment": "Decrypts passwords in the settings.\n\n@deprecated since 4.0.0",
        "model_generated_comment": "DefaultSettingsDecrypter @link MavenSecDispatcher."
    },
    {
        "id": 101,
        "code_snippet": "private void assertEvaluated(String value) {\n        assertNotNull(value);\n        assertTrue(value.length() > 0);\n        assertFalse(value.contains(\"${\"), value);\n    }\n}",
        "human_comment": "Verify that plugin configurations are subject to the parameter expression evaluator, in particular composite\nparameter types.\n\n@throws Exception in case of failure",
        "model_generated_comment": "p>Assert/p> that the value of the value is @code null. @param value the value that contains the value."
    },
    {
        "id": 102,
        "code_snippet": "public Service(ServiceDiscoveryService service) {\n    this.sd = service;\n  }",
        "human_comment": "Common abstraction class representing services. implementing a general contract @see {@link\nChoreographyChapter}",
        "model_generated_comment": "ServiceDiscoveryServiceService service @link Servicediscovery/@link DiscoveryServiceServiceService. p>This service is a service that is used to provide a discovery service."
    },
    {
        "id": 103,
        "code_snippet": "protected String getEnvironmentVariable(String name) {\n\t\treturn System.getenv(name);\n\t}",
        "human_comment": "Get the value of the named environment variable.\n\n<p>The default implementation delegates to\n{@link System#getenv(String)}. Can be overridden in a subclass for\ntesting purposes.",
        "model_generated_comment": "Returns the name of the environment variable. @param name @link System.getEnvironmentVariable"
    },
    {
        "id": 104,
        "code_snippet": "void getUser(final LoadUserCallback callback) {\n        final WeakReference<LoadUserCallback> loadUserCallback = new WeakReference<>(callback);\n\n        // request the user on the I/O thread\n        mAppExecutors.diskIO().execute(new Runnable() {\n                mAppExecutors.mainThread().execute(new Runnable() {\n                        if (user == null) {\n                            userCallback.onDataNotAvailable();\n                        } else {\n                            mCachedUser = user;\n                            userCallback.onUserLoaded(mCachedUser);\n                        }\n                    }\n                });\n            }",
        "human_comment": "Get the user from the data source, cache it and notify via the callback that the user has\nbeen retrieved.\n\n@param callback callback that gets called when the user was retrieved from the data source.",
        "model_generated_comment": "@link LoadUserCallback @param user on the I/O thread mAppExecutors.diskIO()."
    },
    {
        "id": 105,
        "code_snippet": "@Override public void update(MutableAggregationBuffer buffer, Row input) {\n    if (!input.isNullAt(0)) {\n      if (buffer.isNullAt(0)) {\n        buffer.update(0, input.getDouble(0));\n      } else {\n        Double newValue = input.getDouble(0) + buffer.getDouble(0);\n        buffer.update(0, newValue);\n      }\n    }\n  }",
        "human_comment": "This input Row only has a single column storing the input value in Double.\nWe only update the buffer when the input value is not null.\nIf the buffer value (the intermediate result of the sum) is still null,\nwe set the input value to the buffer.\nOtherwise, we add the input value to the buffer value.",
        "model_generated_comment": "@Override @link  @param input.getDouble(0) if the input buffer is null if it is not null if a row is a null value. @return a new value if an input buffer has a value of null, if there is no value, and if no value exists, the value of the new value will be null."
    },
    {
        "id": 106,
        "code_snippet": "public String getArtifactMetadataPath(String gid, String aid, String version, String filename) {\n        return getArtifactMetadataPath(gid, aid, version, filename, null);\n    }",
        "human_comment": "Gets the path to a file in the local artifact directory. Note that the method does not check whether the returned\npath actually points to an existing file.\n\n@param gid      The group id, must not be <code>null</code>.\n@param aid      The artifact id, may be <code>null</code>.\n@param version  The artifact version, may be <code>null</code>.\n@param filename The filename to use, must not be <code>null</code>.\n@return The (absolute) path to the local artifact metadata, never <code>null</code>.",
        "model_generated_comment": "p>Assert/p> that the @link ArtifactMetadataPath is a gid, aid, version, filename, and filename of the object."
    },
    {
        "id": 107,
        "code_snippet": "public static void assertNotEquals(char unexpected, Character actual, String message) {\n\t\tAssertNotEquals.assertNotEquals((Character) unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "p>Assert/p> that @code unexpected and /code actual are equal."
    },
    {
        "id": 108,
        "code_snippet": "public static void assertArrayEquals(Object[] expected, Object[] actual) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} object arrays are deeply equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Nested float arrays are checked as in {@link #assertEquals(float, float)}.\n<p>Nested double arrays are checked as in {@link #assertEquals(double, double)}.\n\n@see Objects#equals(Object, Object)\n@see Arrays#deepEquals(Object[], Object[])",
        "model_generated_comment": "Asserts that a @link expected array is equal. @param expected the expected array, and the actual array are equal."
    },
    {
        "id": 109,
        "code_snippet": "public static InputLocation merge(InputLocation target, InputLocation source, Collection<Integer> indices) {\n        if (source == null) {\n            return target;\n        } else if (target == null) {\n            return source;\n        }\n\n        Map<Object, InputLocation> locations;\n        Map<Object, InputLocation> sourceLocations = source.locations;\n        Map<Object, InputLocation> targetLocations = target.locations;\n        if (sourceLocations == null) {\n            locations = targetLocations;\n        } else if (targetLocations == null) {\n            locations = sourceLocations;\n        } else {\n            locations = new LinkedHashMap<>();\n            for (int index : indices) {\n                InputLocation location;\n                if (index < 0) {\n                    location = sourceLocations.get(~index);\n                } else {\n                    location = targetLocations.get(index);\n                }\n                locations.put(locations.size(), location);\n            }\n        }\n\n        return new InputLocation(target.getLineNumber(), target.getColumnNumber(), target.getSource(), locations);\n    } // -- InputLocation merge( InputLocation, InputLocation, java.util.Collection )",
        "human_comment": "Merges the {@code source} location into the {@code target} location.\nThis method is used when the locations refer to lists and also merges the indices.\n\n@param target the target location\n@param source the source location\n@param indices the list of integers for the indices\n@return the merged location",
        "model_generated_comment": "@link InputLocation/@link LinkedHashMap/www.linkedhashmap.org/input-locations/index.html> p>If the target is a Linked HashMap, it should be able to be mapped to a specific location. @param target indices /p>"
    },
    {
        "id": 110,
        "code_snippet": "protected ExecutionCondition getExecutionCondition() {\n\t\treturn new EnabledIfSystemPropertyCondition();\n\t}",
        "human_comment": "Unit tests for {@link EnabledIfSystemPropertyCondition}.\n\n<p>Note that test method names MUST match the test method names in\n{@link EnabledIfSystemPropertyIntegrationTests}.\n\n@since 5.1",
        "model_generated_comment": "Returns a new EnabledIfSystemPropertyCondition @link ExecutionCondition."
    },
    {
        "id": 111,
        "code_snippet": "public static UTF8String fromBytes(byte[] bytes, int offset, int numBytes) {\n    if (bytes != null) {\n      return new UTF8String(bytes, BYTE_ARRAY_OFFSET + offset, numBytes);\n    } else {\n      return null;\n    }\n  }",
        "human_comment": "Creates an UTF8String from byte array, which should be encoded in UTF-8.\n\nNote: `bytes` will be hold by returned UTF8String.",
        "model_generated_comment": "@param offset offset bytes offset offset numBytes offset @code null @return a UTF8String from byte[] bytes to byte() bytes. @example offset is a number of bytes that can be used to represent a byte. @subtract a null byte if the offset is null."
    },
    {
        "id": 112,
        "code_snippet": "public static Resolution selectors(Set<? extends DiscoverySelector> selectors) {\n\t\t\tPreconditions.containsNoNullElements(selectors, \"selectors must not contain null elements\");\n\t\t\tPreconditions.notEmpty(selectors, \"selectors must not be empty\");\n\t\t\treturn new Resolution(emptySet(), selectors);\n\t\t}",
        "human_comment": "Factory for creating a resolution that contains the supplied\n{@link DiscoverySelector DiscoverySelectors}.\n\n@param selectors the resolved {@code DiscoverySelectors}; never\n{@code null} or empty\n@return an resolution that contains the supplied\n{@code DiscoverySelectors}; never {@code null}",
        "model_generated_comment": "Sets a set of @link DiscoverySelector> selectors."
    },
    {
        "id": 113,
        "code_snippet": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
        "human_comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp#main(String[])} throws an exception.",
        "model_generated_comment": "p>Application with @code Exception should not be executed."
    },
    {
        "id": 114,
        "code_snippet": "private static LinkedList<Method> getApplicables(List<Method> methods, Class<?>... classes) {\n        LinkedList<Method> list = new LinkedList<>();\n\n        for (Method method : methods) {\n            if (isApplicable(method, classes)) {\n                list.add(method);\n            }\n        }\n        return list;\n    }",
        "human_comment": "Returns all methods that are applicable to actual argument types.\n\n@param methods list of all candidate methods\n@param classes the actual types of the arguments\n@return a list that contains only applicable methods (number of\nformal and actual arguments matches, and argument types are assignable\nto formal types through a method invocation conversion).",
        "model_generated_comment": "LinkedListMethod> methods/?>. @param methods @code methods /code classes. @return a list of methods if a method is applicable to a class."
    },
    {
        "id": 115,
        "code_snippet": "void removeWithTypeSafetyAndPrimitiveValueType() {\n\t\t\tString key = \"enigma\";\n\t\t\tint value = 42;\n\t\t\tstore.put(namespace, key, value);\n\n\t\t\tint requiredInt = store.remove(namespace, key, int.class);\n\t\t\tassertEquals(value, requiredInt);\n\n\t\t\tstore.put(namespace, key, value);\n\t\t\tInteger requiredInteger = store.get(namespace, key, Integer.class);\n\t\t\tassertEquals(value, requiredInteger.intValue());\n\t\t}",
        "human_comment": "The fact that we can declare this as an int suffices for testing the required type.\nThe fact that we can declare this as an Integer suffices for testing the required type.",
        "model_generated_comment": "p>Assert/p> that @code enigma is a type-safety-and-primitive-value-type. @param namespace the namespace of the /code int."
    },
    {
        "id": 116,
        "code_snippet": "public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n\n        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;\n\n        return patterns.equals(other.patterns);\n    }",
        "human_comment": "make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter!",
        "model_generated_comment": "Returns a boolean containing the @link ArtifactFilter class."
    },
    {
        "id": 117,
        "code_snippet": "public static void assertEquals(char expected, Character actual) {\n\t\tAssertEquals.assertEquals((Character) expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 118,
        "code_snippet": "protected Statement methodInvoker(FrameworkMethod method, Object test) {\n        return new InvokeMethod(method, test);\n    }",
        "human_comment": "Returns a {@link Statement} that invokes {@code method} on {@code test}",
        "model_generated_comment": "p>Returns a @link InvokeMethod/p>. @param test method the method to invoke."
    },
    {
        "id": 119,
        "code_snippet": "public final ColumnarMap getMap(int rowId) {\n    if (isNullAt(rowId)) return null;\n    return new ColumnarMap(getChild(0), getChild(1), getArrayOffset(rowId), getArrayLength(rowId));\n  }",
        "human_comment": "`WritableColumnVector` puts the key array in the first child column vector, value array in the\nsecond child column vector, and puts the offsets and lengths in the current column vector.",
        "model_generated_comment": "@link ColumnarMap @param rowId the row ID of the column. @return null if the column ID is null"
    },
    {
        "id": 120,
        "code_snippet": "void grow(int neededSize) {\n    if (neededSize < 0) {\n      throw new SparkIllegalArgumentException(\n        \"_LEGACY_ERROR_TEMP_3198\",\n        Map.of(\"neededSize\", String.valueOf(neededSize)));\n    }\n    if (neededSize > ARRAY_MAX - totalSize()) {\n      throw new SparkIllegalArgumentException(\n        \"_LEGACY_ERROR_TEMP_3199\",\n        Map.of(\"neededSize\", String.valueOf(neededSize), \"arrayMax\", String.valueOf(ARRAY_MAX)));\n    }\n    final int length = totalSize() + neededSize;\n    if (buffer.length < length) {\n      // This will not happen frequently, because the buffer is re-used.\n      int newLength = length < ARRAY_MAX / 2 ? length * 2 : ARRAY_MAX;\n      int roundedSize = ByteArrayMethods.roundNumberOfBytesToNearestWord(newLength);\n      final byte[] tmp = new byte[roundedSize];\n      Platform.copyMemory(\n        buffer,\n        Platform.BYTE_ARRAY_OFFSET,\n        tmp,\n        Platform.BYTE_ARRAY_OFFSET,\n        totalSize());\n      buffer = tmp;\n      row.pointTo(buffer, buffer.length);\n    }\n  }",
        "human_comment": "Grows the buffer by at least neededSize and points the row to the buffer.",
        "model_generated_comment": "@code neededSize if the buffer is re-used. @param roundedSize the smallest bytes in the buffer."
    },
    {
        "id": 121,
        "code_snippet": "public Thread newThread(Runnable r) {\n            Thread newThread = new Thread(GROUP, r, \"resolver-\" + THREAD_NUMBER.getAndIncrement());\n            newThread.setDaemon(true);\n            newThread.setContextClassLoader(null);\n            return newThread;\n        }",
        "human_comment": "ThreadCreator for creating daemon threads with fixed ThreadGroup-name.",
        "model_generated_comment": "p>THREAD_NUMBER.getAndIncrement/p>. @param \"resolver-\" @return newThread @code r/code id=\"resolved-\"> a href=\"https://github.com/docs/resolvers/\">"
    },
    {
        "id": 122,
        "code_snippet": "private SettingsUtilsV4() {\n        // don't allow construction.\n    }",
        "human_comment": "Several convenience methods to handle settings",
        "model_generated_comment": "@link SettingsUtilsV4 // don't allow construction."
    },
    {
        "id": 123,
        "code_snippet": "public synchronized boolean wasSuccessful() {\n        return failureCount() == 0 && errorCount() == 0;\n    }",
        "human_comment": "Returns whether the entire test was successful or not.",
        "model_generated_comment": "Returns a synchronized boolean. @param failureCount() @link failedCount(). @return the failed count() if the failure count() is 0."
    },
    {
        "id": 124,
        "code_snippet": "public Options setAcceleratorName(String name) {\n      this.acceleratorName = name;\n      return this;\n    }",
        "human_comment": "Specifies the name of the target accelerator to be used by NNAPI. If this parameter is\nspecified the {@link #setUseNnapiCpu(boolean)} method won't have any effect.\n\n<p>Only effective on Android 10 (API level 29) and above.",
        "model_generated_comment": "Returns the name of the object. @param name @link name @return this object if the object is not already named."
    },
    {
        "id": 125,
        "code_snippet": "public static void assertEquals(Double expected, double actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Double) actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 126,
        "code_snippet": "public Builder convertDurationsTo(TimeUnit durationUnit) {\n            this.durationUnit = durationUnit;\n            return this;\n        }",
        "human_comment": "Convert durations to the given time unit.\n\n@param durationUnit a unit of time\n@return {@code this}",
        "model_generated_comment": "Converts the duration of a time unit to a duration unit. @param durationUnit @link DurationUnit @return the duration unit of the time unit."
    },
    {
        "id": 127,
        "code_snippet": "List<String> buildSparkSubmitArgs(boolean includeRemote) {\n    List<String> args = new ArrayList<>();\n    OptionParser parser = new OptionParser(false);\n    final boolean isSpecialCommand;\n\n    if (!userArgs.isEmpty()) {\n      parser.parse(userArgs);\n      isSpecialCommand = parser.isSpecialCommand;\n    } else {\n      isSpecialCommand = this.isSpecialCommand;\n    }\n\n    if (!allowsMixedArguments && !isSpecialCommand) {\n      checkArgument(appResource != null, \"Missing application resource.\");\n    }\n\n    if (verbose) {\n      args.add(parser.VERBOSE);\n    }\n\n    if (master != null) {\n      args.add(parser.MASTER);\n      args.add(master);\n    }\n\n    if (includeRemote && remote != null) {\n      args.add(parser.REMOTE);\n      args.add(remote);\n    }\n\n    if (deployMode != null) {\n      args.add(parser.DEPLOY_MODE);\n      args.add(deployMode);\n    }\n\n    if (appName != null) {\n      args.add(parser.NAME);\n      args.add(appName);\n    }\n\n    for (Map.Entry<String, String> e : conf.entrySet()) {\n      if (includeRemote ||\n           (!e.getKey().equalsIgnoreCase(\"spark.api.mode\") &&\n             !e.getKey().equalsIgnoreCase(\"spark.remote\"))) {\n        args.add(parser.CONF);\n        args.add(String.format(\"%s=%s\", e.getKey(), e.getValue()));\n      }\n    }\n\n    if (propertiesFile != null) {\n      args.add(parser.PROPERTIES_FILE);\n      args.add(propertiesFile);\n    }\n\n    if (isExample) {\n      jars.addAll(findExamplesJars());\n    }\n\n    if (!jars.isEmpty()) {\n      args.add(parser.JARS);\n      args.add(join(\",\", jars));\n    }\n\n    if (!files.isEmpty()) {\n      args.add(parser.FILES);\n      args.add(join(\",\", files));\n    }\n\n    if (!pyFiles.isEmpty()) {\n      args.add(parser.PY_FILES);\n      args.add(join(\",\", pyFiles));\n    }\n\n    if (isExample && !isSpecialCommand) {\n      checkArgument(mainClass != null, \"Missing example class name.\");\n    }\n\n    if (mainClass != null) {\n      args.add(parser.CLASS);\n      if (isRemote && \"1\".equals(getenv(\"SPARK_SCALA_SHELL\"))) {\n        args.add(\"org.apache.spark.sql.application.ConnectRepl\");\n      } else {\n        args.add(mainClass);\n      }\n    }\n\n    args.addAll(parsedArgs);\n\n    if (appResource != null) {\n      if (isRemote && \"1\".equals(getenv(\"SPARK_SCALA_SHELL\"))) {\n        args.add(\"connect-shell\");\n      } else {\n        args.add(appResource);\n      }\n    }\n\n    args.addAll(appArgs);\n\n    return args;\n  }",
        "human_comment": "If the user args array is not empty, we need to parse it to detect exactly what\nthe user is trying to run, so that checks below are correct.",
        "model_generated_comment": "p>Parser/p>Application/a> if @code null or /code>, args.param && @param remote &@param deployMode is a boolean parser for a given application. a href=\"https://www.spark.api.mode\">Also, if you want to add a new instance of the new version of @code nul/es"
    },
    {
        "id": 128,
        "code_snippet": "private static Map<String, String> splitCookieToken(String tokenStr) {\n    Map<String, String> map = new HashMap<String, String>();\n    StringTokenizer st = new StringTokenizer(tokenStr, COOKIE_ATTR_SEPARATOR);\n\n    while (st.hasMoreTokens()) {\n      String part = st.nextToken();\n      int separator = part.indexOf(COOKIE_KEY_VALUE_SEPARATOR);\n      if (separator == -1) {\n        LOG.error(\"Invalid token string {}\", MDC.of(LogKeys.TOKEN$.MODULE$, tokenStr));\n        return null;\n      }\n      String key = part.substring(0, separator);\n      String value = part.substring(separator + 1);\n      map.put(key, value);\n    }\n    return map;\n  }",
        "human_comment": "Splits the cookie token into attributes pairs.\n@param str input token.\n@return a map with the attribute pairs of the token if the input is valid.\nElse, returns null.",
        "model_generated_comment": "Returns a @code token containing a COOKIE_ATTR_SEPARATOR. @param tokenStr a value of 0 if the token is not a valid one. @return a map of the token if it is a new one."
    },
    {
        "id": 129,
        "code_snippet": "public Options setModelToken(String modelToken) {\n      this.modelToken = modelToken;\n      return this;\n    }",
        "human_comment": "Sets the token to be used to identify this model in the model compilation cache. If either\n{@code cacheDir} or {@code modelToken} parameters are unset NNAPI caching will be disabled.\n\n<p>Only effective on Android 10 (API level 29) and above.",
        "model_generated_comment": "p>ModelToken/p>. @param modelToken @code model Token. @return the model token if the model token is not available."
    },
    {
        "id": 130,
        "code_snippet": "private static LinkedList<Method> getApplicables(List<Method> methods, Class<?>... classes) {\n        LinkedList<Method> list = new LinkedList<>();\n\n        for (Method method : methods) {\n            if (isApplicable(method, classes)) {\n                list.add(method);\n            }\n        }\n        return list;\n    }",
        "human_comment": "Returns all methods that are applicable to actual argument types.\n\n@param methods list of all candidate methods\n@param classes the actual types of the arguments\n@return a list that contains only applicable methods (number of\nformal and actual arguments matches, and argument types are assignable\nto formal types through a method invocation conversion).",
        "model_generated_comment": "LinkedListMethod> methods/?>. @param methods @code methods /code classes. @return a list of methods if a method is applicable to a class."
    },
    {
        "id": 131,
        "code_snippet": "void outOfMemoryErrorInLeafExecution() {\n\t\tvar child = spy(new MyLeaf(UniqueId.root(\"leaf\", \"leaf\")));\n\t\tvar outOfMemoryError = new OutOfMemoryError(\"in test\");\n\t\twhen(child.execute(eq(rootContext), any())).thenThrow(outOfMemoryError);\n\t\troot.addChild(child);\n\n\t\tThrowable actualException = assertThrows(OutOfMemoryError.class, () -> executor.execute());\n\t\tassertSame(outOfMemoryError, actualException);\n\t}",
        "human_comment": "Verifies support for unrecoverable exceptions.",
        "model_generated_comment": "@link OutOfMemoryError/@link InleafExecution @param myLeaf @return a new instance of the execution of the current execution of a leaf execution if the execution fails."
    },
    {
        "id": 132,
        "code_snippet": "public static long byteStringAsMb(String str) {\n    return byteStringAs(str, ByteUnit.MiB);\n  }",
        "human_comment": "Convert a passed byte string (e.g. 50b, 100k, or 250m) to mebibytes for\ninternal use.\n\nIf no suffix is provided, the passed number is assumed to be in mebibytes.",
        "model_generated_comment": "@link ByteUnit.MiB byteStringAsMb. @return a byte string containing a string string."
    },
    {
        "id": 133,
        "code_snippet": "public String[] getSupportedProtocols() {\n        return new String[] {\"b1\", \"b2\"};\n}",
        "human_comment": "Wagon for testing, for protocols <code>b1</code> and <code>b2</code>",
        "model_generated_comment": "p>Returns a @link String/p>SupportedProtocols. @param b1 and b2. @return a new String[] if a supported protocol has been added."
    },
    {
        "id": 134,
        "code_snippet": "private <T> List<T> injectList(List<T> list, UnaryOperator<T> modifer) {\n        List<T> newList = null;\n        for (int i = 0; i < list.size(); i++) {\n            T oldT = list.get(i);\n            T newT = modifer.apply(oldT);\n            if (newT != oldT) {\n                if (newList == null) {\n                    newList = new ArrayList<>(list);\n                }\n                newList.set(i, newT);\n            }\n        }\n        return newList;\n    }",
        "human_comment": "Returns a list suited for the builders, i.e. null if not modified",
        "model_generated_comment": "@link List/@link UnaryOperator/www.unaryoperator.org> p>List/p> Modifer/href=\"https://github.com/modifer.cfm\">Also, if a new list is created, it will be renamed to the new list. @param oldT i = 0; i++ if it is a list /a>"
    },
    {
        "id": 135,
        "code_snippet": "public double calculateTotal(final String userId) {\n    return shoppingCartUseCase.calculateTotal(userId);\n  }",
        "human_comment": "Calculates the total cost of items in the user's cart.\n\n@param userId The ID of the user.\n@return The total price of all items in the cart.",
        "model_generated_comment": "Returns a shoppingCartUseCase that calculates the total of the user's shopping cart."
    },
    {
        "id": 136,
        "code_snippet": "public void testSetup() {\n    lastError = null;\n  }",
        "human_comment": "Arguments passed to the test class to identify the test being run.",
        "model_generated_comment": "@link testSetup/@link TestSetup(). @param lastError null."
    },
    {
        "id": 137,
        "code_snippet": "public String getGroupId() {\n        return (groupId != null) ? groupId : \"\";\n    }",
        "human_comment": "Gets the effective group identifier of the model.\n\n@return The effective group identifier of the model or an empty string if unknown, never {@code null}.",
        "model_generated_comment": "Returns the group ID of a given group. @param groupId @code null"
    },
    {
        "id": 138,
        "code_snippet": "public void setUtf8String(UTF8String value) {\n    stringData = value;\n  }",
        "human_comment": "Sets the `UTF8String` `value` for all rows",
        "model_generated_comment": "Sets the value of @link Utf8String. @param value the value for the UTF-8String."
    },
    {
        "id": 139,
        "code_snippet": "public static <T> Result<T> newResult(T model, Iterable<? extends ModelProblem> problems) {\n        return new Result<>(hasErrors(problems), model, problems);\n    }",
        "human_comment": "New result - determine whether error or success by checking problems for errors\n\n@param model\n@param problems",
        "model_generated_comment": "@link ModelProblem/@link Problems @return a new Result if the model is a problem. @param model, iterable Problems if a model is not an error."
    },
    {
        "id": 140,
        "code_snippet": "public ProjectBuildingRequest setResolveVersionRanges(boolean value) {\n        this.resolveVersionRanges = value;\n        return this;\n    }",
        "human_comment": "@since 3.2.2\n@deprecated This got added when implementing MNG-2199 and is no longer used.\nCommit 6cf9320942c34bc68205425ab696b1712ace9ba4 updated the way 'MavenProject' objects are initialized.",
        "model_generated_comment": "p>Resolve VersionRanges/p>. @param value @link ProjectBuildingRequest."
    },
    {
        "id": 141,
        "code_snippet": "public static UsersDatabase getInstance(Context context) {\n        if (INSTANCE == null) {\n            synchronized (UsersDatabase.class) {\n                if (INSTANCE == null) {\n                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                            UsersDatabase.class, \"Sample.db\")\n                            .build();\n                }\n            }\n        }\n        return INSTANCE;\n    }",
        "human_comment": "The Room database that contains the Users table",
        "model_generated_comment": "@link UsersDatabase @param context context if the context is null. @return a synchronized instance of a users database if a user database is created."
    },
    {
        "id": 142,
        "code_snippet": "protected MavenBaseLogger(String name) {\n        this.name = name;\n\n        String levelString = recursivelyComputeLevelString();\n        if (levelString != null) {\n            this.currentLogLevel = SimpleLoggerConfiguration.stringToLevel(levelString);\n        } else {\n            this.currentLogLevel = CONFIG_PARAMS.defaultLogLevel;\n        }\n    }",
        "human_comment": "Protected access allows only {@link MavenLoggerFactory} and also derived classes to instantiate\nMavenLoggerFactory instances.",
        "model_generated_comment": "@link MavenBaseLogger @param name the name of the recursively-computed levelString the level of the current logger; if the name is null, the level will be set to null."
    },
    {
        "id": 143,
        "code_snippet": "public final boolean matches(Object item) {\n        return item != null\n                && expectedType.isInstance(item)\n                && matchesSafely((T) item);\n    }",
        "human_comment": "Method made final to prevent accidental override.\nIf you need to override this, there's no point on extending TypeSafeMatcher.\nInstead, extend the {@link BaseMatcher}.",
        "model_generated_comment": "Returns a @link object that matches the object. @param Object the object that matches. @return the object if the object is a T."
    },
    {
        "id": 144,
        "code_snippet": "public Comparator<Description> testComparator() {\n        return new TestComparator();\n    }",
        "human_comment": "@return a comparator that ranks tests based on the JUnit Max sorting\nrules, as described in the {@link MaxCore} class comment.",
        "model_generated_comment": "Returns a new Comparator. @param Comparator @link Comparator. @return a testComparator if a Comparator is not available."
    },
    {
        "id": 145,
        "code_snippet": "public DefaultMojoExecutionConfigurator() {\n        this.messageBuilderFactory = new DefaultMessageBuilderFactory();\n    }",
        "human_comment": "Default ctor is used in IT and most probably some 3rd party code. For those cases, we do provide sane defaults\nbut given this is a component, injection should be used, replacing direct instantiation.\n\n@deprecated Do not use this ctor directly, inject this component instead.",
        "model_generated_comment": "@link DefaultMojoExecutionConfigurator. @param DefaultMessageBuilderFactory @return a message builder/returns a default message."
    },
    {
        "id": 146,
        "code_snippet": "default Builder toBuilder() {\n        try {\n            return new Builder(\n                    getUserProperties(), getSystemProperties(), getStartTime(), getTopDirectory(), getRootDirectory());\n        } catch (IllegalStateException e) {\n            return new Builder(getUserProperties(), getSystemProperties(), getStartTime(), getTopDirectory(), null);\n        }\n    }",
        "human_comment": "Returns a proto session builder of this instance.",
        "model_generated_comment": "Error @link Builder. @param getUserProperties(), getStartTime(), and getRootDirectory()."
    },
    {
        "id": 147,
        "code_snippet": "public static void assertEquals(float expected, float actual, float delta, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, actual, delta, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal within the given non-negative {@code delta}.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "Asserts that @code expected and /code actual are equal. @param expected, float delta, messageSupplier are not equal."
    },
    {
        "id": 148,
        "code_snippet": "public static void assertNotEquals(Character unexpected, Character actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4",
        "model_generated_comment": "p>Assert/p> that @code unexpected and /code actual are not equal. @param unexpected and true are equal."
    },
    {
        "id": 149,
        "code_snippet": "private List<Restriction> intersection(List<Restriction> r1, List<Restriction> r2) {\n        List<Restriction> restrictions = new ArrayList<>(r1.size() + r2.size());\n        Iterator<Restriction> i1 = r1.iterator();\n        Iterator<Restriction> i2 = r2.iterator();\n        Restriction res1 = i1.next();\n        Restriction res2 = i2.next();\n\n        boolean done = false;\n        while (!done) {\n            if (res1.getLowerBound() == null\n                    || res2.getUpperBound() == null\n                    || res1.getLowerBound().compareTo(res2.getUpperBound()) <= 0) {\n                if (res1.getUpperBound() == null\n                        || res2.getLowerBound() == null\n                        || res1.getUpperBound().compareTo(res2.getLowerBound()) >= 0) {\n                    ArtifactVersion lower;\n                    ArtifactVersion upper;\n                    boolean lowerInclusive;\n                    boolean upperInclusive;\n\n                    if (res1.getLowerBound() == null) {\n                        lower = res2.getLowerBound();\n                        lowerInclusive = res2.isLowerBoundInclusive();\n                    } else if (res2.getLowerBound() == null) {\n                        lower = res1.getLowerBound();\n                        lowerInclusive = res1.isLowerBoundInclusive();\n                    } else {\n                        int comparison = res1.getLowerBound().compareTo(res2.getLowerBound());\n                        if (comparison < 0) {\n                            lower = res2.getLowerBound();\n                            lowerInclusive = res2.isLowerBoundInclusive();\n                        } else if (comparison == 0) {\n                            lower = res1.getLowerBound();\n                            lowerInclusive = res1.isLowerBoundInclusive() && res2.isLowerBoundInclusive();\n                        } else {\n                            lower = res1.getLowerBound();\n                            lowerInclusive = res1.isLowerBoundInclusive();\n                        }\n                    }\n\n                    if (res1.getUpperBound() == null) {\n                        upper = res2.getUpperBound();\n                        upperInclusive = res2.isUpperBoundInclusive();\n                    } else if (res2.getUpperBound() == null) {\n                        upper = res1.getUpperBound();\n                        upperInclusive = res1.isUpperBoundInclusive();\n                    } else {\n                        int comparison = res1.getUpperBound().compareTo(res2.getUpperBound());\n                        if (comparison < 0) {\n                            upper = res1.getUpperBound();\n                            upperInclusive = res1.isUpperBoundInclusive();\n                        } else if (comparison == 0) {\n                            upper = res1.getUpperBound();\n                            upperInclusive = res1.isUpperBoundInclusive() && res2.isUpperBoundInclusive();\n                        } else {\n                            upper = res2.getUpperBound();\n                            upperInclusive = res2.isUpperBoundInclusive();\n                        }\n                    }\n\n                    if (lower == null || upper == null || lower.compareTo(upper) != 0) {\n                        restrictions.add(new Restriction(lower, lowerInclusive, upper, upperInclusive));\n                    } else if (lowerInclusive && upperInclusive) {\n                        restrictions.add(new Restriction(lower, lowerInclusive, upper, upperInclusive));\n                    }\n\n                    if (upper == res2.getUpperBound()) {\n                        if (i2.hasNext()) {\n                            res2 = i2.next();\n                        } else {\n                            done = true;\n                        }\n                    } else {\n                        if (i1.hasNext()) {\n                            res1 = i1.next();\n                        } else {\n                            done = true;\n                        }\n                    }\n                } else {\n                    if (i1.hasNext()) {\n                        res1 = i1.next();\n                    } else {\n                        done = true;\n                    }\n                }\n            } else {\n                if (i2.hasNext()) {\n                    res2 = i2.next();\n                } else {\n                    done = true;\n                }\n            }\n        }\n\n        return restrictions;\n    }",
        "human_comment": "overlaps\ndon't add if they are equal and one is not inclusive\nnoinspection ObjectEquality\nadvance res2\nadvance res1\nmove on to next in r1\nmove on to next in r2",
        "model_generated_comment": "@code res1.getLowerBound @param r1, r2, r3, r4, r5, r6, r7, r8, r8 and r9."
    },
    {
        "id": 150,
        "code_snippet": "public void setSession(MavenSession session) {\n        AtomicReference<MavenSession> reference = DefaultLegacySupport.SESSION.get();\n        if (reference != null) {\n            reference.set(null);\n        }\n\n        if (session == null && reference != null) {\n            DefaultLegacySupport.SESSION.remove();\n        } else {\n            DefaultLegacySupport.SESSION.set(new AtomicReference<>(session));\n        }\n    }",
        "human_comment": "Helps to provide backward-compatibility with plugins that use legacy components. <strong>Warning:</strong> This is an\ninternal utility component that is only public for technical reasons, it is not part of the public API. In\nparticular, this component can be changed or deleted without prior notice.\n\n@since 3.0",
        "model_generated_comment": "DefaultLegacySupport.Session.get() if @link Session is set to a session. @param null if the session is not set. @reference!= null"
    },
    {
        "id": 151,
        "code_snippet": "private ChannelFuture respond(Encodable result) {\n    SocketAddress remoteAddress = channel.remoteAddress();\n    return channel.writeAndFlush(result).addListener(future -> {\n      if (future.isSuccess()) {\n        logger.trace(\"Sent result {} to client {}\", result, remoteAddress);\n      } else {\n        logger.error(\"Error sending result {} to {}; closing connection\", future.cause(),\n          MDC.of(LogKeys.RESULT$.MODULE$, result),\n          MDC.of(LogKeys.HOST_PORT$.MODULE$, remoteAddress));\n        channel.close();\n      }\n    });\n  }",
        "human_comment": "Responds to a single message with some Encodable object. If a failure occurs while sending,\nit will be logged and the channel closed.",
        "model_generated_comment": "@link logger.trace @param remoteAddress a logger that sends a result to a client. @return a message to the client if the connection is closed."
    },
    {
        "id": 152,
        "code_snippet": "String getFilePath(String filename) {\n      String targetFile =\n        ExecutorDiskUtils.getFilePath(\n          appPathsInfo.activeLocalDirs,\n          appPathsInfo.subDirsPerLocalDir,\n          filename);\n      logger.debug(\"Get merged file {}\", targetFile);\n      return targetFile;\n    }",
        "human_comment": "The logic here is consistent with\n@see [[org.apache.spark.storage.DiskBlockManager#getMergedShuffleFile(\norg.apache.spark.storage.BlockId, scala.Option)]]",
        "model_generated_comment": "@link ExecutorDiskUtils.getFilePath @param filename The filename of a merged file. @return the filename if the file is merged with a new one."
    },
    {
        "id": 153,
        "code_snippet": "default boolean canOverwrite(Predicate[] predicates) {\n    return true;\n  }",
        "human_comment": "Checks whether it is possible to overwrite data from a data source table that matches filter\nexpressions.\n<p>\nRows should be overwritten from the data source iff all of the filter expressions match.\nThat is, the expressions must be interpreted as a set of filters that are ANDed together.\n\n@param predicates V2 filter expressions, used to match data to overwrite\n@return true if the delete operation can be performed\n\n@since 3.4.0",
        "model_generated_comment": "@link CanOverwrite @param predicates @return true if the predicate has been overwritten."
    },
    {
        "id": 154,
        "code_snippet": "public boolean isUnshredded() {\n    return topLevelMetadataIdx >= 0 && variantIdx >= 0 && typedIdx < 0;\n  }",
        "human_comment": "Return whether the variant column is unshrededed. The user is not required to do anything\nspecial, but can have certain optimizations for unshrededed variant.",
        "model_generated_comment": "Returns a @link TopLevelMetadataIdx that is not shredded. @param topLevelMatrix Idx >= 0 && typedIdX >= 0. @return the shredded data if it is a toplevel data type."
    },
    {
        "id": 155,
        "code_snippet": "public static Tensor<Float> create(float[][][][][][] data) {\n    return Tensor.create(data, Float.class);\n  }",
        "human_comment": "Creates a rank-6 tensor of {@code float} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array.",
        "model_generated_comment": "Creates a static Tensor using @link Float. @param data a float containing the data of the float."
    },
    {
        "id": 156,
        "code_snippet": "public static Map<String, String> createDefaultConfigMap() {\n    Map<String, String> confMap = new HashMap<String, String>();\n    confMap.put(\"spark.ssl.rpc.enabled\", \"true\");\n    confMap.put(\"spark.ssl.rpc.openSslEnabled\", \"true\");\n    confMap.put(\"spark.ssl.rpc.privateKey\", SslSampleConfigs.unencryptedPrivateKeyPath);\n    // intentionally not set\n    // confMap.put(\"spark.ssl.rpc.privateKeyPassword\", \"password\");\n    confMap.put(\"spark.ssl.rpc.certChain\", SslSampleConfigs.unencryptedCertChainPath);\n    confMap.put(\"spark.ssl.enabled\", \"true\");\n    confMap.put(\"spark.ssl.keyPassword\", \"password\");\n    confMap.put(\"spark.ssl.trustStoreReloadingEnabled\", \"false\");\n    confMap.put(\"spark.ssl.trustStoreReloadIntervalMs\", \"10000\");\n    confMap.put(\"spark.ssl.keyStore\", SslSampleConfigs.keyStorePath);\n    confMap.put(\"spark.ssl.keyStorePassword\", \"password\");\n    confMap.put(\"spark.ssl.trustStore\", SslSampleConfigs.trustStorePath);\n    confMap.put(\"spark.ssl.trustStorePassword\", \"password\");\n    confMap.put(\"spark.ssl.protocol\", \"TLSv1.3\");\n    confMap.put(\"spark.ssl.standalone.enabled\", \"true\");\n    confMap.put(\"spark.ssl.ui.enabled\", \"true\");\n    return confMap;\n  }",
        "human_comment": "Creates a config map containing the settings needed to enable the RPC SSL feature\nAll the settings (except the enabled one) are intentionally set on the parent namespace\nso that we can verify settings inheritance works. We intentionally set conflicting\noptions for the key password to verify that is handled correctly.",
        "model_generated_comment": "p>Spark.ssl.rpc.openSslEnabled/p>. @param @code SslSampleConfigs/@code SSLv1.3"
    },
    {
        "id": 157,
        "code_snippet": "public static void assertNotEquals(char unexpected, char actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "p>Assert/p> that @code unexpected and /code actual are equal."
    },
    {
        "id": 158,
        "code_snippet": "void testDepth() {\n        ResolutionNode a1n = createResolutionNode(a1);\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n\n        assertResolveConflict(a1n, a1n, a2n);\n    }",
        "human_comment": "Tests that <code>a:1.0</code> wins in the scenario:\n<pre>\na:1.0\nb:1.0 -&gt; a:2.0\n</pre>",
        "model_generated_comment": "@link ResolutionNode/@link ResolveConflict. @param resolutionNode a1n = createResolutionNode(a1); @resolutionnode(b1) = a2n = b1n."
    },
    {
        "id": 159,
        "code_snippet": "public List<Artifact> getSystemArtifacts() {\n        List<Artifact> list = new ArrayList<>(getArtifacts().size());\n\n        for (Artifact a : getArtifacts()) {\n            if (a.getArtifactHandler().isAddedToClasspath()) {\n                if (Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\n                    list.add(a);\n                }\n            }\n        }\n        return list;\n    }",
        "human_comment": "TODO classpath check doesn't belong here - that's the other method\nTODO let the scope handler deal with this",
        "model_generated_comment": "p>Artifacts/p> @link ArtifactHandler/@link System/www.artifacthandler.com>. @param artifact a : a.getScope()."
    },
    {
        "id": 160,
        "code_snippet": "public DelegateSymlinkTextInputSplit() {\n      super((Path) null, 0, 0, (String[]) null);\n      targetPath = null;\n    }",
        "human_comment": "Delegate for SymlinkTextInputFormat, created to address SPARK-40815.\nFixes an issue where SymlinkTextInputFormat returns empty splits which could result in\nthe correctness issue when \"spark.hadoopRDD.ignoreEmptySplits\" is enabled.\n<p>\nIn this class, we update the split start and length to match the target file input thus fixing\nthe issue.",
        "model_generated_comment": "p>DelegateSymlinkTextInputSplit/p>. @param targetPath null @code null if it is a delegate."
    },
    {
        "id": 161,
        "code_snippet": "public void assertEmpty() {\n\t\tif (!isEmpty()) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(this.throwable);\n\t\t}\n\t}",
        "human_comment": "Assert that this {@code ThrowableCollector} is <em>empty</em> (i.e.,\nhas not collected any {@code Throwables}).\n\n<p>If this collector is not empty, the first collected {@code Throwable}\nwill be thrown with any additional {@code Throwables}\n{@linkplain Throwable#addSuppressed(Throwable) suppressed} in the\nfirst {@code Throwable}. Note, however, that the {@code Throwable}\nwill not be wrapped. Rather, it will be\n{@linkplain ExceptionUtils#throwAsUncheckedException masked}\nas an unchecked exception.\n\n@see #getThrowable()\n@see ExceptionUtils#throwAsUncheckedException(Throwable)",
        "model_generated_comment": "@link ExceptionUtils.throwAsUncheckedException. @param emptyException if the exception is not checked."
    },
    {
        "id": 162,
        "code_snippet": "public IValue runMethod(String methodName, IValue... inputs) {\n    return mNativePeer.runMethod(methodName, inputs);\n  }",
        "human_comment": "Runs the specified method of this module with the specified arguments.\n\n@param methodName name of the TorchScript method to run.\n@param inputs arguments that will be passed to TorchScript method.\n@return return value from the method.",
        "model_generated_comment": "@link IValue @param methodName @return the method name and the inputs of the method."
    },
    {
        "id": 163,
        "code_snippet": "private Executions(Stream<Execution> executions, String category) {\n\t\tPreconditions.notNull(executions, \"Execution stream must not be null\");\n\n\t\tthis.executions = Collections.unmodifiableList(executions.collect(toList()));\n\t\tthis.category = category;\n\t}",
        "human_comment": "{@code Executions} is a facade that provides a fluent API for working with\n{@linkplain Execution executions}.\n\n@since 1.4",
        "model_generated_comment": "Execution stream must not be null."
    },
    {
        "id": 164,
        "code_snippet": "void assertLinesMatch() {\n\t\t\tint expectedSize = expectedLines.size();\n\t\t\tint actualSize = actualLines.size();\n\n\t\t\tif (expectedSize > actualSize) {\n\t\t\t\tfail(\"expected %d lines, but only got %d\", expectedSize, actualSize);\n\t\t\t}\n\n\t\t\tif (expectedSize == actualSize) {\n\t\t\t\tif (IntStream.range(0, expectedSize).allMatch(i -> matches(expectedLines.get(i), actualLines.get(i)))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassertLinesMatchWithFastForward();\n\t\t}",
        "human_comment": "trivial case: when expecting more than actual lines available, something is wrong\nsimple case: both list are equally sized, compare them line-by-line\nelse fall-through to \"with fast-forward\" matching",
        "model_generated_comment": "@code expectedSize @param actualSize %d lines, but only got %e. @return true if the expected line size is greater than the actual line size. @example actualLinesMatchWithFastForward() if a line is larger than expected, if it is smaller than expected if there are more than a few lines between the expected and actual lines, i.e. the actual lines are larger than actual lines."
    },
    {
        "id": 165,
        "code_snippet": "private static String[] parseProperty(String line) {\n            // sorry for this spaghetti code, please replace it as soon as\n            // possible with a regexp when the Java 1.3 requirement is dropped\n\n            String[] result = new String[2];\n            StringBuilder key = new StringBuilder();\n            StringBuilder value = new StringBuilder();\n\n            // state of the automaton:\n            // 0: key parsing\n            // 1: antislash found while parsing the key\n            // 2: separator crossing\n            // 3: white spaces\n            // 4: value parsing\n            int state = 0;\n\n            for (int pos = 0; pos < line.length(); pos++) {\n                char c = line.charAt(pos);\n\n                switch (state) {\n                    case 0:\n                        if (c == '\\\\') {\n                            state = 1;\n                        } else if (contains(WHITE_SPACE, c)) {\n                            // switch to the separator crossing state\n                            state = 2;\n                        } else if (contains(SEPARATORS, c)) {\n                            // switch to the value parsing state\n                            state = 3;\n                        } else {\n                            key.append(c);\n                        }\n\n                        break;\n\n                    case 1:\n                        if (contains(SEPARATORS, c) || contains(WHITE_SPACE, c)) {\n                            // this is an escaped separator or white space\n                            key.append(c);\n                        } else {\n                            // another escaped character, the '\\' is preserved\n                            key.append('\\\\');\n                            key.append(c);\n                        }\n\n                        // return to the key parsing state\n                        state = 0;\n\n                        break;\n\n                    case 2:\n                        if (contains(WHITE_SPACE, c)) {\n                            // do nothing, eat all white spaces\n                            state = 2;\n                        } else if (contains(SEPARATORS, c)) {\n                            // switch to the value parsing state\n                            state = 3;\n                        } else {\n                            // any other character indicates we encoutered the beginning of the value\n                            value.append(c);\n\n                            // switch to the value parsing state\n                            state = 4;\n                        }\n\n                        break;\n\n                    case 3:\n                        if (contains(WHITE_SPACE, c)) {\n                            // do nothing, eat all white spaces\n                            state = 3;\n                        } else {\n                            // any other character indicates we encoutered the beginning of the value\n                            value.append(c);\n\n                            // switch to the value parsing state\n                            state = 4;\n                        }\n\n                        break;\n\n                    case 4:\n                        value.append(c);\n                        break;\n\n                    default:\n                        throw new IllegalStateException();\n                }\n            }\n\n            result[0] = key.toString();\n            result[1] = value.toString();\n\n            return result;\n        }",
        "human_comment": "Parse a property line and return the key and the value in an array.\n\n@param line the line to parse\n@return an array with the property's key and value",
        "model_generated_comment": "p>If the '' is an escaped separator or white space key, the value parsing state is 0; if it is not, the /p> will be @link if a key is parsed."
    },
    {
        "id": 166,
        "code_snippet": "public Builder withTimeout(long timeout, TimeUnit unit) {\n            if (timeout < 0) {\n                throw new IllegalArgumentException(\"timeout must be non-negative\");\n            }\n            if (unit == null) {\n                throw new NullPointerException(\"TimeUnit cannot be null\");\n            }\n            this.timeout = timeout;\n            this.unit = unit;\n            return this;\n        }",
        "human_comment": "Specifies the time to wait before timing out the test.\n\n<p>If this is not called, or is called with a {@code timeout} of\n{@code 0}, the returned {@code Statement} will wait forever for the\ntest to complete, however the test will still launch from a separate\nthread. This can be useful for disabling timeouts in environments\nwhere they are dynamically set based on some property.\n\n@param timeout the maximum time to wait\n@param unit the time unit of the {@code timeout} argument\n@return {@code this} for method chaining.",
        "model_generated_comment": "Error if the timeout is not null. @param timeout TimeUnit unit @code null"
    },
    {
        "id": 167,
        "code_snippet": "void throwAsUncheckedExceptionWithNullException() {\n\t\tassertThrows(PreconditionViolationException.class, () -> throwAsUncheckedException(null));\n\t}",
        "human_comment": "Unit tests for {@link ExceptionUtils}.\n\n@since 1.0",
        "model_generated_comment": "Throws a @link PreconditionViolationException if it is not checked."
    },
    {
        "id": 168,
        "code_snippet": "public List<String> getActiveProfiles() {\n        return Collections.unmodifiableList(new ArrayList<>(getProfileIds(pa -> pa.active())));\n    }",
        "human_comment": "Mimics the pre-Maven 4 \"active profiles\" list.\n@deprecated Use {@link #getRequiredActiveProfileIds()} and {@link #getOptionalActiveProfileIds()} instead.",
        "model_generated_comment": "Returns a @link ActiveProfiles Array of active profiles. @param activeProfileIds. @return a new ArrayList/@link ActiveProfile Ids if there are no active profiles in the list."
    },
    {
        "id": 169,
        "code_snippet": "public Double finish(Average reduction) {\n      return ((double) reduction.getSum()) / reduction.getCount();\n    }",
        "human_comment": "Transform the output of the reduction",
        "model_generated_comment": "Returns the number of reductions to be done. @param reduction the reduction @code reduction."
    },
    {
        "id": 170,
        "code_snippet": "public MetadataResolutionResult addVersionRangeViolation(Exception e) {\n        versionRangeViolations = initList(versionRangeViolations);\n\n        versionRangeViolations.add(e);\n\n        exceptions = initList(exceptions);\n\n        exceptions.add(e);\n\n        return this;\n    }",
        "human_comment": "TODO this needs to accept a {@link OverConstrainedVersionException} as returned by\n{@link #getVersionRangeViolation(int)} but it's not used like that in\n{@link org.apache.maven.repository.legacy.resolver.DefaultLegacyArtifactCollector}",
        "model_generated_comment": "@link VersionRangeViolations @param versionRangeVersionRiolation @return this; if it is not already there, it will be removed from the MetadataResolutionResult."
    },
    {
        "id": 171,
        "code_snippet": "public static Tensor<Boolean> create(boolean[][][][] data) {\n    return Tensor.create(data, Boolean.class);\n  }",
        "human_comment": "Creates a rank-4 tensor of {@code boolean} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array.",
        "model_generated_comment": "Creates a static Tensor using @link Boolean. @param data the data of the tensor."
    },
    {
        "id": 172,
        "code_snippet": "void monitorChild() {\n    Process proc = childProc;\n    if (proc == null) {\n      // Process may have already been disposed of, e.g. by calling kill().\n      return;\n    }\n\n    while (proc.isAlive()) {\n      try {\n        proc.waitFor();\n      } catch (Exception e) {\n        LOG.log(Level.WARNING, \"Exception waiting for child process to exit.\", e);\n      }\n    }\n\n    synchronized (this) {\n      if (isDisposed()) {\n        return;\n      }\n\n      int ec;\n      try {\n        ec = proc.exitValue();\n      } catch (Exception e) {\n        LOG.log(Level.WARNING, \"Exception getting child process exit code, assuming failure.\", e);\n        ec = 1;\n      }\n\n      if (ec != 0) {\n        State currState = getState();\n        // Override state with failure if the current state is not final, or is success.\n        if (!currState.isFinal() || currState == State.FINISHED) {\n          setState(State.FAILED, true);\n        }\n      }\n\n      dispose();\n    }\n  }",
        "human_comment": "Wait for the child process to exit and update the handle's state if necessary, according to\nthe exit code.",
        "model_generated_comment": "p>Process may have already been disposed of, e.g. by calling kill()."
    },
    {
        "id": 173,
        "code_snippet": "public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive) {\n        Key key = new Key(project, transitive, true);\n        List<MavenProject> list = cache.get(key);\n        if (list == null) {\n            list = applyFilter(projectDependencyGraph.getUpstreamProjects(project, transitive), transitive, true);\n            cache.put(key, list);\n        }\n        return list;\n    }",
        "human_comment": "Do not use computeIfAbsent here, as the computation is recursive\nand this is not supported by computeIfAbsent.",
        "model_generated_comment": "@link ProjectDependencyGraph.getUpstreamProjects(MavenProject project, transitive, true)/. @param transitive boolean transitive project /link Transitive project. @return if the project is a transitive or transitive one."
    },
    {
        "id": 174,
        "code_snippet": "public Object setProperty(String key, String value) {\n        return this.put(key, value);\n    }",
        "human_comment": "Calls the map method put. Provided for parallelism with the getProperty method.\nEnforces use of strings for property keys and values. The value returned is the result of the map call to put.\n\n@param key the key to be placed into this property list.\n@param value the value corresponding to the key.\n@return the previous value of the specified key in this property list, or null if it did not have one.",
        "model_generated_comment": "Sets the key and value of the object. @param key the key of the property. @return the key if the key is not @code value."
    },
    {
        "id": 175,
        "code_snippet": "private static List<Long> runsJDKWorstCase(int minRun, int length) {\n    List<Long> runs = new ArrayList<>();\n\n    long runningTotal = 0, Y = minRun + 4, X = minRun;\n\n    while (runningTotal + Y + X <= length) {\n      runningTotal += X + Y;\n      generateJDKWrongElem(runs, minRun, X);\n      runs.add(0, Y);\n      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}\n      X = Y + runs.get(1) + 1;\n      // Y_{i+1} = X_{i+1} + Y_i + 1\n      Y += X + 1;\n    }\n\n    if (runningTotal + X <= length) {\n      runningTotal += X;\n      generateJDKWrongElem(runs, minRun, X);\n    }\n\n    runs.add(length - runningTotal);\n    return runs;\n  }",
        "human_comment": "Fills <code>runs</code> with a sequence of run lengths of the form<br>\nY_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>\nY_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>\n... <br>\nY_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>\nThe Y_i's are chosen to satisfy the invariant throughout execution,\nbut the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)\ninto an X_i that violates the invariant.\n\n@param length The sum of all run lengths that will be added to <code>runs</code>.",
        "model_generated_comment": "Runs a JDKWorstCase with a @link Runs function. @param minRun, X, Y, and X. @return a new ArrayList/@link RunningTotal if X is longer than X and Y is shorter than Y if it is longer. @runs X = X + Y = Y + X  @run X @run @run Run @run run @run # X"
    },
    {
        "id": 176,
        "code_snippet": "void testFromString(NumberExpression first) {\n    final var expectedValue = first.interpret();\n    final var testStringValue = String.valueOf(expectedValue);\n    final var numberExpression = new NumberExpression(testStringValue);\n    assertEquals(expectedValue, numberExpression.interpret());\n  }",
        "human_comment": "Verify if the {@link NumberExpression#NumberExpression(String)} constructor works as expected",
        "model_generated_comment": "p>Assert/p> that @link #testStringValue is a valid value. @param numberExpression the value of the string."
    },
    {
        "id": 177,
        "code_snippet": "public Location lookup(Object keyBase, long keyOffset, int keyLength) {\n    safeLookup(keyBase, keyOffset, keyLength, loc,\n      Murmur3_x86_32.hashUnsafeWords(keyBase, keyOffset, keyLength, 42));\n    return loc;\n  }",
        "human_comment": "Looks up a key, and return a {@link Location} handle that can be used to test existence\nand read/write values.\n\nThis function always returns the same {@link Location} instance to avoid object allocation.\nThis function is not thread-safe.",
        "model_generated_comment": "@code keyBase/code keyLength. p>Murmur3_x86_32.hashUnsafeWords(keyBase, keyOffset, int)/p>SecureLookup(KeyBase), long keyOfset/em>."
    },
    {
        "id": 178,
        "code_snippet": "default <A extends Annotation> List<A> findRepeatableAnnotations(Class<A> annotationType) {\n\t\treturn AnnotationSupport.findRepeatableAnnotations(getAnnotatedElement(), annotationType);\n\t}",
        "human_comment": "Find all <em>repeatable</em> {@linkplain Annotation annotations} of\n{@code annotationType} that are either <em>present</em> or\n<em>meta-present</em> on the {@link AnnotatedElement} for this context.\n\n<h4>WARNING</h4>\n<p>Favor the use of this method over directly invoking annotation lookup\nmethods in the {@link AnnotatedElement} API due to a bug in {@code javac} on JDK\nversions prior to JDK 9.\n\n@param <A> the annotation type\n@param annotationType the repeatable annotation type to search for; never\n{@code null}\n@return the list of all such annotations found; neither {@code null} nor\nmutable, but potentially empty\n@see #isAnnotated(Class)\n@see #findAnnotation(Class)\n@see java.lang.annotation.Repeatable",
        "model_generated_comment": "AnnotationSupport.findRepeatableAnnotations(ClassA> annotationType)/."
    },
    {
        "id": 179,
        "code_snippet": "void parseClasspathResourcesWithFilePosition() {\n\t\t\tvar filePosition = FilePosition.from(12, 34);\n\t\t\tvar selector = parseIdentifier(selectClasspathResource(\"/foo/bar/spec.xml\", FilePosition.from(12, 34)));\n\t\t\tassertThat(selector) //\n\t\t\t\t\t.asInstanceOf(type(ClasspathResourceSelector.class)) //\n\t\t\t\t\t.extracting(ClasspathResourceSelector::getClasspathResourceName,\n\t\t\t\t\t\tClasspathResourceSelector::getPosition) //\n\t\t\t\t\t.containsExactly(\"foo/bar/spec.xml\", Optional.of(filePosition));\n\n\t\t\tselector = parseIdentifier(selectClasspathResource(\"A/B/C/spec.json\", FilePosition.from(12, 34)));\n\t\t\tassertThat(selector) //\n\t\t\t\t\t.asInstanceOf(type(ClasspathResourceSelector.class)) //\n\t\t\t\t\t.extracting(ClasspathResourceSelector::getClasspathResourceName,\n\t\t\t\t\t\tClasspathResourceSelector::getPosition) //\n\t\t\t\t\t.containsExactly(\"A/B/C/spec.json\", Optional.of(filePosition));\n\t\t}",
        "human_comment": "with unnecessary \"/\" prefix\nstandard use case",
        "model_generated_comment": "@link FilePosition @param classpathResourceSelector.class // parse classpathresources with a file position. @return the file position if the file is not a spec. @contains exactly(\"/foo/bar/spec.xml\", Optional.of())"
    },
    {
        "id": 180,
        "code_snippet": "public void testNormalize2() {\n        Money expected = new Money(7, \"USD\");\n        assertEquals(expected, fMB1.subtract(f12CHF));\n    }",
        "human_comment": "{[12 CHF][7 USD]} - [12 CHF] == [7 USD]",
        "model_generated_comment": "@code expected @param fMB1.subtract(f12CHF) if the expected amount is less than the expected value."
    },
    {
        "id": 181,
        "code_snippet": "public static void assertNotEquals(float unexpected, Float actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Float) unexpected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n@since 5.4",
        "model_generated_comment": "p>Assert/p> that @code float and /code actual are equal."
    },
    {
        "id": 182,
        "code_snippet": "public static void dropSession() {\n    getSessionFactory().close();\n    sessionFactory = null;\n  }",
        "human_comment": "Drop the current connection, resulting in a create-drop clean database next time. This is\nmainly used for JUnit testing since one test should not influence the other",
        "model_generated_comment": "p>SessionFactory/p> @code null."
    },
    {
        "id": 183,
        "code_snippet": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaKLatentDirichletAllocationExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    String path = \"data/mllib/sample_lda_data.txt\";\n    JavaRDD<String> data = jsc.textFile(path);\n    JavaRDD<Vector> parsedData = data.map(s -> {\n      String[] sarray = s.trim().split(\" \");\n      double[] values = new double[sarray.length];\n      for (int i = 0; i < sarray.length; i++) {\n        values[i] = Double.parseDouble(sarray[i]);\n      }\n      return Vectors.dense(values);\n    });\n    JavaPairRDD<Long, Vector> corpus =\n      JavaPairRDD.fromJavaRDD(parsedData.zipWithIndex().map(Tuple2::swap));\n    corpus.cache();\n\n    LDAModel ldaModel = new LDA().setK(3).run(corpus);\n\n    System.out.println(\"Learned topics (as distributions over vocab of \" + ldaModel.vocabSize()\n      + \" words):\");\n    Matrix topics = ldaModel.topicsMatrix();\n    for (int topic = 0; topic < 3; topic++) {\n      System.out.print(\"Topic \" + topic + \":\");\n      for (int word = 0; word < ldaModel.vocabSize(); word++) {\n        System.out.print(\" \" + topics.apply(word, topic));\n      }\n      System.out.println();\n    }\n\n    ldaModel.save(jsc.sc(),\n      \"target/org/apache/spark/JavaLatentDirichletAllocationExample/LDAModel\");\n    DistributedLDAModel sameModel = DistributedLDAModel.load(jsc.sc(),\n      \"target/org/apache/spark/JavaLatentDirichletAllocationExample/LDAModel\");\n\n    jsc.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data\nIndex documents with unique IDs\nCluster the documents into three topics using LDA\nOutput topics. Each is a distribution over words (matching word count vectors)\n$example off$",
        "model_generated_comment": "p>JavaLatentDirichletAllocationExample/p>/a> ldaModel/b> @link http://www.java.org/apache/spark/jsc/jda/jrdd/index.jsp> v2.0.xml v1.0.x v4.0.xenforces that the vocab of a given java.jar file is a v5.0.xxencode/java."
    },
    {
        "id": 184,
        "code_snippet": "void whereWithNullFunction() {\n\t\tvar exception = assertThrows(PreconditionViolationException.class, () -> FunctionUtils.where(null, o -> true));\n\t\tassertEquals(\"function must not be null\", exception.getMessage());\n\t}",
        "human_comment": "Unit tests for {@link FunctionUtils}.\n\n@since 1.0",
        "model_generated_comment": "@code null if the function is not null. @param function null if it is null"
    },
    {
        "id": 185,
        "code_snippet": "public static SelectorResolutionResult failed(Throwable throwable) {\n\t\treturn new SelectorResolutionResult(Status.FAILED, throwable);\n\t}",
        "human_comment": "Create a {@code SelectorResolutionResult} for a <em>failed</em>\nselector resolution.\n@return the {@code SelectorResolutionResult}; never {@code null}",
        "model_generated_comment": "Returns a @link SelectorResolutionResult. @param throwable if a selector is unable to be resolved."
    },
    {
        "id": 186,
        "code_snippet": "public String nextPropertyName() {\n            final int start = idx;\n\n            while (idx < expression.length() && Character.isJavaIdentifierPart(expression.charAt(idx))) {\n                idx++;\n            }\n\n            if (idx <= start || idx > expression.length()) {\n                return null;\n            }\n\n            return expression.substring(start, idx);\n        }",
        "human_comment": "property name does not require delimiter",
        "model_generated_comment": "@code start @param start idx @return null if a character is a Java Identifier Part. @example if the character is not a java identifier, if it is null, it will be null."
    },
    {
        "id": 187,
        "code_snippet": "public void registerExecutor(String appId, ExecutorShuffleInfo executorInfo) {\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"register executor with RemoteBlockPushResolver {} local-dirs {} \"\n        + \"num sub-dirs {} shuffleManager {}\", appId, Arrays.toString(executorInfo.localDirs),\n        executorInfo.subDirsPerLocalDir, executorInfo.shuffleManager);\n    }\n    String shuffleManagerMeta = executorInfo.shuffleManager;\n    if (shuffleManagerMeta.contains(SHUFFLE_META_DELIMITER)) {\n      String mergeDirInfo =\n        shuffleManagerMeta.substring(shuffleManagerMeta.indexOf(SHUFFLE_META_DELIMITER) + 1);\n      try {\n        ObjectMapper mapper = new ObjectMapper();\n        TypeReference<Map<String, String>> typeRef\n          = new TypeReference<Map<String, String>>(){};\n        if (attemptId == UNDEFINED_ATTEMPT_ID) {\n          appsShuffleInfo.computeIfAbsent(appId, id -> {\n            AppPathsInfo appPathsInfo = new AppPathsInfo(appId, executorInfo.localDirs,\n                mergeDir, executorInfo.subDirsPerLocalDir);\n            writeAppPathsInfoToDb(appId, UNDEFINED_ATTEMPT_ID, appPathsInfo);\n            return new AppShuffleInfo(appId, UNDEFINED_ATTEMPT_ID, appPathsInfo);\n          });\n        } else {\n          AtomicReference<AppShuffleInfo> originalAppShuffleInfo = new AtomicReference<>();\n          appsShuffleInfo.compute(appId, (id, appShuffleInfo) -> {\n            if (appShuffleInfo == null || attemptId > appShuffleInfo.attemptId) {\n              originalAppShuffleInfo.set(appShuffleInfo);\n              AppPathsInfo appPathsInfo = new AppPathsInfo(appId, executorInfo.localDirs,\n                  mergeDir, executorInfo.subDirsPerLocalDir);\n              if (appShuffleInfo != null) {\n                removeAppAttemptPathInfoFromDB(appId, appShuffleInfo.attemptId);\n              }\n              writeAppPathsInfoToDb(appId, attemptId, appPathsInfo);\n              appShuffleInfo =\n                new AppShuffleInfo(\n                  appId, attemptId,\n                  new AppPathsInfo(appId, executorInfo.localDirs,\n                    mergeDir, executorInfo.subDirsPerLocalDir));\n            }\n            return appShuffleInfo;\n          });\n          if (originalAppShuffleInfo.get() != null) {\n            AppShuffleInfo appShuffleInfo = originalAppShuffleInfo.get();\n            logger.warn(\"Cleanup shuffle info and merged shuffle files for {}_{} as new \" +\n        }\n      } catch (JsonProcessingException e) {\n        logger.warn(\"Failed to get the merge directory information from ExecutorShuffleInfo: \", e);\n      }\n    } else {\n      logger.warn(\"ExecutorShuffleInfo does not have the expected merge directory information\");\n    }\n  }\n\n  @Override\n  public void close() {\n    if (!mergedShuffleCleaner.isShutdown()) {\n      // SPARK-40186\uff1aUse two phases shutdown refer to\n      // https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html\n      // Use two phases shutdown can prevent new tasks and wait for executing tasks to\n      // complete gracefully, and once timeout is reached, we want to interrupt running tasks,\n      // so that they fail. This is to prevent updates to shuffle state db after it is closed.\n      try {\n        mergedShuffleCleaner.shutdown();\n        // Wait a while for existing tasks to terminate\n        if (!mergedShuffleCleaner.awaitTermination(cleanerShutdownTimeout, TimeUnit.SECONDS)) {\n          shutdownMergedShuffleCleanerNow();\n        }\n      } catch (InterruptedException e) {\n        logger.info(\"mergedShuffleCleaner is interrupted in the process of graceful shutdown\", e);\n        shutdownMergedShuffleCleanerNow();\n        Thread.currentThread().interrupt();\n      }\n    }\n    if (db != null) {\n      try {\n        db.close();\n      } catch (IOException e) {\n        logger.error(\"Exception closing leveldb with registered app paths info and \"\n            + \"shuffle partition info\", e);\n      }\n    }\n  }\n\n  private void shutdownMergedShuffleCleanerNow() {\n    try {\n      List<Runnable> unfinishedTasks = mergedShuffleCleaner.shutdownNow();\n      logger.warn(\"There are still {} tasks not completed in mergedShuffleCleaner \" +\n        \"after {} ms.\",\n         MDC.of(LogKeys.COUNT$.MODULE$, unfinishedTasks.size()),\n         MDC.of(LogKeys.TIMEOUT$.MODULE$, cleanerShutdownTimeout * 1000L));\n      // Wait a while for tasks to respond to being cancelled\n      if (!mergedShuffleCleaner.awaitTermination(cleanerShutdownTimeout, TimeUnit.SECONDS)) {\n        logger.warn(\"mergedShuffleCleaner did not terminate in {} ms.\",\n          MDC.of(LogKeys.TIMEOUT$.MODULE$, cleanerShutdownTimeout * 1000L));\n      }\n    } catch (InterruptedException ignored) {\n      Thread.currentThread().interrupt();\n    }\n  }\n\n  private void writeAppPathsInfoToDb(String appId, int attemptId, AppPathsInfo appPathsInfo) {\n    if (db != null && AppsWithRecoveryDisabled.isRecoveryEnabledForApp(appId)) {\n      AppAttemptId appAttemptId = new AppAttemptId(appId, attemptId);\n      try {\n        byte[] key = getDbAppAttemptPathsKey(appAttemptId);\n        String valueStr = mapper.writeValueAsString(appPathsInfo);\n        byte[] value = valueStr.getBytes(StandardCharsets.UTF_8);\n        db.put(key, value);\n      } catch (Exception e) {\n        logger.error(\"Error saving registered app paths info for {}\", e,\n          MDC.of(LogKeys.APP_ATTEMPT_ID$.MODULE$, appAttemptId));\n      }\n    }\n  }\n\n  private void writeAppAttemptShuffleMergeInfoToDB(\n      AppAttemptShuffleMergeId appAttemptShuffleMergeId) {\n    if (db != null && AppsWithRecoveryDisabled.isRecoveryEnabledForApp(\n        appAttemptShuffleMergeId.appId)) {\n      // Write AppAttemptShuffleMergeId into LevelDB for finalized shuffles\n      try{\n        byte[] dbKey = getDbAppAttemptShufflePartitionKey(appAttemptShuffleMergeId);\n        db.put(dbKey, new byte[0]);\n      } catch (Exception e) {\n        logger.error(\"Error saving active app shuffle partition {}\", e,\n          MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId));\n      }\n    }\n  }\n\n  private <T> T parseDbKey(String key, String prefix, Class<T> valueType) throws IOException {\n    String json = key.substring(prefix.length() + 1);\n    return mapper.readValue(json, valueType);\n  }\n\n  private AppAttemptId parseDbAppAttemptPathsKey(String key) throws IOException {\n    return parseDbKey(key, APP_ATTEMPT_PATH_KEY_PREFIX, AppAttemptId.class);\n  }\n\n  private AppAttemptShuffleMergeId parseDbAppAttemptShufflePartitionKey(\n      String key) throws IOException {\n    return parseDbKey(\n        key, APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX, AppAttemptShuffleMergeId.class);\n  }\n\n  private byte[] getDbKey(Object key, String prefix) throws IOException {\n    // We add a common prefix on all the keys so we can find them in the DB\n    String keyJsonString = prefix + DB_KEY_DELIMITER + mapper.writeValueAsString(key);\n    return keyJsonString.getBytes(StandardCharsets.UTF_8);\n  }\n\n  private byte[] getDbAppAttemptShufflePartitionKey(\n      AppAttemptShuffleMergeId appAttemptShuffleMergeId) throws IOException {\n    return getDbKey(appAttemptShuffleMergeId, APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX);\n  }\n\n  private byte[] getDbAppAttemptPathsKey(AppAttemptId appAttemptId) throws IOException {\n    return getDbKey(appAttemptId, APP_ATTEMPT_PATH_KEY_PREFIX);\n  }\n\n  @VisibleForTesting\n  void reloadAndCleanUpAppShuffleInfo(DB db) throws IOException {\n    logger.info(\"Reload applications merged shuffle information from DB\");\n    List<byte[]> dbKeysToBeRemoved = new ArrayList<>();\n    dbKeysToBeRemoved.addAll(reloadActiveAppAttemptsPathInfo(db));\n    dbKeysToBeRemoved.addAll(reloadFinalizedAppAttemptsShuffleMergeInfo(db));\n    removeOutdatedKeyValuesInDB(dbKeysToBeRemoved);\n  }\n\n  @VisibleForTesting\n  List<byte[]> reloadActiveAppAttemptsPathInfo(DB db) throws IOException {\n    List<byte[]> dbKeysToBeRemoved = new ArrayList<>();\n    if (db != null) {\n      try (DBIterator itr = db.iterator()) {\n        itr.seek(APP_ATTEMPT_PATH_KEY_PREFIX.getBytes(StandardCharsets.UTF_8));\n        while (itr.hasNext()) {\n          Map.Entry<byte[], byte[]> entry = itr.next();\n          String key = new String(entry.getKey(), StandardCharsets.UTF_8);\n          if (!key.startsWith(APP_ATTEMPT_PATH_KEY_PREFIX)) {\n            break;\n          }\n          AppAttemptId appAttemptId = parseDbAppAttemptPathsKey(key);\n          AppPathsInfo appPathsInfo = mapper.readValue(entry.getValue(), AppPathsInfo.class);\n          logger.debug(\"Reloading Application paths info for application {}\", appAttemptId);\n          appsShuffleInfo.compute(appAttemptId.appId,\n              (appId, existingAppShuffleInfo) -> {\n                if (existingAppShuffleInfo == null ||\n                    existingAppShuffleInfo.attemptId < appAttemptId.attemptId) {\n                  if (existingAppShuffleInfo != null) {\n                    AppAttemptId existingAppAttemptId = new AppAttemptId(\n                        existingAppShuffleInfo.appId, existingAppShuffleInfo.attemptId);\n                    try {\n                      // Add the former outdated DB key to deletion list\n                      dbKeysToBeRemoved.add(getDbAppAttemptPathsKey(existingAppAttemptId));\n                    } catch (IOException e) {\n                      logger.error(\"Failed to get the DB key for {}\", e,\n                        MDC.of(LogKeys.APP_ATTEMPT_ID$.MODULE$, existingAppAttemptId));\n                    }\n                  }\n                  return new AppShuffleInfo(\n                      appAttemptId.appId, appAttemptId.attemptId, appPathsInfo);\n                } else {\n                  // Add the current DB key to deletion list as it is outdated\n                  dbKeysToBeRemoved.add(entry.getKey());\n                  return existingAppShuffleInfo;\n                }\n          });\n        }\n      }\n    }\n    return dbKeysToBeRemoved;\n  }\n\n  @VisibleForTesting\n  List<byte[]> reloadFinalizedAppAttemptsShuffleMergeInfo(DB db) throws IOException {\n    List<byte[]> dbKeysToBeRemoved = new ArrayList<>();\n    if (db != null) {\n      try (DBIterator itr = db.iterator()) {\n        itr.seek(APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX.getBytes(StandardCharsets.UTF_8));\n        while (itr.hasNext()) {\n          Map.Entry<byte[], byte[]> entry = itr.next();\n          String key = new String(entry.getKey(), StandardCharsets.UTF_8);\n          if (!key.startsWith(APP_ATTEMPT_SHUFFLE_FINALIZE_STATUS_KEY_PREFIX)) {\n            break;\n          }\n          AppAttemptShuffleMergeId partitionId = parseDbAppAttemptShufflePartitionKey(key);\n          logger.debug(\"Reloading finalized shuffle info for partitionId {}\", partitionId);\n          AppShuffleInfo appShuffleInfo = appsShuffleInfo.get(partitionId.appId);\n          if (appShuffleInfo != null && appShuffleInfo.attemptId == partitionId.attemptId) {\n            appShuffleInfo.shuffles.compute(partitionId.shuffleId,\n                (shuffleId, existingMergePartitionInfo) -> {\n                  if (existingMergePartitionInfo == null ||\n                      existingMergePartitionInfo.shuffleMergeId < partitionId.shuffleMergeId) {\n                    if (existingMergePartitionInfo != null) {\n                      AppAttemptShuffleMergeId appAttemptShuffleMergeId =\n                          new AppAttemptShuffleMergeId(\n                              appShuffleInfo.appId, appShuffleInfo.attemptId,\n                              shuffleId, existingMergePartitionInfo.shuffleMergeId);\n                      try{\n                        dbKeysToBeRemoved.add(\n                            getDbAppAttemptShufflePartitionKey(appAttemptShuffleMergeId));\n                      } catch (Exception e) {\n                        logger.error(\"Error getting the DB key for {}\", e, MDC.of(\n                          LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId));\n                      }\n                    }\n                    return new AppShuffleMergePartitionsInfo(partitionId.shuffleMergeId, true);\n                  } else {\n                    dbKeysToBeRemoved.add(entry.getKey());\n                    return existingMergePartitionInfo;\n                  }\n            });\n          } else {\n            dbKeysToBeRemoved.add(entry.getKey());\n          }\n        }\n      }\n    }\n    return dbKeysToBeRemoved;\n  }\n\n  @VisibleForTesting\n  void removeOutdatedKeyValuesInDB(List<byte[]> dbKeysToBeRemoved) {\n      dbKeysToBeRemoved.forEach(\n          (key) -> {\n            try {\n              db.delete(key);\n            } catch (Exception e) {\n              logger.error(\"Error deleting dangling key {} in DB\", e,\n                MDC.of(LogKeys.KEY$.MODULE$, key));\n            }\n          }\n      );\n  }\n\n  @VisibleForTesting\n  void submitCleanupTask(Runnable task) {\n    mergedShuffleCleaner.execute(task);\n  }\n\n  @VisibleForTesting\n  boolean isCleanerShutdown() {\n    return mergedShuffleCleaner.isShutdown();\n  }\n\n  static class PushBlockStreamCallback implements StreamCallbackWithID {\n\n    private final RemoteBlockPushResolver mergeManager;\n    private final AppShuffleInfo appShuffleInfo;\n    private final String streamId;\n    private final int mapIndex;\n    private final AppShufflePartitionInfo partitionInfo;\n    private int length = 0;\n    // This indicates that this stream got the opportunity to write the blocks to the merged file.\n    // Once this is set to true and the stream encounters a failure then it will unset the\n    // currentMapId of the partition so that another stream can start merging the blocks to the\n    // partition. This is reset to false when the stream completes.\n    private boolean isWriting = false;\n    // Use on-heap instead of direct ByteBuffer since these buffers will be GC'ed very quickly\n    private List<ByteBuffer> deferredBufs;\n\n    // This collects the total pushed block bytes received in the onData method. Once these bytes\n    // are not being used, we add them to the ignoredBlockBytes of the pushMergeMetrics.\n    private long receivedBytes = 0;\n\n    private PushBlockStreamCallback(\n        RemoteBlockPushResolver mergeManager,\n        AppShuffleInfo appShuffleInfo,\n        String streamId,\n        AppShufflePartitionInfo partitionInfo,\n        int mapIndex) {\n      Preconditions.checkArgument(mergeManager != null);\n      this.mergeManager = mergeManager;\n      Preconditions.checkArgument(appShuffleInfo != null);\n      this.appShuffleInfo = appShuffleInfo;\n      this.streamId = streamId;\n      Preconditions.checkArgument(partitionInfo != null);\n      this.partitionInfo = partitionInfo;\n      this.mapIndex = mapIndex;\n      abortIfNecessary();\n    }\n\n    @Override\n    public String getID() {\n      return streamId;\n    }\n\n    @Override\n    public ByteBuffer getCompletionResponse() {\n      return SUCCESS_RESPONSE.duplicate();\n    }\n\n    private void writeBuf(ByteBuffer buf) throws IOException {\n      while (buf.hasRemaining()) {\n        long updatedPos = partitionInfo.getDataFilePos() + length;\n        logger.debug(\"{} current pos {} updated pos {}\", partitionInfo,\n          partitionInfo.getDataFilePos(), updatedPos);\n        int bytesWritten = partitionInfo.dataChannel.write(buf, updatedPos);\n        length += bytesWritten;\n        mergeManager.pushMergeMetrics.blockBytesWritten.mark(bytesWritten);\n      }\n    }\n\n    private boolean allowedToWrite() {\n      return partitionInfo.getCurrentMapIndex() < 0\n        || partitionInfo.getCurrentMapIndex() == mapIndex;\n    }\n\n    private boolean isDuplicateBlock() {\n      return (partitionInfo.getCurrentMapIndex() == mapIndex && length == 0)\n        || partitionInfo.mapTracker.contains(mapIndex);\n    }\n\n    private void writeDeferredBufs() throws IOException {\n      long totalSize = 0;\n      for (ByteBuffer deferredBuf : deferredBufs) {\n        totalSize += deferredBuf.limit();\n        writeBuf(deferredBuf);\n        mergeManager.pushMergeMetrics.deferredBlocks.mark(-1);\n      }\n      mergeManager.pushMergeMetrics.deferredBlockBytes.dec(totalSize);\n      deferredBufs = null;\n    }\n\n    private void freeDeferredBufs() {\n      if (deferredBufs != null && !deferredBufs.isEmpty()) {\n        long totalSize = 0;\n        for (ByteBuffer deferredBuf : deferredBufs) {\n          totalSize += deferredBuf.limit();\n          mergeManager.pushMergeMetrics.deferredBlocks.mark(-1);\n        }\n        mergeManager.pushMergeMetrics.deferredBlockBytes.dec(totalSize);\n      }\n      deferredBufs = null;\n    }\n\n    private void abortIfNecessary() {\n      if (partitionInfo.shouldAbort(mergeManager.ioExceptionsThresholdDuringMerge)) {\n        freeDeferredBufs();\n        throw new IllegalStateException(String.format(\"%s when merging %s\",\n          ErrorHandler.BlockPushErrorHandler.IOEXCEPTIONS_EXCEEDED_THRESHOLD_PREFIX,\n          streamId));\n      }\n    }\n\n    private void updateIgnoredBlockBytes() {\n      if (receivedBytes > 0) {\n        mergeManager.pushMergeMetrics.ignoredBlockBytes.mark(receivedBytes);\n        receivedBytes = 0;\n      }\n    }\n\n    private void incrementIOExceptionsAndAbortIfNecessary() {\n      // Update the count of IOExceptions\n      partitionInfo.incrementIOExceptions();\n      abortIfNecessary();\n    }\n\n    private boolean isStale(\n        AppShuffleMergePartitionsInfo appShuffleMergePartitionsInfo,\n        int shuffleMergeId) {\n      return null == appShuffleMergePartitionsInfo ||\n        appShuffleMergePartitionsInfo.shuffleMergeId > shuffleMergeId;\n    }\n\n    private boolean isTooLate(\n        AppShuffleMergePartitionsInfo appShuffleMergePartitionsInfo,\n        int reduceId) {\n      return null == appShuffleMergePartitionsInfo ||\n        appShuffleMergePartitionsInfo.isFinalized() ||\n        !appShuffleMergePartitionsInfo.shuffleMergePartitions.containsKey(reduceId);\n    }\n\n    @Override\n    public void onData(String streamId, ByteBuffer buf) throws IOException {\n      receivedBytes += buf.remaining();\n      // When handling the block data using StreamInterceptor, it can help to reduce the amount\n      // of data that needs to be buffered in memory since it does not wait till the completion\n      // of the frame before handling the message, thus releasing the ByteBuf earlier. However,\n      // this also means it would chunk a block into multiple buffers. Here, we want to preserve\n      // the benefit of handling the block data using StreamInterceptor as much as possible while\n      // providing the guarantee that one block would be continuously written to the merged\n      // shuffle file before the next block starts. For each shuffle partition, we would track\n      // the current map index to make sure only block matching the map index can be written to\n      // disk. If one server thread sees the block being handled is the current block, it would\n      // directly write the block to disk. Otherwise, it would buffer the block chunks in memory.\n      // If the block becomes the current block before we see the end of it, we would then dump\n      // all buffered block data to disk and write the remaining portions of the block directly\n      // to disk as well. This way, we avoid having to buffer the entirety of every blocks in\n      // memory, while still providing the necessary guarantee.\n      synchronized (partitionInfo) {\n        AppShuffleMergePartitionsInfo info =\n            appShuffleInfo.shuffles.get(partitionInfo.appAttemptShuffleMergeId.shuffleId);\n        boolean isStaleBlockPush =\n            isStale(info, partitionInfo.appAttemptShuffleMergeId.shuffleMergeId);\n        boolean isTooLateBlockPush = isTooLate(info, partitionInfo.reduceId);\n        if (isStaleBlockPush || isTooLateBlockPush) {\n          freeDeferredBufs();\n          if (isTooLateBlockPush) {\n            mergeManager.pushMergeMetrics.lateBlockPushes.mark();\n          } else {\n            mergeManager.pushMergeMetrics.staleBlockPushes.mark();\n          }\n          return;\n        }\n        // Check whether we can write to disk\n        if (allowedToWrite()) {\n          // Identify duplicate block generated by speculative tasks. We respond success to\n          // the client in cases of duplicate even though no data is written.\n          if (isDuplicateBlock()) {\n            freeDeferredBufs();\n            return;\n          }\n          abortIfNecessary();\n          logger.trace(\"{} onData writable\", partitionInfo);\n          if (partitionInfo.getCurrentMapIndex() < 0) {\n            partitionInfo.setCurrentMapIndex(mapIndex);\n          }\n\n          // If we got here, it's safe to write the block data to the merged shuffle file. We\n          // first write any deferred block.\n          isWriting = true;\n          try {\n            if (deferredBufs != null && !deferredBufs.isEmpty()) {\n              writeDeferredBufs();\n            }\n            writeBuf(buf);\n          } catch (IOException ioe) {\n            incrementIOExceptionsAndAbortIfNecessary();\n            // If the above doesn't throw a RuntimeException, then we propagate the IOException\n            // back to the client so the block could be retried.\n            throw ioe;\n          }\n        } else {\n          logger.trace(\"{} onData deferred\", partitionInfo);\n          // If we cannot write to disk, we buffer the current block chunk in memory so it could\n          // potentially be written to disk later. We take our best effort without guarantee\n          // that the block will be written to disk. If the block data is divided into multiple\n          // chunks during TCP transportation, each #onData invocation is an attempt to write\n          // the block to disk. If the block is still not written to disk after all #onData\n          // invocations, the final #onComplete invocation is the last attempt to write the\n          // block to disk. If we still couldn't write this block to disk after this, we give up\n          // on this block push request and respond failure to client. We could potentially\n          // buffer the block longer or wait for a few iterations inside #onData or #onComplete\n          // to increase the chance of writing the block to disk, however this would incur more\n          // memory footprint or decrease the server processing throughput for the shuffle\n          // service. In addition, during test we observed that by randomizing the order in\n          // which clients sends block push requests batches, only ~0.5% blocks failed to be\n          // written to disk due to this reason. We thus decide to optimize for server\n          // throughput and memory usage.\n          if (deferredBufs == null) {\n            deferredBufs = new ArrayList<>();\n          }\n          // Write the buffer to the in-memory deferred cache. Since buf is a slice of a larger\n          // byte buffer, we cache only the relevant bytes not the entire large buffer to save\n          // memory.\n          int deferredLen = buf.remaining();\n          ByteBuffer deferredBuf = ByteBuffer.allocate(deferredLen);\n          deferredBuf.put(buf);\n          deferredBuf.flip();\n          deferredBufs.add(deferredBuf);\n          mergeManager.pushMergeMetrics.deferredBlockBytes.inc(deferredLen);\n          mergeManager.pushMergeMetrics.deferredBlocks.mark();\n        }\n      }\n    }\n\n    @Override\n    public void onComplete(String streamId) throws IOException {\n      synchronized (partitionInfo) {\n        logger.trace(\"{} onComplete invoked\", partitionInfo);\n        // Initially when this request got to the server, the shuffle merge finalize request\n        // was not received yet or this was the latest stage attempt (or latest shuffleMergeId)\n        // generating shuffle output for the shuffle ID. By the time we finish reading this\n        // message, the block request is either stale or too late. We should thus respond\n        // the error code to the client.\n        AppShuffleMergePartitionsInfo info =\n            appShuffleInfo.shuffles.get(partitionInfo.appAttemptShuffleMergeId.shuffleId);\n        if (isTooLate(info, partitionInfo.reduceId)) {\n          freeDeferredBufs();\n          mergeManager.pushMergeMetrics.lateBlockPushes.mark();\n          throw new BlockPushNonFatalFailure(\n            new BlockPushReturnCode(ReturnCode.TOO_LATE_BLOCK_PUSH.id(), streamId).toByteBuffer(),\n            BlockPushNonFatalFailure.getErrorMsg(streamId, ReturnCode.TOO_LATE_BLOCK_PUSH));\n        }\n        if (isStale(info, partitionInfo.appAttemptShuffleMergeId.shuffleMergeId)) {\n          freeDeferredBufs();\n          mergeManager.pushMergeMetrics.staleBlockPushes.mark();\n          throw new BlockPushNonFatalFailure(\n            new BlockPushReturnCode(ReturnCode.STALE_BLOCK_PUSH.id(), streamId).toByteBuffer(),\n            BlockPushNonFatalFailure.getErrorMsg(streamId, ReturnCode.STALE_BLOCK_PUSH));\n        }\n\n        // Check if we can commit this block\n        if (allowedToWrite()) {\n          // Identify duplicate block generated by speculative tasks. We respond success to\n          // the client in cases of duplicate even though no data is written.\n          if (isDuplicateBlock()) {\n            freeDeferredBufs();\n            // Since we just return without throwing exception, and the received bytes are ignored,\n            // thus we need to add them to ignoredBlockBytes in pushMergeMetrics.\n            updateIgnoredBlockBytes();\n            return;\n          }\n          if (partitionInfo.getCurrentMapIndex() < 0) {\n            try {\n              if (deferredBufs != null && !deferredBufs.isEmpty()) {\n                abortIfNecessary();\n                isWriting = true;\n                writeDeferredBufs();\n              }\n            } catch (IOException ioe) {\n              incrementIOExceptionsAndAbortIfNecessary();\n              // If the above doesn't throw a RuntimeException, then we propagate the IOException\n              // back to the client so the block could be retried.\n              throw ioe;\n            }\n          }\n          long updatedPos = partitionInfo.getDataFilePos() + length;\n          boolean indexUpdated = false;\n          if (updatedPos - partitionInfo.getLastChunkOffset() >= mergeManager.minChunkSize) {\n            try {\n              partitionInfo.updateChunkInfo(updatedPos, mapIndex);\n              indexUpdated = true;\n            } catch (IOException ioe) {\n              incrementIOExceptionsAndAbortIfNecessary();\n              // If the above doesn't throw a RuntimeException, then we do not propagate the\n              // IOException to the client. This may increase the chunk size however the increase is\n              // still limited because of the limit on the number of IOExceptions for a\n              // particular shuffle partition.\n            }\n          }\n          partitionInfo.setDataFilePos(updatedPos);\n          partitionInfo.setCurrentMapIndex(-1);\n\n          // update merged results\n          partitionInfo.blockMerged(mapIndex);\n          if (indexUpdated) {\n            partitionInfo.resetChunkTracker();\n          }\n        } else {\n          freeDeferredBufs();\n          mergeManager.pushMergeMetrics.blockAppendCollisions.mark();\n          throw new BlockPushNonFatalFailure(\n            new BlockPushReturnCode(ReturnCode.BLOCK_APPEND_COLLISION_DETECTED.id(), streamId)\n              .toByteBuffer(), BlockPushNonFatalFailure.getErrorMsg(\n                streamId, ReturnCode.BLOCK_APPEND_COLLISION_DETECTED));\n        }\n      }\n      isWriting = false;\n    }\n\n    @Override\n    public void onFailure(String streamId, Throwable throwable) throws IOException {\n      if (ERROR_HANDLER.shouldLogError(throwable)) {\n        logger.error(\"Encountered issue when merging {}\", throwable,\n          MDC.of(LogKeys.STREAM_ID$.MODULE$, streamId));\n      } else {\n        logger.debug(\"Encountered issue when merging {}\", streamId, throwable);\n      }\n      // The block was received by ESS but didn't get merged, so it is considered as \"ignored\".\n      // Capturing them in ignoredBlockBytes would help measure any server side improvement.\n      updateIgnoredBlockBytes();\n      // Only update partitionInfo if the failure corresponds to a valid request. If the\n      // request is too late, i.e. received after shuffle merge finalize or stale block push,\n      // #onFailure will also be triggered, and we can just ignore. Also, if we couldn't find\n      // an opportunity to write the block data to disk, we should also ignore here.\n      if (isWriting) {\n        synchronized (partitionInfo) {\n          AppShuffleMergePartitionsInfo info =\n            appShuffleInfo.shuffles.get(partitionInfo.appAttemptShuffleMergeId.shuffleId);\n          if (!isTooLate(info, partitionInfo.reduceId) &&\n              !isStale(info, partitionInfo.appAttemptShuffleMergeId.shuffleMergeId)) {\n            logger.debug(\"{} encountered failure\", partitionInfo);\n            partitionInfo.setCurrentMapIndex(-1);\n          }\n        }\n      }\n      isWriting = false;\n    }\n\n    @VisibleForTesting\n    AppShufflePartitionInfo getPartitionInfo() {\n      return partitionInfo;\n    }\n  }\n\n  public static class AppAttemptId {\n    public final String appId;\n    public final int attemptId;\n\n    @JsonCreator\n    public AppAttemptId(\n        @JsonProperty(\"appId\") String appId,\n        @JsonProperty(\"attemptId\") int attemptId) {\n      this.appId = appId;\n      this.attemptId = attemptId;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n\n      AppAttemptId appAttemptId = (AppAttemptId) o;\n      return attemptId == appAttemptId.attemptId &&\n          Objects.equals(appId, appAttemptId.appId);\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(appId, attemptId);\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\"Application %s_%s\", appId, attemptId);\n    }\n  }\n\n  public static class AppShuffleMergePartitionsInfo {\n    // ConcurrentHashMap doesn't allow null for keys or values which is why this is required.\n    // Marker to identify finalized shuffle partitions.\n    private static final Map<Integer, AppShufflePartitionInfo> SHUFFLE_FINALIZED_MARKER =\n        Collections.emptyMap();\n    private final int shuffleMergeId;\n    private final Map<Integer, AppShufflePartitionInfo> shuffleMergePartitions;\n\n    private final AtomicReference<int[]> reduceIds = new AtomicReference<>(new int[0]);\n\n    public AppShuffleMergePartitionsInfo(int shuffleMergeId, boolean shuffleFinalized) {\n      this.shuffleMergeId = shuffleMergeId;\n      this.shuffleMergePartitions = shuffleFinalized ? SHUFFLE_FINALIZED_MARKER :\n          new ConcurrentHashMap<>();\n    }\n\n    @VisibleForTesting\n    public Map<Integer, AppShufflePartitionInfo> getShuffleMergePartitions() {\n      return shuffleMergePartitions;\n    }\n\n    public boolean isFinalized() {\n      return shuffleMergePartitions == SHUFFLE_FINALIZED_MARKER;\n    }\n\n    public void setReduceIds(int[] reduceIds) {\n      this.reduceIds.set(reduceIds);\n    }\n\n    public int[] getReduceIds() {\n      return this.reduceIds.get();\n    }\n  }\n\n  public static class AppAttemptShuffleMergeId {\n    public final String appId;\n    public final int attemptId;\n    public final int shuffleId;\n    public final int shuffleMergeId;\n\n    @JsonCreator\n    public AppAttemptShuffleMergeId(\n        @JsonProperty(\"appId\") String appId,\n        @JsonProperty(\"attemptId\") int attemptId,\n        @JsonProperty(\"shuffleId\") int shuffleId,\n        @JsonProperty(\"shuffleMergeId\") int shuffleMergeId) {\n      Preconditions.checkArgument(appId != null, \"app id is null\");\n      this.appId = appId;\n      this.attemptId = attemptId;\n      this.shuffleId = shuffleId;\n      this.shuffleMergeId = shuffleMergeId;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n\n      AppAttemptShuffleMergeId appAttemptShuffleMergeId = (AppAttemptShuffleMergeId) o;\n      return attemptId == appAttemptShuffleMergeId.attemptId &&\n          shuffleId == appAttemptShuffleMergeId.shuffleId &&\n          shuffleMergeId == appAttemptShuffleMergeId.shuffleMergeId &&\n          Objects.equals(appId, appAttemptShuffleMergeId.appId);\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(appId, attemptId, shuffleId, shuffleMergeId);\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\"Application %s_%s shuffleId %s shuffleMergeId %s\",\n        appId, attemptId, shuffleId, shuffleMergeId);\n    }\n  }\n\n    void updateChunkInfo(long chunkOffset, int mapIndex) throws IOException {\n      try {\n        logger.trace(\"{} index current {} updated {}\", this, this.lastChunkOffset,\n          chunkOffset);\n        if (indexMetaUpdateFailed) {\n          indexFile.getChannel().position(indexFile.getPos());\n        }\n        indexFile.getDos().writeLong(chunkOffset);\n        // Chunk bitmap should be written to the meta file after the index file because if there are\n        // any exceptions during writing the offset to the index file, meta file should not be\n        // updated. If the update to the index file is successful but the update to meta file isn't\n        // then the index file position is not updated.\n        writeChunkTracker(mapIndex);\n        indexFile.updatePos(8);\n        this.lastChunkOffset = chunkOffset;\n        indexMetaUpdateFailed = false;\n      } catch (IOException ioe) {\n        logger.warn(\"{} reduceId {} update to index/meta failed\",\n          MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n          MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        indexMetaUpdateFailed = true;\n        // Any exception here is propagated to the caller and the caller can decide whether to\n        // abort or not.\n        throw ioe;\n      }\n    }\n\n    private void writeChunkTracker(int mapIndex) throws IOException {\n      if (mapIndex == -1) {\n        return;\n      }\n      chunkTracker.add(mapIndex);\n      logger.trace(\"{} mapIndex {} write chunk to meta file\", this, mapIndex);\n      if (indexMetaUpdateFailed) {\n        metaFile.getChannel().position(metaFile.getPos());\n      }\n      chunkTracker.serialize(metaFile.getDos());\n      metaFile.updatePos(metaFile.getChannel().position() - metaFile.getPos());\n    }\n\n    private void incrementIOExceptions() {\n      numIOExceptions++;\n    }\n\n    private boolean shouldAbort(int ioExceptionsThresholdDuringMerge) {\n      return numIOExceptions > ioExceptionsThresholdDuringMerge;\n    }\n\n    private void finalizePartition() throws IOException {\n      if (dataFilePos != lastChunkOffset) {\n        try {\n          updateChunkInfo(dataFilePos, lastMergedMapIndex);\n        } catch (IOException ioe) {\n          // Any exceptions here while updating the meta files can be ignored. If the files\n          // aren't successfully updated they will be truncated.\n        }\n      }\n      // Get rid of any partial block data at the end of the file. This could either\n      // be due to failure, or a request still being processed when the shuffle\n      // merge gets finalized, or any exceptions while updating index/meta files.\n      logger.trace(\"{} reduceId {} truncating files data {} index {} meta {}\",\n          appAttemptShuffleMergeId, reduceId, lastChunkOffset,\n          indexFile.getPos(), metaFile.getPos());\n      dataChannel.truncate(lastChunkOffset);\n      indexFile.getChannel().truncate(indexFile.getPos());\n      metaFile.getChannel().truncate(metaFile.getPos());\n    }\n\n    private void deleteAllFiles() {\n      if (!dataFile.delete()) {\n        logger.info(\"Error deleting data file for {} reduceId {}\",\n          MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n          MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n      }\n      metaFile.delete();\n      indexFile.delete();\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\"Application %s_%s shuffleId %s shuffleMergeId %s reduceId %s\",\n          appAttemptShuffleMergeId.appId, appAttemptShuffleMergeId.attemptId,\n          appAttemptShuffleMergeId.shuffleId, appAttemptShuffleMergeId.shuffleMergeId,\n          reduceId);\n    }\n\n    @VisibleForTesting\n    MergeShuffleFile getIndexFile() {\n      return indexFile;\n    }\n\n    @VisibleForTesting\n    MergeShuffleFile getMetaFile() {\n      return metaFile;\n    }\n\n    @VisibleForTesting\n    FileChannel getDataChannel() {\n      return dataChannel;\n    }\n\n    @VisibleForTesting\n    public RoaringBitmap getMapTracker() {\n      return mapTracker;\n    }\n\n    @VisibleForTesting\n    int getNumIOExceptions() {\n      return numIOExceptions;\n    }\n\n    @VisibleForTesting\n    Cleaner.Cleanable getCleanable() {\n      return cleanable;\n    }\n\n    private record ResourceCleaner(\n        FileChannel dataChannel,\n        MergeShuffleFile indexFile,\n        MergeShuffleFile metaFile,\n        AppAttemptShuffleMergeId appAttemptShuffleMergeId,\n        int reduceId) implements Runnable {\n\n      @Override\n      public void run() {\n        closeAllFiles(dataChannel, indexFile, metaFile, appAttemptShuffleMergeId,\n          reduceId);\n      }\n\n      private void closeAllFiles(\n          FileChannel dataChannel,\n          MergeShuffleFile indexFile,\n          MergeShuffleFile metaFile,\n          AppAttemptShuffleMergeId appAttemptShuffleMergeId,\n          int reduceId) {\n        try {\n          if (dataChannel.isOpen()) {\n            dataChannel.close();\n          }\n        } catch (IOException ioe) {\n          logger.warn(\"Error closing data channel for {} reduceId {}\",\n            MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n            MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        }\n        try {\n          metaFile.close();\n        } catch (IOException ioe) {\n          logger.warn(\"Error closing meta file for {} reduceId {}\",\n            MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n            MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        }\n        try {\n          indexFile.close();\n        } catch (IOException ioe) {\n          logger.warn(\"Error closing index file for {} reduceId {}\",\n            MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$, appAttemptShuffleMergeId),\n            MDC.of(LogKeys.REDUCE_ID$.MODULE$, reduceId));\n        }\n      }\n    }\n  }",
        "human_comment": "Appends the chunk offset to the index file and adds the map index to the chunk tracker.\n\n@param chunkOffset the offset of the chunk in the data file.\n@param mapIndex the map index to be added to chunk tracker.",
        "model_generated_comment": "@link ExecutorShuffleInfo @param appId, id, executorInfo.localDirs @return the shuffleManager if it is debug-enabled."
    },
    {
        "id": 188,
        "code_snippet": "public AlbumInvocationHandler(String baseUrl, HttpClient httpClient) {\n    this.restClient = new TinyRestClient(baseUrl, httpClient);\n  }",
        "human_comment": "Class constructor. It instantiates a TinyRestClient object.\n\n@param baseUrl Root url for endpoints.\n@param httpClient Handle the http communication.",
        "model_generated_comment": "@code baseUrl/code httpClient. p>Also, if you want to create a new instance of a client, you need to create an instance of the client."
    },
    {
        "id": 189,
        "code_snippet": "public static Slf4jConfiguration getConfiguration(ILoggerFactory loggerFactory) {\n        String slf4jBinding = loggerFactory.getClass().getCanonicalName();\n\n        try {\n            Enumeration<URL> resources =\n                    Slf4jConfigurationFactory.class.getClassLoader().getResources(RESOURCE);\n\n            while (resources.hasMoreElements()) {\n                URL resource = resources.nextElement();\n                try {\n                    InputStream is = resource.openStream();\n                    final Properties properties = new Properties();\n                    if (is != null) {\n                        try (InputStream in = is) {\n                            properties.load(in);\n                        }\n                    }\n                    String impl = properties.getProperty(slf4jBinding);\n                    if (impl != null) {\n                        return (Slf4jConfiguration)\n                                Class.forName(impl).getDeclaredConstructor().newInstance();\n                    }\n                } catch (IOException\n                        | ClassNotFoundException\n                        | NoSuchMethodException\n                        | InvocationTargetException\n                        | IllegalAccessException\n                        | InstantiationException ex) {\n                    // ignore and move on to the next\n                }\n            }\n        } catch (IOException ex) {\n            // ignore\n        }\n\n        return new UnsupportedSlf4jBindingConfiguration();\n    }",
        "human_comment": "Slf4jConfiguration factory, loading implementations from <code>META-INF/maven/slf4j-configuration.properties</code>\nconfiguration files in class loader: key is the class name of the ILoggerFactory, value is the class name of\nthe corresponding Slf4jConfiguration.\n\n@since 3.1.0",
        "model_generated_comment": "@link UnsupportedSlf4jBindingConfiguration @param loggerFactory @return a loggerConfigurationConfiguration if the logger isn't a valid logger."
    },
    {
        "id": 190,
        "code_snippet": "public static Optional<String> getModuleVersion(Class<?> type) {\n\t\treturn Optional.empty();\n\t}",
        "human_comment": "Return the raw version of the module that the class or interface is a member of.\n\n@param type class or interface to analyze\n@return the raw module version; never {@code null} but potentially empty",
        "model_generated_comment": "Returns a @link Optional class. @param class the class of the module. @return the class."
    },
    {
        "id": 191,
        "code_snippet": "private void initParent(MavenProject project, ModelBuilderResult result) {\n            Model parentModel = result.getParentModel();\n\n            if (parentModel != null) {\n                final String parentGroupId = getGroupId(parentModel);\n                final String parentVersion = getVersion(parentModel);\n\n                project.setParentArtifact(repositorySystem.createProjectArtifact(\n                        parentGroupId, parentModel.getArtifactId(), parentVersion));\n\n                MavenProject parent = projectIndex.get(parentModel.getId());\n                if (parent == null) {\n                    request.getRemoteRepositories().addAll(project.getRemoteArtifactRepositories());\n                    Path parentPomFile = parentModel.getPomFile();\n                    if (parentPomFile != null) {\n                        project.setParentFile(parentPomFile.toFile());\n                        try {\n                            parent = build(true, parentPomFile, Sources.buildSource(parentPomFile))\n                                    .getProject();\n                        } catch (ProjectBuildingException e) {\n                            if (logger.isDebugEnabled()) {\n                                logger.warn(\"Failed to build parent project for \" + project.getId(), e);\n                            } else {\n                                logger.warn(\"Failed to build parent project for \" + project.getId());\n                            }\n                        }\n                    } else {\n                        Artifact parentArtifact = project.getParentArtifact();\n                        try {\n                            parent = build(true, parentArtifact, false).getProject();\n                        } catch (ProjectBuildingException e) {\n                            if (logger.isDebugEnabled()) {\n                                logger.warn(\"Failed to build parent project for \" + project.getId(), e);\n                            } else {\n                                logger.warn(\"Failed to build parent project for \" + project.getId());\n                            }\n                        }\n                    }\n                }\n                project.setParent(parent);\n                if (project.getParentFile() == null && parent != null) {\n                    project.setParentFile(parent.getFile());\n                }\n            }\n        }",
        "human_comment": "At this point the DefaultModelBuildingListener has fired, and it populates the\nremote repositories with those found in the pom.xml, along with the existing externally\ndefined repositories.\n\nMNG-4488 where let invalid parents slide on by\nMessage below is checked for in the MNG-2199 core IT.\nMessage below is checked for in the MNG-2199 core IT.\nMNG-4488 where let invalid parents slide on by\nMessage below is checked for in the MNG-2199 core IT.\nMessage below is checked for in the MNG-2199 core IT.",
        "model_generated_comment": "@link MavenProjectParent @param parentVersion if (parentVersion) is the parent of the Maven project."
    },
    {
        "id": 192,
        "code_snippet": "ParquetVectorUpdater updater) {\n\n    int leftInBatch = state.rowsToReadInBatch;\n    int leftInPage = state.valuesToReadInPage;\n    long rowId = state.rowId;\n\n    DefLevelProcessor defLevelProcessor = new DefLevelProcessor(defLevelsReader, state, defLevels,\n      values, nulls, valuesReused, valueReader, updater);\n\n    while ((leftInBatch > 0 || !state.lastListCompleted) && leftInPage > 0) {\n      if (currentCount == 0 && !readNextGroup()) break;\n\n      // Values to read in the current RLE/PACKED block, must be <= what's left in the page\n      int valuesLeftInBlock = Math.min(leftInPage, currentCount);\n\n      // The current row range start and end\n      long rangeStart = state.currentRangeStart();\n      long rangeEnd = state.currentRangeEnd();\n\n      switch (mode) {\n        case RLE -> {\n          // This RLE block is consist of top-level rows, so we'll need to check\n          // if the rows should be skipped according to row indexes.\n          if (currentValue == 0) {\n            if (leftInBatch == 0) {\n              state.lastListCompleted = true;\n            } else {\n              // # of rows to read in the block, must be <= what's left in the current batch\n              int n = Math.min(leftInBatch, valuesLeftInBlock);\n\n              if (rowId + n < rangeStart) {\n                // Need to skip all rows in [rowId, rowId + n)\n                defLevelProcessor.skipValues(n);\n                rowId += n;\n                currentCount -= n;\n                leftInPage -= n;\n              } else if (rowId > rangeEnd) {\n                // The current row index already beyond the current range: move to the next range\n                // and repeat\n                state.nextRange();\n              } else {\n                // The range [rowId, rowId + n) overlaps with the current row range\n                long start = Math.max(rangeStart, rowId);\n                long end = Math.min(rangeEnd, rowId + n - 1);\n\n                // Skip the rows in [rowId, start)\n                int toSkip = (int) (start - rowId);\n                if (toSkip > 0) {\n                  defLevelProcessor.skipValues(toSkip);\n                  rowId += toSkip;\n                  currentCount -= toSkip;\n                  leftInPage -= toSkip;\n                }\n\n                // Read the rows in [start, end]\n                n = (int) (end - start + 1);\n\n                if (n > 0) {\n                  repLevels.appendInts(n, 0);\n                  defLevelProcessor.readValues(n);\n                }\n\n                rowId += n;\n                currentCount -= n;\n                leftInBatch -= n;\n                leftInPage -= n;\n              }\n            }\n          } else {\n            // Not a top-level row: just read all the repetition levels in the block if the row\n            // should be included according to row indexes, else skip the rows.\n            if (!state.shouldSkip) {\n              repLevels.appendInts(valuesLeftInBlock, currentValue);\n            }\n            state.numBatchedDefLevels += valuesLeftInBlock;\n            leftInPage -= valuesLeftInBlock;\n            currentCount -= valuesLeftInBlock;\n          }\n        }\n        case PACKED -> {\n          int i = 0;\n\n          for (; i < valuesLeftInBlock; i++) {\n            int currentValue = currentBuffer[currentBufferIdx + i];\n            if (currentValue == 0) {\n              if (leftInBatch == 0) {\n                state.lastListCompleted = true;\n                break;\n              } else if (rowId < rangeStart) {\n                // This is a top-level row, therefore check if we should skip it with row indexes\n                // the row is before the current range, skip it\n                defLevelProcessor.skipValues(1);\n              } else if (rowId > rangeEnd) {\n                // The row is after the current range, move to the next range and compare again\n                state.nextRange();\n                break;\n              } else {\n                // The row is in the current range, decrement the row counter and read it\n                leftInBatch--;\n                repLevels.appendInt(0);\n                defLevelProcessor.readValues(1);\n              }\n              rowId++;\n            } else {\n              if (!state.shouldSkip) {\n                repLevels.appendInt(currentValue);\n              }\n              state.numBatchedDefLevels += 1;\n            }\n          }\n\n          leftInPage -= i;\n          currentCount -= i;\n          currentBufferIdx += i;\n        }\n      }\n    }\n\n    // Process all the batched def levels\n    defLevelProcessor.finish();\n\n    state.rowsToReadInBatch = leftInBatch;\n    state.valuesToReadInPage = leftInPage;\n    state.rowId = rowId;\n  }",
        "human_comment": "Keep reading repetition level values from the page until either: 1) we've read enough\ntop-level rows to fill the current batch, or 2) we've drained the data page completely.\n\n@param valuesReused whether 'values' vector is reused for 'nulls'",
        "model_generated_comment": "if (leftInBatch = 0 ||!readNextPageUpdater updater) p>This RLE/PACKED block is consist of top-level rows, so we'll need to check if the rows should be skipped according to row indexes."
    },
    {
        "id": 193,
        "code_snippet": "String[] supportedCiphers, String[] defaultCiphers, String[] requestedCiphers) {\n    String[] baseCiphers = new String[]{\n    String[] enabledCiphers =\n      ((requestedCiphers == null || requestedCiphers.length == 0) ? baseCiphers : requestedCiphers);\n\n    List<String> ciphers = addIfSupported(supportedCiphers, enabledCiphers);\n    if (!ciphers.isEmpty()) {\n      return ciphers.toArray(new String[ciphers.size()]);\n    } else {\n      return defaultCiphers;\n    }\n  }\n\n  private static String[] enabledCipherSuites(SSLEngine engine, String[] requestedCiphers) {\n    return enabledCipherSuites(\n      engine.getSupportedCipherSuites(), engine.getEnabledCipherSuites(), requestedCiphers);\n  }\n\n  private static List<String> addIfSupported(String[] supported, String... names) {\n    List<String> enabled = new ArrayList<>();\n    Set<String> supportedSet = new HashSet<>(Arrays.asList(supported));\n    for (String n : names) {\n      if (supportedSet.contains(n)) {\n        enabled.add(n);\n      }\n    }\n    return enabled;\n  }\n}",
        "human_comment": "Use the default from JDK as fallback.",
        "model_generated_comment": "@link SupportedCiphers/@link RequestedSSLEngine/www.sslengine.com> p>Assertions/p> if a cipher is not supported, it will not be able to be used. @param supported, requested, requested and requested. @return if it is supported, if not, it should be used instead."
    },
    {
        "id": 194,
        "code_snippet": "default Map<NamedReference, ColumnStatistics> columnStats() {\n    return new HashMap<>();\n  }",
        "human_comment": "An interface to represent statistics for a data source, which is returned by\n{@link SupportsReportStatistics#estimateStatistics()}.\n\n@since 3.0.0",
        "model_generated_comment": "@link ColumnStats @return a new HashMap/@link Map/#returns a hashmap//#Return the new Map."
    },
    {
        "id": 195,
        "code_snippet": "private SerializableValueDescription(Object value) {\n        this.value = String.valueOf(value);\n    }",
        "human_comment": "This class exists solely to provide a serializable description of a value to be serialized as a field in\n{@link AssumptionViolatedException}. Being a {@link Throwable}, it is required to be {@link Serializable}, but a\nvalue of type Object provides no guarantee to be serializable. This class works around that limitation as\n{@link AssumptionViolatedException} only every uses the string representation of the value, while still retaining\nbackwards compatibility with classes compiled against its class signature before 4.14 and/or deserialization of\npreviously serialized instances.",
        "model_generated_comment": "@link SerializableValueDescription @param value the value of the serialized value."
    },
    {
        "id": 196,
        "code_snippet": "public void getReadyToTest(InputStream labelInputStream, MappedByteBuffer model) {\n    try {\n      Log.i(TAG, \"Creating detector.\");\n      detector = new OvicDetector(labelInputStream, model);\n      int[] inputDims = detector.getInputDims();\n      imgHeight = inputDims[1];\n      imgWidth = inputDims[2];\n      imgData = ByteBuffer.allocateDirect(DIM_BATCH_SIZE * imgHeight * imgWidth * DIM_PIXEL_SIZE);\n      imgData.order(ByteOrder.nativeOrder());\n      intValues = new int[imgHeight * imgWidth];\n      benchmarkStarted = false;\n    } catch (Exception e) {\n      Log.e(TAG, e.getMessage());\n      Log.e(TAG, \"Failed to initialize COCO detector for the benchmarker.\", e);\n    }\n  }",
        "human_comment": "Getting the benchmarker ready for detecting images.\n\n@param labelInputStream: an {@link InputStream} specifying where the list of labels should be\nread from.\n@param model: a {@link MappedByteBuffer} model to benchmark.",
        "model_generated_comment": "p>Failed to initialize COCO detector for the benchmarker."
    },
    {
        "id": 197,
        "code_snippet": "public void run() {\n      try (var socket = new DatagramSocket()) {\n            LOGGER.info(new String(reply.getData(), 0, reply.getLength()));\n          }\n\n          artificialDelayOf(100);\n        }",
        "human_comment": "Creates a new UDP logging client.\n\n@param clientName the name of the client to be sent in logging requests.\n@param port the port on which client will send logging requests.\n@throws UnknownHostException if localhost is unknown",
        "model_generated_comment": "p>Assert/p> that a datagram socket is not a @link /a>. @param reply.getLength()."
    },
    {
        "id": 198,
        "code_snippet": "Stream<DynamicTest> generateDynamicTestsThatReferenceLargeAmountsOfMemory() {\n\t\treturn Stream.generate(() -> new byte[TEN_MB])//\n\t\t\t\t// The lambda Executable in the following line *must* reference\n\t\t\t\t// the `bytes` array in order to hold onto the allocated memory.\n\t\t\t\t.map(bytes -> dynamicTest(\"test\", () -> assertNotNull(bytes)))//\n\t\t\t\t.limit(200);\n\t}",
        "human_comment": "Without the fix in {@code DynamicTestTestDescriptor}, setting the\n{@code -mx200m} VM argument will cause an {@link OutOfMemoryError} before\nthe 200 limit is reached.\n\n@see <a href=\"https://github.com/junit-team/junit5/issues/1865\">Issue 1865</a>",
        "model_generated_comment": "p>The lambda Executable in the following line *must* reference the large amounts of memory in order to hold onto the allocated memory."
    },
    {
        "id": 199,
        "code_snippet": "public synchronized int runCount() {\n        return fRunTests;\n    }",
        "human_comment": "Gets the number of run tests.",
        "model_generated_comment": "Returns a synchronized @link runCount function. @param runCount() a runcount of the tests. @return fRunTests if the tests are not running."
    },
    {
        "id": 200,
        "code_snippet": "Collection<Vertex> children, Map<Vertex, DfsState> stateMap, LinkedList<String> cycle) {\n        for (Vertex v : children) {\n            DfsState state = stateMap.putIfAbsent(v, DfsState.VISITING);\n            if (state == null) {\n                cycle.addLast(v.label);\n                List<String> ret = visitCycle(v.children, stateMap, cycle);\n                if (ret != null) {\n                    return ret;\n                }\n                cycle.removeLast();\n                stateMap.put(v, DfsState.VISITED);\n            } else if (state == DfsState.VISITING) {\n                int pos = cycle.lastIndexOf(v.label);\n                List<String> ret = cycle.subList(pos, cycle.size());\n                ret.add(v.label);\n                return ret;\n            }\n        }\n        return null;\n    }",
        "human_comment": "we are already visiting this vertex, this mean we have a cycle",
        "model_generated_comment": "Returns a @link Vertex. @param v : children, MapVertex, DfsState> stateMap, LinkedListString> cycle."
    },
    {
        "id": 201,
        "code_snippet": "public static void assertEquals(short expected, short actual) {\n        assertEquals(null, expected, actual);\n    }",
        "human_comment": "Asserts that two shorts are equal.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 202,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaStandardScalerExample\")\n      .getOrCreate();\n\n    Dataset<Row> dataFrame =\n      spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    StandardScaler scaler = new StandardScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\")\n      .setWithStd(true)\n      .setWithMean(false);\n\n    StandardScalerModel scalerModel = scaler.fit(dataFrame);\n\n    Dataset<Row> scaledData = scalerModel.transform(dataFrame);\n    scaledData.show();\n    spark.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nCompute summary statistics by fitting the StandardScaler\nNormalize each feature to have unit standard deviation.\n$example off$",
        "model_generated_comment": "p>SparkSession/p>Analyze @link SparkScalerExample. @param dataFrame www.sparks.com/wp-content/std/svm_data.txt/href=\"https://github.com/spark-scaler-example.html\">Also, if you want to create a new standard scaler/assembly/jsc_"
    },
    {
        "id": 203,
        "code_snippet": "public TimSort(SortDataFormat<K, Buffer> sortDataFormat) {\n    this.s = sortDataFormat;\n  }",
        "human_comment": "This is the minimum sized sequence that will be merged.  Shorter\nsequences will be lengthened by calling binarySort.  If the entire\narray is less than this length, no merges will be performed.\n\nThis constant should be a power of two.  It was 64 in Tim Peter's C\nimplementation, but 32 was empirically determined to work better in\nthis implementation.  In the unlikely event that you set this constant\nto be a number that's not a power of two, you'll need to change the\nminRunLength computation.\n\nIf you decrease this constant, you must change the stackLen\ncomputation in the TimSort constructor, or you risk an\nArrayOutOfBounds exception.  See listsort.txt for a discussion\nof the minimum stack length required as a function of the length\nof the array being sorted and the minimum merge sequence length.",
        "model_generated_comment": "p>SortDataFormat/p> a @link SortDataForm."
    },
    {
        "id": 204,
        "code_snippet": "static Predicate<Resource> packageName(Predicate<String> packageFilter) {\n\t\treturn resource -> packageFilter.test(packageName(resource.getName()));\n\t}",
        "human_comment": "Match resources against a package filter.\n\n<p>The {@code /} separated path of a resource is rewritten to a\n{@code .} separated package names. The package filter is applied to that\npackage name.",
        "model_generated_comment": "p>Predicate/p> @link PackageFilter/@code PackageName/PageName @param resourceName@returns the name of a predicate. @return a package name if it is not already a Predicate of the resource https://github.com/docs/resources/predicate_resource.getName()/return the package name of the corresponding resource."
    },
    {
        "id": 205,
        "code_snippet": "public static String getFilePath(String[] localDirs, int subDirsPerLocalDir, String filename) {\n    int hash = JavaUtils.nonNegativeHash(filename);\n    String localDir = localDirs[hash % localDirs.length];\n    int subDirId = (hash / localDirs.length) % subDirsPerLocalDir;\n    final String notNormalizedPath =\n      localDir + File.separator + String.format(\"%02x\", subDirId) + File.separator + filename;\n    // Interning the normalized path as according to measurements, in some scenarios such\n    // duplicate strings may waste a lot of memory (~ 10% of the heap).\n    // Unfortunately, we cannot just call the normalization code that java.io.File\n    // uses, since it is in the package-private class java.io.FileSystem.\n    // So we are creating a File just to get the normalized path back to intern it.\n    // We return this interned normalized path.\n    return new File(notNormalizedPath).getPath().intern();\n  }",
        "human_comment": "Hashes a filename into the corresponding local directory, in a manner consistent with\nSpark's DiskBlockManager.getFile().",
        "model_generated_comment": "@code localDirs is a non-negative path. @param filename the filename of the normalized path."
    },
    {
        "id": 206,
        "code_snippet": "public void setNull4Bytes(int ordinal) {\n    setNullBit(ordinal);\n    writeInt(getElementOffset(ordinal), 0);\n  }",
        "human_comment": "put zero into the corresponding field when set null",
        "model_generated_comment": "Sets the number of bits in a given array. @param ordinal @code ordinal. @return a null bit if the null bits are not ordinal. @getElementOffset(ordinal)"
    },
    {
        "id": 207,
        "code_snippet": "public void getUserWithUserInDataSource() {\n        LoadUserCallback callback = mock(LoadUserCallback.class);\n        when(mUserDataSource.getUser()).thenReturn(USER);\n\n        mUserRepository.getUser(callback);\n\n        verify(mUserDataSource).getUser();\n        verify(callback).onUserLoaded(USER);\n    }",
        "human_comment": "Given a callback for loading the user\nAnd user in the data source\nWhen requesting a user from the repository\nThe user is requested from the user data source\nand the callback triggers correct method",
        "model_generated_comment": "p>LoadUserCallback/p>Attach() a @code /code UserDataSource."
    },
    {
        "id": 208,
        "code_snippet": "void failureInTestMethodIsRegistered() {\n\t\tEngineExecutionResults executionResults = executeTests(selectMethod(FailureTestCase.class, \"failingTest\"));\n\t\tEvents tests = executionResults.testEvents();\n\n\t\ttests.assertStatistics(stats -> stats.started(1).failed(1));\n\n\t\ttests.failed().assertEventsMatchExactly( //\n\t\t\tevent(test(\"failingTest\"),\n\t\t\t\tfinishedWithFailure(instanceOf(AssertionFailedError.class), message(\"always fails\"))));\n\t}",
        "human_comment": "Integration tests that verify correct exception handling in the {@link JupiterTestEngine}.\n\n@since 5.0",
        "model_generated_comment": "p>Events/p>AssertionFailedError @link TestMethodIsRegistered."
    },
    {
        "id": 209,
        "code_snippet": "public static Constant<Double> create(Scope scope, double[][][][] data) {\n    return create(scope, data, Double.class);\n  }",
        "human_comment": "Creates a rank-4 constant of {@code double} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array.",
        "model_generated_comment": "Creates a new Constant with @code scope. @param scope scope the scope of the double object. @return a static Constant/@code data the data of the Double object."
    },
    {
        "id": 210,
        "code_snippet": "public static void assertEquals(double expected, Double actual) {\n\t\tAssertEquals.assertEquals((Double) expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.",
        "model_generated_comment": "Asserts that the expected and actual values are equal."
    },
    {
        "id": 211,
        "code_snippet": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
        "human_comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception.",
        "model_generated_comment": "p>Application with @code Exception should not be executed."
    },
    {
        "id": 212,
        "code_snippet": "public ExampleRemoteListenableWorker(Context appContext, WorkerParameters workerParams) {\n        super(appContext, workerParams);\n    }",
        "human_comment": "Example of implementing a RemoteListenableWorker. This worker simply returns Success.\n<p>\nUse RemoteListenableWorker if your worker is implemented in Java, otherwise use\nRemoteCoroutineWorker if your worker is implemented in Kotlin.",
        "model_generated_comment": "p>ExampleRemoteListenableWorker/p>. @param appContext workerParams @code workerParameters. @return a remote worker."
    },
    {
        "id": 213,
        "code_snippet": "public List<MavenProject> markAsFinished(MavenProject mavenProject) {\n        finishedProjects.add(mavenProject);\n        return getSchedulableNewProcesses(mavenProject);\n    }",
        "human_comment": "Marks the provided project as finished. Returns a list of\n\n@param mavenProject The project\n@return The list of builds that are eligible for starting now that the provided project is done",
        "model_generated_comment": "Returns a @link MavenProject that is a complete Maven project. p>MavenProcesses/p>Assemble a new Maven process."
    },
    {
        "id": 214,
        "code_snippet": "void testExtendedPluginDescriptor() {\n        ExtendedPluginDescriptor.Builder builder = new ExtendedPluginDescriptor.Builder();\n        builder.additionalField(\"additional\")\n                .groupId(\"org.apache.maven\")\n                .artifactId(\"maven-plugin-api\")\n                .version(\"1.0.0\");\n        ExtendedPluginDescriptor descriptor = builder.build();\n        assertEquals(\"additional\", descriptor.getAdditionalField());\n        assertEquals(\"org.apache.maven\", descriptor.getGroupId());\n    }",
        "human_comment": "make sure to call the subclasses' builder methods first, otherwise fluent API would not work",
        "model_generated_comment": "p>ExtendedPluginDescriptor/p>Application/a> @link http://www.apache.maven-plugin-api.org/descriptor/builder/programs/extended_plugins/index.html>"
    },
    {
        "id": 215,
        "code_snippet": "protected static String buildMessage(String message, ProblemCollector<BuilderProblem> problems) {\n        StringBuilder msg = new StringBuilder(message);\n        problems.problems().forEach(problem -> msg.append(\"\\n * \")\n                .append(problem.getSeverity().name())\n                .append(\": \")\n                .append(problem.getMessage()));\n        return msg.toString();\n    }",
        "human_comment": "Formats message out of problems: problems are sorted (in natural order of {@link BuilderProblem.Severity})\nand then a list is built. These exceptions are usually thrown in \"fatal\" cases (and usually prevent Maven\nfrom starting), and these exceptions may end up very early on output.\n\n@param message the base message to enhance\n@param problems the collection of problems to include in the message\n@return a formatted message including details of all problems",
        "model_generated_comment": "@link ProblemCollector/@link StringBuilder/. @param message the message of a problem. @return the message if the problem is not found."
    },
    {
        "id": 216,
        "code_snippet": "void executeTestsWithDisabledTestClass() {\n\t\tEngineExecutionResults results = executeTestsForClass(DisabledTestClassTestCase.class);\n\n\t\tresults.containerEvents().assertStatistics(stats -> stats.skipped(1));\n\t\tresults.testEvents().assertStatistics(stats -> stats.started(0));\n\t}",
        "human_comment": "Integration tests that verify support for {@link Disabled @Disabled} in the\n{@link JupiterTestEngine}.\n\n@since 5.0",
        "model_generated_comment": "Executes a test with a disabled test class. @param @link DisabledTestClassTestCase.class if the test is disabled. @return the test with the disabled test class"
    },
    {
        "id": 217,
        "code_snippet": "private ExecutionCondition condition = new EnabledIfEnvironmentVariableCondition() {\n\t};",
        "human_comment": "Stubbed subclass of {@link EnabledIfEnvironmentVariableCondition}.",
        "model_generated_comment": "Enables the Execution of an EnabledIfEnvironmentVariableCondition."
    },
    {
        "id": 218,
        "code_snippet": "public void populateResult(RepositorySystemSession session, ArtifactDescriptorResult result, Model model) {\n        ArtifactTypeRegistry stereotypes = session.getArtifactTypeRegistry();\n\n        for (Repository r : model.getRepositories()) {\n            result.addRepository(ArtifactDescriptorUtils.toRemoteRepository(r));\n        }\n\n        for (org.apache.maven.model.Dependency dependency : model.getDependencies()) {\n            result.addDependency(convert(dependency, stereotypes));\n        }\n\n        DependencyManagement mgmt = model.getDependencyManagement();\n        if (mgmt != null) {\n            for (org.apache.maven.model.Dependency dependency : mgmt.getDependencies()) {\n                result.addManagedDependency(convert(dependency, stereotypes));\n            }\n        }\n\n        Map<String, Object> properties = new LinkedHashMap<>();\n\n        Prerequisites prerequisites = model.getPrerequisites();\n        if (prerequisites != null) {\n            properties.put(\"prerequisites.maven\", prerequisites.getMaven());\n        }\n\n        List<License> licenses = model.getLicenses();\n        properties.put(\"license.count\", licenses.size());\n        for (int i = 0; i < licenses.size(); i++) {\n            License license = licenses.get(i);\n            properties.put(\"license.\" + i + \".name\", license.getName());\n            properties.put(\"license.\" + i + \".url\", license.getUrl());\n            properties.put(\"license.\" + i + \".comments\", license.getComments());\n            properties.put(\"license.\" + i + \".distribution\", license.getDistribution());\n        }\n\n        result.setProperties(properties);\n\n        setArtifactProperties(result, model);\n    }",
        "human_comment": "Populates Aether {@link ArtifactDescriptorResult} from Maven project {@link Model}.\n<p>\n<strong>Note:</strong> This class is part of work in progress and can be changed or removed without notice.\n@since 3.2.4\n@deprecated since 4.0.0, use {@code maven-api-impl} jar instead",
        "model_generated_comment": "p>Returns a @link ArtifactTypeRegistry/p> if the dependency is a dependency on a repository. @param'repository' if it is not, the dependency will be removed."
    },
    {
        "id": 219,
        "code_snippet": "public static Field makeAccessible(Field field) {\n\t\treturn ReflectionUtils.makeAccessible(Preconditions.notNull(field, \"field must not be null\"));\n\t}",
        "human_comment": "Make the supplied field accessible via reflection.\n\n<p>If you're looking for similar functionality for constructors or\nmethods, consider using {@link #newInstance(Class, Object...)} or\n{@link #invokeMethod(Method, Object, Object...)}.\n\n@param field the field to make accessible; never {@code null}\n@return the supplied field\n@since 1.12\n@see Field#setAccessible(boolean)",
        "model_generated_comment": "@link ReflectionUtils.makeAccessible if the field is not null."
    },
    {
        "id": 220,
        "code_snippet": "if (mergePartitionsInfo == null) {\n          logger.info(\"{} attempt {} shuffle {} shuffleMerge {}: creating a new shuffle \" +\n          int latestShuffleMergeId = mergePartitionsInfo.shuffleMergeId;\n          if (latestShuffleMergeId > shuffleMergeId) {\n            // Reject the request as we have already seen a higher shuffleMergeId than the one\n            // in the current request.\n            throw new BlockPushNonFatalFailure(\n              new BlockPushReturnCode(ReturnCode.STALE_BLOCK_PUSH.id(), blockId).toByteBuffer(),\n              BlockPushNonFatalFailure.getErrorMsg(blockId, ReturnCode.STALE_BLOCK_PUSH));\n          } else if (latestShuffleMergeId < shuffleMergeId){\n            // Higher shuffleMergeId seen for the shuffle ID meaning new stage attempt is being\n            // run for the shuffle ID. Close and clean up old shuffleMergeId files,\n            // happens in the indeterminate stage retries\n            AppAttemptShuffleMergeId currentAppAttemptShuffleMergeId =\n                new AppAttemptShuffleMergeId(appShuffleInfo.appId, appShuffleInfo.attemptId,\n                    shuffleId, latestShuffleMergeId);\n            logger.info(\"{}: creating a new shuffle merge metadata since received \" +\n              MDC.of(LogKeys.APP_ATTEMPT_SHUFFLE_MERGE_ID$.MODULE$,\n                currentAppAttemptShuffleMergeId),\n              MDC.of(LogKeys.SHUFFLE_MERGE_ID$.MODULE$, shuffleMergeId),\n              MDC.of(LogKeys.LATEST_SHUFFLE_MERGE_ID$.MODULE$, latestShuffleMergeId));\n            submitCleanupTask(() ->\n                closeAndDeleteOutdatedPartitions(currentAppAttemptShuffleMergeId,\n                    mergePartitionsInfo.shuffleMergePartitions));\n            return new AppShuffleMergePartitionsInfo(shuffleMergeId, false);\n          } else {\n            // The request is for block with same shuffleMergeId as the latest shuffleMergeId\n            if (mergePartitionsInfo.isFinalized()) {\n              throw new BlockPushNonFatalFailure(\n                  new BlockPushReturnCode(\n                      ReturnCode.TOO_LATE_BLOCK_PUSH.id(), blockId).toByteBuffer(),\n                  BlockPushNonFatalFailure.getErrorMsg(blockId, ReturnCode.TOO_LATE_BLOCK_PUSH));\n            }\n            return mergePartitionsInfo;\n          }\n        }",
        "human_comment": "Given the appShuffleInfo, shuffleId, shuffleMergeId and reduceId that uniquely identifies\na given shuffle partition of an application, retrieves the associated metadata. If not\npresent and the corresponding merged shuffle does not exist, initializes the metadata.",
        "model_generated_comment": "shuffleMergeId is a unique identifier for the merge metadata. p>Reject the request if a new stage attempt is being made."
    },
    {
        "id": 221,
        "code_snippet": "protected AbstractArtifactMetadata(Artifact artifact) {\n        this.artifact = artifact;\n    }",
        "human_comment": "Common elements of artifact metadata.",
        "model_generated_comment": "ArtifactMetadata(Artifact artifact) p>This method is used to create a @link AbstractArticles/p>. a href=\"https://github.com/artifacts/articles\">Attachment /a>"
    },
    {
        "id": 222,
        "code_snippet": "public void onCreate(Bundle savedInstanceState) {\n    Log.i(TAG, \"Create benchmark accuracy activity.\");\n    super.onCreate(savedInstanceState);\n\n    Intent intent = getIntent();\n    Bundle bundle = intent.getExtras();\n    String[] tfliteSettingsJsonFiles = bundle.getStringArray(TFLITE_SETTINGS_FILES_INTENT_KEY_0);\n    new BenchmarkAccuracyImpl().benchmark(this, tfliteSettingsJsonFiles);\n  }",
        "human_comment": "{@link Activity} class for Delegate Performance Accuracy Benchmark.\n\n<p>This Activity receives test arguments via a command line specified in an intent extra. It\nperforms accuracy benchmark tests via TFLite MiniBenchmark based on the input arguments. Please\ncheck the test example in\ntensorflow/lite/tools/benchmark/experimental/delegate_performance/android/README.md.",
        "model_generated_comment": "p>Create a benchmark accuracy activity/p>"
    },
    {
        "id": 223,
        "code_snippet": "void testDepthReversed() {\n        ResolutionNode b1n = createResolutionNode(b1);\n        ResolutionNode a2n = createResolutionNode(a2, b1n);\n        ResolutionNode a1n = createResolutionNode(a1);\n\n        assertResolveConflict(a2n, a2n, a1n);\n    }",
        "human_comment": "Tests that <code>a:2.0</code> wins in the scenario:\n<pre>\nb:1.0 -&gt; a:2.0\na:1.0\n</pre>",
        "model_generated_comment": "@link ResolutionNode/@link ResolveConflict. p>Create a resolution node for a given resolution."
    },
    {
        "id": 224,
        "code_snippet": "public static void assertEquals(long expected, Long actual, String message) {\n\t\tAssertEquals.assertEquals((Long) expected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 225,
        "code_snippet": "public Iterator<Operation> operations() {\n    return new OperationIterator(this);\n  }",
        "human_comment": "Iterator over all the {@link Operation}s in the graph.\n\n<p>The order of iteration is unspecified. Consumers of the iterator will receive no\nnotification should the underlying graph change during iteration.",
        "model_generated_comment": "Returns a new OperationIterator."
    },
    {
        "id": 226,
        "code_snippet": "protected PathSource(Path path, String location) {\n            this.path = requireNonNull(path, \"path\").normalize();\n            this.location = location != null ? location : this.path.toString();\n        }",
        "human_comment": "Constructs a new PathSource with the specified path and location.\n\n@param path the filesystem path to the source content\n@param location the logical location of the source, used for reporting purposes.\nIf null, the path string representation is used",
        "model_generated_comment": "p>Path path/p> if the path path is @code null, the path location should be null."
    },
    {
        "id": 227,
        "code_snippet": "public static TestClassLoader forClasses(Class<?>... classes) {\n\t\tPredicate<String> classNameFilter = name -> Arrays.stream(classes).map(Class::getName).anyMatch(name::equals);\n\t\treturn new TestClassLoader(getCodeSourceUrl(stackWalker.getCallerClass()), classNameFilter);\n\t}",
        "human_comment": "Create a {@link TestClassLoader} that filters the provided classes.\n\n@see #forClasses(List)\n@see #forClassNamePrefix(String)",
        "model_generated_comment": "p>StackWalker/p>TestClassLoader/a>. @param classNameFilter @code className @return a test class that is not a class."
    },
    {
        "id": 228,
        "code_snippet": "public int toIntExact() {\n    IntWrapper result = new IntWrapper();\n    if (toInt(result, false)) {\n      return result.value;\n    }\n    throw new NumberFormatException(\"invalid input syntax for type numeric: '\" + this + \"'\");\n  }",
        "human_comment": "Parses UTF8String(trimmed if needed) to int. This method is used when ANSI is enabled.\n\n@return If string contains valid numeric value then it returns the int value otherwise a\nNumberFormatException  is thrown.",
        "model_generated_comment": "@link IntWrapper/@link NumericalFormatException. @param numeric for numeric input type numeric."
    },
    {
        "id": 229,
        "code_snippet": "public Builder<T> addClassContainerSelectorResolver(Predicate<Class<?>> classFilter) {\n\t\t\tPreconditions.notNull(classFilter, \"classFilter must not be null\");\n\t\t\treturn addClassContainerSelectorResolverWithContext(__ -> classFilter);\n\t\t}",
        "human_comment": "Add a predefined resolver that resolves {@link ClasspathRootSelector\nClasspathRootSelectors}, {@link ModuleSelector ModuleSelectors}, and\n{@link PackageSelector PackageSelectors} into {@link ClassSelector\nClassSelectors} by scanning for classes that satisfy the supplied\npredicate in the respective class containers to this builder.\n\n@param classFilter predicate the resolved classes must satisfy; never\n{@code null}\n@return this builder for method chaining",
        "model_generated_comment": "@code null @param classFilter @return a class that is not null if it is null."
    },
    {
        "id": 230,
        "code_snippet": "public static Namespace create(Object... parts) {\n\t\t\tPreconditions.notEmpty(parts, \"parts array must not be null or empty\");\n\t\t\tPreconditions.containsNoNullElements(parts, \"individual parts must not be null\");\n\t\t\treturn new Namespace(new ArrayList<>(Arrays.asList(parts)));\n\t\t}",
        "human_comment": "Create a namespace which restricts access to data to all extensions\nwhich use the same sequence of {@code parts} for creating a namespace.\n\n<p>The order of the {@code parts} is significant.\n\n<p>Internally the {@code parts} are compared using {@link Object#equals(Object)}.",
        "model_generated_comment": "Creates a new namespace for @link Namespace. @param null or empty elements in the array."
    },
    {
        "id": 231,
        "code_snippet": "public static Constant<Float> create(Scope scope, float[][][][][] data) {\n    return create(scope, data, Float.class);\n  }",
        "human_comment": "Creates a rank-5 constant of {@code float} elements.\n\n@param scope is a scope used to add the underlying operation.\n@param data An array containing the values to put into the new constant. The dimensions of the\nnew constant will match those of the array.",
        "model_generated_comment": "Creates a new Constant with @code scope. @param scope scope the scope of the object."
    },
    {
        "id": 232,
        "code_snippet": "public void change(String seg) {\n        Path newCwd = resolve(seg);\n        if (Files.isDirectory(newCwd)) {\n            this.directory = newCwd;\n        } else {\n            throw new IllegalArgumentException(\"Directory '\" + directory + \"' does not exist\");\n        }\n    }",
        "human_comment": "Changes current cwd, if the new path is existing directory.\n\n@throws NullPointerException if {@code seg} is {@code null}.\n@throws IllegalArgumentException if {@code seg} leads to non-existent directory.",
        "model_generated_comment": "p>If a new directory is created, it will be thrown if it does not exist. @param newCwd @link /p>"
    },
    {
        "id": 233,
        "code_snippet": "public List<MavenProject> getActiveDependencies(MavenProject p) {\n        List<MavenProject> activeDependencies = projectDependencyGraph.getUpstreamProjects(p, false);\n        activeDependencies.removeAll(finishedProjects);\n        return activeDependencies;\n    }",
        "human_comment": "For the given {@link MavenProject} {@code p} return {@code p}'s uncompleted dependencies.\n\n@param p\n@return List of uncompleted prerequisite projects",
        "model_generated_comment": "p>MavenProject/p> @link ActiveDependencies/@link UpstreamProjects/www.mavenproject.org/projects/activedependencyGraph/href=\"https://github.com/test/test_projects\">Also, if you want to remove all active projects from a project, you need to remove them from the project."
    },
    {
        "id": 234,
        "code_snippet": "private List<String> extractReactorBuildOrder(List<String> loadedLines) {\n        List<String> resultingLines = new LinkedList<>();\n        boolean start = false;\n        for (String line : loadedLines) {\n            if (start) {\n                if (line.startsWith(\"[INFO] -------------\")) {\n                    start = false;\n                } else if (!line.endsWith(\"[INFO] \")) {\n                    resultingLines.add(line);\n                }\n            } else {\n                if (line.startsWith(\"[INFO] Reactor Summary\")) {\n                    start = true;\n                    resultingLines.add(line);\n                }\n            }\n        }\n        return resultingLines;\n    }",
        "human_comment": "Extract the lines at the end of the Maven output:\n\n<pre>\n[INFO] Reactor Summary..: XXX\n[INFO]\n[INFO] ...SUCCESS [  0.035 s]\n[INFO] ...SUCCESS [  0.035 s]\n[INFO] ...SUCCESS [  0.035 s]\n</pre>",
        "model_generated_comment": "@code loadedLines @param loadLines a LinkedList with a list of loaded lines. @return the resulting Lines if a line is loaded. @example: if the line is a loaded line, the line should be added to the list."
    },
    {
        "id": 235,
        "code_snippet": "public static void assertEquals(Long expected, long actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Long) actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "Asserts that @code expected and long actual are equal."
    },
    {
        "id": 236,
        "code_snippet": "private static Logger getLogger() {\n\t\treturn LoggerFactory.getLogger(ServiceLoaderRegistry.class);\n\t}",
        "human_comment": "Not a constant to avoid problems with building GraalVM native images",
        "model_generated_comment": "LoggerFactory.getLogger() @link ServiceLoaderRegistry.class."
    },
    {
        "id": 237,
        "code_snippet": "public void flirt(Queen queen) {\n    var flirtStatus = queen.getFlirted(this);\n    if (!flirtStatus) {\n      this.makeUnhappy();\n    } else {\n      this.makeHappy();\n    }\n  }",
        "human_comment": "Method to flirt to a queen.\n\n@param queen Queen which should be flirted.",
        "model_generated_comment": "@code queen queen @param queenFlirtStatus if the queen queen is happy. @return the queen's status if it's not happy."
    },
    {
        "id": 238,
        "code_snippet": "public Runner feed(String operation, Tensor<?> t) {\n      return feed(parseOutput(operation), t);\n    }",
        "human_comment": "Avoid evaluating {@code operation} and substitute {@code t} for the value it produces.\n\n@param operation Is either the string name of the operation, in which case this method is a\nshorthand for {@code feed(operation, 0)}, or it is a string of the form\n<tt>operation_name:output_index</tt> , in which case this method acts like {@code\nfeed(operation_name, output_index)}. These colon-separated names are commonly used in the\n{@code SignatureDef} protocol buffer messages that are included in {@link\nSavedModelBundle#metaGraphDef()}.",
        "model_generated_comment": "Returns the output of a @link Runner feed. @param operation the operation to parse. @return a feed from the Runner if the operation is a string."
    },
    {
        "id": 239,
        "code_snippet": "public static Result runClasses(Class<?>... classes) {\n        return runClasses(defaultComputer(), classes);\n    }",
        "human_comment": "Run the tests contained in <code>classes</code>. Write feedback while the tests\nare running and write stack traces for all failed tests after all tests complete. This is\nsimilar to {@link #main(String[])}, but intended to be used programmatically.\n\n@param classes Classes in which to find tests\n@return a {@link Result} describing the details of the test run and the failed tests.",
        "model_generated_comment": "Returns a @link RunClasses class. @return a class with a name of the class to run."
    },
    {
        "id": 240,
        "code_snippet": "public static Saga create() {\n    return new Saga();\n  }",
        "human_comment": "Saga representation. Saga consists of chapters. Every ChoreographyChapter is executed a certain\nservice.",
        "model_generated_comment": "Creates a new Saga using @link Saga. @return a Saga with a static Saga."
    },
    {
        "id": 241,
        "code_snippet": "@Override public Object evaluate(Row buffer) {\n    if (buffer.isNullAt(0)) {\n      return null;\n    } else {\n      return buffer.getDouble(0);\n    }\n  }",
        "human_comment": "If the buffer value is still null, we return null.\nOtherwise, the intermediate sum is the final result.",
        "model_generated_comment": "@Override @code null. @param buffer.getDouble(0) @return null if a buffer is a null value, otherwise the value is null."
    },
    {
        "id": 242,
        "code_snippet": "public static LotteryNumbers createRandom() {\n    return new LotteryNumbers();\n  }",
        "human_comment": "Creates a random lottery number.\n\n@return random LotteryNumbers",
        "model_generated_comment": "Creates a new number for each LotteryNumber. @param @link /. @return a random number if the number is not already created."
    },
    {
        "id": 243,
        "code_snippet": "public int portMaxRetries() {\n    return conf.getInt(\"spark.port.maxRetries\", 16);\n  }",
        "human_comment": "Maximum number of retries when binding to a port before giving up.",
        "model_generated_comment": "Returns a @link portMaxRetries if a port is not reached. @param portmaxRetries the maximum number of attempts. @return portmaxretries if the port isn't reached."
    },
    {
        "id": 244,
        "code_snippet": "public void nodeSkipped(JupiterEngineExecutionContext context, TestDescriptor descriptor, SkipResult result) {\n\t\t/* no-op */\n\t}",
        "human_comment": "Override {@link TestMethodTestDescriptor#nodeSkipped} as a no-op, since\nthe {@code TestWatcher} API is not supported for {@code @TestFactory}\ncontainers.\n\n@since 5.4",
        "model_generated_comment": "NodeSkipped(JupiterEngineExecutionContext, TestDescriptor descriptor, SkipResult result)."
    },
    {
        "id": 245,
        "code_snippet": "public void after(JupiterEngineExecutionContext context) {\n\t\tthis.invocationContext = null;\n\t}",
        "human_comment": "forget invocationContext so it can be garbage collected",
        "model_generated_comment": "p>JupiterEngineExecutionContext/p>. @param context @code null"
    },
    {
        "id": 246,
        "code_snippet": "public static void assertEquals(String message, double expected, double actual, double delta) {\n        if (Double.compare(expected, actual) == 0) {\n            return;\n        }\n        if (!(Math.abs(expected - actual) <= delta)) {\n            failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));\n        }\n    }",
        "human_comment": "Asserts that two doubles are equal concerning a delta.  If they are not\nan AssertionFailedError is thrown with the given message.  If the expected\nvalue is infinity then the delta value is ignored.",
        "model_generated_comment": "@link Double.compare(expected, actual, double delta). @param message, double expected, double actual, and double delta."
    },
    {
        "id": 247,
        "code_snippet": "default Resolution resolve(PackageSelector selector, Context context) {\n\t\treturn resolve((DiscoverySelector) selector, context);\n\t}",
        "human_comment": "Resolve the supplied {@link PackageSelector} using the supplied\n{@link Context Context}.\n\n<p>The default implementation delegates to {@link\n#resolve(DiscoverySelector, Context)}.\n\n@param selector the selector to be resolved; never {@code null}\n@param context the context to be used for resolving the selector; never\n{@code null}\n@return a {@link Resolution Resolution} of {@link Resolution#unresolved()\nunresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link\nResolution#matches(Set) matches()}; never {@code null}\n@see #resolve(DiscoverySelector, Context)",
        "model_generated_comment": "p>Resolve/p> a @link PackageSelector selector, Context context."
    },
    {
        "id": 248,
        "code_snippet": "private DeleteColumn(String[] fieldNames, Boolean ifExists) {\n      this.fieldNames = fieldNames;\n      this.ifExists = ifExists;\n    }",
        "human_comment": "A TableChange to delete a field.\n<p>\nIf the field does not exist, the change must result in an {@link IllegalArgumentException}.",
        "model_generated_comment": "Deletes a field from a @link ifExists. @param fieldNames the field name of the field."
    },
    {
        "id": 249,
        "code_snippet": "public static Finder specializedFinder(String... queries) {\n    var finder = identMult();\n\n    for (String query : queries) {\n      finder = finder.and(Finder.contains(query));\n    }\n    return finder;\n  }",
        "human_comment": "Specialized query. Every next query is looked in previous result.\n\n@param queries array with queries\n@return new finder",
        "model_generated_comment": "p>Structural Finder/p>. @param query @link query : queries. @return a specialized Finder for a string query if the string query is not found."
    },
    {
        "id": 250,
        "code_snippet": "public List<MavenProject> getRootSchedulableBuilds() {\n        Set<MavenProject> result = new LinkedHashSet<>();\n        for (ProjectSegment projectBuild : projectBuilds) {\n            if (projectDependencyGraph\n                    .getUpstreamProjects(projectBuild.getProject(), false)\n                    .isEmpty()) {\n                result.add(projectBuild.getProject());\n            }\n        }\n        if (result.isEmpty() && projectBuilds.size() > 0) {\n            // Must return at least one project\n            result.add(projectBuilds.get(0).getProject());\n        }\n        return new ArrayList<>(result);\n    }",
        "human_comment": "Gets all the builds that have no reactor-dependencies\n\n@return A set of all the initial builds",
        "model_generated_comment": "@link ProjectSegment projectBuild/@link MavenProjectBuilds @return a LinkedHashSet containing the project build. @param projectBuilds a projectBuild if the projectBuild is empty."
    },
    {
        "id": 251,
        "code_snippet": "for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        ArrayKeyIndexType o = new ArrayKeyIndexType();\n        o.key = new int[] { i, j, 0 };\n        o.id = new String[] { \"things\" };\n        o.key = new int[] { i, j, 1 };\n        o.id = new String[] { \"more things\" };\n    }\n\n    ArrayKeyIndexType o = new ArrayKeyIndexType();\n    o.key = new int[] { 2, 2, 2 };\n    o.id = new String[] { \"things\" };\n      ImmutableSet.of(new int[] {0, 0, 0}, new int[] { 2, 2, 2 }));\n      ImmutableSet.of(new String[] { \"things\" }));\n      ImmutableSet.of(new String[] { \"more things\" }));\n\n  @Test\n  public void testSkip() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      db.write(createCustomType1(i));\n    }\n\n    try (KVStoreIterator<CustomType1> it = db.view(CustomType1.class).closeableIterator()) {\n      assertTrue(it.hasNext());\n      assertTrue(it.skip(5));\n      assertEquals(\"key5\", it.next().key);\n      assertTrue(it.skip(3));\n      assertEquals(\"key9\", it.next().key);\n      assertFalse(it.hasNext());\n    }\n  }\n\n  @Test\n  public void testNegativeIndexValues() throws Exception {\n    List<Integer> expected = Arrays.asList(-100, -50, 0, 50, 100);\n\n    expected.forEach(i -> {\n      try {\n        db.write(createCustomType1(i));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    try (KVStoreIterator<CustomType1> iterator =\n      db.view(CustomType1.class).index(\"int\").closeableIterator()) {\n      List<Integer> results = StreamSupport\n        .stream(Spliterators.spliteratorUnknownSize(iterator, 0), false)\n        .map(e -> e.num)\n        .collect(Collectors.toList());\n\n      assertEquals(expected, results);\n    }\n  }\n\n  @Test\n  public void testCloseLevelDBIterator() throws Exception {\n    File dbPathForCloseTest = File\n      .createTempFile(\n        \"test_db_close.\",\n        \".ldb\");\n    dbPathForCloseTest.delete();\n    LevelDB dbForCloseTest = new LevelDB(dbPathForCloseTest);\n    for (int i = 0; i < 8192; i++) {\n      dbForCloseTest.write(createCustomType1(i));\n    }\n    String key = dbForCloseTest\n      .view(CustomType1.class).iterator().next().key;\n    assertEquals(\"key0\", key);\n    Iterator<CustomType1> it0 = dbForCloseTest\n      .view(CustomType1.class).max(1).iterator();\n    while (it0.hasNext()) {\n      it0.next();\n    }\n    System.gc();\n    Iterator<CustomType1> it1 = dbForCloseTest\n      .view(CustomType1.class).iterator();\n    assertEquals(\"key0\", it1.next().key);\n    try (KVStoreIterator<CustomType1> it2 = dbForCloseTest\n      .view(CustomType1.class).closeableIterator()) {\n      assertEquals(\"key0\", it2.next().key);\n    }\n    dbForCloseTest.close();\n    assertTrue(dbPathForCloseTest.exists());\n    FileUtils.deleteQuietly(dbPathForCloseTest);\n    assertTrue(!dbPathForCloseTest.exists());\n  }\n\n  @Test\n  public void testHasNextAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertFalse(iter.hasNext());\n  }\n\n  @Test\n  public void testHasNextAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    db.close();\n    assertFalse(iter.hasNext());\n  }\n\n  @Test\n  public void testNextAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertThrows(NoSuchElementException.class, iter::next);\n  }\n\n  @Test\n  public void testNextAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    iter.close();\n    assertThrows(NoSuchElementException.class, iter::next);\n  }\n\n  @Test\n  public void testSkipAfterIteratorClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    iter.close();\n    assertFalse(iter.skip(0));\n    assertFalse(iter.skip(1));\n  }\n\n  @Test\n  public void testSkipAfterDBClose() throws Exception {\n    db.write(createCustomType1(0));\n    KVStoreIterator<CustomType1> iter =\n      db.view(CustomType1.class).closeableIterator();\n    assertTrue(iter.hasNext());\n    db.close();\n    assertFalse(iter.skip(0));\n    assertFalse(iter.skip(1));\n  }\n\n  @Test\n  public void testResourceCleaner() throws Exception {\n    File dbPathForCleanerTest = File.createTempFile(\n      \"test_db_cleaner.\", \".rdb\");\n    dbPathForCleanerTest.delete();\n\n    LevelDB dbForCleanerTest = new LevelDB(dbPathForCleanerTest);\n    try {\n      for (int i = 0; i < 8192; i++) {\n        dbForCleanerTest.write(createCustomType1(i));\n      }\n      LevelDBIterator<CustomType1> levelDBIterator =\n        (LevelDBIterator<CustomType1>) dbForCleanerTest.view(CustomType1.class).iterator();\n      Reference<LevelDBIterator<?>> reference = new WeakReference<>(levelDBIterator);\n      assertNotNull(reference);\n      LevelDBIterator.ResourceCleaner resourceCleaner = levelDBIterator.getResourceCleaner();\n      assertFalse(resourceCleaner.isCompleted());\n      levelDBIterator = null;\n      int count = 0;\n      while (count < 100 && !reference.refersTo(null)) {\n        System.gc();\n        count++;\n        Thread.sleep(100);\n      }\n      assertTrue(reference.refersTo(null));\n      assertTrue(resourceCleaner.isCompleted());\n    } finally {\n      dbForCleanerTest.close();\n      FileUtils.deleteQuietly(dbPathForCleanerTest);\n    }\n  }\n\n  @Test\n  public void testMultipleTypesWriteAll() throws Exception {\n\n    List<CustomType1> type1List = Arrays.asList(\n      createCustomType1(1),\n      createCustomType1(2),\n      createCustomType1(3),\n      createCustomType1(4)\n    );\n\n    List<CustomType2> type2List = Arrays.asList(\n      createCustomType2(10),\n      createCustomType2(11),\n      createCustomType2(12),\n      createCustomType2(13)\n    );\n\n    List fullList = new ArrayList();\n    fullList.addAll(type1List);\n    fullList.addAll(type2List);\n\n    db.writeAll(fullList);\n    for (CustomType1 value : type1List) {\n      assertEquals(value, db.read(value.getClass(), value.key));\n    }\n    for (CustomType2 value : type2List) {\n      assertEquals(value, db.read(value.getClass(), value.key));\n    }\n  }\n\n\n  private CustomType1 createCustomType1(int i) {\n    CustomType1 t = new CustomType1();\n    t.key = \"key\" + i;\n    t.id = \"id\" + i;\n    t.name = \"name\" + i;\n    t.num = i;\n    t.child = \"child\" + i;\n    return t;\n  }\n\n  private CustomType2 createCustomType2(int i) {\n    CustomType2 t = new CustomType2();\n    t.key = \"key\" + i;\n    t.id = \"id\" + i;\n    t.parentId = \"parent_id\" + (i / 2);\n    return t;\n  }\n\n  private int countKeys(Class<?> type) throws Exception {\n    byte[] prefix = db.getTypeInfo(type).keyPrefix();\n    int count = 0;\n\n    try (DBIterator it = db.db().iterator()) {\n      it.seek(prefix);\n\n      while (it.hasNext()) {\n        byte[] key = it.next().getKey();\n        if (LevelDBIterator.startsWith(key, prefix)) {\n          count++;\n        }\n      }\n    }\n\n    return count;\n  }\n}",
        "human_comment": "Look into the actual DB and make sure that all the keys related to the type have been\nremoved.\nThere should be one \"id\" index entry with two values.\nDelete the first entry; now there should be 3 remaining keys, since one of the \"name\"\nindex entries should have been removed.\nMake sure there's a single entry in the \"id\" index now.\nDelete the remaining entry, make sure all data is gone.\nSPARK-31929: test when LevelDB.close() is called, related LevelDBIterators\nare closed. And files opened by iterators are also closed.\niter should be true\nclose iter\niter.hasNext should be false after iter close\niter should be true\nclose db\niter.hasNext should be false after db close\niter should be true\nclose iter\niter.next should throw NoSuchElementException after iter close\niter should be true\nclose db\niter.next should throw NoSuchElementException after db close\nclose iter\nskip should always return false after iter close\niter should be true\nclose db\nskip should always return false after db close\nManually set levelDBIterator to null, to be GC.\n100 times gc, the levelDBIterator should be GCed.\ncheck rocksDBIterator should be GCed\nVerify that the Cleaner will be executed after a period of time, isAllocated is true.",
        "model_generated_comment": "@link Creates a new KVStoreIterator. @param i = 0; i  2; j++) p>Asserts that the ArrayKeyIndexType is a valid ArrayType."
    },
    {
        "id": 252,
        "code_snippet": "void whenPerformTestTransaction_andPersistFails_thenThrowsException() {\n    // Arrange\n    doThrow(new RuntimeException()).when(entityManager).persist(any(HealthCheck.class));\n\n    // Act & Assert\n    assertThrows(RuntimeException.class, () -> healthCheckRepository.performTestTransaction());\n\n    // Verify that remove is not called if persist fails\n    verify(entityManager, never()).remove(any(HealthCheck.class));\n  }",
        "human_comment": "Test case for the `performTestTransaction()` method when the persist operation fails.\n\n<p>Asserts that when the `performTestTransaction()` method is called and the persist operation\nfails, it throws a RuntimeException.",
        "model_generated_comment": "Verify that remove is not called if persist fails @link RuntimeException. @param healthCheckRepository.performTestTransaction_andPersistFails_thenThrowsException"
    },
    {
        "id": 253,
        "code_snippet": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 2);\n\n    DecisionTreeClassifier dt = new DecisionTreeClassifier()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String impurity : DecisionTreeClassifier.supportedImpurities()) {\n      dt.setImpurity(impurity);\n    }\n    DecisionTreeClassificationModel model = dt.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.numNodes();\n    model.depth();\n    model.toDebugString();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model3.save(sc.sc(), path);\n      DecisionTreeClassificationModel sameModel =\n        DecisionTreeClassificationModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model3, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
        "human_comment": "This tests setters. Training with various options is tested in Scala.\nTODO: Add test once save/load are implemented.  SPARK-6725",
        "model_generated_comment": "@link TreeTreeClassifier/@link LogisticRegressionSuite/www.java.io.tmpdir/jsc/wp-content> p>Utils.deleteRecursively/href=\"https://www.jdd-classifiers.org/docs/jdt-classification-model.cache\"> if a /p> nPoints/header/cc> id/a>"
    },
    {
        "id": 254,
        "code_snippet": "public AlbumListPage cancelChanges() {\n    var cancelButton = (HtmlSubmitInput) page.getElementById(\"cancelButton\");\n    try {\n      cancelButton.click();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return new AlbumListPage(webClient);\n  }",
        "human_comment": "Cancel changes made by clicking the cancel button\n\n@return {@link AlbumListPage}",
        "model_generated_comment": "p>Also, if you want to cancel a page, you need to create a new @link AlbumListPage."
    },
    {
        "id": 255,
        "code_snippet": "public EngineDescriptor(UniqueId uniqueId, String displayName) {\n\t\tsuper(uniqueId, displayName);\n\t}",
        "human_comment": "Create a new {@code EngineDescriptor} with the supplied {@link UniqueId}\nnever {@code null}\n@param displayName the display name for the described {@code TestEngine};\nnever {@code null} or blank\n@see org.junit.platform.engine.TestEngine#getId()\n@see org.junit.platform.engine.TestDescriptor#getDisplayName()",
        "model_generated_comment": "@link UniqueId @param displayName Unique Id is the unique ID of a given display."
    },
    {
        "id": 256,
        "code_snippet": "public Factory(@NonNull Application application, int productId) {\n            mApplication = application;\n            mProductId = productId;\n            mRepository = ((BasicApp) application).getRepository();\n        }",
        "human_comment": "A creator is used to inject the product ID into the ViewModel\n<p>\nThis creator is to showcase how to inject dependencies into ViewModels. It's not\nactually necessary in this case, as the product ID can be passed in a public method.",
        "model_generated_comment": "p>Application/p> mProductId @code productId mRepository. @param application - mNonNull Application - not null Application."
    },
    {
        "id": 257,
        "code_snippet": "public SuiteLauncherDiscoveryRequestBuilder suite(Class<?> suiteClass) {\n\t\tPreconditions.notNull(suiteClass, \"Suite class must not be null\");\n\t\tapplyConfigurationParametersFromSuite(suiteClass);\n\t\tapplySelectorsAndFiltersFromSuite(suiteClass);\n\t\treturn this;\n\t}",
        "human_comment": "Apply a suite's annotation-based configuration, selectors, and filters to\nthis builder.\n\n@param suiteClass the class to apply the annotations from; never {@code null}\n@return this builder for method chaining\n@see org.junit.platform.suite.api.Suite\n@deprecated as of JUnit Platform 1.11 in favor of\n{@link #applyConfigurationParametersFromSuite} and\n{@link #applySelectorsAndFiltersFromSuite}",
        "model_generated_comment": "p>SuiteLauncherDiscoveryRequestBuilder/p>. @param suiteClass @code null. @return this if the class is not null."
    },
    {
        "id": 258,
        "code_snippet": "void testWatcherSemanticsWhenRegisteredAtMethodLevel() {\n\t\tClass<?> testClass = MethodLevelTestWatcherTestCase.class;\n\t\tassertStatsForAbstractDisabledMethodsTestCase(testClass);\n\n\t\tassertThat(TrackingTestWatcher.results.get(\"testDisabled\")).containsExactly(\"test\", \"repeatedTest\");\n\t}",
        "human_comment": "We get \"testDisabled\" events for the @Test method and the @RepeatedTest container.",
        "model_generated_comment": "TestWatcherSemanticsWhenRegisteredAtMethodLevel. @param testWatcherTestCase() @code testDisabled @repeatedTest if the method level is not enabled @return the test level if it's not enabled"
    },
    {
        "id": 259,
        "code_snippet": "public static void assumeFalse(String message, boolean b) {\n        assumeTrue(message, !b);\n    }",
        "human_comment": "The inverse of {@link #assumeTrue(String, boolean)}.",
        "model_generated_comment": "p>Assume/p> that the @link message/@link boolean is false."
    },
    {
        "id": 260,
        "code_snippet": "public Optional<ModernOrder> findOrderInLegacySystem(String id) {\n\n    return legacyShop\n        .findOrder(id)\n        .map(\n            o ->\n                new ModernOrder(\n                    o.getId(),\n                    new Customer(o.getCustomer()),\n                    new Shipment(o.getItem(), o.getQty(), o.getPrice()),\n                    \"\"));\n  }",
        "human_comment": "The method converts the order from the legacy system to the modern system.\n\n@param id the id of the order\n@return the order in the modern system",
        "model_generated_comment": "@link ModernOrder/@link LegacyOrderInLegacySystem/. @param customer id /a> p>ModernOrder in LegacySystem. @return a new Order in LegacyShop if it's a customer of a legacy system em>."
    },
    {
        "id": 261,
        "code_snippet": "public MavenITmng2739RequiredRepositoryElementsTest() {\n        super(\"(2.0.9,)\"); // only test in 2.0.9+\n    }",
        "human_comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-2739\">MNG-2739</a>.\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey",
        "model_generated_comment": "p>MavenITmng2739RequiredRepositoryElementsTest/p>. @param 2.0.9 @code /code 2.0.9."
    },
    {
        "id": 262,
        "code_snippet": "public static OutputMode Update() {\n    return InternalOutputModes.Update$.MODULE$;\n  }",
        "human_comment": "OutputMode in which only the rows that were updated in the streaming DataFrame/Dataset will\nbe written to the sink every time there are some updates. If the query doesn't contain\naggregations, it will be equivalent to `Append` mode.\n\n@since 2.1.1",
        "model_generated_comment": "@link InternalOutputModes.Update(). @returns a new output mode every time the output mode is updated."
    },
    {
        "id": 263,
        "code_snippet": "public SimplexTransferListener(TransferListener delegate) {\n        this(delegate, QUEUE_SIZE, BATCH_MAX_SIZE, true);\n    }",
        "human_comment": "Constructor that makes passed in delegate run on single thread, and will block on last event.",
        "model_generated_comment": "@link SimplexTransferListener. @param QUEUE_SIZE, BATCH_MAX_SIZE, true if a delegate is not present."
    },
    {
        "id": 264,
        "code_snippet": "public ChunkFetchSuccess(StreamChunkId streamChunkId, ManagedBuffer buffer) {\n    super(buffer, true);\n    this.streamChunkId = streamChunkId;\n  }",
        "human_comment": "Response to {@link ChunkFetchRequest} when a chunk exists and has been successfully fetched.\n\nNote that the server-side encoding of this messages does NOT include the buffer itself, as this\nmay be written by Netty in a more efficient manner (i.e., zero-copy write).\nSimilarly, the client-side decoding will reuse the Netty ByteBuf as the buffer.",
        "model_generated_comment": "@link ManagedBuffer/@link StreamChunkId/ @param streamChunkID/> p>This method is used to fetch a stream from a managed buffer."
    },
    {
        "id": 265,
        "code_snippet": "public Ansi cursorUpLine(final int n) {\n        return n < 0 ? cursorDownLine(-n) : appendEscapeSequence('F', n);\n    }",
        "human_comment": "Moves the cursor to the beginning of the n-th line above. If the parameter n is negative it\nmoves the cursor to the beginning of the n-th line below.\n\n@param n the number of lines to move the cursor\n@return this Ansi instance",
        "model_generated_comment": "p>Ansi cursorUpLine/p> @link cursorDownLine. @param n the cursor upline. @return n a cursor downline if it's n@code n."
    },
    {
        "id": 266,
        "code_snippet": "public void validateRawModel(Model m, int validationLevel, ModelProblemCollector problems) {\n        String minVersion = new MavenModelVersion().getModelVersion(m);\n        if (m.getModelVersion() != null && compareModelVersions(minVersion, m.getModelVersion()) > 0) {\n            addViolation(\n                    problems,\n                    Severity.FATAL,\n                    Version.V40,\n                    \"model\",\n                    null,\n                    \"the model contains elements that require a model version of \" + minVersion,\n                    m);\n        }\n\n        Parent parent = m.getParent();\n\n        if (parent != null) {\n            validateStringNotEmpty(\n                    \"parent.groupId\", problems, Severity.FATAL, Version.BASE, parent.getGroupId(), parent);\n\n            validateStringNotEmpty(\n                    \"parent.artifactId\", problems, Severity.FATAL, Version.BASE, parent.getArtifactId(), parent);\n\n            validateStringNotEmpty(\n                    \"parent.version\", problems, Severity.FATAL, Version.BASE, parent.getVersion(), parent);\n\n            if (equals(parent.getGroupId(), m.getGroupId()) && equals(parent.getArtifactId(), m.getArtifactId())) {\n                addViolation(\n                        problems,\n                        Severity.FATAL,\n                        Version.BASE,\n                        \"parent.artifactId\",\n                        null,\n                        \"must be changed\"\n                                + \", the parent element cannot have the same groupId:artifactId as the project.\",\n                        parent);\n            }\n\n            if (equals(\"LATEST\", parent.getVersion()) || equals(\"RELEASE\", parent.getVersion())) {\n                addViolation(\n                        problems,\n                        Severity.WARNING,\n                        Version.BASE,\n                        \"parent.version\",\n                        null,\n                        \"is either LATEST or RELEASE (both of them are being deprecated)\",\n                        parent);\n            }\n        }\n    }",
        "human_comment": "Check that the model version is correctly set wrt the model definition, i.e., that the\nuser does not use an attribute or element that is not available in the modelVersion used.",
        "model_generated_comment": "@link MavenModelVersion @param minVersion a model version of the model m/a> if the model version is not available, it will be removed from the model. @return a Maven model version m if it is a new version of m. p>Also, if m is not a valid model version, the parent element will not have the same groupId:artifactId as the project /p>"
    },
    {
        "id": 267,
        "code_snippet": "public Thread newThread(Runnable r) {\n\t\t\treturn new Thread(r, \"junit-timeout-thread-\" + threadNumber.getAndIncrement());\n\t\t}",
        "human_comment": "The thread factory used for preemptive timeout.\n\n<p>The factory creates threads with meaningful names, helpful for debugging\npurposes.",
        "model_generated_comment": "Returns the number of threads that can be used to create a new thread."
    },
    {
        "id": 268,
        "code_snippet": "default String canonicalName() {\n    // by default, use a random UUID so a function is never equivalent to another, even itself.\n    // this method is not required so that generated implementations (or careless ones) are not\n    // added and forgotten. for example, returning \"\" as a place-holder could cause unnecessary\n    // bugs if not replaced before release.\n    return UUID.randomUUID().toString();\n  }",
        "human_comment": "Returns the canonical name of this function, used to determine if functions are equivalent.\n<p>\nThe canonical name is used to determine whether two functions are the same when loaded by\ndifferent catalogs. For example, the same catalog implementation may be used for by two\nenvironments, \"prod\" and \"test\". Functions produced by the catalogs may be equivalent, but\nloaded using different names, like \"test.func_name\" and \"prod.func_name\".\n<p>\nNames returned by this function should be unique and unlikely to conflict with similar\nfunctions in other catalogs. For example, many catalogs may define a \"bucket\" function with a\ndifferent implementation. Adding context, like \"com.mycompany.bucket(string)\", is recommended\nto avoid unintentional collisions.\n\n@return a canonical name for this function",
        "model_generated_comment": "Returns a random UUID so that a function is never equivalent to another, even itself. // this method is not required so that generated implementations are not added and forgotten."
    },
    {
        "id": 269,
        "code_snippet": "private Location with(Object base, long offset, int length) {\n      this.isDefined = true;\n      this.memoryPage = null;\n      baseObject = base;\n      int uaoSize = UnsafeAlignedOffset.getUaoSize();\n      keyOffset = offset + uaoSize;\n      keyLength = UnsafeAlignedOffset.getSize(base, offset);\n      valueOffset = offset + uaoSize + keyLength;\n      valueLength = length - uaoSize - keyLength;\n      return this;\n    }",
        "human_comment": "This is only used for spilling",
        "model_generated_comment": "@link UnsafeAlignedOffset.getUaoSize @param base - offset - keyLength - int length - uaosize - position - distance - height - width - depth - value - length. @return true if offset is not a valid offset."
    },
    {
        "id": 270,
        "code_snippet": "public MojoExecution(Plugin plugin, String goal, String executionId) {\n        this.plugin = plugin;\n        this.goal = goal;\n        this.executionId = executionId;\n    }",
        "human_comment": "The executions to fork before this execution, indexed by the groupId:artifactId:version of the project on which\nthe forked execution are to be run and in reactor build order.",
        "model_generated_comment": "p>This method executes a @link MojoExecution/plugin>. @param goal a plugin to execute a function."
    },
    {
        "id": 271,
        "code_snippet": "LauncherDiscoveryListener NOOP = new LauncherDiscoveryListener() {\n\n\t@API(status = STABLE, since = \"1.10\")\n\tdefault void launcherDiscoveryStarted(LauncherDiscoveryRequest request) {\n\t}\n\n\t@API(status = STABLE, since = \"1.10\")\n\tdefault void launcherDiscoveryFinished(LauncherDiscoveryRequest request) {\n\t}\n\n\tdefault void engineDiscoveryStarted(UniqueId engineId) {\n\t}\n\n\tdefault void engineDiscoveryFinished(UniqueId engineId, EngineDiscoveryResult result) {\n\t}\n\n}",
        "human_comment": "Called when test discovery has finished for an engine.\n\n<p>Exceptions thrown by implementations of this method will cause the\ncomplete test discovery to be aborted.\n\n@param engineId the unique ID of the engine descriptor\n@param result the discovery result of the supplied engine\n@see EngineDiscoveryResult",
        "model_generated_comment": "@link LauncherDiscoveryListener @param launcherdiscoveryStarted(UniqueId engineId) @return 14if the request is not 1.0."
    },
    {
        "id": 272,
        "code_snippet": "void ensureAllTestMethodsAreCovered() {\n\t\tPredicate<Method> isTestMethod = method -> method.isAnnotationPresent(Test.class);\n\n\t\tList<String> methodsToTest = findMethods(getTestClass(), isTestMethod, TOP_DOWN).stream()//\n\t\t\t\t.map(Method::getName).sorted().toList();\n\n\t\tList<String> localTestMethods = findMethods(getClass(), isTestMethod, TOP_DOWN).stream()//\n\t\t\t\t.map(Method::getName).sorted().toList();\n\n\t\tassertThat(localTestMethods).containsExactlyElementsOf(methodsToTest);\n\t}",
        "human_comment": "Abstract base class for unit testing a concrete {@link ExecutionCondition}\nimplementation.\n\n<p><strong>WARNING</strong>: this abstract base class currently does not\nsupport tests in {@code @Nested} test classes within the\n{@linkplain #getTestClass() test class}, since {@link #beforeEach(TestInfo)}\ninstantiates the test class using the no-args default constructor.\n\n@since 5.1",
        "model_generated_comment": "@code localTestMethods @param method -> method.isAnnotationPresent(Test.class, TOP_DOWN) p>If a method is not found, it will be removed from the list."
    },
    {
        "id": 273,
        "code_snippet": "private void insertNewChild(T valToInsert) {\n    if (this.isLessThanOrEqualTo(valToInsert)) {\n      this.setRight(new TreeNode<>(valToInsert));\n    } else {\n      this.setLeft(new TreeNode<>(valToInsert));\n    }\n  }",
        "human_comment": "Add a new Child TreeNode of given value to self. WARNING: This method is destructive (will\noverwrite existing tree structure, if any), and should be called only by this class's insert()\nmethod.\n\n@param valToInsert Value of the new TreeNode to be inserted",
        "model_generated_comment": "@link valToInsert/@link TreeNode/> p>This method is used to insert a new child/p>. @param tree node a val-to-a-val tree."
    },
    {
        "id": 274,
        "code_snippet": "public File sslRpcKeyStore() {\n    String keyStore = conf.get(\"spark.ssl.rpc.keyStore\", null);\n    if (keyStore != null) {\n      return new File(keyStore);\n    } else {\n      return null;\n    }\n  }",
        "human_comment": "The key-store file; can be relative to the current directory",
        "model_generated_comment": "@link KeyStore @param keyStore the keystore of a ssl-rpc. @return null if the keyStore is null."
    },
    {
        "id": 275,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaQuantileDiscretizerExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(0, 18.0),\n      RowFactory.create(1, 19.0),\n      RowFactory.create(2, 8.0),\n      RowFactory.create(3, 5.0),\n      RowFactory.create(4, 2.2)\n    );\n\n    StructType schema = new StructType(new StructField[]{\n\n    Dataset<Row> df = spark.createDataFrame(data, schema);\n    df = df.repartition(1);\n    QuantileDiscretizer discretizer = new QuantileDiscretizer()\n      .setInputCol(\"hour\")\n      .setOutputCol(\"result\")\n      .setNumBuckets(3);\n\n    Dataset<Row> result = discretizer.fit(df).transform(df);\n    result.show(false);\n    spark.stop();\n  }\n}",
        "human_comment": "$example on$\n$example off$\n$example on$\n$example off$\nOutput of QuantileDiscretizer for such small datasets can depend on the number of\npartitions. Here we force a single partition to ensure consistent results.\nNote this is not necessary for normal use cases\n$example on$\n$example off$",
        "model_generated_comment": "p>SparkSession/p> @link QuantileDiscretizerExample /. @param https://github.com/sparks/java-quantilediscretizer-example.json/json>. @return if a struct is created in a new struct."
    },
    {
        "id": 276,
        "code_snippet": "public static <T> T notNull(T value, String message) {\n        if (value == null) {\n            throw new NullPointerException(message);\n        }\n        return value;\n    }",
        "human_comment": "Checks that the given value is not {@code null}, using the given message\nas the exception message if an exception is thrown.\n\n@param value object reference to check\n@param message message to use if {@code value} is {@code null}\n@return the passed-in value, if not {@code null}\n@throws NullPointerException if {@code value} is {@code null}",
        "model_generated_comment": "@link NullPointerException @param message the value of the null pointer if the value is null. @return null the message if it's null"
    },
    {
        "id": 277,
        "code_snippet": "public Map<String, List<File>> getCollisions() {\n        return collisions;\n    }",
        "human_comment": "Gets the POM files of the projects that collided.\n\n@return The POM files of the projects that collided, indexed by their g:a:v, never {@code null}.",
        "model_generated_comment": "Gets collisions from a @link Map. @return collisions if a collision occurs."
    },
    {
        "id": 278,
        "code_snippet": "public static void main(String[] args) {\n    var form = new RegisterWorkerForm(NAME, OCCUPATION, DATE_OF_BIRTH);\n    form.submit();\n  }",
        "human_comment": "The notification pattern captures information passed between layers, validates the information,\nand returns any errors to the presentation layer if needed.\n\n<p>In this code, this pattern is implemented through the example of a form being submitted to\nregister a worker. The worker inputs their name, occupation, and date of birth to the\nRegisterWorkerForm (which acts as our presentation layer), and passes it to the RegisterWorker\nclass (our domain layer) which validates it. Any errors caught by the domain layer are then\npassed back to the presentation layer through the RegisterWorkerDto.",
        "model_generated_comment": "@link RegisterWorkerForm @param name, OCCUPATION, DATE_OF_BIRTH/@link Creates a new register worker for the registered worker."
    },
    {
        "id": 279,
        "code_snippet": "public void encode(ByteBuf buf) {\n    super.encode(buf);\n    buf.writeInt(shuffleMergeId);\n    Encoders.IntArrays.encode(buf, reduceIds);\n    buf.writeInt(chunkIds.length);\n    for (int[] ids: chunkIds) {\n      Encoders.IntArrays.encode(buf, ids);\n    }\n  }",
        "human_comment": "Even though reduceIds.length == chunkIds.length, we are explicitly setting the length in the\ninterest of forward compatibility.",
        "model_generated_comment": "Encodes @link chunkIds. @param shuffleMergeId the id of the chunk Id."
    },
    {
        "id": 280,
        "code_snippet": "protected String convertSchemaPattern(final String pattern) {\n    if ((pattern == null) || pattern.isEmpty()) {\n      return convertPattern(\"%\", true);\n    } else {\n      return convertPattern(pattern, true);\n    }\n  }",
        "human_comment": "Convert wildchars and escape sequence of schema pattern from JDBC format to datanucleous/regex\nThe schema pattern treats empty string also as wildchar",
        "model_generated_comment": "Returns a @link Pattern if the pattern is empty."
    },
    {
        "id": 281,
        "code_snippet": "public final Void getRawResult() {\n\t\t\treturn null;\n\t\t}",
        "human_comment": "Always returns {@code null}.\n\n@return {@code null} always",
        "model_generated_comment": "Returns the result of a Void call. @param @link Void getRawResult()"
    },
    {
        "id": 282,
        "code_snippet": "public DefaultModelPathTranslator(PathTranslator pathTranslator) {\n        this.pathTranslator = pathTranslator;\n    }",
        "human_comment": "Resolves relative paths within a model against a specific base directory.",
        "model_generated_comment": "DefaultModelPathTranslator for @link PathTranslators."
    },
    {
        "id": 283,
        "code_snippet": "public Period extractAsPeriod() { return Period.of(0, months, days); }",
        "human_comment": "Extracts the date part of the interval.\n@return an instance of {@code java.time.Period} based on the months and days fields\nof the given interval, not null.",
        "model_generated_comment": "Returns a period of 0 months and 0 days."
    },
    {
        "id": 284,
        "code_snippet": "private static CommandLine getLikelyExecutedCommand(final CommandLine commandLine) {\n\t\treturn Optional.ofNullable(commandLine.getParseResult().subcommand()) //\n\t\t\t\t.map(parseResult -> parseResult.commandSpec().commandLine()) //\n\t\t\t\t.orElse(commandLine);\n\t}",
        "human_comment": "Get the most likely executed subcommand, if any, or the main command otherwise.\n@see <a href=\"https://picocli.info/#_executing_commands_with_subcommands\">Executing Commands with Subcommands</a>",
        "model_generated_comment": "Returns a @link Subcommand that is executed by a given command line. @param commandLine a command line a subcommand. @return a nullable if the command line is not executed by the current command line"
    },
    {
        "id": 285,
        "code_snippet": "void before() {\n\t\t\tcountBeforeInvoked++;\n\t\t\tthis.throwExceptionInAfterMethod = false;\n\t\t}",
        "human_comment": "Reset state, since the test instance is retained across all test methods;\notherwise, after() always throws an exception.",
        "model_generated_comment": "@link countBeforeInvoked++ if a method is not invoked. @param this.throwExceptionInAfterMethod the method to invoke."
    },
    {
        "id": 286,
        "code_snippet": "public static String nullSafeToString(Class<?>... classes) {\n\t\treturn nullSafeToString(Class::getName, classes);\n\t}",
        "human_comment": "Generate a comma-separated list of fully qualified class names for the\nsupplied classes.\n\n@param classes the classes whose names should be included in the\ngenerated string\n@return a comma-separated list of fully qualified class names, or an empty\nstring if the supplied class array is {@code null} or empty\n@see #nullSafeToString(Function, Class...)\n@see StringUtils#nullSafeToString(Object)",
        "model_generated_comment": "@link nullSafeToString @param className the class name of the class. @return a nullsafe toString if the class is not a valid class."
    },
    {
        "id": 287,
        "code_snippet": "private void concatPath(StringBuilder url, String path) {\n            if (path.length() > 0) {\n                boolean initialUrlEndsWithSlash = url.charAt(url.length() - 1) == '/';\n                boolean pathStartsWithSlash = path.charAt(0) == '/';\n\n                if (pathStartsWithSlash) {\n                    if (initialUrlEndsWithSlash) {\n                        url.setLength(url.length() - 1);\n                    }\n                } else if (!initialUrlEndsWithSlash) {\n                    url.append('/');\n                }\n\n                url.append(path);\n\n                if (initialUrlEndsWithSlash && !path.endsWith(\"/\")) {\n                    url.append('/');\n                }\n            }\n        }",
        "human_comment": "1 extra '/' to remove\nadd missing '/' between url and path\nensure resulting url ends with slash if initial url was",
        "model_generated_comment": "p>If @code url/code path is a string, it should be able to be inserted into a path. @param path url url path path if the path starts with a '@code path' character."
    },
    {
        "id": 288,
        "code_snippet": "public int find(UTF8String str, int start) {\n    assert (str.numBytes > 0);\n    while (start <= numBytes - str.numBytes) {\n      if (ByteArrayMethods.arrayEquals(base, offset + start, str.base, str.offset, str.numBytes)) {\n        return start;\n      }\n      start += 1;\n    }\n    return -1;\n  }",
        "human_comment": "Find the `str` from left to right.",
        "model_generated_comment": "p>Assert/p> that @code numBytes is a UTF8String. @param start - str.numBYtes. @return 0 if a byte array has a base, offset, and a starting point."
    },
    {
        "id": 289,
        "code_snippet": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 2);\n\n    GBTClassifier rf = new GBTClassifier()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setSubsamplingRate(1.0)\n      .setSeed(1234)\n      .setMaxIter(3)\n      .setStepSize(0.1)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String lossType : GBTClassifier.supportedLossTypes()) {\n      rf.setLossType(lossType);\n    }\n    GBTClassificationModel model = rf.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.totalNumNodes();\n    model.toDebugString();\n    model.trees();\n    model.treeWeights();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model3.save(sc.sc(), path);\n      GBTClassificationModel sameModel = GBTClassificationModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model3, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
        "human_comment": "This tests setters. Training with various options is tested in Scala.\nTODO: Add test once save/load are implemented.  SPARK-6725",
        "model_generated_comment": "p>Assembles a GBTClassifier/p>. @param nPoints = 20; nB = -1.5; double A = 2.0; double B = -1."
    },
    {
        "id": 290,
        "code_snippet": "public DuplicateArtifactAttachmentException(MavenProject project, Artifact artifact) {\n        super(constructMessage(project, artifact));\n        this.project = project;\n        this.artifact = artifact;\n    }",
        "human_comment": "This exception is thrown if an application attempts to attach\ntwo of the same artifacts to a single project.\n\nTODO Make this a checked exception, and modify the API of MavenProjectHelper.\nCurrently, this modification would create compatibility problems for existing plugins.",
        "model_generated_comment": "@link ArtifactAttachmentException. @param project, artifact asynchronously."
    },
    {
        "id": 291,
        "code_snippet": "void setUp() {\n\t\twhen(configuration.getDefaultDisplayNameGenerator()).thenReturn(new DisplayNameGenerator.Standard());\n\t\twhen(configuration.getDefaultExecutionMode()).thenReturn(ExecutionMode.SAME_THREAD);\n\t\twhen(configuration.getDefaultClassesExecutionMode()).thenReturn(ExecutionMode.SAME_THREAD);\n\t\twhen(configuration.getOutputDirectoryProvider()).thenReturn(dummyOutputDirectoryProvider());\n\t}",
        "human_comment": "Unit tests for concrete implementations of {@link ExtensionContext}:\n{@link JupiterEngineExtensionContext}, {@link ClassExtensionContext}, and\n{@link MethodExtensionContext}.\n\n@since 5.0",
        "model_generated_comment": "p>Configuration.getDefaultDisplayNameGenerator.Standard/p>. @param defaultExecutionMode.SAME_THREAD @code /code dummyOutputDirectoryProvider. @return the default display name generator."
    },
    {
        "id": 292,
        "code_snippet": "public void accept(Visitor visitor) {\n\t\tgetRoots().forEach(it -> accept(visitor, it));\n\t}",
        "human_comment": "Accept the supplied {@link Visitor} for a depth-first traversal of the\ntest plan.\n\n@param visitor the visitor to accept; never {@code null}\n@since 1.10",
        "model_generated_comment": "p>Assert/p> that @code visitor is a visitor."
    },
    {
        "id": 293,
        "code_snippet": "public AssertionFailureBuilder cause(Throwable cause) {\n\t\tthis.cause = cause;\n\t\treturn this;\n\t}",
        "human_comment": "Set the cause of the assertion failure.\n\n@param cause the failure cause; may be {@code null}\n@return this builder for method chaining",
        "model_generated_comment": "p>AssertionFailureBuilder/p>. @param cause @code cause."
    },
    {
        "id": 294,
        "code_snippet": "public int indexOfEmpty(int start) {\n    return 0; // TODO: Fix this behaviour (SPARK-48284)\n  }",
        "human_comment": "Returns the (default) position of the first occurrence of an empty substr in the current\nstring from the specified position (0-based index).\n\n@param start the start position of the current string for searching\n@return the position of the first occurrence of the empty substr (now, always 0)",
        "model_generated_comment": "@link IndexOfEmpty @return 0 if the index is empty. @param start the index of the empty index. @todo: Fix this behaviour (SPARK-48284)"
    },
    {
        "id": 295,
        "code_snippet": "public void whatHappensWhenASuiteContainsItselfIndirectly() {\n        Result result = JUnitCore.runClasses(Hydra.class);\n        assertEquals(2, result.getFailureCount());\n    }",
        "human_comment": "The interesting case here is that Hydra indirectly contains two copies of\nitself (if it only contains one, Java's StackOverflowError eventually\nbails us out)",
        "model_generated_comment": "p>Assert/p> that @code /code hydra.class is a JUnitCore class."
    },
    {
        "id": 296,
        "code_snippet": "public boolean isCancellable() {\n      return allowCancellation != null && allowCancellation;\n    }",
        "human_comment": "Advanced: Returns whether the interpreter is able to be cancelled.\n\n<p>Interpreters may have an experimental API <a\nhref=\"https://www.tensorflow.org/lite/api_docs/java/org/tensorflow/lite/Interpreter#setCancelled(boolean)\">setCancelled(boolean)</a>.\nIf this interpreter is cancellable and such a method is invoked, a cancellation flag will be\nset to true. The interpreter will check the flag between Op invocations, and if it's {@code\ntrue}, the interpreter will stop execution. The interpreter will remain a cancelled state\nuntil explicitly \"uncancelled\" by {@code setCancelled(false)}.",
        "model_generated_comment": "@link isCancellable @return a boolean if a cancellation is allowed. @param cancelCancellation a cancelable cancellation if the cancellation is not allowed."
    },
    {
        "id": 297,
        "code_snippet": "static ArgumentSet argumentSet(String name, Object... arguments) {\n\t\treturn new ArgumentSet(name, arguments);\n\t}",
        "human_comment": "Factory method for creating an {@link ArgumentSet} based on the supplied\n{@code name} and {@code arguments}.\n\n<p>Favor this method over {@link Arguments#of Arguments.of(...)} and\n{@link Arguments#arguments arguments(...)} when you wish to assign a name\nto the entire set of arguments.\n\n<p>This method is well suited to be used as a static import &mdash; for\nexample, via:\n{@code import static org.junit.jupiter.params.provider.Arguments.argumentSet;}.\n\n@param name the name of the argument set; must not be {@code null} or blank\n@param arguments the arguments to be used for an invocation of the test\nmethod; must not be {@code null}\n@return an {@code ArgumentSet}; never {@code null}\n@since 5.11\n@see ArgumentSet\n@see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_PLACEHOLDER\n@see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER",
        "model_generated_comment": "p>Assert/p> that the argument is @link ArgumentSet. @param name, Object name, arguments."
    },
    {
        "id": 298,
        "code_snippet": "protected String escapeSpecialCharsForLikePattern(String str) {\n    StringBuilder builder = new StringBuilder();\n\n    for (char c : str.toCharArray()) {\n      switch (c) {\n        case '_' -> builder.append(\"\\\\_\");\n        case '%' -> builder.append(\"\\\\%\");\n        default -> builder.append(c);\n      }\n    }\n\n    return builder.toString();\n  }",
        "human_comment": "Escape the special chars for like pattern.\n\nNote: This method adopts the escape representation within Spark and is not bound to any JDBC\ndialect. JDBC dialect should overwrite this API if the underlying database have more special\nchars other than _ and %.",
        "model_generated_comment": "p>Builder/p>StringBuilder @link Builder. @param str.toCharArrayStringString @return a StringBuilder that builds a char array of chars from a type like a pattern. @code '%' -> '%' // #code /code %% // @code @code #returns a string with a value of %."
    },
    {
        "id": 299,
        "code_snippet": "public static <T extends Throwable> Matcher<T> isThrowable(Matcher<T> throwableMatcher) {\n        return StacktracePrintingMatcher.isThrowable(throwableMatcher);\n    }",
        "human_comment": "@return A matcher that delegates to throwableMatcher and in addition\nappends the stacktrace of the actual Throwable in case of a mismatch.",
        "model_generated_comment": "@link Throwable/@link PrintingMatcher @param throwable @return Throwable if the matcher is not a throwable matcher. @extension Throwable is a matcher that can be used to print a printout of a document."
    },
    {
        "id": 300,
        "code_snippet": "public PrefixedConfigurationParameters(ConfigurationParameters delegate, String prefix) {\n\t\tthis.delegate = Preconditions.notNull(delegate, \"delegate must not be null\");\n\t\tthis.prefix = Preconditions.notBlank(prefix, \"prefix must not be null or blank\");\n\t}",
        "human_comment": "Create a new view of the supplied {@link ConfigurationParameters} that\n{@code null}\n@param prefix the prefix to apply to all queries; never {@code null} or\nblank",
        "model_generated_comment": "p>ConfigurationParameters/p> @param delegate, @code null @configurationparameters if the delegate is null or blank @return a delegate with a prefix that is not null and blank if it is a null delegate if a Prefix isn't null unless it's a valid prefix for the prefix."
    },
    {
        "id": 301,
        "code_snippet": "public UserAccount updateDb(final UserAccount userAccount) {\n    return writeToDb(userAccount);\n  }",
        "human_comment": "Update reecord in DB.\n\n@param userAccount {@link UserAccount}\n@return {@link UserAccount}",
        "model_generated_comment": "@link UserAccount updateDb @return a user account with a valid user account. @param userAccount the user account whose user account is updated."
    },
    {
        "id": 302,
        "code_snippet": "public static long timeStringAs(String str, TimeUnit unit) {\n    String lower = str.toLowerCase(Locale.ROOT).trim();\n\n    try {\n      Matcher m = TIME_STRING_PATTERN.matcher(lower);\n      if (!m.matches()) {\n        throw new NumberFormatException(\"Failed to parse time string: \" + str);\n      }\n\n      long val = Long.parseLong(m.group(1));\n      String suffix = m.group(2);\n\n      // Check for invalid suffixes\n      if (suffix != null && !timeSuffixes.containsKey(suffix)) {\n        throw new NumberFormatException(\"Invalid suffix: \\\"\" + suffix + \"\\\"\");\n      }\n\n      // If suffix is valid use that, otherwise none was provided and use the default passed\n      return unit.convert(val, suffix != null ? timeSuffixes.get(suffix) : unit);\n    } catch (NumberFormatException e) {\n      String timeError = \"Time must be specified as seconds (s), \" +\n              \"milliseconds (ms), microseconds (us), minutes (m or min), hour (h), or day (d). \" +\n              \"E.g. 50s, 100ms, or 250us.\";\n\n      throw new NumberFormatException(timeError + \"\\n\" + e.getMessage());\n    }\n  }",
        "human_comment": "Convert a passed time string (e.g. 50s, 100ms, or 250us) to a time count in the given unit.\nThe unit is also considered the default if the given string does not specify a unit.",
        "model_generated_comment": "@link TimeStringAs @param timeString @return null if no valid suffixes are provided if the value is null. p>Failed to parse time as a time string if e.g. 50s, 100ms, or 250us."
    },
    {
        "id": 303,
        "code_snippet": "void updateUserName(String userName, UpdateUserCallback callback) {\n        final WeakReference<UpdateUserCallback> updateUserCallback = new WeakReference<>(callback);\n\n        final User user = mCachedUser == null\n                ? new User(userName)\n                : new User(mCachedUser.getId(), userName);\n\n        // update the user on the I/O thread\n        mAppExecutors.diskIO().execute(() -> {\n            mUserDataSource.insertOrUpdateUser(user);\n            mCachedUser = user;\n            // notify on the main thread\n            mAppExecutors.mainThread().execute(() -> {\n                UpdateUserCallback userCallback = updateUserCallback.get();\n                if (userCallback != null) {\n                    userCallback.onUserUpdated(user);\n                }\n            });\n        });\n    }",
        "human_comment": "Insert an new user or update the name of the user.\n\n@param userName the user name\n@param callback callback that gets triggered when the user was updated.",
        "model_generated_comment": "Updates the user on the I/O thread mAppExecutors.mainThread()."
    },
    {
        "id": 304,
        "code_snippet": "public boolean onKeyDown(int keyCode, KeyEvent event) {\n    int moveOffset = 0;\n    switch (keyCode) {\n      case KeyEvent.KEYCODE_DPAD_LEFT:\n        moveOffset = -1;\n        break;\n      case KeyEvent.KEYCODE_DPAD_RIGHT:\n        moveOffset = 1;\n        break;\n      case KeyEvent.KEYCODE_DPAD_UP:\n        moveOffset = -1 * grid.getNumColumns();\n        break;\n      case KeyEvent.KEYCODE_DPAD_DOWN:\n        moveOffset = grid.getNumColumns();\n        break;\n      default:\n        return super.onKeyDown(keyCode, event);\n    }\n\n    int currentSelect = 0;\n    float highestValue = 0;\n    for (int i = 0; i < adapter.getCount(); i++) {\n      if (adapter.items[i].value > highestValue) {\n        currentSelect = i;\n        highestValue = adapter.items[i].value;\n      }\n    }\n    setStyle(adapter.items[(currentSelect + moveOffset + adapter.getCount()) % adapter.getCount()], 1);\n\n    return true;\n  }",
        "human_comment": "get the highest selected style",
        "model_generated_comment": "@link KeyEvent @param keyCode the keycode of the key event. @return a boolean onKeyDown if the key code is a keyEvent."
    },
    {
        "id": 305,
        "code_snippet": "public static StructType createStructType(List<StructField> fields) {\n    return createStructType(fields.toArray(new StructField[fields.size()]));\n  }",
        "human_comment": "Creates a StructType with the given list of StructFields ({@code fields}).",
        "model_generated_comment": "Creates a new StructType from a list of fields. @param fields @code fields. @return a structstructType from an array of fields whose size is the smallest of the arrays."
    },
    {
        "id": 306,
        "code_snippet": "public TestIdentifier getTestIdentifier(UniqueId uniqueId) {\n\t\tPreconditions.notNull(uniqueId, () -> \"uniqueId must not be null\");\n\t\treturn Preconditions.notNull(allIdentifiers.get(uniqueId),\n\t\t\t() -> \"No TestIdentifier with unique ID [\" + uniqueId + \"] has been added to this TestPlan.\");\n\t}",
        "human_comment": "Get the {@link TestIdentifier} with the supplied unique ID.\n\n@param uniqueId the unique ID to look up the identifier for; never\n{@code null}\n@return the identifier with the supplied unique ID; never {@code null}\n@throws PreconditionViolationException if no {@code TestIdentifier}\nwith the supplied unique ID is present in this test plan",
        "model_generated_comment": "TestIdentifier with unique ID has been added to this TestPlan."
    },
    {
        "id": 307,
        "code_snippet": "public OffHeapColumnVector(int capacity, DataType type) {\n    super(capacity, type);\n\n    nulls = 0;\n    data = 0;\n    lengthData = 0;\n    offsetData = 0;\n\n    reserveInternal(capacity);\n    reset();\n  }",
        "human_comment": "The data stored in these two allocations need to maintain binary compatible. We can\ndirectly pass this buffer to external components.\nOnly set if type is Array or Map.",
        "model_generated_comment": "@link Capacity/@link DataType type. @param data type the data type of a column. @reset the datatype of the column."
    },
    {
        "id": 308,
        "code_snippet": "void testWatcherSemanticsWhenRegisteredAtInstanceLevelWithTestInstanceLifecyclePerMethod() {\n\t\tClass<?> testClass = TestInstancePerMethodInstanceLevelTestWatcherTestCase.class;\n\t\tassertStatsForAbstractDisabledMethodsTestCase(testClass);\n\n\t\tassertThat(TrackingTestWatcher.results.get(\"testDisabled\")).containsExactly(\"test\");\n\t}",
        "human_comment": "Since the TestWatcher is registered at the instance level with test instance\nlifecycle per-method semantics, we get a \"testDisabled\" event only for the @Test\nmethod and NOT for the @RepeatedTest container.",
        "model_generated_comment": "TestWatcherSemanticsWhenRegisteredAtInstanceLevelWithTestInstanceLifecyclePerMethod() p>TestWatcherTestCase/p>"
    },
    {
        "id": 309,
        "code_snippet": "public static ConditionEvaluationResult enabled(String reason) {\n\t\treturn new ConditionEvaluationResult(true, reason);\n\t}",
        "human_comment": "Factory for creating <em>enabled</em> results.\n\n@param reason the reason why the container or test should be enabled\n@return an enabled {@code ConditionEvaluationResult} with the given reason",
        "model_generated_comment": "Returns a ConditionEvaluationResult with a reason."
    },
    {
        "id": 310,
        "code_snippet": "public ColumnarBatch(ColumnVector[] columns, int numRows) {\n    this.columns = columns;\n    this.numRows = numRows;\n    this.row = new ColumnarBatchRow(columns);\n  }",
        "human_comment": "Create a new batch from existing column vectors.\n@param columns The columns of this batch\n@param numRows The number of rows in this batch",
        "model_generated_comment": "ColumnarBatchRow(ColumnVector[] columns, int numRows)."
    },
    {
        "id": 311,
        "code_snippet": "private static File getLocalRepoFile(Verifier verifier) {\n        return new File(verifier.getArtifactPath(\"org.apache.maven\", \"maven-core-it-support\", \"1.0-SNAPSHOT\", \"jar\"));\n    }",
        "human_comment": "this is to delete metadata - TODO: incorporate into deleteArtifact in verifier",
        "model_generated_comment": "p>Verifier/p>Application/a> @link Maven-core-it-support. @param org.apache.maven /."
    },
    {
        "id": 312,
        "code_snippet": "default Optional<String> getString(@Nonnull URI relativeSource) {\n        return getString(relativeSource, StandardCharsets.UTF_8);\n    }",
        "human_comment": "GETs the source URI content as string using UTF8 charset. The source MUST BE relative from the\n{@link RemoteRepository#getUrl()} root.\n\n@return the string if operation succeeded, {@code null} if source does not exist.\n@throws RuntimeException If failed (and not due source not exists).",
        "model_generated_comment": "Returns the value of the URI relativeSource. @param relativeSource URI the source of a @code URI. @return the value URI URI that is the relative source of the source URI. @optionalString(@Nonnull URI)"
    },
    {
        "id": 313,
        "code_snippet": "void allAreIn(JavaClasses classes) {\n\t\tassertTrue(classes.size() > 800, \"expected more than 800 classes, got: \" + classes.size());\n\t}",
        "human_comment": "about 928 classes found in all jars",
        "model_generated_comment": "p>Assert/p>JavaClasses that the class size is greater than 800."
    },
    {
        "id": 314,
        "code_snippet": "public LifecyclePhaseNotFoundException(String message, String lifecyclePhase) {\n        super(message);\n        this.lifecyclePhase = (lifecyclePhase != null) ? lifecyclePhase : \"\";\n    }",
        "human_comment": "Creates a new exception to indicate that the specified lifecycle phase is not defined by any known lifecycle.\n\n@param message The detail message, may be {@code null}.\n@param lifecyclePhase The name of the lifecycle phase that could not be located, may be {@code null}.",
        "model_generated_comment": "@link message/@link LifecyclePhaseNotFoundException if a message is not found. @param message the message that the message is sent. @return the message if the message has not been sent."
    },
    {
        "id": 315,
        "code_snippet": "public static Tensor<Float> create(float data) {\n    return Tensor.create(data, Float.class);\n  }",
        "human_comment": "Creates a scalar tensor containing a single {@code float} element.\n\n@param data The value to put into the new scalar tensor.",
        "model_generated_comment": "Creates a static Tensor using @link Data. @param data float data a float of the float. @return a new static Tension."
    },
    {
        "id": 316,
        "code_snippet": "public Car(String manufacturer, String model, int noOfPassengers, int engineCapacity) {\n    super(manufacturer, model, noOfPassengers);\n    this.engineCapacity = engineCapacity;\n  }",
        "human_comment": "A class that extends the PassengerVehicle class and provides the concrete inheritance\nimplementation of the Car.\n\n@see PassengerVehicle PassengerVehicle\n@see Vehicle Vehicle",
        "model_generated_comment": "@link manufacturer/@link engineCapacity @param model, model, noOfPassengers/> p>Manufacturer/p>"
    },
    {
        "id": 317,
        "code_snippet": "public static void main(String[] args) {\n    BlocUi blocUi = new BlocUi();\n    blocUi.createAndShowUi();\n  }",
        "human_comment": "The entry point of the application. Initializes the GUI.\n\n@param args command-line arguments (not used in this example)",
        "model_generated_comment": "BlocUi is a @link BlocUI function."
    },
    {
        "id": 318,
        "code_snippet": "private void testAllDaysWithoutDefaultObserver(final Weekday specialDay, final Event event) {\n    final var observer1 = mock(EventObserver.class);\n    final var observer2 = mock(EventObserver.class);\n\n    final var emitter = this.factoryWithoutDefaultObserver.get();\n    emitter.registerObserver(observer1, event);\n    emitter.registerObserver(observer2, event);\n\n    testAllDays(specialDay, event, emitter, observer1, observer2);\n  }",
        "human_comment": "Go over every day of the month, and check if the event is emitted on the given day. Use an\nevent emitter without a default observer\n\n@param specialDay The special day on which an event is emitted\n@param event The expected event emitted by the test object",
        "model_generated_comment": "p>EventObserver/p>TestAllDaysWithoutDefaultObserver(final Weekday specialDay, final Event event)."
    },
    {
        "id": 319,
        "code_snippet": "static DiscoveryIssueReporter forwarding(EngineDiscoveryListener engineDiscoveryListener, UniqueId engineId) {\n\t\tPreconditions.notNull(engineDiscoveryListener, \"engineDiscoveryListener must not be null\");\n\t\tPreconditions.notNull(engineId, \"engineId must not be null\");\n\t\treturn issue -> engineDiscoveryListener.issueEncountered(engineId, issue);\n\t}",
        "human_comment": "Create a new {@code DiscoveryIssueReporter} that reports issues to the\n\n@param engineDiscoveryListener the listener to report issues to; never\n{@code null}\n@param engineId the unique identifier of the engine; never {@code null}",
        "model_generated_comment": "p>EngineDiscoveryListener/p>EmployeeIssueReporter."
    },
    {
        "id": 320,
        "code_snippet": "private void assertChecksum(String checksum, Properties checksums) {\n        assertEquals(checksum, checksums.getProperty(\"dep-0.1.jar\").toLowerCase(java.util.Locale.ENGLISH));\n    }",
        "human_comment": "Verify that repositories declared in the POM are accessed in their declaration order.\n\n@throws Exception in case of failure",
        "model_generated_comment": "p>Assert/p> that the checksums are equal."
    },
    {
        "id": 321,
        "code_snippet": "private void gameLoop() {\n    while (isRunning) {\n      processInput();\n      update();\n      render();\n    }\n  }",
        "human_comment": "Main game loop. This loop will always run until the game is over. For each loop it will process\nuser input, update internal status, and render the next frames. For more detail please refer to\nthe game-loop pattern.",
        "model_generated_comment": "@link gameLoop/@link isRunning. p>Also, if a game is running, it will not be able to run it. @param https://github.com/gameloop//p>"
    },
    {
        "id": 322,
        "code_snippet": "public void setExecutions(java.util.List<Execution> executions) {\n        this.executions = executions;\n    } // -- void setExecutions( java.util.List )",
        "human_comment": "Set the goals to execute within the phase.\n\n@param executions a executions object.",
        "model_generated_comment": "Sets the executions of java.util.Executions. @param executions the executed executions."
    },
    {
        "id": 323,
        "code_snippet": "public ModelBuildingException(Model model, String modelId, List<ModelProblem> problems) {\n        super(toMessage(modelId, problems));\n\n        if (model != null) {\n            DefaultModelBuildingResult tmp = new DefaultModelBuildingResult();\n            if (modelId == null) {\n                modelId = \"\";\n            }\n            tmp.addModelId(modelId);\n            tmp.setRawModel(modelId, model);\n            tmp.setProblems(problems);\n            result = tmp;\n        } else {\n            result = null;\n        }\n    }",
        "human_comment": "Creates a new exception with the specified problems.\n\n@param model The model that could not be built, may be {@code null}.\n@param modelId The identifier of the model that could not be built, may be {@code null}.\n@param problems The problems that causes this exception, may be {@code null}.\n@deprecated Use {@link #ModelBuildingException(ModelBuildingResult)} instead.",
        "model_generated_comment": "@link ModelBuildingException @param modelId modelProblems if the model Id is null, if it is not null the model will be created. @return the DefaultModelBuildingError if a model is a null model."
    },
    {
        "id": 324,
        "code_snippet": "public static void assertEquals(String message, double expected, double actual, double delta) {\n        Assert.assertEquals(message, expected, actual, delta);\n    }",
        "human_comment": "Asserts that two doubles are equal concerning a delta.  If they are not\nan AssertionFailedError is thrown with the given message.  If the expected\nvalue is infinity then the delta value is ignored.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code delta are equal."
    },
    {
        "id": 325,
        "code_snippet": "public Variant getElementAtIndex(int index) {\n    return handleArray(value, pos, (size, offsetSize, offsetStart, dataStart) -> {\n      if (index < 0 || index >= size) return null;\n      int offset = readUnsigned(value, offsetStart + offsetSize * index, offsetSize);\n      return new Variant(value, metadata, dataStart + offset);\n    });\n  }",
        "human_comment": "Get the array element at the `index` slot. Return null if `index` is out of the bound of\n`[0, arraySize())`.\nIt is only legal to call it when `getType()` is `Type.ARRAY`.",
        "model_generated_comment": "Returns the value of @code offset. @param offsetSize the offset of the element."
    },
    {
        "id": 326,
        "code_snippet": "public static void assertNotEquals(Double unexpected, Double actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n@since 5.4",
        "model_generated_comment": "Asserts that @code unexpected and/@code actual are equal. @param unexpected, double actual are not equal."
    },
    {
        "id": 327,
        "code_snippet": "public void setStringToIntColumn(java.util.Map<java.lang.String,java.lang.Integer> value) {\n    this.string_to_int_column = value;\n  }",
        "human_comment": "Sets the value of the 'string_to_int_column' field.\n@param value the value to set.",
        "model_generated_comment": "Sets a java.lang.String to an int-column value."
    },
    {
        "id": 328,
        "code_snippet": "public void write(Object data, SelectionKey key) {\n    super.write(data, key);\n  }",
        "human_comment": "Writes the outgoing {@link DatagramPacket} to the channel. The intended receiver of the\ndatagram packet must be set in the <code>data</code> using {@link\nDatagramPacket#setReceiver(SocketAddress)}.",
        "model_generated_comment": "p>Assembles a @link SelectionKey/p> object to write to. @param data, SelectionKey key the key of the selection."
    },
    {
        "id": 329,
        "code_snippet": "protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n        validateZeroArgConstructor(errors);\n    }",
        "human_comment": "Adds to {@code errors} if the test class has more than one constructor,\nor if the constructor takes parameters. Override if a subclass requires\ndifferent validation rules.",
        "model_generated_comment": "@link Validate a Constructor/@link Errors. @param error if a constructor is not a valid constructor."
    },
    {
        "id": 330,
        "code_snippet": "public final int getRemainingElementsCount() {\n    var counter = 0;\n    for (var ignored : this) {\n      counter++;\n    }\n    return counter;\n  }",
        "human_comment": "Find the count of remaining objects of current iterable.\n\n@return the count of remaining objects of the current Iterable",
        "model_generated_comment": "Returns the remaining element count. @param @code 0. @return the remaining elements count"
    },
    {
        "id": 331,
        "code_snippet": "public static OS current() {\n\t\treturn CURRENT_OS;\n\t}",
        "human_comment": "Get the current operating system.\n\n@since 5.9",
        "model_generated_comment": "Returns the current state of the current OS. @param @link CURRENT_OS. @return the current status of the OS."
    },
    {
        "id": 332,
        "code_snippet": "public void testErrorRetry() {\n    ErrorHandler.BlockPushErrorHandler pushHandler = new ErrorHandler.BlockPushErrorHandler();\n    assertFalse(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.TOO_LATE_BLOCK_PUSH, \"\")));\n    assertFalse(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.TOO_OLD_ATTEMPT_PUSH, \"\")));\n    assertFalse(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.STALE_BLOCK_PUSH, \"\")));\n    assertFalse(pushHandler.shouldRetryError(new RuntimeException(new ConnectException())));\n    assertTrue(pushHandler.shouldRetryError(new BlockPushNonFatalFailure(\n      ReturnCode.BLOCK_APPEND_COLLISION_DETECTED, \"\")));\n    assertTrue(pushHandler.shouldRetryError(new Throwable()));\n\n    ErrorHandler.BlockFetchErrorHandler fetchHandler = new ErrorHandler.BlockFetchErrorHandler();\n    assertFalse(fetchHandler.shouldRetryError(new RuntimeException(\n      ErrorHandler.BlockFetchErrorHandler.STALE_SHUFFLE_BLOCK_FETCH)));\n  }",
        "human_comment": "Test suite for {@link ErrorHandler}",
        "model_generated_comment": "ErrorRetryError @link BlockPushNonFatalFailure @param blockPushnon-fatal failure @return Code.TOO_LATE_BLOCK_PUSH if a block is pushed to a new block."
    },
    {
        "id": 333,
        "code_snippet": "protected final boolean getLookingForStuckThread() {\n        return lookForStuckThread;\n    }",
        "human_comment": "Gets whether this {@code Timeout} will look for a stuck thread\nwhen the test times out.\n\n@since 4.12",
        "model_generated_comment": "Returns a @link lookForStuckThread function."
    },
    {
        "id": 334,
        "code_snippet": "public record RetryParams(int numOfRetries, long retryDuration) {\n  public static final RetryParams DEFAULT = new RetryParams(3, 30000L);\n}",
        "human_comment": "Record to hold the parameters related to retries.\n\n@param numOfRetries number of retries\n@param retryDuration retry duration",
        "model_generated_comment": "RetryParams is a @link Retry function. @param numOfRetries, long retryDuration."
    },
    {
        "id": 335,
        "code_snippet": "void postProcessorAndPreDestroyCallbacks() {\n\t\t// @formatter:off\n\t\tassertPostProcessorAndPreDestroyCallbacks(TopLevelTestCase.class,\n\t\t\t\"fooPostProcessTestInstance\",\n\t\t\t\"barPostProcessTestInstance\",\n\t\t\t\t\"test-1\",\n\t\t\t\"barPreDestroyTestInstance\",\n\t\t\t\"fooPreDestroyTestInstance\"\n\t\t);\n\t\t// @formatter:on\n\t}",
        "human_comment": "Integration tests that verify support for {@link TestInstancePostProcessor}\nand {@link TestInstancePreDestroyCallback} in the {@link JupiterTestEngine}.\n\n@since 5.6",
        "model_generated_comment": "@formatter:off postProcessorAndPreDestroyCallbacks() @link TopLevelTestCase.class @param test-1, test-2, test-3, test-4, test-5, test-6, test-7, test-8, test-9, test-10, test-11, test-12, test-15, test-16, test-20, test-21, test-22, test-25, test-30, test-40, test-50, test-60, test-80, and test-100."
    },
    {
        "id": 336,
        "code_snippet": "public static void assertNotEquals(Short unexpected, Short actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "p>Assert/p> that @code unexpected and /code actual are not equal. @param message Unexpected are equal."
    },
    {
        "id": 337,
        "code_snippet": "public FluentIterable<E> last(int count) {\n    return new LazyFluentIterable<>() {\n        return new DecoratingIterator<>(iterable.iterator()) {\n            if (currentIndex >= stopIndex && fromIterator.hasNext()) {\n              return fromIterator.next();\n            }\n            return null;\n          }\n\n          private void initialize() {\n            if (list == null) {\n              list = new ArrayList<>();\n              iterable.forEach(list::add);\n              totalElementsCount = list.size();\n              stopIndex = totalElementsCount - count;\n            }\n          }\n        };\n      }",
        "human_comment": "Can be used to collect objects from the Iterable. Is a terminating operation. This operation is\nmemory intensive, because the contents of this Iterable are collected into a List, when the\nnext object is requested.\n\n@param count defines the number of objects to return\n@return the same FluentIterable with a collection decimated to a maximum of 'count' last\nobjects",
        "model_generated_comment": "Returns a @link LazyFluentIterable. @param stopIndex && fromIterator.hasNext()."
    },
    {
        "id": 338,
        "code_snippet": "public static void main(String[] args) {\n    Function<Integer, Integer> timesTwo = x -> x * 2;\n    Function<Integer, Integer> square = x -> x * x;\n\n    Function<Integer, Integer> composedFunction =\n        FunctionComposer.composeFunctions(timesTwo, square);\n\n    int result = composedFunction.apply(3);\n    LOGGER.info(\"Result of composing 'timesTwo' and 'square' functions applied to 3 is: \" + result);\n  }",
        "human_comment": "Main method to demonstrate function composition using FunctionComposer.\n\n@param args command line arguments (not used)",
        "model_generated_comment": "p>Composes @code /p>/code args. @param timesTwo and'square' functions."
    },
    {
        "id": 339,
        "code_snippet": "public void testSimpleBagAdd() {\n        IMoney expected = MoneyBag.create(new Money(26, \"CHF\"), new Money(7, \"USD\"));\n        assertEquals(expected, f14CHF.add(fMB1));\n    }",
        "human_comment": "[14 CHF] + {[12 CHF][7 USD]} == {[26 CHF][7 USD]}",
        "model_generated_comment": "@code f14CHF @param moneyBag.create(f14USD) @returns a new MoneyBug if it's not already created. p>Assert that the new money is a simple money-bag, and the new Money(27, \"CHF\") are the same as the original money. @code https://github.com/simple-bag-add()/p>"
    },
    {
        "id": 340,
        "code_snippet": "public void testSuiteStarted(Description description) {\n\t\tRunnerTestDescriptor runnerTestDescriptor = testRun.getRunnerTestDescriptor();\n\t\tif (!runnerTestDescriptor.getDescription().equals(description)) {\n\t\t\ttestStarted(lookupOrRegisterNextTestDescriptor(description), EventType.REPORTED);\n\t\t}\n\t}",
        "human_comment": "runnerTestDescriptor is reported in testRunStarted",
        "model_generated_comment": "TestSuiteStarted(Description description)/a> @link RunnerTestDescriptor @param description description @return a runner test descriptor if the description is not available."
    },
    {
        "id": 341,
        "code_snippet": "public static void assertTimeoutPreemptively(Duration timeout, Executable executable, String message) {\n\t\tAssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable, message);\n\t}",
        "human_comment": "<em>Assert</em> that execution of the supplied {@code executable}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>See the {@linkplain Assertions Preemptive Timeouts} section of the\nclass-level Javadoc for further details.\n\n<p>Fails with the supplied failure {@code message}.\n\n@see #assertTimeoutPreemptively(Duration, Executable)\n@see #assertTimeoutPreemptively(Duration, Executable, Supplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, String)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeout(Duration, Executable, String)",
        "model_generated_comment": "p>Assert/p> that the @link Executable/@link TimeoutPreemptively is a timeout preemptive for em>duration timeout."
    },
    {
        "id": 342,
        "code_snippet": "public int hashCode() {\n        return Objects.hash(\n                directory,\n                includes,\n                excludes,\n                scope,\n                language,\n                moduleName,\n                targetVersion,\n                targetPath,\n                stringFiltering,\n                enabled);\n    }",
        "human_comment": "{@return a hash code value computed from all properties}.",
        "model_generated_comment": "Returns a @code directory object with a name of the module. @param moduleName, targetVersion, targetPath, targetFiltering, enabled."
    },
    {
        "id": 343,
        "code_snippet": "public static void assertNotEquals(Double unexpected, Double actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Inequality imposed by this method is consistent with\n{@link Double#equals(Object)} and {@link Double#compare(double, double)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "p>Assert/p> that @code unexpected and /code actual are equal."
    },
    {
        "id": 344,
        "code_snippet": "public VectorizedRleValuesReader() {\n    this.fixedWidth = false;\n    this.readLength = false;\n  }",
        "human_comment": "A values reader for Parquet's run-length encoded data. This is based off of the version in\nparquet-mr with these changes:\n- Supports the vectorized interface.\n- Works on byte arrays(byte[]) instead of making byte streams.\n\nThis encoding is used in multiple places:\n- Definition/Repetition levels\n- Dictionary ids.\n- Boolean type values of Parquet DataPageV2",
        "model_generated_comment": "@link VectorizedRleValuesReader. @param readLength = true if the value is not fixed."
    },
    {
        "id": 345,
        "code_snippet": "private static String getOsFamily() {\n        return Stream.of(\n                        FAMILY_DOS,\n                        FAMILY_MAC,\n                        FAMILY_NETWARE,\n                        FAMILY_NT,\n                        FAMILY_OPENVMS,\n                        FAMILY_OS2,\n                        FAMILY_OS400,\n                        FAMILY_TANDEM,\n                        FAMILY_UNIX,\n                        FAMILY_WIN9X,\n                        FAMILY_WINDOWS,\n                        FAMILY_ZOS,\n                        FAMILY_UNKNOWN)\n                .filter(Os::isFamily)\n                .findFirst()\n                .orElse(null);\n    }",
        "human_comment": "Helper method to determine the current OS family.\n\n@return name of current OS family.",
        "model_generated_comment": "@link Os::isFamily @param FAMILY_DOS, MAC, NETWARE, NT, OPENVMS, OS2, OS400, UNIX, Windows, Mac, Linux, Unix, Microsoft, etc."
    },
    {
        "id": 346,
        "code_snippet": "public boolean verboseMetrics() {\n    return conf.getBoolean(SPARK_NETWORK_VERBOSE_METRICS, false);\n  }",
        "human_comment": "Whether to track Netty memory detailed metrics. If true, the detailed metrics of Netty\nPoolByteBufAllocator will be gotten, otherwise only general memory usage will be tracked.",
        "model_generated_comment": "@link VerboseMetrics @return a boolean containing the verbosity of a given string. @param verboses a string containing a number of booles."
    },
    {
        "id": 347,
        "code_snippet": "static Builder mvnenc(@Nonnull String[] args, @Nonnull MessageBuilderFactory messageBuilderFactory) {\n        return mvnenc(Arrays.asList(args), messageBuilderFactory);\n    }",
        "human_comment": "Creates a new Builder instance for constructing a Maven Encrypting Tool ParserRequest.\n\n@param args the command-line arguments\n@param messageBuilderFactory the factory for creating message builders\n@return a new Builder instance",
        "model_generated_comment": "@link MessageBuilderFactory @return a mvnenc constructor for a message builder. @param args messageBuilder is a non-null constructor."
    },
    {
        "id": 348,
        "code_snippet": "void testToString() {\n    var heroStatA = HeroStat.valueOf(3, 9, 2);\n    var heroStatB = HeroStat.valueOf(3, 9, 2);\n    var heroStatC = HeroStat.valueOf(3, 9, 8);\n    assertEquals(heroStatA.toString(), heroStatB.toString());\n    assertNotEquals(heroStatA.toString(), heroStatC.toString());\n  }",
        "human_comment": "The toString() for two equal values must be the same. For two non-equal values it must be\ndifferent.",
        "model_generated_comment": "p>HeroStatA/p>String the value of the @link herostat. @param heroStateA a@code herostatB/a/b/c> if the value is not equal, the value should be equal to the value that the hero is assigned to."
    },
    {
        "id": 349,
        "code_snippet": "public <V> Promise<V> thenApply(Function<? super T, V> func) {\n    Promise<V> dest = new Promise<>();\n    fulfillmentAction = new TransformAction<>(this, dest, func);\n    return dest;\n  }",
        "human_comment": "Returns a new promise that, when this promise is fulfilled normally, is fulfilled with result\nof this promise as argument to the function provided.\n\n@param func function to be executed.\n@return a new promise.",
        "model_generated_comment": "@link Promise/@link TransformAction/! @param PromiseActionAction() if a Promise is a func."
    },
    {
        "id": 350,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaRobustScalerExample\")\n      .getOrCreate();\n\n    Dataset<Row> dataFrame =\n      spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    RobustScaler scaler = new RobustScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\")\n      .setWithScaling(true)\n      .setWithCentering(false)\n      .setLower(0.25)\n      .setUpper(0.75);\n\n    RobustScalerModel scalerModel = scaler.fit(dataFrame);\n\n    Dataset<Row> scaledData = scalerModel.transform(dataFrame);\n    scaledData.show();\n    spark.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nCompute summary statistics by fitting the RobustScaler\nTransform each feature to have unit quantile range.\n$example off$",
        "model_generated_comment": "p>SparkSession/p> @link SparkScalerExample @param dataFrame em>Analyzes a.p>JavaRobustScalers/Em> a sample of a Robust Scaler. a href=\"https://github.com/spark-scaler-example.jsp\">/a>@codes /hres>"
    },
    {
        "id": 351,
        "code_snippet": "private RenameColumn(String[] fieldNames, String newName) {\n      this.fieldNames = fieldNames;\n      this.newName = newName;\n    }",
        "human_comment": "A TableChange to rename a field.\n<p>\nThe name is used to find the field to rename. The new name will replace the leaf field name.\nFor example, renameColumn(\"a.b.c\", \"x\") should produce column a.b.x.\n<p>\nIf the field does not exist, the change must result in an {@link IllegalArgumentException}.",
        "model_generated_comment": "@param fieldNames @link newName p>This is a renamed column with a new name. @renamecolumn newName = newName /p>"
    },
    {
        "id": 352,
        "code_snippet": "public static TwoPartSplitResult splitIntoTwo(String separator, String value) {\n\t\tPreconditions.notNull(separator, \"separator must not be null\");\n\t\tPreconditions.notNull(value, \"value must not be null\");\n\t\treturn splitIntoTwo(value, value.indexOf(separator), separator.length());\n\t}",
        "human_comment": "Split the supplied {@link String} into up to two parts using the supplied\nseparator string.\n\n@param separator the separator string; never {@code null}\n@param value the value to split; never {@code null}\n@since 1.11",
        "model_generated_comment": "Returns a two-part split result. @param value @code null if the separator is not null."
    },
    {
        "id": 353,
        "code_snippet": "public static LoggingListener forBiConsumer(BiConsumer<Throwable, Supplier<String>> logger) {\n\t\treturn new LoggingListener(logger);\n\t}",
        "human_comment": "Create a {@code LoggingListener} which delegates to the supplied\n{@link BiConsumer} for consumption of logging messages.\n\n<p>The {@code BiConsumer's} arguments are a {@link Throwable} (potentially\n{@code null}) and a {@link Supplier} (never {@code null}) for the log\nmessage.\n\n@param logger a logger implemented as a {@code BiConsumer};\nnever {@code null}\n\n@see #forJavaUtilLogging()\n@see #forJavaUtilLogging(Level)",
        "model_generated_comment": "Returns a LoggingListener for a logger."
    },
    {
        "id": 354,
        "code_snippet": "public static void assertTrue(BooleanSupplier booleanSupplier, Supplier<String> messageSupplier) {\n\t\tAssertTrue.assertTrue(booleanSupplier, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that the boolean condition supplied by {@code booleanSupplier} is {@code true}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "Asserts that the supplied value is true."
    },
    {
        "id": 355,
        "code_snippet": "default CustomTaskMetric[] currentMetricsValues() {\n    return new CustomTaskMetric[]{};\n}",
        "human_comment": "Returns an array of custom task metrics. By default it returns empty array. Note that it is\nnot recommended to put heavy logic in this method as it may affect writing performance.",
        "model_generated_comment": "CustomTaskMetricsValues() is a method that returns a new @link TestMetric value."
    },
    {
        "id": 356,
        "code_snippet": "public MultiModuleCollectionStrategy(ModelProcessor modelProcessor, ProjectsSelector projectsSelector) {\n        this.modelProcessor = modelProcessor;\n        this.projectsSelector = projectsSelector;\n    }",
        "human_comment": "Strategy for collecting Maven projects from the multi-module project root, even when executed in a submodule.",
        "model_generated_comment": "ModelProcessor, ProjectsSelector @link MultiModuleCollectionStrategy. p>Models that are used to create a multi-module collection."
    },
    {
        "id": 357,
        "code_snippet": "public static boolean isAssignableTo(Object obj, Class<?> targetType) {\n\t\tPreconditions.notNull(targetType, \"target type must not be null\");\n\n\t\tif (obj == null) {\n\t\t\treturn !targetType.isPrimitive();\n\t\t}\n\n\t\tif (targetType.isInstance(obj)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (targetType.isPrimitive()) {\n\t\t\tClass<?> sourceType = obj.getClass();\n\t\t\treturn sourceType == primitiveToWrapperMap.get(targetType) || isWideningConversion(sourceType, targetType);\n\t\t}\n\n\t\treturn false;\n\t}",
        "human_comment": "Determine if the supplied object can be assigned to the supplied target\ntype for the purpose of reflective method invocations.\n\n<p>In contrast to {@link Class#isInstance(Object)}, this method returns\n{@code true} if the target type represents a primitive type whose wrapper\nmatches the supplied object's type. In addition, this method also supports\n<a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2\">\nwidening conversions</a> for primitive types and their corresponding\nwrapper types.\n\n<p>If the supplied object is {@code null} and the supplied type does not\nrepresent a primitive type, this method returns {@code true}.\n\n@param obj the object to test for assignment compatibility; potentially {@code null}\n@param targetType the type to check against; never {@code null}\n@return {@code true} if the object is assignment compatible\n@see Class#isInstance(Object)\n@see Class#isAssignableFrom(Class)\n@see #isAssignableTo(Class, Class)",
        "model_generated_comment": "@link TargetType @param targetType obj @return true if the target type is not null if it's not a boolean object. @code targetType is a primitive to be assigned to a wrapper map if a class is omitted from the wrapperMap if there's a target type in the class."
    },
    {
        "id": 358,
        "code_snippet": "public void moveBullet(float offset) {\n    var currentPosition = bullet.getPosition();\n    bullet.setPosition(currentPosition + offset);\n  }",
        "human_comment": "Move bullet position by the provided offset.\n\n@param offset moving offset",
        "model_generated_comment": "@link currentPosition @param offset the current position of a bullet."
    },
    {
        "id": 359,
        "code_snippet": "public UTF8String substring(final int start, final int until) {\n    if (until <= start || start >= numBytes) {\n      return EMPTY_UTF8;\n    }\n\n    int i = 0;\n    int c = 0;\n    while (i < numBytes && c < start) {\n      i += numBytesForFirstByte(getByte(i));\n      c += 1;\n    }\n\n    int j = i;\n    while (i < numBytes && c < until) {\n      i += numBytesForFirstByte(getByte(i));\n      c += 1;\n    }\n\n    if (i > j) {\n      byte[] bytes = new byte[i - j];\n      copyMemory(base, offset + j, bytes, BYTE_ARRAY_OFFSET, i - j);\n      return fromBytes(bytes);\n    } else {\n      return EMPTY_UTF8;\n    }\n  }",
        "human_comment": "Returns a substring of this.\n@param start the position of first code point\n@param until the position after last code point, exclusive.",
        "model_generated_comment": "@link Start @param start @return EMPTY_UTF8 if (until = numBytes/@link End) p>If /p> a UTF-8 byte is a byte, it is the byte containing the UTF8 byte."
    },
    {
        "id": 360,
        "code_snippet": "public void beforeAll(ExtensionContext context) {\n\t\tinstallFailureTracker(context);\n\t\tinjectStaticFields(context, context.getRequiredTestClass());\n\t}",
        "human_comment": "Perform field injection for non-private, {@code static} fields (i.e.,\nclass fields) of type {@link Path} or {@link File} that are annotated with\n{@link TempDir @TempDir}.",
        "model_generated_comment": "p>Installs @link ExtensionContext/p> if the context is empty. @param context the context of the test."
    },
    {
        "id": 361,
        "code_snippet": "public MavenITmng3710PollutedClonedPluginsTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
        "human_comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3710\">MNG-3710</a>.\n\ntodo Fill in a better description of what this test verifies!\n\n@author <a href=\"mailto:brianf@apache.org\">Brian Fox</a>\n@author jdcasey",
        "model_generated_comment": "@link MavenITmng3710PollutedClonedPluginsTest. @param 2.0.8 if the plugin is not already tested."
    },
    {
        "id": 362,
        "code_snippet": "public void process() {\n    if (realVideoObject == null) {\n      realVideoObject = new RealVideoObject();\n    }\n    realVideoObject.process();\n  }",
        "human_comment": "A proxy class for the real video object, providing a layer of control over the object\ninstantiation.",
        "model_generated_comment": "@link RealVideoObject @param realVideoObject the real video object."
    },
    {
        "id": 363,
        "code_snippet": "static final Migration MIGRATION_1_2 = new Migration(1, 2) {\n    };",
        "human_comment": "Migrate from:\nversion 1 - using the SQLiteDatabase API\nto\nversion 2 - using Room",
        "model_generated_comment": "MIGRATION_1_2 = new Migration(1, 2)/a>."
    },
    {
        "id": 364,
        "code_snippet": "public ShuffleSecretManager() {\n    shuffleSecretMap = new ConcurrentHashMap<>();\n  }",
        "human_comment": "A class that manages shuffle secret used by the external shuffle service.",
        "model_generated_comment": "shuffleSecretManager @link ConcurrentHashMap. @param Concurrent HashMap is a symlink to a secret map."
    },
    {
        "id": 365,
        "code_snippet": "public final String getMethodParameterTypes() {\n\t\treturn this.methodParameterTypes;\n\t}",
        "human_comment": "Get the method parameter types of this source.",
        "model_generated_comment": "Returns the method type of the parameter type. @param methodParameterTypes a @link method."
    },
    {
        "id": 366,
        "code_snippet": "protected void processImage() {\n    if (desiredSize != initializedSize) {\n      LOGGER.i(\n          \"Initializing at size preview size %dx%d, stylize size %d\",\n          previewWidth, previewHeight, desiredSize);\n\n      rgbFrameBitmap = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);\n      croppedBitmap = Bitmap.createBitmap(desiredSize, desiredSize, Config.ARGB_8888);\n      frameToCropTransform = ImageUtils.getTransformationMatrix(\n          previewWidth, previewHeight,\n          desiredSize, desiredSize,\n          sensorOrientation, true);\n\n      cropToFrameTransform = new Matrix();\n      frameToCropTransform.invert(cropToFrameTransform);\n      intValues = new int[desiredSize * desiredSize];\n      floatValues = new float[desiredSize * desiredSize * 3];\n      initializedSize = desiredSize;\n    }\n    rgbFrameBitmap.setPixels(getRgbBytes(), 0, previewWidth, 0, 0, previewWidth, previewHeight);\n    final Canvas canvas = new Canvas(croppedBitmap);\n    canvas.drawBitmap(rgbFrameBitmap, frameToCropTransform, null);\n\n    if (SAVE_PREVIEW_BITMAP) {\n      ImageUtils.saveBitmap(croppedBitmap);\n    }\n\n    runInBackground(\n        new Runnable() {\n        });\n    if (desiredSize != initializedSize) {\n      resetPreviewBuffers();\n    }\n  }",
        "human_comment": "For examining the actual TF input.",
        "model_generated_comment": "@code initializes a preview at size %dx%d, stylizes it at a desiredSize. @param previewWidth, previewHeight, %Dx%DX%D. @resetPreviewBuffers() if the preview size is initialized at size, if it is not initialized, the preview will not be initialized. @code initialized @returns the initializedSize of the preview."
    },
    {
        "id": 367,
        "code_snippet": "public void deactivateOptionalProject(String selector) {\n        this.activations.add(new ProjectActivationSettings(selector, ActivationSettings.deactivatedOpt()));\n    }",
        "human_comment": "Mark a project as optional and deactivated.\n@param selector The selector of the project.",
        "model_generated_comment": "p>Deactivate @link ActivationSettings/p>. @param selector the selected project."
    },
    {
        "id": 368,
        "code_snippet": "static ClassNameFilter excludeClassNamePatterns(String... patterns) {\n\t\treturn new ExcludeClassNameFilter(patterns);\n\t}",
        "human_comment": "Create a new <em>exclude</em> {@link ClassNameFilter} based on the\n@see Class#getName()\n@see #includeClassNamePatterns(String...)",
        "model_generated_comment": "Excludes @link Patterns from the class name filter. @return a new ExcludeClassNameFilter(patterns) that excludes a class name from the filter."
    },
    {
        "id": 369,
        "code_snippet": "public ColumnarArray(ColumnVector data, int offset, int length) {\n    this.data = data;\n    this.offset = offset;\n    this.length = length;\n  }",
        "human_comment": "Array abstraction in {@link ColumnVector}.",
        "model_generated_comment": "@link ColumnarArray. @param offset the offset of a column."
    },
    {
        "id": 370,
        "code_snippet": "public static void assertEquals(Integer expected, int actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Integer) actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "Asserts that @code expected and/.@code actual are equal."
    },
    {
        "id": 371,
        "code_snippet": "public static void assertEquals(float expected, float actual, float delta) {\n        assertEquals(null, expected, actual, delta);\n    }",
        "human_comment": "Asserts that two floats are equal to within a positive delta.\nIf they are not, an {@link AssertionError} is thrown. If the expected\nvalue is infinity then the delta value is ignored. NaNs are considered\nequal: <code>assertEquals(Float.NaN, Float.NaN, *)</code> passes\n\n@param expected expected value\n@param actual the value to check against <code>expected</code>\n@param delta the maximum delta between <code>expected</code> and\n<code>actual</code> for which both numbers are still\nconsidered equal.",
        "model_generated_comment": "@code expected, float actual and float delta. @param expected, actual and delta floats are equal."
    },
    {
        "id": 372,
        "code_snippet": "public MyDoubleAvg() {\n    List<StructField> inputFields = new ArrayList<>();\n    inputFields.add(DataTypes.createStructField(\"inputDouble\", DataTypes.DoubleType, true));\n    _inputDataType = DataTypes.createStructType(inputFields);\n\n    // The buffer has two values, bufferSum for storing the current sum and\n    // bufferCount for storing the number of non-null input values that have been contributed\n    // to the current sum.\n    List<StructField> bufferFields = new ArrayList<>();\n    bufferFields.add(DataTypes.createStructField(\"bufferSum\", DataTypes.DoubleType, true));\n    bufferFields.add(DataTypes.createStructField(\"bufferCount\", DataTypes.LongType, true));\n    _bufferSchema = DataTypes.createStructType(bufferFields);\n\n    _returnDataType = DataTypes.DoubleType;\n  }",
        "human_comment": "An example {@link UserDefinedAggregateFunction} to calculate a special average value of a\n{@link org.apache.spark.sql.types.DoubleType} column. This special average value is the sum\nof the average value of input values and 100.0.",
        "model_generated_comment": "@link InputDoubleAvg @param bufferSum for storing the current sum and bufferCount to store the number of non-null input values that have been contributed. @return The buffer has two values, the sum and the buffer count, respectively."
    },
    {
        "id": 373,
        "code_snippet": "Handler repoHandler = new AbstractHandler() {\n                    response.setStatus(HttpServletResponse.SC_OK);\n                    response.getWriter().println(\"<project>\");\n                    response.getWriter().println(\"  <modelVersion>4.0.0</modelVersion>\");\n                    response.getWriter().println(\"  <groupId>org.apache.maven.its.mng3461</groupId>\");\n                    response.getWriter().println(\"  <artifactId>b</artifactId>\");\n                    response.getWriter().println(\"  <version>0.1</version>\");\n                    response.getWriter().println(\"</project>\");\n                } else {\n                    response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                }",
        "human_comment": "Test that mirror definitions are properly evaluated. In particular, the wildcard external:* should not\nmatch file:// and localhost repos but only external repos.\n\n@throws Exception in case of failure",
        "model_generated_comment": "@link AbstractHandler/@link Mng3461/ap> p>Response to a HttpServlet/Application/p>. @param versionVersion, version 4.0.0"
    },
    {
        "id": 374,
        "code_snippet": "private UsersDatabase getMigratedRoomDatabase() {\n        UsersDatabase database = Room.databaseBuilder(ApplicationProvider.getApplicationContext(),\n                UsersDatabase.class, TEST_DB_NAME)\n                .addMigrations(MIGRATION_1_2, MIGRATION_2_3)\n                .build();\n        // close the database and release any stream resources when the test finishes\n        mMigrationTestHelper.closeWhenFinished(database);\n        return database;\n    }",
        "human_comment": "Test the migration from versions 1 and 2, to version 3.",
        "model_generated_comment": "p>ApplicationProvider.getMigrationRoomDatabase/p>. @param migration_1_2_3."
    },
    {
        "id": 375,
        "code_snippet": "public static synchronized MaintenanceLock getInstance() {\n    if (instance == null) {\n      instance = new MaintenanceLock();\n    }\n    return instance;\n  }",
        "human_comment": "Get the instance of MaintenanceLock.\n\n@return singleton instance of MaintenanceLock",
        "model_generated_comment": "p>An instance of a MaintenanceLock/p>."
    },
    {
        "id": 376,
        "code_snippet": "public Runner addTarget(Operation operation) {\n      if (!(operation instanceof GraphOperation)) {\n        throw new IllegalArgumentException(\n            \"Operation of type \"\n                + operation.getClass().getName()\n                + \" is not supported in graph sessions\");\n      }\n      targets.add((GraphOperation) operation);\n      return this;\n    }",
        "human_comment": "Make {@link #run()} execute {@code operation}, but not return any evaluated {@link Tensor\nTensors}.\n\n@throws IllegalArgumentException if the operation is not a {@link GraphOperation}",
        "model_generated_comment": "Returns a @link GraphOperation that is not supported in graph sessions."
    },
    {
        "id": 377,
        "code_snippet": "private int hash(long item, int count) {\n    long hash = hashA[count] * item;\n    hash += hash >> 32;\n    hash &= PRIME_MODULUS;\n    return ((int) hash) % width;\n  }",
        "human_comment": "A super fast way of computing x mod 2^p-1\nSee http://www.cs.princeton.edu/courses/archive/fall09/cos521/Handouts/universalclasses.pdf\npage 149, right after Proposition 7.\nDoing \"%\" after (int) conversion is ~2x faster than %'ing longs.",
        "model_generated_comment": "@link Int/@link Output if a hash is longer than 32 digits. @param % width if the hash has a long item. @return a number of hash values."
    },
    {
        "id": 378,
        "code_snippet": "protected ConfiguredGoalSupport(MessageBuilderFactory messageBuilderFactory, SecDispatcher secDispatcher) {\n        super(messageBuilderFactory, secDispatcher);\n    }",
        "human_comment": "The support class for goal implementations that requires valid/workable config.",
        "model_generated_comment": "ConfiguredGoalSupport(MessageBuilderFactory, secDispatcher))."
    },
    {
        "id": 379,
        "code_snippet": "public int nextCapacity(int currentCapacity) {\n      assert (currentCapacity > 0);\n      int doubleCapacity = currentCapacity * 2;\n      // Guard against overflow\n      return (doubleCapacity > 0 && doubleCapacity <= ARRAY_MAX) ? doubleCapacity : ARRAY_MAX;\n    }",
        "human_comment": "Double the size of the hash map every time.",
        "model_generated_comment": "@code currentCapacity @param current Capacity > 0; @return the current capacity if it exceeds 0 if the current capacity is greater than 0"
    },
    {
        "id": 380,
        "code_snippet": "public void createObjectFromXml(Node node) {\n    name = node.getAttributes().getNamedItem(\"name\").getNodeValue();\n    NodeList childNodes = node.getChildNodes();\n    iterateXmlForAnimalAndPlants(childNodes, animalsEaten, plantsEaten);\n  }",
        "human_comment": "Parses the Animal Object from the input XML Node.\n\n@param node the XML Node from which the Animal Object is to be parsed",
        "model_generated_comment": "p>Attributes/p> a node node is a @code node."
    },
    {
        "id": 381,
        "code_snippet": "private void addChildrenRecursively(VintageTestDescriptor parent) {\n\t\tif (parent.getDescription().isTest()) {\n\t\t\treturn;\n\t\t}\n\t\tList<Description> children = parent.getDescription().getChildren();\n\t\tMap<String, List<Description>> childrenByUniqueId = children.stream().collect(\n\t\t\tgroupingBy(uniqueIdReader.andThen(uniqueIdStringifier), LinkedHashMap::new, toCollection(ArrayList::new)));\n\t\tfor (Entry<String, List<Description>> entry : childrenByUniqueId.entrySet()) {\n\t\t\tString uniqueId = entry.getKey();\n\t\t\tList<Description> childrenWithSameUniqueId = entry.getValue();\n\t\t\tIntFunction<String> uniqueIdGenerator = determineUniqueIdGenerator(uniqueId, childrenWithSameUniqueId);\n\t\t\tfor (int index = 0; index < childrenWithSameUniqueId.size(); index++) {\n\t\t\t\tString reallyUniqueId = uniqueIdGenerator.apply(index);\n\t\t\t\tDescription description = childrenWithSameUniqueId.get(index);\n\t\t\t\tUniqueId id = parent.getUniqueId().append(VintageTestDescriptor.SEGMENT_TYPE_TEST, reallyUniqueId);\n\t\t\t\tVintageTestDescriptor child = new VintageTestDescriptor(id, description,\n\t\t\t\t\ttestSourceProvider.findTestSource(description));\n\t\t\t\tparent.addChild(child);\n\t\t\t\taddChildrenRecursively(child);\n\t\t\t}\n\t\t}\n\t}",
        "human_comment": "Use LinkedHashMap to preserve order, ArrayList for fast access by index",
        "model_generated_comment": "Returns a @link UniqueId. @param uniqueId id a unique identifier. @return a true unique Id if it's not a valid one."
    },
    {
        "id": 382,
        "code_snippet": "void testRoundTripProfiles() {\n        Random entropy = new Random();\n        ActivationFile af = ActivationFile.newBuilder()\n                .exists(\"exists\" + Long.toHexString(entropy.nextLong()))\n                .missing(\"missing\" + Long.toHexString(entropy.nextLong()))\n                .build();\n        ActivationProperty ap = ActivationProperty.newBuilder()\n                .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                .value(\"value\" + Long.toHexString(entropy.nextLong()))\n                .build();\n        ActivationOS ao = ActivationOS.newBuilder()\n                .arch(\"arch\" + Long.toHexString(entropy.nextLong()))\n                .family(\"family\" + Long.toHexString(entropy.nextLong()))\n                .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                .version(\"version\" + Long.toHexString(entropy.nextLong()))\n                .build();\n        Activation a = Activation.newBuilder()\n                .activeByDefault(entropy.nextBoolean())\n                .jdk(\"jdk\" + Long.toHexString(entropy.nextLong()))\n                .file(af)\n                .property(ap)\n                .os(ao)\n                .packaging(\"pom\")\n                .build();\n        Map<String, String> props = new HashMap<>();\n        int count = entropy.nextInt(10);\n        for (int i = 0; i < count; i++) {\n            props.put(\"name\" + Long.toHexString(entropy.nextLong()), \"value\" + Long.toHexString(entropy.nextLong()));\n        }\n        count = entropy.nextInt(3);\n        List<Repository> repos = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            Repository r = Repository.newBuilder()\n                    .id(\"id\" + Long.toHexString(entropy.nextLong()))\n                    .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                    .url(\"url\" + Long.toHexString(entropy.nextLong()))\n                    .build();\n            repos.add(r);\n        }\n        count = entropy.nextInt(3);\n        List<Repository> pluginRepos = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            Repository r = Repository.newBuilder()\n                    .id(\"id\" + Long.toHexString(entropy.nextLong()))\n                    .name(\"name\" + Long.toHexString(entropy.nextLong()))\n                    .url(\"url\" + Long.toHexString(entropy.nextLong()))\n                    .build();\n            pluginRepos.add(r);\n        }\n        Profile p = Profile.newBuilder()\n                .id(\"id\" + Long.toHexString(entropy.nextLong()))\n                .activation(a)\n                .properties(props)\n                .repositories(repos)\n                .pluginRepositories(pluginRepos)\n                .build();\n\n        Profile clone = SettingsUtilsV4.convertToSettingsProfile(SettingsUtilsV4.convertFromSettingsProfile(p));\n\n        assertEquals(p.getId(), clone.getId());\n        assertEquals(p.getActivation().getJdk(), clone.getActivation().getJdk());\n        assertEquals(\n                p.getActivation().getFile().getExists(),\n                clone.getActivation().getFile().getExists());\n        assertEquals(\n                p.getActivation().getFile().getMissing(),\n                clone.getActivation().getFile().getMissing());\n        assertEquals(\n                p.getActivation().getProperty().getName(),\n                clone.getActivation().getProperty().getName());\n        assertEquals(\n                p.getActivation().getProperty().getValue(),\n                clone.getActivation().getProperty().getValue());\n        assertEquals(\n                p.getActivation().getOs().getArch(),\n                clone.getActivation().getOs().getArch());\n        assertEquals(\n                p.getActivation().getOs().getFamily(),\n                clone.getActivation().getOs().getFamily());\n        assertEquals(\n                p.getActivation().getOs().getName(),\n                clone.getActivation().getOs().getName());\n        assertEquals(\n                p.getActivation().getOs().getVersion(),\n                clone.getActivation().getOs().getVersion());\n        assertEquals(p.getActivation().getPackaging(), clone.getActivation().getPackaging());\n        assertEquals(p.getProperties(), clone.getProperties());\n        assertEquals(p.getRepositories().size(), clone.getRepositories().size());\n        assertEquals(\n                p.getPluginRepositories().size(), clone.getPluginRepositories().size());\n    }",
        "human_comment": "TODO deep compare the lists\nTODO deep compare the lists",
        "model_generated_comment": "ActivationFile ao = new HashMap/ao; @link entropy if a new builder is available. p>Also, if the builder does not exist, it will not be able to build it."
    },
    {
        "id": 383,
        "code_snippet": "public static List<Object[]> dataProvider() {\n    return List.of(\n        new Object[] {new Item(ItemType.POTION, \"Potion of courage\")},\n        new Object[] {new Item(ItemType.RING, \"Ring of shadows\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of wisdom\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of blood\")},\n        new Object[] {new Item(ItemType.WEAPON, \"Sword of silver +1\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of rust\")},\n        new Object[] {new Item(ItemType.POTION, \"Potion of healing\")},\n        new Object[] {new Item(ItemType.RING, \"Ring of armor\")},\n        new Object[] {new Item(ItemType.WEAPON, \"Steel halberd\")},\n        new Object[] {new Item(ItemType.WEAPON, \"Dagger of poison\")});\n\n  @ParameterizedTest\n  @MethodSource(\"dataProvider\")\n  void testIterator(Item expectedItem) {\n    final var chest = new TreasureChest();\n    final var iterator = chest.iterator(expectedItem.getType());\n    assertNotNull(iterator);\n\n    while (iterator.hasNext()) {\n      final var item = iterator.next();\n      assertNotNull(item);\n      assertEquals(expectedItem.getType(), item.getType());\n\n      final var name = item.toString();\n      assertNotNull(name);\n      if (expectedItem.toString().equals(name)) {\n        return;\n      }\n    }\n\n    fail(\"Expected to find item [\" + expectedItem + \"] using iterator, but we didn't.\");\n  }\n\n  @ParameterizedTest\n  @MethodSource(\"dataProvider\")\n  void testGetItems(Item expectedItem) {\n    final var chest = new TreasureChest();\n    final var items = chest.getItems();\n    assertNotNull(items);\n\n    for (final var item : items) {\n      assertNotNull(item);\n      assertNotNull(item.getType());\n      assertNotNull(item.toString());\n\n      final var sameType = expectedItem.getType() == item.getType();\n      final var sameName = expectedItem.toString().equals(item.toString());\n      if (sameType && sameName) {\n        return;\n      }\n    }\n\n    fail(\"Expected to find item [\" + expectedItem + \"] in the item list, but we didn't.\");\n  }\n}",
        "human_comment": "Test if the expected item can be retrieved from the chest using the {@link\nTreasureChest#getItems()} method",
        "model_generated_comment": "@param itemIterator @link Iterator if iterator isn't used."
    },
    {
        "id": 384,
        "code_snippet": "static TableChange addConstraint(Constraint constraint, String validatedTableVersion) {\n    return new AddConstraint(constraint, validatedTableVersion);\n  }",
        "human_comment": "Create a TableChange for adding a new table constraint",
        "model_generated_comment": "Adds a constraint to a table. @param constraint @link validatedTableVersion. @return the constraint."
    },
    {
        "id": 385,
        "code_snippet": "protected LayeredOptions(List<O> options) {\n        this.options = new ArrayList<>(options);\n    }",
        "human_comment": "Options that are \"layered\" by precedence order.\n\n@param <O> The type of options.",
        "model_generated_comment": "@link LayeredOptions @param options ArrayList/O> Array of options."
    },
    {
        "id": 386,
        "code_snippet": "public static boolean isPublic(Class<?> clazz) {\n\t\treturn ReflectionUtils.isPublic(clazz);\n\t}",
        "human_comment": "Determine if the supplied class is {@code public}.\n\n@param clazz the class to check; never {@code null}\n@return {@code true} if the class is {@code public}\n@see java.lang.reflect.Modifier#isPublic(int)",
        "model_generated_comment": "Returns a @link ReflectionUtils class. @param class class clazz a class that is public. @return a static boolean isPublic(clazz) if the class is not public."
    },
    {
        "id": 387,
        "code_snippet": "final int collationId) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType && !collation.supportsSpaceTrimming) {\n        return execBinary(srcString, trimString);\n      }\n\n      if (collation.isUtf8BinaryType) {\n        return execBinaryTrim(srcString, trimString, collationId);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(srcString, trimString, collationId);\n      } else {\n        return execICU(srcString, trimString, collationId);\n      }\n    }",
        "human_comment": "special handling needed for utf8_binary_rtrim collation.",
        "model_generated_comment": "@link CollationFactory/@link Utf8BinaryType @param collationId @return execICU(srcString, trimString), if collation Id/return collation id, if it's a UTF8LowercaseType. @example if the collation type is UTF8, if there's no collation, and if not, the ocl-collationId>@return"
    },
    {
        "id": 388,
        "code_snippet": "protected Module getCustomModule(C context, CoreExports exports) {\n        return new AbstractModule() {\n        };\n    }",
        "human_comment": "Note: overriding this method should be avoided. Preferred way to replace Maven components is the \"normal\" way\nwhere the components are on index (are annotated with JSR330 annotations and Sisu index is created) and, they\nhave priorities set.",
        "model_generated_comment": "Returns a new module with a @link CoreExports value."
    },
    {
        "id": 389,
        "code_snippet": "public void sendHeartbeatInvokeMessage(int currentId) {\n    var nextInstance = this.findNextInstance(currentId);\n    var heartbeatInvokeMessage = new Message(MessageType.HEARTBEAT_INVOKE, \"\");\n    nextInstance.onMessage(heartbeatInvokeMessage);\n  }",
        "human_comment": "Send heartbeat invoke message to the next instance.\n\n@param currentId Instance ID of which sends this message.",
        "model_generated_comment": "@link heartbeatInvokeMessage @param currentId the current instance of the heartbeat invoking a message."
    },
    {
        "id": 390,
        "code_snippet": "private DropConstraint(String name, boolean ifExists, Mode mode) {\n      this.name = name;\n      this.ifExists = ifExists;\n      this.mode = mode;\n    }",
        "human_comment": "Defines modes for dropping a constraint.\n<p>\nRESTRICT - Prevents dropping a constraint if it is referenced by other objects.\nCASCADE - Automatically drops objects that depend on the constraint.",
        "model_generated_comment": "@link DropConstraint ifExists is a drop-down constraint. @param name the name of the constraint, if Exists the mode, and if the mode is the mode."
    },
    {
        "id": 391,
        "code_snippet": "public static EngineFilter includeEngines(List<String> engineIds) {\n\t\treturn new EngineFilter(engineIds, Type.INCLUDE);\n\t}",
        "human_comment": "Create a new <em>include</em> {@code EngineFilter} based on the\n<em>included</em> within the test discovery and execution.\n\n@param engineIds the list of engine IDs to match against; never {@code null}\nor empty; individual IDs must also not be null or blank\n@see #includeEngines(String...)",
        "model_generated_comment": "p>An @link EngineFilter/p> if the engine IDs of the engine are not available."
    },
    {
        "id": 392,
        "code_snippet": "void assertNotEqualsByte() {\n\t\t\tbyte unexpected = 1;\n\t\t\tbyte actual = 2;\n\t\t\tassertNotEquals(unexpected, actual);\n\t\t\tassertNotEquals(unexpected, actual, \"message\");\n\t\t\tassertNotEquals(unexpected, actual, () -> \"message\");\n\t\t}",
        "human_comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.0",
        "model_generated_comment": "@code unexpected = 1; byte actual = 2. @param unexpected = 2; @return unexpected if the byte is unexpected. @example actual if a message is not expected if it's not expected."
    },
    {
        "id": 393,
        "code_snippet": "private void mergeSessions(List<SessionAcc> sessionAccs, GroupState<Sessions> state) {\n\n            int curIdx = 0;\n            while (curIdx < sessionAccs.size() - 1) {\n              SessionAcc curSession = sessionAccs.get(curIdx);\n              SessionAcc nextSession = sessionAccs.get(curIdx + 1);\n\n              if (curSession.endTime().getTime() > nextSession.startTime().getTime()) {\n                List<SessionEvent> accumulatedEvents = new ArrayList<>(curSession.getEvents());\n                accumulatedEvents.addAll(nextSession.getEvents());\n                accumulatedEvents.sort(\n                    Comparator.comparingLong(e -> e.getStartTimestamp().getTime()));\n\n                List<SessionAcc> newSessions = new ArrayList<>();\n                List<SessionEvent> eventsForCurSession = new ArrayList<>();\n                for (SessionEvent event : accumulatedEvents) {\n                  eventsForCurSession.add(event);\n                  if (event.eventType == EventTypes.CLOSE_SESSION) {\n                    SessionAcc newSessionAcc = SessionAcc.newInstance(eventsForCurSession);\n                    newSessions.add(newSessionAcc);\n                    eventsForCurSession = new ArrayList<>();\n                  }\n                }\n                if (!eventsForCurSession.isEmpty()) {\n                  SessionAcc newSessionAcc = SessionAcc.newInstance(eventsForCurSession);\n                  newSessions.add(newSessionAcc);\n                }\n\n                sessionAccs.remove(curIdx + 1);\n                sessionAccs.set(curIdx, newSessions.get(0));\n                if (newSessions.size() > 1) {\n                  sessionAccs.addAll(curIdx + 1,\n                      newSessions.stream().skip(1).collect(Collectors.toList()));\n                }\n\n                curIdx += newSessions.size() - 1;\n              } else {\n                curIdx++;\n              }\n            }\n\n            state.update(Sessions.newInstance(sessionAccs));\n          }",
        "human_comment": "we sorted sessionAccs by timestamp\nCurrent session and next session can be merged\nreplace current session and next session with new session(s)\nmove the cursor to the last new session(s)\nmove to the next session\nupdate state",
        "model_generated_comment": "p>Sessions/p> @link EventTypes. @param curIdx - 0 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 10 - 15 - 20 - 25 - 30 - 40 - 50 - 100 - 200 - 250 - 300 - 400 - 500 - 1000 - 2000 - 2001 - 2002 - 2003 - 2004 - 2005 - 2006 - 2007 - 2008"
    },
    {
        "id": 394,
        "code_snippet": "public Object createTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext extensionContext) {\n\t\t\treturn \"bogus\";\n\t\t}",
        "human_comment": "{@link TestInstanceFactory} that returns an object of a type that does\nnot match the supplied test class.",
        "model_generated_comment": "@link TestInstance. @param testInstanceFactoryContext factoryContext extensionContext. @return false if the test instance does not exist."
    },
    {
        "id": 395,
        "code_snippet": "public static void assertNotEquals(short unexpected, short actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "p>Assert/p> that @code unexpected and /code actual are equal."
    },
    {
        "id": 396,
        "code_snippet": "protected void runChild(final FrameworkMethod method, RunNotifier notifier) {\n        Description description = describeChild(method);\n        if (isIgnored(method)) {\n            notifier.fireTestIgnored(description);\n        } else {\n            Statement statement = new Statement() {\n            };\n            runLeaf(statement, description, notifier);\n        }\n    }",
        "human_comment": "Creates a BlockJUnit4ClassRunner to run {@code testClass}.\n\n@throws InitializationError if the test class is malformed.\n@since 4.13",
        "model_generated_comment": "@link RunNotifier notifier/@link FrameworkMethod/#runNotifier if the method is not defined. @param method the method to be tested. @return the method if it isn't defined."
    },
    {
        "id": 397,
        "code_snippet": "public static Optional<? extends DiscoverySelector> parse(String identifier) {\n\t\treturn DiscoverySelectorIdentifierParsers.parse(identifier);\n\t}",
        "human_comment": "Parse the supplied string representation of a {@link DiscoverySelectorIdentifier}.\n\n@param identifier the string representation of a {@code DiscoverySelectorIdentifier};\nnever {@code null} or blank\n@return an {@link Optional} containing the corresponding {@link DiscoverySelector};\nnever {@code null} but potentially empty\n@since 1.11\n@see DiscoverySelectorIdentifierParser",
        "model_generated_comment": "p>Parse a DiscoverySelectorIdentifier/p>. @param identifier a @code identifiable or http://www.discoveryselector.org/details/discussions/index.htm. @returns the IdentifierParser/link /a>."
    },
    {
        "id": 398,
        "code_snippet": "void executionsFromSucceededTestEvents() {\n\t\tvar testEvents = getTestEvents();\n\n\t\tassertThat(testEvents.executions().succeeded().count()).isEqualTo(1);\n\t\tassertThat(testEvents.succeeded().executions().count()).isEqualTo(0);\n\t}",
        "human_comment": "We expect 1 if the executions are created BEFORE filtering out \"finished\" events.\nWe expect 0 if the executions are created AFTER filtering out \"finished\" events.",
        "model_generated_comment": "@link TestEvents @param executionsFromSucceededTestEvent @return a test event that has been successfully executed by the testEvent. @code executes the test event with a number of executions."
    },
    {
        "id": 399,
        "code_snippet": "private ArtifactRepository createLocalArtifactRepository(Path baseDirectory) {\n        DefaultRepositoryLayout layout = new DefaultRepositoryLayout();\n        ArtifactRepositoryPolicy blah = new ArtifactRepositoryPolicy(\n                true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE);\n        return new MavenArtifactRepository(\n                \"local\", \"file://\" + baseDirectory.toUri().getRawPath(), layout, blah, blah);\n    }",
        "human_comment": "TODO: get rid of this!!!",
        "model_generated_comment": "@link ArtifactRepository @param baseDirectory DefaultRepositoryLayout @return a Maven artifact repository based on a base directory."
    },
    {
        "id": 400,
        "code_snippet": "public Builder assureDeletion() {\n            this.assureDeletion = true;\n            return this;\n        }",
        "human_comment": "Setting this flag assures that no resources are left undeleted. Failure\nto fulfill the assurance results in failure of tests with an\n{@link AssertionError}.\n\n@return this",
        "model_generated_comment": "p>AssureDeletion/p>. @return true if @code true is returned. @param https://github.com/builder/assess/assured_delete()."
    },
    {
        "id": 401,
        "code_snippet": "void testMergeModelModelVersion() {\n        Model parent = Model.newBuilder().modelVersion(\"4.0.0\").build();\n        Model model = Model.newInstance();\n        Model.Builder builder = Model.newBuilder(model);\n        modelMerger.mergeModel_ModelVersion(builder, model, parent, false, null);\n        assertNull(builder.build().getModelVersion());\n\n        model = Model.newBuilder().modelVersion(\"5.0.0\").build();\n        builder = Model.newBuilder(model);\n        modelMerger.mergeModel_ModelVersion(builder, model, parent, false, null);\n        assertEquals(\"5.0.0\", builder.build().getModelVersion());\n    }",
        "human_comment": "modelVersion is neither inherited nor injected",
        "model_generated_comment": "p>ModelModelVersion/p> @link ModelVersion(). @param modelVersion the model version of the model."
    },
    {
        "id": 402,
        "code_snippet": "Stream<DynamicTest> dynamicTestsFromStreamFactoryMethodWithNames() {\n\t\tvar inputStream = Stream.of(\n\t\t\tnamed(\"racecar is a palindrome\", \"racecar\"),\n\t\t\tnamed(\"radar is also a palindrome\", \"radar\"),\n\t\t\tnamed(\"mom also seems to be a palindrome\", \"mom\"),\n\t\t\tnamed(\"dad is yet another palindrome\", \"dad\")\n\t\t);\n\n\t\treturn DynamicTest.stream(inputStream, text -> assertTrue(isPalindrome(text)));\n\t}",
        "human_comment": "tag::user_guide[]\nStream of palindromes to check\nend::user_guide[]\n@formatter:off\ntag::user_guide[]\nend::user_guide[]\n@formatter:on\ntag::user_guide[]\nReturns a stream of dynamic tests.",
        "model_generated_comment": "p>Assert/p> that @link racecar is a palindrome. @param racecar a plindrome /a>. @return a dynamicTest from the StreamFactoryMethodWithNames."
    },
    {
        "id": 403,
        "code_snippet": "private Map<String, BuildStep> merge(Map<String, BuildStep> org, Map<String, BuildStep> add) {\n        List<BuildStep> lasts =\n                org.values().stream().filter(b -> b.successors.isEmpty()).toList();\n        List<BuildStep> firsts =\n                add.values().stream().filter(b -> b.predecessors.isEmpty()).toList();\n        firsts.stream()\n                .filter(addNode -> !org.containsKey(addNode.name))\n                .forEach(addNode -> lasts.forEach(orgNode -> addNode.executeAfter(orgNode)));\n        add.forEach((name, node) -> org.merge(name, node, this::merge));\n        return org;\n    }",
        "human_comment": "all new phases should be added after the existing ones",
        "model_generated_comment": "@link MapString BuildStep @param orgNode -> b.predecessors.isEmpty @return org.values()."
    },
    {
        "id": 404,
        "code_snippet": "default MessageBuilder a(CharSequence value) {\n        return append(value);\n    }",
        "human_comment": "Append content to the message buffer.\n\n@param value the content to append\n@return the current builder",
        "model_generated_comment": "Returns the value of the MessageBuilder."
    },
    {
        "id": 405,
        "code_snippet": "public Loader withConfigProto(byte[] configProto) {\n      this.configProto = configProto;\n      return this;\n    }",
        "human_comment": "Set configuration of the <code>Session</code> object created when loading the model.\n\n@param configProto Serialized <a\nhref=\"https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto\">ConfigProto\nprotocol buffer</a>.",
        "model_generated_comment": "p>ConfigProto/p> is a @link Loader."
    },
    {
        "id": 406,
        "code_snippet": "private static void runJsonDatasetExample(SparkSession spark) {\n    Dataset<Row> people = spark.read().json(\"examples/src/main/resources/people.json\");\n\n    people.printSchema();\n\n    people.createOrReplaceTempView(\"people\");\n\n    Dataset<Row> namesDF = spark.sql(\"SELECT name FROM people WHERE age BETWEEN 13 AND 19\");\n    namesDF.show();\n\n    List<String> jsonData = Arrays.asList(\n            \"{\\\"name\\\":\\\"Yin\\\",\\\"address\\\":{\\\"city\\\":\\\"Columbus\\\",\\\"state\\\":\\\"Ohio\\\"}}\");\n    Dataset<String> anotherPeopleDataset = spark.createDataset(jsonData, Encoders.STRING());\n    Dataset<Row> anotherPeople = spark.read().json(anotherPeopleDataset);\n    anotherPeople.show();\n  }",
        "human_comment": "$example on:json_dataset$\nA JSON dataset is pointed to by path.\nThe path can be either a single text file or a directory storing text files\nThe inferred schema can be visualized using the printSchema() method\nroot\n|-- age: long (nullable = true)\n|-- name: string (nullable = true)\nCreates a temporary view using the DataFrame\nSQL statements can be run by using the sql methods provided by spark\n+------+\n|  name|\n+------+\n|Justin|\n+------+\nAlternatively, a DataFrame can be created for a JSON dataset represented by\na Dataset<String> storing one JSON object per string.\n+---------------+----+\n|        address|name|\n+---------------+----+\n|[Columbus,Ohio]| Yin|\n+---------------+----+\n$example off:json_dataset$",
        "model_generated_comment": "p>AnotherPeopleDataset/p> @link SparkSessionSparkDatasetExample/Places/people.json. @param people SELECT name FROM people WHERE age BETWEEN 13 AND 19/a>"
    },
    {
        "id": 407,
        "code_snippet": "public SuiteLauncherDiscoveryRequestBuilder configurationParameter(String key, String value) {\n\t\tthis.delegate.configurationParameter(key, value);\n\t\treturn this;\n\t}",
        "human_comment": "Add the supplied <em>configuration parameter</em> to the request.\n\n@param key the configuration parameter key under which to store the\nvalue; never {@code null} or blank\n@param value the value to store\n@return this builder for method chaining",
        "model_generated_comment": "p>SuiteLauncherDiscoveryRequestBuilder/p>. @param key, value @code key/@code value @return this if the key is /code>."
    },
    {
        "id": 408,
        "code_snippet": "public long runtime(TimeUnit unit) {\n        return unit.convert(getNanos(), TimeUnit.NANOSECONDS);\n    }",
        "human_comment": "Gets the runtime for the test.\n\n@param unit time unit for returned runtime\n@return runtime measured during the test",
        "model_generated_comment": "Returns a time unit @link TimeUnit. @param timeUnit the time unit. @return unit.convert(getNanos(), timeunit.Nanoconds) if the unit is a Time Unit."
    },
    {
        "id": 409,
        "code_snippet": "public static String showVersion(String commandLine, String terminal) {\n        final String ls = System.lineSeparator();\n        Properties properties = getBuildProperties();\n        StringBuilder version = new StringBuilder(256);\n        version.append(MessageUtils.builder().strong(createMavenVersionString(properties)))\n                .append(ls);\n        version.append(reduce(properties.getProperty(\"distributionShortName\") + \" home: \"\n                        + System.getProperty(\"maven.home\", \"<unknown Maven \" + \"home>\")))\n                .append(ls);\n        version.append(\"Java version: \")\n                .append(System.getProperty(\"java.version\", \"<unknown Java version>\"))\n                .append(\", vendor: \")\n                .append(System.getProperty(\"java.vendor\", \"<unknown vendor>\"))\n                .append(\", runtime: \")\n                .append(System.getProperty(\"java.home\", \"<unknown runtime>\"))\n                .append(ls);\n        version.append(\"Default locale: \")\n                .append(Locale.getDefault())\n                .append(\", platform encoding: \")\n                .append(System.getProperty(\"file.encoding\", \"<unknown encoding>\"))\n                .append(ls);\n        version.append(\"OS name: \\\"\")\n                .append(Os.OS_NAME)\n                .append(\"\\\", version: \\\"\")\n                .append(Os.OS_VERSION)\n                .append(\"\\\", arch: \\\"\")\n                .append(Os.OS_ARCH)\n                .append(\"\\\", family: \\\"\")\n                .append(Os.OS_FAMILY)\n                .append('\\\"');\n        if (commandLine != null) {\n            version.append(ls).append(\"Command line: \").append(commandLine);\n        }\n        if (terminal != null) {\n            version.append(ls).append(\"Terminal: \").append(terminal);\n        }\n        return version.toString();\n    }",
        "human_comment": "Add process information using modern Java API",
        "model_generated_comment": "@link MavenVersion/@link MessageUtils.builder/www.maven-builder.com> p>Versions/p> if a new version is created, the new version will be created."
    },
    {
        "id": 410,
        "code_snippet": "public static List<Resource> findAllResourcesInModule(String moduleName, Predicate<Resource> resourceFilter) {\n\t\treturn ReflectionUtils.findAllResourcesInModule(moduleName, resourceFilter);\n\t}",
        "human_comment": "Find all {@linkplain Resource resources} in the supplied {@code moduleName}\nthat match the specified {@code resourceFilter} predicate.\n\n<p>The module-path scanning algorithm searches recursively in all\npackages contained in the module.\n\n@param moduleName the name of the module to scan; never {@code null} or\n<em>empty</em>\n@param resourceFilter the resource type filter; never {@code null}\n@return an immutable list of all such resources found; never {@code null}\nbut potentially empty\n@since 1.11\n@see #findAllResourcesInClasspathRoot(URI, Predicate)\n@see #findAllResourcesInPackage(String, Predicate)",
        "model_generated_comment": "p>Returns a @link ReflectionUtils class. @param moduleName and predicate resourceFilter/p>. @return a class."
    },
    {
        "id": 411,
        "code_snippet": "public void testQueueStream() {\n    ssc.stop();\n    SparkConf conf = new SparkConf()\n        .setMaster(\"local[2]\")\n        .setAppName(\"test\")\n        .set(\"spark.streaming.clock\", \"org.apache.spark.util.ManualClock\");\n    ssc = new JavaStreamingContext(conf, new Duration(1000));\n\n    List<List<Integer>> expected = Arrays.asList(\n        Arrays.asList(1,2,3),\n        Arrays.asList(4,5,6),\n        Arrays.asList(7,8,9));\n\n    JavaSparkContext jsc = new JavaSparkContext(ssc.ssc().sc());\n    JavaRDD<Integer> rdd1 = jsc.parallelize(Arrays.asList(1, 2, 3));\n    JavaRDD<Integer> rdd2 = jsc.parallelize(Arrays.asList(4, 5, 6));\n    JavaRDD<Integer> rdd3 = jsc.parallelize(Arrays.asList(7,8,9));\n\n    Queue<JavaRDD<Integer>> rdds = new LinkedList<>();\n    rdds.add(rdd1);\n    rdds.add(rdd2);\n    rdds.add(rdd3);\n\n    JavaDStream<Integer> stream = ssc.queueStream(rdds);\n    JavaTestUtils.attachTestOutputStream(stream);\n    List<List<Integer>> result = JavaTestUtils.runStreams(ssc, 3, 3);\n    Assertions.assertEquals(expected, result);\n  }",
        "human_comment": "Create a new JavaStreamingContext without checkpointing",
        "model_generated_comment": "p>Assertions/p> @code ssc/code rdds/. @param Arrays.asList(1,2,3), Array(4,5, 6)/a>. @return a jsc /return the json StreamingContext(spark.streaming.clock()/spark/json/jave.jsvn asynchronously/javajava.sparkStreaming.cc"
    },
    {
        "id": 412,
        "code_snippet": "protected void evaluateState() {\n    if (failureCount >= failureThreshold) { // Then something is wrong with remote service\n      if ((System.nanoTime() - lastFailureTime) > retryTimePeriod) {\n        state = State.HALF_OPEN;\n      } else {\n        state = State.OPEN;\n      }\n    } else {\n      state = State.CLOSED;\n    }\n  }",
        "human_comment": "Evaluate the current state based on failureThreshold, failureCount and lastFailureTime.\nWe have waited long enough and should try checking if service is up\nService would still probably be down\nEverything is working fine",
        "model_generated_comment": "p>Then something is wrong with remote service."
    },
    {
        "id": 413,
        "code_snippet": "public synchronized Enumeration<TestFailure> failures() {\n        return Collections.enumeration(fFailures);\n    }",
        "human_comment": "Returns an Enumeration for the failures.",
        "model_generated_comment": "Enumerates a collection of failed tests. @param @link TestFailures. @return a synchronized enumeration of a failed test."
    },
    {
        "id": 414,
        "code_snippet": "public static String comparableQualifier(String qualifier) {\n            if (RELEASE_QUALIFIERS.contains(qualifier)) {\n                return String.valueOf(QUALIFIERS.indexOf(\"\"));\n            }\n\n            int i = QUALIFIERS.indexOf(qualifier);\n\n            // Just returning an Integer with the index here is faster, but requires a lot of if/then/else to check for\n            // -1\n            //  or QUALIFIERS.size and then resort to lexical ordering. Most comparisons are decided by the first\n            // character,\n            // so this is still fast. If more characters are needed then it requires a lexical sort anyway.\n            return i == -1 ? (QUALIFIERS.size() + \"-\" + qualifier) : String.valueOf(i);\n        }",
        "human_comment": "Returns a comparable value for a qualifier.\n<p>\nThis method takes into account the ordering of known qualifiers then unknown qualifiers with lexical\nordering.\n<p>\n\n@param qualifier\n@return an equivalent value that can be used with lexical comparison",
        "model_generated_comment": "Returns a QUALIFIERS.size integer with the corresponding value. @param -1 the value of a comparison."
    },
    {
        "id": 415,
        "code_snippet": "public void setClassRealm(ClassRealm classRealm) {\n        this.classRealm = classRealm;\n    }",
        "human_comment": "Sets the project's class realm. <strong>Warning:</strong> This is an internal utility method that is only public\nfor technical reasons, it is not part of the public API. In particular, this method can be changed or deleted\nwithout prior notice and must not be used by plugins.\n\n@param classRealm The class realm hosting the build extensions of this project, may be {@code null}.",
        "model_generated_comment": "Sets the class representation of a class. @param classRealm the realm of the class."
    },
    {
        "id": 416,
        "code_snippet": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn parameterContext.getParameter().getType() == Double.class;\n\t}",
        "human_comment": "Example {@link ParameterResolver} that always resolves a {@link Double}\nparameter to {@code 42.0}.\n\n@since 5.0",
        "model_generated_comment": "p>ParameterContext/p>. @param parameterContext @link ExtensionContext> if a parameter is not specified, it will be returned. @return a boolean if the parameter is specified."
    },
    {
        "id": 417,
        "code_snippet": "public boolean hasMetadataResolutionExceptions() {\n        return metadataResolutionExceptions != null;\n    }",
        "human_comment": "------------------------------------------------------------------------\nMetadata Resolution Exceptions: ArtifactResolutionExceptions\n------------------------------------------------------------------------",
        "model_generated_comment": "Returns a @link metadataResolutionExceptions function. @return a null boolean if a metadata resolution exception is encountered. @param metadataresolutionexceptions if the metadata is not resolved."
    },
    {
        "id": 418,
        "code_snippet": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
        "human_comment": "Issue: Add at least one assertion to this test case.\n\n<p>Solution: Inserted assertion to check whether the execution of the main method in {@link\nApp#main(String[])} throws an exception.",
        "model_generated_comment": "p>Application with @code Exception should not be executed."
    },
    {
        "id": 419,
        "code_snippet": "public static <T> void assertThat(T actual, Matcher<? super T> matcher) {\n        assertThat(\"\", actual, matcher);\n    }",
        "human_comment": "Asserts that <code>actual</code> satisfies the condition specified by\n<code>matcher</code>. If not, an {@link AssertionError} is thrown with\ninformation about the matcher and failing value. Example:\n\n<pre>\nassertThat(0, is(1)); // fails:\n// failure message:\n// expected: is &lt;1&gt;\n// got value: &lt;0&gt;\nassertThat(0, is(not(1))) // passes\n</pre>\n\n<code>org.hamcrest.Matcher</code> does not currently document the meaning\nof its type parameter <code>T</code>.  This method assumes that a matcher\ntyped as <code>Matcher&lt;T&gt;</code> can be meaningfully applied only\nto values that could be assigned to a variable of type <code>T</code>.\n\n@param <T> the static type accepted by the matcher (this can flag obvious\ncompile-time problems such as {@code assertThat(1, is(\"a\"))}\n@param actual the computed value being compared\n@param matcher an expression, built of {@link Matcher}s, specifying allowed\nvalues\n@see org.hamcrest.CoreMatchers\n@deprecated use {@code org.hamcrest.MatcherAssert.assertThat()}",
        "model_generated_comment": "@link matcher/@link actual Matcher @param matcher a matcher that matches the actual matcher. @return true if the matcher matches the current matcher"
    },
    {
        "id": 420,
        "code_snippet": "public TcpLoggingClient(String clientName, int serverPort) {\n      this.clientName = clientName;\n      this.serverPort = serverPort;\n    }",
        "human_comment": "Creates a new TCP logging client.\n\n@param clientName the name of the client to be sent in logging requests.\n@param serverPort the port on which client will send logging requests.",
        "model_generated_comment": "TcpLoggingClient(String clientName, int serverPort)/a> @link ServerPort @param clientName @return serverPort the serverPort of the client."
    },
    {
        "id": 421,
        "code_snippet": "protected void prepareOptions(org.apache.commons.cli.Options options) {\n            options.addOption(Option.builder(HELP)\n                    .longOpt(\"help\")\n                    .desc(\"Display help information\")\n                    .build());\n            options.addOption(Option.builder(USER_PROPERTY)\n                    .numberOfArgs(2)\n                    .valueSeparator('=')\n                    .desc(\"Define a user property\")\n                    .build());\n            options.addOption(Option.builder(SHOW_VERSION_AND_EXIT)\n                    .longOpt(\"version\")\n                    .desc(\"Display version information\")\n                    .build());\n            options.addOption(Option.builder(QUIET)\n                    .longOpt(\"quiet\")\n                    .desc(\"Quiet output - only show errors\")\n                    .build());\n            options.addOption(Option.builder(VERBOSE)\n                    .longOpt(\"verbose\")\n                    .desc(\"Produce execution verbose output\")\n                    .build());\n            options.addOption(Option.builder(SHOW_ERRORS)\n                    .longOpt(\"errors\")\n                    .desc(\"Produce execution error messages\")\n                    .build());\n            options.addOption(Option.builder(BATCH_MODE)\n                    .longOpt(\"batch-mode\")\n                    .desc(\"Run in non-interactive mode. Alias for --non-interactive (kept for backwards compatability)\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(NON_INTERACTIVE)\n                    .desc(\"Run in non-interactive mode. Alias for --batch-mode\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(FORCE_INTERACTIVE)\n                    .desc(\n                            \"Run in interactive mode. Overrides, if applicable, the CI environment variable and --non-interactive/--batch-mode options\")\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_USER_SETTINGS)\n                    .longOpt(\"settings\")\n                    .desc(\"Alternate path for the user settings file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_PROJECT_SETTINGS)\n                    .longOpt(\"project-settings\")\n                    .desc(\"Alternate path for the project settings file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_INSTALLATION_SETTINGS)\n                    .longOpt(\"install-settings\")\n                    .desc(\"Alternate path for the installation settings file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_USER_TOOLCHAINS)\n                    .longOpt(\"toolchains\")\n                    .desc(\"Alternate path for the user toolchains file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_INSTALLATION_TOOLCHAINS)\n                    .longOpt(\"install-toolchains\")\n                    .desc(\"Alternate path for the installation toolchains file\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(FAIL_ON_SEVERITY)\n                    .longOpt(\"fail-on-severity\")\n                    .desc(\"Configure which severity of logging should cause the build to fail\")\n                    .hasArg()\n                    .build());\n            options.addOption(Option.builder(LOG_FILE)\n                    .longOpt(\"log-file\")\n                    .hasArg()\n                    .desc(\"Log file where all build output will go (disables output color)\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(RAW_STREAMS)\n                    .desc(\"Do not decorate standard output and error streams\")\n                    .build());\n            options.addOption(Option.builder(SHOW_VERSION)\n                    .longOpt(\"show-version\")\n                    .desc(\"Display version information WITHOUT stopping build\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(COLOR)\n                    .hasArg()\n                    .optionalArg(true)\n                    .desc(\"Defines the color mode of the output. Supported are 'auto', 'always', 'never'.\")\n                    .build());\n            options.addOption(Option.builder(OFFLINE)\n                    .longOpt(\"offline\")\n                    .desc(\"Work offline\")\n                    .build());\n\n            options.addOption(Option.builder()\n                    .longOpt(DEBUG)\n                    .desc(\"Launch the JVM in debug mode (script option).\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(ENC)\n                    .desc(\"Launch the Maven Encryption tool (script option).\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(SHELL)\n                    .desc(\"Launch the Maven Shell tool (script option).\")\n                    .build());\n            options.addOption(Option.builder()\n                    .longOpt(YJP)\n                    .desc(\"Launch the JVM with Yourkit profiler (script option).\")\n                    .build());\n\n            options.addOption(Option.builder(ALTERNATE_GLOBAL_SETTINGS)\n                    .longOpt(\"global-settings\")\n                    .desc(\"<deprecated> Alternate path for the global settings file.\")\n                    .hasArg()\n                    .deprecated(DeprecatedAttributes.builder()\n                            .setForRemoval(true)\n                            .setSince(\"4.0.0\")\n                            .setDescription(\"Use -is,--install-settings instead.\")\n                            .get())\n                    .build());\n            options.addOption(Option.builder(ALTERNATE_GLOBAL_TOOLCHAINS)\n                    .longOpt(\"global-toolchains\")\n                    .desc(\"<deprecated> Alternate path for the global toolchains file.\")\n                    .hasArg()\n                    .deprecated(DeprecatedAttributes.builder()\n                            .setForRemoval(true)\n                            .setSince(\"4.0.0\")\n                            .setDescription(\"Use -it,--install-toolchains instead.\")\n                            .get())\n                    .build());\n        }",
        "human_comment": "Parameters handled by script\nDeprecated",
        "model_generated_comment": "p>Options/p>Application/a> @code /code /options /etc/admin/docs/default.cfg/json>. @param version and exit - if a user property is specified, it will be run in a non-interactive mode."
    },
    {
        "id": 422,
        "code_snippet": "public File get(String groupId, String artifactId, String version) {\n        return pomFiles.get(new CacheKey(groupId, artifactId, version));\n    }",
        "human_comment": "Holds all POM files that are known to the reactor. This allows the project builder to resolve imported POMs from the\nreactor when building another project's effective model.",
        "model_generated_comment": "@link CacheKey (String artifactId, String version) p>Returns a file with a Cache key. @param version the version of the file. @return a pomfile.get(String group Id, string version)/p>"
    },
    {
        "id": 423,
        "code_snippet": "static void afterMethodsOfAllRulesWereExecuted() {\n\t\tif (!asList(initEvents.get(2), initEvents.get(3), initEvents.get(0), initEvents.get(1)).equals(afterEvents))\n\t\t\tfail();\n\t}",
        "human_comment": "beforeEach methods of rules from methods are run before those from fields but in reverse order",
        "model_generated_comment": "@link InitEvents/@link Executes all events that are executed in a given method."
    },
    {
        "id": 424,
        "code_snippet": "public Store getStore(StoreScope scope, Namespace namespace) {\n\t\tswitch (scope) {\n\t\t\tcase LAUNCHER_SESSION:\n\t\t\t\treturn launcherStoreFacade.getSessionLevelStore(namespace);\n\t\t\tcase EXECUTION_REQUEST:\n\t\t\t\treturn launcherStoreFacade.getRequestLevelStore(namespace);\n\t\t\tcase EXTENSION_CONTEXT:\n\t\t\t\treturn getStore(namespace);\n\t\t}\n\t\tthrow new JUnitException(\"Unknown StoreScope: \" + scope);\n\t}",
        "human_comment": "TODO [#4246] Use switch expression",
        "model_generated_comment": "EXECUTION_REQUEST: Returns a @link StoreFacade object. @param StoreScope scope, Namespace namespace"
    },
    {
        "id": 425,
        "code_snippet": "public static Transform apply(String name, Expression... args) {\n    return LogicalExpressions.apply(name,\n        CollectionConverters.asScala(Arrays.asList(args)).toSeq());\n  }",
        "human_comment": "Create a logical transform for applying a named transform.\n<p>\nThis transform can represent applying any named transform.\n\n@param name the transform name\n@param args expression arguments to the transform\n@return a logical transform",
        "model_generated_comment": "p>Assert/p> that @link Expressions/@link CollectionConverters/www.logicalexpressions.apply/proceedings.asScala()/href=\"https://docs.microsoft.com/docs/logicalExpressions\">. @param name, expression name, args /a> @return a Transform that tries to apply an Expression to an Array"
    },
    {
        "id": 426,
        "code_snippet": "public void updateAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        User updatedUser = new User(USER.getId(), \"new username\", USER.getDate());\n        mDataSource.insertOrUpdateUser(updatedUser);\n\n        User dbUser = mDataSource.getUser();\n        assertEquals(dbUser.getId(), USER.getId());\n        assertEquals(dbUser.getUserName(), \"new username\");\n    }",
        "human_comment": "Given that we have a user in the data source\nWhen we are updating the name of the user\nThe retrieved user has the updated username",
        "model_generated_comment": "@link UpdatedUser @param username the new user. @return a new user if the user is not already a user."
    },
    {
        "id": 427,
        "code_snippet": "public void getUserName_whenUserSaved() {\n        User user = new User(\"user name\");\n        when(mDataSource.getUser()).thenReturn(Flowable.just(user));\n\n        mViewModel.getUserName()\n                .test()\n                .assertValue(\"user name\");\n    }",
        "human_comment": "Given that the UserDataSource returns a user\nWhen getting the user name\nThe correct user name is emitted",
        "model_generated_comment": "Gets the user name when the user is saved."
    },
    {
        "id": 428,
        "code_snippet": "public ShuffleIndexRecord getIndex(int startReduceId, int endReduceId) {\n    long offset = offsets.get(startReduceId);\n    long nextOffset = offsets.get(endReduceId);\n    return new ShuffleIndexRecord(offset, nextOffset - offset);\n  }",
        "human_comment": "Get index offset for the reducer range of [startReduceId, endReduceId).",
        "model_generated_comment": "Returns a ShuffleIndexRecord with a @link StartReduceId value."
    },
    {
        "id": 429,
        "code_snippet": "void findMethodsDoesNotReturnOverriddenMethods() {\n\t\t\tPredicate<Method> isSpecial = method -> method.isAnnotationPresent(Special.class);\n\n\t\t\t// Search for all @Special methods.\n\t\t\tvar methods = findMethods(SuperclassWithInstanceMethods.class, isSpecial);\n\n\t\t\tassertThat(signaturesOf(methods))//\n\t\t\t\t\t.containsExactlyInAnyOrder(\"specialFoo()\", \"specialFoo(int)\", \"specialFoo(char)\", \"specialBar()\",\n\t\t\t\t\t\t\"specialBaz()\");\n\n\t\t\t// Search for all @Special methods.\n\t\t\tmethods = findMethods(SubclassWithOverriddenInstanceMethods.class, isSpecial);\n\n\t\t\tassertThat(signaturesOf(methods))//\n\t\t\t\t\t.containsExactlyInAnyOrder(\"foo()\", \"specialFoo()\", \"specialFoo(int)\", \"specialBar()\");\n\t\t}",
        "human_comment": "In legacy mode, \"static hiding\" occurs.",
        "model_generated_comment": "@link SubclassWithOverriddenInstanceMethods.class, isSpecial // Search for all @Predicate methods. @param subclass with overriddenMetheds if the subclass is overridden. @return overridden methods if a subclass has an overridden instance of the same subclass if it's overridden by a Subclass."
    },
    {
        "id": 430,
        "code_snippet": "public static boolean isLuhnNumber(UTF8String numberString) {\n    String digits = numberString.toString();\n    // Empty string is not a valid Luhn number.\n    if (digits.isEmpty()) return false;\n    int checkSum = 0;\n    boolean isSecond = false;\n    for (int i = digits.length() - 1; i >= 0; i--) {\n      char ch = digits.charAt(i);\n      if (!Character.isDigit(ch)) return false;\n\n      int digit = Character.getNumericValue(ch);\n      // Double the digit if it's the second digit in the sequence.\n      int doubled = isSecond ? digit * 2 : digit;\n      // Add the two digits of the doubled number to the sum.\n      checkSum += doubled % 10 + doubled / 10;\n      // Toggle the isSecond flag for the next iteration.\n      isSecond = !isSecond;\n    }\n    // Check if the final sum is divisible by 10.\n    return checkSum % 10 == 0;\n  }",
        "human_comment": "Function to check if a given number string is a valid Luhn number\n@param numberString\nthe number string to check\n@return\ntrue if the number string is a valid Luhn number, false otherwise.",
        "model_generated_comment": "if the digit is the second digit in the sequence, check if it's a valid Luhn number. @param digits the first digit of the sequence. @return 0 if a digit has been doubled."
    },
    {
        "id": 431,
        "code_snippet": "private void addDelegates(InterpreterImpl.Options options) {\n    if (originalGraphHasUnresolvedFlexOp) {\n      Delegate optionalFlexDelegate = maybeCreateFlexDelegate(options.getDelegates());\n      if (optionalFlexDelegate != null) {\n        ownedDelegates.add(optionalFlexDelegate);\n        delegates.add(optionalFlexDelegate);\n      }\n    }\n    addUserProvidedDelegates(options);\n    for (DelegateFactory delegateFactory : options.getDelegateFactories()) {\n      Delegate delegate = delegateFactory.create(RUNTIME_FLAVOR);\n      ownedDelegates.add(delegate);\n      delegates.add(delegate);\n    }\n    if (options.getUseNNAPI()) {\n      NnApiDelegate optionalNnApiDelegate = new NnApiDelegate();\n      ownedDelegates.add(optionalNnApiDelegate);\n      delegates.add(optionalNnApiDelegate);\n    }\n  }",
        "human_comment": "Add all the delegates specified in the options (other than XNNPACK) to this.delegates.\nFirst add the flex delegate if necessary. This ensures the graph is fully resolved before\napplying other delegates.\nNow add the user-supplied delegates.",
        "model_generated_comment": "@link InterpreterImpl.Options if a GraphHasUnresolvedFlexOp. @param a delegateFactory if it's not a DelegateFaculty/a>. @return if the GraphHead is unresolvable if there's no delegate."
    },
    {
        "id": 432,
        "code_snippet": "public InMemoryProductRepository() {\n    products.put(\"1\", new Product(\"1\", \"Laptop\", LAPTOP_PRICE));\n    products.put(\"2\", new Product(\"2\", \"Smartphone\", SMARTPHONE_PRICE));\n  }",
        "human_comment": "Constructs an {@code InMemoryProductRepository} and initializes it with some example products.",
        "model_generated_comment": "@link InMemoryProductRepository. @param \"1\", \"Laptop\", \"Smartphone\", \"2\", \"3\", \"4\", \"4\", etc."
    },
    {
        "id": 433,
        "code_snippet": "public static boolean consumerPom(@Nullable Map<String, String> userProperties, boolean def) {\n        return doGet(userProperties, Constants.MAVEN_CONSUMER_POM, def);\n    }",
        "human_comment": "Check if the consumer POM feature is active.",
        "model_generated_comment": "@link userProperties @param userPom @return a boolean em>Constants@code userPROPERTY@param def."
    },
    {
        "id": 434,
        "code_snippet": "public static Queen createFlirtyQueen() {\n    var queen = new Queen();\n    queen.setFlirtiness(true);\n    return queen;\n  }",
        "human_comment": "Method to create a flirty queen.\n\n@return A flirty {@link com.iluwatar.objectmother.Queen}.",
        "model_generated_comment": "p>Queen/p>Flirtiness/a>. @param queen @code queen. @return true if a queen is set to true."
    },
    {
        "id": 435,
        "code_snippet": "public double calculateTotal(final String userId) {\n    return userCarts.getOrDefault(userId, new ArrayList<>()).stream()\n        .mapToDouble(Cart::getTotalPrice)\n        .sum();\n  }",
        "human_comment": "Calculates the total price of items in the user's cart.\n\n@param userId The ID of the user.\n@return The total price of the cart.",
        "model_generated_comment": "Returns a @link UserCarts ArrayList. @param userId the user's id. @return a userCart with a value of 0 if the user is not a valid user."
    },
    {
        "id": 436,
        "code_snippet": "public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof DefaultSourceRoot other) {\n            return directory.equals(other.directory)\n                    && includes.equals(other.includes)\n                    && excludes.equals(other.excludes)\n                    && Objects.equals(scope, other.scope)\n                    && Objects.equals(language, other.language)\n                    && Objects.equals(moduleName, other.moduleName)\n                    && Objects.equals(targetVersion, other.targetVersion)\n                    && stringFiltering == other.stringFiltering\n                    && enabled == other.enabled;\n        }\n        return false;\n    }",
        "human_comment": "{@return whether the two objects are of the same class with equal property values}.\n\n@param obj the other object to compare with this object, or {@code null}",
        "model_generated_comment": "@link DefaultSourceRoot obj @param Default SourceRoot other @return true if a boolean object is already omitted from the Object /a> && if it's already a directory, it'll be renamed to a new one."
    },
    {
        "id": 437,
        "code_snippet": "static TableChange removeProperty(String property) {\n    return new RemoveProperty(property);\n  }",
        "human_comment": "Create a TableChange for removing a table property.\n<p>\nIf the property does not exist, the change will succeed.\n\n@param property the property name\n@return a TableChange for the addition",
        "model_generated_comment": "Returns a new property @link RemoveProperty(String). @return a property containing a String property."
    },
    {
        "id": 438,
        "code_snippet": "void execution() {\n\t\tLauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()\n\t\t\t.selectors(\n\t\t\t\tselectPackage(\"com.example.mytests\"),\n\t\t\t\tselectClass(MyTestClass.class)\n\t\t\t)\n\t\t\t.filters(\n\t\t\t\tincludeClassNamePatterns(\".*Tests\")\n\t\t\t)\n\t\t\t.configurationParameter(\"enableHttpServer\", \"false\")\n\t\t\t.build();\n\n\t\tSummaryGeneratingListener listener = new SummaryGeneratingListener();\n\n\t\ttry (LauncherSession session = LauncherFactory.openSession()) {\n\t\t\tLauncher launcher = session.getLauncher();\n\t\t\tlauncher.registerTestExecutionListeners(listener);\n\t\t\tTestPlan testPlan = launcher.discover(request);\n\t\t\tlauncher.execute(testPlan);\n\t\t\tlauncher.execute(request);\n\t\t}\n\n\t\tTestExecutionSummary summary = listener.getSummary();\n\n\t}",
        "human_comment": "@formatter:off\ntag::execution[]\nend::execution[]\ntag::execution[]\nRegister a listener of your choice\nDiscover tests and build a test plan\nExecute test plan\nAlternatively, execute the request directly\nDo something with the summary...\nend::execution[]\n@formatter:on",
        "model_generated_comment": "@link LauncherDiscoveryRequestBuilder/@link TestExecutionListeners/www.launcherdiscoveryrequestbuilder.build() p>Session/p> if a new launcher instance is created, it will be able to generate a test execution summary for each test execution. @param testClassNamePatternsListener if it's not already created."
    },
    {
        "id": 439,
        "code_snippet": "default boolean isPartiallyPushed() { return true; }\n}",
        "human_comment": "Whether the LIMIT is partially pushed or not. If it returns true, then Spark will do LIMIT\nagain. This method will only be called when {@link #pushLimit} returns true.",
        "model_generated_comment": "@link isPartiallyPushed @return true if a boolean is thrown. @param a partially-pushed object if it is not pushed by a specified method."
    },
    {
        "id": 440,
        "code_snippet": "public MavenITmng3723ConcreteParentProjectTest() {\n        super(\"(2.0.8,)\"); // only test in 2.0.9+\n    }",
        "human_comment": "This is a test set for <a href=\"https://issues.apache.org/jira/browse/MNG-3723\">MNG-3723</a>.\n\nTests that the parent MavenProject instance of the current project has been\ntransitioned into a concrete state before a mojo is executed. If this is true,\nthen injecting ${project} into the mojo and traversing to project.getParent().getBasedir()\nshould retrieve a File instance that is interpolated and exists (since we're\ngoing to be using a parent-child project set in the projects directory).\n\n@author jdcasey",
        "model_generated_comment": "@link MavenITmng3723ConcreteParentProjectTest @param 2.0.8+ if a project is a constructor. @return a test in 2.0.9+"
    },
    {
        "id": 441,
        "code_snippet": "void validate(TestEngine testEngine, TestDescriptor root) {\n\t\tPreconditions.notNull(root,\n\t\t\t() -> String.format(\n\t\t\t\t\"The discover() method for TestEngine with ID '%s' must return a non-null root TestDescriptor.\",\n\t\t\t\ttestEngine.getId()));\n\t\tOptional<String> cyclicGraphInfo = getCyclicGraphInfo(root);\n\t\tPreconditions.condition(!cyclicGraphInfo.isPresent(),\n\t\t\t() -> String.format(\"The discover() method for TestEngine with ID '%s' returned a cyclic graph; %s\",\n\t\t\t\ttestEngine.getId(), cyclicGraphInfo.get()));\n\t}",
        "human_comment": "Perform common validation checks.\n\n@throws org.junit.platform.commons.PreconditionViolationException if any check fails",
        "model_generated_comment": "@link TestEngine @param root TestDescriptor @return a cyclic graph with ID '%s' if the root TestEngine isn't found."
    },
    {
        "id": 442,
        "code_snippet": "final AppExecutors executors) {\n        return Room.databaseBuilder(appContext, AppDatabase.class, DATABASE_NAME)\n                .addCallback(new Callback() {\n                    }\n                })",
        "human_comment": "Build the database. {@link Builder#build()} only sets up the database configuration and\ncreates a new instance of the database.\nThe SQLite database is only created when it's accessed for the first time.",
        "model_generated_comment": "@link AppExecutors. @param appContext, appDatabase.class, DATABASE_NAME @return a callback to a database."
    },
    {
        "id": 443,
        "code_snippet": "static String findJarsDir(String sparkHome, String scalaVersion, boolean failIfNotFound) {\n    // TODO: change to the correct directory once the assembly build is changed.\n    File libdir = new File(sparkHome, \"jars\");\n    if (!libdir.isDirectory()) {\n      libdir = new File(sparkHome, String.format(\"assembly/target/scala-%s/jars\", scalaVersion));\n      if (!libdir.isDirectory()) {\n        checkState(!failIfNotFound,\n          \"Library directory '%s' does not exist; make sure Spark is built.\",\n          libdir.getAbsolutePath());\n        return null;\n      }\n    }\n    return libdir.getAbsolutePath();\n  }",
        "human_comment": "Find the location of the Spark jars dir, depending on whether we're looking at a build\nor a distribution directory.",
        "model_generated_comment": "p>Make sure Spark is built to the correct directory once the assembly build is changed."
    },
    {
        "id": 444,
        "code_snippet": "public T setMaster(String master) {\n    checkNotNull(master, \"master\");\n    builder.master = master;\n    return self();\n  }",
        "human_comment": "Set the Spark master for the application.\n\n@param master Spark master.\n@return This launcher.",
        "model_generated_comment": "Sets the master of the builder."
    },
    {
        "id": 445,
        "code_snippet": "private SetProperty(String property, String value) {\n      this.property = property;\n      this.value = value;\n    }",
        "human_comment": "A TableChange to set a table property.\n<p>\nIf the property already exists, it must be replaced with the new value.",
        "model_generated_comment": "Sets the property of a property. @param property the value of the property."
    },
    {
        "id": 446,
        "code_snippet": "public static OrcColumnStatistics readStatistics(Reader orcReader) {\n    TypeDescription orcSchema = orcReader.getSchema();\n    ColumnStatistics[] orcStatistics = orcReader.getStatistics();\n    StructType sparkSchema = OrcUtils.toCatalystSchema(orcSchema);\n    return convertStatistics(sparkSchema, new LinkedList<>(Arrays.asList(orcStatistics)));\n  }",
        "human_comment": "Read the columns statistics from ORC file footer.\n\n@param orcReader the reader to read ORC file footer.\n@return Statistics for all columns in the file.",
        "model_generated_comment": "p>OrcUtils.toCatalystSchema/p>StructType OrcColumnStatistics is a LinkedList of Linked Lists."
    },
    {
        "id": 447,
        "code_snippet": "default boolean mayReturnZeroTestTemplateInvocationContexts(ExtensionContext context) {\n\t\treturn false;\n\t}",
        "human_comment": "Signal that this provider may provide zero\n{@linkplain TestTemplateInvocationContext invocation contexts} for the test\ntemplate method represented by the supplied {@code context}.\n\n<p>If this method returns {@code false} (which is the default) and the\nprovider returns an empty stream from\n{@link #provideTestTemplateInvocationContexts}, this will be considered\nan execution error. Override this method to return {@code true} to ignore\nthe absence of invocation contexts for this provider.\n\n@param context the extension context for the test template method about\nto be invoked; never {@code null}\n@return {@code true} to allow zero contexts, {@code false} to fail\nexecution in case of zero contexts\n\n@since 5.12",
        "model_generated_comment": "@link TestTemplateInvocationContexts @returnZeroTestTemplateContext invocation contexts. @param extensionContextContext contexts if a test template is invoked by a specified extension."
    },
    {
        "id": 448,
        "code_snippet": "void beforeAllAndAfterAllAsMetaAnnotations() {\n\t\texecuteTestsForClass(TestCase.class).testEvents().assertStatistics(stats -> stats.started(1).succeeded(1));\n\n\t\tassertThat(methodsInvoked).containsExactly(\"beforeAll\", \"test\", \"afterAll\");\n\t}",
        "human_comment": "Integration tests that verify support for {@link BeforeAll} and {@link AfterAll}\nwhen used as meta-annotations in the {@link JupiterTestEngine}.\n\n@since 5.0\n@see BeforeEachAndAfterEachComposedAnnotationTests",
        "model_generated_comment": "@link TestCase.class>AsMetaAnnotations/. @param testEventsForClass> p>Succeeded/p>"
    },
    {
        "id": 449,
        "code_snippet": "public static void assertEquals(char expected, Character actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals((Character) expected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 450,
        "code_snippet": "protected SettingsReader newSettingsReader() {\n        return new DefaultSettingsReader();\n    }",
        "human_comment": "A factory to create settings builder instances when no dependency injection is available. <em>Note:</em> This class\nis only meant as a utility for developers that want to employ the settings builder outside of the Maven build system,\nMaven plugins should always acquire settings builder instances via dependency injection. Developers might want to\nsubclass this factory to provide custom implementations for some of the components used by the settings builder.\n\n@deprecated since 4.0.0, use {@link org.apache.maven.api.services.SettingsBuilder} instead",
        "model_generated_comment": "Returns a new SettingsReader for the @link SettingsReader."
    },
    {
        "id": 451,
        "code_snippet": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaCorrelationsExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    JavaDoubleRDD seriesX = jsc.parallelizeDoubles(\n      Arrays.asList(1.0, 2.0, 3.0, 3.0, 5.0));  // a series\n\n    JavaDoubleRDD seriesY = jsc.parallelizeDoubles(\n      Arrays.asList(11.0, 22.0, 33.0, 33.0, 555.0));\n\n    double correlation = Statistics.corr(seriesX.srdd(), seriesY.srdd(), \"pearson\");\n    System.out.println(\"Correlation is: \" + correlation);\n\n    JavaRDD<Vector> data = jsc.parallelize(\n      Arrays.asList(\n        Vectors.dense(1.0, 10.0, 100.0),\n        Vectors.dense(2.0, 20.0, 200.0),\n        Vectors.dense(5.0, 33.0, 366.0)\n      )\n    );\n\n    Matrix correlMatrix = Statistics.corr(data.rdd(), \"pearson\");\n    System.out.println(correlMatrix.toString());\n\n    jsc.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nmust have the same number of partitions and cardinality as seriesX\ncompute the correlation using Pearson's method. Enter \"spearman\" for Spearman's method.\nIf a method is not specified, Pearson's method will be used by default.\nnote that each Vector is a row and not a column\ncalculate the correlation matrix using Pearson's method.\nUse \"spearman\" for Spearman's method.\nIf a method is not specified, Pearson's method will be used by default.\n$example off$",
        "model_generated_comment": "p>JavaCorrelationsExample/p>SparkConf jsc.param @link CorrelMatrix/@link Intervals/Pearson/. @param Vectors https://www.sparkconf.org/java/core/jdd/javacore/index.html> a href=\"http://sparkconf.jdf.java.rdd /a>JapaCorrelXample"
    },
    {
        "id": 452,
        "code_snippet": "default Map<String, String> properties() {\n    return Collections.emptyMap();\n  }",
        "human_comment": "Returns the string map of table properties.",
        "model_generated_comment": "Returns a MapString> property. @param @link Map/@link Collections.emptyMap()."
    },
    {
        "id": 453,
        "code_snippet": "public static Condition<Throwable> rootCause(Condition<Throwable>... conditions) {\n\t\tList<Condition<Throwable>> list = Arrays.stream(conditions)//\n\t\t\t\t.map(TestExecutionResultConditions::rootCause)//\n\t\t\t\t.collect(toList());\n\n\t\treturn Assertions.allOf(list);\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if a\nall supplied conditions.\n\n@since 1.11\n@see #cause(Condition...)\n@see #suppressed(int, Condition...)",
        "model_generated_comment": "@link TestExecutionResultConditions @param rootCause(ConditionThrowable>)/. @return Assertions.allOf(ListOf) if a condition is a root cause of a test execution, it will return a list of all instances of the test execution."
    },
    {
        "id": 454,
        "code_snippet": "public synchronized void start() {\n    int i = 0;\n    try {\n      for (int n = serviceList.size(); i < n; i++) {\n        Service service = serviceList.get(i);\n        service.start();\n      }\n      super.start();\n    } catch (Throwable e) {\n      LOG.error(\"Error starting services {}\", e, MDC.of(LogKeys.SERVICE_NAME$.MODULE$, getName()));\n      stop(i);\n      throw new ServiceException(\"Failed to Start \" + getName(), e);\n    }\n\n  }",
        "human_comment": "Note that the state of the failed service is still INITED and not\nSTARTED. Even though the last service is not started completely, still\ncall stop() on all services including failed service to make sure cleanup\nhappens.",
        "model_generated_comment": "p>Also, if the service is synchronized, it will start automatically. @param serviceList.size() @code /code i>"
    },
    {
        "id": 455,
        "code_snippet": "public static void assertTimeout(Duration timeout, Executable executable, Supplier<String> messageSupplier) {\n\t\tAssertTimeout.assertTimeout(timeout, executable, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that execution of the supplied {@code executable}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>Note: the {@code executable} will be executed in the same thread as that\nof the calling code. Consequently, execution of the {@code executable} will\nnot be preemptively aborted if the timeout is exceeded.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@see #assertTimeout(Duration, Executable)\n@see #assertTimeout(Duration, Executable, String)\n@see #assertTimeout(Duration, ThrowingSupplier)\n@see #assertTimeout(Duration, ThrowingSupplier, String)\n@see #assertTimeout(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeoutPreemptively(Duration, Executable, Supplier)",
        "model_generated_comment": "p>Assert/p> that @code timeout is a timeout that is not a messageSupplier."
    },
    {
        "id": 456,
        "code_snippet": "public List<Lifecycle> getLifeCycles() {\n        List<String> lifecycleIds = Arrays.asList(STANDARD_LIFECYCLES);\n\n        Comparator<String> comparator = (l, r) -> {\n            int lx = lifecycleIds.indexOf(l);\n            int rx = lifecycleIds.indexOf(r);\n\n            if (lx < 0 || rx < 0) {\n                return rx - lx;\n            } else {\n                return lx - rx;\n            }\n        };\n\n        Map<String, Lifecycle> lifecyclesMap = lookupLifecycles();\n\n        // ensure canonical order of standard lifecycles\n        return lifecyclesMap.values().stream()\n                .peek(l -> Objects.requireNonNull(l.getId(), \"A lifecycle must have an id.\"))\n                .sorted(Comparator.comparing(Lifecycle::getId, comparator))\n                .collect(Collectors.toList());\n    }",
        "human_comment": "Returns an ordered list of lifecycles",
        "model_generated_comment": "Returns a list of standard lifecycles. @param lifecycle ids @code standard_lifecycles. @return lx - rx if a lifecycle has a unique identifier."
    },
    {
        "id": 457,
        "code_snippet": "default boolean shouldLogError(Throwable t) {\n    return true;\n  }",
        "human_comment": "Plugs into {@link RetryingBlockTransferor} to further control when an exception should be retried\nand logged.\nNote: {@link RetryingBlockTransferor} will delegate the exception to this handler only when\n- remaining retries  &lt; max retries\n- exception is an IOException\n\n@since 3.1.0",
        "model_generated_comment": "Returns a boolean indicating that a log error has occurred. @param t @code alogError @return true if the log error occurred."
    },
    {
        "id": 458,
        "code_snippet": "public ColumnVector column(int ordinal) { return columns[ordinal]; }",
        "human_comment": "Returns the column at `ordinal`.",
        "model_generated_comment": "ColumnVector column(int ordinal) p>Returns a column with a @code ordinal value."
    },
    {
        "id": 459,
        "code_snippet": "private List<String> findReadOnlyWarning(List<String> logLines) {\n        Pattern pattern = Pattern.compile(\".* Parameter .* is read-only.*\");\n        List<String> result = new ArrayList<>();\n        for (String line : logLines) {\n            if (pattern.matcher(line).matches()) {\n                result.add(line);\n            }\n        }\n        return result;\n    }",
        "human_comment": "Test that ensures that warning is printed for read-only parameter set by plugin configuration.",
        "model_generated_comment": "Returns a @link Pattern that matches a line to a pattern. @param.* is read-only. @return a new ArrayList/@link ReadOnlyWarning if the pattern matches the line to the pattern."
    },
    {
        "id": 460,
        "code_snippet": "public static boolean arraysSame(int[] a1, int[] a2) {\n    // compares if 2 arrays have the same value\n    if (a1.length != a2.length) {\n      return false;\n    } else {\n      var answer = false;\n      for (var i = 0; i < a1.length; i++) {\n        if (a1[i] == a2[i]) {\n          answer = true;\n        } else {\n          answer = false;\n          break;\n        }\n      }\n      return answer;\n    }\n  }",
        "human_comment": "Method arraysSame compares 2 arrays @param a1 and @param a2 and @return whether their values\nare equal (boolean).",
        "model_generated_comment": "if 2 arrays have the same value, @link if a1[i] == a2.length. @param a1, a2, a3, a4, a5, a6, a7, a8, a9, and a10. @return true if the two arrays are the same length."
    },
    {
        "id": 461,
        "code_snippet": "void testSystemTimeAlignment() {\n        Instant monotonic = MonotonicClock.now();\n        Instant system = Instant.now();\n\n        Duration difference = Duration.between(monotonic, system).abs();\n        assertTrue(difference.getSeconds() <= 1, \"Monotonic time should be reasonably aligned with system time\");\n    }",
        "human_comment": "The difference should be relatively small (allow for 1 second max)",
        "model_generated_comment": "@link MonotonicTimeAlignment. @param monotonic time should be reasonably aligned with system time."
    },
    {
        "id": 462,
        "code_snippet": "public boolean hasMetadataResolutionExceptions() {\n        return metadataResolutionExceptions != null;\n    }",
        "human_comment": "------------------------------------------------------------------------\nMetadata Resolution Exceptions: ArtifactResolutionExceptions\n------------------------------------------------------------------------",
        "model_generated_comment": "Returns a @link metadataResolutionExceptions function. @return a null boolean if a metadata resolution exception is encountered. @param metadataresolutionexceptions if the metadata is not resolved."
    },
    {
        "id": 463,
        "code_snippet": "void whenHealthCheckThrowsException_thenReturnsDown() {\n    // Arrange\n    Supplier<Health> healthSupplier =\n        () -> {\n          throw new RuntimeException(\"Health check failed\");\n        };\n    // Act\n    CompletableFuture<Health> healthFuture = healthChecker.performCheck(healthSupplier, 10);\n    // Assert\n    Health health = healthFuture.join();\n    assertEquals(Status.DOWN, health.getStatus());\n    String errorMessage = health.getDetails().get(\"error\").toString();\n    assertTrue(errorMessage.contains(\"Health check failed\"));\n  }",
        "human_comment": "Tests that the {@link performCheck()} method returns a healthy health status when the health\nsupplier returns a healthy status.\n\n<p>Given a health supplier that throws a RuntimeException, the test verifies that the {@link\nperformCheck()} method returns a health object with a status of DOWN and an error message\ncontaining the exception message.",
        "model_generated_comment": "@code HealthCheckThrowsException @param healthSupplier @returns a RuntimeException if a health check fails. @example if the health check failed."
    },
    {
        "id": 464,
        "code_snippet": "public SaslClientBootstrap(TransportConf conf, String appId, SecretKeyHolder secretKeyHolder) {\n    this.conf = conf;\n    this.appId = appId;\n    this.secretKeyHolder = secretKeyHolder;\n  }",
        "human_comment": "Bootstraps a {@link TransportClient} by performing SASL authentication on the connection. The\nserver should be setup with a {@link SaslRpcHandler} with matching keys for the given appId.",
        "model_generated_comment": "p>SaslClientBootstrap/p>. @param appId secretKeyHolder the secret key of the @code conf. @return the conf to a conf containing the app Id and secret key."
    },
    {
        "id": 465,
        "code_snippet": "public static IterationSelector selectIteration(DiscoverySelector parentSelector, int... iterationIndices) {\n\t\tPreconditions.notNull(parentSelector, \"Parent selector must not be null\");\n\t\tPreconditions.notEmpty(iterationIndices, \"iteration indices must not be empty\");\n\t\treturn new IterationSelector(parentSelector, iterationIndices);\n\t}",
        "human_comment": "Create an {@code IterationSelector} for the supplied parent selector and\niteration indices.\n\n@param parentSelector the parent selector to select iterations for; never\n{@code null}\n@param iterationIndices the iteration indices to select; never {@code null}\nor empty\n@since 1.9\n@see IterationSelector",
        "model_generated_comment": "Iteration indices must not be empty."
    },
    {
        "id": 466,
        "code_snippet": "private byte[] makeValidBytes() {\n    assert(numBytesValid > 0);\n    byte[] bytes = new byte[numBytesValid];\n    int byteIndex = 0, byteIndexValid = 0;\n    while (byteIndex < numBytes) {\n      // Read the first byte.\n      byte firstByte = getByte(byteIndex);\n      int expectedLen = bytesOfCodePointInUTF8[firstByte & 0xFF];\n      int codePointLen = Math.min(expectedLen, numBytes - byteIndex);\n      // 0B UTF-8 sequence (invalid first byte).\n      if (codePointLen == 0) {\n        insertReplacementCharacter(bytes, byteIndexValid);\n        byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        ++byteIndex;\n        continue;\n      }\n      // 1B UTF-8 sequence (ASCII or truncated).\n      if (codePointLen == 1) {\n        if (firstByte >= 0) {\n          bytes[byteIndexValid++] = firstByte;\n        }\n        else {\n          insertReplacementCharacter(bytes, byteIndexValid);\n          byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        }\n        ++byteIndex;\n        continue;\n      }\n      // Read the second byte.\n      byte secondByte = getByte(byteIndex + 1);\n      if (!isValidSecondByte(secondByte, firstByte)) {\n        insertReplacementCharacter(bytes, byteIndexValid);\n        byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        ++byteIndex;\n        continue;\n      }\n      // Read remaining continuation bytes.\n      int continuationBytes = 2;\n      for (; continuationBytes < codePointLen; ++continuationBytes) {\n        byte nextByte = getByte(byteIndex + continuationBytes);\n        if (!isValidContinuationByte(nextByte)) {\n          break;\n        }\n      }\n      // Invalid UTF-8 sequence (not enough continuation bytes).\n      if (continuationBytes < expectedLen) {\n        insertReplacementCharacter(bytes, byteIndexValid);\n        byteIndexValid += UNICODE_REPLACEMENT_CHARACTER.length;\n        byteIndex += continuationBytes;\n        continue;\n      }\n      // Valid UTF-8 sequence.\n      for (int i = 0; i < codePointLen; ++i) {\n        bytes[byteIndexValid++] = getByte(byteIndex + i);\n      }\n      byteIndex += codePointLen;\n    }\n    return bytes;\n  }",
        "human_comment": "Private helper method to create a valid UTF-8 byte sequence from the current UTF8String.\nIn order to use this method, the number of bytes of the validated version of the current\nstring (after possible replacement) must be evaluated first by calling `getIsValid`.",
        "model_generated_comment": "@codePointInUTF8 @param numBytesValid // Read the second byte. @codePointLen = 0; if the first byte is 0xFF, the second bytes will be read."
    },
    {
        "id": 467,
        "code_snippet": "public DefaultSourceRoot(final Session session, final Path baseDir, final Source source) {\n        includes = source.getIncludes();\n        excludes = source.getExcludes();\n        stringFiltering = source.isStringFiltering();\n        enabled = source.isEnabled();\n        moduleName = nonBlank(source.getModule());\n\n        String value = nonBlank(source.getScope());\n        scope = (value != null) ? session.requireProjectScope(value) : ProjectScope.MAIN;\n\n        value = nonBlank(source.getLang());\n        language = (value != null) ? session.requireLanguage(value) : Language.JAVA_FAMILY;\n\n        value = nonBlank(source.getDirectory());\n        if (value != null) {\n            directory = baseDir.resolve(value);\n        } else {\n            directory = baseDir.resolve(\"src\").resolve(scope.id()).resolve(language.id());\n        }\n\n        value = nonBlank(source.getTargetVersion());\n        targetVersion = (value != null) ? session.parseVersion(value) : null;\n\n        value = nonBlank(source.getTargetPath());\n        targetPath = (value != null) ? baseDir.resolve(value) : null;\n    }",
        "human_comment": "Creates a new instance from the given model.\n\n@param session the session of resolving extensible enumerations\n@param baseDir the base directory for resolving relative paths\n@param source a source element from the model",
        "model_generated_comment": "p>Assembles the Default SourceRoot/p>. @param @code null if the target language is not available."
    },
    {
        "id": 468,
        "code_snippet": "public static File getTestFile(String path) {\n        return new File(getBasedir(), path);\n    }",
        "human_comment": "Creates a File object for a path relative to the base directory.\n\n@param path The relative path\n@return A File object representing the path",
        "model_generated_comment": "Returns a @link TestFile file. @param path the path of the test file."
    },
    {
        "id": 469,
        "code_snippet": "public EagerOperationBuilder setAttr(String name, Tensor<?>[] values) {\n    throw new UnsupportedOperationException(\n        \"Tensor list attributes are not supported in eager mode\");\n  }",
        "human_comment": "TODO (karllessard) could be supported by adding this attribute type in the eager C API",
        "model_generated_comment": "EagerOperationBuilder @link TensorList. @param name, tensor list attributes are not supported in eager mode."
    },
    {
        "id": 470,
        "code_snippet": "void closeIterator(RocksIterator it) {\n    notifyIteratorClosed(it);\n    synchronized (this._db) {\n      org.rocksdb.RocksDB _db = this._db.get();\n      if (_db != null) {\n        it.close();\n      }\n    }\n  }",
        "human_comment": "Closes the given iterator if the DB is still open. Trying to close a JNI RocksDB handle\nwith a closed DB can cause JVM crashes, so this ensures that situation does not happen.",
        "model_generated_comment": "@link RocksIteratorClosed @param this._db synchronizes a Rocks Iterator with a synchronized Rocks DB."
    },
    {
        "id": 471,
        "code_snippet": "public static NestedClassSelector selectNestedClass(List<Class<?>> enclosingClasses, Class<?> nestedClass) {\n\t\tPreconditions.notEmpty(enclosingClasses, \"Enclosing classes must not be null or empty\");\n\t\tPreconditions.notNull(nestedClass, \"Nested class must not be null\");\n\t\treturn new NestedClassSelector(enclosingClasses, nestedClass);\n\t}",
        "human_comment": "Create a {@code NestedClassSelector} for the supplied nested {@link Class} and its\nenclosing classes.\n\n@param enclosingClasses the path to the nested class to select; never {@code null} or empty\n@param nestedClass the nested class to select; never {@code null}\n@since 1.6\n@see NestedClassSelector",
        "model_generated_comment": "NestedClassSelector(enclosingClasses, nestedClass) with @code null."
    },
    {
        "id": 472,
        "code_snippet": "public static void main(String[] args) {\n\n    SparkConf conf = new SparkConf().setAppName(\"JavaSummaryStatisticsExample\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    JavaRDD<Vector> mat = jsc.parallelize(\n      Arrays.asList(\n        Vectors.dense(1.0, 10.0, 100.0),\n        Vectors.dense(2.0, 20.0, 200.0),\n        Vectors.dense(3.0, 30.0, 300.0)\n      )\n    ); // an RDD of Vectors\n\n    MultivariateStatisticalSummary summary = Statistics.colStats(mat.rdd());\n    System.out.println(summary.mean());  // a dense vector containing the mean value for each column\n    System.out.println(summary.variance());  // column-wise variance\n    System.out.println(summary.numNonzeros());  // number of nonzeros in each column\n\n    jsc.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nCompute column summary statistics.\n$example off$",
        "model_generated_comment": "p>SparkContext/p>An RDD of a @link MultivariateStatisticalSummaryStatisticsExample."
    },
    {
        "id": 473,
        "code_snippet": "public static void main(String[] args) {\n\n    if (args.length < 2) {\n      System.err.println(\"Usage: JavaHdfsLR <file> <iters>\");\n      System.exit(1);\n    }\n\n    showWarning();\n\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaHdfsLR\")\n      .getOrCreate();\n\n    JavaRDD<String> lines = spark.read().textFile(args[0]).javaRDD();\n    JavaRDD<DataPoint> points = lines.map(new ParsePoint()).cache();\n    int ITERATIONS = Integer.parseInt(args[1]);\n\n    double[] w = new double[D];\n    for (int i = 0; i < D; i++) {\n      w[i] = 2 * rand.nextDouble() - 1;\n    }\n\n    System.out.print(\"Initial w: \");\n    printWeights(w);\n\n    for (int i = 1; i <= ITERATIONS; i++) {\n      System.out.println(\"On iteration \" + i);\n\n      double[] gradient = points.map(\n        new ComputeGradient(w)\n      ).reduce(new VectorSum());\n\n      for (int j = 0; j < D; j++) {\n        w[j] -= gradient[j];\n      }\n\n    }\n\n    System.out.print(\"Final w: \");\n    printWeights(w);\n    spark.stop();\n  }",
        "human_comment": "Initialize w to a random value",
        "model_generated_comment": "p>SparkSession/p> @code /code args. @param i = 0 - i++ - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 15 - 20 - 21 - 22 - 24 - 25 - 26 - 28 - 27 - 29 - 30 - 31 - 32 - 64--"
    },
    {
        "id": 474,
        "code_snippet": "public List<Exception> validateTestClass(TestClass testClass) {\n        List<Exception> validationErrors= new ArrayList<Exception>();\n        for (AnnotatableValidator<?> validator : VALIDATORS) {\n            List<Exception> additionalErrors= validator\n                    .validateTestClass(testClass);\n            validationErrors.addAll(additionalErrors);\n        }\n        return validationErrors;\n    }",
        "human_comment": "Validate all annotations of the specified test class that are be\nannotated with {@link ValidateWith}.\n\n@param testClass\nthe {@link TestClass} that is validated.\n@return the errors found by the validator.",
        "model_generated_comment": "@link Validator/@link AdditionalErrors @param testClass(testClass) @return a validator if the test class is not a test class (e.g. testClass, testClass)."
    },
    {
        "id": 475,
        "code_snippet": "public static void assertEquals(float expected, float actual, float delta) {\n        Assert.assertEquals(expected, actual, delta);\n    }",
        "human_comment": "Asserts that two floats are equal concerning a delta. If the expected\nvalue is infinity then the delta value is ignored.",
        "model_generated_comment": "Asserts that the expected and actual values are equal."
    },
    {
        "id": 476,
        "code_snippet": "public static void assertEquals(byte expected, Byte actual, String message) {\n\t\tAssertEquals.assertEquals((Byte) expected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 477,
        "code_snippet": "public static DirectorySelector selectDirectory(String path) {\n\t\tPreconditions.notBlank(path, \"Directory path must not be null or blank\");\n\t\treturn new DirectorySelector(path);\n\t}",
        "human_comment": "Create a {@code DirectorySelector} for the supplied directory path.\n\n<p>This method selects the directory using the supplied path <em>as is</em>,\nwithout verifying if the directory exists.\n\n@param path the path to the directory to select; never {@code null} or blank\n@see DirectorySelector\n@see #selectDirectory(File)\n@see #selectFile(String)\n@see #selectFile(File)",
        "model_generated_comment": "Returns a new DirectorySelector. @param path @code null or blank if the path is not null."
    },
    {
        "id": 478,
        "code_snippet": "protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        applyValidators(errors);\n    }",
        "human_comment": "Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\nDefault implementation adds an error for each method annotated with\n{@code @BeforeClass} or {@code @AfterClass} that is not\n{@code public static void} with no arguments.",
        "model_generated_comment": "p>Asserts that @link /p> a class that is not initialized. @param errors if the class is initialized, the class will not be initialized unless the class has a valid value."
    },
    {
        "id": 479,
        "code_snippet": "public ShuffleIndexRecord getIndex(int reduceId) {\n    return getIndex(reduceId, reduceId + 1);\n  }",
        "human_comment": "Get index offset for a particular reducer.",
        "model_generated_comment": "Returns @link ShuffleIndexRecord. @param reduceId ReduceId @return a record of a ShuffleIndexRecord containing a syslog containing an /."
    },
    {
        "id": 480,
        "code_snippet": "public void runSuite() {\n        // Targeting Test:\n        Result testResult= JUnitCore.runClasses(MultiCategorySuite.class);\n\n        assertThat(\"unexpected run count\", testResult.getRunCount(), is(equalTo(2)));\n        assertThat(\"unexpected failure count\", testResult.getFailureCount(), is(equalTo(0)));\n        assertThat(\"unexpected failure count\", testResult.getIgnoreCount(), is(equalTo(0)));\n    }",
        "human_comment": "This test is mentioned in {@code Categories} and any changes\nmust be reflected.",
        "model_generated_comment": "p>Assert/p> that @link MultiCategorySuite.class is not a valid test."
    },
    {
        "id": 481,
        "code_snippet": "private int getNumChars() {\n    int len = 0;\n    for (int i = 0; i < numBytes; i += numBytesForFirstByte(getByte(i))) {\n      len += 1;\n    }\n    return len;\n  }",
        "human_comment": "Private helper method to calculate the number of code points in the UTF-8 string. Counting\nthe code points is a linear time operation, as we need to scan the entire UTF-8 string.\nHence, this method should generally only be called once for non-empty UTF-8 strings.",
        "model_generated_comment": "@code numChars @param numBytesForFirstByte(i) @return len = 0; if len is 0 then the numchars will be numbed to num bytes."
    },
    {
        "id": 482,
        "code_snippet": "public VideoStreamingService getBusinessService(String movie) {\n    if (movie.toLowerCase(Locale.ROOT).contains(\"die hard\")) {\n      return netflixService;\n    } else {\n      return youTubeService;\n    }\n  }",
        "human_comment": "Gets service instance based on given movie search string.\n\n@param movie Search string for the movie.\n@return Service instance.",
        "model_generated_comment": "Returns a VideoStreamingService @link Die Hard. @param diehard a video streaming service if it's not already there. @return youTubeService if there's no video streaming service."
    },
    {
        "id": 483,
        "code_snippet": "public void setArray(ColumnarArray value) {\n    arrayData = value;\n  }",
        "human_comment": "Sets the `ColumnarArray` `value` for all rows",
        "model_generated_comment": "Sets the value of a column array. @param value @link columnarArray."
    },
    {
        "id": 484,
        "code_snippet": "private void showToast(final String text) {\n    final Activity activity = getActivity();\n    if (activity != null) {\n      activity.runOnUiThread(\n          new Runnable() {\n          });\n    }\n  }",
        "human_comment": "Shows a {@link Toast} on the UI thread.\n\n@param text The message to show",
        "model_generated_comment": "@code null if the activity is not runnable. p>Assert that the Activity is running on a UiThread."
    },
    {
        "id": 485,
        "code_snippet": "public void selfSpillIsLowestPriorities() {\n    final TestMemoryManager memoryManager = new TestMemoryManager(new SparkConf());\n    memoryManager.limit(100);\n    final TaskMemoryManager manager = new TaskMemoryManager(memoryManager, 0);\n\n    TestMemoryConsumer c1 = new TestMemoryConsumer(manager);\n    TestMemoryConsumer c2 = new TestMemoryConsumer(manager);\n    TestMemoryConsumer c3 = new TestMemoryConsumer(manager);\n\n    c1.use(50);\n    c2.use(40);\n    c3.use(10);\n    c1.use(50);\n    Assertions.assertEquals(100, c1.getUsed());\n    Assertions.assertEquals(0, c2.getUsed());\n    Assertions.assertEquals(0, c3.getUsed());\n    c1.use(50);\n    Assertions.assertEquals(50, c1.getUsed());\n    c2.use(10);\n    c1.use(60);\n    Assertions.assertEquals(60, c1.getUsed());\n    Assertions.assertEquals(0, c2.getUsed());\n\n    c1.free(c1.getUsed());\n\n    c1.use(50);\n    c2.use(40);\n    c3.use(10);\n    c3.use(50);\n    Assertions.assertEquals(0, c1.getUsed());\n    Assertions.assertEquals(40, c2.getUsed());\n    Assertions.assertEquals(60, c3.getUsed());\n  }",
        "human_comment": "Test that requesting memory consumer (a \"self-spill\") is chosen last to spill.\nSelf-spill is the lowest priority: c2 and c3 are spilled first even though they have less\nmemory.\nForce a self-spill.\nForce a self-spill after c2 is spilled.\nRedo a similar scenario but with a different memory requester.",
        "model_generated_comment": "p>Assertions/p> @link TestMemoryManager c1.use(50) and c2.use(40), c3.use(10), c4.use(10), e.g. c5.assertEquals(50, 0) www.sparkconf.org/www/sparkConf.aspx/href=\"https://github.com/test-m-assertionshttps#testMe"
    },
    {
        "id": 486,
        "code_snippet": "public ModelBuildingException(ModelBuildingResult result) {\n        super(toMessage(result));\n        this.result = result;\n    }",
        "human_comment": "Creates a new exception from the specified interim result and its associated problems.\n\n@param result The interim result, may be {@code null}.",
        "model_generated_comment": "@link ModelBuildingException. @param result the result of a model building exception. @result the result if a result is returned."
    },
    {
        "id": 487,
        "code_snippet": "public MavenProject getTopLevelProject() {\n        return sortedProjects.stream()\n                .filter(MavenProject::isExecutionRoot)\n                .findFirst()\n                .orElse(null);\n    }",
        "human_comment": "TODO !![jc; 28-jul-2005] check this; if we're using '-r' and there are aggregator tasks, this will result in\nweirdness.",
        "model_generated_comment": "p>MavenProject::isExecutionRoot/p> if a Maven project is @code /code>, it should be a top level project."
    },
    {
        "id": 488,
        "code_snippet": "void testMissingArtifactMessageFormat() {\n        String message = \"Missing artifact\";\n        String indentation = \"  \";\n        String groupId = \"aGroupId\";\n        String artifactId = \"anArtifactId\";\n        String version = \"aVersion\";\n        String type = \"jar\";\n        String classifier = \"aClassifier\";\n        String downloadUrl = \"http://somewhere.com/download\";\n        List<String> path = Arrays.asList(\"dependency1\", \"dependency2\");\n        String expected = \"Missing artifact\" + LS + LS + \"  Try downloading the file manually from: \" + LS\n                + \"      http://somewhere.com/download\" + LS + LS + \"  Then, install it using the command: \" + LS\n                + \"      mvn install:install-file -DgroupId=aGroupId -DartifactId=anArtifactId -Dversion=aVersion \"\n                + \"-Dclassifier=aClassifier -Dpackaging=jar -Dfile=/path/to/file\" + LS + LS\n                + \"  Alternatively, if you host your own repository you can deploy the file there: \" + LS\n                + \"      mvn deploy:deploy-file -DgroupId=aGroupId -DartifactId=anArtifactId\"\n                + \" -Dversion=aVersion -Dclassifier=aClassifier -Dpackaging=jar -Dfile=/path/to/file\"\n                + \" -Durl=[url] -DrepositoryId=[id]\" + LS + LS + \"  Path to dependency: \" + LS + \"  \\t1) dependency1\"\n                + LS + \"  \\t2) dependency2\" + LS + LS;\n        String actual = AbstractArtifactResolutionException.constructMissingArtifactMessage(\n                message, indentation, groupId, artifactId, version, type, classifier, downloadUrl, path);\n        assertEquals(expected, actual);\n    }",
        "human_comment": "Test the artifact resolution exception message",
        "model_generated_comment": "@link MissingArtifactMessage @param groupId -DartifactId> An artifact is a jar file that contains a group of jars and a classifier. @return the file if it is missing a particular group."
    },
    {
        "id": 489,
        "code_snippet": "public static void assertEquals(byte expected, Byte actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals((Byte) expected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 490,
        "code_snippet": "public static void assertEquals(Character expected, Character actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n\n@since 5.4",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 491,
        "code_snippet": "void testFormatRateEdgeCases() {\n        FileSizeFormat format = new FileSizeFormat();\n\n        MessageBuilder builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 0.0);\n        assertEquals(\"0.0 B/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000.0);\n        assertEquals(\"1.0 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000000.0);\n        assertEquals(\"1.0 MB/s\", builder.build());\n    }",
        "human_comment": "Test zero rate\nTest rate at exactly 1000 (1 kB/s)\nTest rate at exactly 1000000 (1 MB/s)",
        "model_generated_comment": "Builds a new DefaultMessageBuilder using @link. @param fileSizeFormat a file size of 1.0 kB/s. @return a DefaultMailBuilder a messagebuilder with a default message builder with the default message size."
    },
    {
        "id": 492,
        "code_snippet": "public void preferNewTestsOverTestsThatFailed() {\n        Request one = Request.method(TwoTests.class, \"dontSucceed\");\n        fMax.run(one);\n        Request two = Request.aClass(TwoTests.class);\n        List<Description> things = fMax.sortedLeavesForTest(two);\n        Description succeed = Description.createTestDescription(TwoTests.class,\n                \"succeed\");\n        assertEquals(succeed, things.get(0));\n        assertEquals(2, things.size());\n    }",
        "human_comment": "This covers a seemingly-unlikely case, where you had a test that failed\non the\nlast run and you also introduced new tests. In such a case it pretty much\ndoesn't matter\nwhich order they run, you just want them both to be early in the sequence",
        "model_generated_comment": "p>Tests that fail/p>Attribute a @link TestDescription class. @param two if a test fails, if it fails, then the test will fail. @return a new test over a failed one if the test fails."
    },
    {
        "id": 493,
        "code_snippet": "public Requirement clone() {\n        try {\n            return (Requirement) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e);\n        }\n    }",
        "human_comment": "Creates a shallow copy of this requirement.",
        "model_generated_comment": "@link Requirement clone @return a request that clones a requirement."
    },
    {
        "id": 494,
        "code_snippet": "public static void assertTrue(boolean condition, String message) {\n\t\tAssertTrue.assertTrue(condition, message);\n\t}",
        "human_comment": "<em>Assert</em> that the supplied {@code condition} is {@code true}.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "p>Assert/p> that the @code condition is true."
    },
    {
        "id": 495,
        "code_snippet": "public Action(GiantModel giant) {\n    this.giant = giant;\n  }",
        "human_comment": "Instantiates a new Action.\n\n@param giant the giant",
        "model_generated_comment": "Action(GiantModel giant) @link GiantModel. @param giant the giant model."
    },
    {
        "id": 496,
        "code_snippet": "public Try<V> orElse(Supplier<Try<V>> supplier) {\n\t\t\treturn this;\n\t\t}",
        "human_comment": "don't call supplier because this Try is a success",
        "model_generated_comment": "p>Supplier/p> orElse(SupplyerTryV>>) if the @link Supplier/@link Provider/etc> is not a supplier, it is a provider."
    },
    {
        "id": 497,
        "code_snippet": "public String toString() {\n    return new String(getBytes(), StandardCharsets.UTF_8);\n  }",
        "human_comment": "Returns a string representation of this UTF8String object. The string representation consists\nof the string's characters encoded in UTF-8 and the result of this method is always a valid\nUTF-8 string. However, if the current UTF8String contains illegal UTF-8 byte sequences, the\nmethod will replace the illegal byte sequences with the Unicode replacement character U+FFFD,\naccording to Java specification. Using this method with invalid UTF8Strings is NOT RECOMMENDED.",
        "model_generated_comment": "Returns a String with @link StandardCharsets.UTF_8."
    },
    {
        "id": 498,
        "code_snippet": "Stream<CompositeTestSource> createSerializableInstances() {\n\t\tvar fileSource = FileSource.from(new File(\"sample.instance\"));\n\t\tvar classSource = ClassSource.from(getClass());\n\t\tvar sources = List.of(fileSource, classSource);\n\t\treturn Stream.of(CompositeTestSource.from(sources));\n\t}",
        "human_comment": "Unit tests for {@link CompositeTestSource}.\n\n@since 1.0",
        "model_generated_comment": "Stream @link CompositeTestSource. @param fileSource, classSource if the Stream is not created. @return a Stream of Streams that are created by StreamSerializableInstances if there is no Stream."
    },
    {
        "id": 499,
        "code_snippet": "void blankness() {\n\t\t// @formatter:off\n\t\tassertAll(\"Blankness\",\n\t\t\t() -> assertTrue(isBlank(null)),\n\t\t\t() -> assertTrue(isBlank(\"\")),\n\t\t\t() -> assertTrue(isBlank(\" \\t\\n\\r\")),\n\t\t\t() -> assertTrue(isNotBlank(\".\"))\n\t\t);\n\t\t// @formatter:on\n\t}",
        "human_comment": "Unit tests for {@link StringUtils}.\n\n@since 1.0",
        "model_generated_comment": "@formatter:on @link Blankness @param blankness /@link NotBlank(null) @return a blankness that is not blank if the blankness is a null value."
    },
    {
        "id": 500,
        "code_snippet": "public static Condition<Event> nestedContainer(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(clazz.getEnclosingClass(), () -> clazz.getName() + \" must be a nested class\");\n\n\t\tList<String> classNames = new ArrayList<>();\n\t\tfor (Class<?> current = clazz; current != null; current = current.getEnclosingClass()) {\n\t\t\tclassNames.add(0, current.getSimpleName());\n\t\t}\n\n\t\treturn allOf(container(), uniqueIdSubstrings(classNames));\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if an\na {@linkplain TestDescriptor#isContainer() container} and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the\nsimple names of the supplied {@link Class} and all of its\n{@linkplain Class#getEnclosingClass() enclosing classes}.\n\n<p>Please note that this method does not differentiate between static\nnested classes and non-static member classes (e.g., inner classes).\n\n@see #nestedContainer(Class, Condition)",
        "model_generated_comment": "@code null if the nested class is null."
    },
    {
        "id": 501,
        "code_snippet": "public void removeCIEnvironmentVariables() {\n        environmentVariables.putAll(Map.of(\n                \"CIRCLECI\", \"\",\n                \"CI\", \"false\",\n                \"GITHUB_ACTIONS\", \"\",\n                \"WORKSPACE\", \"\",\n                \"TEAMCITY_VERSION\", \"\",\n                \"TRAVIS\", \"\"));\n    }",
        "human_comment": "This method renders all env variables that are used for CI detection (by all known detector) to not trigger.",
        "model_generated_comment": "p>Removes the CI Environment Variables/p>. @param CIEnvironmentVariables @link CIRCLECI/@link CI. @remove CIenvironmentalvariables the environment variable."
    },
    {
        "id": 502,
        "code_snippet": "public Result run(junit.framework.Test test) {\n        return run(new JUnit38ClassRunner(test));\n    }",
        "human_comment": "Run all the tests contained in JUnit 3.8.x <code>test</code>. Here for backward compatibility.\n\n@param test the old-style test\n@return a {@link Result} describing the details of the test run and the failed tests.",
        "model_generated_comment": "Runs a JUnit38 class @link Test. @param test if a test is run."
    },
    {
        "id": 503,
        "code_snippet": "protected void printDefectHeader(TestFailure booBoo, int count) {\n        getWriter().print(count + \") \" + booBoo.failedTest());\n    }",
        "human_comment": "I feel like making this a println, then adding a line giving the throwable a chance to print something\nbefore we get to the stack trace.",
        "model_generated_comment": "p>TestFailure/p> a booBoo @code count. @param count the number of test failures."
    },
    {
        "id": 504,
        "code_snippet": "public void close() {\n\t\tif (!this.closed) {\n\t\t\ttry {\n\t\t\t\tif (this.closeAction != null) {\n\t\t\t\t\tThrowableCollector throwableCollector = new ThrowableCollector(__ -> false);\n\t\t\t\t\tthis.storedValues.entrySet().stream() //\n\t\t\t\t\t\t\t.map(e -> e.getValue().evaluateSafely(e.getKey())) //\n\t\t\t\t\t\t\t.filter(it -> it != null && it.value != null) //\n\t\t\t\t\t\t\t.sorted(EvaluatedValue.REVERSE_INSERT_ORDER) //\n\t\t\t\t\t\t\t.forEach(it -> throwableCollector.execute(() -> it.close(this.closeAction)));\n\t\t\t\t\tthrowableCollector.assertEmpty();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.closed = true;\n\t\t\t}\n\t\t}\n\t}",
        "human_comment": "If a {@link CloseAction} is configured, it will be called with all successfully\nstored values in reverse insertion order.\n\n<p>Closing a store does not close its parent or any of its children.\n\n<p>Invocations of this method after the store has already been closed will\nbe ignored.\n\n@see #isClosed()",
        "model_generated_comment": "@link ThrowableCollector/@link EvaluatedValues/www/evaluatedvalues @param null if the value is a null value."
    },
    {
        "id": 505,
        "code_snippet": "public void testNoOOMDuringReset() {\n    final SparkConf sparkConf = new SparkConf();\n    sparkConf.set(package$.MODULE$.MEMORY_OFFHEAP_ENABLED(), false);\n\n    final TestMemoryManager testMemoryManager =\n            new TestMemoryManager(sparkConf);\n    final TaskMemoryManager memoryManager = new TaskMemoryManager(\n            testMemoryManager, 0);\n    final TestMemoryConsumer consumer = new TestMemoryConsumer(memoryManager);\n\n    final PrefixComparator prefixComparator = PrefixComparators.LONG;\n    final RecordComparator recordComparator = new RecordComparator() {\n    };\n    UnsafeInMemorySorter sorter = new UnsafeInMemorySorter(consumer, memoryManager,\n            recordComparator, prefixComparator, 100, shouldUseRadixSort());\n\n    testMemoryManager.markconsequentOOM(Integer.MAX_VALUE);\n    sorter.freeMemory();\n    testMemoryManager.resetConsequentOOM();\n    Assertions.assertFalse(sorter.hasSpaceForAnotherRecord());\n\n    LongArray array = consumer.allocateArray(1000);\n    sorter.expandPointerArray(array);\n\n    testMemoryManager.markconsequentOOM(Integer.MAX_VALUE);\n    sorter.freeMemory();\n    sorter.freeMemory();\n    testMemoryManager.resetConsequentOOM();\n    Assertions.assertFalse(sorter.hasSpaceForAnotherRecord());\n\n    assertEquals(0L, memoryManager.cleanUpAllAllocatedMemory());\n  }",
        "human_comment": "Use integer comparison for comparing prefixes (which are partition ids, in this case)\nEnsure that the sorter does not OOM while freeing its memory.\nGet the sorter in an usable state again by allocating a new pointer array.\nEnsure that it is safe to call freeMemory() multiple times.",
        "model_generated_comment": "p>Assert/p> that @link MemoryManager is a memory manager."
    },
    {
        "id": 506,
        "code_snippet": "public BuildResumptionPersistenceException(String message, Throwable cause) {\n        super(message, cause);\n    }",
        "human_comment": "This exception will be thrown when something fails while persisting build resumption data.\n@see BuildResumptionDataRepository#persistResumptionData",
        "model_generated_comment": "@link BuildResumptionPersistenceException. @param message, Throwable cause."
    },
    {
        "id": 507,
        "code_snippet": "public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n    if (roundEnv.processingOver()) {\n      return false;\n    }\n\n    if (annotations.size() == 0) {\n      return false;\n    }\n\n    if (annotations.size() != 1) {\n      throw new IllegalStateException(\n          \"Unexpected - multiple annotations registered: \" + annotations);\n    }\n    TypeElement annotation = annotations.iterator().next();\n    Set<? extends Element> annotated = roundEnv.getElementsAnnotatedWith(annotation);\n\n    if (annotated.size() == 0) {\n      return false;\n    }\n\n    if (hasRun) {\n      for (Element e : annotated) {\n        error(\n            e,\n            \"The Operator processor has already processed @Operator annotated sources\\n\"\n                + \"and written out an Ops API. It cannot process additional @Operator sources.\\n\"\n                + \"One reason this can happen is if other annotation processors generate\\n\"\n                + \"new @Operator source files.\");\n      }\n      return false;\n    }\n\n    Multimap<String, MethodSpec> groupedMethods = HashMultimap.create();\n    if (!collectOpsMethods(roundEnv, groupedMethods, annotation)) {\n      return false;\n    }\n\n    if (groupedMethods.isEmpty()) {\n      return false;\n    }\n\n    writeApi(groupedMethods);\n\n    hasRun = true;\n    return false;\n  }",
        "human_comment": "Nothing needs to be done at the end of all rounds.\nNothing to look at in this round.\nWe expect to be registered for exactly one annotation.\nIf there are no annotated elements, claim the annotation but do nothing.\nThis processor has to aggregate all op classes in one round, as it generates a single Ops\nAPI class which cannot be modified once generated. If we find an annotation after we've\ngenerated our code, flag the location of each such class.\nCollect all classes tagged with our annotation.\nNothing to do when there are no tagged classes.\nValidate operator classes and generate Op API.",
        "model_generated_comment": "@link Annotations @param annotated Element @return a boolean process if an annotation is already registered."
    },
    {
        "id": 508,
        "code_snippet": "void testEquality() {\n\n    /* Create some students */\n    final var firstStudent = new Student(1, \"Adam\", 'A');\n    final var secondStudent = new Student(2, \"Donald\", 'B');\n    final var secondSameStudent = new Student(2, \"Donald\", 'B');\n\n    /* Check equals functionality: should return 'true' */\n    assertEquals(firstStudent, firstStudent);\n\n    /* Check equals functionality: should return 'false' */\n    assertNotEquals(firstStudent, secondStudent);\n\n    /* Check equals functionality: should return 'true' */\n    assertEquals(secondStudent, secondSameStudent);\n  }",
        "human_comment": "This API tests the equality behaviour of Student object Object Equality should work as per\nlogic defined in equals method\n\n@throws Exception if any execution error during test",
        "model_generated_comment": "Create some students */var firstStudent = new Student(1, \"Adam\", 'A'); final var secondSameSeparate = new student(2, \"Donald\"); var @code /code '@code #checkEquals() = 'true'"
    },
    {
        "id": 509,
        "code_snippet": "long checksumByReader) {\n    Cause cause;\n    long duration = -1L;\n    long checksumByWriter = -1L;\n    long checksumByReCalculation = -1L;\n    try {\n      long diagnoseStartNs = System.nanoTime();\n      // Try to get the checksum instance before reading the checksum file so that\n      // `UnsupportedOperationException` can be thrown first before `FileNotFoundException`\n      // when the checksum algorithm isn't supported.\n      Checksum checksumAlgo = getChecksumByAlgorithm(algorithm);\n      checksumByWriter = readChecksumByReduceId(checksumFile, reduceId);\n      checksumByReCalculation = calculateChecksumForPartition(partitionData, checksumAlgo);\n      duration = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - diagnoseStartNs);\n      if (checksumByWriter != checksumByReCalculation) {\n        cause = Cause.DISK_ISSUE;\n      } else if (checksumByWriter != checksumByReader) {\n        cause = Cause.NETWORK_ISSUE;\n      } else {\n        cause = Cause.CHECKSUM_VERIFY_PASS;\n      }\n    } catch (UnsupportedOperationException e) {\n      cause = Cause.UNSUPPORTED_CHECKSUM_ALGORITHM;\n    } catch (FileNotFoundException e) {\n      // Even if checksum is enabled, a checksum file may not exist if error throws during writing.\n      logger.warn(\"Checksum file {} doesn't exit\",\n        MDC.of(LogKeys.PATH$.MODULE$, checksumFile.getName()));\n      cause = Cause.UNKNOWN_ISSUE;\n    } catch (Exception e) {\n      logger.warn(\"Unable to diagnose shuffle block corruption\", e);\n      cause = Cause.UNKNOWN_ISSUE;\n    }\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Shuffle corruption diagnosis took {} ms, checksum file {}, cause {}, \" +\n        \"checksumByReader {}, checksumByWriter {}, checksumByReCalculation {}\",\n        duration, checksumFile.getAbsolutePath(), cause,\n        checksumByReader, checksumByWriter, checksumByReCalculation);\n    } else {\n      logger.info(\"Shuffle corruption diagnosis took {} ms, checksum file {}, cause {}\",\n        MDC.of(LogKeys.TIME$.MODULE$, duration),\n        MDC.of(LogKeys.PATH$.MODULE$, checksumFile.getAbsolutePath()),\n        MDC.of(LogKeys.REASON$.MODULE$, cause));\n    }\n    return cause;\n  }",
        "human_comment": "Diagnose the possible cause of the shuffle data corruption by verifying the shuffle checksums.\n\nThere're 3 different kinds of checksums for the same shuffle partition:\n- checksum (c1) that is calculated by the shuffle data reader\n- checksum (c2) that is calculated by the shuffle data writer and stored in the checksum file\n- checksum (c3) that is recalculated during diagnosis\n\nAnd the diagnosis mechanism works like this:\nIf c2 != c3, we suspect the corruption is caused by the DISK_ISSUE. Otherwise, if c1 != c3,\nwe suspect the corruption is caused by the NETWORK_ISSUE. Otherwise, the cause remains\nCHECKSUM_VERIFY_PASS. In case of the any other failures, the cause remains UNKNOWN_ISSUE.\n\n@param algorithm The checksum algorithm that is used for calculating checksum value\nof partitionData\n@param checksumFile The checksum file that written by the shuffle writer\n@param reduceId The reduceId of the shuffle block\n@param partitionData The partition data of the shuffle block\n@param checksumByReader The checksum value that calculated by the shuffle data reader\n@return The cause of data corruption",
        "model_generated_comment": "@link Unable to diagnose shuffle block corruption if the checksum algorithm isn't supported, a checksum file may not exist if error throws during writing."
    },
    {
        "id": 510,
        "code_snippet": "public static Constant<Double> create(Scope scope, long[] shape, DoubleBuffer data) {\n    try (Tensor<Double> value = Tensor.create(shape, data)) {\n      return createWithTensor(scope, value);\n    }\n  }",
        "human_comment": "Create a {@link DataType#DOUBLE} constant with data from the given buffer.\n\n<p>Creates a constant with the given shape by copying elements from the buffer (starting from\nits current position) into the tensor. For example, if {@code shape = {2,3} } (which represents\na 2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param scope is a scope used to add the underlying operation.\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@return a double constant\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer",
        "model_generated_comment": "Creates a new Tensor with a @link DoubleBuffer value. @param shape scope a long[] shape a doubleBuffer data a single tensor."
    },
    {
        "id": 511,
        "code_snippet": "private ReceiptViewModel purchase(Db.User user, Db.Account account, String itemName) {\n    Db.Product item = Db.getInstance().findProductByItemName(itemName);\n    if (item == null) {\n      return new OutOfStock(user.getUserName(), itemName);\n    }\n\n    ReceiptDto receipt = user.purchase(item);\n    MoneyTransaction transaction = account.withdraw(receipt.getPrice());\n    if (transaction == null) {\n      return new InsufficientFunds(user.getUserName(), account.getAmount(), itemName);\n    }\n\n    return receipt;\n  }",
        "human_comment": "Domain purchase with user, account and itemName, with validation for whether product is out of\nstock and whether user has insufficient funds in the account.\n\n@param user in Db\n@param account in Db\n@param itemName of the item\n@return instance of ReceiptViewModel",
        "model_generated_comment": "Returns a ReceiptViewModel purchase. @param itemName @link InsufficientFunds if the transaction is not available. @return the receipt if it's not available if there's no receipt."
    },
    {
        "id": 512,
        "code_snippet": "void shouldExecuteApplicationWithoutException() {\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
        "human_comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception.",
        "model_generated_comment": "p>Application with @code Exception should not be executed."
    },
    {
        "id": 513,
        "code_snippet": "default String extractCatalog(CaseInsensitiveStringMap options) {\n    return CatalogManager.SESSION_CATALOG_NAME();\n  }",
        "human_comment": "Return the name of a catalog that can be used to check the existence of, load, and create\na table for this DataSource given the identifier that will be extracted by\n{@link #extractIdentifier(CaseInsensitiveStringMap) extractIdentifier}. A `null` value can\nbe used to defer to the V2SessionCatalog.\n\n@param options the user-specified options that can identify a table, e.g. file path, Kafka\ntopic name, etc. It's an immutable case-insensitive string-to-string map.",
        "model_generated_comment": "Returns the name of the session. @param @link CatalogManager.SESSION_CATALOG_NAME."
    },
    {
        "id": 514,
        "code_snippet": "public static void assertEquals(float expected, Float actual, String message) {\n\t\tAssertEquals.assertEquals((Float) expected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Float#equals(Object)} and\n{@link Float#compare(float, float)}.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 515,
        "code_snippet": "public void setConfiguration(Object configuration) {\n        this.configuration = configuration;\n    } // -- void setConfiguration( Object )",
        "human_comment": "Set configuration to pass to all goals run in this phase.\n\n@param configuration a configuration object.",
        "model_generated_comment": "Sets the configuration of a @link configuration object."
    },
    {
        "id": 516,
        "code_snippet": "public String getProperty(String key) {\n        return this.get(key);\n    }",
        "human_comment": "Searches for the property with the specified key in this property list.\n\n@param key the property key.\n@return the value in this property list with the specified key value.",
        "model_generated_comment": "Gets the key of the property. @param key the key to get the key. @return the key if the key is @code key>"
    },
    {
        "id": 517,
        "code_snippet": "public <T> void checkThat(final String reason, final T value, final Matcher<T> matcher) {\n        checkSucceeds(new Callable<Object>() {\n        });\n    }",
        "human_comment": "Adds a failure with the given {@code reason}\nto the table if {@code matcher} does not match {@code value}.\nExecution continues, but the test will fail at the end if the match fails.",
        "model_generated_comment": "Checks that @link MatcherT> matcher/@link T> matches the matcher. @param T value the value of the Matcher."
    },
    {
        "id": 518,
        "code_snippet": "public int[] getInts(int rowId, int count) {\n    int[] res = new int[count];\n    for (int i = 0; i < count; i++) {\n      res[i] = getInt(rowId + i);\n    }\n    return res;\n  }",
        "human_comment": "Gets int type values from {@code [rowId, rowId + count)}. The return values for the null slots\nare undefined and can be anything.",
        "model_generated_comment": "@link rowId = 0; i + i++) p>Returns a res of a row."
    },
    {
        "id": 519,
        "code_snippet": "protected Map<String, String> populateSystemProperties(LocalContext context) {\n        Properties systemProperties = new Properties();\n\n\n        EnvironmentUtils.addEnvVars(systemProperties);\n        SystemProperties.addSystemProperties(systemProperties);\n\n\n        Properties buildProperties = CLIReportingUtils.getBuildProperties();\n\n        String mavenVersion = buildProperties.getProperty(CLIReportingUtils.BUILD_VERSION_PROPERTY);\n        systemProperties.setProperty(Constants.MAVEN_VERSION, mavenVersion);\n\n        boolean snapshot = mavenVersion.endsWith(\"SNAPSHOT\");\n        if (snapshot) {\n            mavenVersion = mavenVersion.substring(0, mavenVersion.length() - \"SNAPSHOT\".length());\n            if (mavenVersion.endsWith(\"-\")) {\n                mavenVersion = mavenVersion.substring(0, mavenVersion.length() - 1);\n            }\n        }\n        String[] versionElements = mavenVersion.split(\"\\\\.\");\n        if (versionElements.length != 3) {\n            throw new IllegalStateException(\"Maven version is expected to have 3 segments: '\" + mavenVersion + \"'\");\n        }\n        systemProperties.setProperty(Constants.MAVEN_VERSION_MAJOR, versionElements[0]);\n        systemProperties.setProperty(Constants.MAVEN_VERSION_MINOR, versionElements[1]);\n        systemProperties.setProperty(Constants.MAVEN_VERSION_PATCH, versionElements[2]);\n        systemProperties.setProperty(Constants.MAVEN_VERSION_SNAPSHOT, Boolean.toString(snapshot));\n\n        String mavenBuildVersion = CLIReportingUtils.createMavenVersionString(buildProperties);\n        systemProperties.setProperty(Constants.MAVEN_BUILD_VERSION, mavenBuildVersion);\n\n        Map<String, String> result = toMap(systemProperties);\n        result.putAll(context.systemPropertiesOverrides);\n        return result;\n    }",
        "human_comment": "----------------------------------------------------------------------\nLoad environment and system properties\n----------------------------------------------------------------------\n----------------------------------------------------------------------\nProperties containing info about the currently running version of Maven\nThese override any corresponding properties set on the command line\n----------------------------------------------------------------------",
        "model_generated_comment": "@link MavenVersion @param versionElements if a new Maven version is expected to have 3 segments: '', '','' and '####### if the current version is not a maven version."
    },
    {
        "id": 520,
        "code_snippet": "default boolean viewExists(Identifier ident) {\n    try {\n      return loadView(ident) != null;\n    } catch (NoSuchViewException e) {\n      return false;\n    }\n  }",
        "human_comment": "Test whether a view exists using an {@link Identifier identifier} from the catalog.\n<p>\nIf the catalog supports views and contains a view for the identifier and not a table,\nthis must return false.\n\n@param ident a view identifier\n@return true if the view exists, false otherwise",
        "model_generated_comment": "Returns a boolean viewExists(Identifier ident) with @code null."
    },
    {
        "id": 521,
        "code_snippet": "private void skipValues(int total) {\n    readValues(total, null, -1, (w, r, v) -> {});\n  }",
        "human_comment": "Read the values but don't write them out (the writer output method is a no-op)",
        "model_generated_comment": "@link skipValues. @param total, null, -1, (w, r, v) if the value is null."
    },
    {
        "id": 522,
        "code_snippet": "public void executionSkipped(TestDescriptor testDescriptor, String reason) {\n\t\tthis.events.add(Event.executionSkipped(testDescriptor, reason));\n\t}",
        "human_comment": "Record an {@link Event} for a container or test that was skipped.",
        "model_generated_comment": "p>Events/p>TestDescriptor/P>. @param reason @code https://github.com/events/Event.executionSkipped/>."
    },
    {
        "id": 523,
        "code_snippet": "void testWatcherSemanticsWhenRegisteredAtInstanceLevelWithTestInstanceLifecyclePerClass() {\n\t\tClass<?> testClass = TestInstancePerClassInstanceLevelTestWatcherTestCase.class;\n\t\tassertStatsForAbstractDisabledMethodsTestCase(testClass);\n\n\t\tassertThat(TrackingTestWatcher.results.get(\"testDisabled\")).containsExactly(\"test\", \"repeatedTest\");\n\t}",
        "human_comment": "We get \"testDisabled\" events for the @Test method and the @RepeatedTest container.",
        "model_generated_comment": "TestWatcherSemanticsWhenRegisteredAtInstanceLevelWithTestInstanceLifecyclePerClass() p>TestWatcherTestCase/p>"
    },
    {
        "id": 524,
        "code_snippet": "handle.addListener(new SparkAppHandle.Listener() {\n        public void infoChanged(SparkAppHandle handle) {\n          semaphore.release();\n        }\n      });",
        "human_comment": "Make sure the server matched the client to the handle.\nLauncherServer will immediately close the server-side socket when the timeout is set\nto 0.",
        "model_generated_comment": "p>SparkAppHandle/p>Listener/a>. @param handle @code handle. @return a new handle if a handle is added to the handle."
    },
    {
        "id": 525,
        "code_snippet": "void testMultiply_NegativeFactor() {\n    Money money = new Money(100.00, \"USD\");\n\n    assertThrows(IllegalArgumentException.class, () -> money.multiply(-2));\n  }",
        "human_comment": "Test multiplying by a negative factor",
        "model_generated_comment": "Tests if a factor is not @code null. @param $multiply(100.00, \"USD\")."
    },
    {
        "id": 526,
        "code_snippet": "static TableChange updateColumnDefaultValue(String[] fieldNames, String newDefaultValue) {\n    return new UpdateColumnDefaultValue(fieldNames, newDefaultValue);\n  }",
        "human_comment": "Create a TableChange for updating the default value of a field.\n<p>\nThe name is used to find the field to update.\n<p>\nIf the field does not exist, the change will result in an {@link IllegalArgumentException}.\n\n@param fieldNames field names of the column to update\n@param newDefaultValue the new default value SQL string (Spark SQL dialect).\n@return a TableChange for the update",
        "model_generated_comment": "@link UpdateColumnDefaultValue. @param fieldNames, String newDefaultVALue. @return a new default value for a field in a column."
    },
    {
        "id": 527,
        "code_snippet": "public void error(String msg) {\n        out.print(ERROR);\n        out.println(msg);\n    }",
        "human_comment": "These are the only methods we need in our primordial logger",
        "model_generated_comment": "@link Error/@link Print a msg file. @param error if there is an error."
    },
    {
        "id": 528,
        "code_snippet": "private String toString(Object obj) {\n        String str;\n        if (obj != null && obj.getClass().isArray()) {\n            int n = Array.getLength(obj);\n            StringBuilder buf = new StringBuilder(256);\n            buf.append('[');\n            for (int i = 0; i < n; i++) {\n                if (i > 0) {\n                    buf.append(\", \");\n                }\n                buf.append(Array.get(obj, i));\n            }\n            buf.append(']');\n            str = buf.toString();\n        } else {\n            str = String.valueOf(obj);\n        }\n        return str;\n    }",
        "human_comment": "Creates a human-friendly string representation of the specified object.\n\n@param obj The object to create a string representation for, may be <code>null</code>.\n@return The string representation, never <code>null</code>.",
        "model_generated_comment": "p>If the @link obj is null, it will return a null value. @param 0 null if the object is a string. @return null the value of the object if it is not a String."
    },
    {
        "id": 529,
        "code_snippet": "public void set(final String userId, final UserAccount userAccount) {\n    cache.set(userId, userAccount);\n  }",
        "human_comment": "Delegate to backing cache store.\n\n@param userId {@link String}\n@param userAccount {@link UserAccount}",
        "model_generated_comment": "Sets the user ID of the user account. @param userId the userID of the final userAccount userAccount"
    },
    {
        "id": 530,
        "code_snippet": "public void free(MemoryBlock memory) {\n    assert (memory.obj != null) :\n      \"baseObject was null; are you trying to use the on-heap allocator to free off-heap memory?\";\n    assert (memory.pageNumber != MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER) :\n      \"page has already been freed\";\n    assert ((memory.pageNumber == MemoryBlock.NO_PAGE_NUMBER)\n            || (memory.pageNumber == MemoryBlock.FREED_IN_TMM_PAGE_NUMBER)) :\n      \"TMM-allocated pages must first be freed via TMM.freePage(), not directly in allocator \" +\n        \"free()\";\n\n    final long size = memory.size();\n    if (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) {\n      memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_FREED_VALUE);\n    }\n\n    memory.pageNumber = MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER;\n\n    long[] array = (long[]) memory.obj;\n    memory.setObjAndOffset(null, 0);\n\n    long alignedSize = ((size + 7) / 8) * 8;\n    if (shouldPool(alignedSize)) {\n      synchronized (this) {\n        LinkedList<WeakReference<long[]>> pool =\n          bufferPoolsBySize.computeIfAbsent(alignedSize, k -> new LinkedList<>());\n        pool.add(new WeakReference<>(array));\n      }\n    }\n  }",
        "human_comment": "Mark the page as freed (so we can detect double-frees).\nAs an additional layer of defense against use-after-free bugs, we mutate the\nMemoryBlock to null out its reference to the long[] array.",
        "model_generated_comment": "@link MemoryBlock @param null : \"MemoryBlock is an on-heap allocator\" @return null: \"This is a LinkedList with a WeakReference\" @example: \"this is not a TMM-allocated memory block\" @ask if you want to use a memory block to free memory."
    },
    {
        "id": 531,
        "code_snippet": "public static Queen createNotFlirtyQueen() {\n    return new Queen();\n  }",
        "human_comment": "Method to create a not flirty queen.\n\n@return A not flirty {@link com.iluwatar.objectmother.Queen}.",
        "model_generated_comment": "Creates a new Queen from a @link Queen."
    },
    {
        "id": 532,
        "code_snippet": "public static UnspecifiedDistribution unspecified() {\n    return LogicalDistributions.unspecified();\n  }",
        "human_comment": "Creates a distribution where no promises are made about co-location of data.",
        "model_generated_comment": "UnspecifiedDistribution is a @link Logical distribution."
    },
    {
        "id": 533,
        "code_snippet": "default DiscoveryIssue withMessage(UnaryOperator<String> messageModifier) {\n\t\tString oldMessage = message();\n\t\tString newMessage = messageModifier.apply(oldMessage);\n\t\tif (oldMessage.equals(newMessage)) {\n\t\t\treturn this;\n\t\t}\n\t\treturn DiscoveryIssue.builder(severity(), newMessage) //\n\t\t\t\t.source(source()) //\n\t\t\t\t.cause(cause()) //\n\t\t\t\t.build();\n\t}",
        "human_comment": "Create a copy of this issue with the modified message produced by the\nsupplied operator.",
        "model_generated_comment": "@link oldMessage/@link newMessage @param messageModifier @return this; if this is not the case, it will be used to build a new DiscoveryIssue."
    },
    {
        "id": 534,
        "code_snippet": "private void checkVersionsArrayEqual(String[] array) {\n        for (int i = 0; i < array.length; ++i) {\n            for (int j = i; j < array.length; ++j) {\n                checkVersionsEqual(array[i], array[j]);\n            }\n        }\n    }",
        "human_comment": "compare against each other (including itself)",
        "model_generated_comment": "p>Assert/p> that the @link array is equal to the array i. @param array the value of the array."
    },
    {
        "id": 535,
        "code_snippet": "public AlbumListPage navigateToPage() {\n    try {\n      page = this.webClient.getPage(PAGE_URL);\n    } catch (IOException e) {\n      LOGGER.error(\"An error occurred on navigateToPage.\", e);\n    }\n    return this;\n  }",
        "human_comment": "Navigates to the Album List Page.\n\n@return {@link AlbumListPage}",
        "model_generated_comment": "p>An error occurred on navigateToPage/p>."
    },
    {
        "id": 536,
        "code_snippet": "public boolean saslEncryption() {\n    return conf.getBoolean(\"spark.authenticate.enableSaslEncryption\", false);\n  }",
        "human_comment": "Whether to enable SASL-based encryption when authenticating using SASL.",
        "model_generated_comment": "p>Spark.authenticate.enableSaslEncryption/p>. @return a boolean if the @code encrypted is enabled."
    },
    {
        "id": 537,
        "code_snippet": "void setTo(Object src) {\n    if (src == null) {\n      if (hasDelegateBufferHandle(nativeHandle)) {\n        return;\n      }\n      throw new IllegalArgumentException(\n          \"Null inputs are allowed only if the Tensor is bound to a buffer handle.\");\n    }\n    throwIfTypeIsIncompatible(src);\n    throwIfSrcShapeIsIncompatible(src);\n    if (isBuffer(src)) {\n      setTo((Buffer) src);\n    } else if (dtype == DataType.STRING && shapeCopy.length == 0) {\n      // Update scalar string input with 1-d byte array.\n      writeScalar(nativeHandle, src);\n    } else if (src.getClass().isArray()) {\n      writeMultiDimensionalArray(nativeHandle, src);\n    } else {\n      writeScalar(nativeHandle, src);\n    }\n  }",
        "human_comment": "Copies the contents of the provided {@code src} object to the Tensor.\n\n<p>The {@code src} should either be a (multi-dimensional) array with a shape matching that of\nthis tensor, a {@link ByteBuffer} of compatible primitive type with a matching flat size, or\n{@code null} iff the tensor has an underlying delegate buffer handle.\n\n@throws IllegalArgumentException if the tensor is a scalar or if {@code src} is not compatible\nwith the tensor (for example, mismatched data types or shapes).",
        "model_generated_comment": "p>If the Tensor is bound to a src handle, the @code null will be null. a>Also, if a handle is not bound to the buffer handle, it will not be able to be used."
    },
    {
        "id": 538,
        "code_snippet": "public UnsafeRow getRow() {\n    row.setTotalSize(totalSize());\n    return row;\n  }",
        "human_comment": "Updates total size of the UnsafeRow using the size collected by BufferHolder, and returns\nthe UnsafeRow created at a constructor",
        "model_generated_comment": "Sets the total size of a row. @param totalSize() @link UnsafeRow() @return the value of the row to be set."
    },
    {
        "id": 539,
        "code_snippet": "default void info(@Nonnull String message) {\n        log(Level.INFO, message);\n    }",
        "human_comment": "Logs an info message without an associated exception.\n\n@param message the info message to be logged",
        "model_generated_comment": "@link String message @param message a string containing a message indicating the level of the message. @return the message if the message is a null string."
    },
    {
        "id": 540,
        "code_snippet": "void annotationOnField() {\n\t\texecuteTestsForClass(AnnotationOnFieldTestCase.class).testEvents()//\n\t\t\t\t.assertStatistics(stats -> stats.started(1).succeeded(1));\n\t}",
        "human_comment": "Integration tests for the use of {@link TempDir} as a meta-annotation.\n\n@since 5.10",
        "model_generated_comment": "p>AnnotationOnField/p> An annotation on a field is a method that can be used to create a test event."
    },
    {
        "id": 541,
        "code_snippet": "private ByteBuffer createHeaderByteBuffer() {\n            ByteBuffer encrypterHeader = encrypter.getHeader();\n            return ByteBuffer\n                    .allocate(encrypterHeader.remaining() + LENGTH_HEADER_BYTES)\n                    .putLong(encryptedCount)\n                    .put(encrypterHeader)\n                    .flip();\n        }",
        "human_comment": "If the ciphertext buffer cannot be fully written the target, transferTo may\nreturn with it containing some unwritten data. The initial call we'll explicitly\nset its limit to 0 to indicate the first call to transferTo.\nThe format of the output is:\n[8 byte length][Internal IV and header][Ciphertext][Auth Tag]",
        "model_generated_comment": "@link EncrypterHeaderByteBuffer @param length encryptedCount www.encrypterheader.com> p>EncrypterBytes/p>"
    },
    {
        "id": 542,
        "code_snippet": "public InitializationError(List<Throwable> errors) {\n        this.fErrors = errors;\n    }",
        "human_comment": "Construct a new {@code InitializationError} with one or more",
        "model_generated_comment": "@link InitializationError/@link Errors. @param errors if the initialization error is not found."
    },
    {
        "id": 543,
        "code_snippet": "public Saga setInValue(Object value) {\n    if (chapters.isEmpty()) {\n      return this;\n    }\n    chapters.get(chapters.size() - 1).setInValue(value);\n    return this;\n  }",
        "human_comment": "set value to last chapter.\n\n@param value invalue\n@return this",
        "model_generated_comment": "Sets the value of a @link Chapters. @param value the size of the chapter. @return this value if the value is empty."
    },
    {
        "id": 544,
        "code_snippet": "protected Filter createFilter(List<Class<?>> categories) {\n        return new IncludesAny(categories);\n    }",
        "human_comment": "Creates a {@link Filter} which is only passed by tests that are\ncategorized with any of the specified categories.\n\n@param categories Category classes.",
        "model_generated_comment": "p>Filter/p> if @code categories are not included in a Filter. @return the Filter that includes all categories. @param a class if no categories are included in the filter."
    },
    {
        "id": 545,
        "code_snippet": "public void testNormalize4() {\n        IMoney ms1 = MoneyBag.create(new Money(12, \"CHF\"), new Money(3, \"USD\"));\n        Money expected = new Money(-3, \"USD\");\n        assertEquals(expected, f12CHF.subtract(ms1));\n    }",
        "human_comment": "[12 CHF] - {[12 CHF][3 USD]} == [-3 USD]",
        "model_generated_comment": "@link IMoney @param moneyBag.create(ms1) and f12CHF(-3, \"USD\"); if ms1 is not already created, it will not be able to create a new Money."
    },
    {
        "id": 546,
        "code_snippet": "public static Tensor<Integer> create(int[][][] data) {\n    return Tensor.create(data, Integer.class);\n  }",
        "human_comment": "Creates a rank-3 tensor of {@code int} elements.\n\n@param data An array containing the values to put into the new tensor. The dimensions of the\nnew tensor will match those of the array.",
        "model_generated_comment": "Creates a new Tensor using @link Integer. @param data the data of a tensor."
    },
    {
        "id": 547,
        "code_snippet": "public Keypoint(final float x, final float y) {\n      this.x = x;\n      this.y = y;\n      this.score = 0;\n      this.type = -1;\n    }",
        "human_comment": "A simple class that records keypoint information, which includes\nlocal location, score and type. This will be used in calculating\nFrameChange.",
        "model_generated_comment": "@code x @param final float y @return a float with a value of 0 if the float is a valid float."
    },
    {
        "id": 548,
        "code_snippet": "public static String[] parseFullyQualifiedMethodName(String fullyQualifiedMethodName) {\n\t\tPreconditions.notBlank(fullyQualifiedMethodName, \"fullyQualifiedMethodName must not be null or blank\");\n\n\t\tint indexOfFirstHashtag = fullyQualifiedMethodName.indexOf('#');\n\t\tboolean validSyntax = (indexOfFirstHashtag > 0)\n\t\t\t\t&& (indexOfFirstHashtag < fullyQualifiedMethodName.length() - 1);\n\n\t\tPreconditions.condition(validSyntax,\n\t\t\t() -> \"[\" + fullyQualifiedMethodName + \"] is not a valid fully qualified method name: \"\n\t\t\t\t\t+ \"it must start with a fully qualified class name followed by a '#' \"\n\t\t\t\t\t+ \"and then the method name, optionally followed by a parameter list enclosed in parentheses.\");\n\n\t\tString className = fullyQualifiedMethodName.substring(0, indexOfFirstHashtag);\n\t\tString methodPart = fullyQualifiedMethodName.substring(indexOfFirstHashtag + 1);\n\t\tString methodName = methodPart;\n\t\tString methodParameters = \"\";\n\n\t\tif (methodPart.endsWith(\"()\")) {\n\t\t\tmethodName = methodPart.substring(0, methodPart.length() - 2);\n\t\t}\n\t\telse if (methodPart.endsWith(\")\")) {\n\t\t\tint indexOfLastOpeningParenthesis = methodPart.lastIndexOf('(');\n\t\t\tif ((indexOfLastOpeningParenthesis > 0) && (indexOfLastOpeningParenthesis < methodPart.length() - 1)) {\n\t\t\t\tmethodName = methodPart.substring(0, indexOfLastOpeningParenthesis);\n\t\t\t\tmethodParameters = methodPart.substring(indexOfLastOpeningParenthesis + 1, methodPart.length() - 1);\n\t\t\t}\n\t\t}\n\t\treturn new String[] { className, methodName, methodParameters };\n\n\t@API(status = INTERNAL, since = \"1.11\")\n\tpublic static String[] parseFullyQualifiedFieldName(String fullyQualifiedFieldName) {\n\t\tPreconditions.notBlank(fullyQualifiedFieldName, \"fullyQualifiedFieldName must not be null or blank\");\n\n\t\tint indexOfHashtag = fullyQualifiedFieldName.indexOf('#');\n\t\tboolean validSyntax = (indexOfHashtag > 0) && (indexOfHashtag < fullyQualifiedFieldName.length() - 1);\n\t\tPreconditions.condition(validSyntax,\n\t\t\t() -> \"[\" + fullyQualifiedFieldName + \"] is not a valid fully qualified field name: \"\n\t\t\t\t\t+ \"it must start with a fully qualified class name followed by a '#' \"\n\t\t\t\t\t+ \"and then the field name.\");\n\t\treturn fullyQualifiedFieldName.split(\"#\");\n\t}\n\n\tpublic static Set<Path> getAllClasspathRootDirectories() {\n\t\t// This is quite a hack, since sometimes the classpath is quite different\n\t\tString fullClassPath = System.getProperty(\"java.class.path\");\n\t\t// @formatter:off\n\t\treturn Arrays.stream(fullClassPath.split(File.pathSeparator))\n\t\t\t\t.map(Paths::get)\n\t\t\t\t.filter(Files::isDirectory)\n\t\t\t\t.collect(toSet());\n\t\t// @formatter:on\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInClasspathRoot(URI root, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\t// unmodifiable since returned by public, non-internal method(s)\n\t\treturn findAllClassesInClasspathRoot(root, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInClasspathRoot(URI root, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\treturn streamAllClassesInClasspathRoot(root, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInClasspathRoot(URI root, ClassFilter classFilter) {\n\t\treturn Collections.unmodifiableList(classpathScanner.scanForClassesInClasspathRoot(root, classFilter));\n\t}\n\n\tpublic static List<Resource> findAllResourcesInClasspathRoot(URI root, Predicate<Resource> resourceFilter) {\n\t\treturn Collections.unmodifiableList(classpathScanner.scanForResourcesInClasspathRoot(root, resourceFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInClasspathRoot(URI root, ClassFilter classFilter) {\n\t\treturn findAllClassesInClasspathRoot(root, classFilter).stream();\n\t}\n\n\tpublic static Stream<Resource> streamAllResourcesInClasspathRoot(URI root, Predicate<Resource> resourceFilter) {\n\t\treturn findAllResourcesInClasspathRoot(root, resourceFilter).stream();\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInPackage(String basePackageName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\t// unmodifiable since returned by public, non-internal method(s)\n\t\treturn findAllClassesInPackage(basePackageName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInPackage(String basePackageName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\treturn streamAllClassesInPackage(basePackageName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInPackage(String basePackageName, ClassFilter classFilter) {\n\t\treturn Collections.unmodifiableList(classpathScanner.scanForClassesInPackage(basePackageName, classFilter));\n\t}\n\n\tpublic static List<Resource> findAllResourcesInPackage(String basePackageName, Predicate<Resource> resourceFilter) {\n\t\treturn Collections.unmodifiableList(\n\t\t\tclasspathScanner.scanForResourcesInPackage(basePackageName, resourceFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInPackage(String basePackageName, ClassFilter classFilter) {\n\t\treturn findAllClassesInPackage(basePackageName, classFilter).stream();\n\t}\n\n\tpublic static Stream<Resource> streamAllResourcesInPackage(String basePackageName,\n\t\t\tPredicate<Resource> resourceFilter) {\n\t\treturn findAllResourcesInPackage(basePackageName, resourceFilter).stream();\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInModule(String moduleName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\t// unmodifiable since returned by public, non-internal method(s)\n\t\treturn findAllClassesInModule(moduleName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInModule(String moduleName, Predicate<Class<?>> classFilter,\n\t\t\tPredicate<String> classNameFilter) {\n\t\treturn streamAllClassesInModule(moduleName, ClassFilter.of(classNameFilter, classFilter));\n\t}\n\n\tpublic static List<Class<?>> findAllClassesInModule(String moduleName, ClassFilter classFilter) {\n\t\treturn Collections.unmodifiableList(ModuleUtils.findAllClassesInModule(moduleName, classFilter));\n\t}\n\n\tpublic static List<Resource> findAllResourcesInModule(String moduleName, Predicate<Resource> resourceFilter) {\n\t\treturn Collections.unmodifiableList(ModuleUtils.findAllResourcesInModule(moduleName, resourceFilter));\n\t}\n\n\tpublic static Stream<Class<?>> streamAllClassesInModule(String moduleName, ClassFilter classFilter) {\n\t\treturn findAllClassesInModule(moduleName, classFilter).stream();\n\t}\n\n\tpublic static Stream<Resource> streamAllResourcesInModule(String moduleName, Predicate<Resource> resourceFilter) {\n\t\treturn findAllResourcesInModule(moduleName, resourceFilter).stream();\n\t}\n\n\tpublic static List<Class<?>> findNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\tSet<Class<?>> candidates = new LinkedHashSet<>();\n\t\tvisitNestedClasses(clazz, predicate, nestedClass -> {\n\t\t\tcandidates.add(nestedClass);\n\t\t\treturn true;\n\t\t});\n\t\treturn Collections.unmodifiableList(new ArrayList<>(candidates));\n\t}\n\n\t@API(status = INTERNAL, since = \"1.13\")\n\tpublic static boolean isNestedClassPresent(Class<?> clazz, Predicate<Class<?>> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\tboolean visitorWasNotCalled = visitNestedClasses(clazz, predicate, __ -> false);\n\t\treturn !visitorWasNotCalled;\n\t}\n\n\tpublic static Stream<Class<?>> streamNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate) {\n\t\treturn findNestedClasses(clazz, predicate).stream();\n\t}\n\n\tprivate static boolean visitNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate,\n\t\t\tVisitor<Class<?>> visitor) {\n\t\tif (!isSearchable(clazz)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isInnerClass(clazz) && predicate.test(clazz)) {\n\t\t\tdetectInnerClassCycle(clazz);\n\t\t}\n\n\t\ttry {\n\t\t\t// Candidates in current class\n\t\t\tfor (Class<?> nestedClass : clazz.getDeclaredClasses()) {\n\t\t\t\tif (predicate.test(nestedClass)) {\n\t\t\t\t\tdetectInnerClassCycle(nestedClass);\n\t\t\t\t\tboolean shouldContinue = visitor.accept(nestedClass);\n\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoClassDefFoundError error) {\n\t\t\tlogger.debug(error, () -> \"Failed to retrieve declared classes for \" + clazz.getName());\n\t\t}\n\n\t\t// Search class hierarchy\n\t\tboolean shouldContinue = visitNestedClasses(clazz.getSuperclass(), predicate, visitor);\n\t\tif (!shouldContinue) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Search interface hierarchy\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tshouldContinue = visitNestedClasses(ifc, predicate, visitor);\n\t\t\tif (!shouldContinue) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static void detectInnerClassCycle(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tString className = clazz.getName();\n\n\t\tif (noCyclesDetectedCache.contains(className)) {\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (isInnerClass(clazz) && isSearchable(superclass)) {\n\t\t\tfor (Class<?> enclosing = clazz.getEnclosingClass(); enclosing != null; enclosing = enclosing.getEnclosingClass()) {\n\t\t\t\tif (superclass.equals(enclosing)) {\n\t\t\t\t\tthrow new JUnitException(String.format(\"Detected cycle in inner class hierarchy between %s and %s\",\n\t\t\t\t\t\tclassName, enclosing.getName()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnoCyclesDetectedCache.add(className);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> Constructor<T> getDeclaredConstructor(Class<T> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\tConstructor<?>[] constructors = Arrays.stream(clazz.getDeclaredConstructors())//\n\t\t\t\t\t.filter(ctor -> !ctor.isSynthetic())//\n\t\t\t\t\t.toArray(Constructor[]::new);\n\n\t\t\tPreconditions.condition(constructors.length == 1,\n\t\t\t\t() -> String.format(\"Class [%s] must declare a single constructor\", clazz.getName()));\n\n\t\t\treturn (Constructor<T>) constructors[0];\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\n\t\t}\n\t}\n\n\tpublic static List<Constructor<?>> findConstructors(Class<?> clazz, Predicate<Constructor<?>> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\ttry {\n\t\t\t// @formatter:off\n\t\t\treturn Arrays.stream(clazz.getDeclaredConstructors())\n\t\t\t\t\t.filter(predicate)\n\t\t\t\t\t.collect(toUnmodifiableList());\n\t\t\t// @formatter:on\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));\n\t\t}\n\t}\n\n\tpublic static List<Field> findFields(Class<?> clazz, Predicate<Field> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\treturn streamFields(clazz, predicate, traversalMode).collect(toUnmodifiableList());\n\t}\n\n\tpublic static Stream<Field> streamFields(Class<?> clazz, Predicate<Field> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\treturn findAllFieldsInHierarchy(clazz, traversalMode).stream()\n\t\t\t\t.filter(predicate)\n\t\t\t\t.distinct();\n\t\t// @formatter:on\n\t}\n\n\tprivate static List<Field> findAllFieldsInHierarchy(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\tField[] localFields = getDeclaredFields(clazz).stream()\n\t\t\t\t.filter(field -> !field.isSynthetic())\n\t\t\t\t.toArray(Field[]::new);\n\t\tField[] superclassFields = getSuperclassFields(clazz, traversalMode).stream()\n\t\t\t\t.filter(field -> isNotShadowedByLocalFields(field, localFields))\n\t\t\t\t.toArray(Field[]::new);\n\t\tField[] interfaceFields = getInterfaceFields(clazz, traversalMode).stream()\n\t\t\t\t.filter(field -> isNotShadowedByLocalFields(field, localFields))\n\t\t\t\t.toArray(Field[]::new);\n\t\t// @formatter:on\n\n\t\tList<Field> fields = new ArrayList<>(superclassFields.length + interfaceFields.length + localFields.length);\n\t\tif (traversalMode == TOP_DOWN) {\n\t\t\tCollections.addAll(fields, superclassFields);\n\t\t\tCollections.addAll(fields, interfaceFields);\n\t\t}\n\t\tCollections.addAll(fields, localFields);\n\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\tCollections.addAll(fields, interfaceFields);\n\t\t\tCollections.addAll(fields, superclassFields);\n\t\t}\n\t\treturn fields;\n\t}\n\n\tpublic static boolean isMethodPresent(Class<?> clazz, Predicate<Method> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\treturn findMethod(clazz, predicate).isPresent();\n\t}\n\n\t@API(status = DEPRECATED, since = \"1.4\")\n\t@Deprecated\n\tstatic Optional<Method> getMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\treturn tryToGetMethod(clazz, methodName, parameterTypes).toOptional();\n\t}\n\n\t@API(status = INTERNAL, since = \"1.4\")\n\tpublic static Try<Method> tryToGetMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\n\t\treturn Try.call(() -> clazz.getMethod(methodName, parameterTypes));\n\t}\n\n\t@API(status = INTERNAL, since = \"1.11\")\n\tpublic static Method getInterfaceMethodIfPossible(Method method, Class<?> targetClass) {\n\t\tif (!isPublic(method) || method.getDeclaringClass().isInterface()) {\n\t\t\treturn method;\n\t\t}\n\t\t// Try cached version of method in its declaring class\n\t\tMethod result = interfaceMethodCache.computeIfAbsent(method,\n\t\t\tm -> findInterfaceMethodIfPossible(m, m.getParameterTypes(), m.getDeclaringClass(), Object.class));\n\t\tif (result == method && targetClass != null) {\n\t\t\t// No interface method found yet -> try given target class (possibly a subclass of the\n\t\t\t// declaring class, late-binding a base class method to a subclass-declared interface:\n\t\t\t// see e.g. HashMap.HashIterator.hasNext)\n\t\t\tresult = findInterfaceMethodIfPossible(method, method.getParameterTypes(), targetClass,\n\t\t\t\tmethod.getDeclaringClass());\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static Method findInterfaceMethodIfPossible(Method method, Class<?>[] parameterTypes, Class<?> startClass,\n\t\t\tClass<?> endClass) {\n\n\t\tClass<?> current = startClass;\n\t\twhile (current != null && current != endClass) {\n\t\t\tfor (Class<?> ifc : current.getInterfaces()) {\n\t\t\t\ttry {\n\t\t\t\t\treturn ifc.getMethod(method.getName(), parameterTypes);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.getSuperclass();\n\t\t}\n\t\treturn method;\n\t}\n\n\tpublic static Optional<Method> findMethod(Class<?> clazz, String methodName, String parameterTypeNames) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\t\treturn findMethod(clazz, methodName, resolveParameterTypes(clazz, methodName, parameterTypeNames));\n\t}\n\n\t@API(status = INTERNAL, since = \"1.10\")\n\tpublic static Class<?>[] resolveParameterTypes(Class<?> clazz, String methodName, String parameterTypeNames) {\n\t\tif (StringUtils.isBlank(parameterTypeNames)) {\n\t\t\treturn EMPTY_CLASS_ARRAY;\n\t\t}\n\n\t\t// @formatter:off\n\t\treturn Arrays.stream(parameterTypeNames.split(\",\"))\n\t\t\t\t.map(String::trim)\n\t\t\t\t.map(typeName -> loadRequiredParameterType(clazz, methodName, typeName))\n\t\t\t\t.toArray(Class[]::new);\n\t\t// @formatter:on\n\t}\n\n\tprivate static Class<?> loadRequiredParameterType(Class<?> clazz, String methodName, String typeName) {\n\t\tClassLoader classLoader = ClassLoaderUtils.getClassLoader(clazz);\n\n\t\t// @formatter:off\n\t\treturn tryToLoadClass(typeName, classLoader)\n\t\t\t\t.getOrThrow(cause -> new JUnitException(\n\t\t\t\t\t\tString.format(\"Failed to load parameter type [%s] for method [%s] in class [%s].\",\n\t\t\t\t\t\t\t\ttypeName, methodName, clazz.getName()), cause));\n\t\t// @formatter:on\n\t}\n\n\tpublic static Optional<Method> findMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notBlank(methodName, \"Method name must not be null or blank\");\n\t\tPreconditions.notNull(parameterTypes, \"Parameter types array must not be null\");\n\t\tPreconditions.containsNoNullElements(parameterTypes, \"Individual parameter types must not be null\");\n\n\t\treturn findMethod(clazz, method -> hasCompatibleSignature(method, methodName, parameterTypes));\n\t}\n\n\tprivate static Optional<Method> findMethod(Class<?> clazz, Predicate<Method> predicate) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\n\t\tfor (Class<?> current = clazz; isSearchable(current); current = current.getSuperclass()) {\n\t\t\t// Search for match in current type\n\t\t\tList<Method> methods = current.isInterface() ? getMethods(current) : getDeclaredMethods(current, BOTTOM_UP);\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (predicate.test(method)) {\n\t\t\t\t\treturn Optional.of(method);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Search for match in interfaces implemented by current type\n\t\t\tfor (Class<?> ifc : current.getInterfaces()) {\n\t\t\t\tOptional<Method> optional = findMethod(ifc, predicate);\n\t\t\t\tif (optional.isPresent()) {\n\t\t\t\t\treturn optional;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Optional.empty();\n\t}\n\n\t@API(status = STABLE, since = \"1.7\")\n\tpublic static Method getRequiredMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) {\n\t\treturn ReflectionUtils.findMethod(clazz, methodName, parameterTypes).orElseThrow(\n\t\t\t() -> new JUnitException(format(\"Could not find method [%s] in class [%s]\", methodName, clazz.getName())));\n\t}\n\n\tpublic static List<Method> findMethods(Class<?> clazz, Predicate<Method> predicate) {\n\t\treturn findMethods(clazz, predicate, TOP_DOWN);\n\t}\n\n\tpublic static List<Method> findMethods(Class<?> clazz, Predicate<Method> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\treturn streamMethods(clazz, predicate, traversalMode).collect(toUnmodifiableList());\n\t}\n\n\tpublic static Stream<Method> streamMethods(Class<?> clazz, Predicate<Method> predicate,\n\t\t\tHierarchyTraversalMode traversalMode) {\n\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(predicate, \"Predicate must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\treturn findAllMethodsInHierarchy(clazz, traversalMode).stream()\n\t\t\t\t.filter(predicate)\n\t\t\t\t.distinct();\n\t\t// @formatter:on\n\t}\n\n\tprivate static List<Method> findAllMethodsInHierarchy(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\t\tPreconditions.notNull(traversalMode, \"HierarchyTraversalMode must not be null\");\n\n\t\t// @formatter:off\n\t\tMethod[] localMethods = getDeclaredMethods(clazz, traversalMode).stream()\n\t\t\t\t.filter(method -> !method.isSynthetic())\n\t\t\t\t.toArray(Method[]::new);\n\t\tMethod[] superclassMethods = getSuperclassMethods(clazz, traversalMode).stream()\n\t\t\t\t.filter(method -> isNotOverriddenByLocalMethods(method, localMethods))\n\t\t\t\t.toArray(Method[]::new);\n\t\tMethod[] interfaceMethods = getInterfaceMethods(clazz, traversalMode).stream()\n\t\t\t\t.filter(method -> isNotOverriddenByLocalMethods(method, localMethods))\n\t\t\t\t.toArray(Method[]::new);\n\t\t// @formatter:on\n\n\t\tList<Method> methods = new ArrayList<>(\n\t\t\tsuperclassMethods.length + interfaceMethods.length + localMethods.length);\n\t\tif (traversalMode == TOP_DOWN) {\n\t\t\tCollections.addAll(methods, superclassMethods);\n\t\t\tCollections.addAll(methods, interfaceMethods);\n\t\t}\n\t\tCollections.addAll(methods, localMethods);\n\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\tCollections.addAll(methods, interfaceMethods);\n\t\t\tCollections.addAll(methods, superclassMethods);\n\t\t}\n\t\treturn methods;\n\t}\n\n\tprivate static List<Field> getFields(Class<?> clazz) {\n\t\treturn toSortedMutableList(clazz.getFields());\n\t}\n\n\tprivate static List<Field> getDeclaredFields(Class<?> clazz) {\n\t\treturn toSortedMutableList(clazz.getDeclaredFields());\n\t}\n\n\tprivate static List<Method> getMethods(Class<?> clazz) {\n\t\treturn toSortedMutableList(clazz.getMethods());\n\t}\n\n\tprivate static List<Method> getDeclaredMethods(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\t// Note: getDefaultMethods() already sorts the methods,\n\t\tList<Method> defaultMethods = getDefaultMethods(clazz);\n\t\tList<Method> declaredMethods = toSortedMutableList(clazz.getDeclaredMethods());\n\n\t\t// Take the traversal mode into account in order to retain the inherited\n\t\t// nature of interface default methods.\n\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\tdeclaredMethods.addAll(defaultMethods);\n\t\t\treturn declaredMethods;\n\t\t}\n\t\telse {\n\t\t\tdefaultMethods.addAll(declaredMethods);\n\t\t\treturn defaultMethods;\n\t\t}\n\t}\n\n\tprivate static List<Method> getDefaultMethods(Class<?> clazz) {\n\t\t// @formatter:off\n\t\t// Visible default methods are interface default methods that have not\n\t\t// been overridden.\n\t\tList<Method> visibleDefaultMethods = Arrays.stream(clazz.getMethods())\n\t\t\t\t.filter(Method::isDefault)\n\t\t\t\t.collect(toCollection(ArrayList::new));\n\t\tif (visibleDefaultMethods.isEmpty()) {\n\t\t\treturn visibleDefaultMethods;\n\t\t}\n\t\treturn Arrays.stream(clazz.getInterfaces())\n\t\t\t\t.map(ReflectionUtils::getMethods)\n\t\t\t\t.flatMap(List::stream)\n\t\t\t\t.filter(visibleDefaultMethods::contains)\n\t\t\t\t.collect(toCollection(ArrayList::new));\n\t\t// @formatter:on\n\t}\n\n\tprivate static List<Field> toSortedMutableList(Field[] fields) {\n\t\treturn toSortedMutableList(fields, ReflectionUtils::defaultFieldSorter);\n\t}\n\n\tprivate static List<Method> toSortedMutableList(Method[] methods) {\n\t\treturn toSortedMutableList(methods, ReflectionUtils::defaultMethodSorter);\n\t}\n\n\tprivate static <T> List<T> toSortedMutableList(T[] items, Comparator<? super T> comparator) {\n\t\tList<T> result = new ArrayList<>(items.length);\n\t\tCollections.addAll(result, items);\n\t\tresult.sort(comparator);\n\t\treturn result;\n\t}\n\n\tprivate static int defaultFieldSorter(Field field1, Field field2) {\n\t\treturn Integer.compare(field1.getName().hashCode(), field2.getName().hashCode());\n\t}\n\n\tprivate static int defaultMethodSorter(Method method1, Method method2) {\n\t\tString name1 = method1.getName();\n\t\tString name2 = method2.getName();\n\t\tint comparison = Integer.compare(name1.hashCode(), name2.hashCode());\n\t\tif (comparison == 0) {\n\t\t\tcomparison = name1.compareTo(name2);\n\t\t\tif (comparison == 0) {\n\t\t\t\tcomparison = method1.toString().compareTo(method2.toString());\n\t\t\t}\n\t\t}\n\t\treturn comparison;\n\t}\n\n\tprivate static List<Method> getInterfaceMethods(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tList<Method> allInterfaceMethods = new ArrayList<>();\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\n\t\t\t// @formatter:off\n\t\t\tMethod[] localInterfaceMethods = getMethods(ifc).stream()\n\t\t\t\t\t.filter(m -> !isAbstract(m))\n\t\t\t\t\t.toArray(Method[]::new);\n\n\t\t\tMethod[] superinterfaceMethods = getInterfaceMethods(ifc, traversalMode).stream()\n\t\t\t\t\t.filter(method -> isNotOverriddenByLocalMethods(method, localInterfaceMethods))\n\t\t\t\t\t.toArray(Method[]::new);\n\t\t\t// @formatter:on\n\n\t\t\tif (traversalMode == TOP_DOWN) {\n\t\t\t\tCollections.addAll(allInterfaceMethods, superinterfaceMethods);\n\t\t\t}\n\t\t\tCollections.addAll(allInterfaceMethods, localInterfaceMethods);\n\t\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\t\tCollections.addAll(allInterfaceMethods, superinterfaceMethods);\n\t\t\t}\n\t\t}\n\t\treturn allInterfaceMethods;\n\t}\n\n\tprivate static List<Field> getInterfaceFields(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tList<Field> allInterfaceFields = new ArrayList<>();\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tField[] localInterfaceFields = ifc.getFields();\n\t\t\tArrays.sort(localInterfaceFields, ReflectionUtils::defaultFieldSorter);\n\n\t\t\t// @formatter:off\n\t\t\tField[] superinterfaceFields = getInterfaceFields(ifc, traversalMode).stream()\n\t\t\t\t\t.filter(field -> isNotShadowedByLocalFields(field, localInterfaceFields))\n\t\t\t\t\t.toArray(Field[]::new);\n\t\t\t// @formatter:on\n\n\t\t\tif (traversalMode == TOP_DOWN) {\n\t\t\t\tCollections.addAll(allInterfaceFields, superinterfaceFields);\n\t\t\t}\n\t\t\tCollections.addAll(allInterfaceFields, localInterfaceFields);\n\t\t\tif (traversalMode == BOTTOM_UP) {\n\t\t\t\tCollections.addAll(allInterfaceFields, superinterfaceFields);\n\t\t\t}\n\t\t}\n\t\treturn allInterfaceFields;\n\t}\n\n\tprivate static List<Field> getSuperclassFields(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (!isSearchable(superclass)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn findAllFieldsInHierarchy(superclass, traversalMode);\n\t}\n\n\tprivate static boolean isNotShadowedByLocalFields(Field field, Field[] localFields) {\n\t\tif (useLegacySearchSemantics) {\n\t\t\tfor (Field local : localFields) {\n\t\t\t\tif (local.getName().equals(field.getName())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static List<Method> getSuperclassMethods(Class<?> clazz, HierarchyTraversalMode traversalMode) {\n\t\tClass<?> superclass = clazz.getSuperclass();\n\t\tif (!isSearchable(superclass)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn findAllMethodsInHierarchy(superclass, traversalMode);\n\t}\n\n\tprivate static boolean isNotOverriddenByLocalMethods(Method method, Method[] localMethods) {\n\t\tfor (Method local : localMethods) {\n\t\t\tif (isMethodOverriddenBy(method, local)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static boolean isMethodOverriddenBy(Method upper, Method lower) {\n\t\t// If legacy search semantics are enabled, skip to hasCompatibleSignature() check.\n\t\tif (!useLegacySearchSemantics) {\n\t\t\t// A static method cannot override anything.\n\t\t\tif (Modifier.isStatic(lower.getModifiers())) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Cannot override a private, static, or final method.\n\t\t\tint modifiers = upper.getModifiers();\n\t\t\tif (Modifier.isPrivate(modifiers) || Modifier.isStatic(modifiers) || Modifier.isFinal(modifiers)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Cannot override a package-private method in another package.\n\t\t\tif (isPackagePrivate(upper) && !declaredInSamePackage(upper, lower)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn hasCompatibleSignature(upper, lower.getName(), lower.getParameterTypes());\n\t}\n\n\tprivate static boolean isPackagePrivate(Member member) {\n\t\tint modifiers = member.getModifiers();\n\t\treturn !(Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers) || Modifier.isPrivate(modifiers));\n\t}\n\n\tprivate static boolean declaredInSamePackage(Method m1, Method m2) {\n\t\treturn getPackageName(m1.getDeclaringClass()).equals(getPackageName(m2.getDeclaringClass()));\n\t}\n\n\tprivate static boolean hasCompatibleSignature(Method candidate, String methodName, Class<?>[] parameterTypes) {\n\t\tif (!methodName.equals(candidate.getName())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (parameterTypes.length != candidate.getParameterCount()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?>[] candidateParameterTypes = candidate.getParameterTypes();\n\t\t// trivial case: parameter types exactly match\n\t\tif (Arrays.equals(parameterTypes, candidateParameterTypes)) {\n\t\t\treturn true;\n\t\t}\n\t\t// param count is equal, but types do not match exactly: check for method sub-signatures\n\t\t// https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.2\n\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\tClass<?> lowerType = parameterTypes[i];\n\t\t\tClass<?> upperType = candidateParameterTypes[i];\n\t\t\tif (!upperType.isAssignableFrom(lowerType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t// lower is sub-signature of upper: check for generics in upper method\n\t\tif (isGeneric(candidate)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean isGeneric(Method method) {\n\t\treturn isGeneric(method.getGenericReturnType())\n\t\t\t\t|| Arrays.stream(method.getGenericParameterTypes()).anyMatch(ReflectionUtils::isGeneric);\n\t}\n\n\tprivate static boolean isGeneric(Type type) {\n\t\treturn type instanceof TypeVariable || type instanceof GenericArrayType;\n\t}\n\n\t@API(status = INTERNAL, since = \"1.11\")\n\t@SuppressWarnings(\"deprecation\") // \"AccessibleObject.isAccessible()\" is deprecated in Java 9\n\tpublic static <T extends Executable> T makeAccessible(T executable) {\n\t\tif ((!isPublic(executable) || !isPublic(executable.getDeclaringClass())) && !executable.isAccessible()) {\n\t\t\texecutable.setAccessible(true);\n\t\t}\n\t\treturn executable;\n\t}\n\n\t@API(status = INTERNAL, since = \"1.12\")\n\t@SuppressWarnings(\"deprecation\") // \"AccessibleObject.isAccessible()\" is deprecated in Java 9\n\tpublic static Field makeAccessible(Field field) {\n\t\tif ((!isPublic(field) || !isPublic(field.getDeclaringClass()) || isFinal(field)) && !field.isAccessible()) {\n\t\t\tfield.setAccessible(true);\n\t\t}\n\t\treturn field;\n\t}\n\n\tpublic static Set<Class<?>> getAllAssignmentCompatibleClasses(Class<?> clazz) {\n\t\tPreconditions.notNull(clazz, \"Class must not be null\");\n\n\t\tSet<Class<?>> result = new LinkedHashSet<>();\n\t\tgetAllAssignmentCompatibleClasses(clazz, result);\n\t\treturn result;\n\t}\n\n\tprivate static void getAllAssignmentCompatibleClasses(Class<?> clazz, Set<Class<?>> result) {\n\t\tfor (Class<?> current = clazz; current != null; current = current.getSuperclass()) {\n\t\t\tresult.add(current);\n\t\t\tfor (Class<?> interfaceClass : current.getInterfaces()) {\n\t\t\t\tif (!result.contains(interfaceClass)) {\n\t\t\t\t\tgetAllAssignmentCompatibleClasses(interfaceClass, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static boolean isSearchable(Class<?> clazz) {\n\t\treturn (clazz != null && clazz != Object.class);\n\t}\n\n\tprivate static Throwable getUnderlyingCause(Throwable t) {\n\t\tif (t instanceof InvocationTargetException) {\n\t\t\treturn getUnderlyingCause(((InvocationTargetException) t).getTargetException());\n\t\t}\n\t\treturn t;\n\t}\n\n\tprivate static boolean getLegacySearchSemanticsFlag() {\n\t\tString rawValue = System.getProperty(USE_LEGACY_SEARCH_SEMANTICS_PROPERTY_NAME);\n\t\tif (StringUtils.isBlank(rawValue)) {\n\t\t\treturn false;\n\t\t}\n\t\tString value = rawValue.trim().toLowerCase();\n\t\tboolean isTrue = \"true\".equals(value);\n\t\tPreconditions.condition(isTrue || \"false\".equals(value), () -> USE_LEGACY_SEARCH_SEMANTICS_PROPERTY_NAME\n\t\t\t\t+ \" property must be 'true' or 'false' (ignoring case): \" + rawValue);\n\t\treturn isTrue;\n\t}\n\n\tprivate interface Visitor<T> {\n\n\t\tboolean accept(T value);\n\n\t}\n\n}",
        "human_comment": "@return {@code true} if the visitor should continue searching;\n{@code false} if the visitor should stop",
        "model_generated_comment": "p>If the method name is null or blank, it must start with a fully qualified class name followed by a '#'."
    },
    {
        "id": 549,
        "code_snippet": "private static Method getPublicMethod(Class<?> clazz, String name, Class<?>... paramTypes) {\n        // if this class is public, then try to get it\n        if ((clazz.getModifiers() & Modifier.PUBLIC) != 0) {\n            try {\n                return clazz.getMethod(name, paramTypes);\n            } catch (NoSuchMethodException e) {\n                // If the class does not have the method, then neither its superclass\n                // nor any of its interfaces has it so quickly return null.\n                return null;\n            }\n        }\n\n        //  try the superclass\n        Class<?> superclazz = clazz.getSuperclass();\n\n        if (superclazz != null) {\n            Method superclazzMethod = getPublicMethod(superclazz, name, paramTypes);\n\n            if (superclazzMethod != null) {\n                return superclazzMethod;\n            }\n        }\n\n        // and interfaces\n        Class<?>[] interfaces = clazz.getInterfaces();\n\n        for (Class<?> anInterface : interfaces) {\n            Method interfaceMethod = getPublicMethod(anInterface, name, paramTypes);\n\n            if (interfaceMethod != null) {\n                return interfaceMethod;\n            }\n        }\n\n        return null;\n    }",
        "human_comment": "Looks up the method with specified name and signature in the first public\nsuperclass or implemented interface of the class.\n\n@param clazz      the class whose method is sought\n@param name       the name of the method\n@param paramTypes the classes of method parameters",
        "model_generated_comment": "p>If the class is public, then the method will be @code null. @param name, class name, paramTypes/p>. @return null if the class does not have a superclazzMethod; if it does not, it will return null."
    },
    {
        "id": 550,
        "code_snippet": "static ProjectBuilderRequest build(@Nonnull Session session, @Nonnull Path path) {\n        return builder()\n                .session(requireNonNull(session, \"session cannot be null\"))\n                .path(requireNonNull(path, \"path cannot be null\"))\n                .build();\n    }",
        "human_comment": "Creates a new ProjectBuilderRequest with the specified session and path.\n\n@param session the Maven session\n@param path the path to the project to build\n@return a new ProjectBuilderRequest\n@throws NullPointerException if session or path is null",
        "model_generated_comment": "Builds a non-null session from a @link Session."
    },
    {
        "id": 551,
        "code_snippet": "public static void disableRecoveryOfApp(String appId) {\n    Preconditions.checkNotNull(appId);\n    INSTANCE.appsWithRecoveryDisabled.add(appId);\n  }",
        "human_comment": "Add an application for which recovery is disabled.\n@param appId application id",
        "model_generated_comment": "p>Preconditions.checkNotNull/p> for @link RecoveryOfApp."
    },
    {
        "id": 552,
        "code_snippet": "public Builder filter(MetricFilter filter) {\n            this.filter = filter;\n            return this;\n        }",
        "human_comment": "Only report metrics which match the given filter.\n\n@param filter a {@link MetricFilter}\n@return {@code this}",
        "model_generated_comment": "p>MetricFilter/p>Analyzes the filter."
    },
    {
        "id": 553,
        "code_snippet": "public long getTotalMemoryConsumption() {\n    long totalDataPagesSize = 0L;\n    for (MemoryBlock dataPage : dataPages) {\n      totalDataPagesSize += dataPage.size();\n    }\n    return totalDataPagesSize + ((longArray != null) ? longArray.memoryBlock().size() : 0L);\n  }",
        "human_comment": "Returns the total amount of memory, in bytes, consumed by this map's managed structures.",
        "model_generated_comment": "@code null @param dataPagesSize = 0L. @return a dataPage with a size of 1L if the size of the data is greater than 1L."
    },
    {
        "id": 554,
        "code_snippet": "public static void assertEquals(Short expected, Short actual) {\n\t\tAssertEquals.assertEquals(expected, actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n\n@since 5.4",
        "model_generated_comment": "Asserts that the expected and actual values are equal."
    },
    {
        "id": 555,
        "code_snippet": "public void setProjectBuildingRequest(ProjectBuildingRequest projectBuildingRequest) {\n        this.projectBuilderConfiguration = projectBuildingRequest;\n    }",
        "human_comment": "Sets the project building request from which this project instance was created. <strong>Warning:</strong> This is\na utility method that is meant to assist integrators of Maven, it must not be used by Maven plugins.\n\n@param projectBuildingRequest The project building request, may be {@code null}.\n@since 2.1",
        "model_generated_comment": "Sets a project builder request to @link projectBuilderConfiguration. @param projectBuildingRequest the project building request. @return the request if the project builds a new project."
    },
    {
        "id": 556,
        "code_snippet": "public static String replaceIsoControlCharacters(String str, String replacement) {\n\t\tPreconditions.notNull(replacement, \"replacement must not be null\");\n\t\treturn str == null ? null : ISO_CONTROL_PATTERN.matcher(str).replaceAll(replacement);\n\t}",
        "human_comment": "Replace all ISO control characters in the supplied {@link String}.\n\n@param str the string in which to perform the replacement; may be {@code null}\n@param replacement the replacement string; never {@code null}\n@return the supplied string with all control characters replaced, or\n{@code null} if the supplied string was {@code null}\n@since 1.4",
        "model_generated_comment": "p>Replacement/p>String replacement @code null. @param replaceIsoControlCharacters."
    },
    {
        "id": 557,
        "code_snippet": "public ParallelExecutionConfiguration createConfiguration(ConfigurationParameters configurationParameters) {\n\t\t\tBigDecimal factor = configurationParameters.get(CONFIG_DYNAMIC_FACTOR_PROPERTY_NAME,\n\t\t\t\tBigDecimal::new).orElse(BigDecimal.ONE);\n\n\t\t\tPreconditions.condition(factor.compareTo(BigDecimal.ZERO) > 0,\n\t\t\t\t() -> String.format(\"Factor '%s' specified via configuration parameter '%s' must be greater than 0\",\n\t\t\t\t\tfactor, CONFIG_DYNAMIC_FACTOR_PROPERTY_NAME));\n\n\t\t\tint parallelism = Math.max(1,\n\t\t\t\tfactor.multiply(BigDecimal.valueOf(Runtime.getRuntime().availableProcessors())).intValue());\n\n\t\t\tint maxPoolSize = configurationParameters.get(CONFIG_DYNAMIC_MAX_POOL_SIZE_FACTOR_PROPERTY_NAME,\n\t\t\t\tBigDecimal::new).map(maxPoolSizeFactor -> {\n\t\t\t\t\tPreconditions.condition(maxPoolSizeFactor.compareTo(BigDecimal.ONE) >= 0,\n\t\t\t\t\t\t() -> String.format(\n\t\t\t\t\t\t\t\"Factor '%s' specified via configuration parameter '%s' must be greater than or equal to 1\",\n\t\t\t\t\t\t\tfactor, CONFIG_DYNAMIC_MAX_POOL_SIZE_FACTOR_PROPERTY_NAME));\n\t\t\t\t\treturn maxPoolSizeFactor.multiply(BigDecimal.valueOf(parallelism)).intValue();\n\t\t\t\t}).orElseGet(() -> 256 + parallelism);\n\n\t\t\tboolean saturate = configurationParameters.get(CONFIG_DYNAMIC_SATURATE_PROPERTY_NAME,\n\t\t\t\tBoolean::valueOf).orElse(true);\n\n\t\t\treturn new DefaultParallelExecutionConfiguration(parallelism, parallelism, maxPoolSize, parallelism,\n\t\t\t\tKEEP_ALIVE_SECONDS, __ -> saturate);\n\t\t}",
        "human_comment": "Computes the desired parallelism based on the number of available\nprocessors/cores multiplied by the {@value #CONFIG_DYNAMIC_FACTOR_PROPERTY_NAME}\nconfiguration parameter.",
        "model_generated_comment": "@link ParallelExecutionConfiguration. @param %s - 0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 - 15 - 20 - 24 - 25 - 30 - 40 - 50 - 60 - 80 - 100 - 150 - 200 - 250 - 300 - 400 - 500 - 600 - 800 -"
    },
    {
        "id": 558,
        "code_snippet": "public void beforeEach(ExtensionContext context) {\n\t\tinstallFailureTracker(context);\n\t\tcontext.getRequiredTestInstances().getAllInstances() //\n\t\t\t\t.forEach(instance -> injectInstanceFields(context, instance));\n\t}",
        "human_comment": "Perform field injection for non-private, non-static fields (i.e.,\ninstance fields) of type {@link Path} or {@link File} that are annotated\nwith {@link TempDir @TempDir}.",
        "model_generated_comment": "p>ExtensionContext/p>FailureTracker.getAllInstanceFields(context, instance) @link Installer.getInstanceFails(instance) @param context The context of an instance."
    },
    {
        "id": 559,
        "code_snippet": "public static void assertEquals(short expected, short actual) {\n        Assert.assertEquals(expected, actual);\n    }",
        "human_comment": "Asserts that two shorts are equal.",
        "model_generated_comment": "Asserts that the expected and actual values are equal."
    },
    {
        "id": 560,
        "code_snippet": "Model transformFileToRaw(Model model) {\n            if (model.getDependencies().isEmpty()) {\n                return model;\n            }\n            List<Dependency> newDeps = new ArrayList<>(model.getDependencies().size());\n            boolean changed = false;\n            for (Dependency dep : model.getDependencies()) {\n                Dependency newDep = null;\n                if (dep.getVersion() == null) {\n                    newDep = inferDependencyVersion(model, dep);\n                    if (newDep != null) {\n                        changed = true;\n                    }\n                }\n                newDeps.add(newDep == null ? dep : newDep);\n            }\n            return changed ? model.withDependencies(newDeps) : model;\n        }",
        "human_comment": "Transform raw model to build pom.\nInfer inner reactor dependencies version",
        "model_generated_comment": "p>Model model/p> if the model is empty, the model will be transformed into a @link model. @param modelDependencies if it is empty."
    },
    {
        "id": 561,
        "code_snippet": "public String toString() {\n        return fFailedTest + \": \" + fThrownException.getMessage();\n    }",
        "human_comment": "Returns a short description of the failure.",
        "model_generated_comment": "@link fFailedTest. @param fThrownException.getMessage()"
    },
    {
        "id": 562,
        "code_snippet": "public static Stream<? extends DiscoverySelector> parseAll(Collection<DiscoverySelectorIdentifier> identifiers) {\n\t\treturn DiscoverySelectorIdentifierParsers.parseAll(identifiers);\n\t}",
        "human_comment": "Parse the supplied {@link DiscoverySelectorIdentifier\nDiscoverySelectorIdentifiers}.\n\n@param identifiers the {@code DiscoverySelectorIdentifiers} to parse;\nnever {@code null}\n@return a stream of the corresponding {@link DiscoverySelector DiscoverySelectors};\nnever {@code null} but potentially empty\n@since 1.11\n@see DiscoverySelectorIdentifierParser",
        "model_generated_comment": "@link DiscoverySelectorIdentifierParsers/. @param identifiers of a Discovery Selector."
    },
    {
        "id": 563,
        "code_snippet": "protected String processArguments(String[] args) {\n        String suiteName = null;\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].equals(\"-noloading\")) {\n                setLoading(false);\n            } else if (args[i].equals(\"-nofilterstack\")) {\n                fgFilterStack = false;\n            } else if (args[i].equals(\"-c\")) {\n                if (args.length > i + 1) {\n                    suiteName = extractClassName(args[i + 1]);\n                } else {\n                    System.out.println(\"Missing Test class name\");\n                }\n                i++;\n            } else {\n                suiteName = args[i];\n            }\n        }\n        return suiteName;\n    }",
        "human_comment": "Processes the command line arguments and\nreturns the name of the suite class to run or null",
        "model_generated_comment": "p>If @link i/p> a test class name is missing, the test class will not be loaded. @param args i++ if the test is not loaded."
    },
    {
        "id": 564,
        "code_snippet": "private Mapper() {\n    throw new UnsupportedOperationException(\n        \"Mapper is a utility class and cannot be instantiated.\");\n  }",
        "human_comment": "The Mapper class is responsible for processing an input string and generating a map of word\noccurrences.",
        "model_generated_comment": "Mapper is a utility class and cannot be instantiated."
    },
    {
        "id": 565,
        "code_snippet": "@Override public void merge(MutableAggregationBuffer buffer1, Row buffer2) {\n    if (!buffer2.isNullAt(0)) {\n      if (buffer1.isNullAt(0)) {\n        buffer1.update(0, buffer2.getDouble(0));\n      } else {\n        Double newValue = buffer2.getDouble(0) + buffer1.getDouble(0);\n        buffer1.update(0, newValue);\n      }\n    }\n  }",
        "human_comment": "buffer1 and buffer2 have the same structure.\nWe only update the buffer1 when the input buffer2's value is not null.\nIf the buffer value (intermediate result of the sum) is still null,\nwe set the it as the input buffer's value.\nOtherwise, we add the input buffer's value (buffer1) to the mutable\nbuffer's value (buffer2).",
        "model_generated_comment": "@Override @link  @param buffer1, Row buffer2 @return a buffer that is not a row buffer, if the row buffer is a column buffer, and if it is not, the buffer will be merged with a new row buffer. @example: if a block is null, it should be null."
    },
    {
        "id": 566,
        "code_snippet": "public Scope withName(String opName) {\n    return new Scope(env, nameScope.withName(opName), controlDependencies);\n  }",
        "human_comment": "Return a new scope that uses the provided name for an op.\n\n<p>Operations created within this scope will have a name of the form {@code\nname/opName[_suffix]}. This lets you name a specific operator more meaningfully.\n\n<p>Names must match the regular expression {@code [A-Za-z0-9.][A-Za-z0-9_.\\-]*}\n\n@param opName name for an operator in the returned scope\n@return a new Scope that uses opName for operations.\n@throws IllegalArgumentException if the name is invalid",
        "model_generated_comment": "Returns a new Scope with a name. @param opName the name of the Scope @link Scope. @return a Scope that contains a specific name."
    },
    {
        "id": 567,
        "code_snippet": "public static Optional<Method> findMethod(Class<?> clazz, String methodName, String parameterTypeNames) {\n\t\treturn ReflectionUtils.findMethod(clazz, methodName, parameterTypeNames);\n\t}",
        "human_comment": "Find the first {@link Method} of the supplied class or interface that\nmeets the specified criteria, beginning with the specified class or\ninterface and traversing up the type hierarchy until such a method is\nfound or the type hierarchy is exhausted.\n\n<p>As of JUnit Platform 1.10, this method uses the {@link ClassLoader} of\nthe supplied {@code clazz} to load parameter types instead of using the\n<em>default</em> {@code ClassLoader}, which allows parameter types to be\nresolved in different {@code ClassLoader} arrangements.\n\n<p>The algorithm does not search for methods in {@link java.lang.Object}.\n\n@param clazz the class or interface in which to find the method; never {@code null}\n@param methodName the name of the method to find; never {@code null} or empty\n@param parameterTypeNames the fully qualified names of the types of parameters\naccepted by the method, if any, provided as a comma-separated list\n@return an {@code Optional} containing the method found; never {@code null}\nbut potentially empty if no such method could be found\n@see #findMethod(Class, String, Class...)",
        "model_generated_comment": "Returns a @link ReflectionUtils method. @param methodName, parameterTypeNames if the method is not clazzed. @return the method name if it is a parameter type."
    },
    {
        "id": 568,
        "code_snippet": "public AlbumPage changeNumberOfSongs(int numberOfSongs) {\n    var numberOfSongsNumberField = (HtmlNumberInput) page.getElementById(\"numberOfSongs\");\n    numberOfSongsNumberField.setText(Integer.toString(numberOfSongs));\n    return this;\n  }",
        "human_comment": "Sets the number of songs number input field.\n\n@param numberOfSongs the new number of songs value to be set\n@return {@link AlbumPage}",
        "model_generated_comment": "@link NumberOfSongsNumberField if the number of songs is not specified. p>Also, if a number is not defined, a string will be returned."
    },
    {
        "id": 569,
        "code_snippet": "public Object exists(List<Object> args) {\n        if (args.size() != 1) {\n            throw new IllegalArgumentException(\"exists function requires exactly one argument\");\n        }\n        String path = ConditionParser.toString(args.get(0));\n        return context.exists(path, true);\n    }",
        "human_comment": "Checks if a file or directory exists at the given path.\n\n@param args A list containing a single string argument representing the path\n@return {@code true} if the file or directory exists, {@code false} otherwise\n@throws IllegalArgumentException if the number of arguments is not exactly one\n@throws ModelBuilderException if a problem occurs while walking the file system\n@throws InterpolatorException if an error occurs during interpolation",
        "model_generated_comment": "Error if @link ConditionParser does not exist."
    },
    {
        "id": 570,
        "code_snippet": "static Injector create() {\n        return new InjectorImpl();\n    }",
        "human_comment": "Creates a new Injector instance with default settings.\n\n@return a new Injector instance",
        "model_generated_comment": "Returns a new InjectorImpl."
    },
    {
        "id": 571,
        "code_snippet": "public void setPassword(String password) {\n        this.password = password;\n    }",
        "human_comment": "Set the user's password which is used when connecting to the repository.\n\n@param password password of the user",
        "model_generated_comment": "Sets the password of the user. @param password the password for the user to use."
    },
    {
        "id": 572,
        "code_snippet": "public void deactivateRequiredProject(String selector) {\n        this.activations.add(new ProjectActivationSettings(selector, ActivationSettings.deactivated()));\n    }",
        "human_comment": "Mark a project as required and deactivated.\n@param selector The selector of the project.",
        "model_generated_comment": "@link deactivateRequiredProject/@link ActivationSettings. @param selector the selected project. @return a project activation setting if the project is not active."
    },
    {
        "id": 573,
        "code_snippet": "public static Condition<Event> nestedContainer(Class<?> clazz, Condition<Event> condition) {\n\t\treturn allOf(nestedContainer(clazz), condition);\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if an\n{@linkplain Event#getTestDescriptor() test descriptor} is\na {@linkplain TestDescriptor#isContainer() container}, and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the\nsimple names of the supplied {@link Class} and all of its\n{@linkplain Class#getEnclosingClass() enclosing classes}.\n\n<p>For example, {@code nestedContainer(MyNestedTests.class, displayName(\"my display name\"))}\ncan be used to match against a nested container with the given display name.\n\n<p>Please note that this method does not differentiate between static\nnested classes and non-static member classes (e.g., inner classes).\n\n@since 1.8\n@see #nestedContainer(Class)",
        "model_generated_comment": "Returns a nested container for a ConditionEvent."
    },
    {
        "id": 574,
        "code_snippet": "public void beforeAllMethodsExecuted(boolean beforeAllMethodsExecuted) {\n\t\tthis.beforeAllMethodsExecuted = beforeAllMethodsExecuted;\n\t}",
        "human_comment": "Track that an attempt was made to execute {@code @BeforeAll} methods.",
        "model_generated_comment": "@param beforeAllMethodsExecuted @link @code @code #boolean beforeAlso beforeAllMethodesExecuted @return @value beforeAllAltsobeforeAltesoforEachEachecuteDisabled/@code #beforeAllEthodSequencesEffectsEmploymentEfploymentsEffluentEfffectEfficientEFployEfFExecEEf"
    },
    {
        "id": 575,
        "code_snippet": "record TransferResourceIdentifier(String repositoryId, String repositoryUrl, String resourceName, @Nullable File file) {\n    TransferResourceIdentifier(TransferResource resource) {\n        this(resource.getRepositoryId(), resource.getRepositoryUrl(), resource.getResourceName(), resource.getFile());\n    }\n}",
        "human_comment": "Immutable identifier of a {@link TransferResource}.\nThe {@link TransferResource} is not immutable and does not implement {@code Objects#equals} and {@code Objects#hashCode} methods,\nmaking it not very suitable for usage in collections.",
        "model_generated_comment": "p>TransferResourceIdentifier/p> a @code repositoryId and /code repositoryUrl."
    },
    {
        "id": 576,
        "code_snippet": "public static ResolverTrace enter(Session session, Object data) {\n        InternalSession iSession = InternalSession.from(session);\n        org.apache.maven.api.services.RequestTrace trace = data instanceof Request<?> req && req.getTrace() != null\n                ? req.getTrace()\n                : new org.apache.maven.api.services.RequestTrace(iSession.getCurrentTrace(), data);\n        iSession.setCurrentTrace(trace);\n        return new ResolverTrace(session, trace.context(), toResolver(trace), trace);\n    }",
        "human_comment": "Creates a new trace entry and updates the session's current trace\n@param session The current Maven session\n@param data The data object to associate with the trace\n@return A new ResolverTrace containing both Maven and Resolver trace information",
        "model_generated_comment": "@link ResolverTrace @param session session, Object data. @returns a new instance of Request/@link org.apache.maven.api.services.resolver_trace() if a session is a data instance of a request."
    },
    {
        "id": 577,
        "code_snippet": "public void checkAuthorization(TransportClient client, long streamId) { }",
        "human_comment": "Verify that the client is authorized to read from the given stream.\n\n@throws SecurityException If client is not authorized.",
        "model_generated_comment": "@link TransportClient/@link Transport Client. @param long streamId the stream ID of the client."
    },
    {
        "id": 578,
        "code_snippet": "public static synchronized PhaseId of(String phase) {\n        return INSTANCES.computeIfAbsent(phase, PhaseId::new);\n    }",
        "human_comment": "Parses the phase identifier.\n\n@param phase the phase identifier.\n@return the {@link PhaseId}.",
        "model_generated_comment": "@link PhaseId @return a synchronized phase of a phase. @param phase phase the phase of the phase."
    },
    {
        "id": 579,
        "code_snippet": "public UTF8String makeValid() {\n    if (isValid()) return this;\n    return UTF8String.fromBytes(makeValidBytes());\n  }",
        "human_comment": "Returns a validated version of the current UTF-8 string by replacing invalid UTF-8 sequences\nwith the Unicode replacement character (U+FFFD), as per the rules defined in the Unicode\nstandard 15, Section 3.9, Paragraph D86, Table 3-7. This behaviour is consistent with the\nbehaviour of `UnicodeString` in ICU4C.\n\n@return A new UTF8String that is a valid UTF8 string.",
        "model_generated_comment": "Returns a UTF8String with a value of @code. @param value the value of the string."
    },
    {
        "id": 580,
        "code_snippet": "public static DoubleBuffer allocateDoubleBuffer(int numElements) {\n    return ByteBuffer.allocateDirect(numElements * DOUBLE_SIZE_BYTES)\n        .order(ByteOrder.nativeOrder())\n        .asDoubleBuffer();\n  }",
        "human_comment": "Allocates a new direct {@link java.nio.DoubleBuffer} with native byte order with specified\n\n@param numElements capacity (number of elements) of result buffer.",
        "model_generated_comment": "@link DoubleBuffer @param numElements * DOUBLE_SIZE_BYTES @return ByteBuffer to allocate a double byte to a single byte."
    },
    {
        "id": 581,
        "code_snippet": "public static ByteBuffer stringToBytes(String s) {\n    return ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8));\n  }",
        "human_comment": "Convert the given string to a byte buffer. The resulting buffer can be\nconverted back to the same string through {@link #bytesToString(ByteBuffer)}.",
        "model_generated_comment": "p>StandardCharsets/p>. @param stringToBytes(String s) @link ByteBuffer. @return a string to a bytes bytes if the string is not a valid string."
    },
    {
        "id": 582,
        "code_snippet": "public static int hashUnsafeBytes2(Object base, long offset, int lengthInBytes, int seed) {\n    assert (lengthInBytes >= 0): \"lengthInBytes cannot be negative\";\n    int lengthAligned = lengthInBytes - lengthInBytes % 4;\n    int h1 = hashBytesByInt(base, offset, lengthAligned, seed);\n    int k1 = 0;\n    for (int i = lengthAligned, shift = 0; i < lengthInBytes; i++, shift += 8) {\n      k1 ^= (Platform.getByte(base, offset + i) & 0xFF) << shift;\n    }\n    h1 ^= mixK1(k1);\n    return fmix(h1, lengthInBytes);\n  }",
        "human_comment": "This is compatible with original and another implementations.\nUse this method for new components after Spark 2.3.",
        "model_generated_comment": "@code lengthInBytes @param base, offset, int lengthAligned @return 0xFF if the offset is longer than the length of the offset if it is shorter than the distance between the offset and the int seed."
    },
    {
        "id": 583,
        "code_snippet": "public Object parse(String expression) {\n        this.tokens = tokenize(expression);\n        this.current = 0;\n        return parseExpression();\n    }",
        "human_comment": "Parses the given expression and returns the result of the evaluation.\n\n@param expression the expression to be parsed\n@return the result of parsing and evaluating the expression",
        "model_generated_comment": "Parse the expression using @link parse. @param expression expression the expression of the expression. @return the expression if the expression is valid."
    },
    {
        "id": 584,
        "code_snippet": "public static UTF8String getSparkVersion() {\n    String shortVersion = VersionUtils.shortVersion(SparkBuildInfo.spark_version());\n    String revision = SparkBuildInfo.spark_revision();\n    return UTF8String.fromString(shortVersion + \" \" + revision);\n  }",
        "human_comment": "Function to return the Spark version.\n@return\nSpace separated version and revision.",
        "model_generated_comment": "p>SparkBuildInfo.spark_version/p>. @param shortVersion a short version of a @code SparkBuildInfo. @return a long version of the http://sparkbuildinfo.intl> /.p>"
    },
    {
        "id": 585,
        "code_snippet": "public String aggregateTaskMetrics(long[] taskMetrics) {\n    if (taskMetrics.length > 0) {\n      long sum = 0L;\n      for (long taskMetric : taskMetrics) {\n        sum += taskMetric;\n      }\n      double average = ((double) sum) / taskMetrics.length;\n      return new DecimalFormat(\"#0.000\").format(average);\n    } else {\n      return \"0\";\n    }\n  }",
        "human_comment": "Built-in `CustomMetric` that computes average of metric values. Note that please extend this\nclass and override `name` and `description` to create your custom metric for real usage.\n\n@since 3.2.0",
        "model_generated_comment": "@link TaskMetrics @param taskMetric @return \"0\" if the task is longer than the length of the task; if it is shorter than the task, the length will be 0L."
    },
    {
        "id": 586,
        "code_snippet": "public void setOrder(Object rule, int order) {\n        orderValues.put(rule, order);\n    }",
        "human_comment": "Sets order value for the specified rule.",
        "model_generated_comment": "Sets the order values of a @link. @param rule, int order."
    },
    {
        "id": 587,
        "code_snippet": "default void testDisabled(ExtensionContext context, Optional<String> reason) {\n\t\t/* no-op */\n\t}",
        "human_comment": "Invoked after a disabled test has been skipped.\n\n<p>The default implementation does nothing. Concrete implementations can\noverride this method as appropriate.\n\n@param context the current extension context; never {@code null}\n@param reason the reason the test is disabled; never {@code null} but\npotentially <em>empty</em>",
        "model_generated_comment": "p>ExtensionContext/p>/a> @link ExtensionContext reason for a given extension."
    },
    {
        "id": 588,
        "code_snippet": "static Object asSerializableValue(Object value) {\n        if (value == null || value instanceof Serializable) {\n            return value;\n        } else {\n            return new SerializableValueDescription(value);\n        }\n    }",
        "human_comment": "Factory method that checks to see if the value is already serializable.\n@param value the value to make serializable\n@return The provided value if it is null or already serializable,\nthe SerializableValueDescription representation of it if it is not.",
        "model_generated_comment": "@link SerializableValueDescription @param value the value of the Object."
    },
    {
        "id": 589,
        "code_snippet": "public void testwithColumns() {\n    Dataset<Row> df = spark.table(\"testData2\");\n    Map<String, Column> colMaps = new HashMap<>();\n    colMaps.put(\"a1\", col(\"a\"));\n    colMaps.put(\"b1\", col(\"b\"));\n\n    StructType expected = df.withColumn(\"a1\", col(\"a\")).withColumn(\"b1\", col(\"b\")).schema();\n    StructType actual = df.withColumns(colMaps).schema();\n    Assertions.assertEquals(expected, actual);\n    Assertions.assertArrayEquals(actual.fieldNames(), new String[] {\"a\", \"b\", \"a1\", \"b1\"});\n\n  @Test\n  public void testSampleByColumn() {\n    Dataset<Row> df = spark.range(0, 100, 1, 2).select(col(\"id\").mod(3).as(\"key\"));\n    Dataset<Row> sampled = df.stat().sampleBy(col(\"key\"), ImmutableMap.of(0, 0.1, 1, 0.2), 0L);\n    List<Row> actual = sampled.groupBy(\"key\").count().orderBy(\"key\").collectAsList();\n    Assertions.assertEquals(0, actual.get(0).getLong(0));\n    Assertions.assertTrue(0 <= actual.get(0).getLong(1) && actual.get(0).getLong(1) <= 8);\n    Assertions.assertEquals(1, actual.get(1).getLong(0));\n    Assertions.assertTrue(2 <= actual.get(1).getLong(1) && actual.get(1).getLong(1) <= 13);\n  }\n\n  @Test\n  public void pivot() {\n    Dataset<Row> df = spark.table(\"courseSales\");\n    List<Row> actual = df.groupBy(\"year\")\n      .pivot(\"course\", Arrays.asList(\"dotNET\", \"Java\"))\n      .agg(sum(\"earnings\")).orderBy(\"year\").collectAsList();\n\n    Assertions.assertEquals(2012, actual.get(0).getInt(0));\n    Assertions.assertEquals(15000.0, actual.get(0).getDouble(1), 0.01);\n    Assertions.assertEquals(20000.0, actual.get(0).getDouble(2), 0.01);\n\n    Assertions.assertEquals(2013, actual.get(1).getInt(0));\n    Assertions.assertEquals(48000.0, actual.get(1).getDouble(1), 0.01);\n    Assertions.assertEquals(30000.0, actual.get(1).getDouble(2), 0.01);\n  }\n\n  @Test\n  public void pivotColumnValues() {\n    Dataset<Row> df = spark.table(\"courseSales\");\n    List<Row> actual = df.groupBy(\"year\")\n      .pivot(col(\"course\"), Arrays.asList(lit(\"dotNET\"), lit(\"Java\")))\n      .agg(sum(\"earnings\")).orderBy(\"year\").collectAsList();\n\n    Assertions.assertEquals(2012, actual.get(0).getInt(0));\n    Assertions.assertEquals(15000.0, actual.get(0).getDouble(1), 0.01);\n    Assertions.assertEquals(20000.0, actual.get(0).getDouble(2), 0.01);\n\n    Assertions.assertEquals(2013, actual.get(1).getInt(0));\n    Assertions.assertEquals(48000.0, actual.get(1).getDouble(1), 0.01);\n    Assertions.assertEquals(30000.0, actual.get(1).getDouble(2), 0.01);\n  }\n\n  private String getResource(String resource) {\n    try {\n      URL url = Thread.currentThread().getContextClassLoader().getResource(resource);\n      return url.toURI().getPath();\n    } catch (URISyntaxException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Test\n  public void testGenericLoad() {\n    Dataset<Row> df1 = spark.read().format(\"text\").load(getResource(\"test-data/text-suite.txt\"));\n    Assertions.assertEquals(4L, df1.count());\n\n    Dataset<Row> df2 = spark.read().format(\"text\").load(\n      getResource(\"test-data/text-suite.txt\"),\n      getResource(\"test-data/text-suite2.txt\"));\n    Assertions.assertEquals(5L, df2.count());\n  }\n\n  @Test\n  public void testTextLoad() {\n    Dataset<String> ds1 = spark.read().textFile(getResource(\"test-data/text-suite.txt\"));\n    Assertions.assertEquals(4L, ds1.count());\n\n    Dataset<String> ds2 = spark.read().textFile(\n      getResource(\"test-data/text-suite.txt\"),\n      getResource(\"test-data/text-suite2.txt\"));\n    Assertions.assertEquals(5L, ds2.count());\n  }\n\n  @Test\n  public void testCountMinSketch() {\n    Dataset<Long> df = spark.range(1000);\n\n    CountMinSketch sketch1 = df.stat().countMinSketch(\"id\", 10, 20, 42);\n    Assertions.assertEquals(1000, sketch1.totalCount());\n    Assertions.assertEquals(10, sketch1.depth());\n    Assertions.assertEquals(20, sketch1.width());\n\n    CountMinSketch sketch2 = df.stat().countMinSketch(col(\"id\"), 10, 20, 42);\n    Assertions.assertEquals(1000, sketch2.totalCount());\n    Assertions.assertEquals(10, sketch2.depth());\n    Assertions.assertEquals(20, sketch2.width());\n\n    CountMinSketch sketch3 = df.stat().countMinSketch(\"id\", 0.001, 0.99, 42);\n    Assertions.assertEquals(1000, sketch3.totalCount());\n    Assertions.assertEquals(0.001, sketch3.relativeError(), 1.0e-4);\n    Assertions.assertEquals(0.99, sketch3.confidence(), 5.0e-3);\n\n    CountMinSketch sketch4 = df.stat().countMinSketch(col(\"id\"), 0.001, 0.99, 42);\n    Assertions.assertEquals(1000, sketch4.totalCount());\n    Assertions.assertEquals(0.001, sketch4.relativeError(), 1.0e-4);\n    Assertions.assertEquals(0.99, sketch4.confidence(), 5.0e-3);\n  }\n\n  @Test\n  public void testBloomFilter() {\n    Dataset<Long> df = spark.range(1000);\n\n    BloomFilter filter1 = df.stat().bloomFilter(\"id\", 1000, 0.03);\n    Assertions.assertTrue(filter1.expectedFpp() - 0.03 < 1e-3);\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter1.mightContain(i));\n    }\n\n    BloomFilter filter2 = df.stat().bloomFilter(col(\"id\").multiply(3), 1000, 0.03);\n    Assertions.assertTrue(filter2.expectedFpp() - 0.03 < 1e-3);\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter2.mightContain(i * 3));\n    }\n\n    BloomFilter filter3 = df.stat().bloomFilter(\"id\", 1000, 64 * 5);\n    Assertions.assertEquals(64 * 5, filter3.bitSize());\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter3.mightContain(i));\n    }\n\n    BloomFilter filter4 = df.stat().bloomFilter(col(\"id\").multiply(3), 1000, 64 * 5);\n    Assertions.assertEquals(64 * 5, filter4.bitSize());\n    for (int i = 0; i < 1000; i++) {\n      Assertions.assertTrue(filter4.mightContain(i * 3));\n    }\n  }\n\n  public static class BeanWithoutGetter implements Serializable {\n    private String a;\n\n    public void setA(String a) {\n      this.a = a;\n    }\n  }\n\n  @Test\n  public void testBeanWithoutGetter() {\n    BeanWithoutGetter bean = new BeanWithoutGetter();\n    List<BeanWithoutGetter> data = Arrays.asList(bean);\n    Dataset<Row> df = spark.createDataFrame(data, BeanWithoutGetter.class);\n    Assertions.assertEquals(0, df.schema().length());\n    Assertions.assertEquals(1, df.collectAsList().size());\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @Test\n  public void testJsonRDDToDataFrame() {\n    JavaRDD<String> rdd = jsc.parallelize(Arrays.asList(\"{\\\"a\\\": 2}\"));\n    Dataset<Row> df = spark.read().json(rdd);\n    Assertions.assertEquals(1L, df.count());\n    Assertions.assertEquals(2L, df.collectAsList().get(0).getLong(0));\n  }\n\n  public class CircularReference1Bean implements Serializable {\n    private CircularReference2Bean child;\n\n    public CircularReference2Bean getChild() {\n      return child;\n    }\n\n    public void setChild(CircularReference2Bean child) {\n      this.child = child;\n    }\n  }\n\n  public class CircularReference2Bean implements Serializable {\n    private CircularReference1Bean child;\n\n    public CircularReference1Bean getChild() {\n      return child;\n    }\n\n    public void setChild(CircularReference1Bean child) {\n      this.child = child;\n    }\n  }\n\n  @Test\n  public void testCircularReferenceBean() {\n    CircularReference1Bean bean = new CircularReference1Bean();\n    Assertions.assertThrows(UnsupportedOperationException.class,\n      () -> spark.createDataFrame(Arrays.asList(bean), CircularReference1Bean.class));\n  }\n\n  @Test\n  public void testUDF() {\n    UserDefinedFunction foo = udf((Integer i, String s) -> i.toString() + s, DataTypes.StringType);\n    Dataset<Row> df = spark.table(\"testData\").select(foo.apply(col(\"key\"), col(\"value\")));\n    String[] result = df.collectAsList().stream().map(row -> row.getString(0))\n      .toArray(String[]::new);\n    String[] expected = spark.table(\"testData\").collectAsList().stream()\n      .map(row -> row.get(0).toString() + row.getString(1)).toArray(String[]::new);\n    Assertions.assertArrayEquals(expected, result);\n  }\n\n  @Test\n  public void testTransformBase() {\n    Dataset<Integer> ds = spark.createDataset(Arrays.asList(1,2), Encoders.INT());\n    Dataset<Integer> transformed = ds.transform((Dataset<Integer> d) ->\n            ds.selectExpr(\"(value + 1) value\").as(Encoders.INT()));\n    Integer[] expected = {2, 3};\n    Integer[] got = transformed.collectAsList().toArray(new Integer[0]);\n    Arrays.sort(got);\n    Assertions.assertArrayEquals(expected, got);\n  }\n\n  @Test\n  public void testTransformAsClassic() {\n    org.apache.spark.sql.classic.Dataset<Integer> ds =\n            spark.createDataset(Arrays.asList(1,2), Encoders.INT());\n    org.apache.spark.sql.classic.Dataset<Integer> transformed =\n            ds.transform((Dataset<Integer> d) ->\n              ds.selectExpr(\"(value + 1) value\").as(Encoders.INT()));\n    Integer[] expected = {2, 3};\n    Integer[] got = transformed.collectAsList().toArray(new Integer[0]);\n    Arrays.sort(got);\n    Assertions.assertArrayEquals(expected, got);\n  }\n}",
        "human_comment": "Validate geting same result with withColumn loop call\nValidate the col names\nThe following \"getResource\" has different behaviors in SBT and Maven.\nWhen running in Jenkins, the file path may contain \"@\" when there are multiple\nSparkPullRequestBuilders running in the same worker\n(e.g., /home/jenkins/workspace/SparkPullRequestBuilder@2)\nWhen running in SBT, \"@\" in the file path will be returned as \"@\", however,\nwhen running in Maven, \"@\" will be encoded as \"%40\".\nTherefore, we convert it to URI then call \"getPath\" to decode it back so that it can both\nwork both in SBT and Maven.\nThis is a test for the deprecated API in SPARK-15615.\nChecks a simple case for DataFrame here and put exhaustive tests for the issue\nof circular references in `JavaDatasetSuite`.\nSPARK-49961 - transform must have the correct type\nSPARK-49961 - transform must have the correct type",
        "model_generated_comment": "@Test @link TestData2 @param key a1, a2, a3, a4, a5, a6, a7, a8, a9, and a10. @test df.assertEquals with a value of 0  @test @test Dataset a1 @testData2 @testSchema() @test dataset @testdataset @test dataset #testDataset #testDataset#testData*"
    },
    {
        "id": 590,
        "code_snippet": "public void setAddDefaultEntities(boolean addDefaultEntities) {\n        delegate.setAddLocationInformation(addDefaultEntities);\n    } // -- void setAddDefaultEntities( boolean )",
        "human_comment": "Sets the state of the \"add default entities\" flag.\n\n@param addDefaultEntities a addDefaultEntities object.",
        "model_generated_comment": "Sets the default values for the specified location. @param addDefaultEntities the default value for the selected location."
    },
    {
        "id": 591,
        "code_snippet": "protected Instance findNextInstance(int currentId) {\n    Instance result = null;\n    var candidateList =\n        instanceMap.keySet().stream()\n            .filter((i) -> i > currentId && instanceMap.get(i).isAlive())\n            .sorted()\n            .toList();\n    if (candidateList.isEmpty()) {\n      var index =\n          instanceMap.keySet().stream()\n              .filter((i) -> instanceMap.get(i).isAlive())\n              .sorted()\n              .toList()\n              .get(0);\n      result = instanceMap.get(index);\n    } else {\n      var index = candidateList.get(0);\n      result = instanceMap.get(index);\n    }\n    return result;\n  }",
        "human_comment": "Find the next instance with the smallest ID.\n\n@return The next instance.",
        "model_generated_comment": "@link CurrentId @param currentId if the current Id is not present. @return null if a new instance is found."
    },
    {
        "id": 592,
        "code_snippet": "protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement = childrenInvoker(notifier);\n        if (!areAllChildrenIgnored()) {\n            statement = withBeforeClasses(statement);\n            statement = withAfterClasses(statement);\n            statement = withClassRules(statement);\n            statement = withInterruptIsolation(statement);\n        }\n        return statement;\n    }",
        "human_comment": "Constructs a {@code Statement} to run all of the tests in the test class.\nOverride to add pre-/post-processing. Here is an outline of the\nimplementation:\n<ol>\n<li>Determine the children to be run using {@link #getChildren()}\n(subject to any imposed filter and sort).</li>\n<li>If there are any children remaining after filtering and ignoring,\nconstruct a statement that will:\n<ol>\n<li>Apply all {@code ClassRule}s on the test-class and superclasses.</li>\n<li>Run all non-overridden {@code @BeforeClass} methods on the test-class\nand superclasses; if any throws an Exception, stop execution and pass the\nexception on.</li>\n<li>Run all remaining tests on the test-class.</li>\n<li>Run all non-overridden {@code @AfterClass} methods on the test-class\nand superclasses: exceptions thrown by previous steps are combined, if\nnecessary, with exceptions from AfterClass methods into a\n{@link org.junit.runners.model.MultipleFailureException}.</li>\n</ol>\n</li>\n</ol>\n\n@return {@code Statement}",
        "model_generated_comment": "Returns a @link RunNotifier. @param childrenIgnored if a class is not defined."
    },
    {
        "id": 593,
        "code_snippet": "public Author getAuthorByUsername(String username) {\n    Author authorDto;\n    try (var session = sessionFactory.openSession()) {\n      Query<Author> sqlQuery =\n          session.createQuery(\n              \"select new com.iluwatar.cqrs.dto.Author(a.name, a.email, a.username)\"\n                  + \" from com.iluwatar.cqrs.domain.model.Author a where a.username=:username\");\n      sqlQuery.setParameter(AppConstants.USER_NAME, username);\n      authorDto = sqlQuery.uniqueResult();\n    }\n    return authorDto;\n  }",
        "human_comment": "This class is an implementation of {@link QueryService}. It uses Hibernate native queries to\nreturn DTOs from the database.",
        "model_generated_comment": "p>Select new com.iluwatar.cqrs.domain.model.Author/p>. @param username a username a.email a.username @link AuthorDto @returns a unique URI containing the user name of the URI to be used by the Query."
    },
    {
        "id": 594,
        "code_snippet": "public void allocate(int num_bins) {\n    nbins = num_bins;\n    bins = new ArrayList<>();\n    nusedbins = 0;\n  }",
        "human_comment": "Sets the number of histogram bins to use for approximating data.\n\n@param num_bins Number of non-uniform-width histogram bins to use",
        "model_generated_comment": "@code nusedbins @param num_bins p>Always allocate bins/p>"
    },
    {
        "id": 595,
        "code_snippet": "public Model expandPluginConfiguration(Model model, ModelBuilderRequest request, ModelProblemCollector problems) {\n        Build build = model.getBuild();\n        if (build != null) {\n            build = build.withPlugins(expandPlugin(build.getPlugins()));\n            PluginManagement pluginManagement = build.getPluginManagement();\n            if (pluginManagement != null) {\n                build = build.withPluginManagement(\n                        pluginManagement.withPlugins(expandPlugin(pluginManagement.getPlugins())));\n            }\n            model = model.withBuild(build);\n        }\n        Reporting reporting = model.getReporting();\n        if (reporting != null) {\n            expandReport(reporting.getPlugins());\n        }\n        return model.withBuild(build);\n    }",
        "human_comment": "Handles expansion of general build plugin configuration into individual executions.",
        "model_generated_comment": "Builds a @link PluginConfiguration model. @param modelModelModelModelBuilderRequest modelProblemCollector problems. @return model.withBuild(); if (build!= null) a build of a model with a built PluginManager, if the model is not built, the builder should be able to create a new builder for the model."
    },
    {
        "id": 596,
        "code_snippet": "public static void assertArrayEquals(byte[] expected, byte[] actual, String message) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} byte arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 597,
        "code_snippet": "public File locatePom(File projectDirectory) {\n        return new File(projectDirectory, \"pom.xml\");\n    }",
        "human_comment": "Locates a POM file within a project base directory.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead",
        "model_generated_comment": "Returns @link ProjectDirectory."
    },
    {
        "id": 598,
        "code_snippet": "private static boolean isCompatibleContainerType(Method method, DiscoveryIssueReporter issueReporter) {\n\t\tType genericReturnType = method.getGenericReturnType();\n\n\t\tif (genericReturnType instanceof ParameterizedType) {\n\t\t\tType[] typeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();\n\t\t\tif (typeArguments.length == 1) {\n\t\t\t\tType typeArgument = typeArguments[0];\n\t\t\t\tif (typeArgument instanceof Class) {\n\t\t\t\t\treturn DynamicNode.class.isAssignableFrom((Class<?>) typeArgument);\n\t\t\t\t}\n\t\t\t\tif (typeArgument instanceof WildcardType) {\n\t\t\t\t\tWildcardType wildcardType = (WildcardType) typeArgument;\n\t\t\t\t\tType[] upperBounds = wildcardType.getUpperBounds();\n\t\t\t\t\tType[] lowerBounds = wildcardType.getLowerBounds();\n\t\t\t\t\tif (upperBounds.length == 1 && lowerBounds.length == 0 && upperBounds[0] instanceof Class) {\n\t\t\t\t\t\tClass<?> upperBound = (Class<?>) upperBounds[0];\n\t\t\t\t\t\tif (Object.class.equals(upperBound)) { // Stream<?> etc.\n\t\t\t\t\t\t\tissueReporter.reportIssue(createTooGenericReturnTypeIssue(method));\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn DynamicNode.class.isAssignableFrom(upperBound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tissueReporter.reportIssue(createTooGenericReturnTypeIssue(method));\n\t\treturn true;\n\t}",
        "human_comment": "Stream<DynamicNode> etc.\nStream<? extends DynamicNode> etc.\nRaw Stream etc. without type argument",
        "model_generated_comment": "p>Assigns a @link ParameterizedType/p>. @param Param ParameterizeType if a class is assigned a specific type of return type. @return a generic return type if it is assigned to a particular class."
    },
    {
        "id": 599,
        "code_snippet": "public static void loadNativeLibs() {\n    try {\n      NativeLoader.loadLibrary(\"torch-code-gen\");\n    } catch (Throwable t) {\n    }\n  }",
        "human_comment": "Loading the codegen lib is best-effort since it's only there for query based builds.",
        "model_generated_comment": "@code-gen @param loadNativeLibrary @returns a library that loads native libraries from a local library."
    },
    {
        "id": 600,
        "code_snippet": "void cleanupModeDefaultParameter() {\n\t\t\tLauncherDiscoveryRequest request = request()//\n\t\t\t\t\t.selectors(selectMethod(DefaultParameterCase.class, \"testDefaultParameter\", \"java.nio.file.Path\"))//\n\t\t\t\t\t.build();\n\t\t\texecuteTests(request);\n\n\t\t\tassertThat(defaultParameterDir).doesNotExist();\n\t\t}",
        "human_comment": "Ensure the cleanup mode defaults to ALWAYS for parameters.\n<p/>\nExpect the TempDir to be cleaned up.",
        "model_generated_comment": "p>Create a new @code DefaultParameter."
    },
    {
        "id": 601,
        "code_snippet": "protected ThrowableCollector.Factory createThrowableCollectorFactory(ExecutionRequest request) {\n\t\treturn OpenTest4JAwareThrowableCollector::new;\n\t}",
        "human_comment": "Create the {@linkplain ThrowableCollector.Factory factory} for creating\n{@link ThrowableCollector} instances used to handle exceptions that occur\nduring execution of this engine's tests.\n\n<p>An engine may use the information in the supplied <em>request</em>\nsuch as the contained\n{@linkplain ExecutionRequest#getConfigurationParameters() configuration parameters}\nto decide what kind of factory to return or how to configure it.\n\n<p>By default, this method returns a factory that always creates instances of\n{@link OpenTest4JAwareThrowableCollector}.\n\n@param request the request about to be executed\n@since 1.3\n@see OpenTest4JAwareThrowableCollector\n@see ThrowableCollector",
        "model_generated_comment": "ThrowableCollectorFactory(ExecutionRequest request)/."
    },
    {
        "id": 602,
        "code_snippet": "public long mergedIndexCacheSize() {\n    return JavaUtils.byteStringAsBytes(\n      conf.get(\"spark.shuffle.push.server.mergedIndexCacheSize\", \"100m\"));\n  }",
        "human_comment": "The maximum size of cache in memory which is used in push-based shuffle for storing merged\nindex files. This cache is in addition to the one configured via\nspark.shuffle.service.index.cache.size.",
        "model_generated_comment": "p>Spark.shuffle.push.server.mergedIndexCacheSize/p>."
    },
    {
        "id": 603,
        "code_snippet": "private static DefinitionOrigin getDefinitionOrigin(int collationId) {\n        return DefinitionOrigin.values()[SpecifierUtils.getSpecValue(collationId,\n          DEFINITION_ORIGIN_OFFSET, DEFINITION_ORIGIN_MASK)];\n      }",
        "human_comment": "Utility function to retrieve `DefinitionOrigin` enum instance from collation ID.",
        "model_generated_comment": "p>SpecifierUtils.getDefinitionOrigin/p>. @param collationId @code collationId/code definition."
    },
    {
        "id": 604,
        "code_snippet": "public static void main(String[] args) {\n    SpringApplication.run(SingleTableInheritance.class, args);\n  }",
        "human_comment": "The entry point of the Spring Boot Application.\n\n@param args program runtime arguments",
        "model_generated_comment": "SpringApplication.run(SingleTableInheritance.class, args)."
    },
    {
        "id": 605,
        "code_snippet": "public String getLocation() {\n        return this.location;\n    } // -- String getLocation()",
        "human_comment": "Get the path/URL of the POM or {@code null} if unknown.\n\n@return String",
        "model_generated_comment": "@link String getLocation @param location the location of the location. @return this.location the location where the location is located. @transfer this.location to the location if it's not already there."
    },
    {
        "id": 606,
        "code_snippet": "public void publish(Message message) {\n    for (Subscriber subscriber : subscribers) {\n      CompletableFuture.runAsync(() -> subscriber.onMessage(message));\n    }\n  }",
        "human_comment": "Publish a message to subscribers.\n\n@param message message with content to publish",
        "model_generated_comment": "CompletableFuture.runAsync() for @link Subscriber. @param message message the message sent to the subscriber."
    },
    {
        "id": 607,
        "code_snippet": "public void testCodePointFrom() {\n    String str = \"abcde\";\n    UTF8String s = fromString(str);\n    for (int i = 0; i < str.length(); ++i) {\n      assertEquals(str.charAt(i), s.codePointFrom(i));\n    }\n    assertThrows(IndexOutOfBoundsException.class, () -> s.codePointFrom(-1));\n    assertThrows(IndexOutOfBoundsException.class, () -> s.codePointFrom(str.length()));\n    assertThrows(IndexOutOfBoundsException.class, () -> s.codePointFrom(str.length() + 1));\n\n    byte[] invalidString = new byte[] {(byte) 0x41, (byte) 0x42, (byte) 0x80};\n        assertEquals(0, invalidUTF8String.codePointFrom(i));\n      }",
        "human_comment": "Valid UTF-8 string\nValid character index handling\nInvalid character index handling\nInvalid UTF-8 string",
        "model_generated_comment": "@link Int/@link CodePointFrom(i) @param i = 0 if a byte is 0x40 if the byte has a value of /codePointFrom(). @return a UTF8String str.length() if it is not a valid byte i."
    },
    {
        "id": 608,
        "code_snippet": "public static void assertEquals(Byte expected, byte actual) {\n\t\tAssertEquals.assertEquals(expected, (Byte) actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 609,
        "code_snippet": "public void testStreamingContextTransform() {\n    List<List<Integer>> stream1input = Arrays.asList(\n      Arrays.asList(1),\n      Arrays.asList(2)\n    );\n\n    List<List<Integer>> stream2input = Arrays.asList(\n      Arrays.asList(3),\n      Arrays.asList(4)\n    );\n\n    List<List<Tuple2<Integer, String>>> pairStream1input = Arrays.asList(\n      Arrays.asList(new Tuple2<>(1, \"x\")),\n      Arrays.asList(new Tuple2<>(2, \"y\"))\n    );\n\n    List<List<Tuple2<Integer, Tuple2<Integer, String>>>> expected = Arrays.asList(\n      Arrays.asList(new Tuple2<>(1, new Tuple2<>(1, \"x\"))),\n      Arrays.asList(new Tuple2<>(2, new Tuple2<>(2, \"y\")))\n    );\n\n    JavaDStream<Integer> stream1 = JavaTestUtils.attachTestInputStream(ssc, stream1input, 1);\n    JavaDStream<Integer> stream2 = JavaTestUtils.attachTestInputStream(ssc, stream2input, 1);\n    JavaPairDStream<Integer, String> pairStream1 = JavaPairDStream.fromJavaDStream(\n      JavaTestUtils.attachTestInputStream(ssc, pairStream1input, 1));\n\n    List<JavaDStream<?>> listOfDStreams1 = Arrays.asList(stream1, stream2);\n\n    JavaDStream<Long> transformed1 = ssc.transform(\n      listOfDStreams1, (List<JavaRDD<?>> listOfRDDs, Time time) -> {\n      Assertions.assertEquals(2, listOfRDDs.size());\n      return null;\n    });\n\n    List<JavaDStream<?>> listOfDStreams2 =\n      Arrays.asList(stream1, stream2, pairStream1.toJavaDStream());\n\n    JavaPairDStream<Integer, Tuple2<Integer, String>> transformed2 = ssc.transformToPair(\n      listOfDStreams2, (List<JavaRDD<?>> listOfRDDs, Time time) -> {\n      Assertions.assertEquals(3, listOfRDDs.size());\n      JavaRDD<Integer> rdd1 = (JavaRDD<Integer>) listOfRDDs.get(0);\n      JavaRDD<Integer> rdd2 = (JavaRDD<Integer>) listOfRDDs.get(1);\n      JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>) listOfRDDs.get(2);\n      JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3);\n      PairFunction<Integer, Integer, Integer> mapToTuple =\n        (Integer i) -> new Tuple2<>(i, i);\n      return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3);\n    });\n    JavaTestUtils.attachTestOutputStream(transformed2);\n    List<List<Tuple2<Integer, Tuple2<Integer, String>>>> result =\n      JavaTestUtils.runStreams(ssc, 2, 2);\n    Assertions.assertEquals(expected, result);\n  }",
        "human_comment": "This is just to test whether this transform to JavaStream compiles",
        "model_generated_comment": "@link Arrays/@link JavaDStream/www.java-test-utils.com> p>Assertions/p> if a StreamingContextTransform() is called, it will return a new Stream. @param stream1 if the Stream is an Array containing a Tuple2 containing Tuple2."
    },
    {
        "id": 610,
        "code_snippet": "public MethodValidator(TestClass testClass) {\n        this.testClass = testClass;\n    }",
        "human_comment": "@deprecated Included for backwards compatibility with JUnit 4.4. Will be\nremoved in the next major release. Please use\n{@link BlockJUnit4ClassRunner} in place of {@link JUnit4ClassRunner}.",
        "model_generated_comment": "@link TestClass @param testClass the test class for which the test is to be performed. @return a test class if it's not a valid test class."
    },
    {
        "id": 611,
        "code_snippet": "private static boolean checkCombineLines(String line) {\n            int bsCount = 0;\n            for (int idx = line.length() - 1; idx >= 0 && line.charAt(idx) == '\\\\'; idx--) {\n                bsCount++;\n            }\n\n            return bsCount % 2 != 0;\n        }",
        "human_comment": "Checks if the passed in line should be combined with the following.\nThis is true, if the line ends with an odd number of backslashes.\n\n@param line the line\n@return a flag if the lines should be combined",
        "model_generated_comment": "@code line @param line idx = 0 && line.length() - 1 p>If a line is a string, it should be a boolean string. @return a list of all the lines in the list."
    },
    {
        "id": 612,
        "code_snippet": "public ConsolePasswordPrompt(Prompter prompter) {\n        this.prompter = prompter;\n    }",
        "human_comment": "Trivial master password source using Maven {@link Prompter} service.",
        "model_generated_comment": "Prompter prompter for @link ConsolePasswordPrompt."
    },
    {
        "id": 613,
        "code_snippet": "private long cpuTime(Thread thr) {\n        ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n        if (mxBean.isThreadCpuTimeSupported()) {\n            try {\n                return mxBean.getThreadCpuTime(thr.getId());\n            } catch (UnsupportedOperationException e) {\n            }\n        }\n        return 0;\n    }",
        "human_comment": "Returns the CPU time used by a thread, if possible.\n@param thr The thread to query.\n@return The CPU time used by {@code thr}, or 0 if it cannot be determined.",
        "model_generated_comment": "@link ThreadMXBean @param ThreadCpuTimeSupported @return UnsupportedOperationException e if a thread is not supported."
    },
    {
        "id": 614,
        "code_snippet": "public Message retrieveMsg() {\n    try {\n      return blkQueue.poll();\n    } catch (Exception e) {\n      LOGGER.error(e.getMessage());\n    }\n    return null;\n  }",
        "human_comment": "All the messages will be retrieved by the ServiceExecutor by calling this method and process\nthem. Retrieves and removes the head of this queue, or returns null if this queue is empty.",
        "model_generated_comment": "@link Exception e. @param emsg if a message is retrieved from a queue. @return null if the message is not retrieved."
    },
    {
        "id": 615,
        "code_snippet": "private void installIntoProjectLocalRepository(MavenProject project) {\n        if (\"pom\".equals(project.getPackaging())\n                        && !\"clean\".equals(getLifecycles(project).peekLast())\n                || hasBeenPackagedDuringThisSession(project)) {\n            getProjectArtifacts(project).filter(this::isRegularFile).forEach(this::installIntoProjectLocalRepository);\n        }\n    }",
        "human_comment": "Copy packaged and attached artifacts from this project to the\nproject local repository.\nThis allows a subsequent build to resume while still being able\nto locate attached artifacts.\n\n@param project the project to copy artifacts from",
        "model_generated_comment": "@link hasBeenPackagedDuringThisSession. @param project if the project has been packaged during this Session a new version of the project will be installed into the local repository. @return a project that has been installed into a local repository if it hasn't already been installed a different version of it."
    },
    {
        "id": 616,
        "code_snippet": "public SettingsBuildingException(List<SettingsProblem> problems) {\n        super(toMessage(problems));\n\n        this.problems = new ArrayList<>();\n        if (problems != null) {\n            this.problems.addAll(problems);\n        }\n    }",
        "human_comment": "Creates a new exception with the specified problems.\n\n@param problems The problems that cause this exception, may be {@code null}.",
        "model_generated_comment": "@link SettingsBuildingException/@link SettingsProblems/. @param problems a list of problems. @return a new ArrayList of problems if the problem is null. @examples: if a problem is not found, it will be removed from the list."
    },
    {
        "id": 617,
        "code_snippet": "private void addUserProvidedDelegates(Options options) {\n    for (Delegate delegate : options.getDelegates()) {\n      if (options.getRuntime() != TfLiteRuntime.FROM_APPLICATION_ONLY\n          && !(delegate instanceof NnApiDelegate)) {\n        throw new IllegalArgumentException(\n            \"Instantiated delegates (other than NnApiDelegate) are not allowed when using TF Lite\"\n                + \" from Google Play Services. Please use\"\n                + \" InterpreterApi.Options.addDelegateFactory() with an appropriate DelegateFactory\"\n                + \" instead.\");\n      }\n      delegates.add(delegate);\n    }\n  }",
        "human_comment": "NnApiDelegate is compatible with both the system and built-in runtimes and therefore can be\nadded directly even when using TF Lite from the system.",
        "model_generated_comment": "@link NnApiDelegate/@link TfLiteRuntime.FROM_APPLICATION_ONLY. p>Delegates are not allowed when using TF Lite."
    },
    {
        "id": 618,
        "code_snippet": "Artifact originatingArtifact, Map<String, Artifact> managedVersions) {\n        ManagedVersionMap versionMap;\n        if (managedVersions instanceof ManagedVersionMap managedVersionMap) {\n            versionMap = managedVersionMap;\n        } else {\n            versionMap = new ManagedVersionMap(managedVersions);\n        }\n\n        // remove the originating artifact if it is also in managed versions to avoid being modified during resolution\n        Artifact managedOriginatingArtifact = versionMap.get(originatingArtifact.getDependencyConflictId());\n\n        if (managedOriginatingArtifact != null) {\n            // TODO we probably want to warn the user that he is building an artifact with\n            // different values than in dependencyManagement\n            if (managedVersions instanceof ManagedVersionMap) {\n                /* avoid modifying the managedVersions parameter creating a new map */\n                versionMap = new ManagedVersionMap(managedVersions);\n            }\n            versionMap.remove(originatingArtifact.getDependencyConflictId());\n        }\n\n        return versionMap;\n    }",
        "human_comment": "Get the map of managed versions, removing the originating artifact if it is also in managed versions\n\n@param originatingArtifact artifact we are processing\n@param managedVersions original managed versions",
        "model_generated_comment": "@link ManagedVersions if the originating artifact is also in managed versions to avoid being modified during resolution. @param originatingArtifact, MapString, Artifact> if a managed version is managed, it will be removed from the managed version. @return a version of managedVersionMap if it is in managed version if there is a originating version."
    },
    {
        "id": 619,
        "code_snippet": "public JavaCustomReceiver(String host_ , int port_) {\n    super(StorageLevel.MEMORY_AND_DISK_2());\n    host = host_;\n    port = port_;\n  }",
        "human_comment": "Create the context with a 1 second batch size\nCreate an input stream with the custom receiver on target ip:port and count the\nwords in input stream of \\n delimited text (e.g. generated by 'nc')\n============= Receiver code that receives data over a socket ==============",
        "model_generated_comment": "p>StorageLevel/p>Analyzes a @code port_/code port."
    },
    {
        "id": 620,
        "code_snippet": "public ConditionFunctions(ProfileActivationContext context, VersionParser versionParser) {\n        this.context = context;\n        this.versionParser = versionParser;\n    }",
        "human_comment": "Constructs a new ConditionFunctions instance.\n\n@param context The profile activation context\n@param versionParser The version parser for comparing versions",
        "model_generated_comment": "Context for @link ProfileActivationContext."
    },
    {
        "id": 621,
        "code_snippet": "public ByteBuffer getByteBuffer() {\n    if (base instanceof byte[] bytes && offset >= BYTE_ARRAY_OFFSET) {\n\n      // the offset includes an object header... this is only needed for unsafe copies\n      final long arrayOffset = offset - BYTE_ARRAY_OFFSET;\n\n      // verify that the offset and length points somewhere inside the byte array\n      // and that the offset can safely be truncated to a 32-bit integer\n      if ((long) bytes.length < arrayOffset + numBytes) {\n        throw new ArrayIndexOutOfBoundsException();\n      }\n\n      return ByteBuffer.wrap(bytes, (int) arrayOffset, numBytes);\n    } else {\n      return ByteBuffer.wrap(getBytes());\n    }\n  }",
        "human_comment": "Returns a {@link ByteBuffer} wrapping the base object if it is a byte array\nor a copy of the data if the base object is not a byte array.\n\nUnlike getBytes this will not create a copy the array if this is a slice.",
        "model_generated_comment": "@link Bytes @param offset The offset is truncated to a 32-bit integer."
    },
    {
        "id": 622,
        "code_snippet": "public MavenExecutionPlan calculateExecutionPlan(MavenSession session, String... tasks) {\n        return new MavenExecutionPlan(null, new DefaultLifecycles());\n    }",
        "human_comment": "A stub implementation that assumes an empty lifecycle to bypass interaction with the plugin manager and to avoid\nplugin artifact resolution from repositories.",
        "model_generated_comment": "MavenExecutionPlan(null, new DefaultLifecycles())."
    },
    {
        "id": 623,
        "code_snippet": "public void closeIfFreeable() {\n    // By default, we just call close() for all column vectors. If a column vector is writable or\n    // constant, it should override this method and do nothing.\n    close();\n  }",
        "human_comment": "Cleans up memory for this column vector if it's resources are freeable between batches.\nThe column vector is not usable after this.\n\nIf this is a writable column vector or constant column vector, it is a no-op.",
        "model_generated_comment": "Closes a column vector if it is writable."
    },
    {
        "id": 624,
        "code_snippet": "public static Predicate<Event> byTestDescriptor(Predicate<? super TestDescriptor> testDescriptorPredicate) {\n\t\treturn where(Event::getTestDescriptor, testDescriptorPredicate);\n\t}",
        "human_comment": "Create a {@link Predicate} for {@linkplain Event events} whose\n{@link TestDescriptor TestDescriptors} match the supplied\n{@code testDescriptorPredicate}.\n\n@param testDescriptorPredicate a {@code Predicate} to match against test\ndescriptors\n@return the resulting {@link Predicate}",
        "model_generated_comment": "@link TestDescriptorPredicate @return the test descriptor for the predicate. @param testdescriptorpredicate the test definition for a given event."
    },
    {
        "id": 625,
        "code_snippet": "public int accumulateSum(int... nums) {\n    LOGGER.info(SOURCE_MODULE, VERSION);\n    return Arrays.stream(nums).reduce(0, Integer::sum);\n  }",
        "human_comment": "New source. Completely covers functionalities of old source with new techniques and also has some\nnew features.",
        "model_generated_comment": "p>SOURCE_MODULE/p>Assembles a sum of the sum of a @link Integer."
    },
    {
        "id": 626,
        "code_snippet": "public ProjectBuilderRequest build() {\n            return new DefaultProjectBuilderRequest(\n                    session, trace, path, source, allowStubModel, recursive, processPlugins, repositories);\n        }",
        "human_comment": "Builds a new ProjectBuilderRequest with the current builder settings.\n\n@return a new ProjectBuilderRequest instance",
        "model_generated_comment": "Builds a new ProjectBuilderRequest. @param session, trace, path, source, allowStubModel, recursive, processPlugins, repositories."
    },
    {
        "id": 627,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaVectorIndexerExample\")\n      .getOrCreate();\n\n    Dataset<Row> data = spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");\n\n    VectorIndexer indexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexed\")\n      .setMaxCategories(10);\n    VectorIndexerModel indexerModel = indexer.fit(data);\n\n    Map<Integer, Map<Double, Integer>> categoryMaps = indexerModel.javaCategoryMaps();\n    System.out.print(\"Chose \" + categoryMaps.size() + \" categorical features:\");\n\n    for (Integer feature : categoryMaps.keySet()) {\n      System.out.print(\" \" + feature);\n    }\n    System.out.println();\n\n    Dataset<Row> indexedData = indexerModel.transform(data);\n    indexedData.show();\n    spark.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nCreate new column \"indexed\" with categorical values transformed to indices\n$example off$",
        "model_generated_comment": "p>SparkSession/p> @link Integer /. @param https://github.com/sparks/indexers/indexer_model.jsvm_data.txt\"> if a VectorIndexerModel is created, it will be able to create a new indexed data set."
    },
    {
        "id": 628,
        "code_snippet": "private static Logger getLogger() {\n\t\treturn LoggerFactory.getLogger(ServiceLoaderTestEngineRegistry.class);\n\t}",
        "human_comment": "Not a constant to avoid problems with building GraalVM native images",
        "model_generated_comment": "LoggerFactory.getLogger() @link ServiceLoaderTestEngineRegistry. @return a static Logger for a service loader."
    },
    {
        "id": 629,
        "code_snippet": "public static <V> V fail() {\n\t\tAssertionUtils.fail();\n\t\treturn null; // appeasing the compiler: this line will never be executed.\n\t}",
        "human_comment": "<em>Fail</em> the test <em>without</em> a failure message.\n\n<p>Although failing <em>with</em> an explicit failure message is recommended,\nthis method may be useful when maintaining legacy code.\n\n<p>See Javadoc for {@link #fail(String)} for an explanation of this method's\ngeneric return type {@code V}.",
        "model_generated_comment": "p>AssertionUtils.fail()/p>This line will never be executed."
    },
    {
        "id": 630,
        "code_snippet": "public void put(int field$, java.lang.Object value$) {\n    switch (field$) {\n    case 0: maybe_bool_column = (java.lang.Boolean)value$; break;\n    case 1: maybe_int_column = (java.lang.Integer)value$; break;\n    case 2: maybe_long_column = (java.lang.Long)value$; break;\n    case 3: maybe_float_column = (java.lang.Float)value$; break;\n    case 4: maybe_double_column = (java.lang.Double)value$; break;\n    case 5: maybe_binary_column = (java.nio.ByteBuffer)value$; break;\n    case 6: maybe_string_column = (java.lang.String)value$; break;\n    default: throw new org.apache.avro.AvroRuntimeException(\"Bad index\");\n    }\n  }",
        "human_comment": "Used by DatumReader.  Applications should not call.",
        "model_generated_comment": "@link java.lang.avro.runtimeException @param field$ p>Avro.AvroRuntimeException is thrown when a new runtime is created."
    },
    {
        "id": 631,
        "code_snippet": "final UTF8String getUTF8String(int rowId) {\n      accessor.get(rowId, stringResult);\n      if (stringResult.isSet == 0) {\n        return null;\n      } else {\n        return UTF8String.fromAddress(null,\n          stringResult.buffer.memoryAddress() + stringResult.start,\n          (int)(stringResult.end - stringResult.start));\n      }\n    }",
        "human_comment": "A single string cannot be larger than the max integer size, so the conversion is safe",
        "model_generated_comment": "p>Utilizes the UTF8String by @link UTF-8String. @param rowId if the row is a null value."
    },
    {
        "id": 632,
        "code_snippet": "public Events started() {\n\t\treturn new Events(eventsByType(EventType.STARTED), this.category + \" Started\");\n\t}",
        "human_comment": "Get the started {@link Events} contained in this {@code Events} object.\n\n@return the filtered {@code Events}; never {@code null}",
        "model_generated_comment": "@link EventsByType @param EventType.STARTED @return a new Event type if the event type is already started."
    },
    {
        "id": 633,
        "code_snippet": "public boolean isChildOfRootNode() {\n        return parent != null && parent.parent == null;\n    }",
        "human_comment": "Test whether the node is direct or transitive dependency.\n\n@return whether the node is direct or transitive dependency",
        "model_generated_comment": "@link isChildOfRootNode. @param parent the parent of a node. @return a boolean if the node is a child of the parent node"
    },
    {
        "id": 634,
        "code_snippet": "static RuntimeException handleCsvException(Throwable throwable, Annotation annotation) {\n\t\tUnrecoverableExceptions.rethrowIfUnrecoverable(throwable);\n\t\tif (throwable instanceof PreconditionViolationException) {\n\t\t\tthrow (PreconditionViolationException) throwable;\n\t\t}\n\t\tthrow new CsvParsingException(\"Failed to parse CSV input configured via \" + annotation, throwable);\n\t}",
        "human_comment": "@return this method always throws an exception and therefore never\nreturns anything; the return type is merely present to allow this\nmethod to be supplied as the operand in a {@code throw} statement",
        "model_generated_comment": "Throws a @link PreconditionViolationException that fails to parse CSV input configured via an annotation."
    },
    {
        "id": 635,
        "code_snippet": "public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn int[].class == parameterContext.getParameter().getType();\n\t}",
        "human_comment": "Example {@link ParameterResolver} that resolves arrays of primitive integers.\n\n@since 5.0",
        "model_generated_comment": "p>ParameterContext/p>. @param parameterContext @code param parameter/@code extensionContext> @return a boolean if a parameter is a type of parameter."
    },
    {
        "id": 636,
        "code_snippet": "static ReadLimit minRows(long rows, long maxTriggerDelayMs) {\n    return new ReadMinRows(rows, maxTriggerDelayMs);\n  }",
        "human_comment": "Interface representing limits on how much to read from a {@link MicroBatchStream} when it\nimplements {@link SupportsAdmissionControl}. There are several child interfaces representing\nvarious kinds of limits.\n\n@see SupportsAdmissionControl#latestOffset(Offset, ReadLimit)\n@see ReadAllAvailable\n@see ReadMaxRows\n@since 3.0.0",
        "model_generated_comment": "Returns a read limit of minRows(rows, maxTriggerDelayMs)."
    },
    {
        "id": 637,
        "code_snippet": "public int find(long key) {\n    long h = hash(key);\n    int step = 0;\n    int idx = (int) h & (numBuckets - 1);\n    while (step < maxSteps) {\n      if (buckets[idx] == -1) {\n        return idx;\n      } else if (equals(idx, key)) {\n        return idx;\n      }\n      idx = (idx + 1) & (numBuckets - 1);\n      step++;\n    }\n    return -1;\n  }",
        "human_comment": "Return bucket index if it's either an empty slot or already contains the key\nDidn't find it",
        "model_generated_comment": "p>If the key is a long key, the idx of the key will be 0/p>. @param key @code key @return the key if the key has a value greater than /code key>."
    },
    {
        "id": 638,
        "code_snippet": "public MojoFailureException(Object source, String shortMessage, String longMessage) {\n        super(shortMessage);\n        this.source = source;\n        this.longMessage = longMessage;\n    }",
        "human_comment": "Construct a new <code>MojoFailureException</code> exception providing the source and a short and long message:\nthese messages are used to improve the message written at the end of Maven build.\n\n@param source\n@param shortMessage\n@param longMessage",
        "model_generated_comment": "@link MojoFailureException. @param shortMessage the source of the object; if the object is a short message, the long message will be returned."
    },
    {
        "id": 639,
        "code_snippet": "void testFailure_HalfOpenStateTransition() {\n    assertEquals(\"Delayed service is down\", monitoringService.delayedServiceResponse());\n    assertEquals(\"OPEN\", delayedServiceCircuitBreaker.getState());\n\n    try {\n      LOGGER.info(\"Waiting 2s for delayed service to become responsive\");\n      Thread.sleep(2000);\n    } catch (InterruptedException e) {\n      LOGGER.error(\"An error occurred: \", e);\n    }\n    assertEquals(\"HALF_OPEN\", delayedServiceCircuitBreaker.getState());\n  }",
        "human_comment": "Calling delayed service, which will be unhealthy till 4 seconds\nAs failure threshold is \"1\", the circuit breaker is changed to OPEN\nWaiting for recovery period of 2 seconds for circuit breaker to retry service.\nAfter 2 seconds, the circuit breaker should move to \"HALF_OPEN\" state and retry fetching\nresponse from service again",
        "model_generated_comment": "p>An error occurred for delayed service to become responsive. @param \"Delayed service is down\", monitoringService.delayedServiceResponse()/p>"
    },
    {
        "id": 640,
        "code_snippet": "public <T extends Annotation> T getAnnotation(Class<T> annotationType) {\n        for (Annotation each : fAnnotations) {\n            if (each.annotationType().equals(annotationType)) {\n                return annotationType.cast(each);\n            }\n        }\n        return null;\n    }",
        "human_comment": "@return the annotation of type annotationType that is attached to this description node,\nor null if none exists",
        "model_generated_comment": "@link AnnotationType @param annotationType annotationType for each annotation type. @return null if the annotation type is equal to a given annotation type"
    },
    {
        "id": 641,
        "code_snippet": "public UserAccount readFromDb(final String userId) {\n    var iterable =\n        db.getCollection(CachingConstants.USER_ACCOUNT).find(new Document(USER_ID, userId));\n    if (iterable.first() == null) {\n      return null;\n    }\n    Document doc = iterable.first();\n    if (doc != null) {\n      String userName = doc.getString(USER_NAME);\n      String appInfo = doc.getString(ADD_INFO);\n      return new UserAccount(userId, userName, appInfo);\n    } else {\n      return null;\n    }\n  }",
        "human_comment": "Read data from DB.\n\n@param userId {@link String}\n@return {@link UserAccount}",
        "model_generated_comment": "@link UserAccount @param userId, userName, appInfo @return null if the user is not a valid user. @example: if a user is logged in to a db server, the user account will be renamed to doc."
    },
    {
        "id": 642,
        "code_snippet": "public String put(String key, List<String> commentLines, List<String> valueLines) {\n        commentLines = new ArrayList<>(commentLines);\n        valueLines = new ArrayList<>(valueLines);\n        String escapedKey = escapeKey(key);\n        StringBuilder sb = new StringBuilder();\n        if (valueLines.isEmpty()) {\n            valueLines.add(escapedKey + \"=\");\n            sb.append(escapedKey).append(\"=\");\n        } else {\n            String val0 = valueLines.get(0);\n            String rv0 = typed ? val0 : escapeJava(val0);\n            if (!val0.trim().startsWith(escapedKey)) {\n                valueLines.set(0, escapedKey + \" = \" + rv0 /*+ (0 < lastLine? \"\\\\\": \"\")*/);\n                sb.append(escapedKey).append(\" = \").append(rv0);\n            } else {\n                valueLines.set(0, rv0 /*+ (0 < lastLine? \"\\\\\": \"\")*/);\n                sb.append(rv0);\n            }\n        }\n        for (int i = 1; i < valueLines.size(); i++) {\n            String val = valueLines.get(i);\n            valueLines.set(i, typed ? val : escapeJava(val) /*+ (i < lastLine? \"\\\\\": \"\")*/);\n            while (!val.isEmpty() && Character.isWhitespace(val.charAt(0))) {\n                val = val.substring(1);\n            }\n            sb.append(val);\n        }\n        String[] property = PropertiesReader.parseProperty(sb.toString());\n        this.layout.put(key, new Layout(commentLines, valueLines));\n        return storage.put(key, property[1]);\n    }",
        "human_comment": "int lastLine = valueLines.size() - 1;",
        "model_generated_comment": "@link @param valueLines/. @return a string containing the escaped key of the ArrayList/link @code /code escapedKey if the key is not a valid key #code escapingKey. @code the escaping key if it's a val0 val1 val2 val3 val4 val5 val6 val7 val8 val9 val10 val11 val12 val13 val14 val16 val"
    },
    {
        "id": 643,
        "code_snippet": "public static ClassSelector selectClass(ClassLoader classLoader, String className) {\n\t\tPreconditions.notBlank(className, \"Class name must not be null or blank\");\n\t\treturn new ClassSelector(classLoader, className);\n\t}",
        "human_comment": "Create a {@code ClassSelector} for the supplied class name and class loader.\n\n@param classLoader the class loader to use to load the class, or {@code null}\nto signal that the default {@code ClassLoader} should be used\n@param className the fully qualified name of the class to select; never\n{@code null} or blank\n@since 1.10\n@see ClassSelector",
        "model_generated_comment": "@code null @param classLoader className @return a class that is not null or blank. @reason if the class is null/null or blank"
    },
    {
        "id": 644,
        "code_snippet": "public void launcherSessionOpened(LauncherSession session) {\n\t\tsession.getLauncher().registerTestExecutionListeners(new TestExecutionListener() {\n\t\t\t\tNamespacedHierarchicalStore<Namespace> store = session.getStore(); // <1>\n\t\t\t\tstore.getOrComputeIfAbsent(Namespace.GLOBAL, \"httpServer\", key -> { // <2>\n\t\t\t\t\tInetSocketAddress address = new InetSocketAddress(getLoopbackAddress(), 0);\n\t\t\t\t\tHttpServer server;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tserver = HttpServer.create(address, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t\tthrow new UncheckedIOException(\"Failed to start HTTP server\", e);\n\t\t\t\t\t}\n\t\t\t\t\tserver.createContext(\"/test\", exchange -> {\n\t\t\t\t\t\texchange.sendResponseHeaders(204, -1);\n\t\t\t\t\t\texchange.close();\n\t\t\t\t\t});\n\t\t\t\t\tExecutorService executorService = Executors.newCachedThreadPool();\n\t\t\t\t\tserver.setExecutor(executorService);\n\t\t\t\t\tserver.start(); // <3>\n\n\t\t\t\t\treturn new CloseableHttpServer(server, executorService);\n\t\t\t\t});\n\t\t\t}\n\t\t});",
        "human_comment": "tag::user_guide[]\nAvoid setup for test discovery by delaying it until tests are about to be executed\ntag::user_guide[]",
        "model_generated_comment": "@link UncheckedIOException @param \"httpServer\" if the server is not running. @return true if it is running."
    },
    {
        "id": 645,
        "code_snippet": "public static Tensor fromBlob(IntBuffer data, long[] shape, MemoryFormat memoryFormat) {\n    checkArgument(data != null, ERROR_MSG_DATA_BUFFER_NOT_NULL);\n    checkArgument(shape != null, ERROR_MSG_SHAPE_NOT_NULL);\n    checkShape(shape);\n    checkShapeAndDataCapacityConsistency(data.capacity(), shape);\n    checkArgument(data.isDirect(), ERROR_MSG_DATA_BUFFER_MUST_BE_DIRECT);\n    checkArgument(\n        (data.order() == ByteOrder.nativeOrder()),\n        ERROR_MSG_DATA_BUFFER_MUST_HAVE_NATIVE_BYTE_ORDER);\n    return new Tensor_int32(data, shape, memoryFormat);\n  }",
        "human_comment": "Creates a new Tensor instance with dtype torch.int32 with specified shape and data.\n\n@param data Direct buffer with native byte order that contains {@code Tensor.numel(shape)}\nelements. The buffer is used directly without copying, and changes to its content will\nchange the tensor.\n@param shape Tensor shape",
        "model_generated_comment": "p>Assembles a @code Tensor. @param shape data, shape, MemoryFormat memoryFormat /p>"
    },
    {
        "id": 646,
        "code_snippet": "public static void assertNotEquals(Byte unexpected, byte actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Byte) actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4",
        "model_generated_comment": "Asserts that @code unexpected is equal. @param actual, byte actual, messageSupplier/@code actual is not equal."
    },
    {
        "id": 647,
        "code_snippet": "void resetStatics() {\n\t\tthrowExceptionBeforeAll = true;\n\t\tthrowExceptionBeforeEach = true;\n\t\tthrowExceptionAfterEach = true;\n\t\tthrowExceptionAfterAll = true;\n\t\thandlerCalls.clear();\n\n\t\tSwallowExceptionHandler.callCounter.reset();\n\n\t\tRethrowExceptionHandler.callCounter.reset();\n\n\t\tConvertExceptionHandler.callCounter.reset();\n\n\t\tUnrecoverableExceptionHandler.callCounter.reset();\n\n\t\tShouldNotBeCalledHandler.callCounter.reset();\n\t}",
        "human_comment": "Tests that verify the support for lifecycle method execution exception handling\nvia {@link LifecycleMethodExecutionExceptionHandler}\n\n@since 5.5",
        "model_generated_comment": "p>Resets the call counter/p>. @param @code ExceptionHandler.callCounter.resetStatics(). @returns all calls to the handler."
    },
    {
        "id": 648,
        "code_snippet": "public static Artifact toPomArtifact(Artifact artifact) {\n        Artifact pomArtifact = artifact;\n\n        if (!pomArtifact.getClassifier().isEmpty() || !\"pom\".equals(pomArtifact.getExtension())) {\n            pomArtifact =\n                    new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), \"pom\", artifact.getVersion());\n        }\n\n        return pomArtifact;\n    }",
        "human_comment": "<strong>Warning:</strong> This is an internal utility class that is only public for technical reasons, it is not part\nof the public API. In particular, this class can be changed or deleted without prior notice.",
        "model_generated_comment": "@link Artifacts @param artifact a pomArtifact the pom classifier. @return a classifact that is empty if it's not already pom-artifact; // if the class is empty, it'll return a Classifact with the same name as the class."
    },
    {
        "id": 649,
        "code_snippet": "default DependencyResolverResult collect(@Nonnull DependencyResolverRequest request) {\n        if (request.getRequestType() != DependencyResolverRequest.RequestType.COLLECT) {\n            throw new IllegalArgumentException(\"requestType should be COLLECT when calling collect()\");\n        }\n        return resolve(request);\n    }",
        "human_comment": "Collects the transitive dependencies and builds a dependency graph.\nNote that this operation is only concerned about determining the coordinates of the\ntransitive dependencies and does not actually resolve the artifact files.\n\n@param request the dependency collection request, must not be {@code null}\n@return the collection result, never {@code null}\n@throws DependencyResolverException if the dependency tree could not be built\n@throws IllegalArgumentException if an argument is null or invalid\n\n@see DependencyResolver#collect(Session, Project, PathScope)\n@see DependencyResolver#collect(Session, DependencyCoordinates, PathScope)\n@see DependencyResolver#collect(Session, Artifact, PathScope)",
        "model_generated_comment": "@link DependencyResolverRequest @param dependencyresolverrequestType should be COLLECT when calling collect()."
    },
    {
        "id": 650,
        "code_snippet": "public void setMaybeStringColumn(java.lang.String value) {\n    this.maybe_string_column = value;\n  }",
        "human_comment": "Sets the value of the 'maybe_string_column' field.\n@param value the value to set.",
        "model_generated_comment": "Sets the value of a @link StringColumn. @param value if the value is not set."
    },
    {
        "id": 651,
        "code_snippet": "public final List<TestSource> getSources() {\n\t\treturn this.sources;\n\t}",
        "human_comment": "Get an immutable list of the {@linkplain TestSource sources} stored in this\n{@code CompositeTestSource}.\n\n@return the sources stored in this {@code CompositeTestSource}; never {@code null}",
        "model_generated_comment": "Returns the source of the test. @param @link TestSources. @return this.sources if the source is not a valid test source."
    },
    {
        "id": 652,
        "code_snippet": "protected Object createTest() {\n            final CreateTestDefersToNoArgCreateTestTest obj = new CreateTestDefersToNoArgCreateTestTest();\n\n            obj.createTestCalled = true;\n\n            return obj;\n        }",
        "human_comment": "Runner for testing override of {@link org.junit.runners.BlockJUnit4ClassRunner#createTest()}\nis still called by default if no other {@code createTest} method override\nis in place. This is tested by setting a boolean flag in a field of the\ntest class so it can be checked to confirm that the createTest method was\ncalled.",
        "model_generated_comment": "Creates a new test for each test. @param @link CreateTestDefersToNoArgCreateTestTest. @return true if the test is not created."
    },
    {
        "id": 653,
        "code_snippet": "public void setNestedIntsColumn(java.util.List<java.lang.Integer> value) {\n    this.nested_ints_column = value;\n  }",
        "human_comment": "Sets the value of the 'nested_ints_column' field.\n@param value the value to set.",
        "model_generated_comment": "Sets the nested ints of a java.lang.IntegerColumn. @param value the value of @link /@link #this.nested_ints_column."
    },
    {
        "id": 654,
        "code_snippet": "public UserPresenter(UserRepository dataSource, @Nullable UserView view) {\n        mDataSource = dataSource;\n        mView = view;\n\n        mLoadUserCallback = createLoadUserCallback();\n        mUpdateUserCallback = createUpdateUserCallback();\n    }",
        "human_comment": "Listens for users's actions from the UI {@link UserActivity}, retrieves the data and updates\nthe UI as required.",
        "model_generated_comment": "p>UserPresenter/p>. @param dataSource @code null @return a nullable userView."
    },
    {
        "id": 655,
        "code_snippet": "public void onCreate() {\n        super.onCreate();\n\n        mAppExecutors = new AppExecutors();\n    }",
        "human_comment": "Android Application class. Used for accessing singletons.",
        "model_generated_comment": "@link onCreate @param mAppExecutors/@link AppExecutors/> p>Only/p> if a new app is created, it will be able to create the new app. @return the app."
    },
    {
        "id": 656,
        "code_snippet": "public static <T> Predicate<Event> byPayload(Class<T> payloadType, Predicate<? super T> payloadPredicate) {\n\t\treturn event -> event.getPayload(payloadType).filter(payloadPredicate).isPresent();\n\t}",
        "human_comment": "Create a {@link Predicate} for {@linkplain Event events} whose payload\ntypes match the supplied {@code payloadType} and whose payloads match the\nsupplied {@code payloadPredicate}.\n\n@param payloadType the required payload type\n@param payloadPredicate a {@code Predicate} to match against payloads\n@return the resulting {@code Predicate}",
        "model_generated_comment": "@code payloadPredicate @param payloadType @return a predicate with a payload type of a given type of event."
    },
    {
        "id": 657,
        "code_snippet": "public static void assertNotEquals(float unexpected, float actual, float delta, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, delta, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal\nwithin the given {@code delta}.\n\n<p>Inequality imposed by this method is consistent with\n{@link Float#equals(Object)} and {@link Float#compare(float, float)}.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "p>Assert/p> that @code unexpected and /code actual are not equal."
    },
    {
        "id": 658,
        "code_snippet": "void testFormatRateThresholds() {\n        FileSizeFormat format = new FileSizeFormat();\n\n        MessageBuilder builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 45.0); // 45 B/s\n        assertEquals(\"45.0 B/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 15000.0); // 15 kB/s\n        assertEquals(\"15.0 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 5500.0); // 5.5 kB/s\n        assertEquals(\"5.5 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000.0); // 1 kB/s\n        assertEquals(\"1.0 kB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000000.0); // 1 MB/s\n        assertEquals(\"1.0 MB/s\", builder.build());\n\n        builder = new DefaultMessageBuilder();\n        format.formatRate(builder, 1000000000.0); // 1 GB/s\n        assertEquals(\"1.0 GB/s\", builder.build());\n    }",
        "human_comment": "Test value less than 0.05\nTest exact unit thresholds\nTest value greater than or equal to 10\nTest value between 0.05 and 10\nTest exact unit thresholds",
        "model_generated_comment": "Builds a new DefaultMessageBuilder with a @link FileSizeFormat format."
    },
    {
        "id": 659,
        "code_snippet": "public void runDT() {\n    int nPoints = 20;\n    double A = 2.0;\n    double B = -1.5;\n\n    JavaRDD<LabeledPoint> data = jsc.parallelize(\n      LogisticRegressionSuite.generateLogisticInputAsList(A, B, nPoints, 42), 2).cache();\n    Map<Integer, Integer> categoricalFeatures = new HashMap<>();\n    Dataset<Row> dataFrame = TreeTests.setMetadata(data, categoricalFeatures, 0);\n\n    DecisionTreeRegressor dt = new DecisionTreeRegressor()\n      .setMaxDepth(2)\n      .setMaxBins(10)\n      .setMinInstancesPerNode(5)\n      .setMinInfoGain(0.0)\n      .setMaxMemoryInMB(256)\n      .setCacheNodeIds(false)\n      .setCheckpointInterval(10)\n      .setMaxDepth(2); // duplicate setMaxDepth to check builder pattern\n    for (String impurity : DecisionTreeRegressor.supportedImpurities()) {\n      dt.setImpurity(impurity);\n    }\n    DecisionTreeRegressionModel model = dt.fit(dataFrame);\n\n    model.transform(dataFrame);\n    model.numNodes();\n    model.depth();\n    model.toDebugString();\n\n    /*\n    File tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"spark\");\n    String path = tempDir.toURI().toString();\n    try {\n      model2.save(sc.sc(), path);\n      DecisionTreeRegressionModel sameModel = DecisionTreeRegressionModel.load(sc.sc(), path);\n      TreeTests.checkEqual(model2, sameModel);\n    } finally {\n      Utils.deleteRecursively(tempDir);\n    }\n    */\n  }",
        "human_comment": "This tests setters. Training with various options is tested in Scala.\nTODO: Add test once save/load are implemented.   SPARK-6725",
        "model_generated_comment": "p>Utils.createTempDir/p> @link TreeTreeRegressionModel/PageDataFrame/Alt> if no data is available. @param nPoints = 20; npoints = -1.5; double B = -1."
    },
    {
        "id": 660,
        "code_snippet": "default Predicate<T> toPredicate() {\n\t\treturn object -> apply(object).included();\n\t}",
        "human_comment": "Return a {@link Predicate} that returns {@code true} if this filter\n<em>includes</em> the object supplied to the predicate's\n{@link Predicate#test test} method.",
        "model_generated_comment": "Returns a Predicate with a predicate. @param @code /code apredicate."
    },
    {
        "id": 661,
        "code_snippet": "void verbose_default() {\n\t\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\tTestExecutionListener listener = new VerboseTreePrintingListener(out, ColorPalette.DEFAULT, 16,\n\t\t\t\tTheme.ASCII);\n\n\t\t\tdemoTestRun(listener);\n\n\t\t\tassertDoesNotThrow(out::flush);\n\t\t}",
        "human_comment": "TODO Actually assert something in these \"demo\" tests and stop printing to SYSOUT.",
        "model_generated_comment": "@link VerboseTreePrintingListener/@link ColorPalette.DEFAULT/ @param Theme.ASCII p> /p>"
    },
    {
        "id": 662,
        "code_snippet": "private void validateOptionalProfiles(MavenSession session, ProfileActivation profileActivation) {\n        final Set<String> allAvailableProfiles = getAllProfiles(session);\n\n        final Set<String> optionalProfiles = new HashSet<>();\n        optionalProfiles.addAll(profileActivation.getOptionalActiveProfileIds());\n        optionalProfiles.addAll(profileActivation.getOptionalInactiveProfileIds());\n\n        final Set<String> notFoundOptionalProfiles = optionalProfiles.stream()\n                .filter(rap -> !allAvailableProfiles.contains(rap))\n                .collect(toSet());\n\n        if (!notFoundOptionalProfiles.isEmpty()) {\n            logger.info(\n                    \"The requested optional profiles {} could not be activated or deactivated because they do not\"\n                            + \" exist.\",\n                    notFoundOptionalProfiles);\n        }\n    }",
        "human_comment": "Check whether any of the requested optional profiles were not activated or deactivated.\n@param session the Maven session.\n@param profileActivation the requested optional and required profiles.",
        "model_generated_comment": "@link ProfileActivation @param session, profileActivation if the profile is active or deactivated."
    },
    {
        "id": 663,
        "code_snippet": "public static Condition<Event> result(Condition<TestExecutionResult> condition) {\n\t\treturn new Condition<>(byPayload(TestExecutionResult.class, condition::matches), \"event with result where %s\",\n\t\t\tcondition);\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if an\n{@link TestExecutionResult} that matches the supplied {@code Condition}.",
        "model_generated_comment": "@link TestExecutionResult @param %s if a condition is matched. @return a new static ConditionEvent with a result that matches a test execution result."
    },
    {
        "id": 664,
        "code_snippet": "public void setIntArraysColumn(java.util.List<java.util.List<java.lang.Integer>> value) {\n    this.int_arrays_column = value;\n  }",
        "human_comment": "Sets the value of the 'int_arrays_column' field.\n@param value the value to set.",
        "model_generated_comment": "Sets the value of the @link IntArraysColumn. @param java.lang.Integer> if the value is not set. @return the value if it is set."
    },
    {
        "id": 665,
        "code_snippet": "public int rfind(UTF8String str, int start) {\n    assert (str.numBytes > 0);\n    while (start >= 0) {\n      if (ByteArrayMethods.arrayEquals(base, offset + start, str.base, str.offset, str.numBytes)) {\n        return start;\n      }\n      start -= 1;\n    }\n    return -1;\n  }",
        "human_comment": "Find the `str` from right to left.",
        "model_generated_comment": "p>Assert/p> that @code str/code start is a UTF8String. @param start -0 - 0 = 0; @return -1 -= 0 if the start is 0 (or -1) if it is not 0 the start of the array is -1."
    },
    {
        "id": 666,
        "code_snippet": "public TestClassPredicates(DiscoveryIssueReporter issueReporter) {\n\t\tthis.isTestOrTestFactoryOrTestTemplateMethod = new IsTestMethod(issueReporter) //\n\t\t\t\t.or(new IsTestFactoryMethod(issueReporter)) //\n\t\t\t\t.or(new IsTestTemplateMethod(issueReporter));\n\t\tthis.isValidNestedTestClass = isNotPrivateUnlessAbstract(\"@Nested\", issueReporter) //\n\t\t\t\t.and(isInner(issueReporter));\n\t\tthis.isValidStandaloneTestClass = isNotPrivateUnlessAbstract(\"Test\", issueReporter) //\n\t\t\t\t.and(isNotLocal(issueReporter)) //\n\t\t\t\t.and(isNotInner(issueReporter)) // or should be annotated with @Nested!\n\t\t\t\t.and(isNotAnonymous(issueReporter));\n\t}",
        "human_comment": "Predicates for determining whether a class is a JUnit Jupiter test class.\n\n@since 5.13",
        "model_generated_comment": "@link IssueReporter @param issueReportER if a test is not available. @nested if no test is available."
    },
    {
        "id": 667,
        "code_snippet": "public void onSuccess(ByteBuffer response) {\n      BlockPushReturnCode pushResponse =\n        (BlockPushReturnCode) BlockTransferMessage.Decoder.fromByteBuffer(response);\n      ReturnCode returnCode = BlockPushNonFatalFailure.getReturnCode(pushResponse.returnCode);\n      if (returnCode != ReturnCode.SUCCESS) {\n        String blockId = pushResponse.failureBlockId;\n        Preconditions.checkArgument(!blockId.isEmpty());\n        checkAndFailRemainingBlocks(index, new BlockPushNonFatalFailure(returnCode,\n          BlockPushNonFatalFailure.getErrorMsg(blockId, returnCode)));\n      } else {\n        listener.onBlockPushSuccess(blockId, new NioManagedBuffer(ByteBuffer.allocate(0)));\n      }\n    }",
        "human_comment": "If the return code is not SUCCESS, the server has responded some error code. Handle\nthe error accordingly.\nOn receipt of a successful block push",
        "model_generated_comment": "@code BlockPushNonFatalFailure @param blockId blockReturnCode @returnCode if the block is empty."
    },
    {
        "id": 668,
        "code_snippet": "public void setStringToIntsColumn(java.util.Map<java.lang.String,java.util.List<java.lang.Integer>> value) {\n    this.string_to_ints_column = value;\n  }",
        "human_comment": "Sets the value of the 'string_to_ints_column' field.\n@param value the value to set.",
        "model_generated_comment": "Sets a java.lang.String to an ints-column. @param @code Integer/@code String ToStringToIntsColumn."
    },
    {
        "id": 669,
        "code_snippet": "public static void checkState(boolean expression) {\n    if (!expression) {\n      throw new IllegalStateException();\n    }\n  }",
        "human_comment": "Ensures the truth of an expression involving the state of the calling instance, but not\ninvolving any parameters to the calling method.\n\n@param expression a boolean expression\n@throws IllegalStateException if {@code expression} is false",
        "model_generated_comment": "@link IllegalStateException @param expression boolean expression."
    },
    {
        "id": 670,
        "code_snippet": "public WashingMachine(DelayProvider delayProvider) {\n    this.delayProvider = delayProvider;\n    this.washingMachineState = WashingMachineState.ENABLED;\n  }",
        "human_comment": "Creates a new instance of WashingMachine using provided delayProvider. This constructor is used\nonly for unit testing purposes.",
        "model_generated_comment": "@code delayProvider/@code washingMachineState. p>This method is used to provide a delay for a washing machine."
    },
    {
        "id": 671,
        "code_snippet": "public void onUserLoaded_updatesView() {\n        mPresenter.start();\n        verify(mUserRepository).getUser(mLoadUserCallbackArgumentCaptor.capture());\n\n        User user = new User(\"user name\");\n        mLoadUserCallbackArgumentCaptor.getValue().onUserLoaded(user);\n\n        verify(mView).showUserName(\"user name\");\n    }",
        "human_comment": "Given that start is called\nCallback is captured\nWhen the user is loaded\nThe view is updated with the correct user name",
        "model_generated_comment": "@link UserLoaded_updatesView @param user name the user name of the user. @return a new user if the user is not already a user."
    },
    {
        "id": 672,
        "code_snippet": "void shouldExecuteApplicationWithoutException() {\n\n    assertDoesNotThrow(() -> App.main(new String[] {}));\n}",
        "human_comment": "Issue: Add at least one assertion to this test case. Solution: Inserted assertion to check\nwhether the execution of the main method in {@link App#main(String[])} throws an exception.",
        "model_generated_comment": "p>Application with @code Exception should not be executed."
    },
    {
        "id": 673,
        "code_snippet": "public static XmlNode merge(XmlNode dominant, XmlNode recessive) {\n        return XmlService.merge(dominant, recessive);\n    }",
        "human_comment": "Merge two DOMs, with one having dominance in the case of collision. Merge mechanisms (vs. override for nodes, or\nvs. append for children) is determined by attributes of the dominant root node.\n\n@see XmlService#CHILDREN_COMBINATION_MODE_ATTRIBUTE\n@see XmlService#SELF_COMBINATION_MODE_ATTRIBUTE\n@param dominant The dominant DOM into which the recessive value/attributes/children will be merged\n@param recessive The recessive DOM, which will be merged into the dominant DOM\n@return merged DOM\n\n@deprecated use {@link XmlService#merge(XmlNode, XmlNode, Boolean)} instead",
        "model_generated_comment": "@link dominant XmlService.merge/@link recessive if node is dominant. @return a merge method to merge a node."
    },
    {
        "id": 674,
        "code_snippet": "public static void assertNotEquals(byte unexpected, Byte actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Byte) unexpected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4",
        "model_generated_comment": "Asserts that @code byte is equal. @param unexpected, actual, messageSupplier/@code messageEquals. @return a byte that is not equal."
    },
    {
        "id": 675,
        "code_snippet": "public static Tensor<Boolean> create(boolean data) {\n    return Tensor.create(data, Boolean.class);\n  }",
        "human_comment": "Creates a scalar tensor containing a single {@code boolean} element.\n\n@param data The value to put into the new scalar tensor.",
        "model_generated_comment": "Creates a static Tensor using @link Boolean. @param data boolean data a tensor. @return a new static TenSor."
    },
    {
        "id": 676,
        "code_snippet": "private void registerAfterEachMethodAdapters(ExtensionRegistrar registrar) {\n\t\tList<Method> afterEachMethods = new ArrayList<>(this.lifecycleMethods.afterEach);\n\n\t\tCollections.reverse(afterEachMethods);\n\n\t\tregisterMethodsAsExtensions(afterEachMethods, registrar, this::synthesizeAfterEachMethodAdapter);\n\t}",
        "human_comment": "Make a local copy since findAfterEachMethods() returns an immutable list.\nSince the bottom-up ordering of afterEachMethods will later be reversed when the\nsynthesized AfterEachMethodAdapters are executed within TestMethodTestDescriptor,\nwe have to reverse the afterEachMethods list to put them in top-down order before\nwe register them as synthesized extensions.",
        "model_generated_comment": "p>ExtensionRegistrar/p>AfterEachMethodAdapter/a> @link Extension registrar @param extension Registrar the extension of the extension."
    },
    {
        "id": 677,
        "code_snippet": "void beforeAllCallbackThrowsAnException() {\n\t\tassertBeforeAllAndAfterAllCallbacks(ExceptionInBeforeAllCallbackTestCase.class, 0, 0,\n\t\t\t\"fooBeforeAllCallback\",\n\t\t\t\"exceptionThrowingBeforeAllCallback\", // throws an exception.\n\t\t\t\"fooAfterAllCallback\"\n\t\t);\n\n\t\tassertThat(actualExceptionInAfterAllCallback).containsInstanceOf(EnigmaException.class);\n\t}",
        "human_comment": "@formatter:off\nbeforeAllMethod should not get invoked.\ntest should not get invoked.\nafterAllMethod should not get invoked.\n@formatter:on",
        "model_generated_comment": "p>An exception is thrown if @code enigma is not a valid test case. @param actualExceptionInAfterAllCallbackTestCase/p>"
    },
    {
        "id": 678,
        "code_snippet": "public void reset() {\n    updatePeakMemoryUsed();\n    numKeys = 0;\n    numValues = 0;\n    freeArray(longArray);\n    longArray = null;\n    while (dataPages.size() > 0) {\n      MemoryBlock dataPage = dataPages.removeLast();\n      freePage(dataPage);\n    }\n    allocate(initialCapacity);\n    canGrowArray = true;\n    currentPage = null;\n    pageCursor = 0;\n  }",
        "human_comment": "Reset this map to initialized state.",
        "model_generated_comment": "p>DataPages.removeLast()/p> if @code null if the dataPage isn't available."
    },
    {
        "id": 679,
        "code_snippet": "static WeaponFactory factory(Consumer<Builder> consumer) {\n    var map = new HashMap<WeaponType, Supplier<Weapon>>();\n    consumer.accept(map::put);\n    return name -> map.get(name).get();\n  }",
        "human_comment": "Creates an instance of the given type.\n\n@param name representing enum of an object type to be created.\n@return new instance of a requested class implementing {@link Weapon} interface.\n\n@param consumer for the new builder to the factory.\n@return factory with specified {@link Builder}s",
        "model_generated_comment": "Creates a new HashMap of a WeaponFactory."
    },
    {
        "id": 680,
        "code_snippet": "boolean detectByteBuffer(ByteBuffer imgData, int imageId) {\n    if (tflite == null) {\n      throw new RuntimeException(TAG + \": Detector has not been initialized; Failed.\");\n    }\n\n    Object[] inputArray = {imgData};\n    tflite.runForMultipleInputsOutputs(inputArray, outputMap);\n\n    Long latencyMilli = getLastNativeInferenceLatencyMilliseconds();\n    Long latencyNano = getLastNativeInferenceLatencyNanoseconds();\n\n    // Update the results.\n    result.resetTo(latencyMilli, latencyNano, imageId);\n    for (int i = 0; i < NUM_RESULTS; i++) {\n      // The model returns normalized coordinates [start_y, start_x, end_y, end_x].\n      // The boxes expect pixel coordinates [x1, y1, x2, y2].\n      // The height and width of the input are in inputDims[1] and inputDims[2].\n      // The following command converts between model outputs to bounding boxes.\n      result.addBox(\n          outputLocations[0][i][1] * inputDims[2],\n          outputLocations[0][i][0] * inputDims[1],\n          outputLocations[0][i][3] * inputDims[2],\n          outputLocations[0][i][2] * inputDims[1],\n          Math.round(outputClasses[0][i] + 1 /* Label offset */),\n          outputScores[0][i]);\n    }\n    return true;  // Marks that the result is available.\n  }",
        "human_comment": "The interface to run the detection. This method currently only support float mobilenet_ssd\nmodel. The quantized models will be added in the future.\n\n@param imgData The image buffer in ByteBuffer format.\n@return boolean indicator of whether detection was a success. If success, the detection results\nis available in the result member variable.\nSee OvicDetectionResult.java for details.",
        "model_generated_comment": "@link Detector/@link Failed to initialize the model. @param latencyMilliseconds the pixel coordinates of the input and output. @return true if the model has not been initialized."
    },
    {
        "id": 681,
        "code_snippet": "public String alignToBaseDirectory(String path, File basedir) {\n        String result = path;\n\n        if (path != null && basedir != null) {\n            path = path.replace('\\\\', File.separatorChar).replace('/', File.separatorChar);\n\n            File file = new File(path);\n            if (file.isAbsolute()) {\n                // path was already absolute, just normalize file separator and we're done\n                result = file.getPath();\n            } else if (file.getPath().startsWith(File.separator)) {\n                // drive-relative Windows path, don't align with project directory but with drive root\n                result = file.getAbsolutePath();\n            } else {\n                // an ordinary relative path, align with project directory\n                result = new File(new File(basedir, path).toURI().normalize()).getAbsolutePath();\n            }\n        }\n\n        return result;\n    }",
        "human_comment": "Resolves relative paths against a specific base directory.\n\n@deprecated use {@code org.apache.maven.api.services.ModelBuilder} instead",
        "model_generated_comment": "Returns a file-relative Windows path aligned with a project directory."
    },
    {
        "id": 682,
        "code_snippet": "protected TransportVehicle(String manufacturer, String model, int loadCapacity) {\n    super(manufacturer, model);\n    this.loadCapacity = loadCapacity;\n  }",
        "human_comment": "An abstract class that extends the Vehicle class and provides properties for the Transport type\nof Vehicles.\n\n@see Vehicle",
        "model_generated_comment": "TransportVehicle(String manufacturer, String model, int loadCapacity) @link Manufacturer/@link Load Capacity(Model, Manufacturer, Model, Model)/. @param manufacturer the model of the transport vehicle (model, manufacturer, model, model)"
    },
    {
        "id": 683,
        "code_snippet": "private static void closeAll(List<CloseablePath> paths) {\n\t\tvar throwableCollector = new OpenTest4JAwareThrowableCollector();\n\t\tpaths.forEach(closeablePath -> throwableCollector.execute(closeablePath::close));\n\t\tthrowableCollector.assertEmpty();\n\t}",
        "human_comment": "Close all but the first path\nClose last remaining path",
        "model_generated_comment": "@link CloseablePath/@link OpenTest4JAwareThrowableCollector. @param closeAll() if a path is closed. @return a jar file if the path is not closed."
    },
    {
        "id": 684,
        "code_snippet": "public void insertAndGetUser() {\n        mDatabase.userDao().insertUser(USER).blockingAwait();\n\n        mDatabase.userDao().getUser()\n                .test()\n                .assertValue(user -> {\n                    return user != null && user.getId().equals(USER.getId()) &&\n                            user.getUserName().equals(USER.getUserName());\n                });\n    }",
        "human_comment": "When inserting a new user in the data source\nWhen subscribing to the emissions of the user\nassertValue asserts that there was only one emission of the user\nThe emitted user is the expected one",
        "model_generated_comment": "p>Insert/p>UserDao/a> @code /code user."
    },
    {
        "id": 685,
        "code_snippet": "public UniqueId appendEngine(String engineId) {\n\t\treturn append(new Segment(ENGINE_SEGMENT_TYPE, engineId));\n\t}",
        "human_comment": "Construct a new {@code UniqueId} by appending a new {@link Segment}, based\n\n<p>This {@code UniqueId} will not be modified.\n\n<p>The engine ID will be stored in a {@link Segment} with\n{@link Segment#getType type} {@value #ENGINE_SEGMENT_TYPE}.\n\n@param engineId the engine ID; never {@code null} or blank\n\n@since 1.8",
        "model_generated_comment": "Appends a Segment with a unique ID."
    },
    {
        "id": 686,
        "code_snippet": "public void throwsTestTimedOutExceptionWithMeaningfulMessage() {\n        Exception e = assertThrows(\n                TestTimedOutException.class,\n                run(failAfter50Ms(new RunForASecond())));\n        assertEquals(\"test timed out after 50 milliseconds\", e.getMessage());\n    }",
        "human_comment": "test is successful when no exception is thrown",
        "model_generated_comment": "Throws a test timed out after 50 milliseconds."
    },
    {
        "id": 687,
        "code_snippet": "public void onResume() {\n    super.onResume();\n    startBackgroundThread();\n\n    if (textureView.isAvailable()) {\n      camera.startPreview();\n    } else {\n      textureView.setSurfaceTextureListener(surfaceTextureListener);\n    }\n  }",
        "human_comment": "When the screen is turned off and turned back on, the SurfaceTexture is already\navailable, and \"onSurfaceTextureAvailable\" will not be called. In that case, we can open\na camera and start preview from here (otherwise, we wait until the surface is ready in\nthe SurfaceTextureListener).",
        "model_generated_comment": "p>Assert/p> that @link textureView/@link surfaceTextureListener/. @param surfacetextureView.startBackgroundThread()/a>. @return a new texture view if it is not available."
    },
    {
        "id": 688,
        "code_snippet": "private void setVariable(final Double variable) {\n    model = new CalculatorModel(variable, model.getOutput());\n  }",
        "human_comment": "Set new calculator model variable.\n\n@param variable -> value of new calculator model variable.",
        "model_generated_comment": "Sets a model for a single variable. @param Double variable @code Double variable if the model is not set by the model."
    },
    {
        "id": 689,
        "code_snippet": "public UnknownRepositoryLayoutException(String repositoryId, String layoutId) {\n        super(\"Cannot find ArtifactRepositoryLayout instance for: \" + layoutId, repositoryId);\n        this.layoutId = layoutId;\n    }",
        "human_comment": "Exception which is meant to occur when a layout specified for a particular\nrepository doesn't have a corresponding {@link org.apache.maven.artifact.repository.layout.ArtifactRepositoryLayout}\ncomponent in the current container.",
        "model_generated_comment": "UnknownRepositoryLayoutException for @link ArtifactRepositoryId. @param repositoryId, layoutId LayoutId An instance of a repository."
    },
    {
        "id": 690,
        "code_snippet": "public void vectorIndexerAPI() {\n    List<FeatureData> points = Arrays.asList(\n      new FeatureData(Vectors.dense(0.0, -2.0)),\n      new FeatureData(Vectors.dense(1.0, 3.0)),\n      new FeatureData(Vectors.dense(1.0, 4.0))\n    );\n    Dataset<Row> data = spark.createDataFrame(jsc.parallelize(points, 2), FeatureData.class);\n    VectorIndexer indexer = new VectorIndexer()\n      .setInputCol(\"features\")\n      .setOutputCol(\"indexed\")\n      .setMaxCategories(2);\n    VectorIndexerModel model = indexer.fit(data);\n    Assertions.assertEquals(2, model.numFeatures());\n    Map<Integer, Map<Double, Integer>> categoryMaps = model.javaCategoryMaps();\n    Assertions.assertEquals(1, categoryMaps.size());\n    Dataset<Row> indexedData = model.transform(data);\n  }",
        "human_comment": "The tests are to check Java compatibility.",
        "model_generated_comment": "p>Assertions/p> @link VectorIndexerApi if a vector indexer is not available."
    },
    {
        "id": 691,
        "code_snippet": "private boolean acquireNewPage(long required) {\n    try {\n      currentPage = allocatePage(required);\n    } catch (SparkOutOfMemoryError e) {\n      return false;\n    }\n    dataPages.add(currentPage);\n    UnsafeAlignedOffset.putSize(currentPage.getBaseObject(), currentPage.getBaseOffset(), 0);\n    pageCursor = UnsafeAlignedOffset.getUaoSize();\n    return true;\n  }",
        "human_comment": "Acquire a new page from the memory manager.\n@return whether there is enough space to allocate the new page.",
        "model_generated_comment": "Returns a boolean containing a new page. @param length the length of the current page @code required. @return true if the new page is not allocated. @sparkOutOfMemoryError e is returned."
    },
    {
        "id": 692,
        "code_snippet": "public void tfIdfMinimumDocumentFrequency() {\n    HashingTF tf = new HashingTF();\n    JavaRDD<List<String>> documents = jsc.parallelize(Arrays.asList(\n      Arrays.asList(\"this is a sentence\".split(\" \")),\n      Arrays.asList(\"this is another sentence\".split(\" \")),\n      Arrays.asList(\"this is still a sentence\".split(\" \"))), 2);\n    JavaRDD<Vector> termFreqs = tf.transform(documents);\n    termFreqs.collect();\n    IDF idf = new IDF(2);\n    JavaRDD<Vector> tfIdfs = idf.fit(termFreqs).transform(termFreqs);\n    List<Vector> localTfIdfs = tfIdfs.collect();\n    int indexOfThis = tf.indexOf(\"this\");\n    for (Vector v : localTfIdfs) {\n      Assertions.assertEquals(0.0, v.apply(indexOfThis), 1e-15);\n    }\n  }",
        "human_comment": "The tests are to check Java compatibility.",
        "model_generated_comment": "p>Assertions/p> @code /code tfIdfMinimumDocumentFrequency is the minimum number of documents required for a given sentence."
    },
    {
        "id": 693,
        "code_snippet": "public static List<String> getModelsAfter2000(List<Car> cars) {\n    return cars.stream()\n        .filter(car -> car.year() > 2000)\n        .sorted(Comparator.comparing(Car::year))\n        .map(Car::model)\n        .toList();\n  }",
        "human_comment": "Method to get models using for collection pipeline.\n\n@param cars {@link List} of {@link Car} to be used for filtering\n@return {@link List} of {@link String} representing models built after year 2000",
        "model_generated_comment": "Returns a list of all the models after 2000. @param car -> car.year() > 2000."
    },
    {
        "id": 694,
        "code_snippet": "public T setMainClass(String mainClass) {\n    checkNotNull(mainClass, \"mainClass\");\n    builder.mainClass = mainClass;\n    return self();\n  }",
        "human_comment": "Sets the application class name for Java/Scala applications.\n\n@param mainClass Application's main class.\n@return This launcher.",
        "model_generated_comment": "@code mainClass if the main class is not null. @param mainClass, \"mainClass\" @return mainClass if it is null"
    },
    {
        "id": 695,
        "code_snippet": "private List<String> getProjects(Properties props) {\n        List<String> projects = new ArrayList<>();\n\n        for (Object o : props.keySet()) {\n            String key = o.toString();\n            if (key.startsWith(\"project.collectedProjects.\") && !key.endsWith(\".size\")) {\n                projects.add(props.getProperty(key));\n            }\n        }\n\n        Collections.sort(projects);\n\n        return projects;\n    }",
        "human_comment": "Verify that MavenProject.getCollectedProjects() provides access to the direct and indirect modules\nof the current project.\n\n@throws Exception in case of failure",
        "model_generated_comment": "p>Projects/p> @param props @code props /@codeprops. @return a list of props with a key set to a project."
    },
    {
        "id": 696,
        "code_snippet": "public Optional<Throwable> getError() {\n    return redirector != null ? Optional.ofNullable(redirector.getError()) : Optional.empty();\n  }",
        "human_comment": "Parses the logs of {@code spark-submit} and returns the last exception thrown.\n<p>\nSince {@link SparkLauncher} runs {@code spark-submit} in a sub-process, it's difficult to\naccurately retrieve the full {@link Throwable} from the {@code spark-submit} process.\nThis method parses the logs of the sub-process and provides a best-effort attempt at\nreturning the last exception thrown by the {@code spark-submit} process. Only the exception\nmessage is parsed, the associated stacktrace is meaningless.\n\n@return an {@link Optional} containing a {@link RuntimeException} with the parsed\nexception, otherwise returns a {@link Optional#EMPTY}",
        "model_generated_comment": "OptionalThrowable> getError()@code null @param null if the redirector is null."
    },
    {
        "id": 697,
        "code_snippet": "default void attachArtifact(@Nonnull Session session, @Nonnull Project project, @Nonnull Path path) {\n        String name = path.getFileName().toString();\n        int dot = name.lastIndexOf('.');\n        String ext = dot >= 1 ? name.substring(dot + 1) : \"\";\n        ProducedArtifact artifact = session.createProducedArtifact(\n                project.getGroupId(), project.getArtifactId(), project.getVersion(), ext);\n        attachArtifact(project, artifact, path);\n    }",
        "human_comment": "Attaches an artifact to the project using the given file path. The artifact type will be\ndetermined from the file extension. This method is thread-safe and ensures proper\nsynchronization of the project's artifact state.\n\n@param session the current build session\n@param project the project to attach the artifact to\n@param path the path to the artifact file",
        "model_generated_comment": "p>Assembles a @link Session/@link Path /p>. @param artifact a project a path a file a document a class a group a folder a directory a database a repository a system a server a process a method a client a program a web application a website a site a service a product a user a task a company a business a"
    },
    {
        "id": 698,
        "code_snippet": "public ModelResolverException(String message, String groupId, String artifactId, String version) {\n        super(message);\n        this.groupId = (groupId != null) ? groupId : \"\";\n        this.artifactId = (artifactId != null) ? artifactId : \"\";\n        this.version = (version != null) ? version : \"\";\n    }",
        "human_comment": "Creates a new exception with specified detail message.\n\n@param message The detail message, may be {@code null}.\n@param groupId The group id of the unresolvable model, may be {@code null}.\n@param artifactId The artifact id of the unresolvable model, may be {@code null}.\n@param version The version of the unresolvable model, may be {@code null}.",
        "model_generated_comment": "@link ModelResolverException (String message, String artifactId, String version) if a message is sent to a group, it will be thrown if the group is null."
    },
    {
        "id": 699,
        "code_snippet": "void testSuccessfulTaskWithCallback() {\n    assertTimeout(\n        ofMillis(3000),\n        () -> {\n          // Instantiate a new executor and start a new 'null' task ...\n          final var executor = new ThreadAsyncExecutor();\n\n          final var result = new Object();\n          when(task.call()).thenReturn(result);\n\n          final var asyncResult = executor.startProcess(task, callback);\n          assertNotNull(asyncResult);\n          asyncResult.await(); // Prevent timing issues, and wait until the result is available\n          assertTrue(asyncResult.isCompleted());\n\n          // Our task should only execute once ...\n          verify(task, times(1)).call();\n\n          // ... same for the callback, we expect our object\n          verify(callback, times(1)).onComplete(eq(result));\n          verify(callback, times(0)).onError(exceptionCaptor.capture());\n\n          // ... and the result should be exactly the same object\n          assertSame(result, asyncResult.getValue());\n        });\n  }",
        "human_comment": "Test used to verify the happy path of {@link ThreadAsyncExecutor#startProcess(Callable,\nAsyncCallback)}",
        "model_generated_comment": "AsyncExecutor.startProcessWithCallback() if the callback is 'null'."
    },
    {
        "id": 700,
        "code_snippet": "public static void mute(CheckedRunnable runnable) {\n    try {\n      runnable.run();\n    } catch (Exception e) {\n      throw new AssertionError(e);\n    }\n  }",
        "human_comment": "Executes the <code>runnable</code> and throws the exception occurred within a {@link\nAssertionError}. This method should be utilized to mute the operations that are guaranteed not\nto throw an exception. For instance {@link ByteArrayOutputStream#write(byte[])} declares in its\nsignature that it can throw an {@link IOException}, but in reality it cannot. This is because\nthe bulk write method is not overridden in {@link ByteArrayOutputStream}.\n\n@param runnable a runnable that should never throw an exception on execution.",
        "model_generated_comment": "@link Runnable @param runnable emi@code CheckedRunnable is a mute method."
    },
    {
        "id": 701,
        "code_snippet": "public synchronized boolean isAlive() {\n    return getHealth() > 0;\n  }",
        "human_comment": "Checks if the creature is still alive.\n\n@return true of creature is alive.",
        "model_generated_comment": "Returns a synchronized boolean isAlive() function. @param health() @link synchronize(). @return a value for the health of the object."
    },
    {
        "id": 702,
        "code_snippet": "public static Timeout millis(long millis) {\n        return new Timeout(millis, TimeUnit.MILLISECONDS);\n    }",
        "human_comment": "Creates a {@link Timeout} that will timeout a test after the\ngiven duration, in milliseconds.\n\n@since 4.12",
        "model_generated_comment": "Returns a timeout of milliseconds. @param millis the length of millis @link millis. @return a new timeout millis."
    },
    {
        "id": 703,
        "code_snippet": "public String getMethodName() {\n        return methodAndClassNamePatternGroupOrDefault(1, null);\n    }",
        "human_comment": "@return If this describes a method invocation,\nthe name of the method (or null if not)",
        "model_generated_comment": "Returns a @link MethodName class name. @param className the class name of the class. @return the method name of a class."
    },
    {
        "id": 704,
        "code_snippet": "public void standardScaler() {\n    List<VectorIndexerSuite.FeatureData> points = Arrays.asList(\n      new VectorIndexerSuite.FeatureData(Vectors.dense(0.0, -2.0)),\n      new VectorIndexerSuite.FeatureData(Vectors.dense(1.0, 3.0)),\n      new VectorIndexerSuite.FeatureData(Vectors.dense(1.0, 4.0))\n    );\n    Dataset<Row> dataFrame = spark.createDataFrame(jsc.parallelize(points, 2),\n      VectorIndexerSuite.FeatureData.class);\n    StandardScaler scaler = new StandardScaler()\n      .setInputCol(\"features\")\n      .setOutputCol(\"scaledFeatures\")\n      .setWithStd(true)\n      .setWithMean(false);\n\n    StandardScalerModel scalerModel = scaler.fit(dataFrame);\n\n    Dataset<Row> scaledData = scalerModel.transform(dataFrame);\n    scaledData.count();\n  }",
        "human_comment": "The tests are to check Java compatibility.\nCompute summary statistics by fitting the StandardScaler\nNormalize each feature to have unit standard deviation.",
        "model_generated_comment": "@link VectorIndexerSuite.FeatureData.class @param vectorIndexersuite.featuredata.class if a vector is a FeatureData, it will be scaled to the smallest possible size."
    },
    {
        "id": 705,
        "code_snippet": "public static void assertNotEquals(Short unexpected, short actual) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, (Short) actual);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n@since 5.4",
        "model_generated_comment": "Asserts that @code unexpected is not equal. @param unexpected, short actual are equal."
    },
    {
        "id": 706,
        "code_snippet": "public static UTF8String exec(final UTF8String v, final int collationId, boolean useICU) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType) {\n        return useICU ? execBinaryICU(v) : execBinary(v);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(v);\n      } else {\n        return execICU(v, collationId);\n      }\n    }",
        "human_comment": "Space trimming does not affect the output of this expression.",
        "model_generated_comment": "@link CollationFactory/@link UTF8String @param collationId boolean useICU @return if the collation is a UTF-8String v/a> if it is not a collation ICU, if not, it will not be able to be used."
    },
    {
        "id": 707,
        "code_snippet": "private LatencyCriteria tryLoadLatencyCriteria(String fileBasename) {\n    try {\n      return loadLatencyCriteria(fileBasename);\n    } catch (IOException e) {\n      Log.w(\n          TAG,\n          \"Failed to load the latency criteria of \"\n              + fileBasename\n              + \". Fallback to the default latency criteria.\");\n    }\n    return defaultLatencyCriteria;\n  }",
        "human_comment": "Tries to load the model-specific latency criteria file by the model name.\n\n<p>Returns the latency criteria for the specific model if the loading was successful.\nOtherwise, returns the default latency criteria.",
        "model_generated_comment": "p>Failed to load the latency criteria of fileBasename/p>."
    },
    {
        "id": 708,
        "code_snippet": "public static void main(String[] args) {\n\n    // Demonstrates the PropertiesFeatureToggleVersion running with properties\n    // that set the feature toggle to enabled.\n\n    final var properties = new Properties();\n    properties.put(\"enhancedWelcome\", true);\n    var service = new PropertiesFeatureToggleVersion(properties);\n    final var welcomeMessage = service.getWelcomeMessage(new User(\"Jamie No Code\"));\n    LOGGER.info(welcomeMessage);\n\n    // Demonstrates the PropertiesFeatureToggleVersion running with properties\n    // that set the feature toggle to disabled. Note the difference in the printed welcome message\n    // where the username is not included.\n\n    final var turnedOff = new Properties();\n    turnedOff.put(\"enhancedWelcome\", false);\n    var turnedOffService = new PropertiesFeatureToggleVersion(turnedOff);\n    final var welcomeMessageturnedOff =\n        turnedOffService.getWelcomeMessage(new User(\"Jamie No Code\"));\n    LOGGER.info(welcomeMessageturnedOff);\n\n    // Demonstrates the TieredFeatureToggleVersion setup with\n    // two users: one on the free tier and the other on the paid tier. When the\n    // Service#getWelcomeMessage(User) method is called with the paid user, the welcome\n    // message includes their username. In contrast, calling the same service with the free tier\n    // user results\n    // in a more generic welcome message without the username.\n\n    var service2 = new TieredFeatureToggleVersion();\n\n    final var paidUser = new User(\"Jamie Coder\");\n    final var freeUser = new User(\"Alan Defect\");\n\n    UserGroup.addUserToPaidGroup(paidUser);\n    UserGroup.addUserToFreeGroup(freeUser);\n\n    final var welcomeMessagePaidUser = service2.getWelcomeMessage(paidUser);\n    final var welcomeMessageFreeUser = service2.getWelcomeMessage(freeUser);\n    LOGGER.info(welcomeMessageFreeUser);\n    LOGGER.info(welcomeMessagePaidUser);\n  }",
        "human_comment": "Block 1 shows the {@link PropertiesFeatureToggleVersion} being run with {@link Properties}\nsetting the feature toggle to enabled.\n\n<p>Block 2 shows the {@link PropertiesFeatureToggleVersion} being run with {@link Properties}\nsetting the feature toggle to disabled. Notice the difference with the printed welcome message\nthe username is not included.\n\n<p>Block 3 shows the {@link\ncom.iluwatar.featuretoggle.pattern.tieredversion.TieredFeatureToggleVersion} being set up with\ntwo users on who is on the free level, while the other is on the paid level. When the {@link\nService#getWelcomeMessage(User)} is called with the paid {@link User} note that the welcome\nmessage contains their username, while the same service call with the free tier user is more\ngeneric. No username is printed.\n\n@see User\n@see UserGroup\n@see Service\n@see PropertiesFeatureToggleVersion\n@see com.iluwatar.featuretoggle.pattern.tieredversion.TieredFeatureToggleVersion",
        "model_generated_comment": "p>Demonstrates the TieredFeatureToggleVersion/p>."
    },
    {
        "id": 709,
        "code_snippet": "public String[] getSupportedProtocols() {\n        return new String[] {\"a\"};\n}",
        "human_comment": "Wagon for testing, for protocol <code>a</code>",
        "model_generated_comment": "em>Returns a string containing the @link SupportedProtocols. @return a new String[] if it is not already supported."
    },
    {
        "id": 710,
        "code_snippet": "public ThreadFactoryWithGarbageCleanup(String threadPoolName) {\n    namePrefix = threadPoolName;\n  }",
        "human_comment": "A ThreadFactory for constructing new HiveServer2 threads that lets you plug\nin custom cleanup code to be called before this thread is GC-ed.\nCurrently cleans up the following:\n1. ThreadLocal RawStore object:\nIn case of an embedded metastore, HiveServer2 threads (foreground and background)\nend up caching a ThreadLocal RawStore object. The ThreadLocal RawStore object has\nan instance of PersistenceManagerFactory and PersistenceManager.\nThe PersistenceManagerFactory keeps a cache of PersistenceManager objects,\nwhich are only removed when PersistenceManager#close method is called.\nHiveServer2 uses ExecutorService for managing thread pools for foreground and background threads.\nExecutorService unfortunately does not provide any hooks to be called,\nwhen a thread from the pool is terminated.\nAs a solution, we're using this ThreadFactory to keep a cache of RawStore objects per thread.\nAnd we are doing clean shutdown in the finalizer for each thread.",
        "model_generated_comment": "@link ThreadFactoryWithGarbageCleanup @param threadPoolName if a thread is a garbage container. @return a clean thread if it's a trash container."
    },
    {
        "id": 711,
        "code_snippet": "void assertDoesNotThrowWithMethodReferenceForNonVoidReturnType() {\n\t\tFutureTask<String> future = new FutureTask<>(() -> {\n\t\tfuture.run();\n\n\t\tString result;\n\n\t\t// Current compiler's type inference: does NOT compile since the compiler\n\t\t// cannot figure out which overloaded variant of assertDoesNotThrow() to\n\t\t// invoke (i.e., Executable vs. ThrowingSupplier).\n\t\t//\n\t\t// result = assertDoesNotThrow(future::get);\n\n\t\t// Explicitly as an Executable\n\t\tassertDoesNotThrow((Executable) future::get);\n\n\t\t// Explicitly as a ThrowingSupplier\n\t\tresult = assertDoesNotThrow((ThrowingSupplier<String>) future::get);\n\t\tassertEquals(\"foo\", result);\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithMethodReferenceForVoidReturnType() {\n\t\tvar foo = new Foo();\n\n\t\t// Note: the following does not compile since the compiler cannot properly\n\t\t// perform type inference for a method reference for an overloaded method\n\t\t// that has a void return type such as Foo.overloaded(...), IFF the\n\t\t// compiler is simultaneously trying to pick which overloaded variant\n\t\t// of assertDoesNotThrow() to invoke.\n\t\t//\n\t\t// assertDoesNotThrow(foo::overloaded);\n\n\t\t// Current compiler's type inference\n\t\tassertDoesNotThrow(foo::normalMethod);\n\n\t\t// Explicitly as an Executable\n\t\tassertDoesNotThrow(foo::normalMethod);\n\t\tassertDoesNotThrow((Executable) foo::overloaded);\n\t}\n\n\t// --- executable ----------------------------------------------------------\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithExecutable() {\n\t\tassertDoesNotThrow(nix);\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithExecutableAndMessage() {\n\t\tassertDoesNotThrow(nix, \"message\");\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithExecutableAndMessageSupplier() {\n\t\tassertDoesNotThrow(nix, () -> \"message\");\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsACheckedException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IOException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IOException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsACheckedExceptionWithMessage() {\n\t\tString message = \"Checked exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IOException(message);\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IOException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsARuntimeException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsARuntimeExceptionWithMessage() {\n\t\tString message = \"Runtime exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Unexpected exception thrown: \" + IllegalStateException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnError() {\n\t\ttry {\n\t\t\tassertDoesNotThrow(AssertionTestUtils::recurseIndefinitely);\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + StackOverflowError.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageString() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageWithMessageString() {\n\t\tString message = \"Runtime exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t}, \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Custom message ==> Unexpected exception thrown: \"\n\t\t\t\t\t+ IllegalStateException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageSupplier() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, () -> \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithExecutableThatThrowsAnExceptionWithMessageWithMessageSupplier() {\n\t\tString message = \"Runtime exception message\";\n\t\ttry {\n\t\t\tassertDoesNotThrow((Executable) () -> {\n\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t}, () -> \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Custom message ==> Unexpected exception thrown: \"\n\t\t\t\t\t+ IllegalStateException.class.getName() + \": \" + message);\n\t\t}\n\t}\n\n\t// --- supplier ------------------------------------------------------------\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithSupplier() {\n\t\tassertEquals(\"enigma\", assertDoesNotThrow(something));\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithSupplierAndMessage() {\n\t\tassertEquals(\"enigma\", assertDoesNotThrow(something, \"message\"));\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowAnythingWithSupplierAndMessageSupplier() {\n\t\tassertEquals(\"enigma\", assertDoesNotThrow(something, () -> \"message\"));\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsACheckedException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IOException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IOException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsARuntimeException() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsAnError() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new StackOverflowError();\n\t\t\t});\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex, \"Unexpected exception thrown: \" + StackOverflowError.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsAnExceptionWithMessageString() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t@Test\n\tvoid assertDoesNotThrowWithSupplierThatThrowsAnExceptionWithMessageSupplier() {\n\t\ttry {\n\t\t\tassertDoesNotThrow((ThrowingSupplier<?>) () -> {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}, () -> \"Custom message\");\n\t\t\texpectAssertionFailedError();\n\t\t}\n\t\tcatch (AssertionFailedError ex) {\n\t\t\tassertMessageEquals(ex,\n\t\t\t\t\"Custom message ==> Unexpected exception thrown: \" + IllegalStateException.class.getName());\n\t\t}\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\tprivate static class Foo {\n\n\t\tvoid normalMethod() {\n\t\t}\n\n\t\tvoid overloaded() {\n\t\t}\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tvoid overloaded(int i) {\n\t\t}\n\n\t}\n\n}",
        "human_comment": "Unit tests for JUnit Jupiter {@link Assertions}.\n\n@since 5.2",
        "model_generated_comment": "@link ThrowingSupplier/@link Executable vs. ThrowingReturnType does NOT compile since the compiler cannot perform type inference for an overloaded method reference for a non-void return type. @param \"foo::overloaded\" the compiler is trying to pick which overloaded variant of assertDoesNotThrow() to invoke."
    },
    {
        "id": 712,
        "code_snippet": "static String quoteForBatchScript(String arg) {\n\n    boolean needsQuotes = false;\n    for (int i = 0; i < arg.length(); i++) {\n      int c = arg.codePointAt(i);\n      if (Character.isWhitespace(c) || c == '\"' || c == '=' || c == ',' || c == ';') {\n        needsQuotes = true;\n        break;\n      }\n    }\n    if (!needsQuotes) {\n      return arg;\n    }\n    StringBuilder quoted = new StringBuilder();\n    quoted.append(\"\\\"\");\n    for (int i = 0; i < arg.length(); i++) {\n      int cp = arg.codePointAt(i);\n      switch (cp) {\n        case '\"' -> quoted.append('\"');\n        default -> {}\n      }\n      quoted.appendCodePoint(cp);\n    }\n    if (arg.codePointAt(arg.length() - 1) == '\\\\') {\n      quoted.append(\"\\\\\");\n    }\n    quoted.append(\"\\\"\");\n    return quoted.toString();\n  }",
        "human_comment": "Quote a command argument for a command to be run by a Windows batch script, if the argument\nneeds quoting. Arguments only seem to need quotes in batch scripts if they have certain\nspecial characters, some of which need extra (and different) escaping.\n\nFor example:\noriginal single argument: ab=\"cde fgh\"\nquoted: \"ab^=\"\"cde fgh\"\"\"",
        "model_generated_comment": "p>StringBuilder/p>Create a new StringBuilder with a @link CodePointAt value. @param 'character.isWhitespace' if i = '', i++@codepointAt()/codepoint if it is a copy of the code pointAt(i). @return a string with args containing a code point at the end of the string enumeration @code point @code"
    },
    {
        "id": 713,
        "code_snippet": "List<MojoExecution> getExecutions(MavenExecutionPlan mavenExecutionPlan) {\n        List<MojoExecution> result = new ArrayList<>();\n        for (ExecutionPlanItem executionPlanItem : mavenExecutionPlan) {\n            result.add(executionPlanItem.getMojoExecution());\n        }\n        return result;\n    }",
        "human_comment": "-----------------------------------------------------------------------------------------------\nTests which exercise the lifecycle executor when it is dealing with default lifecycle phases.\n-----------------------------------------------------------------------------------------------\nWe are doing something like \"mvn resources:resources\" where no version is specified but this\nproject we are working on has the version specified in the POM so the version should come from there.\nWe are doing something like \"mvn clean:clean\" where no version is specified but this\nproject we are working on has the version specified in the POM so the version should come from there.\nWe are doing something like \"mvn clean:clean\" where no version is specified but this\nproject we are working on has the version specified in the POM so the version should come from there.",
        "model_generated_comment": "@link ExecutionPlanItem/@link MavenExecutionPlan Item @param executionplanItem> p>Executions/p>"
    },
    {
        "id": 714,
        "code_snippet": "synchronized boolean initiateRetry(Throwable e) {\n    if (enableSaslRetries && e instanceof SaslTimeoutException) {\n      saslRetryCount += 1;\n    }\n    retryCount += 1;\n    currentListener = new RetryingBlockTransferListener();\n\n    logger.info(\"Retrying {} ({}/{}) for {} outstanding blocks after {} ms\",\n      MDC.of(LogKeys.TRANSFER_TYPE$.MODULE$, listener.getTransferType()),\n      MDC.of(LogKeys.NUM_RETRY$.MODULE$, retryCount),\n      MDC.of(LogKeys.MAX_ATTEMPTS$.MODULE$, maxRetries),\n      MDC.of(LogKeys.NUM_BLOCKS$.MODULE$, outstandingBlocksIds.size()),\n      MDC.of(LogKeys.RETRY_WAIT_TIME$.MODULE$, retryWaitTime));\n\n    try {\n      executorService.execute(() -> {\n        Uninterruptibles.sleepUninterruptibly(retryWaitTime, TimeUnit.MILLISECONDS);\n        transferAllOutstanding();\n      });\n    } catch (Throwable t) {\n      logger.error(\"Exception while trying to initiate retry\", t);\n      return false;\n    }\n\n    return true;\n  }",
        "human_comment": "Lightweight method which initiates a retry in a different thread. The retry will involve\ncalling transferAllOutstanding() after a configured wait time.\nReturns true if the retry was successfully initiated, false otherwise.",
        "model_generated_comment": "@code saslTimeoutException. @param timeoutException if a block is retrying after  ms."
    },
    {
        "id": 715,
        "code_snippet": "public int compare(final Size lhs, final Size rhs) {\n      // We cast here to ensure the multiplications won't overflow\n      return Long.signum(\n          (long) lhs.getWidth() * lhs.getHeight() - (long) rhs.getWidth() * rhs.getHeight());\n    }",
        "human_comment": "Compares two {@code Size}s based on their areas.",
        "model_generated_comment": "p>We cast this to ensure that the multiplications won't overflow. @param size lhs, final size rhs"
    },
    {
        "id": 716,
        "code_snippet": "public static void assertEquals(int expected, int actual) {\n        assertEquals(null, expected, actual);\n    }",
        "human_comment": "Asserts that two ints are equal.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 717,
        "code_snippet": "public void testFinalizationResultIsEmptyWhenTheServerDidNotReceiveAnyBlocks() {\n    MergeStatuses statuses = pushResolver.finalizeShuffleMerge(\n        new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 1, 0));\n    assertEquals(0, statuses.reduceIds.length, \"no partitions were merged\");\n    RemoteBlockPushResolver.AppShuffleInfo appShuffleInfo =\n        pushResolver.validateAndGetAppShuffleInfo(TEST_APP);\n    assertTrue(appShuffleInfo.getShuffles().get(1).isFinalized(),\n      \"shuffle 1 should be marked finalized\");\n    removeApplication(TEST_APP);\n  }",
        "human_comment": "For the previous merge id\nstream 2 now completes\nshuffle 1 0 is finalized even though the server didn't receive any blocks for it.",
        "model_generated_comment": "@link MergeStatuses if no partitions were merged."
    },
    {
        "id": 718,
        "code_snippet": "public boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\n        Activation activation = profile.getActivation();\n\n        if (activation == null) {\n            return false;\n        }\n\n        ActivationProperty property = activation.getProperty();\n\n        if (property == null) {\n            return false;\n        }\n\n        String name = property.getName();\n        boolean reverseName = false;\n\n        if (name != null && name.startsWith(\"!\")) {\n            reverseName = true;\n            name = name.substring(1);\n        }\n\n        if (name == null || name.isEmpty()) {\n            problems.add(\n                    BuilderProblem.Severity.ERROR,\n                    ModelProblem.Version.BASE,\n                    \"The property name is required to activate the profile \" + profile.getId(),\n                    property.getLocation(\"\"));\n            return false;\n        }\n\n        String sysValue = context.getUserProperty(name);\n        if (sysValue == null && \"packaging\".equals(name)) {\n            sysValue = context.getModelPackaging();\n        }\n        if (sysValue == null) {\n            sysValue = context.getSystemProperty(name);\n        }\n\n        String propValue = property.getValue();\n        if (propValue != null && !propValue.isEmpty()) {\n            boolean reverseValue = false;\n            if (propValue.startsWith(\"!\")) {\n                reverseValue = true;\n                propValue = propValue.substring(1);\n            }\n\n            // we have a value, so it has to match the system value...\n            return reverseValue != propValue.equals(sysValue);\n        } else {\n            return reverseName != (sysValue != null && !sysValue.isEmpty());\n        }\n    }",
        "human_comment": "Determines profile activation based on the existence or value of some execution property.\n\n@see ActivationProperty",
        "model_generated_comment": "@link ProfileActivationContext @param name The profile name is required to activate the profile. @return true if (activation = null &&!propValue.isEmpty()) the profile is activated."
    },
    {
        "id": 719,
        "code_snippet": "public static UTF8String fromBytes(byte[] bytes) {\n    if (bytes != null) {\n      return new UTF8String(bytes, BYTE_ARRAY_OFFSET, bytes.length);\n    } else {\n      return null;\n    }\n  }",
        "human_comment": "Creates an UTF8String from byte array, which should be encoded in UTF-8.\n\nNote: `bytes` will be hold by returned UTF8String.",
        "model_generated_comment": "Returns a UTF8String from a bytes array. @param bytes the number of bytes in the array."
    },
    {
        "id": 720,
        "code_snippet": "public Location lookup(Object keyBase, long keyOffset, int keyLength, int hash) {\n    safeLookup(keyBase, keyOffset, keyLength, loc, hash);\n    return loc;\n  }",
        "human_comment": "Looks up a key, and return a {@link Location} handle that can be used to test existence\nand read/write values.\n\nThis function always returns the same {@link Location} instance to avoid object allocation.\nThis function is not thread-safe.",
        "model_generated_comment": "@code keyBase/code keyLength. p>SecureLookup(keyBase, keyOffset, hash)/p>Also, if a location is not found, it will be returned."
    },
    {
        "id": 721,
        "code_snippet": "public static MethodSource from(String className, String methodName, String methodParameterTypes) {\n\t\treturn new MethodSource(className, methodName, methodParameterTypes);\n\t}",
        "human_comment": "Create a new {@code MethodSource} using the supplied class name, method\n@param methodName the method name; must not be {@code null} or blank\n@param methodParameterTypes a comma-separated list of fully qualified\nclass names representing the method parameter types",
        "model_generated_comment": "@link MethodSource @param className, String methodName, string methodParameterTypes @return a new methodSource from a class."
    },
    {
        "id": 722,
        "code_snippet": "public static Constant<Float> create(Scope scope, long[] shape, FloatBuffer data) {\n    try (Tensor<Float> value = Tensor.create(shape, data)) {\n      return createWithTensor(scope, value);\n    }\n  }",
        "human_comment": "Create a {@link DataType#FLOAT} constant with data from the given buffer.\n\n<p>Creates a constant with the given shape by copying elements from the buffer (starting from\nits current position) into the tensor. For example, if {@code shape = {2,3} } (which represents\na 2x3 matrix) then the buffer must have 6 elements remaining, which will be consumed by this\nmethod.\n\n@param scope is a scope used to add the underlying operation.\n@param shape the tensor shape.\n@param data a buffer containing the tensor data.\n@return a float constant\n@throws IllegalArgumentException If the tensor shape is not compatible with the buffer",
        "model_generated_comment": "Creates a new Tensor with a @link FloatBuffer value. @param shape scope a long[] shape a data float. @return a static ConstantFloat value a string containing the shape of the float, if the shape is longer than the value of the object, the data will be stored in the FloatingBuffer."
    },
    {
        "id": 723,
        "code_snippet": "protected String visitContains(String l, String r) {\n    String value = r.substring(1, r.length() - 1);\n    return l + \" LIKE '%\" + escapeSpecialCharsForLikePattern(value) + \"%' ESCAPE '\\\\'\";\n  }",
        "human_comment": "Remove quotes at the beginning and end.\ne.g. converts \"'str'\" to \"str\".",
        "model_generated_comment": "Returns a @link Substring. @param l a string containing a similar pattern. @return a substring with a value of '%'."
    },
    {
        "id": 724,
        "code_snippet": "public void afterProjectExecutionFailure(ProjectExecutionEvent projectExecutionEvent) {\n        MavenSession session = projectExecutionEvent.getSession();\n        boolean halted;\n        ReactorBuildStatus status =\n                (ReactorBuildStatus) session.getRepositorySession().getData().get(ReactorBuildStatus.class);\n        if (status != null) {\n            halted = status.isHalted();\n        } else {\n            Throwable t = projectExecutionEvent.getCause();\n            halted = (t instanceof RuntimeException || !(t instanceof Exception))\n                    || !MavenExecutionRequest.REACTOR_FAIL_NEVER.equals(session.getReactorFailureBehavior())\n                            && !MavenExecutionRequest.REACTOR_FAIL_AT_END.equals(session.getReactorFailureBehavior());\n        }\n        Throwable cause = projectExecutionEvent.getCause();\n        buildEventListener.executionFailure(\n                projectExecutionEvent.getProject().getArtifactId(), halted, cause != null ? cause.toString() : null);\n    }",
        "human_comment": "The ReactorBuildStatus is only available if the SmartBuilder is used\nassume sensible default",
        "model_generated_comment": "@link ProjectExecutionFailure @param halted a MavenSession instance of a ReactorBuilder."
    },
    {
        "id": 725,
        "code_snippet": "public static Condition<Event> test(String uniqueIdSubstring) {\n\t\treturn test(uniqueIdSubstring(uniqueIdSubstring));\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if an\na {@linkplain TestDescriptor#isTest() test} and its\n{@linkplain TestDescriptor#getUniqueId() unique id} contains the supplied\n{@link String}.\n\n@see #test()\n@see #uniqueIdSubstring(String)",
        "model_generated_comment": "@link UniqueIdSubstring/@link ConditionEvent @return a condition containing a unique Id Substring. @param uniqueSubstring is a string containing the unique id substring of a given event."
    },
    {
        "id": 726,
        "code_snippet": "public void setInterval(int ordinal, CalendarInterval value) {\n    assertIndexIsValid(ordinal);\n    long cursor = getLong(ordinal) >>> 32;\n    assert cursor > 0 : \"invalid cursor \" + cursor;\n    if (value == null) {\n      setNullAt(ordinal);\n      Platform.putLong(baseObject, baseOffset + cursor, 0L);\n      Platform.putLong(baseObject, baseOffset + cursor + 8, 0L);\n      Platform.putLong(baseObject, getFieldOffset(ordinal), (cursor << 32) | 16L);\n    } else {\n      long longVal =\n        ((long) value.months & 0xFFFFFFFFL) | (((long) value.days << 32) & 0xFFFFFFFF00000000L);\n      Platform.putLong(baseObject, baseOffset + cursor, longVal);\n      Platform.putLong(baseObject, baseOffset + cursor + 8, value.microseconds);\n      setLong(ordinal, (cursor << 32) | 16L);\n    }\n  }",
        "human_comment": "zero-out the bytes\nkeep the offset for future update",
        "model_generated_comment": "p>If the cursor is @code ordinal ordinal, the value is null. @param ordinal the value of the calendar interval."
    },
    {
        "id": 727,
        "code_snippet": "public static ReportEntry from(Map<String, String> keyValuePairs) {\n\t\tPreconditions.notNull(keyValuePairs, \"keyValuePairs must not be null\");\n\n\t\tReportEntry reportEntry = new ReportEntry();\n\t\tkeyValuePairs.forEach(reportEntry::add);\n\t\treturn reportEntry;\n\t}",
        "human_comment": "Factory for creating a new {@code ReportEntry} from a map of key-value pairs.\n{@code null} or blank",
        "model_generated_comment": "ReportEntry @code null. @param keyValuePairs the key value pairs of a report."
    },
    {
        "id": 728,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaMinHashLSHExample\")\n      .getOrCreate();\n\n    // $example on$\n    List<Row> dataA = Arrays.asList(\n      RowFactory.create(0, Vectors.sparse(6, new int[]{0, 1, 2}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(1, Vectors.sparse(6, new int[]{2, 3, 4}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(2, Vectors.sparse(6, new int[]{0, 2, 4}, new double[]{1.0, 1.0, 1.0}))\n      RowFactory.create(0, Vectors.sparse(6, new int[]{1, 3, 5}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(1, Vectors.sparse(6, new int[]{2, 3, 5}, new double[]{1.0, 1.0, 1.0})),\n      RowFactory.create(2, Vectors.sparse(6, new int[]{1, 2, 4}, new double[]{1.0, 1.0, 1.0}))\n    StructType schema = new StructType(new StructField[]{\n    Dataset<Row> dfA = spark.createDataFrame(dataA, schema);\n    Dataset<Row> dfB = spark.createDataFrame(dataB, schema);\n\n    int[] indices = {1, 3};\n    double[] values = {1.0, 1.0};\n    Vector key = Vectors.sparse(6, indices, values);\n\n    MinHashLSH mh = new MinHashLSH()\n      .setNumHashTables(5)\n      .setInputCol(\"features\")\n      .setOutputCol(\"hashes\");\n\n    MinHashLSHModel model = mh.fit(dfA);\n\n    // Feature Transformation\n    System.out.println(\"The hashed dataset where hashed values are stored in the column 'hashes':\");\n    model.transform(dfA).show();\n\n    // Compute the locality sensitive hashes for the input rows, then perform approximate\n    // similarity join.\n    // We could avoid computing hashes by passing in the already-transformed dataset, e.g.\n    // `model.approxSimilarityJoin(transformedA, transformedB, 0.6)`\n    System.out.println(\"Approximately joining dfA and dfB on Jaccard distance smaller than 0.6:\");\n    model.approxSimilarityJoin(dfA, dfB, 0.6, \"JaccardDistance\")\n      .select(col(\"datasetA.id\").alias(\"idA\"),\n        col(\"datasetB.id\").alias(\"idB\"),\n        col(\"JaccardDistance\")).show();\n\n    // Compute the locality sensitive hashes for the input rows, then perform approximate nearest\n    // neighbor search.\n    // We could avoid computing hashes by passing in the already-transformed dataset, e.g.\n    // `model.approxNearestNeighbors(transformedA, key, 2)`\n    // It may return less than 2 rows when not enough approximate near-neighbor candidates are\n    // found.\n    System.out.println(\"Approximately searching dfA for 2 nearest neighbors of the key:\");\n    model.approxNearestNeighbors(dfA, key, 2).show();\n    // $example off$\n\n    spark.stop();\n  }\n}",
        "human_comment": "An example demonstrating MinHashLSH.\nRun with:\nbin/run-example ml.JavaMinHashLSHExample",
        "model_generated_comment": "p>SparkSession/p> @link SparkFactory/a>. @param int indices 1, 2, 12 & 34. @return a.hashlshexample /. sparks.createDataFrame/spark.spark.create()/jshlshLSHLSH/hashLshLSHExa"
    },
    {
        "id": 729,
        "code_snippet": "protected MavenOptions parseMavenConfigOptions(Path configFile) {\n        try (Stream<String> lines = Files.lines(configFile, Charset.defaultCharset())) {\n            List<String> args =\n                    lines.filter(arg -> !arg.isEmpty() && !arg.startsWith(\"#\")).toList();\n            MavenOptions options = parseArgs(\"maven.config\", args);\n            if (options.goals().isPresent()) {\n                throw new IllegalArgumentException(\"Unrecognized entries in maven.config (\" + configFile + \") file: \"\n                        + options.goals().get());\n            }\n            return options;\n        } catch (ParseException e) {\n            throw new IllegalArgumentException(\n                    \"Failed to parse arguments from maven.config file (\" + configFile + \"): \" + e.getMessage(),\n                    e.getCause());\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Error reading config file: \" + configFile, e);\n        }\n    }",
        "human_comment": "This file can only contain options, not args (goals or phases)",
        "model_generated_comment": "@link MavenConfigOptions @param configFile @return a MavenOption to parse arguments from a maven.config file (e.g."
    },
    {
        "id": 730,
        "code_snippet": "public Builder enablePostDiscoveryFilterAutoRegistration(boolean enabled) {\n\t\t\tthis.postDiscoveryFilterAutoRegistrationEnabled = enabled;\n\t\t\treturn this;\n\t\t}",
        "human_comment": "Configure the auto-registration flag for post discovery filters.\n\n<p>Defaults to {@code true}.\n\n@param enabled {@code true} if post discovery filters should be automatically\nregistered\n@return this builder for method chaining\n@since 1.7",
        "model_generated_comment": "@link PostDiscoveryFilterAutoRegistration. @param enabled if the builder is enabled. @return this if it is enabled by default."
    },
    {
        "id": 731,
        "code_snippet": "public static Object[] data() {\n\t\treturn new Object[] { 1, 2, 3 };\n\n\tpublic JUnit4ParameterizedTestCase(int i) {\n\t}\n\n\t@Test\n\tpublic void test1() {\n\t\tfail(\"this test should fail\");\n\t}\n\n\t@Test\n\tpublic void endingIn_test1() {\n\t\tfail(\"this test should fail\");\n\t}\n\n\t@Test\n\tpublic void test1_atTheBeginning() {\n\t\tfail(\"this test should fail\");\n\t}\n\n\t@Test\n\tpublic void test2() {\n\t\t/* always succeeds */\n\t}\n\n}",
        "human_comment": "Test case used in {@link JUnit4ParameterizedTests}.\n\n@since 4.12",
        "model_generated_comment": "@Test JUnit4ParameterizedTestCase(int i) @link @return new Object[] @param i Object(s) if a test is a void. @test void test1_atTheBeginning()  @test test2() if the test is not void if it is void */*"
    },
    {
        "id": 732,
        "code_snippet": "byte[] childPrefix(Object value) {\n      Preconditions.checkState(parent == null, \"Not a parent index.\");\n      return buildKey(name, toParentKey(value));\n    }",
        "human_comment": "Creates a key prefix for child indices of this index. This allows the prefix to be\ncalculated only once, avoiding redundant work when multiple child indices of the\nsame parent index exist.",
        "model_generated_comment": "@code null if the parent index is not a parent index. @param value the value of the child index."
    },
    {
        "id": 733,
        "code_snippet": "public void composeUi(String path, Map<String, String> params) {\n    // Fetch data dynamically based on the route and parameters\n    String data = apiGateway.handleRequest(path, params);\n    LOGGER.info(\"Composed UI Component for path '\" + path + \"':\");\n    LOGGER.info(data);\n  }",
        "human_comment": "Composes the user interface dynamically by fetching data from different frontend components\nbased on provided parameters.\n\n@param path the route of the frontend component\n@param params a map of dynamic parameters to influence the data fetching",
        "model_generated_comment": "p>Fetch data dynamically based on the route and parameters @link Components. @param path the path and the params the data. @return a UI Component for the path if the path is not defined."
    },
    {
        "id": 734,
        "code_snippet": "public SparkLauncher redirectError(File errFile) {\n    errorStream = ProcessBuilder.Redirect.to(errFile);\n    return this;\n  }",
        "human_comment": "Redirects error output to the specified File.\n\n@param errFile The file to which stderr is written.\n@return This launcher.",
        "model_generated_comment": "Error @link SparkLauncher. @param errFile if a process is attempting to redirect a file."
    },
    {
        "id": 735,
        "code_snippet": "public boolean append(Object kbase, long koff, int klen, Object vbase, long voff, int vlen) {\n      assert (klen % 8 == 0);\n      assert (vlen % 8 == 0);\n      assert (longArray != null);\n\n      // We should not increase number of keys to be MAX_CAPACITY. The usage pattern of this map is\n      // lookup + append. If we append key until the number of keys to be MAX_CAPACITY, next time\n      // the call of lookup will hang forever because it cannot find an empty slot.\n      if (numKeys == MAX_CAPACITY - 1\n        // The map could be reused from last spill (because of no enough memory to grow),\n        // then we don't try to grow again if hit the `growthThreshold`.\n        || !canGrowArray && numKeys >= growthThreshold) {\n        return false;\n      }\n\n      // Here, we'll copy the data into our data pages. Because we only store a relative offset from\n      // the key address instead of storing the absolute address of the value, the key and value\n      // must be stored in the same memory page.\n      // (total length) (key length) (key) (value) (8 byte pointer to next value)\n      int uaoSize = UnsafeAlignedOffset.getUaoSize();\n      final long recordLength = (2L * uaoSize) + klen + vlen + 8;\n      if (currentPage == null || currentPage.size() - pageCursor < recordLength) {\n        if (!acquireNewPage(recordLength + uaoSize)) {\n          return false;\n        }\n      }\n\n      // --- Append the key and value data to the current data page --------------------------------\n      final Object base = currentPage.getBaseObject();\n      long offset = currentPage.getBaseOffset() + pageCursor;\n      final long recordOffset = offset;\n      UnsafeAlignedOffset.putSize(base, offset, klen + vlen + uaoSize);\n      UnsafeAlignedOffset.putSize(base, offset + uaoSize, klen);\n      offset += (2L * uaoSize);\n      Platform.copyMemory(kbase, koff, base, offset, klen);\n      offset += klen;\n      Platform.copyMemory(vbase, voff, base, offset, vlen);\n      offset += vlen;\n      // put this value at the beginning of the list\n      Platform.putLong(base, offset, isDefined ? longArray.get(pos * 2) : 0);\n\n      // --- Update bookkeeping data structures ----------------------------------------------------\n      offset = currentPage.getBaseOffset();\n      UnsafeAlignedOffset.putSize(base, offset, UnsafeAlignedOffset.getSize(base, offset) + 1);\n      pageCursor += recordLength;\n      final long storedKeyAddress = taskMemoryManager.encodePageNumberAndOffset(\n        currentPage, recordOffset);\n      longArray.set(pos * 2, storedKeyAddress);\n      updateAddressesAndSizes(storedKeyAddress);\n      numValues++;\n      if (!isDefined) {\n        numKeys++;\n        longArray.set(pos * 2 + 1, keyHashcode);\n        isDefined = true;\n\n        // If the map has reached its growth threshold, try to grow it.\n        if (numKeys >= growthThreshold) {\n          // We use two array entries per key, so the array size is twice the capacity.\n          // We should compare the current capacity of the array, instead of its size.\n          if (longArray.size() / 2 < MAX_CAPACITY) {\n            try {\n              growAndRehash();\n            } catch (SparkOutOfMemoryError oom) {\n              canGrowArray = false;\n            }\n          } else {\n            // The map is already at MAX_CAPACITY and cannot grow. Instead, we prevent it from\n            // accepting any more new elements to make sure we don't exceed the load factor. If we\n            // need to spill later, this allows UnsafeKVExternalSorter to reuse the array for\n            // sorting.\n            canGrowArray = false;\n          }\n        }\n      }\n      return true;\n    }",
        "human_comment": "Append a new value for the key. This method could be called multiple times for a given key.\nThe return value indicates whether the put succeeded or whether it failed because additional\nmemory could not be acquired.\n<p>\nIt is only valid to call this method immediately after calling `lookup()` using the same key.\n</p>\n<p>\nThe key and value must be word-aligned (that is, their sizes must be a multiple of 8).\n</p>\n<p>\nAfter calling this method, calls to `get[Key|Value]Address()` and `get[Key|Value]Length`\nwill return information on the data stored by this `append` call.\n</p>\n<p>\nAs an example usage, here's the proper way to store a new key:\n</p>\n<pre>\nLocation loc = map.lookup(keyBase, keyOffset, keyLength);\nif (!loc.isDefined()) {\nif (!loc.append(keyBase, keyOffset, keyLength, ...)) {\n// handle failure to grow map (by spilling, for example)\n}\n}\n</pre>\n<p>\nUnspecified behavior if the key is not defined.\n</p>\n\n@return true if the put() was successful and false if the put() failed because memory could\nnot be acquired.",
        "model_generated_comment": "if the key and value are not MAX_CAPACITY, the map will be reused from last spill (because of no enough memory to grow). @param uaoSize the current data page."
    },
    {
        "id": 736,
        "code_snippet": "public static String formatLocation(ModelProblem problem, String projectId) {\n        StringBuilder buffer = new StringBuilder(256);\n\n        if (!problem.getModelId().equals(projectId)) {\n            buffer.append(problem.getModelId());\n            if (!problem.getSource().isEmpty()) {\n                if (!buffer.isEmpty()) {\n                    buffer.append(\", \");\n                }\n                buffer.append(problem.getSource());\n            }\n        }\n\n        if (problem.getLineNumber() > 0) {\n            if (!buffer.isEmpty()) {\n                buffer.append(\", \");\n            }\n            buffer.append(\"line \").append(problem.getLineNumber());\n        }\n\n        if (problem.getColumnNumber() > 0) {\n            if (!buffer.isEmpty()) {\n                buffer.append(\", \");\n            }\n            buffer.append(\"column \").append(problem.getColumnNumber());\n        }\n\n        return buffer.toString();\n    }",
        "human_comment": "Creates a string with all location details for the specified model problem. If the project identifier is\nprovided, the generated location will omit the model id and source information and only give line/column\ninformation for problems originating directly from this POM.\n\n@param problem The problem whose location should be formatted, must not be {@code null}.\n@param projectId The {@code <groupId>:<artifactId>:<version>} of the corresponding project, may be {@code null}\nto force output of model id and source.\n@return The formatted problem location or an empty string if unknown, never {@code null}.",
        "model_generated_comment": "p>If @code modelProblem/@code projectId/code modelId> is empty, it will be discarded."
    },
    {
        "id": 737,
        "code_snippet": "public OrderService(Map<Integer, Product> cart) {\n    this.cart = cart;\n  }",
        "human_comment": "Instantiates a new Order service.\n\n@param cart the cart",
        "model_generated_comment": "@link Cart/@link OrderService(MapInteger, Product>)/."
    },
    {
        "id": 738,
        "code_snippet": "private long relativeOffset(int numFields) {\n    return 8 + numFields * 8L;\n  }",
        "human_comment": "Compute the relative offset of variable-length values.\nAll the UnsafeRows in this suite contains less than 64 columns, so the bitSetSize shall\nalways be 8.",
        "model_generated_comment": "Returns a long relative offset of @code numFields. @param numFelds the number of fields in the relative offset."
    },
    {
        "id": 739,
        "code_snippet": "while (nettyBufReadableBytes > 0 && !completed) {\n                    int readableBytes = Integer.min(\n                            nettyBufReadableBytes,\n                            ciphertextBuffer.remaining());\n                    int expectedRemaining = (int) (expectedLength - ciphertextRead);\n                    int bytesToRead = Integer.min(readableBytes, expectedRemaining);\n                    ciphertextBuffer.limit(ciphertextBuffer.position() + bytesToRead);\n                    ciphertextNettyBuf.readBytes(ciphertextBuffer);\n                    ciphertextRead += bytesToRead;\n                    if (ciphertextRead == expectedLength) {\n                        completed = true;\n                    } else if (ciphertextRead > expectedLength) {\n                        throw new IllegalStateException(\"Read more ciphertext than expected.\");\n                    }\n                    if (ciphertextBuffer.limit() == ciphertextBuffer.capacity() || completed) {\n                        ByteBuffer plaintextBuffer = ByteBuffer.allocate(plaintextSegmentSize);\n                        ciphertextBuffer.flip();\n                        decrypter.decryptSegment(\n                                ciphertextBuffer,\n                                segmentNumber,\n                                completed,\n                                plaintextBuffer);\n                        segmentNumber++;\n                        ciphertextBuffer.clear();\n                        plaintextBuffer.flip();\n                        ctx.fireChannelRead(Unpooled.wrappedBuffer(plaintextBuffer));\n                    } else {\n                        ciphertextBuffer.limit(ciphertextBuffer.capacity());\n                    }\n                    nettyBufReadableBytes = ciphertextNettyBuf.readableBytes();\n                }",
        "human_comment": "Read the ciphertext into the local buffer\nThe smallest ciphertext size is 16 bytes for the auth tag\nCheck if this is the last segment\nIf the ciphertext buffer is full, or this is the last segment,\nthen decrypt it and fire a read.\nClear the ciphertext buffer because it's been read\nSet the ciphertext buffer up to read the next chunk",
        "model_generated_comment": "@link ciphertextBuffer/@link UnpooledBufReadableBytes if a nettyBuf reads a bit more than expected. @param expectedLength /. @return if there is a bytes to read; if it is not, the bytes will be read."
    },
    {
        "id": 740,
        "code_snippet": "public Double finish(Average reduction) {\n      return ((double) reduction.getSum()) / reduction.getCount();\n    }",
        "human_comment": "Transform the output of the reduction",
        "model_generated_comment": "Returns the number of reductions to be done. @param reduction the reduction @code reduction."
    },
    {
        "id": 741,
        "code_snippet": "public T setRemote(String remote) {\n    checkNotNull(remote, \"remote\");\n    builder.remote = remote;\n    return self();\n  }",
        "human_comment": "Set the Spark master for the application.\n\n@param remote Spark remote url.\n@return This launcher.",
        "model_generated_comment": "Sets a remote object for @code remote. @param remote the remote object."
    },
    {
        "id": 742,
        "code_snippet": "private boolean isAlreadyRegistered(Class<? extends Extension> extensionType) {\n\t\treturn this.registeredExtensionTypes.contains(extensionType);\n\t}",
        "human_comment": "Determine if the supplied type is already registered in this registry or in a\nparent registry.",
        "model_generated_comment": "Returns a @link Extension that is already registered. @param extensionType the extension type. @return this.registeredExtensionTypes.contains the extensionType."
    },
    {
        "id": 743,
        "code_snippet": "public final int getElementsAppended() { return elementsAppended; }",
        "human_comment": "Returns the elements appended. This is useful",
        "model_generated_comment": "Returns a list of elements appended to a given element. @param elementsAppended() @code /code elementAppended. @return elements Appended if the element is appended."
    },
    {
        "id": 744,
        "code_snippet": "public String delayedServiceResponse() {\n    try {\n      return this.delayedService.attemptRequest();\n    } catch (RemoteServiceException e) {\n      return e.getMessage();\n    }\n  }",
        "human_comment": "Fetch response from the delayed service (with some simulated startup time).\n\n@return response string",
        "model_generated_comment": "p>Returns a delayed response from a remote service. @param delayedServiceResponse @link RemoteServiceException @return this.delayedService.attemptRequest/p>AttorneyServiceException if the request is delayed."
    },
    {
        "id": 745,
        "code_snippet": "public static void assertTimeoutPreemptively(Duration timeout, Executable executable) {\n\t\tAssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable);\n\t}",
        "human_comment": "<em>Assert</em> that execution of the supplied {@code executable}\ncompletes before the given {@code timeout} is exceeded.\n\n<p>See the {@linkplain Assertions Preemptive Timeouts} section of the\nclass-level Javadoc for further details.\n\n@see #assertTimeoutPreemptively(Duration, Executable, String)\n@see #assertTimeoutPreemptively(Duration, Executable, Supplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, String)\n@see #assertTimeoutPreemptively(Duration, ThrowingSupplier, Supplier)\n@see #assertTimeout(Duration, Executable)",
        "model_generated_comment": "p>Assert/p> that the @link Executable timeout is preemptive."
    },
    {
        "id": 746,
        "code_snippet": "public byte[] getBinary(int rowId) {\n    if (isNullAt(rowId)) return null;\n    if (dictionary == null) {\n      return arrayData().getBytes(getArrayOffset(rowId), getArrayLength(rowId));\n    } else {\n      return dictionary.decodeToBinary(dictionaryIds.getDictId(rowId));\n    }\n  }",
        "human_comment": "Gets the values of bytes from [rowId, rowId + count), as a UTF8String.\nThis method is similar to {@link ColumnVector#getBytes(int, int)}, but can save data copy as\nUTF8String is used as a pointer.",
        "model_generated_comment": "@code null if rowId is null. @return null if dictionaryIds are null; if null, return null and if not, null will be returned. @param row Id if a row has a null value."
    },
    {
        "id": 747,
        "code_snippet": "private int getUsableCapacity() {\n    return (int) (array.size() / (useRadixSort ? 2 : 1.5));\n  }",
        "human_comment": "Radix sort requires same amount of used memory as buffer, Tim sort requires\nhalf of the used memory as buffer.",
        "model_generated_comment": "Returns a @link array with the size of the array. If the array is larger than the array, the array will be larger."
    },
    {
        "id": 748,
        "code_snippet": "public UserRepository(AppExecutors appExecutors, UserDataSource userDataSource) {\n        mAppExecutors = appExecutors;\n        mUserDataSource = userDataSource;\n    }",
        "human_comment": "The repository is responsible of handling user data operations.",
        "model_generated_comment": "@link UserRepository userDataSource @param appExecutors mAppDataSource mUserDataSource appDataSource userDatasource @return a user repository containing the user data source if the user is executing the app."
    },
    {
        "id": 749,
        "code_snippet": "public void testTypedAggregationAverage() {\n    KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset();\n    Dataset<Tuple2<String, Double>> aggregated = grouped.agg(\n      org.apache.spark.sql.expressions.javalang.typed.avg(v -> (double)(v._2() * 2)));\n    Assertions.assertEquals(\n        Arrays.asList(new Tuple2<>(\"a\", 3.0), new Tuple2<>(\"b\", 6.0)),\n        aggregated.collectAsList());\n  }",
        "human_comment": "Suite that replicates tests in JavaDatasetAggregatorSuite using lambda syntax.",
        "model_generated_comment": "p>Assertions/p> @link Tuple2/@link Integer/PUTLE2String/a>. @param dataset avg = www.apache.spark.sql.expressions.javalang.typedAggregationAverage/href=\"https://github.com.au/spark/index.cfm#assemblyAgggregations/jsso.java#"
    },
    {
        "id": 750,
        "code_snippet": "public long toLongExact() {\n    LongWrapper result = new LongWrapper();\n    if (toLong(result, false)) {\n      return result.value;\n    }\n    throw new NumberFormatException(\"invalid input syntax for type numeric: '\" + this + \"'\");\n  }",
        "human_comment": "Parses UTF8String(trimmed if needed) to long. This method is used when ANSI is enabled.\n\n@return If string contains valid numeric value then it returns the long value otherwise a\nNumberFormatException  is thrown.",
        "model_generated_comment": "@link LongWrapper/@link NumericalFormatException. @param numeric the length of a long wrapper."
    },
    {
        "id": 751,
        "code_snippet": "public static Trigger ProcessingTime(long intervalMs) {\n      return ProcessingTimeTrigger.create(intervalMs, TimeUnit.MILLISECONDS);\n  }",
        "human_comment": "A trigger policy that runs a query periodically based on an interval in processing time.\nIf `interval` is 0, the query will run as fast as possible.\n\n@since 2.2.0",
        "model_generated_comment": "@link Trigger ProcessingTime @param intervalMs the length of the Trigger. @return a Trigger Trigger with a length of 1 milliseconds."
    },
    {
        "id": 752,
        "code_snippet": "default Optional<String> getVersion() {\n\t\tOptional<String> standalone = PackageUtils.getAttribute(getClass(), \"Engine-Version-\" + getId());\n\t\tif (standalone.isPresent()) {\n\t\t\treturn standalone;\n\t\t}\n\t\treturn Optional.of(PackageUtils.getModuleOrImplementationVersion(getClass()).orElse(\"DEVELOPMENT\"));\n\t}",
        "human_comment": "Get the version of this test engine.\n\n<p>This information is used solely for debugging and reporting purposes.\n\n<p>Initially, the default implementation tries to retrieve the engine\nversion from the manifest attribute named: {@code \"Engine-Version-\" + getId()}\n\n<p>Then the default implementation attempts to query the\n{@linkplain Package#getImplementationVersion() implementation version}\nfrom the package attributes for the {@link Package} in which the engine\nresides. Note that a package only has attributes if the information is\ndefined in the {@link java.util.jar.Manifest Manifest} of the JAR\ncontaining that package, and if the class loader created the\n{@link Package} instance with the attributes from the manifest.\n\n<p>If the implementation version cannot be queried from the package\nattributes, the default implementation returns {@code \"DEVELOPMENT\"}.\n\n<p>Concrete test engine implementations may override this method to\ndetermine the version by some other means.\n\n<p>implNote: Since JUnit Platform version 1.1 this default implementation\nhonors the \"raw version\" information stored in the module (modular jar\non the module-path) of this test engine.\n\n@return an {@code Optional} containing the version; never {@code null}\nbut potentially empty if the version is unknown\n@see Class#getPackage()\n@see Package#getImplementationVersion()\n@see #getGroupId()\n@see #getArtifactId()",
        "model_generated_comment": "OptionalString> getVersion() @link PackageUtils.getVersionVersion @param \"Engine-Version-\" + \"DevelopmentVersion\" @return a new version of the package."
    },
    {
        "id": 753,
        "code_snippet": "private void setCurrentNamePattern(OperationLog.LoggingLevel mode) {\n      if (mode == OperationLog.LoggingLevel.VERBOSE) {\n        this.namePattern = verboseExcludeNamePattern;\n      } else if (mode == OperationLog.LoggingLevel.EXECUTION) {\n        this.namePattern = executionIncludeNamePattern;\n      } else if (mode == OperationLog.LoggingLevel.PERFORMANCE) {\n        this.namePattern = performanceIncludeNamePattern;\n      }\n    }",
        "human_comment": "A log filter that filters messages coming from the logger with the given names.\nIt be used as a white list filter or a black list filter.\nWe apply black list filter on the Loggers used by the log diversion stuff, so that\nthey don't generate more logs for themselves when they process logs.\nWhite list filter is used for less verbose log collection",
        "model_generated_comment": "@link OperationLog.LoggingLevel mode. @param performanceIncludeNamePattern if (mode == VERBOSE mode) the name of the logged operation."
    },
    {
        "id": 754,
        "code_snippet": "public void remove(final Node node) {\n    if (node.previous != null) {\n      node.previous.next = node.next;\n    } else {\n      head = node.next;\n    }\n    if (node.next != null) {\n      node.next.previous = node.previous;\n    } else {\n      end = node.previous;\n    }\n  }",
        "human_comment": "Remove node from linked list.\n\n@param node {@link Node}",
        "model_generated_comment": "@link Node node @param node if node.previous is a node with a pre-existing node; if this is not the case, the node will be removed from the list of nodes."
    },
    {
        "id": 755,
        "code_snippet": "public Options setPrecisionLossAllowed(boolean precisionLossAllowed) {\n      this.precisionLossAllowed = precisionLossAllowed;\n      return this;\n    }",
        "human_comment": "Sets whether precision loss is allowed.\n\n@param precisionLossAllowed When `true` (default), the GPU may quantify tensors, downcast\nvalues, process in FP16. When `false`, computations are carried out in 32-bit floating\npoint.",
        "model_generated_comment": "p>PrecisionLossAllowed/p>. @return this if the value is @code boolean."
    },
    {
        "id": 756,
        "code_snippet": "public <T> AssumptionViolatedException(String message, T expected, Matcher<T> matcher) {\n        super(message, expected, matcher);\n    }",
        "human_comment": "An assumption exception with a message with the given <i>actual</i> value and a\n<i>matcher</i> describing the expectation that failed.",
        "model_generated_comment": "@link AssumptionViolatedException @param message, expected, matcher/@link Matcher @return a message if a matcher is expected/returns an expected matcher if it is not expected if the matcher does not exist."
    },
    {
        "id": 757,
        "code_snippet": "public static void assertNotEquals(Long unexpected, Long actual, String message) {\n\t\tAssertNotEquals.assertNotEquals(unexpected, actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>Fails with the supplied failure {@code message}.\n\n@since 5.4",
        "model_generated_comment": "p>Assert/p> that @code unexpected and /code actual are equal."
    },
    {
        "id": 758,
        "code_snippet": "private static void disableProgressBarAnimation(ProgressBar progressBar) {\n        progressBar.setIndeterminateDrawable(new ColorDrawable(Color.BLUE));\n    }",
        "human_comment": "necessary to run tests on older API levels where progress bar uses handler loop to animate.\n\n@param progressBar The progress bar whose animation will be swapped with a drawable",
        "model_generated_comment": "p>Assert/p> that @link ProgressBarAnimation is disabled."
    },
    {
        "id": 759,
        "code_snippet": "private List<Runner> runners(Class<?>[] children) {\n        List<Runner> runners = new ArrayList<Runner>();\n        for (Class<?> each : children) {\n            Runner childRunner = safeRunnerForClass(each);\n            if (childRunner != null) {\n                runners.add(childRunner);\n            }\n        }\n        return runners;\n    }",
        "human_comment": "Constructs and returns a list of Runners, one for each child class in\n{@code children}.  Care is taken to avoid infinite recursion:\nthis builder will throw an exception if it is requested for another\nrunner for {@code parent} before this call completes.",
        "model_generated_comment": "Returns a list of Runners for each Runner class. p>Also, if the Runner is a child of a Runner, it will return a new Runner for that Runner."
    },
    {
        "id": 760,
        "code_snippet": "default Optional<Version> getHighestVersion() {\n        return getVersions().isEmpty()\n                ? Optional.empty()\n                : Optional.of(getVersions().get(getVersions().size() - 1));\n    }",
        "human_comment": "Gets the highest version matching the requested range.\n\n@return An Optional containing the highest matching version, or empty Optional if no versions\nmatched the requested range",
        "model_generated_comment": "OptionalVersion> getVersions/a> @link Version. @param VersionVersion @return a version if the version is empty."
    },
    {
        "id": 761,
        "code_snippet": "public static List<Car> getSedanCarsOwnedSortedByDate(List<Person> persons) {\n    return persons.stream()\n        .map(Person::cars)\n        .flatMap(List::stream)\n        .filter(car -> Category.SEDAN.equals(car.category()))\n        .sorted(Comparator.comparing(Car::year))\n        .toList();\n  }",
        "human_comment": "Method to get all Sedan cars belonging to a group of persons sorted by year of manufacture.\n\n@param persons {@link List} of {@link Person} to be used\n@return {@link List} of {@link Car} to belonging to the group",
        "model_generated_comment": "p>List/p>SedanCarsOwnedSortedByDate>. @param car @code car/@code sedancars. @return a list of cars sorted by the date of the corresponding car if a car is a SedanCar."
    },
    {
        "id": 762,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaTokenizerExample\")\n      .getOrCreate();\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(0, \"Hi I heard about Spark\"),\n      RowFactory.create(1, \"I wish Java could use case classes\"),\n      RowFactory.create(2, \"Logistic,regression,models,are,neat\")\n    );\n\n    StructType schema = new StructType(new StructField[]{\n\n    Dataset<Row> sentenceDataFrame = spark.createDataFrame(data, schema);\n\n    Tokenizer tokenizer = new Tokenizer().setInputCol(\"sentence\").setOutputCol(\"words\");\n\n    RegexTokenizer regexTokenizer = new RegexTokenizer()\n        .setInputCol(\"sentence\")\n        .setOutputCol(\"words\")\n        .setPattern(\"\\\\W\");  // alternatively .setPattern(\"\\\\w+\").setGaps(false);\n\n    spark.udf().register(\n      \"countTokens\", (Seq<?> words) -> words.size(), DataTypes.IntegerType);\n\n    Dataset<Row> tokenized = tokenizer.transform(sentenceDataFrame);\n    tokenized.select(\"sentence\", \"words\")\n        .withColumn(\"tokens\", call_udf(\"countTokens\", col(\"words\")))\n        .show(false);\n\n    Dataset<Row> regexTokenized = regexTokenizer.transform(sentenceDataFrame);\n    regexTokenized.select(\"sentence\", \"words\")\n        .withColumn(\"tokens\", call_udf(\"countTokens\", col(\"words\")))\n        .show(false);\n\n    spark.stop();\n  }\n}",
        "human_comment": "$example on$\ncol(\"...\") is preferable to df.col(\"...\")\n$example off$\n$example on$\n$example off$",
        "model_generated_comment": "p>SparkSession/p>Assembles a @link TokenizerExample. @param sentenceDataFrame a row of data containing a Spark tokenizer. @return the tokenizer if it's not already there."
    },
    {
        "id": 763,
        "code_snippet": "public void error(String format, Object arg1, Object arg2) {\n        super.error(format, arg1, arg2);\n        logLevelRecorder.record(Level.ERROR);\n    }",
        "human_comment": "Perform double parameter substitution before logging the message of level\nERROR according to the format outlined above.",
        "model_generated_comment": "@link LevelRecorder/@link Error. @param format, arg1, arg2, Object arg2."
    },
    {
        "id": 764,
        "code_snippet": "public final void addElementsAppended(int num) {\n    elementsAppended += num;\n  }",
        "human_comment": "Increment number of elements appended by 'num'.\n\nThis is useful when one wants to use the 'putXXX' API to add new elements to the vector, but\nstill want to keep count of how many elements have been added (since the 'putXXX' APIs don't\nincrement count).",
        "model_generated_comment": "@link addElementsAppended. @param num element Appended /. @return a new element if it is not already appended."
    },
    {
        "id": 765,
        "code_snippet": "if (loggerName == null && (outputToLog || errorToLog)) {\n      String appName;\n      if (builder.appName != null) {\n        appName = builder.appName;\n      } else if (builder.mainClass != null) {\n        int dot = builder.mainClass.lastIndexOf(\".\");\n        if (dot >= 0 && dot < builder.mainClass.length() - 1) {\n          appName = builder.mainClass.substring(dot + 1, builder.mainClass.length());\n        } else {\n          appName = builder.mainClass;\n        }\n      } else if (builder.appResource != null) {\n        appName = new File(builder.appResource).getName();\n      } else {\n        appName = String.valueOf(COUNTER.incrementAndGet());\n      }\n      String loggerPrefix = getClass().getPackage().getName();\n      loggerName = String.format(\"%s.app.%s\", loggerPrefix, appName);\n    }",
        "human_comment": "Only setup stderr + stdout to logger redirection if user has not otherwise configured output\nredirection.",
        "model_generated_comment": "@link Builder.increment @param builder.appResource if the logger name is null &amp; errorToLog if it's null."
    },
    {
        "id": 766,
        "code_snippet": "private void updateUserName() {\n        String userName = mUserNameInput.getText().toString();\n        mUpdateButton.setEnabled(false);\n        mDisposable.add(mViewModel.updateUserName(userName)\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(() -> mUpdateButton.setEnabled(true),\n                        throwable -> Log.e(TAG, \"Unable to update username\", throwable)));\n    }",
        "human_comment": "Disable the update button until the user name update has been done\nSubscribe to updating the user name.\nRe-enable the button once the user name has been updated",
        "model_generated_comment": "p>Unable to update user name/p> mUpdateButton.setEnabled(false) if the update is not enabled."
    },
    {
        "id": 767,
        "code_snippet": "static Identifier of(String[] namespace, String name) {\n    return new IdentifierImpl(namespace, name);\n  }",
        "human_comment": "Identifies an object in a catalog.\n\n@since 3.0.0",
        "model_generated_comment": "Returns a new IdentifierImpl(namespace, namespace) if the namespace is @code namespace."
    },
    {
        "id": 768,
        "code_snippet": "public DefaultProfileActivationContext setActiveProfileIds(List<String> activeProfileIds) {\n        if (activeProfileIds != null) {\n            this.activeProfileIds = Collections.unmodifiableList(activeProfileIds);\n        } else {\n            this.activeProfileIds = Collections.emptyList();\n        }\n\n        return this;\n    }",
        "human_comment": "Sets the identifiers of those profiles that should be activated by explicit demand.\n\n@param activeProfileIds The identifiers of those profiles to activate, may be {@code null}.\n@return This context, never {@code null}.",
        "model_generated_comment": "@link ActiveProfileIds/@link DefaultProfileActivationContext. @param activeProfile Ids if a list of active profile ids exists. @return null if the list is empty."
    },
    {
        "id": 769,
        "code_snippet": "public List evaluate(Object o) {\n    return Collections.singletonList(\"data1\");\n  }",
        "human_comment": "UDF that returns a raw (non-parameterized) java List.",
        "model_generated_comment": "Returns a list of all the collections in a given list. @param @link Collections.singletonList."
    },
    {
        "id": 770,
        "code_snippet": "public static void main(String[] args) {\n    HiveConf.setLoadHiveServer2Config(true);\n    ServerOptionsProcessor oproc = new ServerOptionsProcessor(\"hiveserver2\");\n    ServerOptionsProcessorResponse oprocResponse = oproc.parse(args);\n\n    HiveStringUtils.startupShutdownMessage(HiveServer2.class, args, LOG.getSlf4jLogger());\n\n    oprocResponse.getServerOptionsExecutor().execute();\n  }",
        "human_comment": "Call the executor which will execute the appropriate command based on the parsed options",
        "model_generated_comment": "p>HiveServer2.class/p> @link ServerOptionsProcessor. @param hiveserver2.class oproc.getSlf4jLogger()."
    },
    {
        "id": 771,
        "code_snippet": "public void populateResult(InternalSession session, ArtifactDescriptorResult result, Model model) {\n        ArtifactTypeRegistry stereotypes = session.getSession().getArtifactTypeRegistry();\n\n        for (Repository r : model.getRepositories()) {\n            result.addRepository(session.toRepository(\n                    session.getService(RepositoryFactory.class).createRemote(r)));\n        }\n\n        for (org.apache.maven.api.model.Dependency dependency : model.getDependencies()) {\n            result.addDependency(convert(dependency, stereotypes));\n        }\n\n        DependencyManagement mgmt = model.getDependencyManagement();\n        if (mgmt != null) {\n            for (org.apache.maven.api.model.Dependency dependency : mgmt.getDependencies()) {\n                result.addManagedDependency(convert(dependency, stereotypes));\n            }\n        }\n\n        Map<String, Object> properties = new LinkedHashMap<>();\n\n        Prerequisites prerequisites = model.getPrerequisites();\n        if (prerequisites != null) {\n            properties.put(\"prerequisites.maven\", prerequisites.getMaven());\n        }\n\n        List<License> licenses = model.getLicenses();\n        properties.put(\"license.count\", licenses.size());\n        for (int i = 0; i < licenses.size(); i++) {\n            License license = licenses.get(i);\n            properties.put(\"license.\" + i + \".name\", license.getName());\n            properties.put(\"license.\" + i + \".url\", license.getUrl());\n            properties.put(\"license.\" + i + \".comments\", license.getComments());\n            properties.put(\"license.\" + i + \".distribution\", license.getDistribution());\n        }\n\n        result.setProperties(properties);\n\n        setArtifactProperties(result, model);\n    }",
        "human_comment": "Populates Aether {@link ArtifactDescriptorResult} from Maven project {@link Model}.\n<p>\n<strong>Note:</strong> This class is part of work in progress and can be changed or removed without notice.\n@since 3.2.4",
        "model_generated_comment": "p>Returns a LinkedHashMap/p> if @code null or if it's not null, it'll be returned a new Linked HashMap if there's no dependency. @param stereotypes if the dependency isn't null. @returns the dependency if no dependency exists."
    },
    {
        "id": 772,
        "code_snippet": "public void testNormalize3() {\n        IMoney ms1 = MoneyBag.create(new Money(12, \"CHF\"), new Money(3, \"USD\"));\n        Money expected = new Money(4, \"USD\");\n        assertEquals(expected, fMB1.subtract(ms1));\n    }",
        "human_comment": "{[12 CHF][7 USD]} - {[12 CHF][3 USD]} == [4 USD]",
        "model_generated_comment": "@link IMoney @param moneyBag.create(ms1) if the ms1 value is not a valid value."
    },
    {
        "id": 773,
        "code_snippet": "void shouldUseIdentityComparison() {\n        String key1 = new String(\"key\");\n        String key2 = new String(\"key\");\n\n        assertTrue(key1.equals(key2), \"Sanity check: keys should be equal\");\n        assertNotSame(key1, key2, \"Sanity check: keys should be distinct objects\");\n\n        AtomicInteger computeCount = new AtomicInteger(0);\n\n        map.computeIfAbsent(key1, k -> {\n            computeCount.incrementAndGet();\n            return \"value1\";\n        });\n\n        map.computeIfAbsent(key2, k -> {\n            computeCount.incrementAndGet();\n            return \"value2\";\n        });\n\n        assertEquals(1, computeCount.get(), \"Should compute once for equal but distinct keys\");\n    }",
        "human_comment": "Create two equal but distinct keys",
        "model_generated_comment": "@code key1 @param key1, key2, \"Sanity check: keys should be equal\" @return \"key1\" if a key is not equal, the value of the key should be the same."
    },
    {
        "id": 774,
        "code_snippet": "public DefaultProfileActivationContext setProjectDirectory(File projectDirectory) {\n        this.projectDirectory = projectDirectory;\n\n        return this;\n    }",
        "human_comment": "Sets the base directory of the current project.\n\n@param projectDirectory The base directory of the current project, may be {@code null} if profile activation\nhappens in the context of metadata retrieval rather than project building.\n@return This context, never {@code null}.",
        "model_generated_comment": "Sets the project directory of the project to be activated. @param projectDirectory @link DefaultProfileActivationContext."
    },
    {
        "id": 775,
        "code_snippet": "protected void failed(Throwable e, Description description) {\n    }",
        "human_comment": "Invoked when a test fails",
        "model_generated_comment": "@link /a> p>Analyzed if a e/e value is not found. @param description Description Description Description description Description description of a protected void failed."
    },
    {
        "id": 776,
        "code_snippet": "public UnsafeRow getAggregationBuffer(InternalRow groupingKey) {\n    final UnsafeRow unsafeGroupingKeyRow = this.groupingKeyProjection.apply(groupingKey);\n\n    return getAggregationBufferFromUnsafeRow(unsafeGroupingKeyRow);\n  }",
        "human_comment": "Return the aggregation buffer for the current group. For efficiency, all calls to this method\nreturn the same object. If additional memory could not be allocated, then this method will\nsignal an error by returning null.",
        "model_generated_comment": "Gets a grouping key from @link UnsafeRow."
    },
    {
        "id": 777,
        "code_snippet": "public static TestExecutionResult successful() {\n\t\treturn SUCCESSFUL_RESULT;\n\t}",
        "human_comment": "Create a {@code TestExecutionResult} for a <em>successful</em> execution\nof a test or container.\n\n@return the {@code TestExecutionResult}; never {@code null}",
        "model_generated_comment": "@link TestExecutionResult @return SUCCESSFUL_RESULT @param test execution result p>Successful_result/p>"
    },
    {
        "id": 778,
        "code_snippet": "void getWithTypeSafety() {\n\t\t\tInteger key = 42;\n\t\t\tString value = \"enigma\";\n\t\t\tstore.put(namespace, key, value);\n\n\t\t\tString requiredTypeValue = store.get(namespace, key, String.class);\n\t\t\tassertEquals(value, requiredTypeValue);\n\t\t}",
        "human_comment": "The fact that we can declare this as a String suffices for testing the required type.",
        "model_generated_comment": "p>Assert/p> that @code enigma is a valid type. @param namespace the namespace of the key, and the value of the class."
    },
    {
        "id": 779,
        "code_snippet": "public static void assertNotEquals(short unexpected, Short actual, Supplier<String> messageSupplier) {\n\t\tAssertNotEquals.assertNotEquals((Short) unexpected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are not equal.\n\n<p>If necessary, the failure message will be retrieved lazily from the\nsupplied {@code messageSupplier}.\n\n@since 5.4",
        "model_generated_comment": "Asserts that @link  are not equal. @param short unexpected, @short actual, messageSupplier."
    },
    {
        "id": 780,
        "code_snippet": "public synchronized void hit(int damage) {\n    if (damage < 0) {\n      throw new IllegalArgumentException(\"Damage cannot be a negative number\");\n    }\n    if (isAlive()) {\n      setHealth(getHealth() - damage);\n      if (!isAlive()) {\n        kill();\n      }\n    }\n  }",
        "human_comment": "When a creature gets hit it removed the amount of damage from the creature's life.\n\n@param damage as the damage that was taken.",
        "model_generated_comment": "p>If the damage is a negative number, the @link damage will be thrown. @param damage - 0 the damage cannot be a positive number."
    },
    {
        "id": 781,
        "code_snippet": "default Transform[] inferPartitioning(CaseInsensitiveStringMap options) {\n    return new Transform[0];\n  }",
        "human_comment": "Infer the partitioning of the table identified by the given options.\n<p>\nBy default this method returns empty partitioning, please override it if this source support\npartitioning.\n\n@param options an immutable case-insensitive string-to-string map that can identify a table,\ne.g. file path, Kafka topic name, etc.",
        "model_generated_comment": "Returns a new Transform. @param caseInsensitiveStringMap @link CaseInsensitiveStructureMap. @return a Transform with a case-insensitive StringMap if the case is insensitive."
    },
    {
        "id": 782,
        "code_snippet": "public Request complete(UUID uuid) {\n    Optional<Request> optReq = requestRepository.findById(uuid);\n    if (optReq.isEmpty()) {\n      throw new RequestNotFoundException(uuid);\n    }\n    return requestRepository.save(requestStateMachine.next(optReq.get(), Request.Status.COMPLETED));\n  }",
        "human_comment": "Complete the Request assigned with the given UUID.\n\n@param uuid The unique identifier for the Request.\n@return The completed Request.\n@throws RequestNotFoundException if a Request with the given UUID is not found.",
        "model_generated_comment": "@link Request NotFoundException @param UUID uuid if the request is not complete. @return a request that is incomplete if it is not found. @optionalRequestRepository.get() if there is a new request."
    },
    {
        "id": 783,
        "code_snippet": "public static UTF8String toTitleCaseICU(UTF8String source) {\n    // In the default UTF8String implementation, `toLowerCase` method implicitly does UTF8String\n    // validation (replacing invalid UTF-8 byte sequences with Unicode replacement character\n    // U+FFFD), but now we have to do the validation manually.\n    source = source.makeValid();\n\n    // Building the title cased source with 'sb'.\n    UTF8StringBuilder sb = new UTF8StringBuilder();\n\n    // 'isNewWord' is true if the current character is the beginning of a word, false otherwise.\n    boolean isNewWord = true;\n    // We are maintaining if the current character is preceded by a cased letter.\n    // This is used when lowercasing capital Greek letter sigma ('\u03a3'), to figure out if it should be\n    // lowercased into \u03c3 or \u03c2.\n    boolean precededByCasedLetter = false;\n\n    // 'offset' is a byte offset in source's byte array pointing to the beginning of the character\n    // that we need to process next.\n    int offset = 0;\n    int len = source.numBytes();\n\n    while (offset < len) {\n      // We will actually call 'codePointFrom()' 2 times for each character in the worst case (once\n      // here, and once in 'followedByCasedLetter'). Example of a string where we call it 2 times\n      // for almost every character is '\u03a3\u03a3\u03a3\u03a3\u03a3' (a string consisting only of Greek capital sigma)\n      // and '\u03a3`````' (a string consisting of a Greek capital sigma, followed by case-ignorable\n      // characters).\n      int codepoint = source.codePointFrom(offset);\n      // Appending the correctly cased character onto 'sb'.\n      appendTitleCasedCodepoint(sb, codepoint, isNewWord, precededByCasedLetter, source, offset);\n      // Updating 'isNewWord', 'precededByCasedLetter' and 'offset' to be ready for the next\n      // character that we will process.\n      isNewWord = (codepoint == SpecialCodePointConstants.ASCII_SPACE);\n      if (!UCharacter.hasBinaryProperty(codepoint, UProperty.CASE_IGNORABLE)) {\n        precededByCasedLetter = UCharacter.hasBinaryProperty(codepoint, UProperty.CASED);\n      }\n      offset += UTF8String.numBytesForFirstByte(source.getByte(offset));\n    }\n    return sb.build();\n  }",
        "human_comment": "Title-casing a string using ICU case mappings. Iterates over the string and title-cases\nthe first character in each word, and lowercases every other character. Handles lowercasing\ncapital Greek letter sigma ('\u03a3') separately, taking into account if it should be a small final\nGreek sigma ('\u03c2') or small non-final Greek sigma ('\u03c3'). Words are separated by ASCII\nspace(\\u0020).\n\n@param source UTF8String to be title cased\n@return title cased source",
        "model_generated_comment": "@param 'isNewWord' is the beginning of a word, and '' is a case-ignorable sigma followed by a @code byte offset' is an offset in the source's byte array pointing to the end of the character 'codePointFrom()' if the current character is preceded by /codepoint if it should be // lowercased into  or."
    },
    {
        "id": 784,
        "code_snippet": "private record RowRange(long start, long end) {\n  }",
        "human_comment": "Helper struct to represent a range of row indexes `[start, end]`.",
        "model_generated_comment": "RowRange(long start, long end) is a private record."
    },
    {
        "id": 785,
        "code_snippet": "public static void assertEquals(Long expected, long actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Long) actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "Asserts that the expected and actual values are equal. @param expected, long actual, messageSupplier"
    },
    {
        "id": 786,
        "code_snippet": "private static int numDimensions(Object o, DataType dtype) {\n    int ret = numArrayDimensions(o);\n    if (dtype == DataType.STRING && ret > 0) {\n      return ret - 1;\n    }\n    return ret;\n  }",
        "human_comment": "Return the number of dimensions of the tensor that object {@code o} represents as a tensor\nwhose datatype is {@code dtype}. Normally this is the same as the number of dimensions of o\nitself, but is one smaller for tensors of strings.\n\n@param o The object to inspect. It must be a valid representation of the given data type.\n@param dtype The expected data type of the tensor.",
        "model_generated_comment": "@link DataType.STRING @param oArrayDimensions @return ret if dtype is a DataType, if it is not a datatype, then retry if the datatype is the same as the corresponding datatype."
    },
    {
        "id": 787,
        "code_snippet": "public static String truncate(String s) {\n        if (fgMaxMessageLength != -1 && s.length() > fgMaxMessageLength) {\n            s = s.substring(0, fgMaxMessageLength) + \"...\";\n        }\n        return s;\n    }",
        "human_comment": "Truncates a String to the maximum length.",
        "model_generated_comment": "@link fgMaxMessageLength @param -1 && s.length() = -1. @return a truncated string containing a message length of 0 ms if the message length is greater than the length of the message."
    },
    {
        "id": 788,
        "code_snippet": "public static Shape make(long firstDimensionSize, long... otherDimensionSizes) {\n    long[] shape = new long[otherDimensionSizes.length + 1];\n    shape[0] = firstDimensionSize;\n    System.arraycopy(otherDimensionSizes, 0, shape, 1, otherDimensionSizes.length);\n    return new Shape(shape);\n  }",
        "human_comment": "Create a Shape representing an N-dimensional value.\n\n<p>Creates a Shape representing an N-dimensional value (N being at least 1), with the provided\nsize for each dimension. A -1 indicates that the size of the corresponding dimension is\nunknown. For example:\n\n<pre>{@code\n// A 2-element vector.\nShape vector = Shape.create(2);\n\n// A 2x3 matrix.\nShape matrix = Shape.create(2, 3);\n\n// A matrix with 4 columns but an unknown number of rows.\n// This is typically used to indicate the shape of tensors that represent\n// a variable-sized batch of values. The Shape below might represent a\n// variable-sized batch of 4-element vectors.\nShape batch = Shape.create(-1, 4);\n}</pre>",
        "model_generated_comment": "Returns a new shape for each dimension. @param firstDimensionSize the length of the first dimension."
    },
    {
        "id": 789,
        "code_snippet": "public int ioExceptionsThresholdDuringMerge() {\n    return conf.getInt(\"spark.shuffle.push.server.ioExceptionsThresholdDuringMerge\", 4);\n  }",
        "human_comment": "The threshold for number of IOExceptions while merging shuffle blocks to a shuffle partition.\nWhen the number of IOExceptions while writing to merged shuffle data/index/meta file exceed\nthis threshold then the shuffle server will respond back to client to stop pushing shuffle\nblocks for this shuffle partition.",
        "model_generated_comment": "p>Spark.shuffle.push.server.ioExceptionsThresholdDuringMerge/p>"
    },
    {
        "id": 790,
        "code_snippet": "static void registerExtensionsFromStaticFields(ExtensionRegistrar registrar, Class<?> clazz) {\n\t\tstreamExtensionRegisteringFields(clazz, ModifierSupport::isStatic) //\n\t\t\t\t.forEach(field -> {\n\t\t\t\t\tList<Class<? extends Extension>> extensionTypes = streamDeclarativeExtensionTypes(field).collect(\n\t\t\t\t\t\ttoList());\n\t\t\t\t\tboolean isExtendWithPresent = !extensionTypes.isEmpty();\n\n\t\t\t\t\tif (isExtendWithPresent) {\n\t\t\t\t\t\textensionTypes.forEach(registrar::registerExtension);\n\t\t\t\t\t}\n\t\t\t\t\tif (isAnnotated(field, RegisterExtension.class)) {\n\t\t\t\t\t\tExtension extension = readAndValidateExtensionFromField(field, null, extensionTypes);\n\t\t\t\t\t\tregistrar.registerExtension(extension, field);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}",
        "human_comment": "Register extensions using the supplied registrar from static fields in\nthe supplied class that are annotated with {@link ExtendWith @ExtendWith}\nor {@link RegisterExtension @RegisterExtension}.\n\n<p>The extensions will be sorted according to {@link Order @Order} semantics\nprior to registration.\n\n@param registrar the registrar with which to register the extensions; never {@code null}\n@param clazz the class or interface in which to find the fields; never {@code null}\n@since 5.11",
        "model_generated_comment": "@link ExtensionTypes @param field registrar Registrar/@link ModifierSupport::isStatic @returns a boolean registerExtensionTypes from a static field if the field is a registered extension, if it is not a valid extension, and if not, it will not be able to be retrieved. @code extensionTypes::registerExtensionsFromStatus/code>  @code class class class-class-extension-class"
    },
    {
        "id": 791,
        "code_snippet": "public void forkStarted(ExecutionEvent event) {\n        if (logger.isInfoEnabled()) {\n            init();\n            logger.info(\"\");\n\n            MessageBuilder buffer = builder().strong(\">>> \");\n            append(buffer, event.getMojoExecution());\n            buffer.strong(\" > \");\n            appendForkInfo(buffer, event.getMojoExecution().getMojoDescriptor());\n            append(buffer, event.getProject());\n            buffer.strong(\" >>>\");\n\n            logger.info(buffer.toString());\n        }\n    }",
        "human_comment": "<pre>&gt;&gt;&gt; mojo-artifactId:version:goal (mojo-executionId) &gt; :forked-goal @ project-artifactId &gt;&gt;&gt;</pre>\n<pre>&gt;&gt;&gt; mojo-artifactId:version:goal (mojo-executionId) &gt; [lifecycle]phase @ project-artifactId &gt;&gt;&gt;</pre>",
        "model_generated_comment": "p>ForkStarted/p> @link logger.infoEnabled a logger event. @param loggerExecutionEventEvent // if the event is enabled, the logger will be able to start a new instance of the event."
    },
    {
        "id": 792,
        "code_snippet": "public UnresolvableModelException(Throwable cause, String groupId, String artifactId, String version) {\n        super(cause);\n        this.groupId = groupId;\n        this.artifactId = artifactId;\n        this.version = version;\n    }",
        "human_comment": "Creates a new exception with specified cause\n\n@param cause\n@param groupId\n@param artifactId\n@param version",
        "model_generated_comment": "UnresolvableModelException is thrown when @code cause is returned. @param artifactId /code version is the version of the object."
    },
    {
        "id": 793,
        "code_snippet": "public static boolean isAssignableTo(Class<?> sourceType, Class<?> targetType) {\n\t\tPreconditions.notNull(sourceType, \"source type must not be null\");\n\t\tPreconditions.condition(!sourceType.isPrimitive(), \"source type must not be a primitive type\");\n\t\tPreconditions.notNull(targetType, \"target type must not be null\");\n\n\t\tif (targetType.isAssignableFrom(sourceType)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (targetType.isPrimitive()) {\n\t\t\treturn sourceType == primitiveToWrapperMap.get(targetType) || isWideningConversion(sourceType, targetType);\n\t\t}\n\n\t\treturn false;\n\t}",
        "human_comment": "Determine if an object of the supplied source type can be assigned to the\nsupplied target type for the purpose of reflective method invocations.\n\n<p>In contrast to {@link Class#isAssignableFrom(Class)}, this method\nreturns {@code true} if the target type represents a primitive type whose\nwrapper matches the supplied source type. In addition, this method also supports\n<a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2\">\nwidening conversions</a> for primitive target types.\n\n@param sourceType the non-primitive target type; never {@code null}\n@param targetType the target type; never {@code null}\n@return {@code true} if an object of the source type is assignment compatible\nwith the target type\n@since 1.8\n@see Class#isInstance(Object)\n@see Class#isAssignableFrom(Class)\n@see #isAssignableTo(Object, Class)",
        "model_generated_comment": "Returns a boolean @link TargetType. @param targetType a primitive type if the target type is not null."
    },
    {
        "id": 794,
        "code_snippet": "static final Migration MIGRATION_2_3 = new Migration(2, 3) {\n    };",
        "human_comment": "Migrate from:\nversion 2 - using Room\nto\nversion 3 - using Room where the {@link User} has an extra field: date",
        "model_generated_comment": "MIGRATION_2_3 = new Migration(2, 3)/a>."
    },
    {
        "id": 795,
        "code_snippet": "public static <T> CombinableBothMatcher<T> both(Matcher<? super T> matcher) {\n        return CoreMatchers.both(matcher);\n    }",
        "human_comment": "This is useful for fluently combining matchers that must both pass.  For example:\n<pre>\nassertThat(string, both(containsString(\"a\")).and(containsString(\"b\")));\n</pre>\n\n@deprecated Please use {@link CoreMatchers#both(Matcher)} instead.",
        "model_generated_comment": "@link Matchers/@link CombinableBothMatcher/! @param matcher a matcher for a matching matcher. @return the matcher that matches the two matchers."
    },
    {
        "id": 796,
        "code_snippet": "void setUp() {\n    parameterObject = ParameterObject.newBuilder().withType(\"sneakers\").build();\n\n    searchService = new SearchService();\n  }",
        "human_comment": "Creating parameter object with default values set",
        "model_generated_comment": "p>ParameterObject/p>. @param @code sneakers/code www>."
    },
    {
        "id": 797,
        "code_snippet": "public static void assertEquals(Double expected, double actual, Supplier<String> messageSupplier) {\n\t\tAssertEquals.assertEquals(expected, (Double) actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Equality imposed by this method is consistent with {@link Double#equals(Object)} and\n{@link Double#compare(double, double)}.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "Asserts that @link  are equal. @param expected, double actual, messageSupplier. @return the value that is equal to the expected value."
    },
    {
        "id": 798,
        "code_snippet": "void testCaseWithDeclaredInterruptCallbackThrowsException() {\n\t\tinterruptCallbackShallThrowException.set(true);\n\t\tEvents tests = executeTestsForClass(DefaultPreInterruptCallbackWithExplicitCallbackTestCase.class).testEvents();\n\t\ttests.failed().assertEventsMatchExactly(event(test(TC),\n\t\t\tfinishedWithFailure(instanceOf(TimeoutException.class), message(TIMEOUT_ERROR_MSG),\n\t\t\t\tsuppressed(0, instanceOf(InterruptedException.class)),\n\t\t\t\tsuppressed(1, instanceOf(IllegalStateException.class)))));\n\t\tassertTrue(interruptedTest.get());\n\t\tPreInterruptContext preInterruptContext = calledPreInterruptContext.get();\n\t\tassertNotNull(preInterruptContext);\n\t\tassertNotNull(preInterruptContext.getThreadToInterrupt());\n\t\tassertEquals(preInterruptContext.getThreadToInterrupt(), interruptedTestThread.get());\n\t}",
        "human_comment": "Wait until the real test thread was interrupted due to executor.shutdown(), otherwise the asserts below will be flaky.",
        "model_generated_comment": "@link InterruptCallbackThrowsException @param instanceOf(InterruptedException.class), suppressed(1, instanceOof(IllegalStateException).class)))); if the event is a test case, it will be a callback to the test case."
    },
    {
        "id": 799,
        "code_snippet": "private TreeNode<T> traverseOneLevelDown(T value) {\n    if (this.isGreaterThan(value)) {\n      return this.left;\n    }\n    return this.right;\n  }",
        "human_comment": "Returns left or right child of self based on a value that would be inserted; maintaining the\nintegrity of the BST.\n\n@param value The value of the TreeNode that would be inserted beneath self\n@return The child TreeNode of self which represents the subtree where `value` would be inserted",
        "model_generated_comment": "@link TreeNode @param value the value of the tree node if the value is greater than the value. @return the value if it's greater than a value."
    },
    {
        "id": 800,
        "code_snippet": "public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2) {\n        try {\n            ArtifactVersion version1 = node1.getArtifact().getSelectedVersion();\n            ArtifactVersion version2 = node2.getArtifact().getSelectedVersion();\n\n            return version1.compareTo(version2) > 0 ? node1 : node2;\n        } catch (OverConstrainedVersionException exception) {\n            // TODO log message or throw exception?\n\n            return null;\n        }\n    }",
        "human_comment": "Resolves conflicting artifacts by always selecting the <em>newest</em> declaration. Newest is defined as the\ndeclaration whose version is greater according to <code>ArtifactVersion.compareTo</code>.\n\n@see ArtifactVersion#compareTo\n@since 3.0",
        "model_generated_comment": "@link ResolutionNode/@link ArtifactVersionVersion version1 @param resolutionNode version2 if node1/www.resolutionnode.org/resolveConflict/#returns a new version of a resolution node."
    },
    {
        "id": 801,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaVectorSlicerExample\")\n      .getOrCreate();\n\n    Attribute[] attrs = {\n      NumericAttribute.defaultAttr().withName(\"f1\"),\n      NumericAttribute.defaultAttr().withName(\"f2\"),\n      NumericAttribute.defaultAttr().withName(\"f3\")\n    };\n    AttributeGroup group = new AttributeGroup(\"userFeatures\", attrs);\n\n    List<Row> data = Arrays.asList(\n      RowFactory.create(Vectors.sparse(3, new int[]{0, 1}, new double[]{-2.0, 2.3})),\n    vectorSlicer.setIndices(new int[]{1}).setNames(new String[]{\"f3\"});\n}",
        "human_comment": "$example on$\n$example off$\n$example on$\nor slicer.setIndices(new int[]{1, 2}), or slicer.setNames(new String[]{\"f2\", \"f3\"})",
        "model_generated_comment": "p>Assemble/p> a @code vectorSlicerExample if it's not already created."
    },
    {
        "id": 802,
        "code_snippet": "public static Credentials of(final String username, final String password) {\n      return new Credentials(username, password);\n   }",
        "human_comment": "Construct an immutable Credentials object with the supplied username and password.\n\n@param username the username\n@param password the password\n@return a new Credentials object",
        "model_generated_comment": "@link Username/@link Password @return the username and password of the user. @param username, password the password the user has entered to access the user's account."
    },
    {
        "id": 803,
        "code_snippet": "public BuildPlan buildInitialPlan(List<TaskSegment> taskSegments) {\n            int nThreads = Math.min(\n                    session.getRequest().getDegreeOfConcurrency(),\n                    session.getProjects().size());\n            boolean parallel = nThreads > 1;\n            session.setParallel(parallel);\n\n            ProjectDependencyGraph dependencyGraph = session.getProjectDependencyGraph();\n            MavenProject rootProject = session.getTopLevelProject();\n\n            Map<MavenProject, List<MavenProject>> allProjects = new LinkedHashMap<>();\n            dependencyGraph\n                    .getSortedProjects()\n                    .forEach(p -> allProjects.put(p, dependencyGraph.getUpstreamProjects(p, false)));\n\n            BuildPlan plan = new BuildPlan(allProjects);\n            for (TaskSegment taskSegment : taskSegments) {\n                Map<MavenProject, List<MavenProject>> projects = taskSegment.isAggregating()\n                        ? Collections.singletonMap(rootProject, allProjects.get(rootProject))\n                        : allProjects;\n\n                BuildPlan segment = calculateMojoExecutions(projects, taskSegment.getTasks());\n                plan.then(segment);\n            }\n\n            for (MavenProject project : plan.getAllProjects().keySet()) {\n                BuildStep pplan = new BuildStep(PLAN, project, null);\n                pplan.status.set(PLANNING); // the plan step always need planning\n                BuildStep setup = new BuildStep(SETUP, project, null);\n                BuildStep teardown = new BuildStep(TEARDOWN, project, null);\n                teardown.executeAfter(setup);\n                setup.executeAfter(pplan);\n                plan.steps(project).forEach(step -> {\n                    if (step.predecessors.stream().noneMatch(s -> s.project == project)) {\n                        step.executeAfter(setup);\n                    } else if (step.successors.stream().noneMatch(s -> s.project == project)) {\n                        teardown.executeAfter(step);\n                    }\n                });\n                Stream.of(pplan, setup, teardown).forEach(step -> plan.addStep(project, step.name, step));\n            }\n\n            return plan;\n        }",
        "human_comment": "Propagate the parallel flag to the root session\nCreate plan, setup and teardown",
        "model_generated_comment": "p>MavenProject/p> @param taskSegment if @code nthreads is a LinkedHashMap of a Maven project."
    },
    {
        "id": 804,
        "code_snippet": "public MojoExecutionException(Object source, String shortMessage, String longMessage) {\n        super(shortMessage);\n        this.source = source;\n        this.longMessage = longMessage;\n    }",
        "human_comment": "Construct a new <code>MojoExecutionException</code> exception providing the source and a short and long message:\nthese messages are used to improve the message written at the end of Maven build.\n\n@param source\n@param shortMessage\n@param longMessage",
        "model_generated_comment": "@link MojoExecutionException. @param shortMessage the source of the Exception."
    },
    {
        "id": 805,
        "code_snippet": "public static UTF8String exec(final UTF8String v, final int collationId, boolean useICU) {\n      CollationFactory.Collation collation = CollationFactory.fetchCollation(collationId);\n      if (collation.isUtf8BinaryType) {\n        return useICU ? execBinaryICU(v) : execBinary(v);\n      } else if (collation.isUtf8LcaseType) {\n        return execLowercase(v);\n      } else {\n        return execICU(v, collationId);\n      }\n    }",
        "human_comment": "Space trimming does not affect the output of this expression.",
        "model_generated_comment": "@link CollationFactory/@link UTF8String @param collationId boolean useICU @return if the collation is a UTF-8String v/a> if it is not a collation ICU, if not, it will not be able to be used."
    },
    {
        "id": 806,
        "code_snippet": "protected MemoryConsumer(TaskMemoryManager taskMemoryManager, long pageSize, MemoryMode mode) {\n    this.taskMemoryManager = taskMemoryManager;\n    this.pageSize = pageSize;\n    this.mode = mode;\n  }",
        "human_comment": "A memory consumer of {@link TaskMemoryManager} that supports spilling.\n\nNote: this only supports allocation / spilling of Tungsten memory.",
        "model_generated_comment": "p>TaskMemoryManager/p> @link MemoryConsumer. @param pageSize the page size of the memory manager."
    },
    {
        "id": 807,
        "code_snippet": "public static void main(String[] args) {\n    SparkSession spark = SparkSession\n      .builder()\n      .appName(\"JavaModelSelectionViaCrossValidationExample\")\n      .getOrCreate();\n\n    // $example on$\n    // Prepare training documents, which are labeled.\n    Dataset<Row> training = spark.createDataFrame(Arrays.asList(\n      new JavaLabeledDocument(0L, \"a b c d e spark\", 1.0),\n      new JavaLabeledDocument(1L, \"b d\", 0.0),\n      new JavaLabeledDocument(2L,\"spark f g h\", 1.0),\n      new JavaLabeledDocument(3L, \"hadoop mapreduce\", 0.0),\n      new JavaLabeledDocument(4L, \"b spark who\", 1.0),\n      new JavaLabeledDocument(5L, \"g d a y\", 0.0),\n      new JavaLabeledDocument(6L, \"spark fly\", 1.0),\n      new JavaLabeledDocument(7L, \"was mapreduce\", 0.0),\n      new JavaLabeledDocument(8L, \"e spark program\", 1.0),\n      new JavaLabeledDocument(9L, \"a e c l\", 0.0),\n      new JavaLabeledDocument(10L, \"spark compile\", 1.0),\n      new JavaLabeledDocument(11L, \"hadoop software\", 0.0)\n    ), JavaLabeledDocument.class);\n\n    // Configure an ML pipeline, which consists of three stages: tokenizer, hashingTF, and lr.\n    Tokenizer tokenizer = new Tokenizer()\n      .setInputCol(\"text\")\n      .setOutputCol(\"words\");\n    HashingTF hashingTF = new HashingTF()\n      .setNumFeatures(1000)\n      .setInputCol(tokenizer.getOutputCol())\n      .setOutputCol(\"features\");\n    LogisticRegression lr = new LogisticRegression()\n      .setMaxIter(10)\n      .setRegParam(0.01);\n    Pipeline pipeline = new Pipeline()\n      .setStages(new PipelineStage[] {tokenizer, hashingTF, lr});\n      .addGrid(hashingTF.numFeatures(), new int[] {10, 100, 1000})\n      .addGrid(lr.regParam(), new double[] {0.1, 0.01})\n    // $example off$\n\n    spark.stop();\n  }",
        "human_comment": "Java example for Model Selection via Cross Validation.",
        "model_generated_comment": "p>Assembles a @link SparkSession/p>JavaModelSelectionViaCrossValidationExample. @param \"javamodelselectionviacrossvalidations\" a JavaLabeledDocument, which is labeled."
    },
    {
        "id": 808,
        "code_snippet": "protected void write(StringBuilder buf, Throwable t) {\n        PrintStream targetStream = CONFIG_PARAMS.outputChoice.getTargetPrintStream();\n\n        synchronized (CONFIG_PARAMS) {\n            targetStream.println(buf.toString());\n            writeThrowable(t, targetStream);\n            targetStream.flush();\n        }\n    }",
        "human_comment": "To avoid intermingling of log messages and associated stack traces, the two\noperations are done in a synchronized block.\n\n@param buf   The StringBuilder containing the log message to be written\n@param t     The Throwable object whose stack trace should be written, may be null",
        "model_generated_comment": "@link PrintStream @param buf the target stream of a synchronized CONFIG_PARAMS. @return a print stream if it's not a target stream. @config_params.outputChoice.getTargetPrintStream()"
    },
    {
        "id": 809,
        "code_snippet": "public UserRepository(AppExecutors appExecutors, UserDataSource userDataSource) {\n        mAppExecutors = appExecutors;\n        mUserDataSource = userDataSource;\n    }",
        "human_comment": "The repository is responsible of handling user data operations.",
        "model_generated_comment": "@link UserRepository userDataSource @param appExecutors mAppDataSource mUserDataSource appDataSource userDatasource @return a user repository containing the user data source if the user is executing the app."
    },
    {
        "id": 810,
        "code_snippet": "public DefaultModelUrlNormalizer(UrlNormalizer urlNormalizer) {\n        this.urlNormalizer = urlNormalizer;\n    }",
        "human_comment": "Normalizes URLs to remove the ugly parent references \"../\" that got potentially inserted by URL adjustment during\nmodel inheritance.",
        "model_generated_comment": "DefaultModelUrlNormalizer for @link. @param urlNormalize the url of a model."
    },
    {
        "id": 811,
        "code_snippet": "public void onChannelReadEvent(AbstractNioChannel channel, Object readObject, SelectionKey key) {\n    executorService.execute(() -> channel.getHandler().handleChannelRead(channel, readObject, key));\n  }",
        "human_comment": "Submits the work of dispatching the read event to worker pool, where it gets picked up by\nworker threads. <br>\nNote that this is a non-blocking call and returns immediately. It is not guaranteed that the\nevent has been handled by associated handler.",
        "model_generated_comment": "Executes a @link onChannelRead event. @param Object readObject, SelectionKey key. @return a channel that reads an object from an object."
    },
    {
        "id": 812,
        "code_snippet": "public static SelectorResolutionResult resolved() {\n\t\treturn RESOLVED_RESULT;\n\t}",
        "human_comment": "Create a {@code SelectorResolutionResult} for a <em>resolved</em>\nselector.\n@return the {@code SelectorResolutionResult}; never {@code null}",
        "model_generated_comment": "Returns a @link SelectorResolutionResult. @param RESOLVED_RESULT."
    },
    {
        "id": 813,
        "code_snippet": "void executionsFromStartedTestEvents() {\n\t\tvar testEvents = getTestEvents();\n\n\t\tassertThat(testEvents.executions().started().count()).isEqualTo(3);\n\t\tassertThat(testEvents.started().executions().count()).isEqualTo(0);\n\t}",
        "human_comment": "We expect 3 if the executions are created BEFORE filtering out \"finished\" events.\nWe expect 0 if the executions are created AFTER filtering out \"finished\" events.",
        "model_generated_comment": "@code executionsFromStartedTestEvents @param testEvent() p>Assert/p> that the executions of a test event are equal to the number of executions from the start of the test event. @return the execution of this test event"
    },
    {
        "id": 814,
        "code_snippet": "public void collectLog(LogEntry logEntry) {\n    if (logEntry.getLevel() == null || minLogLevel == null) {\n      LOGGER.warn(\"Log level or threshold level is null. Skipping.\");\n      return;\n    }\n\n    if (logEntry.getLevel().compareTo(minLogLevel) < 0) {\n      LOGGER.debug(\"Log level below threshold. Skipping.\");\n      return;\n    }\n\n    buffer.offer(logEntry);\n\n    if (logCount.incrementAndGet() >= BUFFER_THRESHOLD) {\n      flushBuffer();\n    }\n  }",
        "human_comment": "Collects a given log entry, and filters it by the defined log level.\n\n@param logEntry The log entry to collect.",
        "model_generated_comment": "@link LogEntry @param minLogLevel == null. @return a null log level or threshold level if the level is below the threshold level."
    },
    {
        "id": 815,
        "code_snippet": "static Arguments toArguments(Object item) {\n\t\t// Nothing to do except cast.\n\t\tif (item instanceof Arguments) {\n\t\t\treturn (Arguments) item;\n\t\t}\n\n\t\t// Pass all multidimensional arrays \"as is\", in contrast to Object[].\n\t\t// See https://github.com/junit-team/junit5/issues/1665\n\t\tif (ReflectionUtils.isMultidimensionalArray(item)) {\n\t\t\treturn arguments(item);\n\t\t}\n\n\t\t// Special treatment for one-dimensional reference arrays.\n\t\t// See https://github.com/junit-team/junit5/issues/1665\n\t\tif (item instanceof Object[]) {\n\t\t\treturn arguments((Object[]) item);\n\t\t}\n\n\t\t// Pass everything else \"as is\".\n\t\treturn arguments(item);\n\t}",
        "human_comment": "Convert the supplied object into an {@link Arguments} instance.",
        "model_generated_comment": "p>Return @link ReferenceUtils if the object is a multidimensional reference array. @param object the object. @return the object object if it's a one-dimensional object /p>. @advanced https://github.com/junit5/issues/1665 // Pass all multidimensional arrays \"as is\""
    },
    {
        "id": 816,
        "code_snippet": "public record ShuffleIndexRecord(long offset, long length) {\n}",
        "human_comment": "Contains offset and length of the shuffle block data.",
        "model_generated_comment": "ShuffleIndexRecord(long offset, long length)/a> @link ShuffleIndexRecord (long offset)  @param offset Long offset Long length Long offset $code length \u00a3code length \u20accode length>/code width>@codelength> @return a long offset if the offset is longer than the length of the record."
    },
    {
        "id": 817,
        "code_snippet": "public boolean equals(Object other) {\n    if (other instanceof VariantVal o) {\n      return Arrays.equals(value, o.value) && Arrays.equals(metadata, o.metadata);\n    } else {\n      return false;\n    }\n  }",
        "human_comment": "Compare two variants in bytes. The variant equality is more complex than it, and we haven't\nsupported it in the user surface yet. This method is only intended for tests.",
        "model_generated_comment": "Returns a @link VariantVal o value. @param value the value of the variable."
    },
    {
        "id": 818,
        "code_snippet": "public ConditionParser(Map<String, ExpressionFunction> functions, UnaryOperator<String> propertyResolver) {\n        this.functions = functions;\n        this.propertyResolver = propertyResolver;\n    }",
        "human_comment": "Constructs a new {@code ConditionParser} with the given function mappings.\n@param propertyResolver the property resolver",
        "model_generated_comment": "UnaryOperatorString> propertyResolver for @link ExpressionFunction."
    },
    {
        "id": 819,
        "code_snippet": "default Set<? extends TestDescriptor> getDescendants() {\n\t\tSet<TestDescriptor> descendants = new LinkedHashSet<>();\n\t\tdescendants.addAll(getChildren());\n\t\tfor (TestDescriptor child : getChildren()) {\n\t\t\tdescendants.addAll(child.getDescendants());\n\t\t}\n\t\treturn Collections.unmodifiableSet(descendants);\n\t}",
        "human_comment": "Get the immutable set of all <em>descendants</em> of this descriptor.\n\n<p>A <em>descendant</em> is a child of this descriptor or a child of one of\nits children, recursively.\n\n@see #getChildren()",
        "model_generated_comment": "Sets the descendants of a LinkedHashSet."
    },
    {
        "id": 820,
        "code_snippet": "public void describeTo(Description description) {\n        if (fAssumption != null) {\n            description.appendText(fAssumption);\n        }\n\n        if (fValueMatcher) {\n            if (fAssumption != null) {\n                description.appendText(\": \");\n            }\n\n            description.appendText(\"got: \");\n            description.appendValue(fValue);\n\n            if (fMatcher != null) {\n                description.appendText(\", expected: \");\n                description.appendDescriptionOf(fMatcher);\n            }\n        }\n    }",
        "human_comment": "a value was passed in when this instance was constructed; print it",
        "model_generated_comment": "p>Assumption/p>Description of the @code description. @param fAssembly the description of a document."
    },
    {
        "id": 821,
        "code_snippet": "public boolean hasReachedMaxLevel() {\n        return maxReached.get().ordinal() > maxAllowed.ordinal();\n    }",
        "human_comment": "Responsible for keeping state of whether the threshold of the --fail-on-severity flag has been hit.",
        "model_generated_comment": "@link hasReachedMaxLevel. @return the boolean that has a re-ached maximum level. @param maxLevel is the maximum level that can be accessed by a user."
    },
    {
        "id": 822,
        "code_snippet": "public static Condition<Throwable> cause(Condition<Throwable>... conditions) {\n\t\tList<Condition<Throwable>> list = Arrays.stream(conditions)//\n\t\t\t\t.map(TestExecutionResultConditions::cause)//\n\t\t\t\t.collect(toList());\n\n\t\treturn Assertions.allOf(list);\n\t}",
        "human_comment": "Create a new {@link Condition} that matches if and only if a\nsupplied conditions.\n\n@see #rootCause(Condition...)\n@see #suppressed(int, Condition...)",
        "model_generated_comment": "@link TestExecutionResultConditions @param conditionThrowable @return Assertions.allOf(ListOf) if a condition is thrown, it will be returned if the condition is not found."
    },
    {
        "id": 823,
        "code_snippet": "public Executions finished() {\n\t\treturn new Executions(finishedExecutions(), this.category + \" Finished\");\n\t}",
        "human_comment": "Get the finished {@link Executions} contained in this {@code Executions} object.\n\n@return the filtered {@code Executions}; never {@code null}",
        "model_generated_comment": "Executes a new Execution from @link Executions. @param finishedExecutions(), this.category + \"Finished\""
    },
    {
        "id": 824,
        "code_snippet": "public ResolutionNode resolveConflict(ResolutionNode node1, ResolutionNode node2) {\n        return node1.getDepth() <= node2.getDepth() ? node1 : node2;\n    }",
        "human_comment": "Resolves conflicting artifacts by always selecting the <em>nearest</em> declaration. Nearest is defined as the\ndeclaration that has the least transitive steps away from the project being built.\n\n@since 3.0",
        "model_generated_comment": "@link ResolutionNode @return node1.getDepth() if node1 is a node."
    },
    {
        "id": 825,
        "code_snippet": "private static boolean checkCombineLines(String line) {\n            int bsCount = 0;\n            for (int idx = line.length() - 1; idx >= 0 && line.charAt(idx) == '\\\\'; idx--) {\n                bsCount++;\n            }\n\n            return bsCount % 2 != 0;\n        }",
        "human_comment": "Checks if the passed in line should be combined with the following.\nThis is true, if the line ends with an odd number of backslashes.\n\n@param line the line\n@return a flag if the lines should be combined",
        "model_generated_comment": "@code line @param line idx = 0 && line.length() - 1 p>If a line is a string, it should be a boolean string. @return a list of all the lines in the list."
    },
    {
        "id": 826,
        "code_snippet": "public long doRemoteFunction(int value) {\n\n    long waitTime = (long) Math.floor(randomProvider.random() * 1000);\n\n    try {\n      sleep(waitTime);\n    } catch (InterruptedException e) {\n      LOGGER.error(\"Thread sleep state interrupted\", e);\n      Thread.currentThread().interrupt();\n    }\n    return waitTime <= THRESHOLD\n        ? value * 10\n        : RemoteServiceStatus.FAILURE.getRemoteServiceStatusValue();\n  }",
        "human_comment": "Remote function takes a value and multiplies it by 10 taking a random amount of time. Will\nsometimes return -1. This imitates connectivity issues a client might have to account for.\n\n@param value integer value to be multiplied.\n@return if waitTime is less than {@link RemoteService#THRESHOLD}, it returns value * 10,\notherwise {@link RemoteServiceStatus#FAILURE}.",
        "model_generated_comment": "@link RemoteServiceStatus @param waitTime = (long) if a remote service is interrupted."
    },
    {
        "id": 827,
        "code_snippet": "public T setDeployMode(String mode) {\n    checkNotNull(mode, \"mode\");\n    builder.deployMode = mode;\n    return self();\n  }",
        "human_comment": "Set the deploy mode for the application.\n\n@param mode Deploy mode.\n@return This launcher.",
        "model_generated_comment": "Sets the mode of a deployment. @param mode the mode the deployment is in. @return the mode if the mode is not @code null."
    },
    {
        "id": 828,
        "code_snippet": "public static void assertArrayEquals(short[] expected, short[] actual, Supplier<String> messageSupplier) {\n\t\tAssertArrayEquals.assertArrayEquals(expected, actual, messageSupplier);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} short arrays are equal.\n<p>If both are {@code null}, they are considered equal.\n<p>If necessary, the failure message will be retrieved lazily from the supplied {@code messageSupplier}.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 829,
        "code_snippet": "byte[] toParentKey(Object value) {\n      return toKey(value, SECONDARY_IDX_PREFIX);\n    }",
        "human_comment": "Remove a value from the index.\n\n@param batch Write batch with other related changes.\n@param entity The entity being removed, to identify the index entry to modify.\n@param naturalKey The value's natural key (to avoid re-computing it for every index).\n@param prefix The parent index prefix, if this is a child index.",
        "model_generated_comment": "Returns the key of the parent key. @param value the value of the key."
    },
    {
        "id": 830,
        "code_snippet": "public Injector getInjector() {\n        if (injector == null) {\n            setupContainer();\n        }\n        return injector;\n    }",
        "human_comment": "Returns the DI injector, creating it if necessary.\n\n@return The configured injector instance",
        "model_generated_comment": "p>Injector/p>. @param injector @code null. @return injector the injector."
    },
    {
        "id": 831,
        "code_snippet": "public void setAspectRatio(int width, int height) {\n    if (width < 0 || height < 0) {\n      throw new IllegalArgumentException(\"Size cannot be negative.\");\n    }\n    mRatioWidth = width;\n    mRatioHeight = height;\n    requestLayout();\n  }",
        "human_comment": "Sets the aspect ratio for this view. The size of the view will be measured based on the ratio\ncalculated from the parameters. Note that the actual sizes of parameters don't matter, that is,\ncalling setAspectRatio(2, 3) and setAspectRatio(4, 6) make the same result.\n\n@param width Relative horizontal size\n@param height Relative vertical size",
        "model_generated_comment": "p>AspectRatio/p>Size cannot be negative."
    },
    {
        "id": 832,
        "code_snippet": "public static FileSource from(File file) {\n\t\treturn new FileSource(file);\n\t}",
        "human_comment": "Create a new {@code FileSource} using the supplied {@link File file}.",
        "model_generated_comment": "Returns a file source from @link FileSource."
    },
    {
        "id": 833,
        "code_snippet": "private SetProperty(String property, String value) {\n      this.property = property;\n      this.value = value;\n    }",
        "human_comment": "A NamespaceChange to set a namespace property.\n<p>\nIf the property already exists, it must be replaced with the new value.",
        "model_generated_comment": "Sets the property of a property. @param property the value of the property."
    },
    {
        "id": 834,
        "code_snippet": "public static <T> T assertInstanceOf(Class<T> expectedType, Object actualValue) {\n\t\treturn AssertInstanceOf.assertInstanceOf(expectedType, actualValue);\n\t}",
        "human_comment": "<em>Assert</em> that the supplied {@code actualValue} is an instance of the\n{@code expectedType}.\n\n<p>Like the {@code instanceof} operator a {@code null} value is not\nconsidered to be of the {@code expectedType} and does not pass the assertion.\n\n@since 5.8",
        "model_generated_comment": "Asserts that @code expectedType is the expected type of the instance. @param expectedType, actualValue the actual value of the object. @return a static instance of a class."
    },
    {
        "id": 835,
        "code_snippet": "void testHandleExceptionLoopInCause() {\n        AtomicReference<Throwable> causeRef = new AtomicReference<>(null);\n        Exception cause2 = new RuntimeException(\"loop\") {\n        };\n        causeRef.set(cause2);\n\n        Plugin plugin = new Plugin();\n        Exception cause = new PluginContainerException(plugin, null, null, cause2);\n        cause2.initCause(cause);\n        PluginDescriptor pluginDescriptor = new PluginDescriptor();\n        MojoDescriptor mojoDescriptor = new MojoDescriptor();\n        mojoDescriptor.setPluginDescriptor(pluginDescriptor);\n        MojoExecution mojoExecution = new MojoExecution(mojoDescriptor);\n        Throwable exception = new PluginExecutionException(mojoExecution, null, cause);\n\n        DefaultExceptionHandler handler = new DefaultExceptionHandler();\n        ExceptionSummary summary = handler.handleException(exception);\n\n        String expectedReference = \"http://cwiki.apache.org/confluence/display/MAVEN/PluginContainerException\";\n        assertEquals(expectedReference, summary.getReference());\n    }",
        "human_comment": "Some broken exception that does return \"this\" as getCause",
        "model_generated_comment": "@link PluginContainerException @param null, null - null. @return a new Exception if a PluginException is thrown."
    },
    {
        "id": 836,
        "code_snippet": "public OverlayView(final Context context, final AttributeSet attrs) {\n    super(context, attrs);\n  }",
        "human_comment": "A simple View providing a render callback to other classes.",
        "model_generated_comment": "p>OverlayView/p> @link Context/@link AttributeSet attrs. @param context Attributes are set in the context of a given context."
    },
    {
        "id": 837,
        "code_snippet": "public static _Fields findByName(String name) {\n      return byName.get(name);\n    }",
        "human_comment": "Find the _Fields constant that matches name, or null if its not found.",
        "model_generated_comment": "Returns the name of the field. @param name The name of a field in a string. @return the name if the field is @code name."
    },
    {
        "id": 838,
        "code_snippet": "private boolean containsPatches(Set<PathType> types) {\n        for (PathType type : types) {\n            if (type instanceof JavaPathType.Modular modular) {\n                type = modular.rawType();\n            }\n            if (JavaPathType.PATCH_MODULE.equals(type)) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "human_comment": "Returns whether the given set of path types contains at least one patch for a module.",
        "model_generated_comment": "@link JavaPathType @param type types @return true if the type is set to a type of the type that is used to set the type of a particular type; if it is not, the type will be set to the same type."
    },
    {
        "id": 839,
        "code_snippet": "public void testSimpleNegate() {\n        Money expected = new Money(-14, \"CHF\");\n        assertEquals(expected, f14CHF.negate());\n    }",
        "human_comment": "[14 CHF] negate == [-14 CHF]",
        "model_generated_comment": "p>Assert/p> that @code f14CHF.negate() is a simple Negate method."
    },
    {
        "id": 840,
        "code_snippet": "void testNullTaskWithNullCallback() {\n    assertTimeout(\n        ofMillis(3000),\n        () -> {\n          // Instantiate a new executor and start a new 'null' task ...\n          final var executor = new ThreadAsyncExecutor();\n          final var asyncResult = executor.startProcess(null, null);\n\n          assertNotNull(\n              asyncResult,\n              \"The AsyncResult should not be 'null', even though the task and callback were 'null'.\");\n          asyncResult.await(); // Prevent timing issues, and wait until the result is available\n          assertTrue(asyncResult.isCompleted());\n\n          try {\n            asyncResult.getValue();\n            fail(\"Expected ExecutionException with NPE as cause\");\n          } catch (final ExecutionException e) {\n            assertNotNull(e.getMessage());\n            assertNotNull(e.getCause());\n            assertEquals(NullPointerException.class, e.getCause().getClass());\n          }\n        });\n  }",
        "human_comment": "Test used to verify the behaviour of {@link ThreadAsyncExecutor#startProcess(Callable,\nAsyncCallback)} when both the callable and the asynchronous callback are 'null'",
        "model_generated_comment": "AsyncExecutor.startProcessWithNullCallback() @link ExecutionException if the task and callback were 'null'."
    },
    {
        "id": 841,
        "code_snippet": "public List<UserAccount> getCacheDataInListForm() {\n    var listOfCacheData = new ArrayList<UserAccount>();\n    var temp = head;\n    while (temp != null) {\n      listOfCacheData.add(temp.userAccount);\n      temp = temp.next;\n    }\n    return listOfCacheData;\n  }",
        "human_comment": "Returns cache data in list form.\n\n@return {@link List}",
        "model_generated_comment": "Returns a list of cache data in the form of an ArrayListUserAccount>."
    },
    {
        "id": 842,
        "code_snippet": "public final Optional<FilePosition> getPosition() {\n\t\treturn Optional.ofNullable(this.filePosition);\n\t}",
        "human_comment": "Get the {@link FilePosition}, if available.",
        "model_generated_comment": "OptionalFilePosition> p>This/p> is not @code null."
    },
    {
        "id": 843,
        "code_snippet": "public static FilePosition from(int line, int column) {\n\t\treturn new FilePosition(line, column);\n\t}",
        "human_comment": "Create a new {@code FilePosition} using the supplied {@code line} and\n\n@param line the line number; must be greater than zero\n@param column the column number; must be greater than zero\n@return a {@link FilePosition} with the given line and column numbers",
        "model_generated_comment": "Returns a new FilePosition from a @link Int. @param line, int column a line or a column."
    },
    {
        "id": 844,
        "code_snippet": "public LoginPage enterUsername(String username) {\n    var usernameInputTextField = (HtmlTextInput) page.getElementById(\"username\");\n    usernameInputTextField.setText(username);\n    return this;\n  }",
        "human_comment": "Enters the username into the username input text field.\n\n@param username the username to enter\n@return {@link LoginPage}",
        "model_generated_comment": "p>Username/p> a @link LoginPage. @param username a username a string a text a URL a tag a link a message a comment a reply a request a response a question a query a form a document a page a website a forum a topic a discussion a post a feature a product a service a client a site a blog a content"
    },
    {
        "id": 845,
        "code_snippet": "public Order checkout(final String userId) {\n    List<Cart> items = cartRepository.getItemsInCart(userId);\n    String orderId = \"ORDER-\" + System.currentTimeMillis();\n    Order order = new Order(orderId, items);\n    orderRepository.saveOrder(order);\n    cartRepository.clearCart(userId);\n    return order;\n  }",
        "human_comment": "Checks out the user's cart and creates an order.\n\n<p>This method retrieves the cart items, generates an order ID, creates a new order, saves it,\nand clears the cart.\n\n@param userId The ID of the user.\n@return The created order containing purchased items.",
        "model_generated_comment": "Returns a list of items in a cart. @param userId the user ID of the cart."
    },
    {
        "id": 846,
        "code_snippet": "public static ArrayType createArrayType(DataType elementType) {\n    if (elementType == null) {\n      throw new IllegalArgumentException(\"elementType should not be null.\");\n    }\n    return new ArrayType(elementType, true);\n  }",
        "human_comment": "Creates an ArrayType by specifying the data type of elements ({@code elementType}).\nThe field of {@code containsNull} is set to {@code true}.",
        "model_generated_comment": "Error if ArrayType is null."
    },
    {
        "id": 847,
        "code_snippet": "public void registerGateway(String key, Gateway gateway) {\n    gateways.put(key, gateway);\n  }",
        "human_comment": "The \"GatewayFactory\" class is responsible for providing different external services in this\nGateway design pattern example. It allows clients to register and retrieve specific gateways\nbased on unique keys.",
        "model_generated_comment": "@link Gateway gateway @param gateway key the gateway gateway key if the gateway key is not present. @return the key of the Gateway gateway if it is not found."
    },
    {
        "id": 848,
        "code_snippet": "public ShuffleSorterIterator getSortedIterator() {\n    int offset = 0;\n    if (useRadixSort) {\n      offset = RadixSort.sort(\n        array, pos,\n        PackedRecordPointer.PARTITION_ID_START_BYTE_INDEX,\n        PackedRecordPointer.PARTITION_ID_END_BYTE_INDEX, false, false);\n    } else {\n      MemoryBlock unused = new MemoryBlock(\n        array.getBaseObject(),\n        array.getBaseOffset() + pos * 8L,\n        (array.size() - pos) * 8L);\n      LongArray buffer = new LongArray(unused);\n      Sorter<PackedRecordPointer, LongArray> sorter =\n        new Sorter<>(new ShuffleSortDataFormat(buffer));\n\n      sorter.sort(array, 0, pos, SORT_COMPARATOR);\n    }\n    return new ShuffleSorterIterator(pos, array, offset);\n  }",
        "human_comment": "Return an iterator over record pointers in sorted order.",
        "model_generated_comment": "p>Sort/p>PackedRecordPointer/a>. @param array, pos array, offset @code /code pos array.getSortedIterator. @return a new ShuffleSorter Iterator if it's not already sorted."
    },
    {
        "id": 849,
        "code_snippet": "private Builder(Mode mode, String name, DataType dataType) {\n      this.mode = mode;\n      this.name = name;\n      this.dataType = dataType;\n    }",
        "human_comment": "An enum representing procedure parameter modes.",
        "model_generated_comment": "p>Mode mode/p>DataType is a @link DataType. @param dataType a datatype a mode a name a type of data type a method of defining a new data type."
    },
    {
        "id": 850,
        "code_snippet": "public static void assertEquals(Character expected, char actual, String message) {\n\t\tAssertEquals.assertEquals(expected, (Character) actual, message);\n\t}",
        "human_comment": "<em>Assert</em> that {@code expected} and {@code actual} are equal.\n<p>Fails with the supplied failure {@code message}.",
        "model_generated_comment": "p>Assert/p> that @code expected and /code actual are equal."
    },
    {
        "id": 851,
        "code_snippet": "public int storeData(Data data) {\n    var shardId = allocateShard(data);\n    lookupMap.put(data.getKey(), shardId);\n    var shard = shardMap.get(shardId);\n    shard.storeData(data);\n    LOGGER.info(data + \" is stored in Shard \" + shardId);\n    return shardId;\n  }",
        "human_comment": "ShardManager with lookup strategy. In this strategy the sharding logic implements a map that\nroutes a request for data to the shard that contains that data by using the shard key.",
        "model_generated_comment": "p>ShardId/p> is stored in a shard."
    },
    {
        "id": 852,
        "code_snippet": "public TempDirectory(JupiterConfiguration configuration) {\n\t\tthis.configuration = configuration;\n\t}",
        "human_comment": "{@code TempDirectory} is a JUnit Jupiter extension that creates and cleans\nup temporary directories if a field in a test class or a parameter in a\ntest class constructor, lifecycle method, or test method is annotated with\n{@code @TempDir}.\n\n<p>Consult the Javadoc for {@link TempDir} for details on the contract.\n\n@since 5.4\n@see TempDir @TempDir\n@see Files#createTempDirectory",
        "model_generated_comment": "Configures a TempDirectory with a configuration file. @param configuration configuration configuration @link configuration configuration"
    },
    {
        "id": 853,
        "code_snippet": "public static void main(String[] args) {\n    SparkConf conf = new SparkConf().setAppName(\"Java Collaborative Filtering Example\");\n    JavaSparkContext jsc = new JavaSparkContext(conf);\n\n    String path = \"data/mllib/als/test.data\";\n    JavaRDD<String> data = jsc.textFile(path);\n    JavaRDD<Rating> ratings = data.map(s -> {\n      String[] sarray = s.split(\",\");\n      return new Rating(Integer.parseInt(sarray[0]),\n        Integer.parseInt(sarray[1]),\n        Double.parseDouble(sarray[2]));\n    });\n\n    int rank = 10;\n    int numIterations = 10;\n    MatrixFactorizationModel model = ALS.train(JavaRDD.toRDD(ratings), rank, numIterations, 0.01);\n\n    JavaRDD<Tuple2<Object, Object>> userProducts =\n      ratings.map(r -> new Tuple2<>(r.user(), r.product()));\n    JavaPairRDD<Tuple2<Integer, Integer>, Double> predictions = JavaPairRDD.fromJavaRDD(\n      model.predict(JavaRDD.toRDD(userProducts)).toJavaRDD()\n          .map(r -> new Tuple2<>(new Tuple2<>(r.user(), r.product()), r.rating()))\n    );\n    JavaRDD<Tuple2<Double, Double>> ratesAndPreds = JavaPairRDD.fromJavaRDD(\n        ratings.map(r -> new Tuple2<>(new Tuple2<>(r.user(), r.product()), r.rating())))\n      .join(predictions).values();\n    double MSE = ratesAndPreds.mapToDouble(pair -> {\n      double err = pair._1() - pair._2();\n      return err * err;\n    }).mean();\n    System.out.println(\"Mean Squared Error = \" + MSE);\n\n    model.save(jsc.sc(), \"target/tmp/myCollaborativeFilter\");\n    MatrixFactorizationModel sameModel = MatrixFactorizationModel.load(jsc.sc(),\n      \"target/tmp/myCollaborativeFilter\");\n\n    jsc.stop();\n  }",
        "human_comment": "$example on$\n$example off$\n$example on$\nLoad and parse the data\nBuild the recommendation model using ALS\nEvaluate the model on rating data\nSave and load model\n$example off$",
        "model_generated_comment": "p>Java Collaborative Filtering Example/p>. @param @code /code rdd if a jsc file is created, it will be used to create a new json file."
    },
    {
        "id": 854,
        "code_snippet": "public void setConfigurableField(String configurableField) {\n        this.configurableField = configurableField;\n    }",
        "human_comment": "A field that can be configured in the Wagon\n\n@component.configuration default=\"configurableField\"",
        "model_generated_comment": "Sets a configurable field for @link ConfigurableField. @param configurableField if the field is configurable."
    },
    {
        "id": 855,
        "code_snippet": "public InternalRow copy() {\n    GenericInternalRow row = new GenericInternalRow(numFields);\n    for (int i = 0; i < numFields(); i++) {\n      if (isNullAt(i)) {\n        row.setNullAt(i);\n      } else {\n        DataType dt = data.getChild(i).dataType();\n        PhysicalDataType pdt = PhysicalDataType.apply(dt);\n        if (pdt instanceof PhysicalBooleanType) {\n          row.setBoolean(i, getBoolean(i));\n        } else if (pdt instanceof PhysicalByteType) {\n          row.setByte(i, getByte(i));\n        } else if (pdt instanceof PhysicalShortType) {\n          row.setShort(i, getShort(i));\n        } else if (pdt instanceof PhysicalIntegerType) {\n          row.setInt(i, getInt(i));\n        } else if (pdt instanceof PhysicalLongType) {\n          row.setLong(i, getLong(i));\n        } else if (pdt instanceof PhysicalFloatType) {\n          row.setFloat(i, getFloat(i));\n        } else if (pdt instanceof PhysicalDoubleType) {\n          row.setDouble(i, getDouble(i));\n        } else if (pdt instanceof PhysicalStringType) {\n          row.update(i, getUTF8String(i).copy());\n        } else if (pdt instanceof PhysicalBinaryType) {\n          row.update(i, getBinary(i));\n        } else if (pdt instanceof PhysicalDecimalType t) {\n          row.setDecimal(i, getDecimal(i, t.precision(), t.scale()), t.precision());\n        } else if (pdt instanceof PhysicalStructType t) {\n          row.update(i, getStruct(i, t.fields().length).copy());\n        } else if (pdt instanceof PhysicalArrayType) {\n          row.update(i, getArray(i).copy());\n        } else if (pdt instanceof PhysicalMapType) {\n          row.update(i, getMap(i).copy());\n        } else {\n          throw new RuntimeException(\"Not implemented. \" + dt);\n        }\n      }\n    }\n    return row;\n  }",
        "human_comment": "Revisit this. This is expensive. This is currently only used in test paths.",
        "model_generated_comment": "p>If (pdt instanceof PhysicalIntegerType) /p>, @link PhysicalDataType should be used."
    },
    {
        "id": 856,
        "code_snippet": "public AlbumPage changeAlbumRating(String albumRating) {\n    var albumRatingInputTextField = (HtmlTextInput) page.getElementById(\"albumRating\");\n    albumRatingInputTextField.setText(albumRating);\n    return this;\n  }",
        "human_comment": "Sets the album rating input text field\n\n@param albumRating the new album rating value to set\n@return {@link AlbumPage}",
        "model_generated_comment": "p>Also, if the @link albumRating is a string, it will be set to a value of 0x100."
    },
    {
        "id": 857,
        "code_snippet": "public static <T> Result<T> error(Iterable<? extends ModelProblem> problems) {\n        return error(null, problems);\n    }",
        "human_comment": "Error with problems describing the cause\n\n@param problems",
        "model_generated_comment": "@link ModelProblem> problems/. @param problems if the problem is a problem."
    },
    {
        "id": 858,
        "code_snippet": "public static XmlNode merge(XmlNode dominant, XmlNode recessive) {\n        return merge(dominant, recessive, null);\n    }",
        "human_comment": "Convenience method to merge two XML nodes using default settings.",
        "model_generated_comment": "XmlNode merges a XML node into a new node. @param dominant, xmlnode recessive, null."
    },
    {
        "id": 859,
        "code_snippet": "static boolean isCommentLine(String line) {\n        String s = line.trim();\n        // blank lines are also treated as comment lines\n        return s.isEmpty() || COMMENT_CHARS.indexOf(s.charAt(0)) >= 0;\n    }",
        "human_comment": "Tests whether a line is a comment, i.e. whether it starts with a comment\ncharacter.\n\n@param line the line\n@return a flag if this is a comment line",
        "model_generated_comment": "p>Comment lines are also treated as comment lines. @param comment line @code comment line @return a boolean if a comment line is a line."
    },
    {
        "id": 860,
        "code_snippet": "void selectClasspathResourcesWithFilePosition() {\n\t\t\tvar filePosition = FilePosition.from(12, 34);\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(null, filePosition));\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(\"\", filePosition));\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(\"    \", filePosition));\n\t\t\tassertViolatesPrecondition(() -> selectClasspathResource(\"\\t\", filePosition));\n\n\t\t\tvar selector = selectClasspathResource(\"/foo/bar/spec.xml\", filePosition);\n\t\t\tassertEquals(\"foo/bar/spec.xml\", selector.getClasspathResourceName());\n\t\t\tassertEquals(FilePosition.from(12, 34), selector.getPosition().orElseThrow());\n\n\t\t\tselector = selectClasspathResource(\"A/B/C/spec.json\", filePosition);\n\t\t\tassertEquals(\"A/B/C/spec.json\", selector.getClasspathResourceName());\n\t\t\tassertEquals(filePosition, selector.getPosition().orElseThrow());\n\t\t}",
        "human_comment": "with unnecessary \"/\" prefix\nstandard use case",
        "model_generated_comment": "p>FilePosition/p>A/B/C/spec.json @code /code spec.xml a/b/c/spec spec. @param http://github.com/selectClasspathResources/docs/elseThrow/resources>"
    },
    {
        "id": 861,
        "code_snippet": "public Count(Expression column, boolean isDistinct) {\n    this.input = column;\n    this.isDistinct = isDistinct;\n  }",
        "human_comment": "An aggregate function that returns the number of the specific row in a group.\n\n@since 3.2.0",
        "model_generated_comment": "Counts the number of expression columns in a given column. @param isDistinct if the column is a boolean column."
    },
    {
        "id": 862,
        "code_snippet": "public List<Artifact> getAttachedArtifacts() {\n        if (attachedArtifacts == null) {\n            attachedArtifacts = new ArrayList<>();\n        }\n        return Collections.unmodifiableList(attachedArtifacts);\n    }",
        "human_comment": "Returns a read-only list of the attached artifacts to this project.\n\n@return the attached artifacts of this project",
        "model_generated_comment": "@link AttachedArtifacts/@link UnmodifiableList/> p>Attach/p> An array of objects that can be attached to a collection. @return a list of the objects that are attached to the collection."
    },
    {
        "id": 863,
        "code_snippet": "private String makeMethodKey(Method method) {\n        Class<?>[] parameterTypes = method.getParameterTypes();\n\n        StringBuilder methodKey = new StringBuilder(method.getName());\n\n        for (Class<?> parameterType : parameterTypes) {\n            // If the argument type is primitive then we want\n            // to convert our primitive type signature to the\n            // corresponding Object type so introspection for\n            // methods with primitive types will work correctly.\n            if (parameterType.isPrimitive()) {\n                if (parameterType.equals(Boolean.TYPE)) {\n                    methodKey.append(\"java.lang.Boolean\");\n                } else if (parameterType.equals(Byte.TYPE)) {\n                    methodKey.append(\"java.lang.Byte\");\n                } else if (parameterType.equals(Character.TYPE)) {\n                    methodKey.append(\"java.lang.Character\");\n                } else if (parameterType.equals(Double.TYPE)) {\n                    methodKey.append(\"java.lang.Double\");\n                } else if (parameterType.equals(Float.TYPE)) {\n                    methodKey.append(\"java.lang.Float\");\n                } else if (parameterType.equals(Integer.TYPE)) {\n                    methodKey.append(\"java.lang.Integer\");\n                } else if (parameterType.equals(Long.TYPE)) {\n                    methodKey.append(\"java.lang.Long\");\n                } else if (parameterType.equals(Short.TYPE)) {\n                    methodKey.append(\"java.lang.Short\");\n                }\n            } else {\n                methodKey.append(parameterType.getName());\n            }\n        }\n\n        return methodKey.toString();\n    }",
        "human_comment": "Make a methodKey for the given method using\nthe concatenation of the name and the\ntypes of the method parameters.",
        "model_generated_comment": "p>If the argument type is primitive then we want to convert our primitive type signature to the corresponding Object type so introspection for // methods with primitive types will work correctly."
    },
    {
        "id": 864,
        "code_snippet": "protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main_activity);\n\n        final RecyclerView list = findViewById(R.id.list);\n        list.setLayoutManager(new LinearLayoutManager(list.getContext()));\n        mCheeseAdapter = new CheeseAdapter();\n        list.setAdapter(mCheeseAdapter);\n\n        LoaderManager.getInstance(this).initLoader(LOADER_CHEESES, null, mLoaderCallbacks);\n    }",
        "human_comment": "Not very relevant to Room. This just shows data from {@link SampleContentProvider}.\n\n<p>Since the data is exposed through the ContentProvider, other apps can read and write the\ncontent in a similar manner to this.</p>",
        "model_generated_comment": "p>SavedInstanceState/p>Create a new RecyclerView from a saved instance. @param @code mLoaderCallbacks if it is not already created, it will not be created."
    },
    {
        "id": 865,
        "code_snippet": "public String getVersion() {\n        return (version != null) ? version : \"\";\n    }",
        "human_comment": "Gets the effective version of the model.\n\n@return The effective version of the model or an empty string if unknown, never {@code null}.",
        "model_generated_comment": "Returns the version of the current version. @param version The version of a given version."
    },
    {
        "id": 866,
        "code_snippet": "public void testShow() {\n    Dataset<Row> df = spark.table(\"testData\");\n    df.show();\n    df.show(1000);\n  }",
        "human_comment": "This test case is intended ignored, but to make sure it compiles correctly",
        "model_generated_comment": "@link testShow @param testData a dataset containing a test data set. @return the test data if the data set is not available."
    },
    {
        "id": 867,
        "code_snippet": "protected void printErrors(C context, boolean showStackTrace, List<Logger.Entry> entries, Logger logger) {\n        if (logger instanceof AccumulatingLogger) {\n            logger = new SystemLogger(context.invokerRequest.stdErr().orElse(null));\n        }\n        logger.error(\"Error executing \" + context.invokerRequest.parserRequest().commandName() + \".\");\n        for (Logger.Entry entry : entries) {\n            if (showStackTrace) {\n                logger.log(entry.level(), entry.message(), entry.error());\n            } else {\n                logger.error(entry.message());\n                for (Throwable cause = entry.error();\n                        cause != null && cause != cause.getCause();\n                        cause = cause.getCause()) {\n                    logger.log(entry.level(), \"Caused by: \" + cause.getMessage());\n                }\n            }\n        }\n    }",
        "human_comment": "if accumulating logger passed, this is \"early failure\", swap logger for stdErr and use that to emit log\nthis is important message; many Maven IT assert for presence of this message",
        "model_generated_comment": "Error executing a Logger logger. p>AccumulatingLogger/p>Caused by @code null."
    },
    {
        "id": 868,
        "code_snippet": "public TransportConf(String module, ConfigProvider conf) {\n    this.module = module;\n    this.conf = conf;\n    SPARK_NETWORK_IO_MODE_KEY = getConfKey(\"io.mode\");\n    SPARK_NETWORK_IO_PREFERDIRECTBUFS_KEY = getConfKey(\"io.preferDirectBufs\");\n    SPARK_NETWORK_IO_CONNECTIONTIMEOUT_KEY = getConfKey(\"io.connectionTimeout\");\n    SPARK_NETWORK_IO_CONNECTIONCREATIONTIMEOUT_KEY = getConfKey(\"io.connectionCreationTimeout\");\n    SPARK_NETWORK_IO_BACKLOG_KEY = getConfKey(\"io.backLog\");\n    SPARK_NETWORK_IO_NUMCONNECTIONSPERPEER_KEY =  getConfKey(\"io.numConnectionsPerPeer\");\n    SPARK_NETWORK_IO_SERVERTHREADS_KEY = getConfKey(\"io.serverThreads\");\n    SPARK_NETWORK_IO_CLIENTTHREADS_KEY = getConfKey(\"io.clientThreads\");\n    SPARK_NETWORK_IO_RECEIVEBUFFER_KEY = getConfKey(\"io.receiveBuffer\");\n    SPARK_NETWORK_IO_SENDBUFFER_KEY = getConfKey(\"io.sendBuffer\");\n    SPARK_NETWORK_SASL_TIMEOUT_KEY = getConfKey(\"sasl.timeout\");\n    SPARK_NETWORK_IO_MAXRETRIES_KEY = getConfKey(\"io.maxRetries\");\n    SPARK_NETWORK_IO_RETRYWAIT_KEY = getConfKey(\"io.retryWait\");\n    SPARK_NETWORK_IO_LAZYFD_KEY = getConfKey(\"io.lazyFD\");\n    SPARK_NETWORK_VERBOSE_METRICS = getConfKey(\"io.enableVerboseMetrics\");\n    SPARK_NETWORK_IO_ENABLETCPKEEPALIVE_KEY = getConfKey(\"io.enableTcpKeepAlive\");\n  }",
        "human_comment": "A central location that tracks all the settings we expose to users.",
        "model_generated_comment": "p>SpARK_NETWORK_IO_CONNECTION_KEY/p>. @param io.connexion.conf a @link ConfigProvider conf/jsp> if a new /.conf> is created, it will be used to create a concatenated ConcatenateConfigConf. @return the '@linkConf' if the new '/."
    },
    {
        "id": 869,
        "code_snippet": "public Result run(Request request) {\n        return run(request, new JUnitCore());\n    }",
        "human_comment": "Run all the tests contained in <code>request</code>.\n\n@param request the request describing tests\n@return a {@link Result} describing the details of the test run and the failed tests.",
        "model_generated_comment": "Runs a JUnitCore from a request."
    },
    {
        "id": 870,
        "code_snippet": "private void updateQueue(QueueTask qt) {\n    if (System.currentTimeMillis() - qt.order.createdTime >= this.queueTime) {\n      LOG.trace(ORDER_ID + \": Queue time for order over, failed..\", qt.order.id);\n      return;\n    } else if (qt.taskType.equals(TaskType.PAYMENT) && !qt.order.paid.equals(PaymentStatus.TRYING)\n        || qt.taskType.equals(TaskType.MESSAGING)\n            && (qt.messageType == 1 && !qt.order.messageSent.equals(MessageSent.NONE_SENT)\n                || qt.order.messageSent.equals(MessageSent.PAYMENT_FAIL)\n                || qt.order.messageSent.equals(MessageSent.PAYMENT_SUCCESSFUL))\n        || qt.taskType.equals(TaskType.EMPLOYEE_DB) && qt.order.addedToEmployeeHandle) {\n      LOG.trace(ORDER_ID + \": Not queueing task since task already done..\", qt.order.id);\n      return;\n    }\n    var list = queue.exceptionsList;\n    Thread t =\n        new Thread(\n            () -> {\n              Retry.Operation op =\n                  list1 -> {\n                    if (!list1.isEmpty()) {\n                      LOG.warn(\n                          ORDER_ID + \": Error in connecting to queue db, trying again..\",\n                          qt.order.id);\n                      throw list1.remove(0);\n                    }\n                    queue.add(qt);\n                    queueItems++;\n                    LOG.info(ORDER_ID + \": {}\" + \" task enqueued..\", qt.order.id, qt.getType());\n                    tryDoingTasksInQueue();\n                  };\n              Retry.HandleErrorIssue<QueueTask> handleError =\n                  (qt1, err) -> {\n                    if (qt1.taskType.equals(TaskType.PAYMENT)) {\n                      qt1.order.paid = PaymentStatus.NOT_DONE;\n                      sendPaymentFailureMessage(qt1.order);\n                      LOG.error(\n                          ORDER_ID + \": Unable to enqueue payment task,\" + \" payment failed..\",\n                          qt1.order.id);\n                    }\n                    LOG.error(\n                        ORDER_ID\n                            + \": Unable to enqueue task of type {}\"\n                            + \", trying to add to employee handle..\",\n                        qt1.order.id,\n                        qt1.getType());\n                    employeeHandleIssue(qt1.order);\n                  };\n              var r =\n                  new Retry<>(\n                      op,\n                      handleError,\n                      numOfRetries,\n                      retryDuration,\n                      e -> DatabaseUnavailableException.class.isAssignableFrom(e.getClass()));\n              try {\n                r.perform(list, qt);\n              } catch (Exception e1) {\n                LOG.error(DEFAULT_EXCEPTION_MESSAGE, e1);\n              }\n            });\n    t.start();\n  }",
        "human_comment": "since payment time is lesser than queuetime it would have already failed..\nadditional check not needed",
        "model_generated_comment": "qt.order.createdTime = this.queueTimeMillis @link QueueTask. @param $qt_order_addedToEmployeeHandle() p>QueueType.equals() &#160;Qt.OrderType.MESSAGING/p> /a> if the queue is empty, the queue will be re-created. @retry.qt-qt()"
    },
    {
        "id": 871,
        "code_snippet": "public static void main(String... args) {\n\t\tCommandFacade facade = newCommandFacade(CustomClassLoaderCloseStrategy.KEEP_OPEN);\n\t\tCommandResult<?> result = facade.run(args);\n\t\tSystem.exit(result.getExitCode());\n\t}",
        "human_comment": "The {@code ConsoleLauncher} is a stand-alone application for launching the\nJUnit Platform from the console.\n\n@since 1.0",
        "model_generated_comment": "p>Assert that @link CommandFacade/p> is a closed structure."
    },
    {
        "id": 872,
        "code_snippet": "public ExecutionPlanItem(MojoExecution mojoExecution) {\n        this.mojoExecution = mojoExecution;\n    }",
        "human_comment": "<p>\nWraps individual MojoExecutions, containing information about completion status and scheduling.\n</p>\n<strong>NOTE:</strong> This class is not part of any public api and can be changed or deleted without prior notice.\n\n@since 3.0",
        "model_generated_comment": "p>MojoExecution/p>. @param @link ExecutionPlanItem a mojo execution plan that executes a java.execution."
    },
    {
        "id": 873,
        "code_snippet": "default NamedReference[] references() {\n    // SPARK-40398: Replace `Arrays.stream()...distinct()`\n    // to this for perf gain, the result order is not important.\n    Set<NamedReference> set = new HashSet<>();\n    for (Expression e : children()) {\n      Collections.addAll(set, e.references());\n    }\n    return set.toArray(EMPTY_NAMED_REFERENCE);\n  }",
        "human_comment": "List of fields or columns that are referenced by this expression.",
        "model_generated_comment": "Sets the name of a reference. @param @code NamedReference if the reference is not a name. @return the reference if it is a non-named reference."
    },
    {
        "id": 874,
        "code_snippet": "public static void assertEquals(Object expected, Object actual) {\n        Assert.assertEquals(expected, actual);\n    }",
        "human_comment": "Asserts that two objects are equal. If they are not\nan AssertionFailedError is thrown.",
        "model_generated_comment": "Asserts that the @code expected and /code actual are equal."
    },
    {
        "id": 875,
        "code_snippet": "for (Callback callback : callbacks) {\n        if (callback instanceof NameCallback nc) {\n          logger.trace(\"SASL server callback: setting username\");\n          nc.setName(encodeIdentifier(secretKeyHolder.getSaslUser(secretKeyId)));\n        } else if (callback instanceof PasswordCallback pc) {\n          logger.trace(\"SASL server callback: setting password\");\n          pc.setPassword(encodePassword(secretKeyHolder.getSecretKey(secretKeyId)));\n        } else if (callback instanceof RealmCallback rc) {\n          logger.trace(\"SASL server callback: setting realm\");\n          rc.setText(rc.getDefaultText());\n        } else if (callback instanceof AuthorizeCallback ac) {\n          String authId = ac.getAuthenticationID();\n          String authzId = ac.getAuthorizationID();\n          ac.setAuthorized(authId.equals(authzId));\n          if (ac.isAuthorized()) {\n            ac.setAuthorizedID(authzId);\n          }\n          logger.debug(\"SASL Authorization complete, authorized set to {}\", ac.isAuthorized());\n        } else {\n          throw new UnsupportedCallbackException(callback, \"Unrecognized SASL DIGEST-MD5 Callback\");\n        }\n      }",
        "human_comment": "Implementation of javax.security.auth.callback.CallbackHandler for SASL DIGEST-MD5 mechanism.",
        "model_generated_comment": "Callback instance of NameCallback nc @link Callbacks. @param AuthenticationID is the name of the callback instance. @return a callback if a name is set to a specific identifier (e.g."
    },
    {
        "id": 876,
        "code_snippet": "static <T> Trampoline<T> done(final T result) {\n    return () -> result;\n  }",
        "human_comment": "Created a completed Trampoline.\n\n@param result Completed result\n@return Completed Trampoline",
        "model_generated_comment": "@link Trampoline @param T result @return the result if the result is not returned."
    },
    {
        "id": 877,
        "code_snippet": "public void setFooter(List<String> footer) {\n        this.footer = footer;\n    }",
        "human_comment": "Set the comment footer.\n\n@param footer the footer to use",
        "model_generated_comment": "Sets the footer of a @link footer. @param footer a footer with a list of footers."
    },
    {
        "id": 878,
        "code_snippet": "public DefaultProjectsSelector(ProjectBuilder projectBuilder) {\n        this.projectBuilder = projectBuilder;\n    }",
        "human_comment": "Utility to select projects for a given set of pom.xml files.",
        "model_generated_comment": "DefaultProjectsSelector(ProjectBuilder) @link ProjectBuilder/@link ProjectBuilders. @param projectBuilder the project builder for a project."
    },
    {
        "id": 879,
        "code_snippet": "public void deleteAndGetUser() {\n        mDataSource.insertOrUpdateUser(USER);\n\n        mDataSource.deleteAllUsers();\n\n        User dbUser = mDataSource.getUser();\n        assertNull(dbUser);\n    }",
        "human_comment": "Given that we have a user in the data source\nWhen we are deleting all users\nThe user is no longer in the data source",
        "model_generated_comment": "p>MDataSource.insertOrUpdateUser/p>DeleteAllUsers from the @link mDataSource."
    },
    {
        "id": 880,
        "code_snippet": "public static boolean unaligned() {\n    return unaligned;\n  }",
        "human_comment": "@return true when running JVM is having sun's Unsafe package available in it and underlying\nsystem having unaligned-access capability.",
        "model_generated_comment": "Returns a boolean aligned @link unaligned. @return the alignment if the alignment is not matched."
    },
    {
        "id": 881,
        "code_snippet": "public static ClassSource from(URI uri) {\n\t\tPreconditions.notNull(uri, \"URI must not be null\");\n\t\tPreconditions.condition(CLASS_SCHEME.equals(uri.getScheme()),\n\t\t\t() -> \"URI [\" + uri + \"] must have [\" + CLASS_SCHEME + \"] scheme\");\n\n\t\tString className = uri.getSchemeSpecificPart();\n\t\tFilePosition filePosition = null;\n\t\tint indexOfQuery = className.indexOf('?');\n\t\tif (indexOfQuery >= 0) {\n\t\t\tfilePosition = FilePosition.fromQuery(className.substring(indexOfQuery + 1)).orElse(null);\n\t\t\tclassName = className.substring(0, indexOfQuery);\n\t\t}\n\n\t\treturn ClassSource.from(className, filePosition);\n\t}",
        "human_comment": "Create a new {@code ClassSource} from the supplied {@link URI}.\nThe {@linkplain URI#getQuery() query} component of the {@code URI}, if\npresent, will be used to retrieve the {@link FilePosition} via\n{@link FilePosition#fromQuery(String)}. For example, line 42 and column\n13 can be referenced in class {@code org.example.MyType} via the following\nURI: {@code class:com.example.MyType?line=42&column=13}. The URI fragment,\nif present, will be ignored.\n\n@param uri the {@code URI} for the class source; never {@code null}\n@return a new {@code ClassSource}; never {@code null}\n{@code null}, if the scheme of the supplied {@code URI} is not equal\nto the {@link #CLASS_SCHEME}, or if the specified class name is empty\n@since 1.8\n@see #CLASS_SCHEME",
        "model_generated_comment": "@code null if the URI is null. @param URI URI must have [\" + uri + \"] scheme\" if URI has a URI, it must have a scheme. @return ClassSource.from() if it is not null, it will return a filePosition."
    },
    {
        "id": 882,
        "code_snippet": "private String convertPattern(final String pattern, boolean datanucleusFormat) {\n    String wStr;\n    if (datanucleusFormat) {\n      wStr = \"*\";\n    } else {\n      wStr = \".*\";\n    }\n    return pattern\n        .replaceAll(\"([^\\\\\\\\])%\", \"$1\" + wStr).replaceAll(\"\\\\\\\\%\", \"%\").replaceAll(\"^%\", wStr)\n        .replaceAll(\"([^\\\\\\\\])_\", \"$1.\").replaceAll(\"\\\\\\\\_\", \"_\").replaceAll(\"^_\", \".\");\n  }",
        "human_comment": "Convert a pattern containing JDBC catalog search wildcards into\nJava regex patterns.\n\n@param pattern input which may contain '%' or '_' wildcard characters, or\nthese characters escaped using {@link #getSearchStringEscape()}.\n@return replace %/_ with regex search characters, also handle escaped\ncharacters.\n\nThe datanucleus module expects the wildchar as '*'. The columns search on the\nother hand is done locally inside the hive code and that requires the regex wildchar\nformat '.*'  This is driven by the datanucleusFormat flag.",
        "model_generated_comment": "Returns a boolean datanucleusFormat. @param @code #replaceAll if the pattern is \"*\" or \"$1\". @return the pattern if it's \"#$1\""
    },
    {
        "id": 883,
        "code_snippet": "private Stream<org.apache.maven.artifact.Artifact> getProjectArtifacts(MavenProject project) {\n        return Stream.concat(Stream.of(project.getArtifact()), project.getAttachedArtifacts().stream());\n    }",
        "human_comment": "Retrieve a stream of the project's artifacts.\nDo not include the POM artifact as the file can't be set anyway.",
        "model_generated_comment": "@link Apache.maven.artifact.Artifacts @return a Stream from a Maven project."
    },
    {
        "id": 884,
        "code_snippet": "public Request filterWith(Filter filter) {\n        return new FilterRequest(this, filter);\n    }",
        "human_comment": "Returns a Request that only contains those tests that should run when\n<code>filter</code> is applied\n\n@param filter The {@link Filter} to apply to this Request\n@return the filtered Request",
        "model_generated_comment": "Returns a Filter request with @link FilterRequest. @return a filter request with this filter filter."
    },
    {
        "id": 885,
        "code_snippet": "public static List<ModuleSelector> selectModules(Set<String> moduleNames) {\n\t\tPreconditions.notNull(moduleNames, \"Module names must not be null\");\n\t\tPreconditions.containsNoNullElements(moduleNames, \"Individual module name must not be null\");\n\n\t\t// @formatter:off\n\t\treturn moduleNames.stream()\n\t\t\t\t.map(DiscoverySelectors::selectModule)\n\t\t\t\t// unmodifiable since this is a public, non-internal method\n\t\t\t\t.collect(toUnmodifiableList());\n\t\t// @formatter:on\n\t}",
        "human_comment": "Create a list of {@code ModuleSelectors} for the supplied module names.\n\n<p>The unnamed module is not supported.\n\n@param moduleNames the module names to select; never {@code null}, never\ncontaining {@code null} or blank\n@since 1.1\n@see ModuleSelector",
        "model_generated_comment": "@link DiscoverySelectors::selectModules. @param moduleNames if a module name is null. @formatter:on if the module name must not be null if it isn't null"
    }
]